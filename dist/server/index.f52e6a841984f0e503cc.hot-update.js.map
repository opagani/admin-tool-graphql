{"version":3,"file":"index.f52e6a841984f0e503cc.hot-update.js","sources":["webpack:////Users/opagani/projects/zillowgroup/rentals-js/modules/monitor-node/src/plugins/node-vitals-plugin/nodeVitals.ts","webpack:////Users/opagani/projects/zillowgroup/rentals-js/modules/particles-js-healthcheck/src/index.ts","webpack:////Users/opagani/projects/zillowgroup/rentals-js/modules/particles-js-node-logger/src/pinoLogger.ts","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/@datadog/native-appsec/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/@datadog/native-appsec/lib/loader.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/@datadog/native-appsec/vendor sync ^\\.\\/.*\\/appsec\\.node$","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/@datadog/native-metrics/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/@datadog/pprof/node_modules/pify/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/@datadog/pprof/node_modules/source-map/lib/array-set.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/@datadog/pprof/node_modules/source-map/lib/base64-vlq.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/@datadog/pprof/node_modules/source-map/lib/base64.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/@datadog/pprof/node_modules/source-map/lib/binary-search.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/@datadog/pprof/node_modules/source-map/lib/mapping-list.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/@datadog/pprof/node_modules/source-map/lib/read-wasm.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/@datadog/pprof/node_modules/source-map/lib/source-map-consumer.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/@datadog/pprof/node_modules/source-map/lib/source-map-generator.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/@datadog/pprof/node_modules/source-map/lib/source-node.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/@datadog/pprof/node_modules/source-map/lib/util.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/@datadog/pprof/node_modules/source-map/lib/wasm.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/@datadog/pprof/node_modules/source-map/source-map.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/@datadog/pprof/out/src/heap-profiler-bindings.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/@datadog/pprof/out/src/heap-profiler.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/@datadog/pprof/out/src/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/@datadog/pprof/out/src/profile-encoder.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/@datadog/pprof/out/src/profile-serializer.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/@datadog/pprof/out/src/sourcemapper/sourcemapper.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/@datadog/pprof/out/src/time-profiler-bindings.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/@datadog/pprof/out/src/time-profiler.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/@datadog/pprof/out/third_party/cloud-debug-nodejs/src/agent/io/scanner.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/@datadog/pprof/proto/profile.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/@datadog/sketches-js/dist/ddsketch/DDSketch.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/@datadog/sketches-js/dist/ddsketch/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/@datadog/sketches-js/dist/ddsketch/mapping/CubicallyInterpolatedMapping.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/@datadog/sketches-js/dist/ddsketch/mapping/KeyMapping.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/@datadog/sketches-js/dist/ddsketch/mapping/LinearlyInterpolatedMapping.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/@datadog/sketches-js/dist/ddsketch/mapping/LogarithmicMapping.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/@datadog/sketches-js/dist/ddsketch/mapping/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/@datadog/sketches-js/dist/ddsketch/math.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/@datadog/sketches-js/dist/ddsketch/proto/compiled.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/@datadog/sketches-js/dist/ddsketch/store/CollapsingHighestDenseStore.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/@datadog/sketches-js/dist/ddsketch/store/CollapsingLowestDenseStore.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/@datadog/sketches-js/dist/ddsketch/store/DenseStore.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/@datadog/sketches-js/dist/ddsketch/store/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/@datadog/sketches-js/dist/ddsketch/store/util.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/@datadog/sketches-js/dist/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/@graphql-toolkit/common/node_modules/graphql-tools/index.esm.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/@graphql-toolkit/schema-merging/node_modules/graphql-tools/index.esm.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/crypto-randomuuid/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/crypto-randomuuid/polyfill.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/crypto-randomuuid/validators.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/ext/exporters.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/ext/formats.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/ext/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/ext/kinds.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/ext/priority.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/ext/tags.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/ext/types.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/node_modules/ignore/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/node_modules/retry/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/node_modules/retry/lib/retry.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/node_modules/retry/lib/retry_operation.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/node_modules/semver/semver.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-core/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-core/src/storage/async_hooks.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-core/src/storage/async_resource.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-core/src/storage/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-instrumentations/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-instrumentations/src/amqp10.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-instrumentations/src/amqplib.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-instrumentations/src/bluebird.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-instrumentations/src/bunyan.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-instrumentations/src/cassandra-driver.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-instrumentations/src/couchbase.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-instrumentations/src/cucumber.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-instrumentations/src/dns.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-instrumentations/src/elasticsearch.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-instrumentations/src/generic-pool.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-instrumentations/src/helpers/hook.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-instrumentations/src/helpers/instrument.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-instrumentations/src/helpers/promise.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-instrumentations/src/http.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-instrumentations/src/http/client.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-instrumentations/src/http/server.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-instrumentations/src/ioredis.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-instrumentations/src/memcached.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-instrumentations/src/mocha.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-instrumentations/src/mongodb-core.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-instrumentations/src/mongoose.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-instrumentations/src/mysql.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-instrumentations/src/mysql2.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-instrumentations/src/net.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-instrumentations/src/pg.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-instrumentations/src/pino.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-instrumentations/src/promise-js.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-instrumentations/src/promise.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-instrumentations/src/q.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-instrumentations/src/redis.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-instrumentations/src/rhea.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-instrumentations/src/sharedb.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-instrumentations/src/tedious.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-instrumentations/src/when.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-instrumentations/src/winston.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-amqp10/src/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-amqplib/src/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/helpers.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/services/cloudwatchlogs.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/services/dynamodb.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/services/eventbridge.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/services/kinesis.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/services/lambda.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/services/redshift.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/services/s3.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/services/sns.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/services/sqs.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-bunyan/src/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-cassandra-driver/src/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-connect/src/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-couchbase/src/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-cucumber/src/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-cypress/src/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-dns/src/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-elasticsearch/src/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-express/src/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-fastify/src/fastify.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-fastify/src/find-my-way.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-fastify/src/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-fs/src/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-google-cloud-pubsub/src/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-graphql/src/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-graphql/src/tools/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-graphql/src/tools/signature.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-graphql/src/tools/transforms.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-grpc/src/client.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-grpc/src/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-grpc/src/kinds.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-grpc/src/server.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-grpc/src/util.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-hapi/src/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-hapi/src/route.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-hapi/src/server.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-http/src/client.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-http/src/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-http/src/server.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-http2/src/client.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-http2/src/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-http2/src/server.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-ioredis/src/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-jest/src/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-jest/src/jest-environment.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-jest/src/jest-jasmine2.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-jest/src/util.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-kafkajs/src/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-knex/src/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-koa/src/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-limitd-client/src/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-memcached/src/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-microgateway-core/src/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-mocha/src/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-moleculer/src/client.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-moleculer/src/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-moleculer/src/server.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-moleculer/src/util.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-mongodb-core/src/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-mysql/src/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-mysql2/src/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-net/src/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-next/src/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-oracledb/src/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-paperplane/src/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-pg/src/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-pino/src/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-redis/src/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-restify/src/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-rhea/src/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-router/src/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-sharedb/src/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-tedious/src/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-winston/src/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-shimmer/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-shimmer/src/shimmer.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/lib/version.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/analytics_sampler.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/appsec/addresses.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/appsec/callbacks/ddwaf.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/appsec/callbacks/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/appsec/gateway/als.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/appsec/gateway/channels.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/appsec/gateway/engine/engine.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/appsec/gateway/engine/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/appsec/gateway/engine/runner.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/appsec/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/appsec/reporter.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/appsec/rule_manager.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/ci-visibility/exporters/agentless/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/ci-visibility/exporters/agentless/writer.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/config.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/constants.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/dogstatsd.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/encode/0.4.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/encode/0.5.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/encode/agentless-ci-visibility.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/encode/chunk.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/encode/tags-processors.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/exporter.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/exporters/agent/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/exporters/agent/writer.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/exporters/common/docker.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/exporters/common/request.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/exporters/common/writer.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/exporters/log/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/exporters/scheduler.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/format.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/histogram.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/id.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/iitm.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/instrumenter.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/loader.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/log.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/metrics.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/noop/scope.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/noop/span.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/noop/span_context.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/noop/tracer.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/opentracing/propagation/binary.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/opentracing/propagation/http.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/opentracing/propagation/log.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/opentracing/propagation/text_map.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/opentracing/span.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/opentracing/span_context.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/opentracing/tracer.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/pkg.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/plugin_manager.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/plugins/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/plugins/log_plugin.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/plugins/plugin.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/plugins/util/ci.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/plugins/util/env.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/plugins/util/exec.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/plugins/util/git.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/plugins/util/tags.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/plugins/util/test.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/plugins/util/urlfilter.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/plugins/util/user-provided-git.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/plugins/util/web.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/priority_sampler.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/profiler.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/profiling/config.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/profiling/exporters/agent.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/profiling/exporters/file.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/profiling/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/profiling/loggers/console.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/profiling/profiler.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/profiling/profilers/cpu.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/profiling/profilers/heap.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/profiling/tagger.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/proxy.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/rate_limiter.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/require-package-json.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/ritm.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/sampler.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/scope.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/span_processor.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/startup-log.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/tagger.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/telemetry.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/tracer.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/util.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/delay/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/detect-libc/lib/detect-libc.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/findit2/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/form-data/lib/form_data.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/import-in-the-middle/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/import-in-the-middle/lib/register.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/koalas/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/limiter/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/limiter/lib/clock.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/limiter/lib/rateLimiter.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/limiter/lib/tokenBucket.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/lodash.kebabcase/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/lodash.pick/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/lodash.uniq/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/module-details-from-path/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/node-gyp-build/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/opentracing/lib/binary_carrier.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/opentracing/lib/constants.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/opentracing/lib/ext/tags.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/opentracing/lib/functions.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/opentracing/lib/global_tracer.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/opentracing/lib/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/opentracing/lib/mock_tracer/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/opentracing/lib/mock_tracer/mock_context.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/opentracing/lib/mock_tracer/mock_report.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/opentracing/lib/mock_tracer/mock_span.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/opentracing/lib/mock_tracer/mock_tracer.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/opentracing/lib/noop.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/opentracing/lib/reference.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/opentracing/lib/span.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/opentracing/lib/span_context.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/opentracing/lib/tracer.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/p-limit/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/performance-now/lib/performance-now.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/protobufjs/minimal.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/protobufjs/src/index-minimal.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/protobufjs/src/reader.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/protobufjs/src/reader_buffer.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/protobufjs/src/roots.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/protobufjs/src/rpc.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/protobufjs/src/rpc/service.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/protobufjs/src/util/longbits.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/protobufjs/src/util/minimal.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/protobufjs/src/writer.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/protobufjs/src/writer_buffer.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/split/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/through/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/yocto-queue/index.js","webpack:///external \"child_process\"","webpack:///external \"dgram\"","webpack:///external \"diagnostics_channel\"","webpack:///external \"dns\"","webpack:///external \"v8\""],"sourcesContent":["import os from 'os';\nimport fs from 'fs';\nimport v8 from 'v8';\nimport { constants, PerformanceObserver } from 'perf_hooks';\nimport eventLoopStats from 'event-loop-stats';\nimport type { NodeVitalsPlugin } from '.';\nimport type { PerformanceEntry } from 'perf_hooks';\n\nconst gcFlagMap = {\n  [constants.NODE_PERFORMANCE_GC_MAJOR]: 'MarkSweepCompact',\n  [constants.NODE_PERFORMANCE_GC_MINOR]: 'Scavange',\n  [constants.NODE_PERFORMANCE_GC_INCREMENTAL]: 'IncrementalMarking',\n  [constants.NODE_PERFORMANCE_GC_WEAKCB]: 'ProcessWeakCallbacks',\n};\n\nlet observer: PerformanceObserver;\n\nexport const Bytes = {\n  toKb: (bytes: number) => Math.round(bytes / 1024),\n  toMb: (bytes: number) => Math.round(bytes / 1024 / 1024),\n};\n\nexport default {\n  start({ increment }: NodeVitalsPlugin) {\n    if (increment) {\n      increment({ name: 'App startup', amount: 1 });\n\n      observer = new PerformanceObserver((list) => {\n        list.getEntries().forEach((entry: PerformanceEntry) => {\n          // @ts-ignore the type definition is missing this property\n          const kindFlag = entry.kind;\n          const typeName = `${kindFlag}-${gcFlagMap[kindFlag]}`;\n          const pauseMS = Math.round(entry.duration);\n          increment({ name: 'gc type ' + typeName, amount: 1 });\n          increment({ name: 'gc pause ms', amount: pauseMS });\n          increment({ name: 'gc type ' + typeName + ' pause ms', amount: pauseMS });\n        });\n      });\n\n      observer.observe({\n        entryTypes: ['gc'],\n      });\n    }\n  },\n\n  stop() {\n    observer.disconnect();\n  },\n\n  record({ buildInfo, increment, gauge }: NodeVitalsPlugin) {\n    const serverType = buildInfo.serverType;\n    const loopStats = eventLoopStats.sense();\n\n    if (increment) {\n      increment({ name: 'App heartbeat ' + serverType, amount: 1 });\n      increment({ name: 'App heartbeat type-build ' + serverType + ' ' + buildInfo.buildNumber, amount: 1 });\n      increment({ name: 'App heartbeat type-commit ' + serverType + ' ' + buildInfo.gitCommit, amount: 1 });\n      increment({ name: 'App heartbeat build ' + buildInfo.buildNumber, amount: 1 });\n      increment({ name: 'App heartbeat commit ' + buildInfo.gitCommit, amount: 1 });\n      increment({ name: 'event loops', amount: loopStats.num });\n    }\n\n    if (gauge) {\n      const loadavg = os.loadavg();\n      const loadavgScaler = 1_000; //pontoon rounds to integer, scale for additional precision\n      gauge({ name: 'os load avg 1m', amount: loadavg[0] * loadavgScaler });\n      gauge({ name: 'os load avg 5m', amount: loadavg[1] * loadavgScaler });\n      gauge({ name: 'os load avg 15m', amount: loadavg[2] * loadavgScaler });\n\n      const totalmem = os.totalmem();\n      const freemem = os.freemem();\n      const usedmem = totalmem - freemem;\n      gauge({ name: 'memory total MB', amount: Bytes.toMb(totalmem) });\n      gauge({ name: 'memory free MB', amount: Bytes.toMb(freemem) });\n      gauge({ name: 'memory used MB', amount: Bytes.toMb(usedmem) });\n\n      const memoryUsage = process.memoryUsage();\n      gauge({ name: 'node memory mb rss', amount: Bytes.toMb(memoryUsage.rss) });\n      gauge({ name: 'node memory mb heapTotal', amount: Bytes.toMb(memoryUsage.heapTotal) });\n      gauge({ name: 'node memory mb heapUsed', amount: Bytes.toMb(memoryUsage.heapUsed) });\n      gauge({ name: 'node memory mb external', amount: Bytes.toMb(memoryUsage.external) });\n\n      v8.getHeapSpaceStatistics().forEach(\n        ({ space_name, space_size, space_used_size, space_available_size, physical_space_size }) => {\n          const prefix = 'v8 heap kb ' + space_name + ' ';\n          gauge({ name: prefix + 'space_size', amount: Bytes.toKb(space_size) });\n          gauge({ name: prefix + 'space_used_size', amount: Bytes.toKb(space_used_size) });\n          gauge({ name: prefix + 'space_available_size', amount: Bytes.toKb(space_available_size) });\n          gauge({ name: prefix + 'physical_space_size', amount: Bytes.toKb(physical_space_size) });\n        },\n      );\n\n      gauge({ name: 'event loop ms max', amount: loopStats.max });\n      gauge({ name: 'event loop ms min', amount: loopStats.min });\n      gauge({ name: 'event loop ms avg', amount: loopStats.sum / loopStats.num });\n\n      fs.readFile('/proc/sys/fs/file-nr', (err, out) => {\n        if (!err) {\n          const fileNrParts = out.toString().replace(/\\n/g, '').split(' ');\n          const fileHandles = parseInt(fileNrParts[0], 10);\n          gauge({ name: 'file-nr allocated file handles', amount: fileHandles });\n        }\n      });\n    }\n  },\n};\n","import type { Logger } from '@zg-rentals/particles-js-base-logger';\nimport { Utils } from '@zg-rentals/particles-js-utils';\nimport type express from 'express';\nimport os from 'os';\nimport readPkg from 'read-pkg';\nimport v8 from 'v8';\n\nexport const BAD_SHUTDOWN_TOKEN_MSG = 'invalid shutdown token provided.';\nexport const GOOD_STATUS_CODE = 200;\nexport const SHUTDOWN_STATUS_CODE = 555;\n\nexport interface onPingInterface {\n  hasAccess: boolean;\n  isProtected: boolean;\n  response: { [key: string]: unknown };\n}\n\nexport interface HealthcheckInterface {\n  shutdownToken?: string;\n  accessToken?: string;\n  protectedQueryParams?: Array<string>;\n  onPing?: ({ hasAccess, isProtected, response }: onPingInterface) => unknown;\n  logger?: Logger;\n  buildNumber: string | number;\n  maxMemoryThresholdMb?: number;\n}\n\nexport interface EnvironmentData {\n  node_version: string;\n  NODE_ENV: string;\n  gitCommit: string;\n  gitUsername: string;\n  gitBranch: string;\n  buildDate: string;\n}\n\nexport interface ServerData {\n  host: string;\n  uptime: number;\n  memory_used: NodeJS.MemoryUsage;\n  memory_total: number;\n  memory_free: number;\n  average_load: Array<number>;\n  heap: v8.HeapInfo;\n}\n\nexport interface DependencyMap {\n  [key: string]: string;\n}\n\nexport interface PackageJson {\n  name: string;\n  alias?: string;\n  version?: string;\n  main?: string;\n  module?: string;\n  bin?: string | Record<string, string>;\n  scripts?: Record<string, string>;\n  sideEffects?: boolean;\n  publishConfig?: Record<string, string>;\n  private?: boolean;\n  dependencies?: DependencyMap;\n  devDependencies?: DependencyMap;\n  peerDependencies?: DependencyMap;\n  workspaces?: Array<string>;\n}\n\nexport type ConfidentialData = EnvironmentData & ServerData & Pick<PackageJson, 'dependencies' | 'devDependencies'>;\n\nexport class Healthcheck {\n  shutdownToken?: string;\n  protectedQueryParams: Array<string>;\n  accessToken?: string;\n  isShuttingDown: boolean;\n  logger?: Logger;\n  packageJson: readPkg.NormalizedPackageJson;\n  buildNumber: number;\n  onPing?: ({ hasAccess, isProtected, response }: onPingInterface) => unknown;\n  maxMemoryThresholdMb: number;\n\n  constructor({\n    logger,\n    shutdownToken,\n    accessToken,\n    buildNumber = 0,\n    onPing,\n    protectedQueryParams = ['runscope', 'sonar', 'liveliness', 'site_liveliness'],\n    maxMemoryThresholdMb = 5_120,\n  }: HealthcheckInterface) {\n    this.logger = logger;\n    this.accessToken = accessToken;\n    this.shutdownToken = shutdownToken;\n    this.protectedQueryParams = protectedQueryParams;\n    this.isShuttingDown = false;\n    this.buildNumber = Number(buildNumber);\n    this.setupPm2GracefulExit();\n    this.packageJson = readPkg.sync();\n    this.onPing = onPing;\n    this.maxMemoryThresholdMb = maxMemoryThresholdMb;\n\n    this.logger?.info('instantiating healthcheck');\n  }\n\n  setupPm2GracefulExit = (): void => {\n    if (Utils.isProd() && process && process.send) {\n      this.logger?.debug('setting up pm2 graceful exit');\n\n      process.on('message', (message: { topic?: string; [key: string]: unknown }) => {\n        this.logger?.warn(message, 'healthcheck received a process message');\n\n        const { topic } = message;\n\n        if (topic === 'TRIGGER_SHUTDOWN') {\n          this.isShuttingDown = true;\n        }\n      });\n    }\n  };\n\n  bytesToMb(bytes: number): number {\n    if (bytes === 0) return 0;\n\n    return bytes / 1024 / 1024;\n  }\n\n  getPackageJsonData(): Pick<PackageJson, 'dependencies' | 'devDependencies'> {\n    const data: { dependencies: DependencyMap; devDependencies: DependencyMap } = {\n      dependencies: {},\n      devDependencies: {},\n    };\n\n    const { dependencies = {}, devDependencies = {} } = this.packageJson;\n\n    for (const dependency in dependencies) {\n      if (dependency.startsWith('@zg-rentals/')) {\n        data.dependencies[dependency] = dependencies[dependency];\n      }\n    }\n    for (const dependency in devDependencies) {\n      if (dependency.startsWith('@zg-rentals/')) {\n        data.devDependencies[dependency] = devDependencies[dependency];\n      }\n    }\n\n    return data;\n  }\n\n  getEnvironmentData(): EnvironmentData {\n    return {\n      NODE_ENV: process.env.NODE_ENV || 'development',\n      node_version: process.versions.node,\n      gitCommit: process.env.GIT_COMMIT || '',\n      gitUsername: process.env.GIT_COMMIT_AUTHOR || '',\n      gitBranch: process.env.BRANCH_NAME || '',\n      buildDate: process.env.BUILD_TIME || '',\n    };\n  }\n\n  getServerData(): ServerData {\n    return {\n      host: os.hostname(),\n      uptime: process.uptime(),\n      memory_used: process.memoryUsage(),\n      memory_total: os.totalmem(),\n      memory_free: os.freemem(),\n      average_load: os.loadavg(),\n      heap: v8.getHeapStatistics(),\n    };\n  }\n\n  hasAccess = (req: express.Request): boolean => {\n    if (!this.accessToken) return false;\n\n    if (req.query.accessToken === this.accessToken) return true;\n\n    return false;\n  };\n\n  isMemoryOverloaded(memoryUsage: NodeJS.MemoryUsage): boolean {\n    if (!memoryUsage || !memoryUsage.rss) {\n      return false;\n    }\n\n    const mb = this.bytesToMb(memoryUsage.rss);\n\n    if (mb >= Number(this.maxMemoryThresholdMb)) {\n      return true;\n    }\n\n    return false;\n  }\n\n  aggregateConfidentialData = (req: express.Request): ConfidentialData | undefined => {\n    const data = {\n      ...this.getPackageJsonData(),\n      ...this.getEnvironmentData(),\n      ...this.getServerData(),\n    };\n\n    if (this.isMemoryOverloaded(data.memory_used)) {\n      this.isShuttingDown = true;\n    }\n\n    if (!this.hasAccess(req)) {\n      return;\n    }\n\n    return data;\n  };\n\n  generateBaseResponse(): { name: string; buildNumber: number } {\n    return {\n      name: this.packageJson.name,\n      buildNumber: this.buildNumber,\n    };\n  }\n\n  shouldIgnoreShutdown(req: express.Request): boolean {\n    if (typeof req.query.mode === 'string' && this.protectedQueryParams.includes(req.query.mode)) {\n      return true;\n    }\n\n    return false;\n  }\n\n  getStatusCode = (req: express.Request): number => {\n    if (this.isShuttingDown) {\n      if (this.shouldIgnoreShutdown(req)) {\n        this.logger?.warn(`app is ignoring shutdown mode, returning status code=${GOOD_STATUS_CODE}`);\n        return GOOD_STATUS_CODE;\n      }\n      this.logger?.warn(`app is in shutdown mode, returning status code=${SHUTDOWN_STATUS_CODE}`);\n\n      return SHUTDOWN_STATUS_CODE;\n    } else {\n      return GOOD_STATUS_CODE;\n    }\n  };\n\n  check = (req: express.Request, res: express.Response): void => {\n    try {\n      const confidentialData = this.aggregateConfidentialData(req);\n      const baseResponse = this.generateBaseResponse();\n      const status = this.getStatusCode(req);\n\n      const response = {\n        ...confidentialData,\n        ...baseResponse,\n      };\n\n      if (this.onPing) {\n        res.status(status).json(\n          this.onPing({\n            hasAccess: this.hasAccess(req),\n            isProtected: this.shouldIgnoreShutdown(req),\n            response,\n          }),\n        );\n      } else {\n        res.status(status).json(response);\n      }\n    } catch (err: any) {\n      res.status(500).json({\n        error: err.message,\n        success: false,\n      });\n    }\n  };\n\n  shutdown = (req: express.Request, res: express.Response): void => {\n    const reqShutdownToken = req.query.secretToken;\n    const isNotEmpty = reqShutdownToken !== '';\n    const isDefined = typeof reqShutdownToken !== 'undefined' && typeof this.shutdownToken !== 'undefined';\n\n    if (isDefined && isNotEmpty && reqShutdownToken === this.shutdownToken) {\n      this.isShuttingDown = true;\n      this.logger?.warn('successful shutdownToken received, putting app in shutdown mode');\n\n      res.status(200).json({\n        success: true,\n        statusCode: SHUTDOWN_STATUS_CODE,\n      });\n    } else {\n      this.logger?.warn('incorrect or missing shutdown token');\n\n      res.status(500).json({\n        success: false,\n        error: BAD_SHUTDOWN_TOKEN_MSG,\n      });\n    }\n  };\n}\n","import type { GetLoggerInterface, Logger } from '@zg-rentals/particles-js-base-logger';\nimport { BaseLogger } from '@zg-rentals/particles-js-base-logger';\n\nimport child_process from 'child_process';\nimport fs from 'fs';\nimport path from 'path';\nimport pino from 'pino';\nimport stream from 'stream';\n\nexport interface PinoLoggerInterface extends GetLoggerInterface {\n  logPath?: string;\n  prettyPath?: string;\n  pinoArgs?: pino.LoggerOptions;\n}\nexport class PinoLogger extends BaseLogger<pino.Logger> implements Logger {\n  logger: pino.Logger;\n  prettyLogger?: child_process.ChildProcess;\n  _enableLogSync = true;\n  runtime: 'node';\n\n  constructor({\n    pinoArgs = {},\n    logPath = '',\n    prettyPath = 'node_modules/pino-pretty/bin.js',\n    __reset = () => {},\n  }: PinoLoggerInterface = {}) {\n    super({ __reset, runtime: 'node' });\n\n    this.runtime = 'node';\n\n    const cwd = process.cwd();\n    const logThrough = new stream.PassThrough();\n\n    this.logger = pino(\n      {\n        level: 'info',\n        ...pinoArgs,\n      },\n      logThrough,\n    );\n\n    if (logPath) {\n      logThrough.pipe(fs.createWriteStream(logPath, { flags: 'a' }));\n    }\n\n    if (prettyPath) {\n      const prettyLogger = child_process.spawn(process.execPath, [path.join(process.cwd(), prettyPath), '-c'], {\n        cwd,\n        env: process.env,\n      });\n\n      logThrough.pipe(prettyLogger.stdin);\n\n      prettyLogger.stdout.pipe(process.stdout);\n\n      this.prettyLogger = prettyLogger;\n    } else {\n      logThrough.pipe(process.stdout);\n    }\n  }\n\n  child(name: string, bindings?: pino.Bindings): pino.Logger {\n    if (name.length > 255) {\n      throw new Error(`child logger name length is ${name.length}, must be less than 255`);\n    }\n\n    const logger = this.logger.child({ ...bindings, name });\n\n    this._children.set(name, logger);\n\n    return logger;\n  }\n\n  error(...args: Array<unknown>) {\n    this.logger.error(args);\n  }\n  warn(...args: Array<unknown>) {\n    this.logger.warn(args);\n  }\n  info(...args: Array<unknown>) {\n    this.logger.info(args);\n  }\n  debug(...args: Array<unknown>) {\n    this.logger.debug(args);\n  }\n  trace(...args: Array<unknown>) {\n    this.logger.trace(args);\n  }\n\n  _getChildLogger(name: string) {\n    return this._children.get(name);\n  }\n\n  setChildLogLevel(name: string, level?: string) {\n    const logger = this._getChildLogger(name);\n\n    if (logger) logger.level = level || process.env.LOG_LEVEL || 'warn';\n  }\n}\n","/**\n * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.\n * This product includes software developed at Datadog (https://www.datadoghq.com/). Copyright 2021 Datadog, Inc.\n **/\n'use strict'\nconst { DDWAF } = require('./lib/loader').load()\n\nmodule.exports.DDWAF = DDWAF\n","/**\n * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.\n * This product includes software developed at Datadog (https://www.datadoghq.com/). Copyright 2021 Datadog, Inc.\n **/\n'use strict'\nconst os = require('os')\nconst detectLibc = require('detect-libc')\n\nconst getDir = module.exports.getDir = function () {\n  return `${os.platform()}-${os.arch()}-${detectLibc.family || 'unknown'}`\n}\n\nmodule.exports.load = function () {\n  return require(`../vendor/${getDir()}/appsec.node`)\n}\n","function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = function() { return []; };\nwebpackEmptyContext.resolve = webpackEmptyContext;\nmodule.exports = webpackEmptyContext;\nwebpackEmptyContext.id = \"../../node_modules/@datadog/native-appsec/vendor sync recursive ^\\\\.\\\\/.*\\\\/appsec\\\\.node$\";","'use strict'\n\nconst nativeMetrics = require('node-gyp-build')(__dirname)\n\nmodule.exports = nativeMetrics\n","'use strict';\n\nconst processFn = (fn, options, proxy, unwrapped) => function (...arguments_) {\n\tconst P = options.promiseModule;\n\n\treturn new P((resolve, reject) => {\n\t\tif (options.multiArgs) {\n\t\t\targuments_.push((...result) => {\n\t\t\t\tif (options.errorFirst) {\n\t\t\t\t\tif (result[0]) {\n\t\t\t\t\t\treject(result);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.shift();\n\t\t\t\t\t\tresolve(result);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tresolve(result);\n\t\t\t\t}\n\t\t\t});\n\t\t} else if (options.errorFirst) {\n\t\t\targuments_.push((error, result) => {\n\t\t\t\tif (error) {\n\t\t\t\t\treject(error);\n\t\t\t\t} else {\n\t\t\t\t\tresolve(result);\n\t\t\t\t}\n\t\t\t});\n\t\t} else {\n\t\t\targuments_.push(resolve);\n\t\t}\n\n\t\tconst self = this === proxy ? unwrapped : this;\n\t\tReflect.apply(fn, self, arguments_);\n\t});\n};\n\nconst filterCache = new WeakMap();\n\nmodule.exports = (input, options) => {\n\toptions = {\n\t\texclude: [/.+(?:Sync|Stream)$/],\n\t\terrorFirst: true,\n\t\tpromiseModule: Promise,\n\t\t...options\n\t};\n\n\tconst objectType = typeof input;\n\tif (!(input !== null && (objectType === 'object' || objectType === 'function'))) {\n\t\tthrow new TypeError(`Expected \\`input\\` to be a \\`Function\\` or \\`Object\\`, got \\`${input === null ? 'null' : objectType}\\``);\n\t}\n\n\tconst filter = (target, key) => {\n\t\tlet cached = filterCache.get(target);\n\n\t\tif (!cached) {\n\t\t\tcached = {};\n\t\t\tfilterCache.set(target, cached);\n\t\t}\n\n\t\tif (key in cached) {\n\t\t\treturn cached[key];\n\t\t}\n\n\t\tconst match = pattern => (typeof pattern === 'string' || typeof key === 'symbol') ? key === pattern : pattern.test(key);\n\t\tconst desc = Reflect.getOwnPropertyDescriptor(target, key);\n\t\tconst writableOrConfigurableOwn = (desc === undefined || desc.writable || desc.configurable);\n\t\tconst included = options.include ? options.include.some(match) : !options.exclude.some(match);\n\t\tconst shouldFilter = included && writableOrConfigurableOwn;\n\t\tcached[key] = shouldFilter;\n\t\treturn shouldFilter;\n\t};\n\n\tconst cache = new WeakMap();\n\n\tconst proxy = new Proxy(input, {\n\t\tapply(target, thisArg, args) {\n\t\t\tconst cached = cache.get(target);\n\n\t\t\tif (cached) {\n\t\t\t\treturn Reflect.apply(cached, thisArg, args);\n\t\t\t}\n\n\t\t\tconst pified = options.excludeMain ? target : processFn(target, options, proxy, target);\n\t\t\tcache.set(target, pified);\n\t\t\treturn Reflect.apply(pified, thisArg, args);\n\t\t},\n\n\t\tget(target, key) {\n\t\t\tconst property = target[key];\n\n\t\t\t// eslint-disable-next-line no-use-extend-native/no-use-extend-native\n\t\t\tif (!filter(target, key) || property === Function.prototype[key]) {\n\t\t\t\treturn property;\n\t\t\t}\n\n\t\t\tconst cached = cache.get(property);\n\n\t\t\tif (cached) {\n\t\t\t\treturn cached;\n\t\t\t}\n\n\t\t\tif (typeof property === 'function') {\n\t\t\t\tconst pified = processFn(property, options, proxy, target);\n\t\t\t\tcache.set(property, pified);\n\t\t\t\treturn pified;\n\t\t\t}\n\n\t\t\treturn property;\n\t\t}\n\t});\n\n\treturn proxy;\n};\n","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\n/**\n * A data structure which is a combination of an array and a set. Adding a new\n * member is O(1), testing for membership is O(1), and finding the index of an\n * element is O(1). Removing elements from the set is not supported. Only\n * strings are supported for membership.\n */\nclass ArraySet {\n  constructor() {\n    this._array = [];\n    this._set = new Map();\n  }\n\n  /**\n   * Static method for creating ArraySet instances from an existing array.\n   */\n  static fromArray(aArray, aAllowDuplicates) {\n    const set = new ArraySet();\n    for (let i = 0, len = aArray.length; i < len; i++) {\n      set.add(aArray[i], aAllowDuplicates);\n    }\n    return set;\n  }\n\n  /**\n   * Return how many unique items are in this ArraySet. If duplicates have been\n   * added, than those do not count towards the size.\n   *\n   * @returns Number\n   */\n  size() {\n    return this._set.size;\n  }\n\n  /**\n   * Add the given string to this set.\n   *\n   * @param String aStr\n   */\n  add(aStr, aAllowDuplicates) {\n    const isDuplicate = this.has(aStr);\n    const idx = this._array.length;\n    if (!isDuplicate || aAllowDuplicates) {\n      this._array.push(aStr);\n    }\n    if (!isDuplicate) {\n      this._set.set(aStr, idx);\n    }\n  }\n\n  /**\n   * Is the given string a member of this set?\n   *\n   * @param String aStr\n   */\n  has(aStr) {\n      return this._set.has(aStr);\n  }\n\n  /**\n   * What is the index of the given string in the array?\n   *\n   * @param String aStr\n   */\n  indexOf(aStr) {\n    const idx = this._set.get(aStr);\n    if (idx >= 0) {\n        return idx;\n    }\n    throw new Error('\"' + aStr + '\" is not in the set.');\n  }\n\n  /**\n   * What is the element at the given index?\n   *\n   * @param Number aIdx\n   */\n  at(aIdx) {\n    if (aIdx >= 0 && aIdx < this._array.length) {\n      return this._array[aIdx];\n    }\n    throw new Error(\"No element indexed by \" + aIdx);\n  }\n\n  /**\n   * Returns the array representation of this set (which has the proper indices\n   * indicated by indexOf). Note that this is a copy of the internal array used\n   * for storing the members so that no one can mess with internal state.\n   */\n  toArray() {\n    return this._array.slice();\n  }\n}\nexports.ArraySet = ArraySet;\n","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n *\n * Based on the Base 64 VLQ implementation in Closure Compiler:\n * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java\n *\n * Copyright 2011 The Closure Compiler Authors. All rights reserved.\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *  * Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above\n *    copyright notice, this list of conditions and the following\n *    disclaimer in the documentation and/or other materials provided\n *    with the distribution.\n *  * Neither the name of Google Inc. nor the names of its\n *    contributors may be used to endorse or promote products derived\n *    from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\nconst base64 = require(\"./base64\");\n\n// A single base 64 digit can contain 6 bits of data. For the base 64 variable\n// length quantities we use in the source map spec, the first bit is the sign,\n// the next four bits are the actual value, and the 6th bit is the\n// continuation bit. The continuation bit tells us whether there are more\n// digits in this value following this digit.\n//\n//   Continuation\n//   |    Sign\n//   |    |\n//   V    V\n//   101011\n\nconst VLQ_BASE_SHIFT = 5;\n\n// binary: 100000\nconst VLQ_BASE = 1 << VLQ_BASE_SHIFT;\n\n// binary: 011111\nconst VLQ_BASE_MASK = VLQ_BASE - 1;\n\n// binary: 100000\nconst VLQ_CONTINUATION_BIT = VLQ_BASE;\n\n/**\n * Converts from a two-complement value to a value where the sign bit is\n * placed in the least significant bit.  For example, as decimals:\n *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)\n *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)\n */\nfunction toVLQSigned(aValue) {\n  return aValue < 0\n    ? ((-aValue) << 1) + 1\n    : (aValue << 1) + 0;\n}\n\n/**\n * Converts to a two-complement value from a value where the sign bit is\n * placed in the least significant bit.  For example, as decimals:\n *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1\n *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2\n */\n// eslint-disable-next-line no-unused-vars\nfunction fromVLQSigned(aValue) {\n  const isNegative = (aValue & 1) === 1;\n  const shifted = aValue >> 1;\n  return isNegative\n    ? -shifted\n    : shifted;\n}\n\n/**\n * Returns the base 64 VLQ encoded value.\n */\nexports.encode = function base64VLQ_encode(aValue) {\n  let encoded = \"\";\n  let digit;\n\n  let vlq = toVLQSigned(aValue);\n\n  do {\n    digit = vlq & VLQ_BASE_MASK;\n    vlq >>>= VLQ_BASE_SHIFT;\n    if (vlq > 0) {\n      // There are still more digits in this value, so we must make sure the\n      // continuation bit is marked.\n      digit |= VLQ_CONTINUATION_BIT;\n    }\n    encoded += base64.encode(digit);\n  } while (vlq > 0);\n\n  return encoded;\n};\n","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nconst intToCharMap = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\".split(\"\");\n\n/**\n * Encode an integer in the range of 0 to 63 to a single base 64 digit.\n */\nexports.encode = function(number) {\n  if (0 <= number && number < intToCharMap.length) {\n    return intToCharMap[number];\n  }\n  throw new TypeError(\"Must be between 0 and 63: \" + number);\n};\n","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nexports.GREATEST_LOWER_BOUND = 1;\nexports.LEAST_UPPER_BOUND = 2;\n\n/**\n * Recursive implementation of binary search.\n *\n * @param aLow Indices here and lower do not contain the needle.\n * @param aHigh Indices here and higher do not contain the needle.\n * @param aNeedle The element being searched for.\n * @param aHaystack The non-empty array being searched.\n * @param aCompare Function which takes two elements and returns -1, 0, or 1.\n * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or\n *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the\n *     closest element that is smaller than or greater than the one we are\n *     searching for, respectively, if the exact element cannot be found.\n */\nfunction recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {\n  // This function terminates when one of the following is true:\n  //\n  //   1. We find the exact element we are looking for.\n  //\n  //   2. We did not find the exact element, but we can return the index of\n  //      the next-closest element.\n  //\n  //   3. We did not find the exact element, and there is no next-closest\n  //      element than the one we are searching for, so we return -1.\n  const mid = Math.floor((aHigh - aLow) / 2) + aLow;\n  const cmp = aCompare(aNeedle, aHaystack[mid], true);\n  if (cmp === 0) {\n    // Found the element we are looking for.\n    return mid;\n  } else if (cmp > 0) {\n    // Our needle is greater than aHaystack[mid].\n    if (aHigh - mid > 1) {\n      // The element is in the upper half.\n      return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);\n    }\n\n    // The exact needle element was not found in this haystack. Determine if\n    // we are in termination case (3) or (2) and return the appropriate thing.\n    if (aBias == exports.LEAST_UPPER_BOUND) {\n      return aHigh < aHaystack.length ? aHigh : -1;\n    }\n    return mid;\n  }\n\n  // Our needle is less than aHaystack[mid].\n  if (mid - aLow > 1) {\n    // The element is in the lower half.\n    return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);\n  }\n\n  // we are in termination case (3) or (2) and return the appropriate thing.\n  if (aBias == exports.LEAST_UPPER_BOUND) {\n    return mid;\n  }\n  return aLow < 0 ? -1 : aLow;\n}\n\n/**\n * This is an implementation of binary search which will always try and return\n * the index of the closest element if there is no exact hit. This is because\n * mappings between original and generated line/col pairs are single points,\n * and there is an implicit region between each of them, so a miss just means\n * that you aren't on the very start of a region.\n *\n * @param aNeedle The element you are looking for.\n * @param aHaystack The array that is being searched.\n * @param aCompare A function which takes the needle and an element in the\n *     array and returns -1, 0, or 1 depending on whether the needle is less\n *     than, equal to, or greater than the element, respectively.\n * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or\n *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the\n *     closest element that is smaller than or greater than the one we are\n *     searching for, respectively, if the exact element cannot be found.\n *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.\n */\nexports.search = function search(aNeedle, aHaystack, aCompare, aBias) {\n  if (aHaystack.length === 0) {\n    return -1;\n  }\n\n  let index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack,\n                              aCompare, aBias || exports.GREATEST_LOWER_BOUND);\n  if (index < 0) {\n    return -1;\n  }\n\n  // We have found either the exact element, or the next-closest element than\n  // the one we are searching for. However, there may be more than one such\n  // element. Make sure we always return the smallest of these.\n  while (index - 1 >= 0) {\n    if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {\n      break;\n    }\n    --index;\n  }\n\n  return index;\n};\n","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2014 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nconst util = require(\"./util\");\n\n/**\n * Determine whether mappingB is after mappingA with respect to generated\n * position.\n */\nfunction generatedPositionAfter(mappingA, mappingB) {\n  // Optimized for most common case\n  const lineA = mappingA.generatedLine;\n  const lineB = mappingB.generatedLine;\n  const columnA = mappingA.generatedColumn;\n  const columnB = mappingB.generatedColumn;\n  return lineB > lineA || lineB == lineA && columnB >= columnA ||\n         util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;\n}\n\n/**\n * A data structure to provide a sorted view of accumulated mappings in a\n * performance conscious manner. It trades a negligible overhead in general\n * case for a large speedup in case of mappings being added in order.\n */\nclass MappingList {\n  constructor() {\n    this._array = [];\n    this._sorted = true;\n    // Serves as infimum\n    this._last = {generatedLine: -1, generatedColumn: 0};\n  }\n\n  /**\n   * Iterate through internal items. This method takes the same arguments that\n   * `Array.prototype.forEach` takes.\n   *\n   * NOTE: The order of the mappings is NOT guaranteed.\n   */\n  unsortedForEach(aCallback, aThisArg) {\n    this._array.forEach(aCallback, aThisArg);\n  }\n\n  /**\n   * Add the given source mapping.\n   *\n   * @param Object aMapping\n   */\n  add(aMapping) {\n    if (generatedPositionAfter(this._last, aMapping)) {\n      this._last = aMapping;\n      this._array.push(aMapping);\n    } else {\n      this._sorted = false;\n      this._array.push(aMapping);\n    }\n  }\n\n  /**\n   * Returns the flat, sorted array of mappings. The mappings are sorted by\n   * generated position.\n   *\n   * WARNING: This method returns internal data without copying, for\n   * performance. The return value must NOT be mutated, and should be treated as\n   * an immutable borrow. If you want to take ownership, you must make your own\n   * copy.\n   */\n  toArray() {\n    if (!this._sorted) {\n      this._array.sort(util.compareByGeneratedPositionsInflated);\n      this._sorted = true;\n    }\n    return this._array;\n  }\n}\n\nexports.MappingList = MappingList;\n","if (typeof fetch === \"function\") {\n  // Web version of reading a wasm file into an array buffer.\n\n  let mappingsWasmUrl = null;\n\n  module.exports = function readWasm() {\n    if (typeof mappingsWasmUrl !== \"string\") {\n      throw new Error(\"You must provide the URL of lib/mappings.wasm by calling \" +\n                      \"SourceMapConsumer.initialize({ 'lib/mappings.wasm': ... }) \" +\n                      \"before using SourceMapConsumer\");\n    }\n\n    return fetch(mappingsWasmUrl)\n      .then(response => response.arrayBuffer());\n  };\n\n  module.exports.initialize = url => mappingsWasmUrl = url;\n} else {\n  // Node version of reading a wasm file into an array buffer.\n  const fs = require(\"fs\");\n  const path = require(\"path\");\n\n  module.exports = function readWasm() {\n    return new Promise((resolve, reject) => {\n      const wasmPath = path.join(__dirname, \"mappings.wasm\");\n      fs.readFile(wasmPath, null, (error, data) => {\n        if (error) {\n          reject(error);\n          return;\n        }\n\n        resolve(data.buffer);\n      });\n    });\n  };\n\n  module.exports.initialize = _ => {\n    console.debug(\"SourceMapConsumer.initialize is a no-op when running in node.js\");\n  };\n}\n","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nconst util = require(\"./util\");\nconst binarySearch = require(\"./binary-search\");\nconst ArraySet = require(\"./array-set\").ArraySet;\nconst base64VLQ = require(\"./base64-vlq\"); // eslint-disable-line no-unused-vars\nconst readWasm = require(\"../lib/read-wasm\");\nconst wasm = require(\"./wasm\");\n\nconst INTERNAL = Symbol(\"smcInternal\");\n\nclass SourceMapConsumer {\n  constructor(aSourceMap, aSourceMapURL) {\n    // If the constructor was called by super(), just return Promise<this>.\n    // Yes, this is a hack to retain the pre-existing API of the base-class\n    // constructor also being an async factory function.\n    if (aSourceMap == INTERNAL) {\n      return Promise.resolve(this);\n    }\n\n    return _factory(aSourceMap, aSourceMapURL);\n  }\n\n  static initialize(opts) {\n    readWasm.initialize(opts[\"lib/mappings.wasm\"]);\n  }\n\n  static fromSourceMap(aSourceMap, aSourceMapURL) {\n    return _factoryBSM(aSourceMap, aSourceMapURL);\n  }\n\n  /**\n   * Construct a new `SourceMapConsumer` from `rawSourceMap` and `sourceMapUrl`\n   * (see the `SourceMapConsumer` constructor for details. Then, invoke the `async\n   * function f(SourceMapConsumer) -> T` with the newly constructed consumer, wait\n   * for `f` to complete, call `destroy` on the consumer, and return `f`'s return\n   * value.\n   *\n   * You must not use the consumer after `f` completes!\n   *\n   * By using `with`, you do not have to remember to manually call `destroy` on\n   * the consumer, since it will be called automatically once `f` completes.\n   *\n   * ```js\n   * const xSquared = await SourceMapConsumer.with(\n   *   myRawSourceMap,\n   *   null,\n   *   async function (consumer) {\n   *     // Use `consumer` inside here and don't worry about remembering\n   *     // to call `destroy`.\n   *\n   *     const x = await whatever(consumer);\n   *     return x * x;\n   *   }\n   * );\n   *\n   * // You may not use that `consumer` anymore out here; it has\n   * // been destroyed. But you can use `xSquared`.\n   * console.log(xSquared);\n   * ```\n   */\n  static with(rawSourceMap, sourceMapUrl, f) {\n    // Note: The `acorn` version that `webpack` currently depends on doesn't\n    // support `async` functions, and the nodes that we support don't all have\n    // `.finally`. Therefore, this is written a bit more convolutedly than it\n    // should really be.\n\n    let consumer = null;\n    const promise = new SourceMapConsumer(rawSourceMap, sourceMapUrl);\n    return promise\n      .then(c => {\n        consumer = c;\n        return f(c);\n      })\n      .then(x => {\n        if (consumer) {\n          consumer.destroy();\n        }\n        return x;\n      }, e => {\n        if (consumer) {\n          consumer.destroy();\n        }\n        throw e;\n      });\n  }\n\n  /**\n   * Parse the mappings in a string in to a data structure which we can easily\n   * query (the ordered arrays in the `this.__generatedMappings` and\n   * `this.__originalMappings` properties).\n   */\n  _parseMappings(aStr, aSourceRoot) {\n    throw new Error(\"Subclasses must implement _parseMappings\");\n  }\n\n  /**\n   * Iterate over each mapping between an original source/line/column and a\n   * generated line/column in this source map.\n   *\n   * @param Function aCallback\n   *        The function that is called with each mapping.\n   * @param Object aContext\n   *        Optional. If specified, this object will be the value of `this` every\n   *        time that `aCallback` is called.\n   * @param aOrder\n   *        Either `SourceMapConsumer.GENERATED_ORDER` or\n   *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to\n   *        iterate over the mappings sorted by the generated file's line/column\n   *        order or the original's source/line/column order, respectively. Defaults to\n   *        `SourceMapConsumer.GENERATED_ORDER`.\n   */\n  eachMapping(aCallback, aContext, aOrder) {\n    throw new Error(\"Subclasses must implement eachMapping\");\n  }\n\n  /**\n   * Returns all generated line and column information for the original source,\n   * line, and column provided. If no column is provided, returns all mappings\n   * corresponding to a either the line we are searching for or the next\n   * closest line that has any mappings. Otherwise, returns all mappings\n   * corresponding to the given line and either the column we are searching for\n   * or the next closest column that has any offsets.\n   *\n   * The only argument is an object with the following properties:\n   *\n   *   - source: The filename of the original source.\n   *   - line: The line number in the original source.  The line number is 1-based.\n   *   - column: Optional. the column number in the original source.\n   *    The column number is 0-based.\n   *\n   * and an array of objects is returned, each with the following properties:\n   *\n   *   - line: The line number in the generated source, or null.  The\n   *    line number is 1-based.\n   *   - column: The column number in the generated source, or null.\n   *    The column number is 0-based.\n   */\n  allGeneratedPositionsFor(aArgs) {\n    throw new Error(\"Subclasses must implement allGeneratedPositionsFor\");\n  }\n\n  destroy() {\n    throw new Error(\"Subclasses must implement destroy\");\n  }\n}\n\n/**\n * The version of the source mapping spec that we are consuming.\n */\nSourceMapConsumer.prototype._version = 3;\nSourceMapConsumer.GENERATED_ORDER = 1;\nSourceMapConsumer.ORIGINAL_ORDER = 2;\n\nSourceMapConsumer.GREATEST_LOWER_BOUND = 1;\nSourceMapConsumer.LEAST_UPPER_BOUND = 2;\n\nexports.SourceMapConsumer = SourceMapConsumer;\n\n/**\n * A BasicSourceMapConsumer instance represents a parsed source map which we can\n * query for information about the original file positions by giving it a file\n * position in the generated source.\n *\n * The first parameter is the raw source map (either as a JSON string, or\n * already parsed to an object). According to the spec, source maps have the\n * following attributes:\n *\n *   - version: Which version of the source map spec this map is following.\n *   - sources: An array of URLs to the original source files.\n *   - names: An array of identifiers which can be referenced by individual mappings.\n *   - sourceRoot: Optional. The URL root from which all sources are relative.\n *   - sourcesContent: Optional. An array of contents of the original source files.\n *   - mappings: A string of base64 VLQs which contain the actual mappings.\n *   - file: Optional. The generated file this source map is associated with.\n *\n * Here is an example source map, taken from the source map spec[0]:\n *\n *     {\n *       version : 3,\n *       file: \"out.js\",\n *       sourceRoot : \"\",\n *       sources: [\"foo.js\", \"bar.js\"],\n *       names: [\"src\", \"maps\", \"are\", \"fun\"],\n *       mappings: \"AA,AB;;ABCDE;\"\n *     }\n *\n * The second parameter, if given, is a string whose value is the URL\n * at which the source map was found.  This URL is used to compute the\n * sources array.\n *\n * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#\n */\nclass BasicSourceMapConsumer extends SourceMapConsumer {\n  constructor(aSourceMap, aSourceMapURL) {\n    return super(INTERNAL).then(that => {\n      let sourceMap = aSourceMap;\n      if (typeof aSourceMap === \"string\") {\n        sourceMap = util.parseSourceMapInput(aSourceMap);\n      }\n\n      const version = util.getArg(sourceMap, \"version\");\n      let sources = util.getArg(sourceMap, \"sources\");\n      // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which\n      // requires the array) to play nice here.\n      const names = util.getArg(sourceMap, \"names\", []);\n      let sourceRoot = util.getArg(sourceMap, \"sourceRoot\", null);\n      const sourcesContent = util.getArg(sourceMap, \"sourcesContent\", null);\n      const mappings = util.getArg(sourceMap, \"mappings\");\n      const file = util.getArg(sourceMap, \"file\", null);\n\n      // Once again, Sass deviates from the spec and supplies the version as a\n      // string rather than a number, so we use loose equality checking here.\n      if (version != that._version) {\n        throw new Error(\"Unsupported version: \" + version);\n      }\n\n      if (sourceRoot) {\n        sourceRoot = util.normalize(sourceRoot);\n      }\n\n      sources = sources\n        .map(String)\n        // Some source maps produce relative source paths like \"./foo.js\" instead of\n        // \"foo.js\".  Normalize these first so that future comparisons will succeed.\n        // See bugzil.la/1090768.\n        .map(util.normalize)\n        // Always ensure that absolute sources are internally stored relative to\n        // the source root, if the source root is absolute. Not doing this would\n        // be particularly problematic when the source root is a prefix of the\n        // source (valid, but why??). See github issue #199 and bugzil.la/1188982.\n        .map(function(source) {\n          return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source)\n            ? util.relative(sourceRoot, source)\n            : source;\n        });\n\n      // Pass `true` below to allow duplicate names and sources. While source maps\n      // are intended to be compressed and deduplicated, the TypeScript compiler\n      // sometimes generates source maps with duplicates in them. See Github issue\n      // #72 and bugzil.la/889492.\n      that._names = ArraySet.fromArray(names.map(String), true);\n      that._sources = ArraySet.fromArray(sources, true);\n\n      that._absoluteSources = that._sources.toArray().map(function(s) {\n        return util.computeSourceURL(sourceRoot, s, aSourceMapURL);\n      });\n\n      that.sourceRoot = sourceRoot;\n      that.sourcesContent = sourcesContent;\n      that._mappings = mappings;\n      that._sourceMapURL = aSourceMapURL;\n      that.file = file;\n\n      that._computedColumnSpans = false;\n      that._mappingsPtr = 0;\n      that._wasm = null;\n\n      return wasm().then(w => {\n        that._wasm = w;\n        return that;\n      });\n    });\n  }\n\n  /**\n   * Utility function to find the index of a source.  Returns -1 if not\n   * found.\n   */\n  _findSourceIndex(aSource) {\n    let relativeSource = aSource;\n    if (this.sourceRoot != null) {\n      relativeSource = util.relative(this.sourceRoot, relativeSource);\n    }\n\n    if (this._sources.has(relativeSource)) {\n      return this._sources.indexOf(relativeSource);\n    }\n\n    // Maybe aSource is an absolute URL as returned by |sources|.  In\n    // this case we can't simply undo the transform.\n    for (let i = 0; i < this._absoluteSources.length; ++i) {\n      if (this._absoluteSources[i] == aSource) {\n        return i;\n      }\n    }\n\n    return -1;\n  }\n\n  /**\n   * Create a BasicSourceMapConsumer from a SourceMapGenerator.\n   *\n   * @param SourceMapGenerator aSourceMap\n   *        The source map that will be consumed.\n   * @param String aSourceMapURL\n   *        The URL at which the source map can be found (optional)\n   * @returns BasicSourceMapConsumer\n   */\n  static fromSourceMap(aSourceMap, aSourceMapURL) {\n    return new BasicSourceMapConsumer(aSourceMap.toString());\n  }\n\n  get sources() {\n    return this._absoluteSources.slice();\n  }\n\n  _getMappingsPtr() {\n    if (this._mappingsPtr === 0) {\n      this._parseMappings(this._mappings, this.sourceRoot);\n    }\n\n    return this._mappingsPtr;\n  }\n\n  /**\n   * Parse the mappings in a string in to a data structure which we can easily\n   * query (the ordered arrays in the `this.__generatedMappings` and\n   * `this.__originalMappings` properties).\n   */\n  _parseMappings(aStr, aSourceRoot) {\n    const size = aStr.length;\n\n    const mappingsBufPtr = this._wasm.exports.allocate_mappings(size);\n    const mappingsBuf = new Uint8Array(this._wasm.exports.memory.buffer, mappingsBufPtr, size);\n    for (let i = 0; i < size; i++) {\n      mappingsBuf[i] = aStr.charCodeAt(i);\n    }\n\n    const mappingsPtr = this._wasm.exports.parse_mappings(mappingsBufPtr);\n\n    if (!mappingsPtr) {\n      const error = this._wasm.exports.get_last_error();\n      let msg = `Error parsing mappings (code ${error}): `;\n\n      // XXX: keep these error codes in sync with `fitzgen/source-map-mappings`.\n      switch (error) {\n        case 1:\n          msg += \"the mappings contained a negative line, column, source index, or name index\";\n          break;\n        case 2:\n          msg += \"the mappings contained a number larger than 2**32\";\n          break;\n        case 3:\n          msg += \"reached EOF while in the middle of parsing a VLQ\";\n          break;\n        case 4:\n          msg += \"invalid base 64 character while parsing a VLQ\";\n          break;\n        default:\n          msg += \"unknown error code\";\n          break;\n      }\n\n      throw new Error(msg);\n    }\n\n    this._mappingsPtr = mappingsPtr;\n  }\n\n  eachMapping(aCallback, aContext, aOrder) {\n    const context = aContext || null;\n    const order = aOrder || SourceMapConsumer.GENERATED_ORDER;\n    const sourceRoot = this.sourceRoot;\n\n    this._wasm.withMappingCallback(\n      mapping => {\n        if (mapping.source !== null) {\n          mapping.source = this._sources.at(mapping.source);\n          mapping.source = util.computeSourceURL(sourceRoot, mapping.source, this._sourceMapURL);\n\n          if (mapping.name !== null) {\n            mapping.name = this._names.at(mapping.name);\n          }\n        }\n\n        aCallback.call(context, mapping);\n      },\n      () => {\n        switch (order) {\n        case SourceMapConsumer.GENERATED_ORDER:\n          this._wasm.exports.by_generated_location(this._getMappingsPtr());\n          break;\n        case SourceMapConsumer.ORIGINAL_ORDER:\n          this._wasm.exports.by_original_location(this._getMappingsPtr());\n          break;\n        default:\n          throw new Error(\"Unknown order of iteration.\");\n        }\n      }\n    );\n  }\n\n  allGeneratedPositionsFor(aArgs) {\n    let source = util.getArg(aArgs, \"source\");\n    const originalLine = util.getArg(aArgs, \"line\");\n    const originalColumn = aArgs.column || 0;\n\n    source = this._findSourceIndex(source);\n    if (source < 0) {\n      return [];\n    }\n\n    if (originalLine < 1) {\n      throw new Error(\"Line numbers must be >= 1\");\n    }\n\n    if (originalColumn < 0) {\n      throw new Error(\"Column numbers must be >= 0\");\n    }\n\n    const mappings = [];\n\n    this._wasm.withMappingCallback(\n      m => {\n        let lastColumn = m.lastGeneratedColumn;\n        if (this._computedColumnSpans && lastColumn === null) {\n          lastColumn = Infinity;\n        }\n        mappings.push({\n          line: m.generatedLine,\n          column: m.generatedColumn,\n          lastColumn,\n        });\n      }, () => {\n        this._wasm.exports.all_generated_locations_for(\n          this._getMappingsPtr(),\n          source,\n          originalLine - 1,\n          \"column\" in aArgs,\n          originalColumn\n        );\n      }\n    );\n\n    return mappings;\n  }\n\n  destroy() {\n    if (this._mappingsPtr !== 0) {\n      this._wasm.exports.free_mappings(this._mappingsPtr);\n      this._mappingsPtr = 0;\n    }\n  }\n\n  /**\n   * Compute the last column for each generated mapping. The last column is\n   * inclusive.\n   */\n  computeColumnSpans() {\n    if (this._computedColumnSpans) {\n      return;\n    }\n\n    this._wasm.exports.compute_column_spans(this._getMappingsPtr());\n    this._computedColumnSpans = true;\n  }\n\n  /**\n   * Returns the original source, line, and column information for the generated\n   * source's line and column positions provided. The only argument is an object\n   * with the following properties:\n   *\n   *   - line: The line number in the generated source.  The line number\n   *     is 1-based.\n   *   - column: The column number in the generated source.  The column\n   *     number is 0-based.\n   *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or\n   *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the\n   *     closest element that is smaller than or greater than the one we are\n   *     searching for, respectively, if the exact element cannot be found.\n   *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.\n   *\n   * and an object is returned with the following properties:\n   *\n   *   - source: The original source file, or null.\n   *   - line: The line number in the original source, or null.  The\n   *     line number is 1-based.\n   *   - column: The column number in the original source, or null.  The\n   *     column number is 0-based.\n   *   - name: The original identifier, or null.\n   */\n  originalPositionFor(aArgs) {\n    const needle = {\n      generatedLine: util.getArg(aArgs, \"line\"),\n      generatedColumn: util.getArg(aArgs, \"column\")\n    };\n\n    if (needle.generatedLine < 1) {\n      throw new Error(\"Line numbers must be >= 1\");\n    }\n\n    if (needle.generatedColumn < 0) {\n      throw new Error(\"Column numbers must be >= 0\");\n    }\n\n    let bias = util.getArg(aArgs, \"bias\", SourceMapConsumer.GREATEST_LOWER_BOUND);\n    if (bias == null) {\n      bias = SourceMapConsumer.GREATEST_LOWER_BOUND;\n    }\n\n    let mapping;\n    this._wasm.withMappingCallback(m => mapping = m, () => {\n      this._wasm.exports.original_location_for(\n        this._getMappingsPtr(),\n        needle.generatedLine - 1,\n        needle.generatedColumn,\n        bias\n      );\n    });\n\n    if (mapping) {\n      if (mapping.generatedLine === needle.generatedLine) {\n        let source = util.getArg(mapping, \"source\", null);\n        if (source !== null) {\n          source = this._sources.at(source);\n          source = util.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);\n        }\n\n        let name = util.getArg(mapping, \"name\", null);\n        if (name !== null) {\n          name = this._names.at(name);\n        }\n\n        return {\n          source,\n          line: util.getArg(mapping, \"originalLine\", null),\n          column: util.getArg(mapping, \"originalColumn\", null),\n          name\n        };\n      }\n    }\n\n    return {\n      source: null,\n      line: null,\n      column: null,\n      name: null\n    };\n  }\n\n  /**\n   * Return true if we have the source content for every source in the source\n   * map, false otherwise.\n   */\n  hasContentsOfAllSources() {\n    if (!this.sourcesContent) {\n      return false;\n    }\n    return this.sourcesContent.length >= this._sources.size() &&\n      !this.sourcesContent.some(function(sc) { return sc == null; });\n  }\n\n  /**\n   * Returns the original source content. The only argument is the url of the\n   * original source file. Returns null if no original source content is\n   * available.\n   */\n  sourceContentFor(aSource, nullOnMissing) {\n    if (!this.sourcesContent) {\n      return null;\n    }\n\n    const index = this._findSourceIndex(aSource);\n    if (index >= 0) {\n      return this.sourcesContent[index];\n    }\n\n    let relativeSource = aSource;\n    if (this.sourceRoot != null) {\n      relativeSource = util.relative(this.sourceRoot, relativeSource);\n    }\n\n    let url;\n    if (this.sourceRoot != null\n        && (url = util.urlParse(this.sourceRoot))) {\n      // XXX: file:// URIs and absolute paths lead to unexpected behavior for\n      // many users. We can help them out when they expect file:// URIs to\n      // behave like it would if they were running a local HTTP server. See\n      // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.\n      const fileUriAbsPath = relativeSource.replace(/^file:\\/\\//, \"\");\n      if (url.scheme == \"file\"\n          && this._sources.has(fileUriAbsPath)) {\n        return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];\n      }\n\n      if ((!url.path || url.path == \"/\")\n          && this._sources.has(\"/\" + relativeSource)) {\n        return this.sourcesContent[this._sources.indexOf(\"/\" + relativeSource)];\n      }\n    }\n\n    // This function is used recursively from\n    // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we\n    // don't want to throw if we can't find the source - we just want to\n    // return null, so we provide a flag to exit gracefully.\n    if (nullOnMissing) {\n      return null;\n    }\n\n    throw new Error('\"' + relativeSource + '\" is not in the SourceMap.');\n  }\n\n  /**\n   * Returns the generated line and column information for the original source,\n   * line, and column positions provided. The only argument is an object with\n   * the following properties:\n   *\n   *   - source: The filename of the original source.\n   *   - line: The line number in the original source.  The line number\n   *     is 1-based.\n   *   - column: The column number in the original source.  The column\n   *     number is 0-based.\n   *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or\n   *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the\n   *     closest element that is smaller than or greater than the one we are\n   *     searching for, respectively, if the exact element cannot be found.\n   *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.\n   *\n   * and an object is returned with the following properties:\n   *\n   *   - line: The line number in the generated source, or null.  The\n   *     line number is 1-based.\n   *   - column: The column number in the generated source, or null.\n   *     The column number is 0-based.\n   */\n  generatedPositionFor(aArgs) {\n    let source = util.getArg(aArgs, \"source\");\n    source = this._findSourceIndex(source);\n    if (source < 0) {\n      return {\n        line: null,\n        column: null,\n        lastColumn: null\n      };\n    }\n\n    const needle = {\n      source,\n      originalLine: util.getArg(aArgs, \"line\"),\n      originalColumn: util.getArg(aArgs, \"column\")\n    };\n\n    if (needle.originalLine < 1) {\n      throw new Error(\"Line numbers must be >= 1\");\n    }\n\n    if (needle.originalColumn < 0) {\n      throw new Error(\"Column numbers must be >= 0\");\n    }\n\n    let bias = util.getArg(aArgs, \"bias\", SourceMapConsumer.GREATEST_LOWER_BOUND);\n    if (bias == null) {\n      bias = SourceMapConsumer.GREATEST_LOWER_BOUND;\n    }\n\n    let mapping;\n    this._wasm.withMappingCallback(m => mapping = m, () => {\n      this._wasm.exports.generated_location_for(\n        this._getMappingsPtr(),\n        needle.source,\n        needle.originalLine - 1,\n        needle.originalColumn,\n        bias\n      );\n    });\n\n    if (mapping) {\n      if (mapping.source === needle.source) {\n        let lastColumn = mapping.lastGeneratedColumn;\n        if (this._computedColumnSpans && lastColumn === null) {\n          lastColumn = Infinity;\n        }\n        return {\n          line: util.getArg(mapping, \"generatedLine\", null),\n          column: util.getArg(mapping, \"generatedColumn\", null),\n          lastColumn,\n        };\n      }\n    }\n\n    return {\n      line: null,\n      column: null,\n      lastColumn: null\n    };\n  }\n}\n\nBasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;\nexports.BasicSourceMapConsumer = BasicSourceMapConsumer;\n\n/**\n * An IndexedSourceMapConsumer instance represents a parsed source map which\n * we can query for information. It differs from BasicSourceMapConsumer in\n * that it takes \"indexed\" source maps (i.e. ones with a \"sections\" field) as\n * input.\n *\n * The first parameter is a raw source map (either as a JSON string, or already\n * parsed to an object). According to the spec for indexed source maps, they\n * have the following attributes:\n *\n *   - version: Which version of the source map spec this map is following.\n *   - file: Optional. The generated file this source map is associated with.\n *   - sections: A list of section definitions.\n *\n * Each value under the \"sections\" field has two fields:\n *   - offset: The offset into the original specified at which this section\n *       begins to apply, defined as an object with a \"line\" and \"column\"\n *       field.\n *   - map: A source map definition. This source map could also be indexed,\n *       but doesn't have to be.\n *\n * Instead of the \"map\" field, it's also possible to have a \"url\" field\n * specifying a URL to retrieve a source map from, but that's currently\n * unsupported.\n *\n * Here's an example source map, taken from the source map spec[0], but\n * modified to omit a section which uses the \"url\" field.\n *\n *  {\n *    version : 3,\n *    file: \"app.js\",\n *    sections: [{\n *      offset: {line:100, column:10},\n *      map: {\n *        version : 3,\n *        file: \"section.js\",\n *        sources: [\"foo.js\", \"bar.js\"],\n *        names: [\"src\", \"maps\", \"are\", \"fun\"],\n *        mappings: \"AAAA,E;;ABCDE;\"\n *      }\n *    }],\n *  }\n *\n * The second parameter, if given, is a string whose value is the URL\n * at which the source map was found.  This URL is used to compute the\n * sources array.\n *\n * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt\n */\nclass IndexedSourceMapConsumer extends SourceMapConsumer {\n  constructor(aSourceMap, aSourceMapURL) {\n    return super(INTERNAL).then(that => {\n      let sourceMap = aSourceMap;\n      if (typeof aSourceMap === \"string\") {\n        sourceMap = util.parseSourceMapInput(aSourceMap);\n      }\n\n      const version = util.getArg(sourceMap, \"version\");\n      const sections = util.getArg(sourceMap, \"sections\");\n\n      if (version != that._version) {\n        throw new Error(\"Unsupported version: \" + version);\n      }\n\n      that._sources = new ArraySet();\n      that._names = new ArraySet();\n      that.__generatedMappings = null;\n      that.__originalMappings = null;\n      that.__generatedMappingsUnsorted = null;\n      that.__originalMappingsUnsorted = null;\n\n      let lastOffset = {\n        line: -1,\n        column: 0\n      };\n      return Promise.all(sections.map(s => {\n        if (s.url) {\n          // The url field will require support for asynchronicity.\n          // See https://github.com/mozilla/source-map/issues/16\n          throw new Error(\"Support for url field in sections not implemented.\");\n        }\n        const offset = util.getArg(s, \"offset\");\n        const offsetLine = util.getArg(offset, \"line\");\n        const offsetColumn = util.getArg(offset, \"column\");\n\n        if (offsetLine < lastOffset.line ||\n            (offsetLine === lastOffset.line && offsetColumn < lastOffset.column)) {\n          throw new Error(\"Section offsets must be ordered and non-overlapping.\");\n        }\n        lastOffset = offset;\n\n        const cons = new SourceMapConsumer(util.getArg(s, \"map\"), aSourceMapURL);\n        return cons.then(consumer => {\n          return {\n            generatedOffset: {\n              // The offset fields are 0-based, but we use 1-based indices when\n              // encoding/decoding from VLQ.\n              generatedLine: offsetLine + 1,\n              generatedColumn: offsetColumn + 1\n            },\n            consumer\n          };\n        });\n      })).then(s => {\n        that._sections = s;\n        return that;\n      });\n    });\n  }\n\n  // `__generatedMappings` and `__originalMappings` are arrays that hold the\n  // parsed mapping coordinates from the source map's \"mappings\" attribute. They\n  // are lazily instantiated, accessed via the `_generatedMappings` and\n  // `_originalMappings` getters respectively, and we only parse the mappings\n  // and create these arrays once queried for a source location. We jump through\n  // these hoops because there can be many thousands of mappings, and parsing\n  // them is expensive, so we only want to do it if we must.\n  //\n  // Each object in the arrays is of the form:\n  //\n  //     {\n  //       generatedLine: The line number in the generated code,\n  //       generatedColumn: The column number in the generated code,\n  //       source: The path to the original source file that generated this\n  //               chunk of code,\n  //       originalLine: The line number in the original source that\n  //                     corresponds to this chunk of generated code,\n  //       originalColumn: The column number in the original source that\n  //                       corresponds to this chunk of generated code,\n  //       name: The name of the original symbol which generated this chunk of\n  //             code.\n  //     }\n  //\n  // All properties except for `generatedLine` and `generatedColumn` can be\n  // `null`.\n  //\n  // `_generatedMappings` is ordered by the generated positions.\n  //\n  // `_originalMappings` is ordered by the original positions.\n  get _generatedMappings() {\n    if (!this.__generatedMappings) {\n      this._sortGeneratedMappings();\n    }\n\n    return this.__generatedMappings;\n  }\n\n  get _originalMappings() {\n    if (!this.__originalMappings) {\n      this._sortOriginalMappings();\n    }\n\n    return this.__originalMappings;\n  }\n\n  get _generatedMappingsUnsorted() {\n    if (!this.__generatedMappingsUnsorted) {\n      this._parseMappings(this._mappings, this.sourceRoot);\n    }\n\n    return this.__generatedMappingsUnsorted;\n  }\n\n  get _originalMappingsUnsorted() {\n    if (!this.__originalMappingsUnsorted) {\n      this._parseMappings(this._mappings, this.sourceRoot);\n    }\n\n    return this.__originalMappingsUnsorted;\n  }\n\n  _sortGeneratedMappings() {\n    const mappings = this._generatedMappingsUnsorted;\n    mappings.sort(util.compareByGeneratedPositionsDeflated);\n    this.__generatedMappings = mappings;\n  }\n\n  _sortOriginalMappings() {\n    const mappings = this._originalMappingsUnsorted;\n    mappings.sort(util.compareByOriginalPositions);\n    this.__originalMappings = mappings;\n  }\n\n  /**\n   * The list of original sources.\n   */\n  get sources() {\n    const sources = [];\n    for (let i = 0; i < this._sections.length; i++) {\n      for (let j = 0; j < this._sections[i].consumer.sources.length; j++) {\n        sources.push(this._sections[i].consumer.sources[j]);\n      }\n    }\n    return sources;\n  }\n\n  /**\n   * Returns the original source, line, and column information for the generated\n   * source's line and column positions provided. The only argument is an object\n   * with the following properties:\n   *\n   *   - line: The line number in the generated source.  The line number\n   *     is 1-based.\n   *   - column: The column number in the generated source.  The column\n   *     number is 0-based.\n   *\n   * and an object is returned with the following properties:\n   *\n   *   - source: The original source file, or null.\n   *   - line: The line number in the original source, or null.  The\n   *     line number is 1-based.\n   *   - column: The column number in the original source, or null.  The\n   *     column number is 0-based.\n   *   - name: The original identifier, or null.\n   */\n  originalPositionFor(aArgs) {\n    const needle = {\n      generatedLine: util.getArg(aArgs, \"line\"),\n      generatedColumn: util.getArg(aArgs, \"column\")\n    };\n\n    // Find the section containing the generated position we're trying to map\n    // to an original position.\n    const sectionIndex = binarySearch.search(needle, this._sections,\n      function(aNeedle, section) {\n        const cmp = aNeedle.generatedLine - section.generatedOffset.generatedLine;\n        if (cmp) {\n          return cmp;\n        }\n\n        return (aNeedle.generatedColumn -\n                section.generatedOffset.generatedColumn);\n      });\n    const section = this._sections[sectionIndex];\n\n    if (!section) {\n      return {\n        source: null,\n        line: null,\n        column: null,\n        name: null\n      };\n    }\n\n    return section.consumer.originalPositionFor({\n      line: needle.generatedLine -\n        (section.generatedOffset.generatedLine - 1),\n      column: needle.generatedColumn -\n        (section.generatedOffset.generatedLine === needle.generatedLine\n         ? section.generatedOffset.generatedColumn - 1\n         : 0),\n      bias: aArgs.bias\n    });\n  }\n\n  /**\n   * Return true if we have the source content for every source in the source\n   * map, false otherwise.\n   */\n  hasContentsOfAllSources() {\n    return this._sections.every(function(s) {\n      return s.consumer.hasContentsOfAllSources();\n    });\n  }\n\n  /**\n   * Returns the original source content. The only argument is the url of the\n   * original source file. Returns null if no original source content is\n   * available.\n   */\n  sourceContentFor(aSource, nullOnMissing) {\n    for (let i = 0; i < this._sections.length; i++) {\n      const section = this._sections[i];\n\n      const content = section.consumer.sourceContentFor(aSource, true);\n      if (content) {\n        return content;\n      }\n    }\n    if (nullOnMissing) {\n      return null;\n    }\n    throw new Error('\"' + aSource + '\" is not in the SourceMap.');\n  }\n\n  /**\n   * Returns the generated line and column information for the original source,\n   * line, and column positions provided. The only argument is an object with\n   * the following properties:\n   *\n   *   - source: The filename of the original source.\n   *   - line: The line number in the original source.  The line number\n   *     is 1-based.\n   *   - column: The column number in the original source.  The column\n   *     number is 0-based.\n   *\n   * and an object is returned with the following properties:\n   *\n   *   - line: The line number in the generated source, or null.  The\n   *     line number is 1-based.\n   *   - column: The column number in the generated source, or null.\n   *     The column number is 0-based.\n   */\n  generatedPositionFor(aArgs) {\n    for (let i = 0; i < this._sections.length; i++) {\n      const section = this._sections[i];\n\n      // Only consider this section if the requested source is in the list of\n      // sources of the consumer.\n      if (section.consumer._findSourceIndex(util.getArg(aArgs, \"source\")) === -1) {\n        continue;\n      }\n      const generatedPosition = section.consumer.generatedPositionFor(aArgs);\n      if (generatedPosition) {\n        const ret = {\n          line: generatedPosition.line +\n            (section.generatedOffset.generatedLine - 1),\n          column: generatedPosition.column +\n            (section.generatedOffset.generatedLine === generatedPosition.line\n             ? section.generatedOffset.generatedColumn - 1\n             : 0)\n        };\n        return ret;\n      }\n    }\n\n    return {\n      line: null,\n      column: null\n    };\n  }\n\n  /**\n   * Parse the mappings in a string in to a data structure which we can easily\n   * query (the ordered arrays in the `this.__generatedMappings` and\n   * `this.__originalMappings` properties).\n   */\n  _parseMappings(aStr, aSourceRoot) {\n    const generatedMappings = this.__generatedMappingsUnsorted = [];\n    const originalMappings = this.__originalMappingsUnsorted = [];\n    for (let i = 0; i < this._sections.length; i++) {\n      const section = this._sections[i];\n\n      const sectionMappings = [];\n      section.consumer.eachMapping(m => sectionMappings.push(m));\n\n      for (let j = 0; j < sectionMappings.length; j++) {\n        const mapping = sectionMappings[j];\n\n        // TODO: test if null is correct here.  The original code used\n        // `source`, which would actually have gotten used as null because\n        // var's get hoisted.\n        // See: https://github.com/mozilla/source-map/issues/333\n        let source = util.computeSourceURL(section.consumer.sourceRoot, null, this._sourceMapURL);\n        this._sources.add(source);\n        source = this._sources.indexOf(source);\n\n        let name = null;\n        if (mapping.name) {\n          this._names.add(mapping.name);\n          name = this._names.indexOf(mapping.name);\n        }\n\n        // The mappings coming from the consumer for the section have\n        // generated positions relative to the start of the section, so we\n        // need to offset them to be relative to the start of the concatenated\n        // generated file.\n        const adjustedMapping = {\n          source,\n          generatedLine: mapping.generatedLine +\n            (section.generatedOffset.generatedLine - 1),\n          generatedColumn: mapping.generatedColumn +\n            (section.generatedOffset.generatedLine === mapping.generatedLine\n            ? section.generatedOffset.generatedColumn - 1\n            : 0),\n          originalLine: mapping.originalLine,\n          originalColumn: mapping.originalColumn,\n          name\n        };\n\n        generatedMappings.push(adjustedMapping);\n        if (typeof adjustedMapping.originalLine === \"number\") {\n          originalMappings.push(adjustedMapping);\n        }\n      }\n    }\n  }\n\n  eachMapping(aCallback, aContext, aOrder) {\n    const context = aContext || null;\n    const order = aOrder || SourceMapConsumer.GENERATED_ORDER;\n\n    let mappings;\n    switch (order) {\n    case SourceMapConsumer.GENERATED_ORDER:\n      mappings = this._generatedMappings;\n      break;\n    case SourceMapConsumer.ORIGINAL_ORDER:\n      mappings = this._originalMappings;\n      break;\n    default:\n      throw new Error(\"Unknown order of iteration.\");\n    }\n\n    const sourceRoot = this.sourceRoot;\n    mappings.map(function(mapping) {\n      let source = null;\n      if (mapping.source !== null) {\n        source = this._sources.at(mapping.source);\n        source = util.computeSourceURL(sourceRoot, source, this._sourceMapURL);\n      }\n      return {\n        source,\n        generatedLine: mapping.generatedLine,\n        generatedColumn: mapping.generatedColumn,\n        originalLine: mapping.originalLine,\n        originalColumn: mapping.originalColumn,\n        name: mapping.name === null ? null : this._names.at(mapping.name)\n      };\n    }, this).forEach(aCallback, context);\n  }\n\n  /**\n   * Find the mapping that best matches the hypothetical \"needle\" mapping that\n   * we are searching for in the given \"haystack\" of mappings.\n   */\n  _findMapping(aNeedle, aMappings, aLineName,\n              aColumnName, aComparator, aBias) {\n    // To return the position we are searching for, we must first find the\n    // mapping for the given position and then return the opposite position it\n    // points to. Because the mappings are sorted, we can use binary search to\n    // find the best mapping.\n\n    if (aNeedle[aLineName] <= 0) {\n      throw new TypeError(\"Line must be greater than or equal to 1, got \"\n                          + aNeedle[aLineName]);\n    }\n    if (aNeedle[aColumnName] < 0) {\n      throw new TypeError(\"Column must be greater than or equal to 0, got \"\n                          + aNeedle[aColumnName]);\n    }\n\n    return binarySearch.search(aNeedle, aMappings, aComparator, aBias);\n  }\n\n  allGeneratedPositionsFor(aArgs) {\n    const line = util.getArg(aArgs, \"line\");\n\n    // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping\n    // returns the index of the closest mapping less than the needle. By\n    // setting needle.originalColumn to 0, we thus find the last mapping for\n    // the given line, provided such a mapping exists.\n    const needle = {\n      source: util.getArg(aArgs, \"source\"),\n      originalLine: line,\n      originalColumn: util.getArg(aArgs, \"column\", 0)\n    };\n\n    needle.source = this._findSourceIndex(needle.source);\n    if (needle.source < 0) {\n      return [];\n    }\n\n    if (needle.originalLine < 1) {\n      throw new Error(\"Line numbers must be >= 1\");\n    }\n\n    if (needle.originalColumn < 0) {\n      throw new Error(\"Column numbers must be >= 0\");\n    }\n\n    const mappings = [];\n\n    let index = this._findMapping(needle,\n                                  this._originalMappings,\n                                  \"originalLine\",\n                                  \"originalColumn\",\n                                  util.compareByOriginalPositions,\n                                  binarySearch.LEAST_UPPER_BOUND);\n    if (index >= 0) {\n      let mapping = this._originalMappings[index];\n\n      if (aArgs.column === undefined) {\n        const originalLine = mapping.originalLine;\n\n        // Iterate until either we run out of mappings, or we run into\n        // a mapping for a different line than the one we found. Since\n        // mappings are sorted, this is guaranteed to find all mappings for\n        // the line we found.\n        while (mapping && mapping.originalLine === originalLine) {\n          let lastColumn = mapping.lastGeneratedColumn;\n          if (this._computedColumnSpans && lastColumn === null) {\n            lastColumn = Infinity;\n          }\n          mappings.push({\n            line: util.getArg(mapping, \"generatedLine\", null),\n            column: util.getArg(mapping, \"generatedColumn\", null),\n            lastColumn,\n          });\n\n          mapping = this._originalMappings[++index];\n        }\n      } else {\n        const originalColumn = mapping.originalColumn;\n\n        // Iterate until either we run out of mappings, or we run into\n        // a mapping for a different line than the one we were searching for.\n        // Since mappings are sorted, this is guaranteed to find all mappings for\n        // the line we are searching for.\n        while (mapping &&\n               mapping.originalLine === line &&\n               mapping.originalColumn == originalColumn) {\n          let lastColumn = mapping.lastGeneratedColumn;\n          if (this._computedColumnSpans && lastColumn === null) {\n            lastColumn = Infinity;\n          }\n          mappings.push({\n            line: util.getArg(mapping, \"generatedLine\", null),\n            column: util.getArg(mapping, \"generatedColumn\", null),\n            lastColumn,\n          });\n\n          mapping = this._originalMappings[++index];\n        }\n      }\n    }\n\n    return mappings;\n  }\n\n  destroy() {\n    for (let i = 0; i < this._sections.length; i++) {\n      this._sections[i].consumer.destroy();\n    }\n  }\n}\nexports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;\n\n/*\n * Cheat to get around inter-twingled classes.  `factory()` can be at the end\n * where it has access to non-hoisted classes, but it gets hoisted itself.\n */\nfunction _factory(aSourceMap, aSourceMapURL) {\n  let sourceMap = aSourceMap;\n  if (typeof aSourceMap === \"string\") {\n    sourceMap = util.parseSourceMapInput(aSourceMap);\n  }\n\n  const consumer = sourceMap.sections != null\n      ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL)\n      : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);\n  return Promise.resolve(consumer);\n}\n\nfunction _factoryBSM(aSourceMap, aSourceMapURL) {\n  return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);\n}\n","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nconst base64VLQ = require(\"./base64-vlq\");\nconst util = require(\"./util\");\nconst ArraySet = require(\"./array-set\").ArraySet;\nconst MappingList = require(\"./mapping-list\").MappingList;\n\n/**\n * An instance of the SourceMapGenerator represents a source map which is\n * being built incrementally. You may pass an object with the following\n * properties:\n *\n *   - file: The filename of the generated source.\n *   - sourceRoot: A root for all relative URLs in this source map.\n */\nclass SourceMapGenerator {\n  constructor(aArgs) {\n    if (!aArgs) {\n      aArgs = {};\n    }\n    this._file = util.getArg(aArgs, \"file\", null);\n    this._sourceRoot = util.getArg(aArgs, \"sourceRoot\", null);\n    this._skipValidation = util.getArg(aArgs, \"skipValidation\", false);\n    this._sources = new ArraySet();\n    this._names = new ArraySet();\n    this._mappings = new MappingList();\n    this._sourcesContents = null;\n  }\n\n  /**\n   * Creates a new SourceMapGenerator based on a SourceMapConsumer\n   *\n   * @param aSourceMapConsumer The SourceMap.\n   */\n  static fromSourceMap(aSourceMapConsumer) {\n    const sourceRoot = aSourceMapConsumer.sourceRoot;\n    const generator = new SourceMapGenerator({\n      file: aSourceMapConsumer.file,\n      sourceRoot\n    });\n    aSourceMapConsumer.eachMapping(function(mapping) {\n      const newMapping = {\n        generated: {\n          line: mapping.generatedLine,\n          column: mapping.generatedColumn\n        }\n      };\n\n      if (mapping.source != null) {\n        newMapping.source = mapping.source;\n        if (sourceRoot != null) {\n          newMapping.source = util.relative(sourceRoot, newMapping.source);\n        }\n\n        newMapping.original = {\n          line: mapping.originalLine,\n          column: mapping.originalColumn\n        };\n\n        if (mapping.name != null) {\n          newMapping.name = mapping.name;\n        }\n      }\n\n      generator.addMapping(newMapping);\n    });\n    aSourceMapConsumer.sources.forEach(function(sourceFile) {\n      let sourceRelative = sourceFile;\n      if (sourceRoot !== null) {\n        sourceRelative = util.relative(sourceRoot, sourceFile);\n      }\n\n      if (!generator._sources.has(sourceRelative)) {\n        generator._sources.add(sourceRelative);\n      }\n\n      const content = aSourceMapConsumer.sourceContentFor(sourceFile);\n      if (content != null) {\n        generator.setSourceContent(sourceFile, content);\n      }\n    });\n    return generator;\n  }\n\n  /**\n   * Add a single mapping from original source line and column to the generated\n   * source's line and column for this source map being created. The mapping\n   * object should have the following properties:\n   *\n   *   - generated: An object with the generated line and column positions.\n   *   - original: An object with the original line and column positions.\n   *   - source: The original source file (relative to the sourceRoot).\n   *   - name: An optional original token name for this mapping.\n   */\n  addMapping(aArgs) {\n    const generated = util.getArg(aArgs, \"generated\");\n    const original = util.getArg(aArgs, \"original\", null);\n    let source = util.getArg(aArgs, \"source\", null);\n    let name = util.getArg(aArgs, \"name\", null);\n\n    if (!this._skipValidation) {\n      this._validateMapping(generated, original, source, name);\n    }\n\n    if (source != null) {\n      source = String(source);\n      if (!this._sources.has(source)) {\n        this._sources.add(source);\n      }\n    }\n\n    if (name != null) {\n      name = String(name);\n      if (!this._names.has(name)) {\n        this._names.add(name);\n      }\n    }\n\n    this._mappings.add({\n      generatedLine: generated.line,\n      generatedColumn: generated.column,\n      originalLine: original != null && original.line,\n      originalColumn: original != null && original.column,\n      source,\n      name\n    });\n  }\n\n  /**\n   * Set the source content for a source file.\n   */\n  setSourceContent(aSourceFile, aSourceContent) {\n    let source = aSourceFile;\n    if (this._sourceRoot != null) {\n      source = util.relative(this._sourceRoot, source);\n    }\n\n    if (aSourceContent != null) {\n      // Add the source content to the _sourcesContents map.\n      // Create a new _sourcesContents map if the property is null.\n      if (!this._sourcesContents) {\n        this._sourcesContents = Object.create(null);\n      }\n      this._sourcesContents[util.toSetString(source)] = aSourceContent;\n    } else if (this._sourcesContents) {\n      // Remove the source file from the _sourcesContents map.\n      // If the _sourcesContents map is empty, set the property to null.\n      delete this._sourcesContents[util.toSetString(source)];\n      if (Object.keys(this._sourcesContents).length === 0) {\n        this._sourcesContents = null;\n      }\n    }\n  }\n\n  /**\n   * Applies the mappings of a sub-source-map for a specific source file to the\n   * source map being generated. Each mapping to the supplied source file is\n   * rewritten using the supplied source map. Note: The resolution for the\n   * resulting mappings is the minimium of this map and the supplied map.\n   *\n   * @param aSourceMapConsumer The source map to be applied.\n   * @param aSourceFile Optional. The filename of the source file.\n   *        If omitted, SourceMapConsumer's file property will be used.\n   * @param aSourceMapPath Optional. The dirname of the path to the source map\n   *        to be applied. If relative, it is relative to the SourceMapConsumer.\n   *        This parameter is needed when the two source maps aren't in the same\n   *        directory, and the source map to be applied contains relative source\n   *        paths. If so, those relative source paths need to be rewritten\n   *        relative to the SourceMapGenerator.\n   */\n  applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {\n    let sourceFile = aSourceFile;\n    // If aSourceFile is omitted, we will use the file property of the SourceMap\n    if (aSourceFile == null) {\n      if (aSourceMapConsumer.file == null) {\n        throw new Error(\n          \"SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, \" +\n          'or the source map\\'s \"file\" property. Both were omitted.'\n        );\n      }\n      sourceFile = aSourceMapConsumer.file;\n    }\n    const sourceRoot = this._sourceRoot;\n    // Make \"sourceFile\" relative if an absolute Url is passed.\n    if (sourceRoot != null) {\n      sourceFile = util.relative(sourceRoot, sourceFile);\n    }\n    // Applying the SourceMap can add and remove items from the sources and\n    // the names array.\n    const newSources = this._mappings.toArray().length > 0\n      ? new ArraySet()\n      : this._sources;\n    const newNames = new ArraySet();\n\n    // Find mappings for the \"sourceFile\"\n    this._mappings.unsortedForEach(function(mapping) {\n      if (mapping.source === sourceFile && mapping.originalLine != null) {\n        // Check if it can be mapped by the source map, then update the mapping.\n        const original = aSourceMapConsumer.originalPositionFor({\n          line: mapping.originalLine,\n          column: mapping.originalColumn\n        });\n        if (original.source != null) {\n          // Copy mapping\n          mapping.source = original.source;\n          if (aSourceMapPath != null) {\n            mapping.source = util.join(aSourceMapPath, mapping.source);\n          }\n          if (sourceRoot != null) {\n            mapping.source = util.relative(sourceRoot, mapping.source);\n          }\n          mapping.originalLine = original.line;\n          mapping.originalColumn = original.column;\n          if (original.name != null) {\n            mapping.name = original.name;\n          }\n        }\n      }\n\n      const source = mapping.source;\n      if (source != null && !newSources.has(source)) {\n        newSources.add(source);\n      }\n\n      const name = mapping.name;\n      if (name != null && !newNames.has(name)) {\n        newNames.add(name);\n      }\n\n    }, this);\n    this._sources = newSources;\n    this._names = newNames;\n\n    // Copy sourcesContents of applied map.\n    aSourceMapConsumer.sources.forEach(function(srcFile) {\n      const content = aSourceMapConsumer.sourceContentFor(srcFile);\n      if (content != null) {\n        if (aSourceMapPath != null) {\n          srcFile = util.join(aSourceMapPath, srcFile);\n        }\n        if (sourceRoot != null) {\n          srcFile = util.relative(sourceRoot, srcFile);\n        }\n        this.setSourceContent(srcFile, content);\n      }\n    }, this);\n  }\n\n  /**\n   * A mapping can have one of the three levels of data:\n   *\n   *   1. Just the generated position.\n   *   2. The Generated position, original position, and original source.\n   *   3. Generated and original position, original source, as well as a name\n   *      token.\n   *\n   * To maintain consistency, we validate that any new mapping being added falls\n   * in to one of these categories.\n   */\n  _validateMapping(aGenerated, aOriginal, aSource, aName) {\n    // When aOriginal is truthy but has empty values for .line and .column,\n    // it is most likely a programmer error. In this case we throw a very\n    // specific error message to try to guide them the right way.\n    // For example: https://github.com/Polymer/polymer-bundler/pull/519\n    if (aOriginal && typeof aOriginal.line !== \"number\" && typeof aOriginal.column !== \"number\") {\n        throw new Error(\n            \"original.line and original.column are not numbers -- you probably meant to omit \" +\n            \"the original mapping entirely and only map the generated position. If so, pass \" +\n            \"null for the original mapping instead of an object with empty or null values.\"\n        );\n    }\n\n    if (aGenerated && \"line\" in aGenerated && \"column\" in aGenerated\n        && aGenerated.line > 0 && aGenerated.column >= 0\n        && !aOriginal && !aSource && !aName) {\n      // Case 1.\n\n    } else if (aGenerated && \"line\" in aGenerated && \"column\" in aGenerated\n             && aOriginal && \"line\" in aOriginal && \"column\" in aOriginal\n             && aGenerated.line > 0 && aGenerated.column >= 0\n             && aOriginal.line > 0 && aOriginal.column >= 0\n             && aSource) {\n      // Cases 2 and 3.\n\n    } else {\n      throw new Error(\"Invalid mapping: \" + JSON.stringify({\n        generated: aGenerated,\n        source: aSource,\n        original: aOriginal,\n        name: aName\n      }));\n    }\n  }\n\n  /**\n   * Serialize the accumulated mappings in to the stream of base 64 VLQs\n   * specified by the source map format.\n   */\n  _serializeMappings() {\n    let previousGeneratedColumn = 0;\n    let previousGeneratedLine = 1;\n    let previousOriginalColumn = 0;\n    let previousOriginalLine = 0;\n    let previousName = 0;\n    let previousSource = 0;\n    let result = \"\";\n    let next;\n    let mapping;\n    let nameIdx;\n    let sourceIdx;\n\n    const mappings = this._mappings.toArray();\n    for (let i = 0, len = mappings.length; i < len; i++) {\n      mapping = mappings[i];\n      next = \"\";\n\n      if (mapping.generatedLine !== previousGeneratedLine) {\n        previousGeneratedColumn = 0;\n        while (mapping.generatedLine !== previousGeneratedLine) {\n          next += \";\";\n          previousGeneratedLine++;\n        }\n      } else if (i > 0) {\n        if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {\n          continue;\n        }\n        next += \",\";\n      }\n\n      next += base64VLQ.encode(mapping.generatedColumn\n                                 - previousGeneratedColumn);\n      previousGeneratedColumn = mapping.generatedColumn;\n\n      if (mapping.source != null) {\n        sourceIdx = this._sources.indexOf(mapping.source);\n        next += base64VLQ.encode(sourceIdx - previousSource);\n        previousSource = sourceIdx;\n\n        // lines are stored 0-based in SourceMap spec version 3\n        next += base64VLQ.encode(mapping.originalLine - 1\n                                   - previousOriginalLine);\n        previousOriginalLine = mapping.originalLine - 1;\n\n        next += base64VLQ.encode(mapping.originalColumn\n                                   - previousOriginalColumn);\n        previousOriginalColumn = mapping.originalColumn;\n\n        if (mapping.name != null) {\n          nameIdx = this._names.indexOf(mapping.name);\n          next += base64VLQ.encode(nameIdx - previousName);\n          previousName = nameIdx;\n        }\n      }\n\n      result += next;\n    }\n\n    return result;\n  }\n\n  _generateSourcesContent(aSources, aSourceRoot) {\n    return aSources.map(function(source) {\n      if (!this._sourcesContents) {\n        return null;\n      }\n      if (aSourceRoot != null) {\n        source = util.relative(aSourceRoot, source);\n      }\n      const key = util.toSetString(source);\n      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)\n        ? this._sourcesContents[key]\n        : null;\n    }, this);\n  }\n\n  /**\n   * Externalize the source map.\n   */\n  toJSON() {\n    const map = {\n      version: this._version,\n      sources: this._sources.toArray(),\n      names: this._names.toArray(),\n      mappings: this._serializeMappings()\n    };\n    if (this._file != null) {\n      map.file = this._file;\n    }\n    if (this._sourceRoot != null) {\n      map.sourceRoot = this._sourceRoot;\n    }\n    if (this._sourcesContents) {\n      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);\n    }\n\n    return map;\n  }\n\n  /**\n   * Render the source map being generated to a string.\n   */\n  toString() {\n    return JSON.stringify(this.toJSON());\n  }\n}\n\nSourceMapGenerator.prototype._version = 3;\nexports.SourceMapGenerator = SourceMapGenerator;\n","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nconst SourceMapGenerator = require(\"./source-map-generator\").SourceMapGenerator;\nconst util = require(\"./util\");\n\n// Matches a Windows-style `\\r\\n` newline or a `\\n` newline used by all other\n// operating systems these days (capturing the result).\nconst REGEX_NEWLINE = /(\\r?\\n)/;\n\n// Newline character code for charCodeAt() comparisons\nconst NEWLINE_CODE = 10;\n\n// Private symbol for identifying `SourceNode`s when multiple versions of\n// the source-map library are loaded. This MUST NOT CHANGE across\n// versions!\nconst isSourceNode = \"$$$isSourceNode$$$\";\n\n/**\n * SourceNodes provide a way to abstract over interpolating/concatenating\n * snippets of generated JavaScript source code while maintaining the line and\n * column information associated with the original source code.\n *\n * @param aLine The original line number.\n * @param aColumn The original column number.\n * @param aSource The original source's filename.\n * @param aChunks Optional. An array of strings which are snippets of\n *        generated JS, or other SourceNodes.\n * @param aName The original identifier.\n */\nclass SourceNode {\n  constructor(aLine, aColumn, aSource, aChunks, aName) {\n    this.children = [];\n    this.sourceContents = {};\n    this.line = aLine == null ? null : aLine;\n    this.column = aColumn == null ? null : aColumn;\n    this.source = aSource == null ? null : aSource;\n    this.name = aName == null ? null : aName;\n    this[isSourceNode] = true;\n    if (aChunks != null) this.add(aChunks);\n  }\n\n  /**\n   * Creates a SourceNode from generated code and a SourceMapConsumer.\n   *\n   * @param aGeneratedCode The generated code\n   * @param aSourceMapConsumer The SourceMap for the generated code\n   * @param aRelativePath Optional. The path that relative sources in the\n   *        SourceMapConsumer should be relative to.\n   */\n  static fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {\n    // The SourceNode we want to fill with the generated code\n    // and the SourceMap\n    const node = new SourceNode();\n\n    // All even indices of this array are one line of the generated code,\n    // while all odd indices are the newlines between two adjacent lines\n    // (since `REGEX_NEWLINE` captures its match).\n    // Processed fragments are accessed by calling `shiftNextLine`.\n    const remainingLines = aGeneratedCode.split(REGEX_NEWLINE);\n    let remainingLinesIndex = 0;\n    const shiftNextLine = function() {\n      const lineContents = getNextLine();\n      // The last line of a file might not have a newline.\n      const newLine = getNextLine() || \"\";\n      return lineContents + newLine;\n\n      function getNextLine() {\n        return remainingLinesIndex < remainingLines.length ?\n            remainingLines[remainingLinesIndex++] : undefined;\n      }\n    };\n\n    // We need to remember the position of \"remainingLines\"\n    let lastGeneratedLine = 1, lastGeneratedColumn = 0;\n\n    // The generate SourceNodes we need a code range.\n    // To extract it current and last mapping is used.\n    // Here we store the last mapping.\n    let lastMapping = null;\n    let nextLine;\n\n    aSourceMapConsumer.eachMapping(function(mapping) {\n      if (lastMapping !== null) {\n        // We add the code from \"lastMapping\" to \"mapping\":\n        // First check if there is a new line in between.\n        if (lastGeneratedLine < mapping.generatedLine) {\n          // Associate first line with \"lastMapping\"\n          addMappingWithCode(lastMapping, shiftNextLine());\n          lastGeneratedLine++;\n          lastGeneratedColumn = 0;\n          // The remaining code is added without mapping\n        } else {\n          // There is no new line in between.\n          // Associate the code between \"lastGeneratedColumn\" and\n          // \"mapping.generatedColumn\" with \"lastMapping\"\n          nextLine = remainingLines[remainingLinesIndex] || \"\";\n          const code = nextLine.substr(0, mapping.generatedColumn -\n                                        lastGeneratedColumn);\n          remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn -\n                                              lastGeneratedColumn);\n          lastGeneratedColumn = mapping.generatedColumn;\n          addMappingWithCode(lastMapping, code);\n          // No more remaining code, continue\n          lastMapping = mapping;\n          return;\n        }\n      }\n      // We add the generated code until the first mapping\n      // to the SourceNode without any mapping.\n      // Each line is added as separate string.\n      while (lastGeneratedLine < mapping.generatedLine) {\n        node.add(shiftNextLine());\n        lastGeneratedLine++;\n      }\n      if (lastGeneratedColumn < mapping.generatedColumn) {\n        nextLine = remainingLines[remainingLinesIndex] || \"\";\n        node.add(nextLine.substr(0, mapping.generatedColumn));\n        remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);\n        lastGeneratedColumn = mapping.generatedColumn;\n      }\n      lastMapping = mapping;\n    }, this);\n    // We have processed all mappings.\n    if (remainingLinesIndex < remainingLines.length) {\n      if (lastMapping) {\n        // Associate the remaining code in the current line with \"lastMapping\"\n        addMappingWithCode(lastMapping, shiftNextLine());\n      }\n      // and add the remaining lines without any mapping\n      node.add(remainingLines.splice(remainingLinesIndex).join(\"\"));\n    }\n\n    // Copy sourcesContent into SourceNode\n    aSourceMapConsumer.sources.forEach(function(sourceFile) {\n      const content = aSourceMapConsumer.sourceContentFor(sourceFile);\n      if (content != null) {\n        if (aRelativePath != null) {\n          sourceFile = util.join(aRelativePath, sourceFile);\n        }\n        node.setSourceContent(sourceFile, content);\n      }\n    });\n\n    return node;\n\n    function addMappingWithCode(mapping, code) {\n      if (mapping === null || mapping.source === undefined) {\n        node.add(code);\n      } else {\n        const source = aRelativePath\n          ? util.join(aRelativePath, mapping.source)\n          : mapping.source;\n        node.add(new SourceNode(mapping.originalLine,\n                                mapping.originalColumn,\n                                source,\n                                code,\n                                mapping.name));\n      }\n    }\n  }\n\n  /**\n   * Add a chunk of generated JS to this source node.\n   *\n   * @param aChunk A string snippet of generated JS code, another instance of\n   *        SourceNode, or an array where each member is one of those things.\n   */\n  add(aChunk) {\n    if (Array.isArray(aChunk)) {\n      aChunk.forEach(function(chunk) {\n        this.add(chunk);\n      }, this);\n    } else if (aChunk[isSourceNode] || typeof aChunk === \"string\") {\n      if (aChunk) {\n        this.children.push(aChunk);\n      }\n    } else {\n      throw new TypeError(\n        \"Expected a SourceNode, string, or an array of SourceNodes and strings. Got \" + aChunk\n      );\n    }\n    return this;\n  }\n\n  /**\n   * Add a chunk of generated JS to the beginning of this source node.\n   *\n   * @param aChunk A string snippet of generated JS code, another instance of\n   *        SourceNode, or an array where each member is one of those things.\n   */\n  prepend(aChunk) {\n    if (Array.isArray(aChunk)) {\n      for (let i = aChunk.length - 1; i >= 0; i--) {\n        this.prepend(aChunk[i]);\n      }\n    } else if (aChunk[isSourceNode] || typeof aChunk === \"string\") {\n      this.children.unshift(aChunk);\n    } else {\n      throw new TypeError(\n        \"Expected a SourceNode, string, or an array of SourceNodes and strings. Got \" + aChunk\n      );\n    }\n    return this;\n  }\n\n  /**\n   * Walk over the tree of JS snippets in this node and its children. The\n   * walking function is called once for each snippet of JS and is passed that\n   * snippet and the its original associated source's line/column location.\n   *\n   * @param aFn The traversal function.\n   */\n  walk(aFn) {\n    let chunk;\n    for (let i = 0, len = this.children.length; i < len; i++) {\n      chunk = this.children[i];\n      if (chunk[isSourceNode]) {\n        chunk.walk(aFn);\n      } else if (chunk !== \"\") {\n        aFn(chunk, { source: this.source,\n                      line: this.line,\n                      column: this.column,\n                      name: this.name });\n      }\n    }\n  }\n\n  /**\n   * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between\n   * each of `this.children`.\n   *\n   * @param aSep The separator.\n   */\n  join(aSep) {\n    let newChildren;\n    let i;\n    const len = this.children.length;\n    if (len > 0) {\n      newChildren = [];\n      for (i = 0; i < len - 1; i++) {\n        newChildren.push(this.children[i]);\n        newChildren.push(aSep);\n      }\n      newChildren.push(this.children[i]);\n      this.children = newChildren;\n    }\n    return this;\n  }\n\n  /**\n   * Call String.prototype.replace on the very right-most source snippet. Useful\n   * for trimming whitespace from the end of a source node, etc.\n   *\n   * @param aPattern The pattern to replace.\n   * @param aReplacement The thing to replace the pattern with.\n   */\n  replaceRight(aPattern, aReplacement) {\n    const lastChild = this.children[this.children.length - 1];\n    if (lastChild[isSourceNode]) {\n      lastChild.replaceRight(aPattern, aReplacement);\n    } else if (typeof lastChild === \"string\") {\n      this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);\n    } else {\n      this.children.push(\"\".replace(aPattern, aReplacement));\n    }\n    return this;\n  }\n\n  /**\n   * Set the source content for a source file. This will be added to the SourceMapGenerator\n   * in the sourcesContent field.\n   *\n   * @param aSourceFile The filename of the source file\n   * @param aSourceContent The content of the source file\n   */\n  setSourceContent(aSourceFile, aSourceContent) {\n    this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;\n  }\n\n  /**\n   * Walk over the tree of SourceNodes. The walking function is called for each\n   * source file content and is passed the filename and source content.\n   *\n   * @param aFn The traversal function.\n   */\n  walkSourceContents(aFn) {\n    for (let i = 0, len = this.children.length; i < len; i++) {\n      if (this.children[i][isSourceNode]) {\n        this.children[i].walkSourceContents(aFn);\n      }\n    }\n\n    const sources = Object.keys(this.sourceContents);\n    for (let i = 0, len = sources.length; i < len; i++) {\n      aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);\n    }\n  }\n\n  /**\n   * Return the string representation of this source node. Walks over the tree\n   * and concatenates all the various snippets together to one string.\n   */\n  toString() {\n    let str = \"\";\n    this.walk(function(chunk) {\n      str += chunk;\n    });\n    return str;\n  }\n\n  /**\n   * Returns the string representation of this source node along with a source\n   * map.\n   */\n  toStringWithSourceMap(aArgs) {\n    const generated = {\n      code: \"\",\n      line: 1,\n      column: 0\n    };\n    const map = new SourceMapGenerator(aArgs);\n    let sourceMappingActive = false;\n    let lastOriginalSource = null;\n    let lastOriginalLine = null;\n    let lastOriginalColumn = null;\n    let lastOriginalName = null;\n    this.walk(function(chunk, original) {\n      generated.code += chunk;\n      if (original.source !== null\n          && original.line !== null\n          && original.column !== null) {\n        if (lastOriginalSource !== original.source\n          || lastOriginalLine !== original.line\n          || lastOriginalColumn !== original.column\n          || lastOriginalName !== original.name) {\n          map.addMapping({\n            source: original.source,\n            original: {\n              line: original.line,\n              column: original.column\n            },\n            generated: {\n              line: generated.line,\n              column: generated.column\n            },\n            name: original.name\n          });\n        }\n        lastOriginalSource = original.source;\n        lastOriginalLine = original.line;\n        lastOriginalColumn = original.column;\n        lastOriginalName = original.name;\n        sourceMappingActive = true;\n      } else if (sourceMappingActive) {\n        map.addMapping({\n          generated: {\n            line: generated.line,\n            column: generated.column\n          }\n        });\n        lastOriginalSource = null;\n        sourceMappingActive = false;\n      }\n      for (let idx = 0, length = chunk.length; idx < length; idx++) {\n        if (chunk.charCodeAt(idx) === NEWLINE_CODE) {\n          generated.line++;\n          generated.column = 0;\n          // Mappings end at eol\n          if (idx + 1 === length) {\n            lastOriginalSource = null;\n            sourceMappingActive = false;\n          } else if (sourceMappingActive) {\n            map.addMapping({\n              source: original.source,\n              original: {\n                line: original.line,\n                column: original.column\n              },\n              generated: {\n                line: generated.line,\n                column: generated.column\n              },\n              name: original.name\n            });\n          }\n        } else {\n          generated.column++;\n        }\n      }\n    });\n    this.walkSourceContents(function(sourceFile, sourceContent) {\n      map.setSourceContent(sourceFile, sourceContent);\n    });\n\n    return { code: generated.code, map };\n  }\n}\n\nexports.SourceNode = SourceNode;\n","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\n/**\n * This is a helper function for getting values from parameter/options\n * objects.\n *\n * @param args The object we are extracting values from\n * @param name The name of the property we are getting.\n * @param defaultValue An optional value to return if the property is missing\n * from the object. If this is not specified and the property is missing, an\n * error will be thrown.\n */\nfunction getArg(aArgs, aName, aDefaultValue) {\n  if (aName in aArgs) {\n    return aArgs[aName];\n  } else if (arguments.length === 3) {\n    return aDefaultValue;\n  }\n    throw new Error('\"' + aName + '\" is a required argument.');\n\n}\nexports.getArg = getArg;\n\nconst urlRegexp = /^(?:([\\w+\\-.]+):)?\\/\\/(?:(\\w+:\\w+)@)?([\\w.-]*)(?::(\\d+))?(.*)$/;\nconst dataUrlRegexp = /^data:.+\\,.+$/;\n\nfunction urlParse(aUrl) {\n  const match = aUrl.match(urlRegexp);\n  if (!match) {\n    return null;\n  }\n  return {\n    scheme: match[1],\n    auth: match[2],\n    host: match[3],\n    port: match[4],\n    path: match[5]\n  };\n}\nexports.urlParse = urlParse;\n\nfunction urlGenerate(aParsedUrl) {\n  let url = \"\";\n  if (aParsedUrl.scheme) {\n    url += aParsedUrl.scheme + \":\";\n  }\n  url += \"//\";\n  if (aParsedUrl.auth) {\n    url += aParsedUrl.auth + \"@\";\n  }\n  if (aParsedUrl.host) {\n    url += aParsedUrl.host;\n  }\n  if (aParsedUrl.port) {\n    url += \":\" + aParsedUrl.port;\n  }\n  if (aParsedUrl.path) {\n    url += aParsedUrl.path;\n  }\n  return url;\n}\nexports.urlGenerate = urlGenerate;\n\nconst MAX_CACHED_INPUTS = 32;\n\n/**\n * Takes some function `f(input) -> result` and returns a memoized version of\n * `f`.\n *\n * We keep at most `MAX_CACHED_INPUTS` memoized results of `f` alive. The\n * memoization is a dumb-simple, linear least-recently-used cache.\n */\nfunction lruMemoize(f) {\n  const cache = [];\n\n  return function(input) {\n    for (let i = 0; i < cache.length; i++) {\n      if (cache[i].input === input) {\n        const temp = cache[0];\n        cache[0] = cache[i];\n        cache[i] = temp;\n        return cache[0].result;\n      }\n    }\n\n    const result = f(input);\n\n    cache.unshift({\n      input,\n      result,\n    });\n\n    if (cache.length > MAX_CACHED_INPUTS) {\n      cache.pop();\n    }\n\n    return result;\n  };\n}\n\n/**\n * Normalizes a path, or the path portion of a URL:\n *\n * - Replaces consecutive slashes with one slash.\n * - Removes unnecessary '.' parts.\n * - Removes unnecessary '<dir>/..' parts.\n *\n * Based on code in the Node.js 'path' core module.\n *\n * @param aPath The path or url to normalize.\n */\nconst normalize = lruMemoize(function normalize(aPath) {\n  let path = aPath;\n  const url = urlParse(aPath);\n  if (url) {\n    if (!url.path) {\n      return aPath;\n    }\n    path = url.path;\n  }\n  const isAbsolute = exports.isAbsolute(path);\n\n  // Split the path into parts between `/` characters. This is much faster than\n  // using `.split(/\\/+/g)`.\n  const parts = [];\n  let start = 0;\n  let i = 0;\n  while (true) {\n    start = i;\n    i = path.indexOf(\"/\", start);\n    if (i === -1) {\n      parts.push(path.slice(start));\n      break;\n    } else {\n      parts.push(path.slice(start, i));\n      while (i < path.length && path[i] === \"/\") {\n        i++;\n      }\n    }\n  }\n\n  let up = 0;\n  for (i = parts.length - 1; i >= 0; i--) {\n    const part = parts[i];\n    if (part === \".\") {\n      parts.splice(i, 1);\n    } else if (part === \"..\") {\n      up++;\n    } else if (up > 0) {\n      if (part === \"\") {\n        // The first part is blank if the path is absolute. Trying to go\n        // above the root is a no-op. Therefore we can remove all '..' parts\n        // directly after the root.\n        parts.splice(i + 1, up);\n        up = 0;\n      } else {\n        parts.splice(i, 2);\n        up--;\n      }\n    }\n  }\n  path = parts.join(\"/\");\n\n  if (path === \"\") {\n    path = isAbsolute ? \"/\" : \".\";\n  }\n\n  if (url) {\n    url.path = path;\n    return urlGenerate(url);\n  }\n  return path;\n});\nexports.normalize = normalize;\n\n/**\n * Joins two paths/URLs.\n *\n * @param aRoot The root path or URL.\n * @param aPath The path or URL to be joined with the root.\n *\n * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a\n *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended\n *   first.\n * - Otherwise aPath is a path. If aRoot is a URL, then its path portion\n *   is updated with the result and aRoot is returned. Otherwise the result\n *   is returned.\n *   - If aPath is absolute, the result is aPath.\n *   - Otherwise the two paths are joined with a slash.\n * - Joining for example 'http://' and 'www.example.com' is also supported.\n */\nfunction join(aRoot, aPath) {\n  if (aRoot === \"\") {\n    aRoot = \".\";\n  }\n  if (aPath === \"\") {\n    aPath = \".\";\n  }\n  const aPathUrl = urlParse(aPath);\n  const aRootUrl = urlParse(aRoot);\n  if (aRootUrl) {\n    aRoot = aRootUrl.path || \"/\";\n  }\n\n  // `join(foo, '//www.example.org')`\n  if (aPathUrl && !aPathUrl.scheme) {\n    if (aRootUrl) {\n      aPathUrl.scheme = aRootUrl.scheme;\n    }\n    return urlGenerate(aPathUrl);\n  }\n\n  if (aPathUrl || aPath.match(dataUrlRegexp)) {\n    return aPath;\n  }\n\n  // `join('http://', 'www.example.com')`\n  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {\n    aRootUrl.host = aPath;\n    return urlGenerate(aRootUrl);\n  }\n\n  const joined = aPath.charAt(0) === \"/\"\n    ? aPath\n    : normalize(aRoot.replace(/\\/+$/, \"\") + \"/\" + aPath);\n\n  if (aRootUrl) {\n    aRootUrl.path = joined;\n    return urlGenerate(aRootUrl);\n  }\n  return joined;\n}\nexports.join = join;\n\nexports.isAbsolute = function(aPath) {\n  return aPath.charAt(0) === \"/\" || urlRegexp.test(aPath);\n};\n\n/**\n * Make a path relative to a URL or another path.\n *\n * @param aRoot The root path or URL.\n * @param aPath The path or URL to be made relative to aRoot.\n */\nfunction relative(aRoot, aPath) {\n  if (aRoot === \"\") {\n    aRoot = \".\";\n  }\n\n  aRoot = aRoot.replace(/\\/$/, \"\");\n\n  // It is possible for the path to be above the root. In this case, simply\n  // checking whether the root is a prefix of the path won't work. Instead, we\n  // need to remove components from the root one by one, until either we find\n  // a prefix that fits, or we run out of components to remove.\n  let level = 0;\n  while (aPath.indexOf(aRoot + \"/\") !== 0) {\n    const index = aRoot.lastIndexOf(\"/\");\n    if (index < 0) {\n      return aPath;\n    }\n\n    // If the only part of the root that is left is the scheme (i.e. http://,\n    // file:///, etc.), one or more slashes (/), or simply nothing at all, we\n    // have exhausted all components, so the path is not relative to the root.\n    aRoot = aRoot.slice(0, index);\n    if (aRoot.match(/^([^\\/]+:\\/)?\\/*$/)) {\n      return aPath;\n    }\n\n    ++level;\n  }\n\n  // Make sure we add a \"../\" for each component we removed from the root.\n  return Array(level + 1).join(\"../\") + aPath.substr(aRoot.length + 1);\n}\nexports.relative = relative;\n\nconst supportsNullProto = (function() {\n  const obj = Object.create(null);\n  return !(\"__proto__\" in obj);\n}());\n\nfunction identity(s) {\n  return s;\n}\n\n/**\n * Because behavior goes wacky when you set `__proto__` on objects, we\n * have to prefix all the strings in our set with an arbitrary character.\n *\n * See https://github.com/mozilla/source-map/pull/31 and\n * https://github.com/mozilla/source-map/issues/30\n *\n * @param String aStr\n */\nfunction toSetString(aStr) {\n  if (isProtoString(aStr)) {\n    return \"$\" + aStr;\n  }\n\n  return aStr;\n}\nexports.toSetString = supportsNullProto ? identity : toSetString;\n\nfunction fromSetString(aStr) {\n  if (isProtoString(aStr)) {\n    return aStr.slice(1);\n  }\n\n  return aStr;\n}\nexports.fromSetString = supportsNullProto ? identity : fromSetString;\n\nfunction isProtoString(s) {\n  if (!s) {\n    return false;\n  }\n\n  const length = s.length;\n\n  if (length < 9 /* \"__proto__\".length */) {\n    return false;\n  }\n\n  /* eslint-disable no-multi-spaces */\n  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||\n      s.charCodeAt(length - 2) !== 95  /* '_' */ ||\n      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||\n      s.charCodeAt(length - 4) !== 116 /* 't' */ ||\n      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||\n      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||\n      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||\n      s.charCodeAt(length - 8) !== 95  /* '_' */ ||\n      s.charCodeAt(length - 9) !== 95  /* '_' */) {\n    return false;\n  }\n  /* eslint-enable no-multi-spaces */\n\n  for (let i = length - 10; i >= 0; i--) {\n    if (s.charCodeAt(i) !== 36 /* '$' */) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Comparator between two mappings where the original positions are compared.\n *\n * Optionally pass in `true` as `onlyCompareGenerated` to consider two\n * mappings with the same original source/line/column, but different generated\n * line and column the same. Useful when searching for a mapping with a\n * stubbed out mapping.\n */\nfunction compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {\n  let cmp = strcmp(mappingA.source, mappingB.source);\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalLine - mappingB.originalLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalColumn - mappingB.originalColumn;\n  if (cmp !== 0 || onlyCompareOriginal) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedLine - mappingB.generatedLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  return strcmp(mappingA.name, mappingB.name);\n}\nexports.compareByOriginalPositions = compareByOriginalPositions;\n\n/**\n * Comparator between two mappings with deflated source and name indices where\n * the generated positions are compared.\n *\n * Optionally pass in `true` as `onlyCompareGenerated` to consider two\n * mappings with the same generated line and column, but different\n * source/name/original line and column the same. Useful when searching for a\n * mapping with a stubbed out mapping.\n */\nfunction compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {\n  let cmp = mappingA.generatedLine - mappingB.generatedLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n  if (cmp !== 0 || onlyCompareGenerated) {\n    return cmp;\n  }\n\n  cmp = strcmp(mappingA.source, mappingB.source);\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalLine - mappingB.originalLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalColumn - mappingB.originalColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  return strcmp(mappingA.name, mappingB.name);\n}\nexports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;\n\nfunction strcmp(aStr1, aStr2) {\n  if (aStr1 === aStr2) {\n    return 0;\n  }\n\n  if (aStr1 === null) {\n    return 1; // aStr2 !== null\n  }\n\n  if (aStr2 === null) {\n    return -1; // aStr1 !== null\n  }\n\n  if (aStr1 > aStr2) {\n    return 1;\n  }\n\n  return -1;\n}\n\n/**\n * Comparator between two mappings with inflated source and name strings where\n * the generated positions are compared.\n */\nfunction compareByGeneratedPositionsInflated(mappingA, mappingB) {\n  let cmp = mappingA.generatedLine - mappingB.generatedLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = strcmp(mappingA.source, mappingB.source);\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalLine - mappingB.originalLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalColumn - mappingB.originalColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  return strcmp(mappingA.name, mappingB.name);\n}\nexports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;\n\n/**\n * Strip any JSON XSSI avoidance prefix from the string (as documented\n * in the source maps specification), and then parse the string as\n * JSON.\n */\nfunction parseSourceMapInput(str) {\n  return JSON.parse(str.replace(/^\\)]}'[^\\n]*\\n/, \"\"));\n}\nexports.parseSourceMapInput = parseSourceMapInput;\n\n/**\n * Compute the URL of a source given the the source root, the source's\n * URL, and the source map's URL.\n */\nfunction computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {\n  sourceURL = sourceURL || \"\";\n\n  if (sourceRoot) {\n    // This follows what Chrome does.\n    if (sourceRoot[sourceRoot.length - 1] !== \"/\" && sourceURL[0] !== \"/\") {\n      sourceRoot += \"/\";\n    }\n    // The spec says:\n    //   Line 4: An optional source root, useful for relocating source\n    //   files on a server or removing repeated values in the\n    //   sources entry.  This value is prepended to the individual\n    //   entries in the source field.\n    sourceURL = sourceRoot + sourceURL;\n  }\n\n  // Historically, SourceMapConsumer did not take the sourceMapURL as\n  // a parameter.  This mode is still somewhat supported, which is why\n  // this code block is conditional.  However, it's preferable to pass\n  // the source map URL to SourceMapConsumer, so that this function\n  // can implement the source URL resolution algorithm as outlined in\n  // the spec.  This block is basically the equivalent of:\n  //    new URL(sourceURL, sourceMapURL).toString()\n  // ... except it avoids using URL, which wasn't available in the\n  // older releases of node still supported by this library.\n  //\n  // The spec says:\n  //   If the sources are not absolute URLs after prepending of the\n  //   sourceRoot, the sources are resolved relative to the\n  //   SourceMap (like resolving script src in a html document).\n  if (sourceMapURL) {\n    const parsed = urlParse(sourceMapURL);\n    if (!parsed) {\n      throw new Error(\"sourceMapURL could not be parsed\");\n    }\n    if (parsed.path) {\n      // Strip the last path component, but keep the \"/\".\n      const index = parsed.path.lastIndexOf(\"/\");\n      if (index >= 0) {\n        parsed.path = parsed.path.substring(0, index + 1);\n      }\n    }\n    sourceURL = join(urlGenerate(parsed), sourceURL);\n  }\n\n  return normalize(sourceURL);\n}\nexports.computeSourceURL = computeSourceURL;\n","const readWasm = require(\"../lib/read-wasm\");\n\n/**\n * Provide the JIT with a nice shape / hidden class.\n */\nfunction Mapping() {\n  this.generatedLine = 0;\n  this.generatedColumn = 0;\n  this.lastGeneratedColumn = null;\n  this.source = null;\n  this.originalLine = null;\n  this.originalColumn = null;\n  this.name = null;\n}\n\nlet cachedWasm = null;\n\nmodule.exports = function wasm() {\n  if (cachedWasm) {\n    return cachedWasm;\n  }\n\n  const callbackStack = [];\n\n  cachedWasm = readWasm().then(buffer => {\n      return WebAssembly.instantiate(buffer, {\n        env: {\n          mapping_callback(\n            generatedLine,\n            generatedColumn,\n\n            hasLastGeneratedColumn,\n            lastGeneratedColumn,\n\n            hasOriginal,\n            source,\n            originalLine,\n            originalColumn,\n\n            hasName,\n            name\n          ) {\n            const mapping = new Mapping();\n            // JS uses 1-based line numbers, wasm uses 0-based.\n            mapping.generatedLine = generatedLine + 1;\n            mapping.generatedColumn = generatedColumn;\n\n            if (hasLastGeneratedColumn) {\n              // JS uses inclusive last generated column, wasm uses exclusive.\n              mapping.lastGeneratedColumn = lastGeneratedColumn - 1;\n            }\n\n            if (hasOriginal) {\n              mapping.source = source;\n              // JS uses 1-based line numbers, wasm uses 0-based.\n              mapping.originalLine = originalLine + 1;\n              mapping.originalColumn = originalColumn;\n\n              if (hasName) {\n                mapping.name = name;\n              }\n            }\n\n            callbackStack[callbackStack.length - 1](mapping);\n          },\n\n          start_all_generated_locations_for() { console.time(\"all_generated_locations_for\"); },\n          end_all_generated_locations_for() { console.timeEnd(\"all_generated_locations_for\"); },\n\n          start_compute_column_spans() { console.time(\"compute_column_spans\"); },\n          end_compute_column_spans() { console.timeEnd(\"compute_column_spans\"); },\n\n          start_generated_location_for() { console.time(\"generated_location_for\"); },\n          end_generated_location_for() { console.timeEnd(\"generated_location_for\"); },\n\n          start_original_location_for() { console.time(\"original_location_for\"); },\n          end_original_location_for() { console.timeEnd(\"original_location_for\"); },\n\n          start_parse_mappings() { console.time(\"parse_mappings\"); },\n          end_parse_mappings() { console.timeEnd(\"parse_mappings\"); },\n\n          start_sort_by_generated_location() { console.time(\"sort_by_generated_location\"); },\n          end_sort_by_generated_location() { console.timeEnd(\"sort_by_generated_location\"); },\n\n          start_sort_by_original_location() { console.time(\"sort_by_original_location\"); },\n          end_sort_by_original_location() { console.timeEnd(\"sort_by_original_location\"); },\n        }\n      });\n  }).then(Wasm => {\n    return {\n      exports: Wasm.instance.exports,\n      withMappingCallback: (mappingCallback, f) => {\n        callbackStack.push(mappingCallback);\n        try {\n          f();\n        } finally {\n          callbackStack.pop();\n        }\n      }\n    };\n  }).then(null, e => {\n    cachedWasm = null;\n    throw e;\n  });\n\n  return cachedWasm;\n};\n","/*\n * Copyright 2009-2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE.txt or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\nexports.SourceMapGenerator = require(\"./lib/source-map-generator\").SourceMapGenerator;\nexports.SourceMapConsumer = require(\"./lib/source-map-consumer\").SourceMapConsumer;\nexports.SourceNode = require(\"./lib/source-node\").SourceNode;\n","\"use strict\";\n/**\n * Copyright 2018 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getAllocationProfile = exports.stopSamplingHeapProfiler = exports.startSamplingHeapProfiler = void 0;\nconst path = require(\"path\");\nconst findBinding = require('node-gyp-build');\nconst profiler = findBinding(path.join(__dirname, '..', '..'));\n// Wrappers around native heap profiler functions.\nfunction startSamplingHeapProfiler(heapIntervalBytes, heapStackDepth) {\n    profiler.heapProfiler.startSamplingHeapProfiler(heapIntervalBytes, heapStackDepth);\n}\nexports.startSamplingHeapProfiler = startSamplingHeapProfiler;\nfunction stopSamplingHeapProfiler() {\n    profiler.heapProfiler.stopSamplingHeapProfiler();\n}\nexports.stopSamplingHeapProfiler = stopSamplingHeapProfiler;\nfunction getAllocationProfile() {\n    return profiler.heapProfiler.getAllocationProfile();\n}\nexports.getAllocationProfile = getAllocationProfile;\n//# sourceMappingURL=heap-profiler-bindings.js.map","\"use strict\";\n/**\n * Copyright 2017 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.stop = exports.start = exports.profile = exports.v8Profile = void 0;\nconst heap_profiler_bindings_1 = require(\"./heap-profiler-bindings\");\nconst profile_serializer_1 = require(\"./profile-serializer\");\nlet enabled = false;\nlet heapIntervalBytes = 0;\nlet heapStackDepth = 0;\n/*\n * Collects a heap profile when heapProfiler is enabled. Otherwise throws\n * an error.\n *\n * Data is returned in V8 allocation profile format.\n */\nfunction v8Profile() {\n    if (!enabled) {\n        throw new Error('Heap profiler is not enabled.');\n    }\n    return heap_profiler_bindings_1.getAllocationProfile();\n}\nexports.v8Profile = v8Profile;\n/**\n * Collects a profile and returns it serialized in pprof format.\n * Throws if heap profiler is not enabled.\n *\n * @param ignoreSamplePath\n * @param sourceMapper\n */\nfunction profile(ignoreSamplePath, sourceMapper) {\n    const startTimeNanos = Date.now() * 1000 * 1000;\n    const result = v8Profile();\n    // Add node for external memory usage.\n    // Current type definitions do not have external.\n    // TODO: remove any once type definition is updated to include external.\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const { external } = process.memoryUsage();\n    if (external > 0) {\n        const externalNode = {\n            name: '(external)',\n            scriptName: '',\n            children: [],\n            allocations: [{ sizeBytes: external, count: 1 }],\n        };\n        result.children.push(externalNode);\n    }\n    return profile_serializer_1.serializeHeapProfile(result, startTimeNanos, heapIntervalBytes, ignoreSamplePath, sourceMapper);\n}\nexports.profile = profile;\n/**\n * Starts heap profiling. If heap profiling has already been started with\n * the same parameters, this is a noop. If heap profiler has already been\n * started with different parameters, this throws an error.\n *\n * @param intervalBytes - average number of bytes between samples.\n * @param stackDepth - maximum stack depth for samples collected.\n */\nfunction start(intervalBytes, stackDepth) {\n    if (enabled) {\n        throw new Error(`Heap profiler is already started  with intervalBytes ${heapIntervalBytes} and stackDepth ${stackDepth}`);\n    }\n    heapIntervalBytes = intervalBytes;\n    heapStackDepth = stackDepth;\n    heap_profiler_bindings_1.startSamplingHeapProfiler(heapIntervalBytes, heapStackDepth);\n    enabled = true;\n}\nexports.start = start;\n// Stops heap profiling. If heap profiling has not been started, does nothing.\nfunction stop() {\n    if (enabled) {\n        enabled = false;\n        heap_profiler_bindings_1.stopSamplingHeapProfiler();\n    }\n}\nexports.stop = stop;\n//# sourceMappingURL=heap-profiler.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.heap = exports.time = exports.SourceMapper = exports.encodeSync = exports.encode = void 0;\n/**\n * Copyright 2019 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst fs_1 = require(\"fs\");\nconst heapProfiler = require(\"./heap-profiler\");\nconst profile_encoder_1 = require(\"./profile-encoder\");\nconst timeProfiler = require(\"./time-profiler\");\nvar profile_encoder_2 = require(\"./profile-encoder\");\nObject.defineProperty(exports, \"encode\", { enumerable: true, get: function () { return profile_encoder_2.encode; } });\nObject.defineProperty(exports, \"encodeSync\", { enumerable: true, get: function () { return profile_encoder_2.encodeSync; } });\nvar sourcemapper_1 = require(\"./sourcemapper/sourcemapper\");\nObject.defineProperty(exports, \"SourceMapper\", { enumerable: true, get: function () { return sourcemapper_1.SourceMapper; } });\nexports.time = {\n    profile: timeProfiler.profile,\n    start: timeProfiler.start,\n};\nexports.heap = {\n    start: heapProfiler.start,\n    stop: heapProfiler.stop,\n    profile: heapProfiler.profile,\n    v8Profile: heapProfiler.v8Profile,\n};\n// If loaded with --require, start profiling.\nif (module.parent && module.parent.id === 'internal/preload') {\n    const stop = exports.time.start();\n    process.on('exit', () => {\n        // The process is going to terminate imminently. All work here needs to\n        // be synchronous.\n        const profile = stop();\n        const buffer = profile_encoder_1.encodeSync(profile);\n        fs_1.writeFileSync(`pprof-profile-${process.pid}.pb.gz`, buffer);\n    });\n}\n//# sourceMappingURL=index.js.map","\"use strict\";\n/**\n * Copyright 2019 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.encodeSync = exports.encode = void 0;\nconst pify = require(\"pify\");\nconst zlib_1 = require(\"zlib\");\nconst profile_1 = require(\"../../proto/profile\");\nconst gzipPromise = pify(zlib_1.gzip);\nfunction encode(profile) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const buffer = profile_1.perftools.profiles.Profile.encode(profile).finish();\n        return gzipPromise(buffer);\n    });\n}\nexports.encode = encode;\nfunction encodeSync(profile) {\n    const buffer = profile_1.perftools.profiles.Profile.encode(profile).finish();\n    return zlib_1.gzipSync(buffer);\n}\nexports.encodeSync = encodeSync;\n//# sourceMappingURL=profile-encoder.js.map","\"use strict\";\n/**\n * Copyright 2017 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.serializeHeapProfile = exports.serializeTimeProfile = void 0;\nconst profile_1 = require(\"../../proto/profile\");\nfunction isGeneratedLocation(location) {\n    return (location.column !== undefined &&\n        location.line !== undefined &&\n        location.line > 0);\n}\n/**\n * Used to build string table and access strings and their ids within the table\n * when serializing a profile.\n */\nclass StringTable {\n    constructor() {\n        this.strings = [];\n        this.stringsMap = new Map();\n        this.getIndexOrAdd('');\n    }\n    /**\n     * @return index of str within the table. Also adds str to string table if\n     * str is not in the table already.\n     */\n    getIndexOrAdd(str) {\n        let idx = this.stringsMap.get(str);\n        if (idx !== undefined) {\n            return idx;\n        }\n        idx = this.strings.push(str) - 1;\n        this.stringsMap.set(str, idx);\n        return idx;\n    }\n}\n/**\n * Takes v8 profile and populates sample, location, and function fields of\n * profile.proto.\n *\n * @param profile - profile.proto with empty sample, location, and function\n * fields.\n * @param root - root of v8 profile tree describing samples to be appended\n * to profile.\n * @param appendToSamples - function which converts entry to sample(s)  and\n * appends these to end of an array of samples.\n * @param stringTable - string table for the existing profile.\n */\nfunction serialize(profile, root, appendToSamples, stringTable, ignoreSamplesPath, sourceMapper) {\n    const samples = [];\n    const locations = [];\n    const functions = [];\n    const functionIdMap = new Map();\n    const locationIdMap = new Map();\n    const entries = root.children.map((n) => ({\n        node: n,\n        stack: [],\n    }));\n    while (entries.length > 0) {\n        const entry = entries.pop();\n        const node = entry.node;\n        if (ignoreSamplesPath && node.scriptName.indexOf(ignoreSamplesPath) > -1) {\n            continue;\n        }\n        if (node.name === '(idle)' || node.name === '(program)')\n            continue;\n        const stack = entry.stack;\n        const location = getLocation(node, sourceMapper);\n        stack.unshift(location.id);\n        appendToSamples(entry, samples);\n        for (const child of node.children) {\n            entries.push({ node: child, stack: stack.slice() });\n        }\n    }\n    profile.sample = samples;\n    profile.location = locations;\n    profile.function = functions;\n    profile.stringTable = stringTable.strings;\n    function getLocation(node, sourceMapper) {\n        let profLoc = {\n            file: node.scriptName || '',\n            line: node.lineNumber,\n            column: node.columnNumber,\n            name: node.name,\n        };\n        if (profLoc.line) {\n            if (sourceMapper && isGeneratedLocation(profLoc)) {\n                profLoc = sourceMapper.mappingInfo(profLoc);\n            }\n        }\n        const keyStr = `${node.scriptId}:${profLoc.line}:${profLoc.column}:${profLoc.name}`;\n        let id = locationIdMap.get(keyStr);\n        if (id !== undefined) {\n            // id is index+1, since 0 is not valid id.\n            return locations[id - 1];\n        }\n        id = locations.length + 1;\n        locationIdMap.set(keyStr, id);\n        const line = getLine(node.scriptId, profLoc.file, profLoc.name, profLoc.line);\n        const location = new profile_1.perftools.profiles.Location({ id, line: [line] });\n        locations.push(location);\n        return location;\n    }\n    function getLine(scriptId, scriptName, name, line) {\n        return new profile_1.perftools.profiles.Line({\n            functionId: getFunction(scriptId, scriptName, name).id,\n            line,\n        });\n    }\n    function getFunction(scriptId, scriptName, name) {\n        const keyStr = `${scriptId}:${name}`;\n        let id = functionIdMap.get(keyStr);\n        if (id !== undefined) {\n            // id is index+1, since 0 is not valid id.\n            return functions[id - 1];\n        }\n        id = functions.length + 1;\n        functionIdMap.set(keyStr, id);\n        const nameId = stringTable.getIndexOrAdd(name || '(anonymous)');\n        const f = new profile_1.perftools.profiles.Function({\n            id,\n            name: nameId,\n            systemName: nameId,\n            filename: stringTable.getIndexOrAdd(scriptName || ''),\n        });\n        functions.push(f);\n        return f;\n    }\n}\n/**\n * @return value type for sample counts (type:sample, units:count), and\n * adds strings used in this value type to the table.\n */\nfunction createSampleCountValueType(table) {\n    return new profile_1.perftools.profiles.ValueType({\n        type: table.getIndexOrAdd('sample'),\n        unit: table.getIndexOrAdd('count'),\n    });\n}\n/**\n * @return value type for time samples (type:wall, units:nanoseconds), and\n * adds strings used in this value type to the table.\n */\nfunction createTimeValueType(table) {\n    return new profile_1.perftools.profiles.ValueType({\n        type: table.getIndexOrAdd('wall'),\n        unit: table.getIndexOrAdd('nanoseconds'),\n    });\n}\n/**\n * @return value type for object counts (type:objects, units:count), and\n * adds strings used in this value type to the table.\n */\nfunction createObjectCountValueType(table) {\n    return new profile_1.perftools.profiles.ValueType({\n        type: table.getIndexOrAdd('objects'),\n        unit: table.getIndexOrAdd('count'),\n    });\n}\n/**\n * @return value type for memory allocations (type:space, units:bytes), and\n * adds strings used in this value type to the table.\n */\nfunction createAllocationValueType(table) {\n    return new profile_1.perftools.profiles.ValueType({\n        type: table.getIndexOrAdd('space'),\n        unit: table.getIndexOrAdd('bytes'),\n    });\n}\n/**\n * Converts v8 time profile into into a profile proto.\n * (https://github.com/google/pprof/blob/master/proto/profile.proto)\n *\n * @param prof - profile to be converted.\n * @param intervalMicros - average time (microseconds) between samples.\n */\nfunction serializeTimeProfile(prof, intervalMicros, sourceMapper) {\n    const intervalNanos = intervalMicros * 1000;\n    const appendTimeEntryToSamples = (entry, samples) => {\n        if (entry.node.hitCount > 0) {\n            const sample = new profile_1.perftools.profiles.Sample({\n                locationId: entry.stack,\n                value: [entry.node.hitCount, entry.node.hitCount * intervalNanos],\n            });\n            samples.push(sample);\n        }\n    };\n    const stringTable = new StringTable();\n    const sampleValueType = createSampleCountValueType(stringTable);\n    const timeValueType = createTimeValueType(stringTable);\n    const profile = {\n        sampleType: [sampleValueType, timeValueType],\n        timeNanos: Date.now() * 1000 * 1000,\n        durationNanos: (prof.endTime - prof.startTime) * 1000,\n        periodType: timeValueType,\n        period: intervalMicros,\n    };\n    serialize(profile, prof.topDownRoot, appendTimeEntryToSamples, stringTable, undefined, sourceMapper);\n    return profile;\n}\nexports.serializeTimeProfile = serializeTimeProfile;\n/**\n * Converts v8 heap profile into into a profile proto.\n * (https://github.com/google/pprof/blob/master/proto/profile.proto)\n *\n * @param prof - profile to be converted.\n * @param startTimeNanos - start time of profile, in nanoseconds (POSIX time).\n * @param durationsNanos - duration of the profile (wall clock time) in\n * nanoseconds.\n * @param intervalBytes - bytes allocated between samples.\n */\nfunction serializeHeapProfile(prof, startTimeNanos, intervalBytes, ignoreSamplesPath, sourceMapper) {\n    const appendHeapEntryToSamples = (entry, samples) => {\n        if (entry.node.allocations.length > 0) {\n            for (const alloc of entry.node.allocations) {\n                const sample = new profile_1.perftools.profiles.Sample({\n                    locationId: entry.stack,\n                    value: [alloc.count, alloc.sizeBytes * alloc.count],\n                    // TODO: add tag for allocation size\n                });\n                samples.push(sample);\n            }\n        }\n    };\n    const stringTable = new StringTable();\n    const sampleValueType = createObjectCountValueType(stringTable);\n    const allocationValueType = createAllocationValueType(stringTable);\n    const profile = {\n        sampleType: [sampleValueType, allocationValueType],\n        timeNanos: startTimeNanos,\n        periodType: allocationValueType,\n        period: intervalBytes,\n    };\n    serialize(profile, prof, appendHeapEntryToSamples, stringTable, ignoreSamplesPath, sourceMapper);\n    return profile;\n}\nexports.serializeHeapProfile = serializeHeapProfile;\n//# sourceMappingURL=profile-serializer.js.map","\"use strict\";\n/**\n * Copyright 2016 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SourceMapper = void 0;\n// Originally copied from cloud-debug-nodejs's sourcemapper.ts from\n// https://github.com/googleapis/cloud-debug-nodejs/blob/7bdc2f1f62a3b45b7b53ea79f9444c8ed50e138b/src/agent/io/sourcemapper.ts\n// Modified to map from generated code to source code, rather than from source\n// code to generated code.\nconst fs = require(\"fs\");\nconst path = require(\"path\");\nconst sourceMap = require(\"source-map\");\nconst scanner = require(\"../../third_party/cloud-debug-nodejs/src/agent/io/scanner\");\nconst pify = require('pify');\nconst pLimit = require('p-limit');\nconst readFile = pify(fs.readFile);\nconst CONCURRENCY = 10;\nconst MAP_EXT = '.map';\n/**\n * @param {!Map} infoMap The map that maps input source files to\n *  SourceMapConsumer objects that are used to calculate mapping information\n * @param {string} mapPath The path to the source map file to process.  The\n *  path should be relative to the process's current working directory\n * @private\n */\nfunction processSourceMap(infoMap, mapPath) {\n    return __awaiter(this, void 0, void 0, function* () {\n        // this handles the case when the path is undefined, null, or\n        // the empty string\n        if (!mapPath || !mapPath.endsWith(MAP_EXT)) {\n            throw new Error(`The path \"${mapPath}\" does not specify a source map file`);\n        }\n        mapPath = path.normalize(mapPath);\n        let contents;\n        try {\n            contents = yield readFile(mapPath, 'utf8');\n        }\n        catch (e) {\n            throw new Error('Could not read source map file ' + mapPath + ': ' + e);\n        }\n        let consumer;\n        try {\n            // TODO: Determine how to reconsile the type conflict where `consumer`\n            //       is constructed as a SourceMapConsumer but is used as a\n            //       RawSourceMap.\n            // TODO: Resolve the cast of `contents as any` (This is needed because the\n            //       type is expected to be of `RawSourceMap` but the existing\n            //       working code uses a string.)\n            consumer = (yield new sourceMap.SourceMapConsumer(contents));\n        }\n        catch (e) {\n            throw new Error('An error occurred while reading the ' +\n                'sourceMap file ' +\n                mapPath +\n                ': ' +\n                e);\n        }\n        /*\n         * If the source map file defines a \"file\" attribute, use it as\n         * the output file where the path is relative to the directory\n         * containing the map file.  Otherwise, use the name of the output\n         * file (with the .map extension removed) as the output file.\n         */\n        const dir = path.dirname(mapPath);\n        const generatedBase = consumer.file\n            ? consumer.file\n            : path.basename(mapPath, MAP_EXT);\n        const generatedPath = path.resolve(dir, generatedBase);\n        infoMap.set(generatedPath, { mapFileDir: dir, mapConsumer: consumer });\n    });\n}\nclass SourceMapper {\n    /**\n     * @param {Array.<string>} sourceMapPaths An array of paths to .map source map\n     *  files that should be processed.  The paths should be relative to the\n     *  current process's current working directory\n     * @param {Logger} logger A logger that reports errors that occurred while\n     *  processing the given source map files\n     * @constructor\n     */\n    constructor() {\n        this.infoMap = new Map();\n    }\n    static create(searchDirs) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const mapFiles = [];\n            for (const dir of searchDirs) {\n                try {\n                    const mf = yield getMapFiles(dir);\n                    mf.forEach(mapFile => {\n                        mapFiles.push(path.resolve(dir, mapFile));\n                    });\n                }\n                catch (e) {\n                    throw new Error(`failed to get source maps from ${dir}: ${e}`);\n                }\n            }\n            return createFromMapFiles(mapFiles);\n        });\n    }\n    /**\n     * Used to get the information about the transpiled file from a given input\n     * source file provided there isn't any ambiguity with associating the input\n     * path to exactly one output transpiled file.\n     *\n     * @param inputPath The (possibly relative) path to the original source file.\n     * @return The `MapInfoCompiled` object that describes the transpiled file\n     *  associated with the specified input path.  `null` is returned if either\n     *  zero files are associated with the input path or if more than one file\n     *  could possibly be associated with the given input path.\n     */\n    getMappingInfo(inputPath) {\n        if (this.infoMap.has(path.normalize(inputPath))) {\n            return this.infoMap.get(inputPath);\n        }\n        return null;\n    }\n    /**\n     * Used to determine if the source file specified by the given path has\n     * a .map file and an output file associated with it.\n     *\n     * If there is no such mapping, it could be because the input file is not\n     * the input to a transpilation process or it is the input to a transpilation\n     * process but its corresponding .map file was not given to the constructor\n     * of this mapper.\n     *\n     * @param {string} inputPath The path to an input file that could\n     *  possibly be the input to a transpilation process.  The path should be\n     *  relative to the process's current working directory.\n     */\n    hasMappingInfo(inputPath) {\n        return this.getMappingInfo(inputPath) !== null;\n    }\n    /**\n     * @param {string} inputPath The path to an input file that could possibly\n     *  be the input to a transpilation process.  The path should be relative to\n     *  the process's current working directory\n     * @param {number} The line number in the input file where the line number is\n     *   zero-based.\n     * @param {number} (Optional) The column number in the line of the file\n     *   specified where the column number is zero-based.\n     * @return {Object} The object returned has a \"file\" attribute for the\n     *   path of the output file associated with the given input file (where the\n     *   path is relative to the process's current working directory),\n     *   a \"line\" attribute of the line number in the output file associated with\n     *   the given line number for the input file, and an optional \"column\" number\n     *   of the column number of the output file associated with the given file\n     *   and line information.\n     *\n     *   If the given input file does not have mapping information associated\n     *   with it then the input location is returned.\n     */\n    mappingInfo(location) {\n        const inputPath = path.normalize(location.file);\n        const entry = this.getMappingInfo(inputPath);\n        if (entry === null) {\n            return location;\n        }\n        const generatedPos = { line: location.line, column: location.column };\n        // TODO: Determine how to remove the explicit cast here.\n        const consumer = entry.mapConsumer;\n        const pos = consumer.originalPositionFor(generatedPos);\n        if (pos.source === null) {\n            return location;\n        }\n        return {\n            file: path.resolve(entry.mapFileDir, pos.source),\n            line: pos.line || undefined,\n            name: pos.name || location.name,\n            column: pos.column || undefined,\n        };\n    }\n}\nexports.SourceMapper = SourceMapper;\nfunction createFromMapFiles(mapFiles) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const limit = pLimit(CONCURRENCY);\n        const mapper = new SourceMapper();\n        const promises = mapFiles.map(mapPath => limit(() => processSourceMap(mapper.infoMap, mapPath)));\n        try {\n            yield Promise.all(promises);\n        }\n        catch (err) {\n            throw new Error('An error occurred while processing the source map files' + err);\n        }\n        return mapper;\n    });\n}\nfunction getMapFiles(baseDir) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const fileStats = yield scanner.scan(false, baseDir, /.js.map$/);\n        const mapFiles = fileStats.selectFiles(/.js.map$/, process.cwd());\n        return mapFiles;\n    });\n}\n//# sourceMappingURL=sourcemapper.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TimeProfiler = void 0;\n/**\n * Copyright 2018 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst path_1 = require(\"path\");\nconst findBinding = require('node-gyp-build');\nconst profiler = findBinding(path_1.join(__dirname, '..', '..'));\nexports.TimeProfiler = profiler.TimeProfiler;\n//# sourceMappingURL=time-profiler-bindings.js.map","\"use strict\";\n/**\n * Copyright 2017 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.start = exports.profile = void 0;\nconst delay_1 = require(\"delay\");\nconst profile_serializer_1 = require(\"./profile-serializer\");\nconst time_profiler_bindings_1 = require(\"./time-profiler-bindings\");\nconst DEFAULT_INTERVAL_MICROS = 1000;\nconst majorVersion = process.version.slice(1).split('.').map(Number)[0];\nfunction profile(options) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const stop = start(options.intervalMicros || DEFAULT_INTERVAL_MICROS, options.name, options.sourceMapper, options.lineNumbers);\n        yield delay_1.default(options.durationMillis);\n        return stop();\n    });\n}\nexports.profile = profile;\nfunction ensureRunName(name) {\n    return name || `pprof-${Date.now()}-${Math.random()}`;\n}\n// NOTE: refreshing doesn't work if giving a profile name.\nfunction start(intervalMicros = DEFAULT_INTERVAL_MICROS, name, sourceMapper, lineNumbers = true) {\n    const profiler = new time_profiler_bindings_1.TimeProfiler(intervalMicros);\n    let runName = start();\n    return majorVersion < 16 ? stopOld : stop;\n    function start() {\n        const runName = ensureRunName(name);\n        profiler.start(runName, lineNumbers);\n        return runName;\n    }\n    // Node.js versions prior to v16 leak memory if not disposed and recreated\n    // between each profile. As disposing deletes current profile data too,\n    // we must stop then dispose then start.\n    function stopOld(restart = false) {\n        const result = profiler.stop(runName, lineNumbers);\n        profiler.dispose();\n        if (restart) {\n            runName = start();\n        }\n        return profile_serializer_1.serializeTimeProfile(result, intervalMicros, sourceMapper);\n    }\n    // For Node.js v16+, we want to start the next profile before we stop the\n    // current one as otherwise the active profile count could reach zero which\n    // means V8 might tear down the symbolizer thread and need to start it again.\n    function stop(restart = false) {\n        let nextRunName;\n        if (restart) {\n            nextRunName = start();\n        }\n        const result = profiler.stop(runName, lineNumbers);\n        if (nextRunName) {\n            runName = nextRunName;\n        }\n        if (!restart)\n            profiler.dispose();\n        return profile_serializer_1.serializeTimeProfile(result, intervalMicros, sourceMapper);\n    }\n}\nexports.start = start;\n//# sourceMappingURL=time-profiler.js.map","\"use strict\";\n/**\n * Copyright 2015 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.scan = void 0;\nconst crypto = require(\"crypto\");\nconst fs = require(\"fs\");\nconst path = require(\"path\");\n// TODO: Make this more precise.\nconst findit = require('findit2');\n// TODO: Make this more precise.\nconst split = require('split');\nclass ScanResultsImpl {\n    /**\n     * Encapsulates the results of a filesystem scan with methods\n     * to easily select scan information or filenames for a\n     * specific subset of the files listed in the scan results.\n     *\n     * @param stats An object that contains filenames\n     *  as keys where each key maps to an object containing the\n     *  hash and number of lines for the specified file.  This\n     *  information is accessed via the `hash` and `lines`\n     *  attributes respectively\n     * @param hash A hashcode computed from the contents of all the files.\n     */\n    constructor(stats, errorMap, hash) {\n        this.stats = stats;\n        this.errorMap = errorMap;\n        this.hash = hash;\n    }\n    errors() {\n        return this.errorMap;\n    }\n    /**\n     * Used to get all of the file scan results.\n     */\n    all() {\n        return this.stats;\n    }\n    /**\n     * Used to get the only the file paths in the scan results\n     * where the filenames match the specified regex and are\n     * returned with the each relative to the specified base\n     * directory.\n     *\n     * @param {regex} regex The regex that tests a filename to\n     *  determine if the scan results for that filename should\n     *  be included in the returned results.\n     * @param {string} baseDir The absolute path to the directory\n     *  from which all of the returned paths should be relative\n     *  to.\n     */\n    selectFiles(regex, baseDir) {\n        // ensure the base directory has only a single trailing path separator\n        baseDir = path.normalize(baseDir + path.sep);\n        return Object.keys(this.stats)\n            .filter(file => {\n            return file && regex.test(file);\n        })\n            .map(file => {\n            return path.normalize(file).replace(baseDir, '');\n        });\n    }\n}\nfunction scan(shouldHash, baseDir, regex) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const fileList = yield findFiles(baseDir, regex);\n        return computeStats(fileList, shouldHash);\n    });\n}\nexports.scan = scan;\n/**\n * This function accept an array of filenames and computes a unique hash-code\n * based on the contents.\n *\n * @param {!Array<string>} fileList array of filenames\n * @param {Boolean} shouldHash whether a hash should be computed\n * @param {!function(?Error, ?string, Object)} callback error-back style callback\n *    returning the hash-code and an object containing file statistics.\n */\n// TODO: Typescript: Fix the docs associated with this function to match the\n// call signature\nfunction computeStats(fileList, shouldHash) {\n    // eslint-disable-next-line no-async-promise-executor\n    return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {\n        // return a valid, if fake, result when there are no js files to hash.\n        if (fileList.length === 0) {\n            resolve(new ScanResultsImpl({}, new Map(), 'EMPTY-no-js-files'));\n            return;\n        }\n        // TODO: Address the case where the array contains `undefined`.\n        const hashes = [];\n        const statistics = {};\n        const errors = new Map();\n        for (const filename of fileList) {\n            try {\n                const fileStats = yield statsForFile(filename, shouldHash);\n                if (shouldHash) {\n                    hashes.push(fileStats.hash);\n                }\n                statistics[filename] = fileStats;\n            }\n            catch (err) {\n                errors.set(filename, err);\n            }\n        }\n        let hash;\n        if (shouldHash) {\n            // Sort the hashes to get a deterministic order as the files may\n            // not be in the same order each time we scan the disk.\n            const buffer = hashes.sort().join();\n            const sha1 = crypto.createHash('sha1').update(buffer).digest('hex');\n            hash = 'SHA1-' + sha1;\n        }\n        resolve(new ScanResultsImpl(statistics, errors, hash));\n    }));\n}\n/**\n * Given a base-directory, this function scans the subtree and finds all the js\n * files. .git and node_module subdirectories are ignored.\n * @param {!string} baseDir top-level directory to scan\n * @param {!regex} regex the regular expression that specifies the types of\n *  files to find based on their filename\n * @param {!function(?Error, Array<string>)} callback error-back callback\n */\nfunction findFiles(baseDir, regex) {\n    return new Promise((resolve, reject) => {\n        let error;\n        if (!baseDir) {\n            reject(new Error('hasher.findJSFiles requires a baseDir argument'));\n            return;\n        }\n        const find = findit(baseDir);\n        const fileList = [];\n        find.on('error', (err) => {\n            error = err;\n            return;\n        });\n        find.on('directory', (dir, ignore, stop) => {\n            const base = path.basename(dir);\n            if (base === '.git' || base === 'node_modules') {\n                stop(); // do not descend\n            }\n        });\n        find.on('file', (file) => {\n            if (regex.test(file)) {\n                fileList.push(file);\n            }\n        });\n        find.on('end', () => {\n            // Note: the `end` event fires even after an error\n            if (error) {\n                reject(error);\n            }\n            else {\n                resolve(fileList);\n            }\n        });\n    });\n}\n/**\n * Compute a sha hash for the given file and record line counts along the way.\n * @param {string} filename\n * @param {Boolean} shouldHash whether a hash should be computed\n * @param {function} cb errorback style callback which returns the sha string\n * @private\n */\nfunction statsForFile(filename, shouldHash) {\n    return new Promise((resolve, reject) => {\n        const reader = fs.createReadStream(filename);\n        reader.on('error', err => {\n            reject(err);\n        });\n        reader.on('open', () => {\n            let shasum;\n            if (shouldHash) {\n                shasum = crypto.createHash('sha1');\n            }\n            let lines = 0;\n            let error;\n            const byLine = reader.pipe(split());\n            byLine.on('error', (e) => {\n                error = e;\n            });\n            byLine.on('data', (d) => {\n                if (shouldHash) {\n                    shasum.update(d);\n                }\n                lines++;\n            });\n            byLine.on('end', () => {\n                if (error) {\n                    reject(error);\n                }\n                else {\n                    const hash = shouldHash ? shasum.digest('hex') : undefined;\n                    resolve({ hash, lines });\n                }\n            });\n        });\n    });\n}\n//# sourceMappingURL=scanner.js.map","/*eslint-disable block-scoped-var, no-redeclare, no-control-regex, no-prototype-builtins*/\n\"use strict\";\n\nvar $protobuf = require(\"protobufjs/minimal\");\n\n// Common aliases\nvar $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;\n\n// Exported root namespace\nvar $root = $protobuf.roots[\"default\"] || ($protobuf.roots[\"default\"] = {});\n\n$root.perftools = (function() {\n\n    /**\n     * Namespace perftools.\n     * @exports perftools\n     * @namespace\n     */\n    var perftools = {};\n\n    perftools.profiles = (function() {\n\n        /**\n         * Namespace profiles.\n         * @memberof perftools\n         * @namespace\n         */\n        var profiles = {};\n\n        profiles.Profile = (function() {\n\n            /**\n             * Properties of a Profile.\n             * @memberof perftools.profiles\n             * @interface IProfile\n             * @property {Array.<perftools.profiles.IValueType>} [sampleType] Profile sampleType\n             * @property {Array.<perftools.profiles.ISample>} [sample] Profile sample\n             * @property {Array.<perftools.profiles.IMapping>} [mapping] Profile mapping\n             * @property {Array.<perftools.profiles.ILocation>} [location] Profile location\n             * @property {Array.<perftools.profiles.IFunction>} [\"function\"] Profile function\n             * @property {Array.<string>} [stringTable] Profile stringTable\n             * @property {number|Long} [dropFrames] Profile dropFrames\n             * @property {number|Long} [keepFrames] Profile keepFrames\n             * @property {number|Long} [timeNanos] Profile timeNanos\n             * @property {number|Long} [durationNanos] Profile durationNanos\n             * @property {perftools.profiles.IValueType} [periodType] Profile periodType\n             * @property {number|Long} [period] Profile period\n             * @property {Array.<number|Long>} [comment] Profile comment\n             * @property {number|Long} [defaultSampleType] Profile defaultSampleType\n             */\n\n            /**\n             * Constructs a new Profile.\n             * @memberof perftools.profiles\n             * @classdesc Represents a Profile.\n             * @constructor\n             * @param {perftools.profiles.IProfile=} [properties] Properties to set\n             */\n            function Profile(properties) {\n                this.sampleType = [];\n                this.sample = [];\n                this.mapping = [];\n                this.location = [];\n                this[\"function\"] = [];\n                this.stringTable = [];\n                this.comment = [];\n                if (properties)\n                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }\n\n            /**\n             * Profile sampleType.\n             * @member {Array.<perftools.profiles.IValueType>}sampleType\n             * @memberof perftools.profiles.Profile\n             * @instance\n             */\n            Profile.prototype.sampleType = $util.emptyArray;\n\n            /**\n             * Profile sample.\n             * @member {Array.<perftools.profiles.ISample>}sample\n             * @memberof perftools.profiles.Profile\n             * @instance\n             */\n            Profile.prototype.sample = $util.emptyArray;\n\n            /**\n             * Profile mapping.\n             * @member {Array.<perftools.profiles.IMapping>}mapping\n             * @memberof perftools.profiles.Profile\n             * @instance\n             */\n            Profile.prototype.mapping = $util.emptyArray;\n\n            /**\n             * Profile location.\n             * @member {Array.<perftools.profiles.ILocation>}location\n             * @memberof perftools.profiles.Profile\n             * @instance\n             */\n            Profile.prototype.location = $util.emptyArray;\n\n            /**\n             * Profile function.\n             * @member {Array.<perftools.profiles.IFunction>}function_\n             * @memberof perftools.profiles.Profile\n             * @instance\n             */\n            Profile.prototype[\"function\"] = $util.emptyArray;\n\n            /**\n             * Profile stringTable.\n             * @member {Array.<string>}stringTable\n             * @memberof perftools.profiles.Profile\n             * @instance\n             */\n            Profile.prototype.stringTable = $util.emptyArray;\n\n            /**\n             * Profile dropFrames.\n             * @member {number|Long}dropFrames\n             * @memberof perftools.profiles.Profile\n             * @instance\n             */\n            Profile.prototype.dropFrames = $util.Long ? $util.Long.fromBits(0,0,false) : 0;\n\n            /**\n             * Profile keepFrames.\n             * @member {number|Long}keepFrames\n             * @memberof perftools.profiles.Profile\n             * @instance\n             */\n            Profile.prototype.keepFrames = $util.Long ? $util.Long.fromBits(0,0,false) : 0;\n\n            /**\n             * Profile timeNanos.\n             * @member {number|Long}timeNanos\n             * @memberof perftools.profiles.Profile\n             * @instance\n             */\n            Profile.prototype.timeNanos = $util.Long ? $util.Long.fromBits(0,0,false) : 0;\n\n            /**\n             * Profile durationNanos.\n             * @member {number|Long}durationNanos\n             * @memberof perftools.profiles.Profile\n             * @instance\n             */\n            Profile.prototype.durationNanos = $util.Long ? $util.Long.fromBits(0,0,false) : 0;\n\n            /**\n             * Profile periodType.\n             * @member {(perftools.profiles.IValueType|null|undefined)}periodType\n             * @memberof perftools.profiles.Profile\n             * @instance\n             */\n            Profile.prototype.periodType = null;\n\n            /**\n             * Profile period.\n             * @member {number|Long}period\n             * @memberof perftools.profiles.Profile\n             * @instance\n             */\n            Profile.prototype.period = $util.Long ? $util.Long.fromBits(0,0,false) : 0;\n\n            /**\n             * Profile comment.\n             * @member {Array.<number|Long>}comment\n             * @memberof perftools.profiles.Profile\n             * @instance\n             */\n            Profile.prototype.comment = $util.emptyArray;\n\n            /**\n             * Profile defaultSampleType.\n             * @member {number|Long}defaultSampleType\n             * @memberof perftools.profiles.Profile\n             * @instance\n             */\n            Profile.prototype.defaultSampleType = $util.Long ? $util.Long.fromBits(0,0,false) : 0;\n\n            /**\n             * Creates a new Profile instance using the specified properties.\n             * @function create\n             * @memberof perftools.profiles.Profile\n             * @static\n             * @param {perftools.profiles.IProfile=} [properties] Properties to set\n             * @returns {perftools.profiles.Profile} Profile instance\n             */\n            Profile.create = function create(properties) {\n                return new Profile(properties);\n            };\n\n            /**\n             * Encodes the specified Profile message. Does not implicitly {@link perftools.profiles.Profile.verify|verify} messages.\n             * @function encode\n             * @memberof perftools.profiles.Profile\n             * @static\n             * @param {perftools.profiles.IProfile} message Profile message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            Profile.encode = function encode(message, writer) {\n                if (!writer)\n                    writer = $Writer.create();\n                if (message.sampleType != null && message.sampleType.length)\n                    for (var i = 0; i < message.sampleType.length; ++i)\n                        $root.perftools.profiles.ValueType.encode(message.sampleType[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                if (message.sample != null && message.sample.length)\n                    for (var i = 0; i < message.sample.length; ++i)\n                        $root.perftools.profiles.Sample.encode(message.sample[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n                if (message.mapping != null && message.mapping.length)\n                    for (var i = 0; i < message.mapping.length; ++i)\n                        $root.perftools.profiles.Mapping.encode(message.mapping[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();\n                if (message.location != null && message.location.length)\n                    for (var i = 0; i < message.location.length; ++i)\n                        $root.perftools.profiles.Location.encode(message.location[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();\n                if (message[\"function\"] != null && message[\"function\"].length)\n                    for (var i = 0; i < message[\"function\"].length; ++i)\n                        $root.perftools.profiles.Function.encode(message[\"function\"][i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();\n                if (message.stringTable != null && message.stringTable.length)\n                    for (var i = 0; i < message.stringTable.length; ++i)\n                        writer.uint32(/* id 6, wireType 2 =*/50).string(message.stringTable[i]);\n                if (message.dropFrames != null && message.hasOwnProperty(\"dropFrames\"))\n                    writer.uint32(/* id 7, wireType 0 =*/56).int64(message.dropFrames);\n                if (message.keepFrames != null && message.hasOwnProperty(\"keepFrames\"))\n                    writer.uint32(/* id 8, wireType 0 =*/64).int64(message.keepFrames);\n                if (message.timeNanos != null && message.hasOwnProperty(\"timeNanos\"))\n                    writer.uint32(/* id 9, wireType 0 =*/72).int64(message.timeNanos);\n                if (message.durationNanos != null && message.hasOwnProperty(\"durationNanos\"))\n                    writer.uint32(/* id 10, wireType 0 =*/80).int64(message.durationNanos);\n                if (message.periodType != null && message.hasOwnProperty(\"periodType\"))\n                    $root.perftools.profiles.ValueType.encode(message.periodType, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();\n                if (message.period != null && message.hasOwnProperty(\"period\"))\n                    writer.uint32(/* id 12, wireType 0 =*/96).int64(message.period);\n                if (message.comment != null && message.comment.length) {\n                    writer.uint32(/* id 13, wireType 2 =*/106).fork();\n                    for (var i = 0; i < message.comment.length; ++i)\n                        writer.int64(message.comment[i]);\n                    writer.ldelim();\n                }\n                if (message.defaultSampleType != null && message.hasOwnProperty(\"defaultSampleType\"))\n                    writer.uint32(/* id 14, wireType 0 =*/112).int64(message.defaultSampleType);\n                return writer;\n            };\n\n            /**\n             * Encodes the specified Profile message, length delimited. Does not implicitly {@link perftools.profiles.Profile.verify|verify} messages.\n             * @function encodeDelimited\n             * @memberof perftools.profiles.Profile\n             * @static\n             * @param {perftools.profiles.IProfile} message Profile message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            Profile.encodeDelimited = function encodeDelimited(message, writer) {\n                return this.encode(message, writer).ldelim();\n            };\n\n            /**\n             * Decodes a Profile message from the specified reader or buffer.\n             * @function decode\n             * @memberof perftools.profiles.Profile\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {perftools.profiles.Profile} Profile\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            Profile.decode = function decode(reader, length) {\n                if (!(reader instanceof $Reader))\n                    reader = $Reader.create(reader);\n                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.perftools.profiles.Profile();\n                while (reader.pos < end) {\n                    var tag = reader.uint32();\n                    switch (tag >>> 3) {\n                    case 1:\n                        if (!(message.sampleType && message.sampleType.length))\n                            message.sampleType = [];\n                        message.sampleType.push($root.perftools.profiles.ValueType.decode(reader, reader.uint32()));\n                        break;\n                    case 2:\n                        if (!(message.sample && message.sample.length))\n                            message.sample = [];\n                        message.sample.push($root.perftools.profiles.Sample.decode(reader, reader.uint32()));\n                        break;\n                    case 3:\n                        if (!(message.mapping && message.mapping.length))\n                            message.mapping = [];\n                        message.mapping.push($root.perftools.profiles.Mapping.decode(reader, reader.uint32()));\n                        break;\n                    case 4:\n                        if (!(message.location && message.location.length))\n                            message.location = [];\n                        message.location.push($root.perftools.profiles.Location.decode(reader, reader.uint32()));\n                        break;\n                    case 5:\n                        if (!(message[\"function\"] && message[\"function\"].length))\n                            message[\"function\"] = [];\n                        message[\"function\"].push($root.perftools.profiles.Function.decode(reader, reader.uint32()));\n                        break;\n                    case 6:\n                        if (!(message.stringTable && message.stringTable.length))\n                            message.stringTable = [];\n                        message.stringTable.push(reader.string());\n                        break;\n                    case 7:\n                        message.dropFrames = reader.int64();\n                        break;\n                    case 8:\n                        message.keepFrames = reader.int64();\n                        break;\n                    case 9:\n                        message.timeNanos = reader.int64();\n                        break;\n                    case 10:\n                        message.durationNanos = reader.int64();\n                        break;\n                    case 11:\n                        message.periodType = $root.perftools.profiles.ValueType.decode(reader, reader.uint32());\n                        break;\n                    case 12:\n                        message.period = reader.int64();\n                        break;\n                    case 13:\n                        if (!(message.comment && message.comment.length))\n                            message.comment = [];\n                        if ((tag & 7) === 2) {\n                            var end2 = reader.uint32() + reader.pos;\n                            while (reader.pos < end2)\n                                message.comment.push(reader.int64());\n                        } else\n                            message.comment.push(reader.int64());\n                        break;\n                    case 14:\n                        message.defaultSampleType = reader.int64();\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                    }\n                }\n                return message;\n            };\n\n            /**\n             * Decodes a Profile message from the specified reader or buffer, length delimited.\n             * @function decodeDelimited\n             * @memberof perftools.profiles.Profile\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @returns {perftools.profiles.Profile} Profile\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            Profile.decodeDelimited = function decodeDelimited(reader) {\n                if (!(reader instanceof $Reader))\n                    reader = new $Reader(reader);\n                return this.decode(reader, reader.uint32());\n            };\n\n            /**\n             * Verifies a Profile message.\n             * @function verify\n             * @memberof perftools.profiles.Profile\n             * @static\n             * @param {Object.<string,*>} message Plain object to verify\n             * @returns {string|null} `null` if valid, otherwise the reason why it is not\n             */\n            Profile.verify = function verify(message) {\n                if (typeof message !== \"object\" || message === null)\n                    return \"object expected\";\n                if (message.sampleType != null && message.hasOwnProperty(\"sampleType\")) {\n                    if (!Array.isArray(message.sampleType))\n                        return \"sampleType: array expected\";\n                    for (var i = 0; i < message.sampleType.length; ++i) {\n                        var error = $root.perftools.profiles.ValueType.verify(message.sampleType[i]);\n                        if (error)\n                            return \"sampleType.\" + error;\n                    }\n                }\n                if (message.sample != null && message.hasOwnProperty(\"sample\")) {\n                    if (!Array.isArray(message.sample))\n                        return \"sample: array expected\";\n                    for (var i = 0; i < message.sample.length; ++i) {\n                        error = $root.perftools.profiles.Sample.verify(message.sample[i]);\n                        if (error)\n                            return \"sample.\" + error;\n                    }\n                }\n                if (message.mapping != null && message.hasOwnProperty(\"mapping\")) {\n                    if (!Array.isArray(message.mapping))\n                        return \"mapping: array expected\";\n                    for (var i = 0; i < message.mapping.length; ++i) {\n                        error = $root.perftools.profiles.Mapping.verify(message.mapping[i]);\n                        if (error)\n                            return \"mapping.\" + error;\n                    }\n                }\n                if (message.location != null && message.hasOwnProperty(\"location\")) {\n                    if (!Array.isArray(message.location))\n                        return \"location: array expected\";\n                    for (var i = 0; i < message.location.length; ++i) {\n                        error = $root.perftools.profiles.Location.verify(message.location[i]);\n                        if (error)\n                            return \"location.\" + error;\n                    }\n                }\n                if (message[\"function\"] != null && message.hasOwnProperty(\"function\")) {\n                    if (!Array.isArray(message[\"function\"]))\n                        return \"function: array expected\";\n                    for (var i = 0; i < message[\"function\"].length; ++i) {\n                        error = $root.perftools.profiles.Function.verify(message[\"function\"][i]);\n                        if (error)\n                            return \"function.\" + error;\n                    }\n                }\n                if (message.stringTable != null && message.hasOwnProperty(\"stringTable\")) {\n                    if (!Array.isArray(message.stringTable))\n                        return \"stringTable: array expected\";\n                    for (var i = 0; i < message.stringTable.length; ++i)\n                        if (!$util.isString(message.stringTable[i]))\n                            return \"stringTable: string[] expected\";\n                }\n                if (message.dropFrames != null && message.hasOwnProperty(\"dropFrames\"))\n                    if (!$util.isInteger(message.dropFrames) && !(message.dropFrames && $util.isInteger(message.dropFrames.low) && $util.isInteger(message.dropFrames.high)))\n                        return \"dropFrames: integer|Long expected\";\n                if (message.keepFrames != null && message.hasOwnProperty(\"keepFrames\"))\n                    if (!$util.isInteger(message.keepFrames) && !(message.keepFrames && $util.isInteger(message.keepFrames.low) && $util.isInteger(message.keepFrames.high)))\n                        return \"keepFrames: integer|Long expected\";\n                if (message.timeNanos != null && message.hasOwnProperty(\"timeNanos\"))\n                    if (!$util.isInteger(message.timeNanos) && !(message.timeNanos && $util.isInteger(message.timeNanos.low) && $util.isInteger(message.timeNanos.high)))\n                        return \"timeNanos: integer|Long expected\";\n                if (message.durationNanos != null && message.hasOwnProperty(\"durationNanos\"))\n                    if (!$util.isInteger(message.durationNanos) && !(message.durationNanos && $util.isInteger(message.durationNanos.low) && $util.isInteger(message.durationNanos.high)))\n                        return \"durationNanos: integer|Long expected\";\n                if (message.periodType != null && message.hasOwnProperty(\"periodType\")) {\n                    error = $root.perftools.profiles.ValueType.verify(message.periodType);\n                    if (error)\n                        return \"periodType.\" + error;\n                }\n                if (message.period != null && message.hasOwnProperty(\"period\"))\n                    if (!$util.isInteger(message.period) && !(message.period && $util.isInteger(message.period.low) && $util.isInteger(message.period.high)))\n                        return \"period: integer|Long expected\";\n                if (message.comment != null && message.hasOwnProperty(\"comment\")) {\n                    if (!Array.isArray(message.comment))\n                        return \"comment: array expected\";\n                    for (var i = 0; i < message.comment.length; ++i)\n                        if (!$util.isInteger(message.comment[i]) && !(message.comment[i] && $util.isInteger(message.comment[i].low) && $util.isInteger(message.comment[i].high)))\n                            return \"comment: integer|Long[] expected\";\n                }\n                if (message.defaultSampleType != null && message.hasOwnProperty(\"defaultSampleType\"))\n                    if (!$util.isInteger(message.defaultSampleType) && !(message.defaultSampleType && $util.isInteger(message.defaultSampleType.low) && $util.isInteger(message.defaultSampleType.high)))\n                        return \"defaultSampleType: integer|Long expected\";\n                return null;\n            };\n\n            /**\n             * Creates a Profile message from a plain object. Also converts values to their respective internal types.\n             * @function fromObject\n             * @memberof perftools.profiles.Profile\n             * @static\n             * @param {Object.<string,*>} object Plain object\n             * @returns {perftools.profiles.Profile} Profile\n             */\n            Profile.fromObject = function fromObject(object) {\n                if (object instanceof $root.perftools.profiles.Profile)\n                    return object;\n                var message = new $root.perftools.profiles.Profile();\n                if (object.sampleType) {\n                    if (!Array.isArray(object.sampleType))\n                        throw TypeError(\".perftools.profiles.Profile.sampleType: array expected\");\n                    message.sampleType = [];\n                    for (var i = 0; i < object.sampleType.length; ++i) {\n                        if (typeof object.sampleType[i] !== \"object\")\n                            throw TypeError(\".perftools.profiles.Profile.sampleType: object expected\");\n                        message.sampleType[i] = $root.perftools.profiles.ValueType.fromObject(object.sampleType[i]);\n                    }\n                }\n                if (object.sample) {\n                    if (!Array.isArray(object.sample))\n                        throw TypeError(\".perftools.profiles.Profile.sample: array expected\");\n                    message.sample = [];\n                    for (var i = 0; i < object.sample.length; ++i) {\n                        if (typeof object.sample[i] !== \"object\")\n                            throw TypeError(\".perftools.profiles.Profile.sample: object expected\");\n                        message.sample[i] = $root.perftools.profiles.Sample.fromObject(object.sample[i]);\n                    }\n                }\n                if (object.mapping) {\n                    if (!Array.isArray(object.mapping))\n                        throw TypeError(\".perftools.profiles.Profile.mapping: array expected\");\n                    message.mapping = [];\n                    for (var i = 0; i < object.mapping.length; ++i) {\n                        if (typeof object.mapping[i] !== \"object\")\n                            throw TypeError(\".perftools.profiles.Profile.mapping: object expected\");\n                        message.mapping[i] = $root.perftools.profiles.Mapping.fromObject(object.mapping[i]);\n                    }\n                }\n                if (object.location) {\n                    if (!Array.isArray(object.location))\n                        throw TypeError(\".perftools.profiles.Profile.location: array expected\");\n                    message.location = [];\n                    for (var i = 0; i < object.location.length; ++i) {\n                        if (typeof object.location[i] !== \"object\")\n                            throw TypeError(\".perftools.profiles.Profile.location: object expected\");\n                        message.location[i] = $root.perftools.profiles.Location.fromObject(object.location[i]);\n                    }\n                }\n                if (object[\"function\"]) {\n                    if (!Array.isArray(object[\"function\"]))\n                        throw TypeError(\".perftools.profiles.Profile.function: array expected\");\n                    message[\"function\"] = [];\n                    for (var i = 0; i < object[\"function\"].length; ++i) {\n                        if (typeof object[\"function\"][i] !== \"object\")\n                            throw TypeError(\".perftools.profiles.Profile.function: object expected\");\n                        message[\"function\"][i] = $root.perftools.profiles.Function.fromObject(object[\"function\"][i]);\n                    }\n                }\n                if (object.stringTable) {\n                    if (!Array.isArray(object.stringTable))\n                        throw TypeError(\".perftools.profiles.Profile.stringTable: array expected\");\n                    message.stringTable = [];\n                    for (var i = 0; i < object.stringTable.length; ++i)\n                        message.stringTable[i] = String(object.stringTable[i]);\n                }\n                if (object.dropFrames != null)\n                    if ($util.Long)\n                        (message.dropFrames = $util.Long.fromValue(object.dropFrames)).unsigned = false;\n                    else if (typeof object.dropFrames === \"string\")\n                        message.dropFrames = parseInt(object.dropFrames, 10);\n                    else if (typeof object.dropFrames === \"number\")\n                        message.dropFrames = object.dropFrames;\n                    else if (typeof object.dropFrames === \"object\")\n                        message.dropFrames = new $util.LongBits(object.dropFrames.low >>> 0, object.dropFrames.high >>> 0).toNumber();\n                if (object.keepFrames != null)\n                    if ($util.Long)\n                        (message.keepFrames = $util.Long.fromValue(object.keepFrames)).unsigned = false;\n                    else if (typeof object.keepFrames === \"string\")\n                        message.keepFrames = parseInt(object.keepFrames, 10);\n                    else if (typeof object.keepFrames === \"number\")\n                        message.keepFrames = object.keepFrames;\n                    else if (typeof object.keepFrames === \"object\")\n                        message.keepFrames = new $util.LongBits(object.keepFrames.low >>> 0, object.keepFrames.high >>> 0).toNumber();\n                if (object.timeNanos != null)\n                    if ($util.Long)\n                        (message.timeNanos = $util.Long.fromValue(object.timeNanos)).unsigned = false;\n                    else if (typeof object.timeNanos === \"string\")\n                        message.timeNanos = parseInt(object.timeNanos, 10);\n                    else if (typeof object.timeNanos === \"number\")\n                        message.timeNanos = object.timeNanos;\n                    else if (typeof object.timeNanos === \"object\")\n                        message.timeNanos = new $util.LongBits(object.timeNanos.low >>> 0, object.timeNanos.high >>> 0).toNumber();\n                if (object.durationNanos != null)\n                    if ($util.Long)\n                        (message.durationNanos = $util.Long.fromValue(object.durationNanos)).unsigned = false;\n                    else if (typeof object.durationNanos === \"string\")\n                        message.durationNanos = parseInt(object.durationNanos, 10);\n                    else if (typeof object.durationNanos === \"number\")\n                        message.durationNanos = object.durationNanos;\n                    else if (typeof object.durationNanos === \"object\")\n                        message.durationNanos = new $util.LongBits(object.durationNanos.low >>> 0, object.durationNanos.high >>> 0).toNumber();\n                if (object.periodType != null) {\n                    if (typeof object.periodType !== \"object\")\n                        throw TypeError(\".perftools.profiles.Profile.periodType: object expected\");\n                    message.periodType = $root.perftools.profiles.ValueType.fromObject(object.periodType);\n                }\n                if (object.period != null)\n                    if ($util.Long)\n                        (message.period = $util.Long.fromValue(object.period)).unsigned = false;\n                    else if (typeof object.period === \"string\")\n                        message.period = parseInt(object.period, 10);\n                    else if (typeof object.period === \"number\")\n                        message.period = object.period;\n                    else if (typeof object.period === \"object\")\n                        message.period = new $util.LongBits(object.period.low >>> 0, object.period.high >>> 0).toNumber();\n                if (object.comment) {\n                    if (!Array.isArray(object.comment))\n                        throw TypeError(\".perftools.profiles.Profile.comment: array expected\");\n                    message.comment = [];\n                    for (var i = 0; i < object.comment.length; ++i)\n                        if ($util.Long)\n                            (message.comment[i] = $util.Long.fromValue(object.comment[i])).unsigned = false;\n                        else if (typeof object.comment[i] === \"string\")\n                            message.comment[i] = parseInt(object.comment[i], 10);\n                        else if (typeof object.comment[i] === \"number\")\n                            message.comment[i] = object.comment[i];\n                        else if (typeof object.comment[i] === \"object\")\n                            message.comment[i] = new $util.LongBits(object.comment[i].low >>> 0, object.comment[i].high >>> 0).toNumber();\n                }\n                if (object.defaultSampleType != null)\n                    if ($util.Long)\n                        (message.defaultSampleType = $util.Long.fromValue(object.defaultSampleType)).unsigned = false;\n                    else if (typeof object.defaultSampleType === \"string\")\n                        message.defaultSampleType = parseInt(object.defaultSampleType, 10);\n                    else if (typeof object.defaultSampleType === \"number\")\n                        message.defaultSampleType = object.defaultSampleType;\n                    else if (typeof object.defaultSampleType === \"object\")\n                        message.defaultSampleType = new $util.LongBits(object.defaultSampleType.low >>> 0, object.defaultSampleType.high >>> 0).toNumber();\n                return message;\n            };\n\n            /**\n             * Creates a plain object from a Profile message. Also converts values to other types if specified.\n             * @function toObject\n             * @memberof perftools.profiles.Profile\n             * @static\n             * @param {perftools.profiles.Profile} message Profile\n             * @param {$protobuf.IConversionOptions} [options] Conversion options\n             * @returns {Object.<string,*>} Plain object\n             */\n            Profile.toObject = function toObject(message, options) {\n                if (!options)\n                    options = {};\n                var object = {};\n                if (options.arrays || options.defaults) {\n                    object.sampleType = [];\n                    object.sample = [];\n                    object.mapping = [];\n                    object.location = [];\n                    object[\"function\"] = [];\n                    object.stringTable = [];\n                    object.comment = [];\n                }\n                if (options.defaults) {\n                    if ($util.Long) {\n                        var long = new $util.Long(0, 0, false);\n                        object.dropFrames = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                    } else\n                        object.dropFrames = options.longs === String ? \"0\" : 0;\n                    if ($util.Long) {\n                        var long = new $util.Long(0, 0, false);\n                        object.keepFrames = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                    } else\n                        object.keepFrames = options.longs === String ? \"0\" : 0;\n                    if ($util.Long) {\n                        var long = new $util.Long(0, 0, false);\n                        object.timeNanos = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                    } else\n                        object.timeNanos = options.longs === String ? \"0\" : 0;\n                    if ($util.Long) {\n                        var long = new $util.Long(0, 0, false);\n                        object.durationNanos = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                    } else\n                        object.durationNanos = options.longs === String ? \"0\" : 0;\n                    object.periodType = null;\n                    if ($util.Long) {\n                        var long = new $util.Long(0, 0, false);\n                        object.period = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                    } else\n                        object.period = options.longs === String ? \"0\" : 0;\n                    if ($util.Long) {\n                        var long = new $util.Long(0, 0, false);\n                        object.defaultSampleType = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                    } else\n                        object.defaultSampleType = options.longs === String ? \"0\" : 0;\n                }\n                if (message.sampleType && message.sampleType.length) {\n                    object.sampleType = [];\n                    for (var j = 0; j < message.sampleType.length; ++j)\n                        object.sampleType[j] = $root.perftools.profiles.ValueType.toObject(message.sampleType[j], options);\n                }\n                if (message.sample && message.sample.length) {\n                    object.sample = [];\n                    for (var j = 0; j < message.sample.length; ++j)\n                        object.sample[j] = $root.perftools.profiles.Sample.toObject(message.sample[j], options);\n                }\n                if (message.mapping && message.mapping.length) {\n                    object.mapping = [];\n                    for (var j = 0; j < message.mapping.length; ++j)\n                        object.mapping[j] = $root.perftools.profiles.Mapping.toObject(message.mapping[j], options);\n                }\n                if (message.location && message.location.length) {\n                    object.location = [];\n                    for (var j = 0; j < message.location.length; ++j)\n                        object.location[j] = $root.perftools.profiles.Location.toObject(message.location[j], options);\n                }\n                if (message[\"function\"] && message[\"function\"].length) {\n                    object[\"function\"] = [];\n                    for (var j = 0; j < message[\"function\"].length; ++j)\n                        object[\"function\"][j] = $root.perftools.profiles.Function.toObject(message[\"function\"][j], options);\n                }\n                if (message.stringTable && message.stringTable.length) {\n                    object.stringTable = [];\n                    for (var j = 0; j < message.stringTable.length; ++j)\n                        object.stringTable[j] = message.stringTable[j];\n                }\n                if (message.dropFrames != null && message.hasOwnProperty(\"dropFrames\"))\n                    if (typeof message.dropFrames === \"number\")\n                        object.dropFrames = options.longs === String ? String(message.dropFrames) : message.dropFrames;\n                    else\n                        object.dropFrames = options.longs === String ? $util.Long.prototype.toString.call(message.dropFrames) : options.longs === Number ? new $util.LongBits(message.dropFrames.low >>> 0, message.dropFrames.high >>> 0).toNumber() : message.dropFrames;\n                if (message.keepFrames != null && message.hasOwnProperty(\"keepFrames\"))\n                    if (typeof message.keepFrames === \"number\")\n                        object.keepFrames = options.longs === String ? String(message.keepFrames) : message.keepFrames;\n                    else\n                        object.keepFrames = options.longs === String ? $util.Long.prototype.toString.call(message.keepFrames) : options.longs === Number ? new $util.LongBits(message.keepFrames.low >>> 0, message.keepFrames.high >>> 0).toNumber() : message.keepFrames;\n                if (message.timeNanos != null && message.hasOwnProperty(\"timeNanos\"))\n                    if (typeof message.timeNanos === \"number\")\n                        object.timeNanos = options.longs === String ? String(message.timeNanos) : message.timeNanos;\n                    else\n                        object.timeNanos = options.longs === String ? $util.Long.prototype.toString.call(message.timeNanos) : options.longs === Number ? new $util.LongBits(message.timeNanos.low >>> 0, message.timeNanos.high >>> 0).toNumber() : message.timeNanos;\n                if (message.durationNanos != null && message.hasOwnProperty(\"durationNanos\"))\n                    if (typeof message.durationNanos === \"number\")\n                        object.durationNanos = options.longs === String ? String(message.durationNanos) : message.durationNanos;\n                    else\n                        object.durationNanos = options.longs === String ? $util.Long.prototype.toString.call(message.durationNanos) : options.longs === Number ? new $util.LongBits(message.durationNanos.low >>> 0, message.durationNanos.high >>> 0).toNumber() : message.durationNanos;\n                if (message.periodType != null && message.hasOwnProperty(\"periodType\"))\n                    object.periodType = $root.perftools.profiles.ValueType.toObject(message.periodType, options);\n                if (message.period != null && message.hasOwnProperty(\"period\"))\n                    if (typeof message.period === \"number\")\n                        object.period = options.longs === String ? String(message.period) : message.period;\n                    else\n                        object.period = options.longs === String ? $util.Long.prototype.toString.call(message.period) : options.longs === Number ? new $util.LongBits(message.period.low >>> 0, message.period.high >>> 0).toNumber() : message.period;\n                if (message.comment && message.comment.length) {\n                    object.comment = [];\n                    for (var j = 0; j < message.comment.length; ++j)\n                        if (typeof message.comment[j] === \"number\")\n                            object.comment[j] = options.longs === String ? String(message.comment[j]) : message.comment[j];\n                        else\n                            object.comment[j] = options.longs === String ? $util.Long.prototype.toString.call(message.comment[j]) : options.longs === Number ? new $util.LongBits(message.comment[j].low >>> 0, message.comment[j].high >>> 0).toNumber() : message.comment[j];\n                }\n                if (message.defaultSampleType != null && message.hasOwnProperty(\"defaultSampleType\"))\n                    if (typeof message.defaultSampleType === \"number\")\n                        object.defaultSampleType = options.longs === String ? String(message.defaultSampleType) : message.defaultSampleType;\n                    else\n                        object.defaultSampleType = options.longs === String ? $util.Long.prototype.toString.call(message.defaultSampleType) : options.longs === Number ? new $util.LongBits(message.defaultSampleType.low >>> 0, message.defaultSampleType.high >>> 0).toNumber() : message.defaultSampleType;\n                return object;\n            };\n\n            /**\n             * Converts this Profile to JSON.\n             * @function toJSON\n             * @memberof perftools.profiles.Profile\n             * @instance\n             * @returns {Object.<string,*>} JSON object\n             */\n            Profile.prototype.toJSON = function toJSON() {\n                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n            };\n\n            return Profile;\n        })();\n\n        profiles.ValueType = (function() {\n\n            /**\n             * Properties of a ValueType.\n             * @memberof perftools.profiles\n             * @interface IValueType\n             * @property {number|Long} [type] ValueType type\n             * @property {number|Long} [unit] ValueType unit\n             */\n\n            /**\n             * Constructs a new ValueType.\n             * @memberof perftools.profiles\n             * @classdesc Represents a ValueType.\n             * @constructor\n             * @param {perftools.profiles.IValueType=} [properties] Properties to set\n             */\n            function ValueType(properties) {\n                if (properties)\n                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }\n\n            /**\n             * ValueType type.\n             * @member {number|Long}type\n             * @memberof perftools.profiles.ValueType\n             * @instance\n             */\n            ValueType.prototype.type = $util.Long ? $util.Long.fromBits(0,0,false) : 0;\n\n            /**\n             * ValueType unit.\n             * @member {number|Long}unit\n             * @memberof perftools.profiles.ValueType\n             * @instance\n             */\n            ValueType.prototype.unit = $util.Long ? $util.Long.fromBits(0,0,false) : 0;\n\n            /**\n             * Creates a new ValueType instance using the specified properties.\n             * @function create\n             * @memberof perftools.profiles.ValueType\n             * @static\n             * @param {perftools.profiles.IValueType=} [properties] Properties to set\n             * @returns {perftools.profiles.ValueType} ValueType instance\n             */\n            ValueType.create = function create(properties) {\n                return new ValueType(properties);\n            };\n\n            /**\n             * Encodes the specified ValueType message. Does not implicitly {@link perftools.profiles.ValueType.verify|verify} messages.\n             * @function encode\n             * @memberof perftools.profiles.ValueType\n             * @static\n             * @param {perftools.profiles.IValueType} message ValueType message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            ValueType.encode = function encode(message, writer) {\n                if (!writer)\n                    writer = $Writer.create();\n                if (message.type != null && message.hasOwnProperty(\"type\"))\n                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.type);\n                if (message.unit != null && message.hasOwnProperty(\"unit\"))\n                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.unit);\n                return writer;\n            };\n\n            /**\n             * Encodes the specified ValueType message, length delimited. Does not implicitly {@link perftools.profiles.ValueType.verify|verify} messages.\n             * @function encodeDelimited\n             * @memberof perftools.profiles.ValueType\n             * @static\n             * @param {perftools.profiles.IValueType} message ValueType message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            ValueType.encodeDelimited = function encodeDelimited(message, writer) {\n                return this.encode(message, writer).ldelim();\n            };\n\n            /**\n             * Decodes a ValueType message from the specified reader or buffer.\n             * @function decode\n             * @memberof perftools.profiles.ValueType\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {perftools.profiles.ValueType} ValueType\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            ValueType.decode = function decode(reader, length) {\n                if (!(reader instanceof $Reader))\n                    reader = $Reader.create(reader);\n                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.perftools.profiles.ValueType();\n                while (reader.pos < end) {\n                    var tag = reader.uint32();\n                    switch (tag >>> 3) {\n                    case 1:\n                        message.type = reader.int64();\n                        break;\n                    case 2:\n                        message.unit = reader.int64();\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                    }\n                }\n                return message;\n            };\n\n            /**\n             * Decodes a ValueType message from the specified reader or buffer, length delimited.\n             * @function decodeDelimited\n             * @memberof perftools.profiles.ValueType\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @returns {perftools.profiles.ValueType} ValueType\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            ValueType.decodeDelimited = function decodeDelimited(reader) {\n                if (!(reader instanceof $Reader))\n                    reader = new $Reader(reader);\n                return this.decode(reader, reader.uint32());\n            };\n\n            /**\n             * Verifies a ValueType message.\n             * @function verify\n             * @memberof perftools.profiles.ValueType\n             * @static\n             * @param {Object.<string,*>} message Plain object to verify\n             * @returns {string|null} `null` if valid, otherwise the reason why it is not\n             */\n            ValueType.verify = function verify(message) {\n                if (typeof message !== \"object\" || message === null)\n                    return \"object expected\";\n                if (message.type != null && message.hasOwnProperty(\"type\"))\n                    if (!$util.isInteger(message.type) && !(message.type && $util.isInteger(message.type.low) && $util.isInteger(message.type.high)))\n                        return \"type: integer|Long expected\";\n                if (message.unit != null && message.hasOwnProperty(\"unit\"))\n                    if (!$util.isInteger(message.unit) && !(message.unit && $util.isInteger(message.unit.low) && $util.isInteger(message.unit.high)))\n                        return \"unit: integer|Long expected\";\n                return null;\n            };\n\n            /**\n             * Creates a ValueType message from a plain object. Also converts values to their respective internal types.\n             * @function fromObject\n             * @memberof perftools.profiles.ValueType\n             * @static\n             * @param {Object.<string,*>} object Plain object\n             * @returns {perftools.profiles.ValueType} ValueType\n             */\n            ValueType.fromObject = function fromObject(object) {\n                if (object instanceof $root.perftools.profiles.ValueType)\n                    return object;\n                var message = new $root.perftools.profiles.ValueType();\n                if (object.type != null)\n                    if ($util.Long)\n                        (message.type = $util.Long.fromValue(object.type)).unsigned = false;\n                    else if (typeof object.type === \"string\")\n                        message.type = parseInt(object.type, 10);\n                    else if (typeof object.type === \"number\")\n                        message.type = object.type;\n                    else if (typeof object.type === \"object\")\n                        message.type = new $util.LongBits(object.type.low >>> 0, object.type.high >>> 0).toNumber();\n                if (object.unit != null)\n                    if ($util.Long)\n                        (message.unit = $util.Long.fromValue(object.unit)).unsigned = false;\n                    else if (typeof object.unit === \"string\")\n                        message.unit = parseInt(object.unit, 10);\n                    else if (typeof object.unit === \"number\")\n                        message.unit = object.unit;\n                    else if (typeof object.unit === \"object\")\n                        message.unit = new $util.LongBits(object.unit.low >>> 0, object.unit.high >>> 0).toNumber();\n                return message;\n            };\n\n            /**\n             * Creates a plain object from a ValueType message. Also converts values to other types if specified.\n             * @function toObject\n             * @memberof perftools.profiles.ValueType\n             * @static\n             * @param {perftools.profiles.ValueType} message ValueType\n             * @param {$protobuf.IConversionOptions} [options] Conversion options\n             * @returns {Object.<string,*>} Plain object\n             */\n            ValueType.toObject = function toObject(message, options) {\n                if (!options)\n                    options = {};\n                var object = {};\n                if (options.defaults) {\n                    if ($util.Long) {\n                        var long = new $util.Long(0, 0, false);\n                        object.type = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                    } else\n                        object.type = options.longs === String ? \"0\" : 0;\n                    if ($util.Long) {\n                        var long = new $util.Long(0, 0, false);\n                        object.unit = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                    } else\n                        object.unit = options.longs === String ? \"0\" : 0;\n                }\n                if (message.type != null && message.hasOwnProperty(\"type\"))\n                    if (typeof message.type === \"number\")\n                        object.type = options.longs === String ? String(message.type) : message.type;\n                    else\n                        object.type = options.longs === String ? $util.Long.prototype.toString.call(message.type) : options.longs === Number ? new $util.LongBits(message.type.low >>> 0, message.type.high >>> 0).toNumber() : message.type;\n                if (message.unit != null && message.hasOwnProperty(\"unit\"))\n                    if (typeof message.unit === \"number\")\n                        object.unit = options.longs === String ? String(message.unit) : message.unit;\n                    else\n                        object.unit = options.longs === String ? $util.Long.prototype.toString.call(message.unit) : options.longs === Number ? new $util.LongBits(message.unit.low >>> 0, message.unit.high >>> 0).toNumber() : message.unit;\n                return object;\n            };\n\n            /**\n             * Converts this ValueType to JSON.\n             * @function toJSON\n             * @memberof perftools.profiles.ValueType\n             * @instance\n             * @returns {Object.<string,*>} JSON object\n             */\n            ValueType.prototype.toJSON = function toJSON() {\n                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n            };\n\n            return ValueType;\n        })();\n\n        profiles.Sample = (function() {\n\n            /**\n             * Properties of a Sample.\n             * @memberof perftools.profiles\n             * @interface ISample\n             * @property {Array.<number|Long>} [locationId] Sample locationId\n             * @property {Array.<number|Long>} [value] Sample value\n             * @property {Array.<perftools.profiles.ILabel>} [label] Sample label\n             */\n\n            /**\n             * Constructs a new Sample.\n             * @memberof perftools.profiles\n             * @classdesc Represents a Sample.\n             * @constructor\n             * @param {perftools.profiles.ISample=} [properties] Properties to set\n             */\n            function Sample(properties) {\n                this.locationId = [];\n                this.value = [];\n                this.label = [];\n                if (properties)\n                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }\n\n            /**\n             * Sample locationId.\n             * @member {Array.<number|Long>}locationId\n             * @memberof perftools.profiles.Sample\n             * @instance\n             */\n            Sample.prototype.locationId = $util.emptyArray;\n\n            /**\n             * Sample value.\n             * @member {Array.<number|Long>}value\n             * @memberof perftools.profiles.Sample\n             * @instance\n             */\n            Sample.prototype.value = $util.emptyArray;\n\n            /**\n             * Sample label.\n             * @member {Array.<perftools.profiles.ILabel>}label\n             * @memberof perftools.profiles.Sample\n             * @instance\n             */\n            Sample.prototype.label = $util.emptyArray;\n\n            /**\n             * Creates a new Sample instance using the specified properties.\n             * @function create\n             * @memberof perftools.profiles.Sample\n             * @static\n             * @param {perftools.profiles.ISample=} [properties] Properties to set\n             * @returns {perftools.profiles.Sample} Sample instance\n             */\n            Sample.create = function create(properties) {\n                return new Sample(properties);\n            };\n\n            /**\n             * Encodes the specified Sample message. Does not implicitly {@link perftools.profiles.Sample.verify|verify} messages.\n             * @function encode\n             * @memberof perftools.profiles.Sample\n             * @static\n             * @param {perftools.profiles.ISample} message Sample message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            Sample.encode = function encode(message, writer) {\n                if (!writer)\n                    writer = $Writer.create();\n                if (message.locationId != null && message.locationId.length) {\n                    writer.uint32(/* id 1, wireType 2 =*/10).fork();\n                    for (var i = 0; i < message.locationId.length; ++i)\n                        writer.uint64(message.locationId[i]);\n                    writer.ldelim();\n                }\n                if (message.value != null && message.value.length) {\n                    writer.uint32(/* id 2, wireType 2 =*/18).fork();\n                    for (var i = 0; i < message.value.length; ++i)\n                        writer.int64(message.value[i]);\n                    writer.ldelim();\n                }\n                if (message.label != null && message.label.length)\n                    for (var i = 0; i < message.label.length; ++i)\n                        $root.perftools.profiles.Label.encode(message.label[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();\n                return writer;\n            };\n\n            /**\n             * Encodes the specified Sample message, length delimited. Does not implicitly {@link perftools.profiles.Sample.verify|verify} messages.\n             * @function encodeDelimited\n             * @memberof perftools.profiles.Sample\n             * @static\n             * @param {perftools.profiles.ISample} message Sample message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            Sample.encodeDelimited = function encodeDelimited(message, writer) {\n                return this.encode(message, writer).ldelim();\n            };\n\n            /**\n             * Decodes a Sample message from the specified reader or buffer.\n             * @function decode\n             * @memberof perftools.profiles.Sample\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {perftools.profiles.Sample} Sample\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            Sample.decode = function decode(reader, length) {\n                if (!(reader instanceof $Reader))\n                    reader = $Reader.create(reader);\n                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.perftools.profiles.Sample();\n                while (reader.pos < end) {\n                    var tag = reader.uint32();\n                    switch (tag >>> 3) {\n                    case 1:\n                        if (!(message.locationId && message.locationId.length))\n                            message.locationId = [];\n                        if ((tag & 7) === 2) {\n                            var end2 = reader.uint32() + reader.pos;\n                            while (reader.pos < end2)\n                                message.locationId.push(reader.uint64());\n                        } else\n                            message.locationId.push(reader.uint64());\n                        break;\n                    case 2:\n                        if (!(message.value && message.value.length))\n                            message.value = [];\n                        if ((tag & 7) === 2) {\n                            var end2 = reader.uint32() + reader.pos;\n                            while (reader.pos < end2)\n                                message.value.push(reader.int64());\n                        } else\n                            message.value.push(reader.int64());\n                        break;\n                    case 3:\n                        if (!(message.label && message.label.length))\n                            message.label = [];\n                        message.label.push($root.perftools.profiles.Label.decode(reader, reader.uint32()));\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                    }\n                }\n                return message;\n            };\n\n            /**\n             * Decodes a Sample message from the specified reader or buffer, length delimited.\n             * @function decodeDelimited\n             * @memberof perftools.profiles.Sample\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @returns {perftools.profiles.Sample} Sample\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            Sample.decodeDelimited = function decodeDelimited(reader) {\n                if (!(reader instanceof $Reader))\n                    reader = new $Reader(reader);\n                return this.decode(reader, reader.uint32());\n            };\n\n            /**\n             * Verifies a Sample message.\n             * @function verify\n             * @memberof perftools.profiles.Sample\n             * @static\n             * @param {Object.<string,*>} message Plain object to verify\n             * @returns {string|null} `null` if valid, otherwise the reason why it is not\n             */\n            Sample.verify = function verify(message) {\n                if (typeof message !== \"object\" || message === null)\n                    return \"object expected\";\n                if (message.locationId != null && message.hasOwnProperty(\"locationId\")) {\n                    if (!Array.isArray(message.locationId))\n                        return \"locationId: array expected\";\n                    for (var i = 0; i < message.locationId.length; ++i)\n                        if (!$util.isInteger(message.locationId[i]) && !(message.locationId[i] && $util.isInteger(message.locationId[i].low) && $util.isInteger(message.locationId[i].high)))\n                            return \"locationId: integer|Long[] expected\";\n                }\n                if (message.value != null && message.hasOwnProperty(\"value\")) {\n                    if (!Array.isArray(message.value))\n                        return \"value: array expected\";\n                    for (var i = 0; i < message.value.length; ++i)\n                        if (!$util.isInteger(message.value[i]) && !(message.value[i] && $util.isInteger(message.value[i].low) && $util.isInteger(message.value[i].high)))\n                            return \"value: integer|Long[] expected\";\n                }\n                if (message.label != null && message.hasOwnProperty(\"label\")) {\n                    if (!Array.isArray(message.label))\n                        return \"label: array expected\";\n                    for (var i = 0; i < message.label.length; ++i) {\n                        var error = $root.perftools.profiles.Label.verify(message.label[i]);\n                        if (error)\n                            return \"label.\" + error;\n                    }\n                }\n                return null;\n            };\n\n            /**\n             * Creates a Sample message from a plain object. Also converts values to their respective internal types.\n             * @function fromObject\n             * @memberof perftools.profiles.Sample\n             * @static\n             * @param {Object.<string,*>} object Plain object\n             * @returns {perftools.profiles.Sample} Sample\n             */\n            Sample.fromObject = function fromObject(object) {\n                if (object instanceof $root.perftools.profiles.Sample)\n                    return object;\n                var message = new $root.perftools.profiles.Sample();\n                if (object.locationId) {\n                    if (!Array.isArray(object.locationId))\n                        throw TypeError(\".perftools.profiles.Sample.locationId: array expected\");\n                    message.locationId = [];\n                    for (var i = 0; i < object.locationId.length; ++i)\n                        if ($util.Long)\n                            (message.locationId[i] = $util.Long.fromValue(object.locationId[i])).unsigned = true;\n                        else if (typeof object.locationId[i] === \"string\")\n                            message.locationId[i] = parseInt(object.locationId[i], 10);\n                        else if (typeof object.locationId[i] === \"number\")\n                            message.locationId[i] = object.locationId[i];\n                        else if (typeof object.locationId[i] === \"object\")\n                            message.locationId[i] = new $util.LongBits(object.locationId[i].low >>> 0, object.locationId[i].high >>> 0).toNumber(true);\n                }\n                if (object.value) {\n                    if (!Array.isArray(object.value))\n                        throw TypeError(\".perftools.profiles.Sample.value: array expected\");\n                    message.value = [];\n                    for (var i = 0; i < object.value.length; ++i)\n                        if ($util.Long)\n                            (message.value[i] = $util.Long.fromValue(object.value[i])).unsigned = false;\n                        else if (typeof object.value[i] === \"string\")\n                            message.value[i] = parseInt(object.value[i], 10);\n                        else if (typeof object.value[i] === \"number\")\n                            message.value[i] = object.value[i];\n                        else if (typeof object.value[i] === \"object\")\n                            message.value[i] = new $util.LongBits(object.value[i].low >>> 0, object.value[i].high >>> 0).toNumber();\n                }\n                if (object.label) {\n                    if (!Array.isArray(object.label))\n                        throw TypeError(\".perftools.profiles.Sample.label: array expected\");\n                    message.label = [];\n                    for (var i = 0; i < object.label.length; ++i) {\n                        if (typeof object.label[i] !== \"object\")\n                            throw TypeError(\".perftools.profiles.Sample.label: object expected\");\n                        message.label[i] = $root.perftools.profiles.Label.fromObject(object.label[i]);\n                    }\n                }\n                return message;\n            };\n\n            /**\n             * Creates a plain object from a Sample message. Also converts values to other types if specified.\n             * @function toObject\n             * @memberof perftools.profiles.Sample\n             * @static\n             * @param {perftools.profiles.Sample} message Sample\n             * @param {$protobuf.IConversionOptions} [options] Conversion options\n             * @returns {Object.<string,*>} Plain object\n             */\n            Sample.toObject = function toObject(message, options) {\n                if (!options)\n                    options = {};\n                var object = {};\n                if (options.arrays || options.defaults) {\n                    object.locationId = [];\n                    object.value = [];\n                    object.label = [];\n                }\n                if (message.locationId && message.locationId.length) {\n                    object.locationId = [];\n                    for (var j = 0; j < message.locationId.length; ++j)\n                        if (typeof message.locationId[j] === \"number\")\n                            object.locationId[j] = options.longs === String ? String(message.locationId[j]) : message.locationId[j];\n                        else\n                            object.locationId[j] = options.longs === String ? $util.Long.prototype.toString.call(message.locationId[j]) : options.longs === Number ? new $util.LongBits(message.locationId[j].low >>> 0, message.locationId[j].high >>> 0).toNumber(true) : message.locationId[j];\n                }\n                if (message.value && message.value.length) {\n                    object.value = [];\n                    for (var j = 0; j < message.value.length; ++j)\n                        if (typeof message.value[j] === \"number\")\n                            object.value[j] = options.longs === String ? String(message.value[j]) : message.value[j];\n                        else\n                            object.value[j] = options.longs === String ? $util.Long.prototype.toString.call(message.value[j]) : options.longs === Number ? new $util.LongBits(message.value[j].low >>> 0, message.value[j].high >>> 0).toNumber() : message.value[j];\n                }\n                if (message.label && message.label.length) {\n                    object.label = [];\n                    for (var j = 0; j < message.label.length; ++j)\n                        object.label[j] = $root.perftools.profiles.Label.toObject(message.label[j], options);\n                }\n                return object;\n            };\n\n            /**\n             * Converts this Sample to JSON.\n             * @function toJSON\n             * @memberof perftools.profiles.Sample\n             * @instance\n             * @returns {Object.<string,*>} JSON object\n             */\n            Sample.prototype.toJSON = function toJSON() {\n                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n            };\n\n            return Sample;\n        })();\n\n        profiles.Label = (function() {\n\n            /**\n             * Properties of a Label.\n             * @memberof perftools.profiles\n             * @interface ILabel\n             * @property {number|Long} [key] Label key\n             * @property {number|Long} [str] Label str\n             * @property {number|Long} [num] Label num\n             * @property {number|Long} [numUnit] Label numUnit\n             */\n\n            /**\n             * Constructs a new Label.\n             * @memberof perftools.profiles\n             * @classdesc Represents a Label.\n             * @constructor\n             * @param {perftools.profiles.ILabel=} [properties] Properties to set\n             */\n            function Label(properties) {\n                if (properties)\n                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }\n\n            /**\n             * Label key.\n             * @member {number|Long}key\n             * @memberof perftools.profiles.Label\n             * @instance\n             */\n            Label.prototype.key = $util.Long ? $util.Long.fromBits(0,0,false) : 0;\n\n            /**\n             * Label str.\n             * @member {number|Long}str\n             * @memberof perftools.profiles.Label\n             * @instance\n             */\n            Label.prototype.str = $util.Long ? $util.Long.fromBits(0,0,false) : 0;\n\n            /**\n             * Label num.\n             * @member {number|Long}num\n             * @memberof perftools.profiles.Label\n             * @instance\n             */\n            Label.prototype.num = $util.Long ? $util.Long.fromBits(0,0,false) : 0;\n\n            /**\n             * Label numUnit.\n             * @member {number|Long}numUnit\n             * @memberof perftools.profiles.Label\n             * @instance\n             */\n            Label.prototype.numUnit = $util.Long ? $util.Long.fromBits(0,0,false) : 0;\n\n            /**\n             * Creates a new Label instance using the specified properties.\n             * @function create\n             * @memberof perftools.profiles.Label\n             * @static\n             * @param {perftools.profiles.ILabel=} [properties] Properties to set\n             * @returns {perftools.profiles.Label} Label instance\n             */\n            Label.create = function create(properties) {\n                return new Label(properties);\n            };\n\n            /**\n             * Encodes the specified Label message. Does not implicitly {@link perftools.profiles.Label.verify|verify} messages.\n             * @function encode\n             * @memberof perftools.profiles.Label\n             * @static\n             * @param {perftools.profiles.ILabel} message Label message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            Label.encode = function encode(message, writer) {\n                if (!writer)\n                    writer = $Writer.create();\n                if (message.key != null && message.hasOwnProperty(\"key\"))\n                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.key);\n                if (message.str != null && message.hasOwnProperty(\"str\"))\n                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.str);\n                if (message.num != null && message.hasOwnProperty(\"num\"))\n                    writer.uint32(/* id 3, wireType 0 =*/24).int64(message.num);\n                if (message.numUnit != null && message.hasOwnProperty(\"numUnit\"))\n                    writer.uint32(/* id 4, wireType 0 =*/32).int64(message.numUnit);\n                return writer;\n            };\n\n            /**\n             * Encodes the specified Label message, length delimited. Does not implicitly {@link perftools.profiles.Label.verify|verify} messages.\n             * @function encodeDelimited\n             * @memberof perftools.profiles.Label\n             * @static\n             * @param {perftools.profiles.ILabel} message Label message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            Label.encodeDelimited = function encodeDelimited(message, writer) {\n                return this.encode(message, writer).ldelim();\n            };\n\n            /**\n             * Decodes a Label message from the specified reader or buffer.\n             * @function decode\n             * @memberof perftools.profiles.Label\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {perftools.profiles.Label} Label\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            Label.decode = function decode(reader, length) {\n                if (!(reader instanceof $Reader))\n                    reader = $Reader.create(reader);\n                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.perftools.profiles.Label();\n                while (reader.pos < end) {\n                    var tag = reader.uint32();\n                    switch (tag >>> 3) {\n                    case 1:\n                        message.key = reader.int64();\n                        break;\n                    case 2:\n                        message.str = reader.int64();\n                        break;\n                    case 3:\n                        message.num = reader.int64();\n                        break;\n                    case 4:\n                        message.numUnit = reader.int64();\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                    }\n                }\n                return message;\n            };\n\n            /**\n             * Decodes a Label message from the specified reader or buffer, length delimited.\n             * @function decodeDelimited\n             * @memberof perftools.profiles.Label\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @returns {perftools.profiles.Label} Label\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            Label.decodeDelimited = function decodeDelimited(reader) {\n                if (!(reader instanceof $Reader))\n                    reader = new $Reader(reader);\n                return this.decode(reader, reader.uint32());\n            };\n\n            /**\n             * Verifies a Label message.\n             * @function verify\n             * @memberof perftools.profiles.Label\n             * @static\n             * @param {Object.<string,*>} message Plain object to verify\n             * @returns {string|null} `null` if valid, otherwise the reason why it is not\n             */\n            Label.verify = function verify(message) {\n                if (typeof message !== \"object\" || message === null)\n                    return \"object expected\";\n                if (message.key != null && message.hasOwnProperty(\"key\"))\n                    if (!$util.isInteger(message.key) && !(message.key && $util.isInteger(message.key.low) && $util.isInteger(message.key.high)))\n                        return \"key: integer|Long expected\";\n                if (message.str != null && message.hasOwnProperty(\"str\"))\n                    if (!$util.isInteger(message.str) && !(message.str && $util.isInteger(message.str.low) && $util.isInteger(message.str.high)))\n                        return \"str: integer|Long expected\";\n                if (message.num != null && message.hasOwnProperty(\"num\"))\n                    if (!$util.isInteger(message.num) && !(message.num && $util.isInteger(message.num.low) && $util.isInteger(message.num.high)))\n                        return \"num: integer|Long expected\";\n                if (message.numUnit != null && message.hasOwnProperty(\"numUnit\"))\n                    if (!$util.isInteger(message.numUnit) && !(message.numUnit && $util.isInteger(message.numUnit.low) && $util.isInteger(message.numUnit.high)))\n                        return \"numUnit: integer|Long expected\";\n                return null;\n            };\n\n            /**\n             * Creates a Label message from a plain object. Also converts values to their respective internal types.\n             * @function fromObject\n             * @memberof perftools.profiles.Label\n             * @static\n             * @param {Object.<string,*>} object Plain object\n             * @returns {perftools.profiles.Label} Label\n             */\n            Label.fromObject = function fromObject(object) {\n                if (object instanceof $root.perftools.profiles.Label)\n                    return object;\n                var message = new $root.perftools.profiles.Label();\n                if (object.key != null)\n                    if ($util.Long)\n                        (message.key = $util.Long.fromValue(object.key)).unsigned = false;\n                    else if (typeof object.key === \"string\")\n                        message.key = parseInt(object.key, 10);\n                    else if (typeof object.key === \"number\")\n                        message.key = object.key;\n                    else if (typeof object.key === \"object\")\n                        message.key = new $util.LongBits(object.key.low >>> 0, object.key.high >>> 0).toNumber();\n                if (object.str != null)\n                    if ($util.Long)\n                        (message.str = $util.Long.fromValue(object.str)).unsigned = false;\n                    else if (typeof object.str === \"string\")\n                        message.str = parseInt(object.str, 10);\n                    else if (typeof object.str === \"number\")\n                        message.str = object.str;\n                    else if (typeof object.str === \"object\")\n                        message.str = new $util.LongBits(object.str.low >>> 0, object.str.high >>> 0).toNumber();\n                if (object.num != null)\n                    if ($util.Long)\n                        (message.num = $util.Long.fromValue(object.num)).unsigned = false;\n                    else if (typeof object.num === \"string\")\n                        message.num = parseInt(object.num, 10);\n                    else if (typeof object.num === \"number\")\n                        message.num = object.num;\n                    else if (typeof object.num === \"object\")\n                        message.num = new $util.LongBits(object.num.low >>> 0, object.num.high >>> 0).toNumber();\n                if (object.numUnit != null)\n                    if ($util.Long)\n                        (message.numUnit = $util.Long.fromValue(object.numUnit)).unsigned = false;\n                    else if (typeof object.numUnit === \"string\")\n                        message.numUnit = parseInt(object.numUnit, 10);\n                    else if (typeof object.numUnit === \"number\")\n                        message.numUnit = object.numUnit;\n                    else if (typeof object.numUnit === \"object\")\n                        message.numUnit = new $util.LongBits(object.numUnit.low >>> 0, object.numUnit.high >>> 0).toNumber();\n                return message;\n            };\n\n            /**\n             * Creates a plain object from a Label message. Also converts values to other types if specified.\n             * @function toObject\n             * @memberof perftools.profiles.Label\n             * @static\n             * @param {perftools.profiles.Label} message Label\n             * @param {$protobuf.IConversionOptions} [options] Conversion options\n             * @returns {Object.<string,*>} Plain object\n             */\n            Label.toObject = function toObject(message, options) {\n                if (!options)\n                    options = {};\n                var object = {};\n                if (options.defaults) {\n                    if ($util.Long) {\n                        var long = new $util.Long(0, 0, false);\n                        object.key = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                    } else\n                        object.key = options.longs === String ? \"0\" : 0;\n                    if ($util.Long) {\n                        var long = new $util.Long(0, 0, false);\n                        object.str = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                    } else\n                        object.str = options.longs === String ? \"0\" : 0;\n                    if ($util.Long) {\n                        var long = new $util.Long(0, 0, false);\n                        object.num = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                    } else\n                        object.num = options.longs === String ? \"0\" : 0;\n                    if ($util.Long) {\n                        var long = new $util.Long(0, 0, false);\n                        object.numUnit = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                    } else\n                        object.numUnit = options.longs === String ? \"0\" : 0;\n                }\n                if (message.key != null && message.hasOwnProperty(\"key\"))\n                    if (typeof message.key === \"number\")\n                        object.key = options.longs === String ? String(message.key) : message.key;\n                    else\n                        object.key = options.longs === String ? $util.Long.prototype.toString.call(message.key) : options.longs === Number ? new $util.LongBits(message.key.low >>> 0, message.key.high >>> 0).toNumber() : message.key;\n                if (message.str != null && message.hasOwnProperty(\"str\"))\n                    if (typeof message.str === \"number\")\n                        object.str = options.longs === String ? String(message.str) : message.str;\n                    else\n                        object.str = options.longs === String ? $util.Long.prototype.toString.call(message.str) : options.longs === Number ? new $util.LongBits(message.str.low >>> 0, message.str.high >>> 0).toNumber() : message.str;\n                if (message.num != null && message.hasOwnProperty(\"num\"))\n                    if (typeof message.num === \"number\")\n                        object.num = options.longs === String ? String(message.num) : message.num;\n                    else\n                        object.num = options.longs === String ? $util.Long.prototype.toString.call(message.num) : options.longs === Number ? new $util.LongBits(message.num.low >>> 0, message.num.high >>> 0).toNumber() : message.num;\n                if (message.numUnit != null && message.hasOwnProperty(\"numUnit\"))\n                    if (typeof message.numUnit === \"number\")\n                        object.numUnit = options.longs === String ? String(message.numUnit) : message.numUnit;\n                    else\n                        object.numUnit = options.longs === String ? $util.Long.prototype.toString.call(message.numUnit) : options.longs === Number ? new $util.LongBits(message.numUnit.low >>> 0, message.numUnit.high >>> 0).toNumber() : message.numUnit;\n                return object;\n            };\n\n            /**\n             * Converts this Label to JSON.\n             * @function toJSON\n             * @memberof perftools.profiles.Label\n             * @instance\n             * @returns {Object.<string,*>} JSON object\n             */\n            Label.prototype.toJSON = function toJSON() {\n                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n            };\n\n            return Label;\n        })();\n\n        profiles.Mapping = (function() {\n\n            /**\n             * Properties of a Mapping.\n             * @memberof perftools.profiles\n             * @interface IMapping\n             * @property {number|Long} [id] Mapping id\n             * @property {number|Long} [memoryStart] Mapping memoryStart\n             * @property {number|Long} [memoryLimit] Mapping memoryLimit\n             * @property {number|Long} [fileOffset] Mapping fileOffset\n             * @property {number|Long} [filename] Mapping filename\n             * @property {number|Long} [buildId] Mapping buildId\n             * @property {boolean} [hasFunctions] Mapping hasFunctions\n             * @property {boolean} [hasFilenames] Mapping hasFilenames\n             * @property {boolean} [hasLineNumbers] Mapping hasLineNumbers\n             * @property {boolean} [hasInlineFrames] Mapping hasInlineFrames\n             */\n\n            /**\n             * Constructs a new Mapping.\n             * @memberof perftools.profiles\n             * @classdesc Represents a Mapping.\n             * @constructor\n             * @param {perftools.profiles.IMapping=} [properties] Properties to set\n             */\n            function Mapping(properties) {\n                if (properties)\n                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }\n\n            /**\n             * Mapping id.\n             * @member {number|Long}id\n             * @memberof perftools.profiles.Mapping\n             * @instance\n             */\n            Mapping.prototype.id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;\n\n            /**\n             * Mapping memoryStart.\n             * @member {number|Long}memoryStart\n             * @memberof perftools.profiles.Mapping\n             * @instance\n             */\n            Mapping.prototype.memoryStart = $util.Long ? $util.Long.fromBits(0,0,true) : 0;\n\n            /**\n             * Mapping memoryLimit.\n             * @member {number|Long}memoryLimit\n             * @memberof perftools.profiles.Mapping\n             * @instance\n             */\n            Mapping.prototype.memoryLimit = $util.Long ? $util.Long.fromBits(0,0,true) : 0;\n\n            /**\n             * Mapping fileOffset.\n             * @member {number|Long}fileOffset\n             * @memberof perftools.profiles.Mapping\n             * @instance\n             */\n            Mapping.prototype.fileOffset = $util.Long ? $util.Long.fromBits(0,0,true) : 0;\n\n            /**\n             * Mapping filename.\n             * @member {number|Long}filename\n             * @memberof perftools.profiles.Mapping\n             * @instance\n             */\n            Mapping.prototype.filename = $util.Long ? $util.Long.fromBits(0,0,false) : 0;\n\n            /**\n             * Mapping buildId.\n             * @member {number|Long}buildId\n             * @memberof perftools.profiles.Mapping\n             * @instance\n             */\n            Mapping.prototype.buildId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;\n\n            /**\n             * Mapping hasFunctions.\n             * @member {boolean}hasFunctions\n             * @memberof perftools.profiles.Mapping\n             * @instance\n             */\n            Mapping.prototype.hasFunctions = false;\n\n            /**\n             * Mapping hasFilenames.\n             * @member {boolean}hasFilenames\n             * @memberof perftools.profiles.Mapping\n             * @instance\n             */\n            Mapping.prototype.hasFilenames = false;\n\n            /**\n             * Mapping hasLineNumbers.\n             * @member {boolean}hasLineNumbers\n             * @memberof perftools.profiles.Mapping\n             * @instance\n             */\n            Mapping.prototype.hasLineNumbers = false;\n\n            /**\n             * Mapping hasInlineFrames.\n             * @member {boolean}hasInlineFrames\n             * @memberof perftools.profiles.Mapping\n             * @instance\n             */\n            Mapping.prototype.hasInlineFrames = false;\n\n            /**\n             * Creates a new Mapping instance using the specified properties.\n             * @function create\n             * @memberof perftools.profiles.Mapping\n             * @static\n             * @param {perftools.profiles.IMapping=} [properties] Properties to set\n             * @returns {perftools.profiles.Mapping} Mapping instance\n             */\n            Mapping.create = function create(properties) {\n                return new Mapping(properties);\n            };\n\n            /**\n             * Encodes the specified Mapping message. Does not implicitly {@link perftools.profiles.Mapping.verify|verify} messages.\n             * @function encode\n             * @memberof perftools.profiles.Mapping\n             * @static\n             * @param {perftools.profiles.IMapping} message Mapping message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            Mapping.encode = function encode(message, writer) {\n                if (!writer)\n                    writer = $Writer.create();\n                if (message.id != null && message.hasOwnProperty(\"id\"))\n                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.id);\n                if (message.memoryStart != null && message.hasOwnProperty(\"memoryStart\"))\n                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.memoryStart);\n                if (message.memoryLimit != null && message.hasOwnProperty(\"memoryLimit\"))\n                    writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.memoryLimit);\n                if (message.fileOffset != null && message.hasOwnProperty(\"fileOffset\"))\n                    writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.fileOffset);\n                if (message.filename != null && message.hasOwnProperty(\"filename\"))\n                    writer.uint32(/* id 5, wireType 0 =*/40).int64(message.filename);\n                if (message.buildId != null && message.hasOwnProperty(\"buildId\"))\n                    writer.uint32(/* id 6, wireType 0 =*/48).int64(message.buildId);\n                if (message.hasFunctions != null && message.hasOwnProperty(\"hasFunctions\"))\n                    writer.uint32(/* id 7, wireType 0 =*/56).bool(message.hasFunctions);\n                if (message.hasFilenames != null && message.hasOwnProperty(\"hasFilenames\"))\n                    writer.uint32(/* id 8, wireType 0 =*/64).bool(message.hasFilenames);\n                if (message.hasLineNumbers != null && message.hasOwnProperty(\"hasLineNumbers\"))\n                    writer.uint32(/* id 9, wireType 0 =*/72).bool(message.hasLineNumbers);\n                if (message.hasInlineFrames != null && message.hasOwnProperty(\"hasInlineFrames\"))\n                    writer.uint32(/* id 10, wireType 0 =*/80).bool(message.hasInlineFrames);\n                return writer;\n            };\n\n            /**\n             * Encodes the specified Mapping message, length delimited. Does not implicitly {@link perftools.profiles.Mapping.verify|verify} messages.\n             * @function encodeDelimited\n             * @memberof perftools.profiles.Mapping\n             * @static\n             * @param {perftools.profiles.IMapping} message Mapping message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            Mapping.encodeDelimited = function encodeDelimited(message, writer) {\n                return this.encode(message, writer).ldelim();\n            };\n\n            /**\n             * Decodes a Mapping message from the specified reader or buffer.\n             * @function decode\n             * @memberof perftools.profiles.Mapping\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {perftools.profiles.Mapping} Mapping\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            Mapping.decode = function decode(reader, length) {\n                if (!(reader instanceof $Reader))\n                    reader = $Reader.create(reader);\n                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.perftools.profiles.Mapping();\n                while (reader.pos < end) {\n                    var tag = reader.uint32();\n                    switch (tag >>> 3) {\n                    case 1:\n                        message.id = reader.uint64();\n                        break;\n                    case 2:\n                        message.memoryStart = reader.uint64();\n                        break;\n                    case 3:\n                        message.memoryLimit = reader.uint64();\n                        break;\n                    case 4:\n                        message.fileOffset = reader.uint64();\n                        break;\n                    case 5:\n                        message.filename = reader.int64();\n                        break;\n                    case 6:\n                        message.buildId = reader.int64();\n                        break;\n                    case 7:\n                        message.hasFunctions = reader.bool();\n                        break;\n                    case 8:\n                        message.hasFilenames = reader.bool();\n                        break;\n                    case 9:\n                        message.hasLineNumbers = reader.bool();\n                        break;\n                    case 10:\n                        message.hasInlineFrames = reader.bool();\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                    }\n                }\n                return message;\n            };\n\n            /**\n             * Decodes a Mapping message from the specified reader or buffer, length delimited.\n             * @function decodeDelimited\n             * @memberof perftools.profiles.Mapping\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @returns {perftools.profiles.Mapping} Mapping\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            Mapping.decodeDelimited = function decodeDelimited(reader) {\n                if (!(reader instanceof $Reader))\n                    reader = new $Reader(reader);\n                return this.decode(reader, reader.uint32());\n            };\n\n            /**\n             * Verifies a Mapping message.\n             * @function verify\n             * @memberof perftools.profiles.Mapping\n             * @static\n             * @param {Object.<string,*>} message Plain object to verify\n             * @returns {string|null} `null` if valid, otherwise the reason why it is not\n             */\n            Mapping.verify = function verify(message) {\n                if (typeof message !== \"object\" || message === null)\n                    return \"object expected\";\n                if (message.id != null && message.hasOwnProperty(\"id\"))\n                    if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))\n                        return \"id: integer|Long expected\";\n                if (message.memoryStart != null && message.hasOwnProperty(\"memoryStart\"))\n                    if (!$util.isInteger(message.memoryStart) && !(message.memoryStart && $util.isInteger(message.memoryStart.low) && $util.isInteger(message.memoryStart.high)))\n                        return \"memoryStart: integer|Long expected\";\n                if (message.memoryLimit != null && message.hasOwnProperty(\"memoryLimit\"))\n                    if (!$util.isInteger(message.memoryLimit) && !(message.memoryLimit && $util.isInteger(message.memoryLimit.low) && $util.isInteger(message.memoryLimit.high)))\n                        return \"memoryLimit: integer|Long expected\";\n                if (message.fileOffset != null && message.hasOwnProperty(\"fileOffset\"))\n                    if (!$util.isInteger(message.fileOffset) && !(message.fileOffset && $util.isInteger(message.fileOffset.low) && $util.isInteger(message.fileOffset.high)))\n                        return \"fileOffset: integer|Long expected\";\n                if (message.filename != null && message.hasOwnProperty(\"filename\"))\n                    if (!$util.isInteger(message.filename) && !(message.filename && $util.isInteger(message.filename.low) && $util.isInteger(message.filename.high)))\n                        return \"filename: integer|Long expected\";\n                if (message.buildId != null && message.hasOwnProperty(\"buildId\"))\n                    if (!$util.isInteger(message.buildId) && !(message.buildId && $util.isInteger(message.buildId.low) && $util.isInteger(message.buildId.high)))\n                        return \"buildId: integer|Long expected\";\n                if (message.hasFunctions != null && message.hasOwnProperty(\"hasFunctions\"))\n                    if (typeof message.hasFunctions !== \"boolean\")\n                        return \"hasFunctions: boolean expected\";\n                if (message.hasFilenames != null && message.hasOwnProperty(\"hasFilenames\"))\n                    if (typeof message.hasFilenames !== \"boolean\")\n                        return \"hasFilenames: boolean expected\";\n                if (message.hasLineNumbers != null && message.hasOwnProperty(\"hasLineNumbers\"))\n                    if (typeof message.hasLineNumbers !== \"boolean\")\n                        return \"hasLineNumbers: boolean expected\";\n                if (message.hasInlineFrames != null && message.hasOwnProperty(\"hasInlineFrames\"))\n                    if (typeof message.hasInlineFrames !== \"boolean\")\n                        return \"hasInlineFrames: boolean expected\";\n                return null;\n            };\n\n            /**\n             * Creates a Mapping message from a plain object. Also converts values to their respective internal types.\n             * @function fromObject\n             * @memberof perftools.profiles.Mapping\n             * @static\n             * @param {Object.<string,*>} object Plain object\n             * @returns {perftools.profiles.Mapping} Mapping\n             */\n            Mapping.fromObject = function fromObject(object) {\n                if (object instanceof $root.perftools.profiles.Mapping)\n                    return object;\n                var message = new $root.perftools.profiles.Mapping();\n                if (object.id != null)\n                    if ($util.Long)\n                        (message.id = $util.Long.fromValue(object.id)).unsigned = true;\n                    else if (typeof object.id === \"string\")\n                        message.id = parseInt(object.id, 10);\n                    else if (typeof object.id === \"number\")\n                        message.id = object.id;\n                    else if (typeof object.id === \"object\")\n                        message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);\n                if (object.memoryStart != null)\n                    if ($util.Long)\n                        (message.memoryStart = $util.Long.fromValue(object.memoryStart)).unsigned = true;\n                    else if (typeof object.memoryStart === \"string\")\n                        message.memoryStart = parseInt(object.memoryStart, 10);\n                    else if (typeof object.memoryStart === \"number\")\n                        message.memoryStart = object.memoryStart;\n                    else if (typeof object.memoryStart === \"object\")\n                        message.memoryStart = new $util.LongBits(object.memoryStart.low >>> 0, object.memoryStart.high >>> 0).toNumber(true);\n                if (object.memoryLimit != null)\n                    if ($util.Long)\n                        (message.memoryLimit = $util.Long.fromValue(object.memoryLimit)).unsigned = true;\n                    else if (typeof object.memoryLimit === \"string\")\n                        message.memoryLimit = parseInt(object.memoryLimit, 10);\n                    else if (typeof object.memoryLimit === \"number\")\n                        message.memoryLimit = object.memoryLimit;\n                    else if (typeof object.memoryLimit === \"object\")\n                        message.memoryLimit = new $util.LongBits(object.memoryLimit.low >>> 0, object.memoryLimit.high >>> 0).toNumber(true);\n                if (object.fileOffset != null)\n                    if ($util.Long)\n                        (message.fileOffset = $util.Long.fromValue(object.fileOffset)).unsigned = true;\n                    else if (typeof object.fileOffset === \"string\")\n                        message.fileOffset = parseInt(object.fileOffset, 10);\n                    else if (typeof object.fileOffset === \"number\")\n                        message.fileOffset = object.fileOffset;\n                    else if (typeof object.fileOffset === \"object\")\n                        message.fileOffset = new $util.LongBits(object.fileOffset.low >>> 0, object.fileOffset.high >>> 0).toNumber(true);\n                if (object.filename != null)\n                    if ($util.Long)\n                        (message.filename = $util.Long.fromValue(object.filename)).unsigned = false;\n                    else if (typeof object.filename === \"string\")\n                        message.filename = parseInt(object.filename, 10);\n                    else if (typeof object.filename === \"number\")\n                        message.filename = object.filename;\n                    else if (typeof object.filename === \"object\")\n                        message.filename = new $util.LongBits(object.filename.low >>> 0, object.filename.high >>> 0).toNumber();\n                if (object.buildId != null)\n                    if ($util.Long)\n                        (message.buildId = $util.Long.fromValue(object.buildId)).unsigned = false;\n                    else if (typeof object.buildId === \"string\")\n                        message.buildId = parseInt(object.buildId, 10);\n                    else if (typeof object.buildId === \"number\")\n                        message.buildId = object.buildId;\n                    else if (typeof object.buildId === \"object\")\n                        message.buildId = new $util.LongBits(object.buildId.low >>> 0, object.buildId.high >>> 0).toNumber();\n                if (object.hasFunctions != null)\n                    message.hasFunctions = Boolean(object.hasFunctions);\n                if (object.hasFilenames != null)\n                    message.hasFilenames = Boolean(object.hasFilenames);\n                if (object.hasLineNumbers != null)\n                    message.hasLineNumbers = Boolean(object.hasLineNumbers);\n                if (object.hasInlineFrames != null)\n                    message.hasInlineFrames = Boolean(object.hasInlineFrames);\n                return message;\n            };\n\n            /**\n             * Creates a plain object from a Mapping message. Also converts values to other types if specified.\n             * @function toObject\n             * @memberof perftools.profiles.Mapping\n             * @static\n             * @param {perftools.profiles.Mapping} message Mapping\n             * @param {$protobuf.IConversionOptions} [options] Conversion options\n             * @returns {Object.<string,*>} Plain object\n             */\n            Mapping.toObject = function toObject(message, options) {\n                if (!options)\n                    options = {};\n                var object = {};\n                if (options.defaults) {\n                    if ($util.Long) {\n                        var long = new $util.Long(0, 0, true);\n                        object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                    } else\n                        object.id = options.longs === String ? \"0\" : 0;\n                    if ($util.Long) {\n                        var long = new $util.Long(0, 0, true);\n                        object.memoryStart = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                    } else\n                        object.memoryStart = options.longs === String ? \"0\" : 0;\n                    if ($util.Long) {\n                        var long = new $util.Long(0, 0, true);\n                        object.memoryLimit = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                    } else\n                        object.memoryLimit = options.longs === String ? \"0\" : 0;\n                    if ($util.Long) {\n                        var long = new $util.Long(0, 0, true);\n                        object.fileOffset = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                    } else\n                        object.fileOffset = options.longs === String ? \"0\" : 0;\n                    if ($util.Long) {\n                        var long = new $util.Long(0, 0, false);\n                        object.filename = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                    } else\n                        object.filename = options.longs === String ? \"0\" : 0;\n                    if ($util.Long) {\n                        var long = new $util.Long(0, 0, false);\n                        object.buildId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                    } else\n                        object.buildId = options.longs === String ? \"0\" : 0;\n                    object.hasFunctions = false;\n                    object.hasFilenames = false;\n                    object.hasLineNumbers = false;\n                    object.hasInlineFrames = false;\n                }\n                if (message.id != null && message.hasOwnProperty(\"id\"))\n                    if (typeof message.id === \"number\")\n                        object.id = options.longs === String ? String(message.id) : message.id;\n                    else\n                        object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true) : message.id;\n                if (message.memoryStart != null && message.hasOwnProperty(\"memoryStart\"))\n                    if (typeof message.memoryStart === \"number\")\n                        object.memoryStart = options.longs === String ? String(message.memoryStart) : message.memoryStart;\n                    else\n                        object.memoryStart = options.longs === String ? $util.Long.prototype.toString.call(message.memoryStart) : options.longs === Number ? new $util.LongBits(message.memoryStart.low >>> 0, message.memoryStart.high >>> 0).toNumber(true) : message.memoryStart;\n                if (message.memoryLimit != null && message.hasOwnProperty(\"memoryLimit\"))\n                    if (typeof message.memoryLimit === \"number\")\n                        object.memoryLimit = options.longs === String ? String(message.memoryLimit) : message.memoryLimit;\n                    else\n                        object.memoryLimit = options.longs === String ? $util.Long.prototype.toString.call(message.memoryLimit) : options.longs === Number ? new $util.LongBits(message.memoryLimit.low >>> 0, message.memoryLimit.high >>> 0).toNumber(true) : message.memoryLimit;\n                if (message.fileOffset != null && message.hasOwnProperty(\"fileOffset\"))\n                    if (typeof message.fileOffset === \"number\")\n                        object.fileOffset = options.longs === String ? String(message.fileOffset) : message.fileOffset;\n                    else\n                        object.fileOffset = options.longs === String ? $util.Long.prototype.toString.call(message.fileOffset) : options.longs === Number ? new $util.LongBits(message.fileOffset.low >>> 0, message.fileOffset.high >>> 0).toNumber(true) : message.fileOffset;\n                if (message.filename != null && message.hasOwnProperty(\"filename\"))\n                    if (typeof message.filename === \"number\")\n                        object.filename = options.longs === String ? String(message.filename) : message.filename;\n                    else\n                        object.filename = options.longs === String ? $util.Long.prototype.toString.call(message.filename) : options.longs === Number ? new $util.LongBits(message.filename.low >>> 0, message.filename.high >>> 0).toNumber() : message.filename;\n                if (message.buildId != null && message.hasOwnProperty(\"buildId\"))\n                    if (typeof message.buildId === \"number\")\n                        object.buildId = options.longs === String ? String(message.buildId) : message.buildId;\n                    else\n                        object.buildId = options.longs === String ? $util.Long.prototype.toString.call(message.buildId) : options.longs === Number ? new $util.LongBits(message.buildId.low >>> 0, message.buildId.high >>> 0).toNumber() : message.buildId;\n                if (message.hasFunctions != null && message.hasOwnProperty(\"hasFunctions\"))\n                    object.hasFunctions = message.hasFunctions;\n                if (message.hasFilenames != null && message.hasOwnProperty(\"hasFilenames\"))\n                    object.hasFilenames = message.hasFilenames;\n                if (message.hasLineNumbers != null && message.hasOwnProperty(\"hasLineNumbers\"))\n                    object.hasLineNumbers = message.hasLineNumbers;\n                if (message.hasInlineFrames != null && message.hasOwnProperty(\"hasInlineFrames\"))\n                    object.hasInlineFrames = message.hasInlineFrames;\n                return object;\n            };\n\n            /**\n             * Converts this Mapping to JSON.\n             * @function toJSON\n             * @memberof perftools.profiles.Mapping\n             * @instance\n             * @returns {Object.<string,*>} JSON object\n             */\n            Mapping.prototype.toJSON = function toJSON() {\n                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n            };\n\n            return Mapping;\n        })();\n\n        profiles.Location = (function() {\n\n            /**\n             * Properties of a Location.\n             * @memberof perftools.profiles\n             * @interface ILocation\n             * @property {number|Long} [id] Location id\n             * @property {number|Long} [mappingId] Location mappingId\n             * @property {number|Long} [address] Location address\n             * @property {Array.<perftools.profiles.ILine>} [line] Location line\n             */\n\n            /**\n             * Constructs a new Location.\n             * @memberof perftools.profiles\n             * @classdesc Represents a Location.\n             * @constructor\n             * @param {perftools.profiles.ILocation=} [properties] Properties to set\n             */\n            function Location(properties) {\n                this.line = [];\n                if (properties)\n                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }\n\n            /**\n             * Location id.\n             * @member {number|Long}id\n             * @memberof perftools.profiles.Location\n             * @instance\n             */\n            Location.prototype.id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;\n\n            /**\n             * Location mappingId.\n             * @member {number|Long}mappingId\n             * @memberof perftools.profiles.Location\n             * @instance\n             */\n            Location.prototype.mappingId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;\n\n            /**\n             * Location address.\n             * @member {number|Long}address\n             * @memberof perftools.profiles.Location\n             * @instance\n             */\n            Location.prototype.address = $util.Long ? $util.Long.fromBits(0,0,true) : 0;\n\n            /**\n             * Location line.\n             * @member {Array.<perftools.profiles.ILine>}line\n             * @memberof perftools.profiles.Location\n             * @instance\n             */\n            Location.prototype.line = $util.emptyArray;\n\n            /**\n             * Creates a new Location instance using the specified properties.\n             * @function create\n             * @memberof perftools.profiles.Location\n             * @static\n             * @param {perftools.profiles.ILocation=} [properties] Properties to set\n             * @returns {perftools.profiles.Location} Location instance\n             */\n            Location.create = function create(properties) {\n                return new Location(properties);\n            };\n\n            /**\n             * Encodes the specified Location message. Does not implicitly {@link perftools.profiles.Location.verify|verify} messages.\n             * @function encode\n             * @memberof perftools.profiles.Location\n             * @static\n             * @param {perftools.profiles.ILocation} message Location message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            Location.encode = function encode(message, writer) {\n                if (!writer)\n                    writer = $Writer.create();\n                if (message.id != null && message.hasOwnProperty(\"id\"))\n                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.id);\n                if (message.mappingId != null && message.hasOwnProperty(\"mappingId\"))\n                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.mappingId);\n                if (message.address != null && message.hasOwnProperty(\"address\"))\n                    writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.address);\n                if (message.line != null && message.line.length)\n                    for (var i = 0; i < message.line.length; ++i)\n                        $root.perftools.profiles.Line.encode(message.line[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();\n                return writer;\n            };\n\n            /**\n             * Encodes the specified Location message, length delimited. Does not implicitly {@link perftools.profiles.Location.verify|verify} messages.\n             * @function encodeDelimited\n             * @memberof perftools.profiles.Location\n             * @static\n             * @param {perftools.profiles.ILocation} message Location message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            Location.encodeDelimited = function encodeDelimited(message, writer) {\n                return this.encode(message, writer).ldelim();\n            };\n\n            /**\n             * Decodes a Location message from the specified reader or buffer.\n             * @function decode\n             * @memberof perftools.profiles.Location\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {perftools.profiles.Location} Location\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            Location.decode = function decode(reader, length) {\n                if (!(reader instanceof $Reader))\n                    reader = $Reader.create(reader);\n                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.perftools.profiles.Location();\n                while (reader.pos < end) {\n                    var tag = reader.uint32();\n                    switch (tag >>> 3) {\n                    case 1:\n                        message.id = reader.uint64();\n                        break;\n                    case 2:\n                        message.mappingId = reader.uint64();\n                        break;\n                    case 3:\n                        message.address = reader.uint64();\n                        break;\n                    case 4:\n                        if (!(message.line && message.line.length))\n                            message.line = [];\n                        message.line.push($root.perftools.profiles.Line.decode(reader, reader.uint32()));\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                    }\n                }\n                return message;\n            };\n\n            /**\n             * Decodes a Location message from the specified reader or buffer, length delimited.\n             * @function decodeDelimited\n             * @memberof perftools.profiles.Location\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @returns {perftools.profiles.Location} Location\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            Location.decodeDelimited = function decodeDelimited(reader) {\n                if (!(reader instanceof $Reader))\n                    reader = new $Reader(reader);\n                return this.decode(reader, reader.uint32());\n            };\n\n            /**\n             * Verifies a Location message.\n             * @function verify\n             * @memberof perftools.profiles.Location\n             * @static\n             * @param {Object.<string,*>} message Plain object to verify\n             * @returns {string|null} `null` if valid, otherwise the reason why it is not\n             */\n            Location.verify = function verify(message) {\n                if (typeof message !== \"object\" || message === null)\n                    return \"object expected\";\n                if (message.id != null && message.hasOwnProperty(\"id\"))\n                    if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))\n                        return \"id: integer|Long expected\";\n                if (message.mappingId != null && message.hasOwnProperty(\"mappingId\"))\n                    if (!$util.isInteger(message.mappingId) && !(message.mappingId && $util.isInteger(message.mappingId.low) && $util.isInteger(message.mappingId.high)))\n                        return \"mappingId: integer|Long expected\";\n                if (message.address != null && message.hasOwnProperty(\"address\"))\n                    if (!$util.isInteger(message.address) && !(message.address && $util.isInteger(message.address.low) && $util.isInteger(message.address.high)))\n                        return \"address: integer|Long expected\";\n                if (message.line != null && message.hasOwnProperty(\"line\")) {\n                    if (!Array.isArray(message.line))\n                        return \"line: array expected\";\n                    for (var i = 0; i < message.line.length; ++i) {\n                        var error = $root.perftools.profiles.Line.verify(message.line[i]);\n                        if (error)\n                            return \"line.\" + error;\n                    }\n                }\n                return null;\n            };\n\n            /**\n             * Creates a Location message from a plain object. Also converts values to their respective internal types.\n             * @function fromObject\n             * @memberof perftools.profiles.Location\n             * @static\n             * @param {Object.<string,*>} object Plain object\n             * @returns {perftools.profiles.Location} Location\n             */\n            Location.fromObject = function fromObject(object) {\n                if (object instanceof $root.perftools.profiles.Location)\n                    return object;\n                var message = new $root.perftools.profiles.Location();\n                if (object.id != null)\n                    if ($util.Long)\n                        (message.id = $util.Long.fromValue(object.id)).unsigned = true;\n                    else if (typeof object.id === \"string\")\n                        message.id = parseInt(object.id, 10);\n                    else if (typeof object.id === \"number\")\n                        message.id = object.id;\n                    else if (typeof object.id === \"object\")\n                        message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);\n                if (object.mappingId != null)\n                    if ($util.Long)\n                        (message.mappingId = $util.Long.fromValue(object.mappingId)).unsigned = true;\n                    else if (typeof object.mappingId === \"string\")\n                        message.mappingId = parseInt(object.mappingId, 10);\n                    else if (typeof object.mappingId === \"number\")\n                        message.mappingId = object.mappingId;\n                    else if (typeof object.mappingId === \"object\")\n                        message.mappingId = new $util.LongBits(object.mappingId.low >>> 0, object.mappingId.high >>> 0).toNumber(true);\n                if (object.address != null)\n                    if ($util.Long)\n                        (message.address = $util.Long.fromValue(object.address)).unsigned = true;\n                    else if (typeof object.address === \"string\")\n                        message.address = parseInt(object.address, 10);\n                    else if (typeof object.address === \"number\")\n                        message.address = object.address;\n                    else if (typeof object.address === \"object\")\n                        message.address = new $util.LongBits(object.address.low >>> 0, object.address.high >>> 0).toNumber(true);\n                if (object.line) {\n                    if (!Array.isArray(object.line))\n                        throw TypeError(\".perftools.profiles.Location.line: array expected\");\n                    message.line = [];\n                    for (var i = 0; i < object.line.length; ++i) {\n                        if (typeof object.line[i] !== \"object\")\n                            throw TypeError(\".perftools.profiles.Location.line: object expected\");\n                        message.line[i] = $root.perftools.profiles.Line.fromObject(object.line[i]);\n                    }\n                }\n                return message;\n            };\n\n            /**\n             * Creates a plain object from a Location message. Also converts values to other types if specified.\n             * @function toObject\n             * @memberof perftools.profiles.Location\n             * @static\n             * @param {perftools.profiles.Location} message Location\n             * @param {$protobuf.IConversionOptions} [options] Conversion options\n             * @returns {Object.<string,*>} Plain object\n             */\n            Location.toObject = function toObject(message, options) {\n                if (!options)\n                    options = {};\n                var object = {};\n                if (options.arrays || options.defaults)\n                    object.line = [];\n                if (options.defaults) {\n                    if ($util.Long) {\n                        var long = new $util.Long(0, 0, true);\n                        object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                    } else\n                        object.id = options.longs === String ? \"0\" : 0;\n                    if ($util.Long) {\n                        var long = new $util.Long(0, 0, true);\n                        object.mappingId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                    } else\n                        object.mappingId = options.longs === String ? \"0\" : 0;\n                    if ($util.Long) {\n                        var long = new $util.Long(0, 0, true);\n                        object.address = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                    } else\n                        object.address = options.longs === String ? \"0\" : 0;\n                }\n                if (message.id != null && message.hasOwnProperty(\"id\"))\n                    if (typeof message.id === \"number\")\n                        object.id = options.longs === String ? String(message.id) : message.id;\n                    else\n                        object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true) : message.id;\n                if (message.mappingId != null && message.hasOwnProperty(\"mappingId\"))\n                    if (typeof message.mappingId === \"number\")\n                        object.mappingId = options.longs === String ? String(message.mappingId) : message.mappingId;\n                    else\n                        object.mappingId = options.longs === String ? $util.Long.prototype.toString.call(message.mappingId) : options.longs === Number ? new $util.LongBits(message.mappingId.low >>> 0, message.mappingId.high >>> 0).toNumber(true) : message.mappingId;\n                if (message.address != null && message.hasOwnProperty(\"address\"))\n                    if (typeof message.address === \"number\")\n                        object.address = options.longs === String ? String(message.address) : message.address;\n                    else\n                        object.address = options.longs === String ? $util.Long.prototype.toString.call(message.address) : options.longs === Number ? new $util.LongBits(message.address.low >>> 0, message.address.high >>> 0).toNumber(true) : message.address;\n                if (message.line && message.line.length) {\n                    object.line = [];\n                    for (var j = 0; j < message.line.length; ++j)\n                        object.line[j] = $root.perftools.profiles.Line.toObject(message.line[j], options);\n                }\n                return object;\n            };\n\n            /**\n             * Converts this Location to JSON.\n             * @function toJSON\n             * @memberof perftools.profiles.Location\n             * @instance\n             * @returns {Object.<string,*>} JSON object\n             */\n            Location.prototype.toJSON = function toJSON() {\n                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n            };\n\n            return Location;\n        })();\n\n        profiles.Line = (function() {\n\n            /**\n             * Properties of a Line.\n             * @memberof perftools.profiles\n             * @interface ILine\n             * @property {number|Long} [functionId] Line functionId\n             * @property {number|Long} [line] Line line\n             */\n\n            /**\n             * Constructs a new Line.\n             * @memberof perftools.profiles\n             * @classdesc Represents a Line.\n             * @constructor\n             * @param {perftools.profiles.ILine=} [properties] Properties to set\n             */\n            function Line(properties) {\n                if (properties)\n                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }\n\n            /**\n             * Line functionId.\n             * @member {number|Long}functionId\n             * @memberof perftools.profiles.Line\n             * @instance\n             */\n            Line.prototype.functionId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;\n\n            /**\n             * Line line.\n             * @member {number|Long}line\n             * @memberof perftools.profiles.Line\n             * @instance\n             */\n            Line.prototype.line = $util.Long ? $util.Long.fromBits(0,0,false) : 0;\n\n            /**\n             * Creates a new Line instance using the specified properties.\n             * @function create\n             * @memberof perftools.profiles.Line\n             * @static\n             * @param {perftools.profiles.ILine=} [properties] Properties to set\n             * @returns {perftools.profiles.Line} Line instance\n             */\n            Line.create = function create(properties) {\n                return new Line(properties);\n            };\n\n            /**\n             * Encodes the specified Line message. Does not implicitly {@link perftools.profiles.Line.verify|verify} messages.\n             * @function encode\n             * @memberof perftools.profiles.Line\n             * @static\n             * @param {perftools.profiles.ILine} message Line message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            Line.encode = function encode(message, writer) {\n                if (!writer)\n                    writer = $Writer.create();\n                if (message.functionId != null && message.hasOwnProperty(\"functionId\"))\n                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.functionId);\n                if (message.line != null && message.hasOwnProperty(\"line\"))\n                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.line);\n                return writer;\n            };\n\n            /**\n             * Encodes the specified Line message, length delimited. Does not implicitly {@link perftools.profiles.Line.verify|verify} messages.\n             * @function encodeDelimited\n             * @memberof perftools.profiles.Line\n             * @static\n             * @param {perftools.profiles.ILine} message Line message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            Line.encodeDelimited = function encodeDelimited(message, writer) {\n                return this.encode(message, writer).ldelim();\n            };\n\n            /**\n             * Decodes a Line message from the specified reader or buffer.\n             * @function decode\n             * @memberof perftools.profiles.Line\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {perftools.profiles.Line} Line\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            Line.decode = function decode(reader, length) {\n                if (!(reader instanceof $Reader))\n                    reader = $Reader.create(reader);\n                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.perftools.profiles.Line();\n                while (reader.pos < end) {\n                    var tag = reader.uint32();\n                    switch (tag >>> 3) {\n                    case 1:\n                        message.functionId = reader.uint64();\n                        break;\n                    case 2:\n                        message.line = reader.int64();\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                    }\n                }\n                return message;\n            };\n\n            /**\n             * Decodes a Line message from the specified reader or buffer, length delimited.\n             * @function decodeDelimited\n             * @memberof perftools.profiles.Line\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @returns {perftools.profiles.Line} Line\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            Line.decodeDelimited = function decodeDelimited(reader) {\n                if (!(reader instanceof $Reader))\n                    reader = new $Reader(reader);\n                return this.decode(reader, reader.uint32());\n            };\n\n            /**\n             * Verifies a Line message.\n             * @function verify\n             * @memberof perftools.profiles.Line\n             * @static\n             * @param {Object.<string,*>} message Plain object to verify\n             * @returns {string|null} `null` if valid, otherwise the reason why it is not\n             */\n            Line.verify = function verify(message) {\n                if (typeof message !== \"object\" || message === null)\n                    return \"object expected\";\n                if (message.functionId != null && message.hasOwnProperty(\"functionId\"))\n                    if (!$util.isInteger(message.functionId) && !(message.functionId && $util.isInteger(message.functionId.low) && $util.isInteger(message.functionId.high)))\n                        return \"functionId: integer|Long expected\";\n                if (message.line != null && message.hasOwnProperty(\"line\"))\n                    if (!$util.isInteger(message.line) && !(message.line && $util.isInteger(message.line.low) && $util.isInteger(message.line.high)))\n                        return \"line: integer|Long expected\";\n                return null;\n            };\n\n            /**\n             * Creates a Line message from a plain object. Also converts values to their respective internal types.\n             * @function fromObject\n             * @memberof perftools.profiles.Line\n             * @static\n             * @param {Object.<string,*>} object Plain object\n             * @returns {perftools.profiles.Line} Line\n             */\n            Line.fromObject = function fromObject(object) {\n                if (object instanceof $root.perftools.profiles.Line)\n                    return object;\n                var message = new $root.perftools.profiles.Line();\n                if (object.functionId != null)\n                    if ($util.Long)\n                        (message.functionId = $util.Long.fromValue(object.functionId)).unsigned = true;\n                    else if (typeof object.functionId === \"string\")\n                        message.functionId = parseInt(object.functionId, 10);\n                    else if (typeof object.functionId === \"number\")\n                        message.functionId = object.functionId;\n                    else if (typeof object.functionId === \"object\")\n                        message.functionId = new $util.LongBits(object.functionId.low >>> 0, object.functionId.high >>> 0).toNumber(true);\n                if (object.line != null)\n                    if ($util.Long)\n                        (message.line = $util.Long.fromValue(object.line)).unsigned = false;\n                    else if (typeof object.line === \"string\")\n                        message.line = parseInt(object.line, 10);\n                    else if (typeof object.line === \"number\")\n                        message.line = object.line;\n                    else if (typeof object.line === \"object\")\n                        message.line = new $util.LongBits(object.line.low >>> 0, object.line.high >>> 0).toNumber();\n                return message;\n            };\n\n            /**\n             * Creates a plain object from a Line message. Also converts values to other types if specified.\n             * @function toObject\n             * @memberof perftools.profiles.Line\n             * @static\n             * @param {perftools.profiles.Line} message Line\n             * @param {$protobuf.IConversionOptions} [options] Conversion options\n             * @returns {Object.<string,*>} Plain object\n             */\n            Line.toObject = function toObject(message, options) {\n                if (!options)\n                    options = {};\n                var object = {};\n                if (options.defaults) {\n                    if ($util.Long) {\n                        var long = new $util.Long(0, 0, true);\n                        object.functionId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                    } else\n                        object.functionId = options.longs === String ? \"0\" : 0;\n                    if ($util.Long) {\n                        var long = new $util.Long(0, 0, false);\n                        object.line = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                    } else\n                        object.line = options.longs === String ? \"0\" : 0;\n                }\n                if (message.functionId != null && message.hasOwnProperty(\"functionId\"))\n                    if (typeof message.functionId === \"number\")\n                        object.functionId = options.longs === String ? String(message.functionId) : message.functionId;\n                    else\n                        object.functionId = options.longs === String ? $util.Long.prototype.toString.call(message.functionId) : options.longs === Number ? new $util.LongBits(message.functionId.low >>> 0, message.functionId.high >>> 0).toNumber(true) : message.functionId;\n                if (message.line != null && message.hasOwnProperty(\"line\"))\n                    if (typeof message.line === \"number\")\n                        object.line = options.longs === String ? String(message.line) : message.line;\n                    else\n                        object.line = options.longs === String ? $util.Long.prototype.toString.call(message.line) : options.longs === Number ? new $util.LongBits(message.line.low >>> 0, message.line.high >>> 0).toNumber() : message.line;\n                return object;\n            };\n\n            /**\n             * Converts this Line to JSON.\n             * @function toJSON\n             * @memberof perftools.profiles.Line\n             * @instance\n             * @returns {Object.<string,*>} JSON object\n             */\n            Line.prototype.toJSON = function toJSON() {\n                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n            };\n\n            return Line;\n        })();\n\n        profiles.Function = (function() {\n\n            /**\n             * Properties of a Function.\n             * @memberof perftools.profiles\n             * @interface IFunction\n             * @property {number|Long} [id] Function id\n             * @property {number|Long} [name] Function name\n             * @property {number|Long} [systemName] Function systemName\n             * @property {number|Long} [filename] Function filename\n             * @property {number|Long} [startLine] Function startLine\n             */\n\n            /**\n             * Constructs a new Function.\n             * @memberof perftools.profiles\n             * @classdesc Represents a Function.\n             * @constructor\n             * @param {perftools.profiles.IFunction=} [properties] Properties to set\n             */\n            function Function(properties) {\n                if (properties)\n                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }\n\n            /**\n             * Function id.\n             * @member {number|Long}id\n             * @memberof perftools.profiles.Function\n             * @instance\n             */\n            Function.prototype.id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;\n\n            /**\n             * Function name.\n             * @member {number|Long}name\n             * @memberof perftools.profiles.Function\n             * @instance\n             */\n            Function.prototype.name = $util.Long ? $util.Long.fromBits(0,0,false) : 0;\n\n            /**\n             * Function systemName.\n             * @member {number|Long}systemName\n             * @memberof perftools.profiles.Function\n             * @instance\n             */\n            Function.prototype.systemName = $util.Long ? $util.Long.fromBits(0,0,false) : 0;\n\n            /**\n             * Function filename.\n             * @member {number|Long}filename\n             * @memberof perftools.profiles.Function\n             * @instance\n             */\n            Function.prototype.filename = $util.Long ? $util.Long.fromBits(0,0,false) : 0;\n\n            /**\n             * Function startLine.\n             * @member {number|Long}startLine\n             * @memberof perftools.profiles.Function\n             * @instance\n             */\n            Function.prototype.startLine = $util.Long ? $util.Long.fromBits(0,0,false) : 0;\n\n            /**\n             * Creates a new Function instance using the specified properties.\n             * @function create\n             * @memberof perftools.profiles.Function\n             * @static\n             * @param {perftools.profiles.IFunction=} [properties] Properties to set\n             * @returns {perftools.profiles.Function} Function instance\n             */\n            Function.create = function create(properties) {\n                return new Function(properties);\n            };\n\n            /**\n             * Encodes the specified Function message. Does not implicitly {@link perftools.profiles.Function.verify|verify} messages.\n             * @function encode\n             * @memberof perftools.profiles.Function\n             * @static\n             * @param {perftools.profiles.IFunction} message Function message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            Function.encode = function encode(message, writer) {\n                if (!writer)\n                    writer = $Writer.create();\n                if (message.id != null && message.hasOwnProperty(\"id\"))\n                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.id);\n                if (message.name != null && message.hasOwnProperty(\"name\"))\n                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.name);\n                if (message.systemName != null && message.hasOwnProperty(\"systemName\"))\n                    writer.uint32(/* id 3, wireType 0 =*/24).int64(message.systemName);\n                if (message.filename != null && message.hasOwnProperty(\"filename\"))\n                    writer.uint32(/* id 4, wireType 0 =*/32).int64(message.filename);\n                if (message.startLine != null && message.hasOwnProperty(\"startLine\"))\n                    writer.uint32(/* id 5, wireType 0 =*/40).int64(message.startLine);\n                return writer;\n            };\n\n            /**\n             * Encodes the specified Function message, length delimited. Does not implicitly {@link perftools.profiles.Function.verify|verify} messages.\n             * @function encodeDelimited\n             * @memberof perftools.profiles.Function\n             * @static\n             * @param {perftools.profiles.IFunction} message Function message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            Function.encodeDelimited = function encodeDelimited(message, writer) {\n                return this.encode(message, writer).ldelim();\n            };\n\n            /**\n             * Decodes a Function message from the specified reader or buffer.\n             * @function decode\n             * @memberof perftools.profiles.Function\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {perftools.profiles.Function} Function\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            Function.decode = function decode(reader, length) {\n                if (!(reader instanceof $Reader))\n                    reader = $Reader.create(reader);\n                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.perftools.profiles.Function();\n                while (reader.pos < end) {\n                    var tag = reader.uint32();\n                    switch (tag >>> 3) {\n                    case 1:\n                        message.id = reader.uint64();\n                        break;\n                    case 2:\n                        message.name = reader.int64();\n                        break;\n                    case 3:\n                        message.systemName = reader.int64();\n                        break;\n                    case 4:\n                        message.filename = reader.int64();\n                        break;\n                    case 5:\n                        message.startLine = reader.int64();\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                    }\n                }\n                return message;\n            };\n\n            /**\n             * Decodes a Function message from the specified reader or buffer, length delimited.\n             * @function decodeDelimited\n             * @memberof perftools.profiles.Function\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @returns {perftools.profiles.Function} Function\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            Function.decodeDelimited = function decodeDelimited(reader) {\n                if (!(reader instanceof $Reader))\n                    reader = new $Reader(reader);\n                return this.decode(reader, reader.uint32());\n            };\n\n            /**\n             * Verifies a Function message.\n             * @function verify\n             * @memberof perftools.profiles.Function\n             * @static\n             * @param {Object.<string,*>} message Plain object to verify\n             * @returns {string|null} `null` if valid, otherwise the reason why it is not\n             */\n            Function.verify = function verify(message) {\n                if (typeof message !== \"object\" || message === null)\n                    return \"object expected\";\n                if (message.id != null && message.hasOwnProperty(\"id\"))\n                    if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))\n                        return \"id: integer|Long expected\";\n                if (message.name != null && message.hasOwnProperty(\"name\"))\n                    if (!$util.isInteger(message.name) && !(message.name && $util.isInteger(message.name.low) && $util.isInteger(message.name.high)))\n                        return \"name: integer|Long expected\";\n                if (message.systemName != null && message.hasOwnProperty(\"systemName\"))\n                    if (!$util.isInteger(message.systemName) && !(message.systemName && $util.isInteger(message.systemName.low) && $util.isInteger(message.systemName.high)))\n                        return \"systemName: integer|Long expected\";\n                if (message.filename != null && message.hasOwnProperty(\"filename\"))\n                    if (!$util.isInteger(message.filename) && !(message.filename && $util.isInteger(message.filename.low) && $util.isInteger(message.filename.high)))\n                        return \"filename: integer|Long expected\";\n                if (message.startLine != null && message.hasOwnProperty(\"startLine\"))\n                    if (!$util.isInteger(message.startLine) && !(message.startLine && $util.isInteger(message.startLine.low) && $util.isInteger(message.startLine.high)))\n                        return \"startLine: integer|Long expected\";\n                return null;\n            };\n\n            /**\n             * Creates a Function message from a plain object. Also converts values to their respective internal types.\n             * @function fromObject\n             * @memberof perftools.profiles.Function\n             * @static\n             * @param {Object.<string,*>} object Plain object\n             * @returns {perftools.profiles.Function} Function\n             */\n            Function.fromObject = function fromObject(object) {\n                if (object instanceof $root.perftools.profiles.Function)\n                    return object;\n                var message = new $root.perftools.profiles.Function();\n                if (object.id != null)\n                    if ($util.Long)\n                        (message.id = $util.Long.fromValue(object.id)).unsigned = true;\n                    else if (typeof object.id === \"string\")\n                        message.id = parseInt(object.id, 10);\n                    else if (typeof object.id === \"number\")\n                        message.id = object.id;\n                    else if (typeof object.id === \"object\")\n                        message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);\n                if (object.name != null)\n                    if ($util.Long)\n                        (message.name = $util.Long.fromValue(object.name)).unsigned = false;\n                    else if (typeof object.name === \"string\")\n                        message.name = parseInt(object.name, 10);\n                    else if (typeof object.name === \"number\")\n                        message.name = object.name;\n                    else if (typeof object.name === \"object\")\n                        message.name = new $util.LongBits(object.name.low >>> 0, object.name.high >>> 0).toNumber();\n                if (object.systemName != null)\n                    if ($util.Long)\n                        (message.systemName = $util.Long.fromValue(object.systemName)).unsigned = false;\n                    else if (typeof object.systemName === \"string\")\n                        message.systemName = parseInt(object.systemName, 10);\n                    else if (typeof object.systemName === \"number\")\n                        message.systemName = object.systemName;\n                    else if (typeof object.systemName === \"object\")\n                        message.systemName = new $util.LongBits(object.systemName.low >>> 0, object.systemName.high >>> 0).toNumber();\n                if (object.filename != null)\n                    if ($util.Long)\n                        (message.filename = $util.Long.fromValue(object.filename)).unsigned = false;\n                    else if (typeof object.filename === \"string\")\n                        message.filename = parseInt(object.filename, 10);\n                    else if (typeof object.filename === \"number\")\n                        message.filename = object.filename;\n                    else if (typeof object.filename === \"object\")\n                        message.filename = new $util.LongBits(object.filename.low >>> 0, object.filename.high >>> 0).toNumber();\n                if (object.startLine != null)\n                    if ($util.Long)\n                        (message.startLine = $util.Long.fromValue(object.startLine)).unsigned = false;\n                    else if (typeof object.startLine === \"string\")\n                        message.startLine = parseInt(object.startLine, 10);\n                    else if (typeof object.startLine === \"number\")\n                        message.startLine = object.startLine;\n                    else if (typeof object.startLine === \"object\")\n                        message.startLine = new $util.LongBits(object.startLine.low >>> 0, object.startLine.high >>> 0).toNumber();\n                return message;\n            };\n\n            /**\n             * Creates a plain object from a Function message. Also converts values to other types if specified.\n             * @function toObject\n             * @memberof perftools.profiles.Function\n             * @static\n             * @param {perftools.profiles.Function} message Function\n             * @param {$protobuf.IConversionOptions} [options] Conversion options\n             * @returns {Object.<string,*>} Plain object\n             */\n            Function.toObject = function toObject(message, options) {\n                if (!options)\n                    options = {};\n                var object = {};\n                if (options.defaults) {\n                    if ($util.Long) {\n                        var long = new $util.Long(0, 0, true);\n                        object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                    } else\n                        object.id = options.longs === String ? \"0\" : 0;\n                    if ($util.Long) {\n                        var long = new $util.Long(0, 0, false);\n                        object.name = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                    } else\n                        object.name = options.longs === String ? \"0\" : 0;\n                    if ($util.Long) {\n                        var long = new $util.Long(0, 0, false);\n                        object.systemName = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                    } else\n                        object.systemName = options.longs === String ? \"0\" : 0;\n                    if ($util.Long) {\n                        var long = new $util.Long(0, 0, false);\n                        object.filename = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                    } else\n                        object.filename = options.longs === String ? \"0\" : 0;\n                    if ($util.Long) {\n                        var long = new $util.Long(0, 0, false);\n                        object.startLine = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                    } else\n                        object.startLine = options.longs === String ? \"0\" : 0;\n                }\n                if (message.id != null && message.hasOwnProperty(\"id\"))\n                    if (typeof message.id === \"number\")\n                        object.id = options.longs === String ? String(message.id) : message.id;\n                    else\n                        object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true) : message.id;\n                if (message.name != null && message.hasOwnProperty(\"name\"))\n                    if (typeof message.name === \"number\")\n                        object.name = options.longs === String ? String(message.name) : message.name;\n                    else\n                        object.name = options.longs === String ? $util.Long.prototype.toString.call(message.name) : options.longs === Number ? new $util.LongBits(message.name.low >>> 0, message.name.high >>> 0).toNumber() : message.name;\n                if (message.systemName != null && message.hasOwnProperty(\"systemName\"))\n                    if (typeof message.systemName === \"number\")\n                        object.systemName = options.longs === String ? String(message.systemName) : message.systemName;\n                    else\n                        object.systemName = options.longs === String ? $util.Long.prototype.toString.call(message.systemName) : options.longs === Number ? new $util.LongBits(message.systemName.low >>> 0, message.systemName.high >>> 0).toNumber() : message.systemName;\n                if (message.filename != null && message.hasOwnProperty(\"filename\"))\n                    if (typeof message.filename === \"number\")\n                        object.filename = options.longs === String ? String(message.filename) : message.filename;\n                    else\n                        object.filename = options.longs === String ? $util.Long.prototype.toString.call(message.filename) : options.longs === Number ? new $util.LongBits(message.filename.low >>> 0, message.filename.high >>> 0).toNumber() : message.filename;\n                if (message.startLine != null && message.hasOwnProperty(\"startLine\"))\n                    if (typeof message.startLine === \"number\")\n                        object.startLine = options.longs === String ? String(message.startLine) : message.startLine;\n                    else\n                        object.startLine = options.longs === String ? $util.Long.prototype.toString.call(message.startLine) : options.longs === Number ? new $util.LongBits(message.startLine.low >>> 0, message.startLine.high >>> 0).toNumber() : message.startLine;\n                return object;\n            };\n\n            /**\n             * Converts this Function to JSON.\n             * @function toJSON\n             * @memberof perftools.profiles.Function\n             * @instance\n             * @returns {Object.<string,*>} JSON object\n             */\n            Function.prototype.toJSON = function toJSON() {\n                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n            };\n\n            return Function;\n        })();\n\n        return profiles;\n    })();\n\n    return perftools;\n})();\n\nmodule.exports = $root;\n","\"use strict\";\n/*\n * Unless explicitly stated otherwise all files in this repository are licensed\n * under the Apache 2.0 license (see LICENSE).\n * This product includes software developed at Datadog (https://www.datadoghq.com/).\n * Copyright 2020 Datadog, Inc.\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DDSketch = void 0;\nvar store_1 = require(\"./store\");\nvar mapping_1 = require(\"./mapping\");\nvar compiled_1 = require(\"./proto/compiled\");\nvar DEFAULT_RELATIVE_ACCURACY = 0.01;\n/** Base class for DDSketch*/\nvar BaseDDSketch = /** @class */ (function () {\n    function BaseDDSketch(_a) {\n        var mapping = _a.mapping, store = _a.store, negativeStore = _a.negativeStore, zeroCount = _a.zeroCount;\n        this.mapping = mapping;\n        this.store = store;\n        this.negativeStore = negativeStore;\n        this.zeroCount = zeroCount;\n        this.count =\n            this.negativeStore.count + this.zeroCount + this.store.count;\n        this.min = Infinity;\n        this.max = -Infinity;\n        this.sum = 0;\n    }\n    /**\n     * Add a value to the sketch\n     *\n     * @param value The value to be added\n     * @param weight The amount to weight the value (default 1.0)\n     *\n     * @throws Error if `weight` is 0 or negative\n     */\n    BaseDDSketch.prototype.accept = function (value, weight) {\n        if (weight === void 0) { weight = 1; }\n        if (weight <= 0) {\n            throw Error('Weight must be a positive number');\n        }\n        if (value > this.mapping.minPossible) {\n            var key = this.mapping.key(value);\n            this.store.add(key, weight);\n        }\n        else if (value < -this.mapping.minPossible) {\n            var key = this.mapping.key(-value);\n            this.negativeStore.add(key, weight);\n        }\n        else {\n            this.zeroCount += weight;\n        }\n        /* Keep track of summary stats */\n        this.count += weight;\n        this.sum += value * weight;\n        if (value < this.min) {\n            this.min = value;\n        }\n        if (value > this.max) {\n            this.max = value;\n        }\n    };\n    /**\n     * Retrieve a value from the sketch at the quantile\n     *\n     * @param quantile A number between `0` and `1` (inclusive)\n     */\n    BaseDDSketch.prototype.getValueAtQuantile = function (quantile) {\n        if (quantile < 0 || quantile > 1 || this.count === 0) {\n            return NaN;\n        }\n        var rank = quantile * (this.count - 1);\n        var quantileValue = 0;\n        if (rank < this.negativeStore.count) {\n            var reversedRank = this.negativeStore.count - rank - 1;\n            var key = this.negativeStore.keyAtRank(reversedRank, false);\n            quantileValue = -this.mapping.value(key);\n        }\n        else if (rank < this.zeroCount + this.negativeStore.count) {\n            return 0;\n        }\n        else {\n            var key = this.store.keyAtRank(rank - this.zeroCount - this.negativeStore.count);\n            quantileValue = this.mapping.value(key);\n        }\n        return quantileValue;\n    };\n    /**\n     * Merge the contents of the parameter `sketch` into this sketch\n     *\n     * @param sketch The sketch to merge into the caller sketch\n     * @throws Error if the sketches were initialized with different `relativeAccuracy` values\n     */\n    BaseDDSketch.prototype.merge = function (sketch) {\n        if (!this.mergeable(sketch)) {\n            throw new Error('Cannot merge two DDSketches with different `relativeAccuracy` parameters');\n        }\n        if (sketch.count === 0) {\n            return;\n        }\n        if (this.count === 0) {\n            this._copy(sketch);\n            return;\n        }\n        this.store.merge(sketch.store);\n        /* Merge summary stats */\n        this.count += sketch.count;\n        this.sum += sketch.sum;\n        if (sketch.min < this.min) {\n            this.min = sketch.min;\n        }\n        if (sketch.max > this.max) {\n            this.max = sketch.max;\n        }\n    };\n    /**\n     * Determine whether two sketches can be merged\n     *\n     * @param sketch The sketch to be merged into the caller sketch\n     */\n    BaseDDSketch.prototype.mergeable = function (sketch) {\n        return this.mapping.gamma === sketch.mapping.gamma;\n    };\n    /**\n     * Helper method to copy the contents of the parameter `store` into this store\n     * @see DDSketch.merge to merge two sketches safely\n     *\n     * @param store The store to be copied into the caller store\n     */\n    BaseDDSketch.prototype._copy = function (sketch) {\n        this.store.copy(sketch.store);\n        this.negativeStore.copy(sketch.negativeStore);\n        this.zeroCount = sketch.zeroCount;\n        this.min = sketch.min;\n        this.max = sketch.max;\n        this.count = sketch.count;\n        this.sum = sketch.sum;\n    };\n    /** Serialize a DDSketch to protobuf format */\n    BaseDDSketch.prototype.toProto = function () {\n        var message = compiled_1.DDSketch.create({\n            mapping: this.mapping.toProto(),\n            positiveValues: this.store.toProto(),\n            negativeValues: this.negativeStore.toProto(),\n            zeroCount: this.zeroCount\n        });\n        return compiled_1.DDSketch.encode(message).finish();\n    };\n    /**\n     * Deserialize a DDSketch from protobuf data\n     *\n     * Note: `fromProto` currently loses summary statistics for the original\n     * sketch (i.e. `min`, `max`)\n     *\n     * @param buffer Byte array containing DDSketch in protobuf format (from DDSketch.toProto)\n     */\n    BaseDDSketch.fromProto = function (buffer) {\n        var decoded = compiled_1.DDSketch.decode(buffer);\n        var mapping = mapping_1.KeyMapping.fromProto(decoded.mapping);\n        var store = store_1.DenseStore.fromProto(decoded.positiveValues);\n        var negativeStore = store_1.DenseStore.fromProto(decoded.negativeValues);\n        var zeroCount = decoded.zeroCount;\n        return new BaseDDSketch({ mapping: mapping, store: store, negativeStore: negativeStore, zeroCount: zeroCount });\n    };\n    return BaseDDSketch;\n}());\nvar defaultConfig = {\n    relativeAccuracy: DEFAULT_RELATIVE_ACCURACY\n};\n/** A quantile sketch with relative-error guarantees */\nvar DDSketch = /** @class */ (function (_super) {\n    __extends(DDSketch, _super);\n    /**\n     * Initialize a new DDSketch\n     *\n     * @param relativeAccuracy The accuracy guarantee of the sketch (default 0.01)\n     */\n    function DDSketch(_a) {\n        var _b = _a === void 0 ? defaultConfig : _a, _c = _b.relativeAccuracy, relativeAccuracy = _c === void 0 ? DEFAULT_RELATIVE_ACCURACY : _c;\n        var _this = this;\n        var mapping = new mapping_1.LogarithmicMapping(relativeAccuracy);\n        var store = new store_1.DenseStore();\n        var negativeStore = new store_1.DenseStore();\n        _this = _super.call(this, { mapping: mapping, store: store, negativeStore: negativeStore, zeroCount: 0 }) || this;\n        return _this;\n    }\n    return DDSketch;\n}(BaseDDSketch));\nexports.DDSketch = DDSketch;\n","\"use strict\";\n/*\n * Unless explicitly stated otherwise all files in this repository are licensed\n * under the Apache 2.0 license (see LICENSE).\n * This product includes software developed at Datadog (https://www.datadoghq.com/).\n * Copyright 2020 Datadog, Inc.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DDSketch = void 0;\nvar DDSketch_1 = require(\"./DDSketch\");\nObject.defineProperty(exports, \"DDSketch\", { enumerable: true, get: function () { return DDSketch_1.DDSketch; } });\n","\"use strict\";\n/*\n * Unless explicitly stated otherwise all files in this repository are licensed\n * under the Apache 2.0 license (see LICENSE).\n * This product includes software developed at Datadog (https://www.datadoghq.com/).\n * Copyright 2020 Datadog, Inc.\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CubicallyInterpolatedMapping = void 0;\nvar KeyMapping_1 = require(\"./KeyMapping\");\nvar math_1 = require(\"../math\");\nvar compiled_1 = require(\"../proto/compiled\");\n/**\n * A fast KeyMapping that approximates the memory-optimal LogarithmicMapping by\n * extracting the floor value of the logarithm to the base 2 from the binary\n * representations of floating-point values and cubically interpolating the\n * logarithm in-between.\n *\n * More detailed documentation of this method can be found in:\n * <a href=\"https://github.com/DataDog/sketches-java/\">sketches-java</a>\n */\nvar CubicallyInterpolatedMapping = /** @class */ (function (_super) {\n    __extends(CubicallyInterpolatedMapping, _super);\n    function CubicallyInterpolatedMapping(relativeAccuracy, offset) {\n        if (offset === void 0) { offset = 0; }\n        var _this = _super.call(this, relativeAccuracy, offset) || this;\n        _this.A = 6 / 35;\n        _this.B = -3 / 5;\n        _this.C = 10 / 7;\n        _this._multiplier /= _this.C;\n        return _this;\n    }\n    /** Approximates log2 using a cubic polynomial */\n    CubicallyInterpolatedMapping.prototype._cubicLog2Approx = function (value) {\n        var _a = math_1.frexp(value), mantissa = _a[0], exponent = _a[1];\n        var significand = 2 * mantissa - 1;\n        return (((this.A * significand + this.B) * significand + this.C) *\n            significand +\n            (exponent - 1));\n    };\n    /** Derived from Cardano's formula */\n    CubicallyInterpolatedMapping.prototype._cubicExp2Approx = function (value) {\n        var exponent = Math.floor(value);\n        var delta0 = this.B * this.B - 3 * this.A * this.C;\n        var delta1 = 2 * this.B * this.B * this.B -\n            9 * this.A * this.B * this.C -\n            27 * this.A * this.A * (value - exponent);\n        var cardano = Math.cbrt((delta1 -\n            Math.sqrt(delta1 * delta1 - 4 * delta0 * delta0 * delta0)) /\n            2);\n        var significandPlusOne = -(this.B + cardano + delta0 / cardano) / (3 * this.A) + 1;\n        var mantissa = significandPlusOne / 2;\n        return math_1.ldexp(mantissa, exponent + 1);\n    };\n    CubicallyInterpolatedMapping.prototype._logGamma = function (value) {\n        return this._cubicLog2Approx(value) * this._multiplier;\n    };\n    CubicallyInterpolatedMapping.prototype._powGamma = function (value) {\n        return this._cubicExp2Approx(value / this._multiplier);\n    };\n    CubicallyInterpolatedMapping.prototype._protoInterpolation = function () {\n        return compiled_1.IndexMapping.Interpolation.CUBIC;\n    };\n    return CubicallyInterpolatedMapping;\n}(KeyMapping_1.KeyMapping));\nexports.CubicallyInterpolatedMapping = CubicallyInterpolatedMapping;\n","\"use strict\";\n/*\n * Unless explicitly stated otherwise all files in this repository are licensed\n * under the Apache 2.0 license (see LICENSE).\n * This product includes software developed at Datadog (https://www.datadoghq.com/).\n * Copyright 2020 Datadog, Inc.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.KeyMapping = void 0;\nvar index_1 = require(\"./index\");\nvar compiled_1 = require(\"../proto/compiled\");\n// 1.1125369292536007e-308\nvar MIN_SAFE_FLOAT = Math.pow(2, -1023);\nvar MAX_SAFE_FLOAT = Number.MAX_VALUE;\n/**\n * A mapping between values and integer indices that imposes relative accuracy\n * guarantees. Specifically, for any value `minPossible() < value <\n * maxPossible` implementations of `KeyMapping` must be such that\n * `value(key(v))` is close to `v` with a relative error that is less than\n * `relativeAccuracy`.\n *\n * In implementations of KeyMapping, there is generally a trade-off between the\n * cost of computing the key and the number of keys that are required to cover a\n * given range of values (memory optimality). The most memory-optimal mapping is\n * the LogarithmicMapping, but it requires the costly evaluation of the logarithm\n * when computing the index. Other mappings can approximate the logarithmic\n * mapping, while being less computationally costly.\n */\nvar KeyMapping = /** @class */ (function () {\n    function KeyMapping(relativeAccuracy, offset) {\n        if (offset === void 0) { offset = 0; }\n        if (relativeAccuracy <= 0 || relativeAccuracy >= 1) {\n            throw Error('Relative accuracy must be between 0 and 1 when initializing a KeyMapping');\n        }\n        this.relativeAccuracy = relativeAccuracy;\n        this._offset = offset;\n        var gammaMantissa = (2 * relativeAccuracy) / (1 - relativeAccuracy);\n        this.gamma = 1 + gammaMantissa;\n        this._multiplier = 1 / Math.log1p(gammaMantissa);\n        this.minPossible = MIN_SAFE_FLOAT * this.gamma;\n        this.maxPossible = MAX_SAFE_FLOAT / this.gamma;\n    }\n    KeyMapping.fromGammaOffset = function (gamma, indexOffset) {\n        var relativeAccuracy = (gamma - 1) / (gamma + 1);\n        return new this(relativeAccuracy, indexOffset);\n    };\n    /** Retrieve the key specifying the bucket for a `value` */\n    KeyMapping.prototype.key = function (value) {\n        return Math.ceil(this._logGamma(value)) + this._offset;\n    };\n    /** Retrieve the value represented by the bucket at `key` */\n    KeyMapping.prototype.value = function (key) {\n        return this._powGamma(key - this._offset) * (2 / (1 + this.gamma));\n    };\n    KeyMapping.prototype.toProto = function () {\n        return compiled_1.IndexMapping.create({\n            gamma: this.gamma,\n            indexOffset: this._offset,\n            interpolation: this._protoInterpolation()\n        });\n    };\n    KeyMapping.fromProto = function (protoMapping) {\n        if (!protoMapping ||\n            /* Double equals (==) is intentional here to check for\n             * `null` | `undefined` without including `0` */\n            protoMapping.gamma == null ||\n            protoMapping.indexOffset == null) {\n            throw Error('Failed to decode mapping from protobuf');\n        }\n        var interpolation = protoMapping.interpolation, gamma = protoMapping.gamma, indexOffset = protoMapping.indexOffset;\n        switch (interpolation) {\n            case compiled_1.IndexMapping.Interpolation.NONE:\n                return index_1.LogarithmicMapping.fromGammaOffset(gamma, indexOffset);\n            case compiled_1.IndexMapping.Interpolation.LINEAR:\n                return index_1.LinearlyInterpolatedMapping.fromGammaOffset(gamma, indexOffset);\n            case compiled_1.IndexMapping.Interpolation.CUBIC:\n                return index_1.CubicallyInterpolatedMapping.fromGammaOffset(gamma, indexOffset);\n            default:\n                throw Error('Unrecognized mapping when decoding from protobuf');\n        }\n    };\n    /** Return (an approximation of) the logarithm of the value base gamma */\n    KeyMapping.prototype._logGamma = function (value) {\n        return Math.log2(value) * this._multiplier;\n    };\n    /** Return (an approximation of) gamma to the power value */\n    KeyMapping.prototype._powGamma = function (value) {\n        return Math.pow(2, value / this._multiplier);\n    };\n    KeyMapping.prototype._protoInterpolation = function () {\n        return compiled_1.IndexMapping.Interpolation.NONE;\n    };\n    return KeyMapping;\n}());\nexports.KeyMapping = KeyMapping;\n","\"use strict\";\n/*\n * Unless explicitly stated otherwise all files in this repository are licensed\n * under the Apache 2.0 license (see LICENSE).\n * This product includes software developed at Datadog (https://www.datadoghq.com/).\n * Copyright 2020 Datadog, Inc.\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.LinearlyInterpolatedMapping = void 0;\nvar KeyMapping_1 = require(\"./KeyMapping\");\nvar math_1 = require(\"../math\");\nvar compiled_1 = require(\"../proto/compiled\");\n/**\n * A fast KeyMapping that approximates the memory-optimal one\n * (LogarithmicMapping) by extracting the floor value of the logarithm to the\n * base 2 from the binary representations of floating-point values and\n * linearly interpolating the logarithm in-between.\n */\nvar LinearlyInterpolatedMapping = /** @class */ (function (_super) {\n    __extends(LinearlyInterpolatedMapping, _super);\n    function LinearlyInterpolatedMapping(relativeAccuracy, offset) {\n        if (offset === void 0) { offset = 0; }\n        return _super.call(this, relativeAccuracy, offset) || this;\n    }\n    /**\n     * Approximates log2 by s + f\n     * where v = (s+1) * 2 ** f  for s in [0, 1)\n     *\n     * frexp(v) returns m and e s.t.\n     * v = m * 2 ** e ; (m in [0.5, 1) or 0.0)\n     * so we adjust m and e accordingly\n     */\n    LinearlyInterpolatedMapping.prototype._log2Approx = function (value) {\n        var _a = math_1.frexp(value), mantissa = _a[0], exponent = _a[1];\n        var significand = 2 * mantissa - 1;\n        return significand + (exponent - 1);\n    };\n    /** Inverse of _log2Approx */\n    LinearlyInterpolatedMapping.prototype._exp2Approx = function (value) {\n        var exponent = Math.floor(value) + 1;\n        var mantissa = (value - exponent + 2) / 2;\n        return math_1.ldexp(mantissa, exponent);\n    };\n    LinearlyInterpolatedMapping.prototype._logGamma = function (value) {\n        return Math.log2(value) * this._multiplier;\n    };\n    LinearlyInterpolatedMapping.prototype._powGamma = function (value) {\n        return Math.pow(2, value / this._multiplier);\n    };\n    LinearlyInterpolatedMapping.prototype._protoInterpolation = function () {\n        return compiled_1.IndexMapping.Interpolation.LINEAR;\n    };\n    return LinearlyInterpolatedMapping;\n}(KeyMapping_1.KeyMapping));\nexports.LinearlyInterpolatedMapping = LinearlyInterpolatedMapping;\n","\"use strict\";\n/*\n * Unless explicitly stated otherwise all files in this repository are licensed\n * under the Apache 2.0 license (see LICENSE).\n * This product includes software developed at Datadog (https://www.datadoghq.com/).\n * Copyright 2020 Datadog, Inc.\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.LogarithmicMapping = void 0;\nvar KeyMapping_1 = require(\"./KeyMapping\");\nvar compiled_1 = require(\"../proto/compiled\");\n/**\n * A memory-optimal KeyMapping, i.e., given a targeted relative accuracy, it\n * requires the least number of keys to cover a given range of values. This is\n * done by logarithmically mapping floating-point values to integers.\n */\nvar LogarithmicMapping = /** @class */ (function (_super) {\n    __extends(LogarithmicMapping, _super);\n    function LogarithmicMapping(relativeAccuracy, offset) {\n        if (offset === void 0) { offset = 0; }\n        var _this = _super.call(this, relativeAccuracy, offset) || this;\n        _this._multiplier *= Math.log(2);\n        return _this;\n    }\n    LogarithmicMapping.prototype._logGamma = function (value) {\n        return Math.log2(value) * this._multiplier;\n    };\n    LogarithmicMapping.prototype._powGamma = function (value) {\n        return Math.pow(2, value / this._multiplier);\n    };\n    LogarithmicMapping.prototype._protoInterpolation = function () {\n        return compiled_1.IndexMapping.Interpolation.NONE;\n    };\n    return LogarithmicMapping;\n}(KeyMapping_1.KeyMapping));\nexports.LogarithmicMapping = LogarithmicMapping;\n","\"use strict\";\n/*\n * Unless explicitly stated otherwise all files in this repository are licensed\n * under the Apache 2.0 license (see LICENSE).\n * This product includes software developed at Datadog (https://www.datadoghq.com/).\n * Copyright 2020 Datadog, Inc.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CubicallyInterpolatedMapping = exports.LinearlyInterpolatedMapping = exports.LogarithmicMapping = exports.KeyMapping = void 0;\nvar KeyMapping_1 = require(\"./KeyMapping\");\nObject.defineProperty(exports, \"KeyMapping\", { enumerable: true, get: function () { return KeyMapping_1.KeyMapping; } });\nvar LogarithmicMapping_1 = require(\"./LogarithmicMapping\");\nObject.defineProperty(exports, \"LogarithmicMapping\", { enumerable: true, get: function () { return LogarithmicMapping_1.LogarithmicMapping; } });\nvar LinearlyInterpolatedMapping_1 = require(\"./LinearlyInterpolatedMapping\");\nObject.defineProperty(exports, \"LinearlyInterpolatedMapping\", { enumerable: true, get: function () { return LinearlyInterpolatedMapping_1.LinearlyInterpolatedMapping; } });\nvar CubicallyInterpolatedMapping_1 = require(\"./CubicallyInterpolatedMapping\");\nObject.defineProperty(exports, \"CubicallyInterpolatedMapping\", { enumerable: true, get: function () { return CubicallyInterpolatedMapping_1.CubicallyInterpolatedMapping; } });\n","\"use strict\";\n/*\n * Unless explicitly stated otherwise all files in this repository are licensed\n * under the Apache 2.0 license (see LICENSE).\n * This product includes software developed at Datadog (https://www.datadoghq.com/).\n * Copyright 2020 Datadog, Inc.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ldexp = exports.frexp = void 0;\n/**\n * Splits a double-precision floating-point number into a normalized fraction\n * and an integer power of two.\n */\nfunction frexp(value) {\n    if (value === 0 || !Number.isFinite(value))\n        return [value, 0];\n    var absValue = Math.abs(value);\n    var exponent = Math.max(-1023, Math.floor(Math.log2(absValue)) + 1);\n    var mantissa = absValue * Math.pow(2, -exponent);\n    while (mantissa < 0.5) {\n        mantissa *= 2;\n        exponent--;\n    }\n    while (mantissa >= 1) {\n        mantissa *= 0.5;\n        exponent++;\n    }\n    if (value < 0) {\n        mantissa = -mantissa;\n    }\n    return [mantissa, exponent];\n}\nexports.frexp = frexp;\n/**\n * Multiplies a double-precision floating-point number by an integer power of\n * two; i.e., x = frac * 2^exp.\n */\nfunction ldexp(mantissa, exponent) {\n    var iterations = Math.min(3, Math.ceil(Math.abs(exponent) / 1023));\n    var result = mantissa;\n    for (var i = 0; i < iterations; i++) {\n        result *= Math.pow(2, Math.floor((exponent + i) / iterations));\n    }\n    return result;\n}\nexports.ldexp = ldexp;\n","/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/\n\"use strict\";\nvar $protobuf = require(\"protobufjs/minimal\");\n// Common aliases\nvar $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;\n// Exported root namespace\nvar $root = $protobuf.roots[\"default\"] || ($protobuf.roots[\"default\"] = {});\n$root.DDSketch = (function () {\n    /**\n     * Properties of a DDSketch.\n     * @exports IDDSketch\n     * @interface IDDSketch\n     * @property {IIndexMapping|null} [mapping] DDSketch mapping\n     * @property {IStore|null} [positiveValues] DDSketch positiveValues\n     * @property {IStore|null} [negativeValues] DDSketch negativeValues\n     * @property {number|null} [zeroCount] DDSketch zeroCount\n     */\n    /**\n     * Constructs a new DDSketch.\n     * @exports DDSketch\n     * @classdesc Represents a DDSketch.\n     * @implements IDDSketch\n     * @constructor\n     * @param {IDDSketch=} [properties] Properties to set\n     */\n    function DDSketch(properties) {\n        if (properties)\n            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * DDSketch mapping.\n     * @member {IIndexMapping|null|undefined} mapping\n     * @memberof DDSketch\n     * @instance\n     */\n    DDSketch.prototype.mapping = null;\n    /**\n     * DDSketch positiveValues.\n     * @member {IStore|null|undefined} positiveValues\n     * @memberof DDSketch\n     * @instance\n     */\n    DDSketch.prototype.positiveValues = null;\n    /**\n     * DDSketch negativeValues.\n     * @member {IStore|null|undefined} negativeValues\n     * @memberof DDSketch\n     * @instance\n     */\n    DDSketch.prototype.negativeValues = null;\n    /**\n     * DDSketch zeroCount.\n     * @member {number} zeroCount\n     * @memberof DDSketch\n     * @instance\n     */\n    DDSketch.prototype.zeroCount = 0;\n    /**\n     * Creates a new DDSketch instance using the specified properties.\n     * @function create\n     * @memberof DDSketch\n     * @static\n     * @param {IDDSketch=} [properties] Properties to set\n     * @returns {DDSketch} DDSketch instance\n     */\n    DDSketch.create = function create(properties) {\n        return new DDSketch(properties);\n    };\n    /**\n     * Encodes the specified DDSketch message. Does not implicitly {@link DDSketch.verify|verify} messages.\n     * @function encode\n     * @memberof DDSketch\n     * @static\n     * @param {IDDSketch} message DDSketch message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    DDSketch.encode = function encode(message, writer) {\n        if (!writer)\n            writer = $Writer.create();\n        if (message.mapping != null && Object.hasOwnProperty.call(message, \"mapping\"))\n            $root.IndexMapping.encode(message.mapping, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();\n        if (message.positiveValues != null && Object.hasOwnProperty.call(message, \"positiveValues\"))\n            $root.Store.encode(message.positiveValues, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();\n        if (message.negativeValues != null && Object.hasOwnProperty.call(message, \"negativeValues\"))\n            $root.Store.encode(message.negativeValues, writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();\n        if (message.zeroCount != null && Object.hasOwnProperty.call(message, \"zeroCount\"))\n            writer.uint32(/* id 4, wireType 1 =*/ 33).double(message.zeroCount);\n        return writer;\n    };\n    /**\n     * Encodes the specified DDSketch message, length delimited. Does not implicitly {@link DDSketch.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof DDSketch\n     * @static\n     * @param {IDDSketch} message DDSketch message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    DDSketch.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n    };\n    /**\n     * Decodes a DDSketch message from the specified reader or buffer.\n     * @function decode\n     * @memberof DDSketch\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {DDSketch} DDSketch\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    DDSketch.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.DDSketch();\n        while (reader.pos < end) {\n            var tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.mapping = $root.IndexMapping.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.positiveValues = $root.Store.decode(reader, reader.uint32());\n                    break;\n                case 3:\n                    message.negativeValues = $root.Store.decode(reader, reader.uint32());\n                    break;\n                case 4:\n                    message.zeroCount = reader.double();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    /**\n     * Decodes a DDSketch message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof DDSketch\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {DDSketch} DDSketch\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    DDSketch.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n    };\n    /**\n     * Verifies a DDSketch message.\n     * @function verify\n     * @memberof DDSketch\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    DDSketch.verify = function verify(message) {\n        if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n        if (message.mapping != null && message.hasOwnProperty(\"mapping\")) {\n            var error = $root.IndexMapping.verify(message.mapping);\n            if (error)\n                return \"mapping.\" + error;\n        }\n        if (message.positiveValues != null && message.hasOwnProperty(\"positiveValues\")) {\n            var error = $root.Store.verify(message.positiveValues);\n            if (error)\n                return \"positiveValues.\" + error;\n        }\n        if (message.negativeValues != null && message.hasOwnProperty(\"negativeValues\")) {\n            var error = $root.Store.verify(message.negativeValues);\n            if (error)\n                return \"negativeValues.\" + error;\n        }\n        if (message.zeroCount != null && message.hasOwnProperty(\"zeroCount\"))\n            if (typeof message.zeroCount !== \"number\")\n                return \"zeroCount: number expected\";\n        return null;\n    };\n    /**\n     * Creates a DDSketch message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof DDSketch\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {DDSketch} DDSketch\n     */\n    DDSketch.fromObject = function fromObject(object) {\n        if (object instanceof $root.DDSketch)\n            return object;\n        var message = new $root.DDSketch();\n        if (object.mapping != null) {\n            if (typeof object.mapping !== \"object\")\n                throw TypeError(\".DDSketch.mapping: object expected\");\n            message.mapping = $root.IndexMapping.fromObject(object.mapping);\n        }\n        if (object.positiveValues != null) {\n            if (typeof object.positiveValues !== \"object\")\n                throw TypeError(\".DDSketch.positiveValues: object expected\");\n            message.positiveValues = $root.Store.fromObject(object.positiveValues);\n        }\n        if (object.negativeValues != null) {\n            if (typeof object.negativeValues !== \"object\")\n                throw TypeError(\".DDSketch.negativeValues: object expected\");\n            message.negativeValues = $root.Store.fromObject(object.negativeValues);\n        }\n        if (object.zeroCount != null)\n            message.zeroCount = Number(object.zeroCount);\n        return message;\n    };\n    /**\n     * Creates a plain object from a DDSketch message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof DDSketch\n     * @static\n     * @param {DDSketch} message DDSketch\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    DDSketch.toObject = function toObject(message, options) {\n        if (!options)\n            options = {};\n        var object = {};\n        if (options.defaults) {\n            object.mapping = null;\n            object.positiveValues = null;\n            object.negativeValues = null;\n            object.zeroCount = 0;\n        }\n        if (message.mapping != null && message.hasOwnProperty(\"mapping\"))\n            object.mapping = $root.IndexMapping.toObject(message.mapping, options);\n        if (message.positiveValues != null && message.hasOwnProperty(\"positiveValues\"))\n            object.positiveValues = $root.Store.toObject(message.positiveValues, options);\n        if (message.negativeValues != null && message.hasOwnProperty(\"negativeValues\"))\n            object.negativeValues = $root.Store.toObject(message.negativeValues, options);\n        if (message.zeroCount != null && message.hasOwnProperty(\"zeroCount\"))\n            object.zeroCount = options.json && !isFinite(message.zeroCount) ? String(message.zeroCount) : message.zeroCount;\n        return object;\n    };\n    /**\n     * Converts this DDSketch to JSON.\n     * @function toJSON\n     * @memberof DDSketch\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    DDSketch.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n    return DDSketch;\n})();\n$root.IndexMapping = (function () {\n    /**\n     * Properties of an IndexMapping.\n     * @exports IIndexMapping\n     * @interface IIndexMapping\n     * @property {number|null} [gamma] IndexMapping gamma\n     * @property {number|null} [indexOffset] IndexMapping indexOffset\n     * @property {IndexMapping.Interpolation|null} [interpolation] IndexMapping interpolation\n     */\n    /**\n     * Constructs a new IndexMapping.\n     * @exports IndexMapping\n     * @classdesc Represents an IndexMapping.\n     * @implements IIndexMapping\n     * @constructor\n     * @param {IIndexMapping=} [properties] Properties to set\n     */\n    function IndexMapping(properties) {\n        if (properties)\n            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * IndexMapping gamma.\n     * @member {number} gamma\n     * @memberof IndexMapping\n     * @instance\n     */\n    IndexMapping.prototype.gamma = 0;\n    /**\n     * IndexMapping indexOffset.\n     * @member {number} indexOffset\n     * @memberof IndexMapping\n     * @instance\n     */\n    IndexMapping.prototype.indexOffset = 0;\n    /**\n     * IndexMapping interpolation.\n     * @member {IndexMapping.Interpolation} interpolation\n     * @memberof IndexMapping\n     * @instance\n     */\n    IndexMapping.prototype.interpolation = 0;\n    /**\n     * Creates a new IndexMapping instance using the specified properties.\n     * @function create\n     * @memberof IndexMapping\n     * @static\n     * @param {IIndexMapping=} [properties] Properties to set\n     * @returns {IndexMapping} IndexMapping instance\n     */\n    IndexMapping.create = function create(properties) {\n        return new IndexMapping(properties);\n    };\n    /**\n     * Encodes the specified IndexMapping message. Does not implicitly {@link IndexMapping.verify|verify} messages.\n     * @function encode\n     * @memberof IndexMapping\n     * @static\n     * @param {IIndexMapping} message IndexMapping message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    IndexMapping.encode = function encode(message, writer) {\n        if (!writer)\n            writer = $Writer.create();\n        if (message.gamma != null && Object.hasOwnProperty.call(message, \"gamma\"))\n            writer.uint32(/* id 1, wireType 1 =*/ 9).double(message.gamma);\n        if (message.indexOffset != null && Object.hasOwnProperty.call(message, \"indexOffset\"))\n            writer.uint32(/* id 2, wireType 1 =*/ 17).double(message.indexOffset);\n        if (message.interpolation != null && Object.hasOwnProperty.call(message, \"interpolation\"))\n            writer.uint32(/* id 3, wireType 0 =*/ 24).int32(message.interpolation);\n        return writer;\n    };\n    /**\n     * Encodes the specified IndexMapping message, length delimited. Does not implicitly {@link IndexMapping.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof IndexMapping\n     * @static\n     * @param {IIndexMapping} message IndexMapping message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    IndexMapping.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n    };\n    /**\n     * Decodes an IndexMapping message from the specified reader or buffer.\n     * @function decode\n     * @memberof IndexMapping\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {IndexMapping} IndexMapping\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    IndexMapping.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.IndexMapping();\n        while (reader.pos < end) {\n            var tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.gamma = reader.double();\n                    break;\n                case 2:\n                    message.indexOffset = reader.double();\n                    break;\n                case 3:\n                    message.interpolation = reader.int32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    /**\n     * Decodes an IndexMapping message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof IndexMapping\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {IndexMapping} IndexMapping\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    IndexMapping.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n    };\n    /**\n     * Verifies an IndexMapping message.\n     * @function verify\n     * @memberof IndexMapping\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    IndexMapping.verify = function verify(message) {\n        if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n        if (message.gamma != null && message.hasOwnProperty(\"gamma\"))\n            if (typeof message.gamma !== \"number\")\n                return \"gamma: number expected\";\n        if (message.indexOffset != null && message.hasOwnProperty(\"indexOffset\"))\n            if (typeof message.indexOffset !== \"number\")\n                return \"indexOffset: number expected\";\n        if (message.interpolation != null && message.hasOwnProperty(\"interpolation\"))\n            switch (message.interpolation) {\n                default:\n                    return \"interpolation: enum value expected\";\n                case 0:\n                case 1:\n                case 2:\n                case 3:\n                    break;\n            }\n        return null;\n    };\n    /**\n     * Creates an IndexMapping message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof IndexMapping\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {IndexMapping} IndexMapping\n     */\n    IndexMapping.fromObject = function fromObject(object) {\n        if (object instanceof $root.IndexMapping)\n            return object;\n        var message = new $root.IndexMapping();\n        if (object.gamma != null)\n            message.gamma = Number(object.gamma);\n        if (object.indexOffset != null)\n            message.indexOffset = Number(object.indexOffset);\n        switch (object.interpolation) {\n            case \"NONE\":\n            case 0:\n                message.interpolation = 0;\n                break;\n            case \"LINEAR\":\n            case 1:\n                message.interpolation = 1;\n                break;\n            case \"QUADRATIC\":\n            case 2:\n                message.interpolation = 2;\n                break;\n            case \"CUBIC\":\n            case 3:\n                message.interpolation = 3;\n                break;\n        }\n        return message;\n    };\n    /**\n     * Creates a plain object from an IndexMapping message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof IndexMapping\n     * @static\n     * @param {IndexMapping} message IndexMapping\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    IndexMapping.toObject = function toObject(message, options) {\n        if (!options)\n            options = {};\n        var object = {};\n        if (options.defaults) {\n            object.gamma = 0;\n            object.indexOffset = 0;\n            object.interpolation = options.enums === String ? \"NONE\" : 0;\n        }\n        if (message.gamma != null && message.hasOwnProperty(\"gamma\"))\n            object.gamma = options.json && !isFinite(message.gamma) ? String(message.gamma) : message.gamma;\n        if (message.indexOffset != null && message.hasOwnProperty(\"indexOffset\"))\n            object.indexOffset = options.json && !isFinite(message.indexOffset) ? String(message.indexOffset) : message.indexOffset;\n        if (message.interpolation != null && message.hasOwnProperty(\"interpolation\"))\n            object.interpolation = options.enums === String ? $root.IndexMapping.Interpolation[message.interpolation] : message.interpolation;\n        return object;\n    };\n    /**\n     * Converts this IndexMapping to JSON.\n     * @function toJSON\n     * @memberof IndexMapping\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    IndexMapping.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n    /**\n     * Interpolation enum.\n     * @name IndexMapping.Interpolation\n     * @enum {number}\n     * @property {number} NONE=0 NONE value\n     * @property {number} LINEAR=1 LINEAR value\n     * @property {number} QUADRATIC=2 QUADRATIC value\n     * @property {number} CUBIC=3 CUBIC value\n     */\n    IndexMapping.Interpolation = (function () {\n        var valuesById = {}, values = Object.create(valuesById);\n        values[valuesById[0] = \"NONE\"] = 0;\n        values[valuesById[1] = \"LINEAR\"] = 1;\n        values[valuesById[2] = \"QUADRATIC\"] = 2;\n        values[valuesById[3] = \"CUBIC\"] = 3;\n        return values;\n    })();\n    return IndexMapping;\n})();\n$root.Store = (function () {\n    /**\n     * Properties of a Store.\n     * @exports IStore\n     * @interface IStore\n     * @property {Object.<string,number>|null} [binCounts] Store binCounts\n     * @property {Array.<number>|null} [contiguousBinCounts] Store contiguousBinCounts\n     * @property {number|null} [contiguousBinIndexOffset] Store contiguousBinIndexOffset\n     */\n    /**\n     * Constructs a new Store.\n     * @exports Store\n     * @classdesc Represents a Store.\n     * @implements IStore\n     * @constructor\n     * @param {IStore=} [properties] Properties to set\n     */\n    function Store(properties) {\n        this.binCounts = {};\n        this.contiguousBinCounts = [];\n        if (properties)\n            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * Store binCounts.\n     * @member {Object.<string,number>} binCounts\n     * @memberof Store\n     * @instance\n     */\n    Store.prototype.binCounts = $util.emptyObject;\n    /**\n     * Store contiguousBinCounts.\n     * @member {Array.<number>} contiguousBinCounts\n     * @memberof Store\n     * @instance\n     */\n    Store.prototype.contiguousBinCounts = $util.emptyArray;\n    /**\n     * Store contiguousBinIndexOffset.\n     * @member {number} contiguousBinIndexOffset\n     * @memberof Store\n     * @instance\n     */\n    Store.prototype.contiguousBinIndexOffset = 0;\n    /**\n     * Creates a new Store instance using the specified properties.\n     * @function create\n     * @memberof Store\n     * @static\n     * @param {IStore=} [properties] Properties to set\n     * @returns {Store} Store instance\n     */\n    Store.create = function create(properties) {\n        return new Store(properties);\n    };\n    /**\n     * Encodes the specified Store message. Does not implicitly {@link Store.verify|verify} messages.\n     * @function encode\n     * @memberof Store\n     * @static\n     * @param {IStore} message Store message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    Store.encode = function encode(message, writer) {\n        if (!writer)\n            writer = $Writer.create();\n        if (message.binCounts != null && Object.hasOwnProperty.call(message, \"binCounts\"))\n            for (var keys = Object.keys(message.binCounts), i = 0; i < keys.length; ++i)\n                writer.uint32(/* id 1, wireType 2 =*/ 10).fork().uint32(/* id 1, wireType 0 =*/ 8).sint32(keys[i]).uint32(/* id 2, wireType 1 =*/ 17).double(message.binCounts[keys[i]]).ldelim();\n        if (message.contiguousBinCounts != null && message.contiguousBinCounts.length) {\n            writer.uint32(/* id 2, wireType 2 =*/ 18).fork();\n            for (var i = 0; i < message.contiguousBinCounts.length; ++i)\n                writer.double(message.contiguousBinCounts[i]);\n            writer.ldelim();\n        }\n        if (message.contiguousBinIndexOffset != null && Object.hasOwnProperty.call(message, \"contiguousBinIndexOffset\"))\n            writer.uint32(/* id 3, wireType 0 =*/ 24).sint32(message.contiguousBinIndexOffset);\n        return writer;\n    };\n    /**\n     * Encodes the specified Store message, length delimited. Does not implicitly {@link Store.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof Store\n     * @static\n     * @param {IStore} message Store message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    Store.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n    };\n    /**\n     * Decodes a Store message from the specified reader or buffer.\n     * @function decode\n     * @memberof Store\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {Store} Store\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    Store.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Store(), key, value;\n        while (reader.pos < end) {\n            var tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    if (message.binCounts === $util.emptyObject)\n                        message.binCounts = {};\n                    var end2 = reader.uint32() + reader.pos;\n                    key = 0;\n                    value = 0;\n                    while (reader.pos < end2) {\n                        var tag2 = reader.uint32();\n                        switch (tag2 >>> 3) {\n                            case 1:\n                                key = reader.sint32();\n                                break;\n                            case 2:\n                                value = reader.double();\n                                break;\n                            default:\n                                reader.skipType(tag2 & 7);\n                                break;\n                        }\n                    }\n                    message.binCounts[key] = value;\n                    break;\n                case 2:\n                    if (!(message.contiguousBinCounts && message.contiguousBinCounts.length))\n                        message.contiguousBinCounts = [];\n                    if ((tag & 7) === 2) {\n                        var end2 = reader.uint32() + reader.pos;\n                        while (reader.pos < end2)\n                            message.contiguousBinCounts.push(reader.double());\n                    }\n                    else\n                        message.contiguousBinCounts.push(reader.double());\n                    break;\n                case 3:\n                    message.contiguousBinIndexOffset = reader.sint32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    /**\n     * Decodes a Store message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof Store\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {Store} Store\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    Store.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n    };\n    /**\n     * Verifies a Store message.\n     * @function verify\n     * @memberof Store\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    Store.verify = function verify(message) {\n        if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n        if (message.binCounts != null && message.hasOwnProperty(\"binCounts\")) {\n            if (!$util.isObject(message.binCounts))\n                return \"binCounts: object expected\";\n            var key = Object.keys(message.binCounts);\n            for (var i = 0; i < key.length; ++i) {\n                if (!$util.key32Re.test(key[i]))\n                    return \"binCounts: integer key{k:sint32} expected\";\n                if (typeof message.binCounts[key[i]] !== \"number\")\n                    return \"binCounts: number{k:sint32} expected\";\n            }\n        }\n        if (message.contiguousBinCounts != null && message.hasOwnProperty(\"contiguousBinCounts\")) {\n            if (!Array.isArray(message.contiguousBinCounts))\n                return \"contiguousBinCounts: array expected\";\n            for (var i = 0; i < message.contiguousBinCounts.length; ++i)\n                if (typeof message.contiguousBinCounts[i] !== \"number\")\n                    return \"contiguousBinCounts: number[] expected\";\n        }\n        if (message.contiguousBinIndexOffset != null && message.hasOwnProperty(\"contiguousBinIndexOffset\"))\n            if (!$util.isInteger(message.contiguousBinIndexOffset))\n                return \"contiguousBinIndexOffset: integer expected\";\n        return null;\n    };\n    /**\n     * Creates a Store message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof Store\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {Store} Store\n     */\n    Store.fromObject = function fromObject(object) {\n        if (object instanceof $root.Store)\n            return object;\n        var message = new $root.Store();\n        if (object.binCounts) {\n            if (typeof object.binCounts !== \"object\")\n                throw TypeError(\".Store.binCounts: object expected\");\n            message.binCounts = {};\n            for (var keys = Object.keys(object.binCounts), i = 0; i < keys.length; ++i)\n                message.binCounts[keys[i]] = Number(object.binCounts[keys[i]]);\n        }\n        if (object.contiguousBinCounts) {\n            if (!Array.isArray(object.contiguousBinCounts))\n                throw TypeError(\".Store.contiguousBinCounts: array expected\");\n            message.contiguousBinCounts = [];\n            for (var i = 0; i < object.contiguousBinCounts.length; ++i)\n                message.contiguousBinCounts[i] = Number(object.contiguousBinCounts[i]);\n        }\n        if (object.contiguousBinIndexOffset != null)\n            message.contiguousBinIndexOffset = object.contiguousBinIndexOffset | 0;\n        return message;\n    };\n    /**\n     * Creates a plain object from a Store message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof Store\n     * @static\n     * @param {Store} message Store\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    Store.toObject = function toObject(message, options) {\n        if (!options)\n            options = {};\n        var object = {};\n        if (options.arrays || options.defaults)\n            object.contiguousBinCounts = [];\n        if (options.objects || options.defaults)\n            object.binCounts = {};\n        if (options.defaults)\n            object.contiguousBinIndexOffset = 0;\n        var keys2;\n        if (message.binCounts && (keys2 = Object.keys(message.binCounts)).length) {\n            object.binCounts = {};\n            for (var j = 0; j < keys2.length; ++j)\n                object.binCounts[keys2[j]] = options.json && !isFinite(message.binCounts[keys2[j]]) ? String(message.binCounts[keys2[j]]) : message.binCounts[keys2[j]];\n        }\n        if (message.contiguousBinCounts && message.contiguousBinCounts.length) {\n            object.contiguousBinCounts = [];\n            for (var j = 0; j < message.contiguousBinCounts.length; ++j)\n                object.contiguousBinCounts[j] = options.json && !isFinite(message.contiguousBinCounts[j]) ? String(message.contiguousBinCounts[j]) : message.contiguousBinCounts[j];\n        }\n        if (message.contiguousBinIndexOffset != null && message.hasOwnProperty(\"contiguousBinIndexOffset\"))\n            object.contiguousBinIndexOffset = message.contiguousBinIndexOffset;\n        return object;\n    };\n    /**\n     * Converts this Store to JSON.\n     * @function toJSON\n     * @memberof Store\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    Store.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n    return Store;\n})();\nmodule.exports = $root;\n","\"use strict\";\n/*\n * Unless explicitly stated otherwise all files in this repository are licensed\n * under the Apache 2.0 license (see LICENSE).\n * This product includes software developed at Datadog (https://www.datadoghq.com/).\n * Copyright 2020 Datadog, Inc.\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CollapsingHighestDenseStore = void 0;\nvar DenseStore_1 = require(\"./DenseStore\");\nvar util_1 = require(\"./util\");\n/**\n * `CollapsingHighestDenseStore` is a dense store that keeps all the bins between\n * the bin for the `minKey` and the `maxKey`, but collapsing the left-most bins\n * if the number of bins exceeds `binLimit`\n */\nvar CollapsingHighestDenseStore = /** @class */ (function (_super) {\n    __extends(CollapsingHighestDenseStore, _super);\n    /**\n     * Initialize a new CollapsingHighestDenseStore\n     *\n     * @param binLimit The maximum number of bins\n     * @param chunkSize The number of bins to add each time the bins grow (default 128)\n     */\n    function CollapsingHighestDenseStore(binLimit, chunkSize) {\n        var _this = _super.call(this, chunkSize) || this;\n        _this.binLimit = binLimit;\n        _this.isCollapsed = false;\n        return _this;\n    }\n    /**\n     * Merge the contents of the parameter `store` into this store\n     *\n     * @param store The store to merge into the caller store\n     */\n    CollapsingHighestDenseStore.prototype.merge = function (store) {\n        if (store.count === 0) {\n            return;\n        }\n        if (this.count === 0) {\n            this.copy(store);\n            return;\n        }\n        if (store.minKey < this.minKey || store.maxKey > this.maxKey) {\n            this._extendRange(store.minKey, store.maxKey);\n        }\n        var collapseEndIndex = store.maxKey - store.offset + 1;\n        var collapseStartIndex = Math.max(this.maxKey + 1, store.minKey) - store.offset;\n        if (collapseEndIndex > collapseStartIndex) {\n            var collapseCount = util_1.sumOfRange(store.bins, collapseStartIndex, collapseEndIndex);\n            this.bins[this.length() - 1] += collapseCount;\n        }\n        else {\n            collapseStartIndex = collapseEndIndex;\n        }\n        for (var key = store.minKey; key < collapseStartIndex + store.offset; key++) {\n            this.bins[key - this.offset] += store.bins[key - store.offset];\n        }\n        this.count += store.count;\n    };\n    /**\n     * Directly clone the contents of the parameter `store` into this store\n     *\n     * @param store The store to be copied into the caller store\n     */\n    CollapsingHighestDenseStore.prototype.copy = function (store) {\n        _super.prototype.copy.call(this, store);\n        this.isCollapsed = store.isCollapsed;\n    };\n    CollapsingHighestDenseStore.prototype._getNewLength = function (newMinKey, newMaxKey) {\n        var desiredLength = newMaxKey - newMinKey + 1;\n        return Math.min(this.chunkSize * Math.ceil(desiredLength / this.chunkSize), this.binLimit);\n    };\n    /**\n     * Adjust the `bins`, the `offset`, the `minKey`, and the `maxKey`\n     * without resizing the bins, in order to try to make it fit the specified range.\n     * Collapse to the left if necessary\n     */\n    CollapsingHighestDenseStore.prototype._adjust = function (newMinKey, newMaxKey) {\n        if (newMaxKey - newMinKey + 1 > this.length()) {\n            // The range of keys is too wide, the lowest bins need to be collapsed\n            newMaxKey = newMinKey + this.length() + 1;\n            if (newMaxKey <= this.minKey) {\n                // Put everything in the first bin\n                this.offset = newMinKey;\n                this.maxKey = newMaxKey;\n                this.bins.fill(0);\n                this.bins[this.length() - 1] = this.count;\n            }\n            else {\n                var shift = this.offset - newMinKey;\n                if (shift > 0) {\n                    var collapseStartIndex = newMaxKey - this.offset + 1;\n                    var collapseEndIndex = this.maxKey - this.offset + 1;\n                    var collapsedCount = util_1.sumOfRange(this.bins, collapseStartIndex, collapseEndIndex);\n                    this.bins.fill(0, collapseStartIndex, collapseEndIndex);\n                    this.bins[collapseStartIndex - 1] += collapsedCount;\n                    this.maxKey = newMaxKey;\n                    this._shiftBins(shift);\n                }\n                else {\n                    this.maxKey = newMaxKey;\n                    // Shift the buckets to make room for newMinKey\n                    this._shiftBins(shift);\n                }\n                this.minKey = newMinKey;\n                this.isCollapsed = true;\n            }\n        }\n        else {\n            this._centerBins(newMinKey, newMaxKey);\n            this.minKey = newMinKey;\n            this.maxKey = newMaxKey;\n        }\n    };\n    /** Calculate the bin index for the key, extending the range if necessary */\n    CollapsingHighestDenseStore.prototype._getIndex = function (key) {\n        if (key < this.minKey) {\n            if (this.isCollapsed) {\n                return this.length() - 1;\n            }\n            this._extendRange(key);\n            if (this.isCollapsed) {\n                return this.length() - 1;\n            }\n        }\n        else if (key > this.maxKey) {\n            this._extendRange(key);\n        }\n        return key - this.offset;\n    };\n    return CollapsingHighestDenseStore;\n}(DenseStore_1.DenseStore));\nexports.CollapsingHighestDenseStore = CollapsingHighestDenseStore;\n","\"use strict\";\n/*\n * Unless explicitly stated otherwise all files in this repository are licensed\n * under the Apache 2.0 license (see LICENSE).\n * This product includes software developed at Datadog (https://www.datadoghq.com/).\n * Copyright 2020 Datadog, Inc.\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CollapsingLowestDenseStore = void 0;\nvar DenseStore_1 = require(\"./DenseStore\");\nvar util_1 = require(\"./util\");\n/**\n * `CollapsingLowestDenseStore` is a dense store that keeps all the bins between\n * the bin for the `minKey` and the `maxKey`, but collapsing the left-most bins\n * if the number of bins exceeds `binLimit`\n */\nvar CollapsingLowestDenseStore = /** @class */ (function (_super) {\n    __extends(CollapsingLowestDenseStore, _super);\n    /**\n     * Initialize a new CollapsingLowestDenseStore\n     *\n     * @param binLimit The maximum number of bins\n     * @param chunkSize The number of bins to add each time the bins grow (default 128)\n     */\n    function CollapsingLowestDenseStore(binLimit, chunkSize) {\n        var _this = _super.call(this, chunkSize) || this;\n        _this.binLimit = binLimit;\n        _this.isCollapsed = false;\n        return _this;\n    }\n    /**\n     * Merge the contents of the parameter `store` into this store\n     *\n     * @param store The store to merge into the caller store\n     */\n    CollapsingLowestDenseStore.prototype.merge = function (store) {\n        if (store.count === 0) {\n            return;\n        }\n        if (this.count === 0) {\n            this.copy(store);\n            return;\n        }\n        if (store.minKey < this.minKey || store.maxKey > this.maxKey) {\n            this._extendRange(store.minKey, store.maxKey);\n        }\n        var collapseStartIndex = store.minKey - store.offset;\n        var collapseEndIndex = Math.min(this.minKey, store.maxKey + 1) - store.offset;\n        if (collapseEndIndex > collapseStartIndex) {\n            var collapseCount = util_1.sumOfRange(store.bins, collapseStartIndex, collapseEndIndex);\n            this.bins[0] += collapseCount;\n        }\n        else {\n            collapseEndIndex = collapseStartIndex;\n        }\n        for (var key = collapseEndIndex + store.offset; key < store.maxKey + 1; key++) {\n            this.bins[key - this.offset] += store.bins[key - store.offset];\n        }\n        this.count += store.count;\n    };\n    /**\n     * Directly clone the contents of the parameter `store` into this store\n     *\n     * @param store The store to be copied into the caller store\n     */\n    CollapsingLowestDenseStore.prototype.copy = function (store) {\n        _super.prototype.copy.call(this, store);\n        this.isCollapsed = store.isCollapsed;\n    };\n    CollapsingLowestDenseStore.prototype._getNewLength = function (newMinKey, newMaxKey) {\n        var desiredLength = newMaxKey - newMinKey + 1;\n        return Math.min(this.chunkSize * Math.ceil(desiredLength / this.chunkSize), this.binLimit);\n    };\n    /**\n     * Adjust the `bins`, the `offset`, the `minKey`, and the `maxKey`\n     * without resizing the bins, in order to try to make it fit the specified range.\n     * Collapse to the left if necessary\n     */\n    CollapsingLowestDenseStore.prototype._adjust = function (newMinKey, newMaxKey) {\n        if (newMaxKey - newMinKey + 1 > this.length()) {\n            // The range of keys is too wide, the lowest bins need to be collapsed\n            newMinKey = newMaxKey - this.length() + 1;\n            if (newMinKey >= this.maxKey) {\n                // Put everything in the first bin\n                this.offset = newMinKey;\n                this.minKey = newMinKey;\n                this.bins.fill(0);\n                this.bins[0] = this.count;\n            }\n            else {\n                var shift = this.offset - newMinKey;\n                if (shift < 0) {\n                    var collapseStartIndex = this.minKey - this.offset;\n                    var collapseEndIndex = newMinKey - this.offset;\n                    var collapsedCount = util_1.sumOfRange(this.bins, collapseStartIndex, collapseEndIndex);\n                    this.bins.fill(0, collapseStartIndex, collapseEndIndex);\n                    this.bins[collapseEndIndex] += collapsedCount;\n                    this.minKey = newMinKey;\n                    this._shiftBins(shift);\n                }\n                else {\n                    this.minKey = newMinKey;\n                    // Shift the buckets to make room for newMinKey\n                    this._shiftBins(shift);\n                }\n            }\n            this.maxKey = newMaxKey;\n            this.isCollapsed = true;\n        }\n        else {\n            this._centerBins(newMinKey, newMaxKey);\n            this.minKey = newMinKey;\n            this.maxKey = newMaxKey;\n        }\n    };\n    /** Calculate the bin index for the key, extending the range if necessary */\n    CollapsingLowestDenseStore.prototype._getIndex = function (key) {\n        if (key < this.minKey) {\n            if (this.isCollapsed) {\n                return 0;\n            }\n            this._extendRange(key);\n            if (this.isCollapsed) {\n                return 0;\n            }\n        }\n        else if (key > this.maxKey) {\n            this._extendRange(key);\n        }\n        return key - this.offset;\n    };\n    return CollapsingLowestDenseStore;\n}(DenseStore_1.DenseStore));\nexports.CollapsingLowestDenseStore = CollapsingLowestDenseStore;\n","\"use strict\";\n/*\n * Unless explicitly stated otherwise all files in this repository are licensed\n * under the Apache 2.0 license (see LICENSE).\n * This product includes software developed at Datadog (https://www.datadoghq.com/).\n * Copyright 2020 Datadog, Inc.\n */\nvar __spreadArray = (this && this.__spreadArray) || function (to, from) {\n    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)\n        to[j] = from[i];\n    return to;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DenseStore = void 0;\nvar util_1 = require(\"./util\");\nvar compiled_1 = require(\"../proto/compiled\");\n/** The default number of bins to grow when necessary */\nvar CHUNK_SIZE = 128;\n/**\n * `DenseStore` is a store that keeps all the bins between\n * the bin for the `minKey` and the `maxKey`.\n */\nvar DenseStore = /** @class */ (function () {\n    /**\n     * Initialize a new DenseStore\n     *\n     * @param chunkSize The number of bins to add each time the bins grow (default 128)\n     */\n    function DenseStore(chunkSize) {\n        if (chunkSize === void 0) { chunkSize = CHUNK_SIZE; }\n        this.chunkSize = chunkSize;\n        this.bins = [];\n        this.count = 0;\n        this.minKey = Infinity;\n        this.maxKey = -Infinity;\n        this.offset = 0;\n    }\n    /**\n     * Update the counter at the specified index key, growing the number of bins if necessary\n     *\n     * @param key The key of the index to update\n     * @param weight The amount to weight the key (default 1.0)\n     */\n    DenseStore.prototype.add = function (key, weight) {\n        if (weight === void 0) { weight = 1; }\n        var index = this._getIndex(key);\n        this.bins[index] += weight;\n        this.count += weight;\n    };\n    /**\n     * Return the key for the value at the given rank\n     *\n     * E.g., if the non-zero bins are [1, 1] for keys a, b with no offset\n     *\n     * if lower = True:\n     *     keyAtRank(x) = a for x in [0, 1)\n     *     keyAtRank(x) = b for x in [1, 2)\n     * if lower = False:\n     *     keyAtRank(x) = a for x in (-1, 0]\n     *     keyAtRank(x) = b for x in (0, 1]\n     *\n     * @param rank The rank at which to retrieve the key\n     */\n    DenseStore.prototype.keyAtRank = function (rank, lower) {\n        if (lower === void 0) { lower = true; }\n        var runningCount = 0;\n        for (var i = 0; i < this.length(); i++) {\n            var bin = this.bins[i];\n            runningCount += bin;\n            if ((lower && runningCount > rank) ||\n                (!lower && runningCount >= rank + 1)) {\n                return i + this.offset;\n            }\n        }\n        return this.maxKey;\n    };\n    /**\n     * Merge the contents of the parameter `store` into this store\n     *\n     * @param store The store to merge into the caller store\n     */\n    DenseStore.prototype.merge = function (store) {\n        if (store.count === 0) {\n            return;\n        }\n        if (this.count === 0) {\n            this.copy(store);\n            return;\n        }\n        if (store.minKey < this.minKey || store.maxKey > this.maxKey) {\n            this._extendRange(store.minKey, store.maxKey);\n        }\n        var collapseStartIndex = store.minKey - store.offset;\n        var collapseEndIndex = Math.min(this.minKey, store.maxKey + 1) - store.offset;\n        if (collapseEndIndex > collapseStartIndex) {\n            var collapseCount = util_1.sumOfRange(store.bins, collapseStartIndex, collapseEndIndex);\n            this.bins[0] += collapseCount;\n        }\n        else {\n            collapseEndIndex = collapseStartIndex;\n        }\n        for (var key = collapseEndIndex + store.offset; key < store.maxKey + 1; key++) {\n            this.bins[key - this.offset] += store.bins[key - store.offset];\n        }\n        this.count += store.count;\n    };\n    /**\n     * Directly clone the contents of the parameter `store` into this store\n     *\n     * @param store The store to be copied into the caller store\n     */\n    DenseStore.prototype.copy = function (store) {\n        this.bins = __spreadArray([], store.bins);\n        this.count = store.count;\n        this.minKey = store.minKey;\n        this.maxKey = store.maxKey;\n        this.offset = store.offset;\n    };\n    /**\n     * Return the length of the underlying storage (`bins`)\n     */\n    DenseStore.prototype.length = function () {\n        return this.bins.length;\n    };\n    DenseStore.prototype._getNewLength = function (newMinKey, newMaxKey) {\n        var desiredLength = newMaxKey - newMinKey + 1;\n        return this.chunkSize * Math.ceil(desiredLength / this.chunkSize);\n    };\n    /**\n     * Adjust the `bins`, the `offset`, the `minKey`, and the `maxKey`\n     * without resizing the bins, in order to try to make it fit the specified range.\n     * Collapse to the left if necessary\n     */\n    DenseStore.prototype._adjust = function (newMinKey, newMaxKey) {\n        this._centerBins(newMinKey, newMaxKey);\n        this.minKey = newMinKey;\n        this.maxKey = newMaxKey;\n    };\n    /** Shift the bins by `shift`. This changes the `offset` */\n    DenseStore.prototype._shiftBins = function (shift) {\n        var _a, _b;\n        if (shift > 0) {\n            this.bins = this.bins.slice(0, -shift);\n            (_a = this.bins).unshift.apply(_a, new Array(shift).fill(0));\n        }\n        else {\n            this.bins = this.bins.slice(Math.abs(shift));\n            (_b = this.bins).push.apply(_b, new Array(Math.abs(shift)).fill(0));\n        }\n        this.offset -= shift;\n    };\n    /** Center the bins. This changes the `offset` */\n    DenseStore.prototype._centerBins = function (newMinKey, newMaxKey) {\n        var middleKey = newMinKey + Math.floor((newMaxKey - newMinKey + 1) / 2);\n        this._shiftBins(Math.floor(this.offset + this.length() / 2) - middleKey);\n    };\n    /** Grow the bins as necessary, and call _adjust */\n    DenseStore.prototype._extendRange = function (key, secondKey) {\n        var _a;\n        secondKey = secondKey || key;\n        var newMinKey = Math.min(key, secondKey, this.minKey);\n        var newMaxKey = Math.max(key, secondKey, this.maxKey);\n        if (this.length() === 0) {\n            this.bins = new Array(this._getNewLength(newMinKey, newMaxKey)).fill(0);\n            this.offset = newMinKey;\n            this._adjust(newMinKey, newMaxKey);\n        }\n        else if (newMinKey >= this.minKey &&\n            newMaxKey < this.offset + this.length()) {\n            // No need to change the range, just update the min and max keys\n            this.minKey = newMinKey;\n            this.maxKey = newMaxKey;\n        }\n        else {\n            // Grow the bins\n            var newLength = this._getNewLength(newMinKey, newMaxKey);\n            if (newLength > this.length()) {\n                (_a = this.bins).push.apply(_a, new Array(newLength - this.length()).fill(0));\n            }\n            this._adjust(newMinKey, newMaxKey);\n        }\n    };\n    /** Calculate the bin index for the key, extending the range if necessary */\n    DenseStore.prototype._getIndex = function (key) {\n        if (key < this.minKey) {\n            this._extendRange(key);\n        }\n        else if (key > this.maxKey) {\n            this._extendRange(key);\n        }\n        return key - this.offset;\n    };\n    DenseStore.prototype.toProto = function () {\n        return compiled_1.Store.create({\n            contiguousBinCounts: this.bins,\n            contiguousBinIndexOffset: this.offset\n        });\n    };\n    DenseStore.fromProto = function (protoStore) {\n        if (!protoStore ||\n            /* Double equals (==) is intentional here to check for\n             * `null` | `undefined` without including `0` */\n            protoStore.contiguousBinCounts == null ||\n            protoStore.contiguousBinIndexOffset == null) {\n            throw Error('Failed to decode store from protobuf');\n        }\n        var store = new this();\n        var index = protoStore.contiguousBinIndexOffset;\n        store.offset = index;\n        for (var _i = 0, _a = protoStore.contiguousBinCounts; _i < _a.length; _i++) {\n            var count = _a[_i];\n            store.add(index, count);\n            index += 1;\n        }\n        return store;\n    };\n    return DenseStore;\n}());\nexports.DenseStore = DenseStore;\n","\"use strict\";\n/*\n * Unless explicitly stated otherwise all files in this repository are licensed\n * under the Apache 2.0 license (see LICENSE).\n * This product includes software developed at Datadog (https://www.datadoghq.com/).\n * Copyright 2020 Datadog, Inc.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CollapsingHighestDenseStore = exports.CollapsingLowestDenseStore = exports.DenseStore = void 0;\nvar DenseStore_1 = require(\"./DenseStore\");\nObject.defineProperty(exports, \"DenseStore\", { enumerable: true, get: function () { return DenseStore_1.DenseStore; } });\nvar CollapsingLowestDenseStore_1 = require(\"./CollapsingLowestDenseStore\");\nObject.defineProperty(exports, \"CollapsingLowestDenseStore\", { enumerable: true, get: function () { return CollapsingLowestDenseStore_1.CollapsingLowestDenseStore; } });\nvar CollapsingHighestDenseStore_1 = require(\"./CollapsingHighestDenseStore\");\nObject.defineProperty(exports, \"CollapsingHighestDenseStore\", { enumerable: true, get: function () { return CollapsingHighestDenseStore_1.CollapsingHighestDenseStore; } });\n","\"use strict\";\n/*\n * Unless explicitly stated otherwise all files in this repository are licensed\n * under the Apache 2.0 license (see LICENSE).\n * This product includes software developed at Datadog (https://www.datadoghq.com/).\n * Copyright 2020 Datadog, Inc.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.sumOfRange = void 0;\n/**\n * Return the sum of the values from range `start` to `end` in `array`\n */\nvar sumOfRange = function (array, start, end) {\n    var sum = 0;\n    for (var i = start; i <= end; i++) {\n        sum += array[i];\n    }\n    return sum;\n};\nexports.sumOfRange = sumOfRange;\n","\"use strict\";\n/*\n * Unless explicitly stated otherwise all files in this repository are licensed\n * under the Apache 2.0 license (see LICENSE).\n * This product includes software developed at Datadog (https://www.datadoghq.com/).\n * Copyright 2020 Datadog, Inc.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DDSketch = void 0;\nvar ddsketch_1 = require(\"./ddsketch\");\nObject.defineProperty(exports, \"DDSketch\", { enumerable: true, get: function () { return ddsketch_1.DDSketch; } });\n","import { __spreadArrays, __assign, __extends, __rest } from 'tslib';\nimport { $$asyncIterator, isAsyncIterable } from 'iterall';\nimport { toPromise, execute, Observable, ApolloLink, concat } from 'apollo-link';\nimport { isCompositeType, doTypesOverlap, visit, visitWithTypeInfo, Kind, getNamedType, TypeInfo, isAbstractType, isObjectType, isInterfaceType, TypeNameMetaFieldDef, GraphQLError, getDirectiveValues, GraphQLSkipDirective, GraphQLIncludeDirective, typeFromAST as typeFromAST$1, responsePathAsArray, getNullableType, isLeafType, isListType, isInputObjectType, isNonNullType, versionInfo, getOperationRootType, lexicographicSortSchema, printError, isSchema, isDirective, isNamedType, isUnionType, isEnumType, isScalarType, GraphQLString, GraphQLInt, GraphQLFloat, GraphQLBoolean, GraphQLID, GraphQLSchema, GraphQLDirective, GraphQLObjectType, GraphQLInterfaceType, GraphQLUnionType, GraphQLInputObjectType, GraphQLEnumType, GraphQLScalarType, GraphQLList, GraphQLNonNull, isInputType, buildASTSchema, parse, extendSchema as extendSchema$1, valueFromAST, print, validate, execute as execute$1, subscribe, defaultFieldResolver, graphql, buildClientSchema, getIntrospectionQuery, DirectiveLocation, TokenKind, BREAK } from 'graphql';\nimport { deprecated } from 'deprecated-decorator';\nimport { createUploadLink, isExtractableFile, formDataAppendFile } from 'apollo-upload-client';\nimport FormData from 'form-data';\nimport fetch from 'node-fetch';\nimport { v4 } from 'uuid';\n\nfunction isSubschemaConfig(value) {\r\n    return Boolean(value.schema);\r\n}\r\nvar VisitSchemaKind;\r\n(function (VisitSchemaKind) {\r\n    VisitSchemaKind[\"TYPE\"] = \"VisitSchemaKind.TYPE\";\r\n    VisitSchemaKind[\"SCALAR_TYPE\"] = \"VisitSchemaKind.SCALAR_TYPE\";\r\n    VisitSchemaKind[\"ENUM_TYPE\"] = \"VisitSchemaKind.ENUM_TYPE\";\r\n    VisitSchemaKind[\"COMPOSITE_TYPE\"] = \"VisitSchemaKind.COMPOSITE_TYPE\";\r\n    VisitSchemaKind[\"OBJECT_TYPE\"] = \"VisitSchemaKind.OBJECT_TYPE\";\r\n    VisitSchemaKind[\"INPUT_OBJECT_TYPE\"] = \"VisitSchemaKind.INPUT_OBJECT_TYPE\";\r\n    VisitSchemaKind[\"ABSTRACT_TYPE\"] = \"VisitSchemaKind.ABSTRACT_TYPE\";\r\n    VisitSchemaKind[\"UNION_TYPE\"] = \"VisitSchemaKind.UNION_TYPE\";\r\n    VisitSchemaKind[\"INTERFACE_TYPE\"] = \"VisitSchemaKind.INTERFACE_TYPE\";\r\n    VisitSchemaKind[\"ROOT_OBJECT\"] = \"VisitSchemaKind.ROOT_OBJECT\";\r\n    VisitSchemaKind[\"QUERY\"] = \"VisitSchemaKind.QUERY\";\r\n    VisitSchemaKind[\"MUTATION\"] = \"VisitSchemaKind.MUTATION\";\r\n    VisitSchemaKind[\"SUBSCRIPTION\"] = \"VisitSchemaKind.SUBSCRIPTION\";\r\n})(VisitSchemaKind || (VisitSchemaKind = {}));\r\nvar MapperKind;\r\n(function (MapperKind) {\r\n    MapperKind[\"TYPE\"] = \"MapperKind.TYPE\";\r\n    MapperKind[\"SCALAR_TYPE\"] = \"MapperKind.SCALAR_TYPE\";\r\n    MapperKind[\"ENUM_TYPE\"] = \"MapperKind.ENUM_TYPE\";\r\n    MapperKind[\"COMPOSITE_TYPE\"] = \"MapperKind.COMPOSITE_TYPE\";\r\n    MapperKind[\"OBJECT_TYPE\"] = \"MapperKind.OBJECT_TYPE\";\r\n    MapperKind[\"INPUT_OBJECT_TYPE\"] = \"MapperKind.INPUT_OBJECT_TYPE\";\r\n    MapperKind[\"ABSTRACT_TYPE\"] = \"MapperKind.ABSTRACT_TYPE\";\r\n    MapperKind[\"UNION_TYPE\"] = \"MapperKind.UNION_TYPE\";\r\n    MapperKind[\"INTERFACE_TYPE\"] = \"MapperKind.INTERFACE_TYPE\";\r\n    MapperKind[\"ROOT_OBJECT\"] = \"MapperKind.ROOT_OBJECT\";\r\n    MapperKind[\"QUERY\"] = \"MapperKind.QUERY\";\r\n    MapperKind[\"MUTATION\"] = \"MapperKind.MUTATION\";\r\n    MapperKind[\"SUBSCRIPTION\"] = \"MapperKind.SUBSCRIPTION\";\r\n    MapperKind[\"DIRECTIVE\"] = \"MapperKind.DIRECTIVE\";\r\n})(MapperKind || (MapperKind = {}));\n\nfunction implementsAbstractType(schema, typeA, typeB) {\r\n    if (typeA === typeB) {\r\n        return true;\r\n    }\r\n    else if (isCompositeType(typeA) && isCompositeType(typeB)) {\r\n        return doTypesOverlap(schema, typeA, typeB);\r\n    }\r\n    return false;\r\n}\n\nvar ExpandAbstractTypes = /** @class */ (function () {\r\n    function ExpandAbstractTypes(sourceSchema, targetSchema) {\r\n        this.targetSchema = targetSchema;\r\n        this.mapping = extractPossibleTypes(sourceSchema, targetSchema);\r\n        this.reverseMapping = flipMapping(this.mapping);\r\n    }\r\n    ExpandAbstractTypes.prototype.transformRequest = function (originalRequest) {\r\n        var document = expandAbstractTypes(this.targetSchema, this.mapping, this.reverseMapping, originalRequest.document);\r\n        return __assign(__assign({}, originalRequest), { document: document });\r\n    };\r\n    return ExpandAbstractTypes;\r\n}());\r\nfunction extractPossibleTypes(sourceSchema, targetSchema) {\r\n    var typeMap = sourceSchema.getTypeMap();\r\n    var mapping = Object.create(null);\r\n    Object.keys(typeMap).forEach(function (typeName) {\r\n        var type = typeMap[typeName];\r\n        if (isAbstractType(type)) {\r\n            var targetType = targetSchema.getType(typeName);\r\n            if (!isAbstractType(targetType)) {\r\n                var implementations = sourceSchema.getPossibleTypes(type);\r\n                mapping[typeName] = implementations\r\n                    .filter(function (impl) { return targetSchema.getType(impl.name); })\r\n                    .map(function (impl) { return impl.name; });\r\n            }\r\n        }\r\n    });\r\n    return mapping;\r\n}\r\nfunction flipMapping(mapping) {\r\n    var result = Object.create(null);\r\n    Object.keys(mapping).forEach(function (typeName) {\r\n        var toTypeNames = mapping[typeName];\r\n        toTypeNames.forEach(function (toTypeName) {\r\n            if (!(toTypeName in result)) {\r\n                result[toTypeName] = [];\r\n            }\r\n            result[toTypeName].push(typeName);\r\n        });\r\n    });\r\n    return result;\r\n}\r\nfunction expandAbstractTypes(targetSchema, mapping, reverseMapping, document) {\r\n    var _a;\r\n    var operations = document.definitions.filter(function (def) { return def.kind === Kind.OPERATION_DEFINITION; });\r\n    var fragments = document.definitions.filter(function (def) { return def.kind === Kind.FRAGMENT_DEFINITION; });\r\n    var existingFragmentNames = fragments.map(function (fragment) { return fragment.name.value; });\r\n    var fragmentCounter = 0;\r\n    var generateFragmentName = function (typeName) {\r\n        var fragmentName;\r\n        do {\r\n            fragmentName = \"_\" + typeName + \"_Fragment\" + fragmentCounter.toString();\r\n            fragmentCounter++;\r\n        } while (existingFragmentNames.indexOf(fragmentName) !== -1);\r\n        return fragmentName;\r\n    };\r\n    var newFragments = [];\r\n    var fragmentReplacements = Object.create(null);\r\n    fragments.forEach(function (fragment) {\r\n        newFragments.push(fragment);\r\n        var possibleTypes = mapping[fragment.typeCondition.name.value];\r\n        if (possibleTypes != null) {\r\n            fragmentReplacements[fragment.name.value] = [];\r\n            possibleTypes.forEach(function (possibleTypeName) {\r\n                var name = generateFragmentName(possibleTypeName);\r\n                existingFragmentNames.push(name);\r\n                var newFragment = {\r\n                    kind: Kind.FRAGMENT_DEFINITION,\r\n                    name: {\r\n                        kind: Kind.NAME,\r\n                        value: name,\r\n                    },\r\n                    typeCondition: {\r\n                        kind: Kind.NAMED_TYPE,\r\n                        name: {\r\n                            kind: Kind.NAME,\r\n                            value: possibleTypeName,\r\n                        },\r\n                    },\r\n                    selectionSet: fragment.selectionSet,\r\n                };\r\n                newFragments.push(newFragment);\r\n                fragmentReplacements[fragment.name.value].push({\r\n                    fragmentName: name,\r\n                    typeName: possibleTypeName,\r\n                });\r\n            });\r\n        }\r\n    });\r\n    var newDocument = __assign(__assign({}, document), { definitions: __spreadArrays(operations, newFragments) });\r\n    var typeInfo = new TypeInfo(targetSchema);\r\n    return visit(newDocument, visitWithTypeInfo(typeInfo, (_a = {},\r\n        _a[Kind.SELECTION_SET] = function (node) {\r\n            var newSelections = __spreadArrays(node.selections);\r\n            var maybeType = typeInfo.getParentType();\r\n            if (maybeType != null) {\r\n                var parentType_1 = getNamedType(maybeType);\r\n                node.selections.forEach(function (selection) {\r\n                    if (selection.kind === Kind.INLINE_FRAGMENT) {\r\n                        if (selection.typeCondition != null) {\r\n                            var possibleTypes = mapping[selection.typeCondition.name.value];\r\n                            if (possibleTypes != null) {\r\n                                possibleTypes.forEach(function (possibleType) {\r\n                                    var maybePossibleType = targetSchema.getType(possibleType);\r\n                                    if (maybePossibleType != null &&\r\n                                        implementsAbstractType(targetSchema, parentType_1, maybePossibleType)) {\r\n                                        newSelections.push({\r\n                                            kind: Kind.INLINE_FRAGMENT,\r\n                                            typeCondition: {\r\n                                                kind: Kind.NAMED_TYPE,\r\n                                                name: {\r\n                                                    kind: Kind.NAME,\r\n                                                    value: possibleType,\r\n                                                },\r\n                                            },\r\n                                            selectionSet: selection.selectionSet,\r\n                                        });\r\n                                    }\r\n                                });\r\n                            }\r\n                        }\r\n                    }\r\n                    else if (selection.kind === Kind.FRAGMENT_SPREAD) {\r\n                        var fragmentName = selection.name.value;\r\n                        if (fragmentName in fragmentReplacements) {\r\n                            fragmentReplacements[fragmentName].forEach(function (replacement) {\r\n                                var typeName = replacement.typeName;\r\n                                var maybeReplacementType = targetSchema.getType(typeName);\r\n                                if (maybeReplacementType != null &&\r\n                                    implementsAbstractType(targetSchema, parentType_1, maybeType)) {\r\n                                    newSelections.push({\r\n                                        kind: Kind.FRAGMENT_SPREAD,\r\n                                        name: {\r\n                                            kind: Kind.NAME,\r\n                                            value: replacement.fragmentName,\r\n                                        },\r\n                                    });\r\n                                }\r\n                            });\r\n                        }\r\n                    }\r\n                });\r\n                if (parentType_1.name in reverseMapping) {\r\n                    newSelections.push({\r\n                        kind: Kind.FIELD,\r\n                        name: {\r\n                            kind: Kind.NAME,\r\n                            value: '__typename',\r\n                        },\r\n                    });\r\n                }\r\n            }\r\n            if (newSelections.length !== node.selections.length) {\r\n                return __assign(__assign({}, node), { selections: newSelections });\r\n            }\r\n        },\r\n        _a)));\r\n}\n\n/**\r\n * Creates a keyed JS object from an array, given a function to produce the keys\r\n * and a function to produce the values from each item in the array.\r\n *\r\n *     const phoneBook = [\r\n *       { name: 'Jon', num: '555-1234' },\r\n *       { name: 'Jenny', num: '867-5309' }\r\n *     ]\r\n *\r\n *     // { Jon: '555-1234', Jenny: '867-5309' }\r\n *     const phonesByName = keyValMap(\r\n *       phoneBook,\r\n *       entry => entry.name,\r\n *       entry => entry.num\r\n *     )\r\n *\r\n */\r\nfunction keyValMap(list, keyFn, valFn) {\r\n    return list.reduce(function (map, item) {\r\n        map[keyFn(item)] = valFn(item);\r\n        return map;\r\n    }, Object.create(null));\r\n}\n\nvar FilterToSchema = /** @class */ (function () {\r\n    function FilterToSchema(targetSchema) {\r\n        this.targetSchema = targetSchema;\r\n    }\r\n    FilterToSchema.prototype.transformRequest = function (originalRequest) {\r\n        return __assign(__assign({}, originalRequest), filterToSchema(this.targetSchema, originalRequest.document, originalRequest.variables));\r\n    };\r\n    return FilterToSchema;\r\n}());\r\nfunction filterToSchema(targetSchema, document, variables) {\r\n    var operations = document.definitions.filter(function (def) { return def.kind === Kind.OPERATION_DEFINITION; });\r\n    var fragments = document.definitions.filter(function (def) { return def.kind === Kind.FRAGMENT_DEFINITION; });\r\n    var usedVariables = [];\r\n    var usedFragments = [];\r\n    var newOperations = [];\r\n    var newFragments = [];\r\n    var validFragments = fragments.filter(function (fragment) {\r\n        var typeName = fragment.typeCondition.name.value;\r\n        return Boolean(targetSchema.getType(typeName));\r\n    });\r\n    var validFragmentsWithType = keyValMap(validFragments, function (fragment) { return fragment.name.value; }, function (fragment) { return targetSchema.getType(fragment.typeCondition.name.value); });\r\n    var fragmentSet = Object.create(null);\r\n    operations.forEach(function (operation) {\r\n        var type;\r\n        if (operation.operation === 'subscription') {\r\n            type = targetSchema.getSubscriptionType();\r\n        }\r\n        else if (operation.operation === 'mutation') {\r\n            type = targetSchema.getMutationType();\r\n        }\r\n        else {\r\n            type = targetSchema.getQueryType();\r\n        }\r\n        var _a = filterSelectionSet(targetSchema, type, validFragmentsWithType, operation.selectionSet), selectionSet = _a.selectionSet, operationUsedFragments = _a.usedFragments, operationUsedVariables = _a.usedVariables;\r\n        usedFragments = union(usedFragments, operationUsedFragments);\r\n        var _b = collectFragmentVariables(targetSchema, fragmentSet, validFragments, validFragmentsWithType, usedFragments), collectedUsedVariables = _b.usedVariables, collectedNewFragments = _b.newFragments, collectedFragmentSet = _b.fragmentSet;\r\n        var operationOrFragmentVariables = union(operationUsedVariables, collectedUsedVariables);\r\n        usedVariables = union(usedVariables, operationOrFragmentVariables);\r\n        newFragments = collectedNewFragments;\r\n        fragmentSet = collectedFragmentSet;\r\n        var variableDefinitions = operation.variableDefinitions.filter(function (variable) {\r\n            return operationOrFragmentVariables.indexOf(variable.variable.name.value) !==\r\n                -1;\r\n        });\r\n        newOperations.push({\r\n            kind: Kind.OPERATION_DEFINITION,\r\n            operation: operation.operation,\r\n            name: operation.name,\r\n            directives: operation.directives,\r\n            variableDefinitions: variableDefinitions,\r\n            selectionSet: selectionSet,\r\n        });\r\n    });\r\n    var newVariables = usedVariables.reduce(function (acc, variableName) {\r\n        acc[variableName] = variables[variableName];\r\n        return acc;\r\n    }, {});\r\n    return {\r\n        document: {\r\n            kind: Kind.DOCUMENT,\r\n            definitions: __spreadArrays(newOperations, newFragments),\r\n        },\r\n        variables: newVariables,\r\n    };\r\n}\r\nfunction collectFragmentVariables(targetSchema, fragmentSet, validFragments, validFragmentsWithType, usedFragments) {\r\n    var remainingFragments = usedFragments.slice();\r\n    var usedVariables = [];\r\n    var newFragments = [];\r\n    var _loop_1 = function () {\r\n        var nextFragmentName = remainingFragments.pop();\r\n        var fragment = validFragments.find(function (fr) { return fr.name.value === nextFragmentName; });\r\n        if (fragment != null) {\r\n            var name_1 = nextFragmentName;\r\n            var typeName = fragment.typeCondition.name.value;\r\n            var type = targetSchema.getType(typeName);\r\n            var _a = filterSelectionSet(targetSchema, type, validFragmentsWithType, fragment.selectionSet), selectionSet = _a.selectionSet, fragmentUsedFragments = _a.usedFragments, fragmentUsedVariables = _a.usedVariables;\r\n            remainingFragments = union(remainingFragments, fragmentUsedFragments);\r\n            usedVariables = union(usedVariables, fragmentUsedVariables);\r\n            if (!(name_1 in fragmentSet)) {\r\n                fragmentSet[name_1] = true;\r\n                newFragments.push({\r\n                    kind: Kind.FRAGMENT_DEFINITION,\r\n                    name: {\r\n                        kind: Kind.NAME,\r\n                        value: name_1,\r\n                    },\r\n                    typeCondition: fragment.typeCondition,\r\n                    selectionSet: selectionSet,\r\n                });\r\n            }\r\n        }\r\n    };\r\n    while (remainingFragments.length !== 0) {\r\n        _loop_1();\r\n    }\r\n    return {\r\n        usedVariables: usedVariables,\r\n        newFragments: newFragments,\r\n        fragmentSet: fragmentSet,\r\n    };\r\n}\r\nfunction filterSelectionSet(schema, type, validFragments, selectionSet) {\r\n    var _a;\r\n    var usedFragments = [];\r\n    var usedVariables = [];\r\n    var typeInfo = new TypeInfo(schema, undefined, type);\r\n    var filteredSelectionSet = visit(selectionSet, visitWithTypeInfo(typeInfo, (_a = {},\r\n        _a[Kind.FIELD] = {\r\n            enter: function (node) {\r\n                var parentType = typeInfo.getParentType();\r\n                if (isObjectType(parentType) || isInterfaceType(parentType)) {\r\n                    var fields = parentType.getFields();\r\n                    var field = node.name.value === '__typename'\r\n                        ? TypeNameMetaFieldDef\r\n                        : fields[node.name.value];\r\n                    if (!field) {\r\n                        return null;\r\n                    }\r\n                    var argNames_1 = (field.args != null ? field.args : []).map(function (arg) { return arg.name; });\r\n                    if (node.arguments != null) {\r\n                        var args = node.arguments.filter(function (arg) { return argNames_1.indexOf(arg.name.value) !== -1; });\r\n                        if (args.length !== node.arguments.length) {\r\n                            return __assign(__assign({}, node), { arguments: args });\r\n                        }\r\n                    }\r\n                }\r\n            },\r\n            leave: function (node) {\r\n                var _a;\r\n                var resolvedType = getNamedType(typeInfo.getType());\r\n                if (isObjectType(resolvedType) || isInterfaceType(resolvedType)) {\r\n                    var selections = node.selectionSet != null ? node.selectionSet.selections : null;\r\n                    if (selections == null || selections.length === 0) {\r\n                        // need to remove any added variables. Is there a better way to do this?\r\n                        visit(node, (_a = {},\r\n                            _a[Kind.VARIABLE] = function (variableNode) {\r\n                                var index = usedVariables.indexOf(variableNode.name.value);\r\n                                if (index !== -1) {\r\n                                    usedVariables.splice(index, 1);\r\n                                }\r\n                            },\r\n                            _a));\r\n                        return null;\r\n                    }\r\n                }\r\n            },\r\n        },\r\n        _a[Kind.FRAGMENT_SPREAD] = function (node) {\r\n            if (node.name.value in validFragments) {\r\n                var parentType = typeInfo.getParentType();\r\n                var innerType = validFragments[node.name.value];\r\n                if (!implementsAbstractType(schema, parentType, innerType)) {\r\n                    return null;\r\n                }\r\n                usedFragments.push(node.name.value);\r\n                return;\r\n            }\r\n            return null;\r\n        },\r\n        _a[Kind.INLINE_FRAGMENT] = {\r\n            enter: function (node) {\r\n                if (node.typeCondition != null) {\r\n                    var parentType = typeInfo.getParentType();\r\n                    var innerType = schema.getType(node.typeCondition.name.value);\r\n                    if (!implementsAbstractType(schema, parentType, innerType)) {\r\n                        return null;\r\n                    }\r\n                }\r\n            },\r\n        },\r\n        _a[Kind.VARIABLE] = function (node) {\r\n            usedVariables.push(node.name.value);\r\n        },\r\n        _a)));\r\n    return {\r\n        selectionSet: filteredSelectionSet,\r\n        usedFragments: usedFragments,\r\n        usedVariables: usedVariables,\r\n    };\r\n}\r\nfunction union() {\r\n    var arrays = [];\r\n    for (var _i = 0; _i < arguments.length; _i++) {\r\n        arrays[_i] = arguments[_i];\r\n    }\r\n    var cache = Object.create(null);\r\n    var result = [];\r\n    arrays.forEach(function (array) {\r\n        array.forEach(function (item) {\r\n            if (!(item in cache)) {\r\n                cache[item] = true;\r\n                result.push(item);\r\n            }\r\n        });\r\n    });\r\n    return result;\r\n}\n\nvar AddReplacementSelectionSets = /** @class */ (function () {\r\n    function AddReplacementSelectionSets(schema, mapping) {\r\n        this.schema = schema;\r\n        this.mapping = mapping;\r\n    }\r\n    AddReplacementSelectionSets.prototype.transformRequest = function (originalRequest) {\r\n        var document = replaceFieldsWithSelectionSet(this.schema, originalRequest.document, this.mapping);\r\n        return __assign(__assign({}, originalRequest), { document: document });\r\n    };\r\n    return AddReplacementSelectionSets;\r\n}());\r\nfunction replaceFieldsWithSelectionSet(schema, document, mapping) {\r\n    var _a;\r\n    var typeInfo = new TypeInfo(schema);\r\n    return visit(document, visitWithTypeInfo(typeInfo, (_a = {},\r\n        _a[Kind.SELECTION_SET] = function (node) {\r\n            var parentType = typeInfo.getParentType();\r\n            if (parentType != null) {\r\n                var parentTypeName_1 = parentType.name;\r\n                var selections_1 = node.selections;\r\n                if (parentTypeName_1 in mapping) {\r\n                    node.selections.forEach(function (selection) {\r\n                        if (selection.kind === Kind.FIELD) {\r\n                            var name_1 = selection.name.value;\r\n                            var selectionSet = mapping[parentTypeName_1][name_1];\r\n                            if (selectionSet != null) {\r\n                                selections_1 = selections_1.concat(selectionSet.selections);\r\n                            }\r\n                        }\r\n                    });\r\n                }\r\n                if (selections_1 !== node.selections) {\r\n                    return __assign(__assign({}, node), { selections: selections_1 });\r\n                }\r\n            }\r\n        },\r\n        _a)));\r\n}\n\nvar AddReplacementFragments = /** @class */ (function () {\r\n    function AddReplacementFragments(targetSchema, mapping) {\r\n        this.targetSchema = targetSchema;\r\n        this.mapping = mapping;\r\n    }\r\n    AddReplacementFragments.prototype.transformRequest = function (originalRequest) {\r\n        var document = replaceFieldsWithFragments(this.targetSchema, originalRequest.document, this.mapping);\r\n        return __assign(__assign({}, originalRequest), { document: document });\r\n    };\r\n    return AddReplacementFragments;\r\n}());\r\nfunction replaceFieldsWithFragments(targetSchema, document, mapping) {\r\n    var _a;\r\n    var typeInfo = new TypeInfo(targetSchema);\r\n    return visit(document, visitWithTypeInfo(typeInfo, (_a = {},\r\n        _a[Kind.SELECTION_SET] = function (node) {\r\n            var parentType = typeInfo.getParentType();\r\n            if (parentType != null) {\r\n                var parentTypeName_1 = parentType.name;\r\n                var selections_1 = node.selections;\r\n                if (parentTypeName_1 in mapping) {\r\n                    node.selections.forEach(function (selection) {\r\n                        if (selection.kind === Kind.FIELD) {\r\n                            var name_1 = selection.name.value;\r\n                            var fragment = mapping[parentTypeName_1][name_1];\r\n                            if (fragment != null) {\r\n                                selections_1 = selections_1.concat(fragment);\r\n                            }\r\n                        }\r\n                    });\r\n                }\r\n                if (selections_1 !== node.selections) {\r\n                    return __assign(__assign({}, node), { selections: selections_1 });\r\n                }\r\n            }\r\n        },\r\n        _a)));\r\n}\n\nvar AddMergedTypeFragments = /** @class */ (function () {\r\n    function AddMergedTypeFragments(targetSchema, mapping) {\r\n        this.targetSchema = targetSchema;\r\n        this.mapping = mapping;\r\n    }\r\n    AddMergedTypeFragments.prototype.transformRequest = function (originalRequest) {\r\n        var document = addMergedTypeSelectionSets(this.targetSchema, originalRequest.document, this.mapping);\r\n        return __assign(__assign({}, originalRequest), { document: document });\r\n    };\r\n    return AddMergedTypeFragments;\r\n}());\r\nfunction addMergedTypeSelectionSets(targetSchema, document, mapping) {\r\n    var _a;\r\n    var typeInfo = new TypeInfo(targetSchema);\r\n    return visit(document, visitWithTypeInfo(typeInfo, (_a = {},\r\n        _a[Kind.SELECTION_SET] = function (node) {\r\n            var parentType = typeInfo.getParentType();\r\n            if (parentType != null) {\r\n                var parentTypeName = parentType.name;\r\n                var selections = node.selections;\r\n                if (parentTypeName in mapping) {\r\n                    var selectionSet = mapping[parentTypeName].selectionSet;\r\n                    if (selectionSet != null) {\r\n                        selections = selections.concat(selectionSet.selections);\r\n                    }\r\n                }\r\n                if (selections !== node.selections) {\r\n                    return __assign(__assign({}, node), { selections: selections });\r\n                }\r\n            }\r\n        },\r\n        _a)));\r\n}\n\nfunction addTypenameToAbstract(targetSchema, document) {\r\n    var _a;\r\n    var typeInfo = new TypeInfo(targetSchema);\r\n    return visit(document, visitWithTypeInfo(typeInfo, (_a = {},\r\n        _a[Kind.SELECTION_SET] = function (node) {\r\n            var parentType = typeInfo.getParentType();\r\n            var selections = node.selections;\r\n            if (parentType != null && isAbstractType(parentType)) {\r\n                selections = selections.concat({\r\n                    kind: Kind.FIELD,\r\n                    name: {\r\n                        kind: Kind.NAME,\r\n                        value: '__typename',\r\n                    },\r\n                });\r\n            }\r\n            if (selections !== node.selections) {\r\n                return __assign(__assign({}, node), { selections: selections });\r\n            }\r\n        },\r\n        _a)));\r\n}\n\nvar AddTypenameToAbstract = /** @class */ (function () {\r\n    function AddTypenameToAbstract(targetSchema) {\r\n        this.targetSchema = targetSchema;\r\n    }\r\n    AddTypenameToAbstract.prototype.transformRequest = function (originalRequest) {\r\n        var document = addTypenameToAbstract(this.targetSchema, originalRequest.document);\r\n        return __assign(__assign({}, originalRequest), { document: document });\r\n    };\r\n    return AddTypenameToAbstract;\r\n}());\n\n/**\r\n * Get the key under which the result of this resolver will be placed in the response JSON. Basically, just\r\n * resolves aliases.\r\n * @param info The info argument to the resolver.\r\n */\r\nfunction getResponseKeyFromInfo(info) {\r\n    return info.fieldNodes[0].alias != null\r\n        ? info.fieldNodes[0].alias.value\r\n        : info.fieldName;\r\n}\n\nvar hasSymbol = (typeof global !== 'undefined' && 'Symbol' in global) ||\r\n    // eslint-disable-next-line no-undef\r\n    (typeof window !== 'undefined' && 'Symbol' in window);\r\nvar OBJECT_SUBSCHEMA_SYMBOL = hasSymbol\r\n    ? Symbol('initialSubschema')\r\n    : '@@__initialSubschema';\r\nvar FIELD_SUBSCHEMA_MAP_SYMBOL = hasSymbol\r\n    ? Symbol('subschemaMap')\r\n    : '@@__subschemaMap';\r\nvar ERROR_SYMBOL = hasSymbol\r\n    ? Symbol('subschemaErrors')\r\n    : '@@__subschemaErrors';\n\nfunction relocatedError(originalError, nodes, path) {\r\n    if (Array.isArray(originalError.path)) {\r\n        return new GraphQLError(originalError.message, originalError.nodes, originalError.source, originalError.positions, path != null ? path : originalError.path, originalError.originalError, originalError.extensions);\r\n    }\r\n    if (originalError == null) {\r\n        return new GraphQLError(undefined, nodes, undefined, undefined, path, originalError);\r\n    }\r\n    return new GraphQLError(originalError.message, originalError.nodes != null\r\n        ? originalError.nodes\r\n        : nodes, originalError.source, originalError.positions, path, originalError);\r\n}\r\nfunction slicedError(originalError) {\r\n    return relocatedError(originalError, originalError.nodes, originalError.path != null ? originalError.path.slice(1) : undefined);\r\n}\r\nfunction getErrorsByPathSegment(errors) {\r\n    var record = Object.create(null);\r\n    errors.forEach(function (error) {\r\n        if (!error.path || error.path.length < 2) {\r\n            return;\r\n        }\r\n        var pathSegment = error.path[1];\r\n        var current = pathSegment in record ? record[pathSegment] : [];\r\n        current.push(slicedError(error));\r\n        record[pathSegment] = current;\r\n    });\r\n    return record;\r\n}\r\nvar CombinedError = /** @class */ (function (_super) {\r\n    __extends(CombinedError, _super);\r\n    function CombinedError(message, errors) {\r\n        var _this = _super.call(this, message) || this;\r\n        _this.errors = errors;\r\n        return _this;\r\n    }\r\n    return CombinedError;\r\n}(Error));\r\nfunction combineErrors(errors) {\r\n    if (errors.length === 1) {\r\n        return new GraphQLError(errors[0].message, errors[0].nodes, errors[0].source, errors[0].positions, errors[0].path, errors[0].originalError, errors[0].extensions);\r\n    }\r\n    return new CombinedError(errors.map(function (error) { return error.message; }).join('\\n'), errors);\r\n}\r\nfunction setErrors(result, errors) {\r\n    result[ERROR_SYMBOL] = errors;\r\n}\r\nfunction getErrors(result, pathSegment) {\r\n    var errors = result != null ? result[ERROR_SYMBOL] : result;\r\n    if (!Array.isArray(errors)) {\r\n        return null;\r\n    }\r\n    var fieldErrors = [];\r\n    for (var _i = 0, errors_1 = errors; _i < errors_1.length; _i++) {\r\n        var error = errors_1[_i];\r\n        if (!error.path || error.path[0] === pathSegment) {\r\n            fieldErrors.push(error);\r\n        }\r\n    }\r\n    return fieldErrors;\r\n}\n\nfunction handleNull(fieldNodes, path, errors) {\r\n    if (errors.length) {\r\n        if (errors.some(function (error) { return !error.path || error.path.length < 2; })) {\r\n            return relocatedError(combineErrors(errors), fieldNodes, path);\r\n        }\r\n        else if (errors.some(function (error) { return typeof error.path[1] === 'string'; })) {\r\n            var childErrors_1 = getErrorsByPathSegment(errors);\r\n            var result_1 = {};\r\n            Object.keys(childErrors_1).forEach(function (pathSegment) {\r\n                result_1[pathSegment] = handleNull(fieldNodes, __spreadArrays(path, [pathSegment]), childErrors_1[pathSegment]);\r\n            });\r\n            return result_1;\r\n        }\r\n        var childErrors_2 = getErrorsByPathSegment(errors);\r\n        var result_2 = [];\r\n        Object.keys(childErrors_2).forEach(function (pathSegment) {\r\n            result_2.push(handleNull(fieldNodes, __spreadArrays(path, [parseInt(pathSegment, 10)]), childErrors_2[pathSegment]));\r\n        });\r\n        return result_2;\r\n    }\r\n    return null;\r\n}\n\n/**\r\n * Given a selectionSet, adds all of the fields in that selection to\r\n * the passed in map of fields, and returns it at the end.\r\n *\r\n * CollectFields requires the \"runtime type\" of an object. For a field which\r\n * returns an Interface or Union type, the \"runtime type\" will be the actual\r\n * Object type returned by that field.\r\n *\r\n * @internal\r\n */\r\nfunction collectFields(exeContext, runtimeType, selectionSet, fields, visitedFragmentNames) {\r\n    for (var _i = 0, _a = selectionSet.selections; _i < _a.length; _i++) {\r\n        var selection = _a[_i];\r\n        switch (selection.kind) {\r\n            case Kind.FIELD: {\r\n                if (!shouldIncludeNode(exeContext, selection)) {\r\n                    continue;\r\n                }\r\n                var name_1 = getFieldEntryKey(selection);\r\n                if (!(name_1 in fields)) {\r\n                    fields[name_1] = [];\r\n                }\r\n                fields[name_1].push(selection);\r\n                break;\r\n            }\r\n            case Kind.INLINE_FRAGMENT: {\r\n                if (!shouldIncludeNode(exeContext, selection) ||\r\n                    !doesFragmentConditionMatch(exeContext, selection, runtimeType)) {\r\n                    continue;\r\n                }\r\n                collectFields(exeContext, runtimeType, selection.selectionSet, fields, visitedFragmentNames);\r\n                break;\r\n            }\r\n            case Kind.FRAGMENT_SPREAD: {\r\n                var fragName = selection.name.value;\r\n                if (visitedFragmentNames[fragName] ||\r\n                    !shouldIncludeNode(exeContext, selection)) {\r\n                    continue;\r\n                }\r\n                visitedFragmentNames[fragName] = true;\r\n                var fragment = exeContext.fragments[fragName];\r\n                if (!fragment ||\r\n                    !doesFragmentConditionMatch(exeContext, fragment, runtimeType)) {\r\n                    continue;\r\n                }\r\n                collectFields(exeContext, runtimeType, fragment.selectionSet, fields, visitedFragmentNames);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    return fields;\r\n}\r\n/**\r\n * Determines if a field should be included based on the @include and @skip\r\n * directives, where @skip has higher precedence than @include.\r\n */\r\nfunction shouldIncludeNode(exeContext, node) {\r\n    var skip = getDirectiveValues(GraphQLSkipDirective, node, exeContext.variableValues);\r\n    if ((skip === null || skip === void 0 ? void 0 : skip.if) === true) {\r\n        return false;\r\n    }\r\n    var include = getDirectiveValues(GraphQLIncludeDirective, node, exeContext.variableValues);\r\n    if ((include === null || include === void 0 ? void 0 : include.if) === false) {\r\n        return false;\r\n    }\r\n    return true;\r\n}\r\n/**\r\n * Determines if a fragment is applicable to the given type.\r\n */\r\nfunction doesFragmentConditionMatch(exeContext, fragment, type) {\r\n    var typeConditionNode = fragment.typeCondition;\r\n    if (!typeConditionNode) {\r\n        return true;\r\n    }\r\n    var conditionalType = typeFromAST$1(exeContext.schema, typeConditionNode);\r\n    if (conditionalType === type) {\r\n        return true;\r\n    }\r\n    if (isAbstractType(conditionalType)) {\r\n        return exeContext.schema.isPossibleType(conditionalType, type);\r\n    }\r\n    return false;\r\n}\r\n/**\r\n * Implements the logic to compute the key of a given field's entry\r\n */\r\nfunction getFieldEntryKey(node) {\r\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\r\n    return node.alias ? node.alias.value : node.name.value;\r\n}\n\nfunction getSubschema(result, responseKey) {\r\n    var subschema = result[FIELD_SUBSCHEMA_MAP_SYMBOL] &&\r\n        result[FIELD_SUBSCHEMA_MAP_SYMBOL][responseKey];\r\n    return subschema ? subschema : result[OBJECT_SUBSCHEMA_SYMBOL];\r\n}\r\nfunction setObjectSubschema(result, subschema) {\r\n    result[OBJECT_SUBSCHEMA_SYMBOL] = subschema;\r\n}\n\nfunction resolveFromParentTypename(parent) {\r\n    var parentTypename = parent['__typename'];\r\n    if (!parentTypename) {\r\n        throw new Error('Did not fetch typename for object, unable to resolve interface.');\r\n    }\r\n    return parentTypename;\r\n}\n\nfunction mergeDeep(target) {\r\n    var sources = [];\r\n    for (var _i = 1; _i < arguments.length; _i++) {\r\n        sources[_i - 1] = arguments[_i];\r\n    }\r\n    var output = __assign({}, target);\r\n    sources.forEach(function (source) {\r\n        if (isObject(target) && isObject(source)) {\r\n            Object.keys(source).forEach(function (key) {\r\n                var _a, _b;\r\n                if (isObject(source[key])) {\r\n                    if (!(key in target)) {\r\n                        Object.assign(output, (_a = {}, _a[key] = source[key], _a));\r\n                    }\r\n                    else {\r\n                        output[key] = mergeDeep(target[key], source[key]);\r\n                    }\r\n                }\r\n                else {\r\n                    Object.assign(output, (_b = {}, _b[key] = source[key], _b));\r\n                }\r\n            });\r\n        }\r\n    });\r\n    return output;\r\n}\r\nfunction isObject(item) {\r\n    return item && typeof item === 'object' && !Array.isArray(item);\r\n}\n\nfunction unwrapResult(parent, info, path) {\r\n    var newParent = parent;\r\n    var pathLength = path.length;\r\n    for (var i = 0; i < pathLength; i++) {\r\n        var responseKey = path[i];\r\n        var errors = getErrors(newParent, responseKey);\r\n        var subschema = getSubschema(newParent, responseKey);\r\n        var object = newParent[responseKey];\r\n        if (object == null) {\r\n            return handleNull(info.fieldNodes, responsePathAsArray(info.path), errors);\r\n        }\r\n        setErrors(object, errors.map(function (error) {\r\n            return relocatedError(error, error.nodes, error.path != null ? error.path.slice(1) : undefined);\r\n        }));\r\n        setObjectSubschema(object, subschema);\r\n        newParent = object;\r\n    }\r\n    return newParent;\r\n}\r\nfunction dehoistResult(parent, delimeter) {\r\n    if (delimeter === void 0) { delimeter = '__gqltf__'; }\r\n    var result = Object.create(null);\r\n    Object.keys(parent).forEach(function (alias) {\r\n        var obj = result;\r\n        var fieldNames = alias.split(delimeter);\r\n        var fieldName = fieldNames.pop();\r\n        fieldNames.forEach(function (key) {\r\n            obj = obj[key] = obj[key] || Object.create(null);\r\n        });\r\n        obj[fieldName] = parent[alias];\r\n    });\r\n    result[ERROR_SYMBOL] = parent[ERROR_SYMBOL].map(function (error) {\r\n        if (error.path != null) {\r\n            var path = error.path.slice();\r\n            var pathSegment = path.shift();\r\n            var expandedPathSegment = pathSegment.split(delimeter);\r\n            return relocatedError(error, error.nodes, expandedPathSegment.concat(path));\r\n        }\r\n        return error;\r\n    });\r\n    result[OBJECT_SUBSCHEMA_SYMBOL] = parent[OBJECT_SUBSCHEMA_SYMBOL];\r\n    return result;\r\n}\r\nfunction mergeProxiedResults(target) {\r\n    var sources = [];\r\n    for (var _i = 1; _i < arguments.length; _i++) {\r\n        sources[_i - 1] = arguments[_i];\r\n    }\r\n    var errors = target[ERROR_SYMBOL].concat(sources.map(function (source) { return source[ERROR_SYMBOL]; }));\r\n    var fieldSubschemaMap = sources.reduce(function (acc, source) {\r\n        var subschema = source[OBJECT_SUBSCHEMA_SYMBOL];\r\n        Object.keys(source).forEach(function (key) {\r\n            acc[key] = subschema;\r\n        });\r\n        return acc;\r\n    }, {});\r\n    var result = mergeDeep.apply(void 0, __spreadArrays([target], sources));\r\n    result[ERROR_SYMBOL] = errors;\r\n    result[FIELD_SUBSCHEMA_MAP_SYMBOL] = target[FIELD_SUBSCHEMA_MAP_SYMBOL]\r\n        ? mergeDeep(target[FIELD_SUBSCHEMA_MAP_SYMBOL], fieldSubschemaMap)\r\n        : fieldSubschemaMap;\r\n    return result;\r\n}\n\nfunction buildDelegationPlan(mergedTypeInfo, originalSelections, sourceSubschemas, targetSubschemas) {\r\n    // 1.  calculate if possible to delegate to given subschema\r\n    //    TODO: change logic so that required selection set can be spread across multiple subschemas?\r\n    var proxiableSubschemas = [];\r\n    var nonProxiableSubschemas = [];\r\n    targetSubschemas.forEach(function (t) {\r\n        if (sourceSubschemas.some(function (s) {\r\n            var selectionSet = mergedTypeInfo.selectionSets.get(t);\r\n            return mergedTypeInfo.containsSelectionSet.get(s).get(selectionSet);\r\n        })) {\r\n            proxiableSubschemas.push(t);\r\n        }\r\n        else {\r\n            nonProxiableSubschemas.push(t);\r\n        }\r\n    });\r\n    var uniqueFields = mergedTypeInfo.uniqueFields, nonUniqueFields = mergedTypeInfo.nonUniqueFields;\r\n    var unproxiableSelections = [];\r\n    // 2. for each selection:\r\n    var delegationMap = new Map();\r\n    originalSelections.forEach(function (selection) {\r\n        // 2a. use uniqueFields map to assign fields to subschema if one of possible subschemas\r\n        var uniqueSubschema = uniqueFields[selection.name.value];\r\n        if (uniqueSubschema != null) {\r\n            if (proxiableSubschemas.includes(uniqueSubschema)) {\r\n                var existingSubschema = delegationMap.get(uniqueSubschema);\r\n                if (existingSubschema != null) {\r\n                    existingSubschema.push(selection);\r\n                }\r\n                else {\r\n                    delegationMap.set(uniqueSubschema, [selection]);\r\n                }\r\n            }\r\n            else {\r\n                unproxiableSelections.push(selection);\r\n            }\r\n        }\r\n        else {\r\n            // 2b. use nonUniqueFields to assign to a possible subschema,\r\n            //     preferring one of the subschemas already targets of delegation\r\n            var nonUniqueSubschemas = nonUniqueFields[selection.name.value];\r\n            nonUniqueSubschemas = nonUniqueSubschemas.filter(function (s) {\r\n                return proxiableSubschemas.includes(s);\r\n            });\r\n            if (nonUniqueSubschemas != null) {\r\n                var subschemas_1 = Array.from(delegationMap.keys());\r\n                var existingSubschema = nonUniqueSubschemas.find(function (s) {\r\n                    return subschemas_1.includes(s);\r\n                });\r\n                if (existingSubschema != null) {\r\n                    delegationMap.get(existingSubschema).push(selection);\r\n                }\r\n                else {\r\n                    delegationMap.set(nonUniqueSubschemas[0], [selection]);\r\n                }\r\n            }\r\n            else {\r\n                unproxiableSelections.push(selection);\r\n            }\r\n        }\r\n    });\r\n    return {\r\n        delegationMap: delegationMap,\r\n        unproxiableSelections: unproxiableSelections,\r\n        proxiableSubschemas: proxiableSubschemas,\r\n        nonProxiableSubschemas: nonProxiableSubschemas,\r\n    };\r\n}\r\nfunction mergeFields(mergedTypeInfo, typeName, object, originalSelections, sourceSubschemas, targetSubschemas, context, info) {\r\n    if (!originalSelections.length) {\r\n        return object;\r\n    }\r\n    var _a = buildDelegationPlan(mergedTypeInfo, originalSelections, sourceSubschemas, targetSubschemas), delegationMap = _a.delegationMap, unproxiableSelections = _a.unproxiableSelections, proxiableSubschemas = _a.proxiableSubschemas, nonProxiableSubschemas = _a.nonProxiableSubschemas;\r\n    if (!delegationMap.size) {\r\n        return object;\r\n    }\r\n    var maybePromises = [];\r\n    delegationMap.forEach(function (selections, s) {\r\n        var maybePromise = s.merge[typeName].resolve(object, context, info, s, {\r\n            kind: Kind.SELECTION_SET,\r\n            selections: selections,\r\n        });\r\n        maybePromises.push(maybePromise);\r\n    });\r\n    var containsPromises = false;\r\n    for (var _i = 0, maybePromises_1 = maybePromises; _i < maybePromises_1.length; _i++) {\r\n        var maybePromise = maybePromises_1[_i];\r\n        if (maybePromise instanceof Promise) {\r\n            containsPromises = true;\r\n            break;\r\n        }\r\n    }\r\n    return containsPromises\r\n        ? Promise.all(maybePromises).then(function (results) {\r\n            return mergeFields(mergedTypeInfo, typeName, mergeProxiedResults.apply(void 0, __spreadArrays([object], results)), unproxiableSelections, sourceSubschemas.concat(proxiableSubschemas), nonProxiableSubschemas, context, info);\r\n        })\r\n        : mergeFields(mergedTypeInfo, typeName, mergeProxiedResults.apply(void 0, __spreadArrays([object], maybePromises)), unproxiableSelections, sourceSubschemas.concat(proxiableSubschemas), nonProxiableSubschemas, context, info);\r\n}\n\nfunction handleObject(type, object, errors, subschema, context, info, skipTypeMerging) {\r\n    setErrors(object, errors.map(function (error) {\r\n        return relocatedError(error, error.nodes, error.path != null ? error.path.slice(1) : undefined);\r\n    }));\r\n    setObjectSubschema(object, subschema);\r\n    if (skipTypeMerging || !info.mergeInfo) {\r\n        return object;\r\n    }\r\n    var typeName = isAbstractType(type)\r\n        ? info.schema.getTypeMap()[resolveFromParentTypename(object)].name\r\n        : type.name;\r\n    var mergedTypeInfo = info.mergeInfo.mergedTypes[typeName];\r\n    var targetSubschemas;\r\n    if (mergedTypeInfo != null) {\r\n        targetSubschemas = mergedTypeInfo.subschemas;\r\n    }\r\n    if (!targetSubschemas) {\r\n        return object;\r\n    }\r\n    targetSubschemas = targetSubschemas.filter(function (s) { return s !== subschema; });\r\n    if (!targetSubschemas.length) {\r\n        return object;\r\n    }\r\n    var subFields = collectSubFields(info, object.__typename);\r\n    var selections = getFieldsNotInSubschema(subFields, subschema, mergedTypeInfo, object.__typename);\r\n    return mergeFields(mergedTypeInfo, typeName, object, selections, [subschema], targetSubschemas, context, info);\r\n}\r\nfunction collectSubFields(info, typeName) {\r\n    var subFieldNodes = Object.create(null);\r\n    var visitedFragmentNames = Object.create(null);\r\n    info.fieldNodes.forEach(function (fieldNode) {\r\n        subFieldNodes = collectFields({\r\n            schema: info.schema,\r\n            variableValues: info.variableValues,\r\n            fragments: info.fragments,\r\n        }, info.schema.getType(typeName), fieldNode.selectionSet, subFieldNodes, visitedFragmentNames);\r\n    });\r\n    return subFieldNodes;\r\n}\r\nfunction getFieldsNotInSubschema(subFieldNodes, subschema, mergedTypeInfo, typeName) {\r\n    var typeMap = isSubschemaConfig(subschema)\r\n        ? mergedTypeInfo.typeMaps.get(subschema)\r\n        : subschema.getTypeMap();\r\n    var fields = typeMap[typeName].getFields();\r\n    var fieldsNotInSchema = [];\r\n    Object.keys(subFieldNodes).forEach(function (responseName) {\r\n        subFieldNodes[responseName].forEach(function (subFieldNode) {\r\n            if (!(subFieldNode.name.value in fields)) {\r\n                fieldsNotInSchema.push(subFieldNode);\r\n            }\r\n        });\r\n    });\r\n    return fieldsNotInSchema;\r\n}\n\nfunction handleList(type, list, errors, subschema, context, info, skipTypeMerging) {\r\n    var childErrors = getErrorsByPathSegment(errors);\r\n    return list.map(function (listMember, index) {\r\n        return handleListMember(getNullableType(type.ofType), listMember, index, index in childErrors ? childErrors[index] : [], subschema, context, info, skipTypeMerging);\r\n    });\r\n}\r\nfunction handleListMember(type, listMember, index, errors, subschema, context, info, skipTypeMerging) {\r\n    if (listMember == null) {\r\n        return handleNull(info.fieldNodes, __spreadArrays(responsePathAsArray(info.path), [index]), errors);\r\n    }\r\n    if (isLeafType(type)) {\r\n        return type.parseValue(listMember);\r\n    }\r\n    else if (isCompositeType(type)) {\r\n        return handleObject(type, listMember, errors, subschema, context, info, skipTypeMerging);\r\n    }\r\n    else if (isListType(type)) {\r\n        return handleList(type, listMember, errors, subschema, context, info, skipTypeMerging);\r\n    }\r\n}\n\nfunction checkResultAndHandleErrors(result, context, info, responseKey, subschema, returnType, skipTypeMerging) {\r\n    if (responseKey === void 0) { responseKey = getResponseKeyFromInfo(info); }\r\n    if (returnType === void 0) { returnType = info.returnType; }\r\n    var errors = result.errors != null ? result.errors : [];\r\n    var data = result.data != null ? result.data[responseKey] : undefined;\r\n    return handleResult(data, errors, subschema, context, info, returnType, skipTypeMerging);\r\n}\r\nfunction handleResult(result, errors, subschema, context, info, returnType, skipTypeMerging) {\r\n    if (returnType === void 0) { returnType = info.returnType; }\r\n    var type = getNullableType(returnType);\r\n    if (result == null) {\r\n        return handleNull(info.fieldNodes, responsePathAsArray(info.path), errors);\r\n    }\r\n    if (isLeafType(type)) {\r\n        return type.parseValue(result);\r\n    }\r\n    else if (isCompositeType(type)) {\r\n        return handleObject(type, result, errors, subschema, context, info, skipTypeMerging);\r\n    }\r\n    else if (isListType(type)) {\r\n        return handleList(type, result, errors, subschema, context, info, skipTypeMerging);\r\n    }\r\n}\n\nvar CheckResultAndHandleErrors = /** @class */ (function () {\r\n    function CheckResultAndHandleErrors(info, fieldName, subschema, context, returnType, typeMerge) {\r\n        if (returnType === void 0) { returnType = info.returnType; }\r\n        this.context = context;\r\n        this.info = info;\r\n        this.fieldName = fieldName;\r\n        this.subschema = subschema;\r\n        this.returnType = returnType;\r\n        this.typeMerge = typeMerge;\r\n    }\r\n    CheckResultAndHandleErrors.prototype.transformResult = function (result) {\r\n        return checkResultAndHandleErrors(result, this.context != null ? this.context : {}, this.info, this.fieldName, this.subschema, this.returnType, this.typeMerge);\r\n    };\r\n    return CheckResultAndHandleErrors;\r\n}());\n\nfunction transformInputValue(type, value, transformer) {\r\n    if (value == null) {\r\n        return value;\r\n    }\r\n    var nullableType = getNullableType(type);\r\n    if (isLeafType(nullableType)) {\r\n        return transformer(nullableType, value);\r\n    }\r\n    else if (isListType(nullableType)) {\r\n        return value.map(function (listMember) {\r\n            return transformInputValue(nullableType.ofType, listMember, transformer);\r\n        });\r\n    }\r\n    else if (isInputObjectType(nullableType)) {\r\n        var fields_1 = nullableType.getFields();\r\n        return keyValMap(Object.keys(value), function (key) { return key; }, function (key) { return transformInputValue(fields_1[key].type, value[key], transformer); });\r\n    }\r\n    // unreachable, no other possible return value\r\n}\r\nfunction serializeInputValue(type, value) {\r\n    return transformInputValue(type, value, function (t, v) { return t.serialize(v); });\r\n}\r\nfunction parseInputValue(type, value) {\r\n    return transformInputValue(type, value, function (t, v) { return t.parseValue(v); });\r\n}\n\nfunction astFromType(type) {\r\n    if (isNonNullType(type)) {\r\n        var innerType = astFromType(type.ofType);\r\n        if (innerType.kind === Kind.NON_NULL_TYPE) {\r\n            throw new Error(\"Invalid type node \" + JSON.stringify(type) + \". Inner type of non-null type cannot be a non-null type.\");\r\n        }\r\n        return {\r\n            kind: Kind.NON_NULL_TYPE,\r\n            type: innerType,\r\n        };\r\n    }\r\n    else if (isListType(type)) {\r\n        return {\r\n            kind: Kind.LIST_TYPE,\r\n            type: astFromType(type.ofType),\r\n        };\r\n    }\r\n    return {\r\n        kind: Kind.NAMED_TYPE,\r\n        name: {\r\n            kind: Kind.NAME,\r\n            value: type.name,\r\n        },\r\n    };\r\n}\n\nfunction updateArgument(argName, argType, argumentNodes, variableDefinitionsMap, variableValues, newArg) {\r\n    var varName;\r\n    var numGeneratedVariables = 0;\r\n    do {\r\n        varName = \"_v\" + (numGeneratedVariables++).toString() + \"_\" + argName;\r\n    } while (varName in variableDefinitionsMap);\r\n    argumentNodes[argName] = {\r\n        kind: Kind.ARGUMENT,\r\n        name: {\r\n            kind: Kind.NAME,\r\n            value: argName,\r\n        },\r\n        value: {\r\n            kind: Kind.VARIABLE,\r\n            name: {\r\n                kind: Kind.NAME,\r\n                value: varName,\r\n            },\r\n        },\r\n    };\r\n    variableDefinitionsMap[varName] = {\r\n        kind: Kind.VARIABLE_DEFINITION,\r\n        variable: {\r\n            kind: Kind.VARIABLE,\r\n            name: {\r\n                kind: Kind.NAME,\r\n                value: varName,\r\n            },\r\n        },\r\n        type: astFromType(argType),\r\n    };\r\n    variableValues[varName] = newArg;\r\n}\n\nfunction toObjMap(obj) {\r\n    if (Object.getPrototypeOf(obj) === null) {\r\n        return obj;\r\n    }\r\n    return Object.entries(obj).reduce(function (map, _a) {\r\n        var key = _a[0], value = _a[1];\r\n        map[key] = value;\r\n        return map;\r\n    }, Object.create(null));\r\n}\n\nvar AddArgumentsAsVariables = /** @class */ (function () {\r\n    function AddArgumentsAsVariables(targetSchema, args) {\r\n        this.targetSchema = targetSchema;\r\n        this.args = toObjMap(args);\r\n    }\r\n    AddArgumentsAsVariables.prototype.transformRequest = function (originalRequest) {\r\n        var _a = addVariablesToRootField(this.targetSchema, originalRequest, this.args), document = _a.document, newVariables = _a.newVariables;\r\n        return {\r\n            document: document,\r\n            variables: newVariables,\r\n        };\r\n    };\r\n    return AddArgumentsAsVariables;\r\n}());\r\nfunction addVariablesToRootField(targetSchema, originalRequest, args) {\r\n    var document = originalRequest.document;\r\n    var variableValues = originalRequest.variables;\r\n    var operations = document.definitions.filter(function (def) { return def.kind === Kind.OPERATION_DEFINITION; });\r\n    var fragments = document.definitions.filter(function (def) { return def.kind === Kind.FRAGMENT_DEFINITION; });\r\n    var newOperations = operations.map(function (operation) {\r\n        var variableDefinitionMap = keyValMap(operation.variableDefinitions, function (def) { return def.variable.name.value; }, function (def) { return def; });\r\n        var type;\r\n        if (operation.operation === 'subscription') {\r\n            type = targetSchema.getSubscriptionType();\r\n        }\r\n        else if (operation.operation === 'mutation') {\r\n            type = targetSchema.getMutationType();\r\n        }\r\n        else {\r\n            type = targetSchema.getQueryType();\r\n        }\r\n        var newSelectionSet = [];\r\n        operation.selectionSet.selections.forEach(function (selection) {\r\n            if (selection.kind === Kind.FIELD) {\r\n                var argumentNodes = selection.arguments;\r\n                var argumentNodeMap_1 = keyValMap(argumentNodes, function (argument) { return argument.name.value; }, function (argument) { return argument; });\r\n                var targetField = type.getFields()[selection.name.value];\r\n                // excludes __typename\r\n                if (targetField != null) {\r\n                    updateArguments(targetField, argumentNodeMap_1, variableDefinitionMap, variableValues, args);\r\n                }\r\n                newSelectionSet.push(__assign(__assign({}, selection), { arguments: Object.keys(argumentNodeMap_1).map(function (argName) { return argumentNodeMap_1[argName]; }) }));\r\n            }\r\n            else {\r\n                newSelectionSet.push(selection);\r\n            }\r\n        });\r\n        return __assign(__assign({}, operation), { variableDefinitions: Object.keys(variableDefinitionMap).map(function (varName) { return variableDefinitionMap[varName]; }), selectionSet: {\r\n                kind: Kind.SELECTION_SET,\r\n                selections: newSelectionSet,\r\n            } });\r\n    });\r\n    return {\r\n        document: __assign(__assign({}, document), { definitions: __spreadArrays(newOperations, fragments) }),\r\n        newVariables: variableValues,\r\n    };\r\n}\r\nfunction updateArguments(targetField, argumentNodeMap, variableDefinitionMap, variableValues, newArgs) {\r\n    targetField.args.forEach(function (argument) {\r\n        var argName = argument.name;\r\n        var argType = argument.type;\r\n        if (argName in newArgs) {\r\n            updateArgument(argName, argType, argumentNodeMap, variableDefinitionMap, variableValues, serializeInputValue(argType, newArgs[argName]));\r\n        }\r\n    });\r\n}\n\nvar version;\r\nif (versionInfo != null && versionInfo.major >= 15) {\r\n    version = 15;\r\n}\r\nelse if (getOperationRootType != null) {\r\n    version = 14;\r\n}\r\nelse if (lexicographicSortSchema != null) {\r\n    version = 13;\r\n}\r\nelse if (printError != null) {\r\n    version = 12;\r\n}\r\nelse {\r\n    version = 11;\r\n}\r\nfunction graphqlVersion() {\r\n    return version;\r\n}\n\nvar hasOwn = Object.prototype.hasOwnProperty;\r\nfunction hasOwnProperty(object, propertyName) {\r\n    return hasOwn.call(object, propertyName);\r\n}\n\n// graphql <v14.2 does not support toConfig\r\nfunction schemaToConfig(schema) {\r\n    if (schema.toConfig != null) {\r\n        return schema.toConfig();\r\n    }\r\n    var newTypes = [];\r\n    var types = schema.getTypeMap();\r\n    Object.keys(types).forEach(function (typeName) {\r\n        newTypes.push(types[typeName]);\r\n    });\r\n    var schemaConfig = {\r\n        query: schema.getQueryType(),\r\n        mutation: schema.getMutationType(),\r\n        subscription: schema.getSubscriptionType(),\r\n        types: newTypes,\r\n        directives: schema.getDirectives().slice(),\r\n        extensions: schema.extensions,\r\n        astNode: schema.astNode,\r\n        extensionASTNodes: schema.extensionASTNodes != null ? schema.extensionASTNodes : [],\r\n        assumeValid: schema.__validationErrors !==\r\n            undefined,\r\n    };\r\n    if (graphqlVersion() >= 15) {\r\n        schemaConfig.description = schema.description;\r\n    }\r\n    return schemaConfig;\r\n}\r\nfunction toConfig(graphqlObject) {\r\n    if (isSchema(graphqlObject)) {\r\n        return schemaToConfig(graphqlObject);\r\n    }\r\n    else if (isDirective(graphqlObject)) {\r\n        return directiveToConfig(graphqlObject);\r\n    }\r\n    else if (isNamedType(graphqlObject)) {\r\n        return typeToConfig(graphqlObject);\r\n    }\r\n    // Input and output fields do not have predicates defined, but using duck typing,\r\n    // type is defined for input and output fields\r\n    if (graphqlObject.type != null) {\r\n        if (graphqlObject.args != null ||\r\n            graphqlObject.resolve != null ||\r\n            graphqlObject.subscribe != null) {\r\n            return fieldToConfig(graphqlObject);\r\n        }\r\n        else if (graphqlObject.defaultValue !== undefined) {\r\n            return inputFieldToConfig(graphqlObject);\r\n        }\r\n        // Not all input and output fields can be checked by above in older versions\r\n        // of graphql, but almost all properties on the field and config are identical.\r\n        // In particular, just name and isDeprecated should be removed.\r\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n        var name_1 = graphqlObject.name, isDeprecated = graphqlObject.isDeprecated, rest = __rest(graphqlObject, [\"name\", \"isDeprecated\"]);\r\n        return __assign({}, rest);\r\n    }\r\n    throw new Error(\"Unknown graphql object \" + graphqlObject);\r\n}\r\nfunction typeToConfig(type) {\r\n    if (isObjectType(type)) {\r\n        return objectTypeToConfig(type);\r\n    }\r\n    else if (isInterfaceType(type)) {\r\n        return interfaceTypeToConfig(type);\r\n    }\r\n    else if (isUnionType(type)) {\r\n        return unionTypeToConfig(type);\r\n    }\r\n    else if (isEnumType(type)) {\r\n        return enumTypeToConfig(type);\r\n    }\r\n    else if (isScalarType(type)) {\r\n        return scalarTypeToConfig(type);\r\n    }\r\n    else if (isInputObjectType(type)) {\r\n        return inputObjectTypeToConfig(type);\r\n    }\r\n    throw new Error(\"Unknown type \" + type);\r\n}\r\nfunction objectTypeToConfig(type) {\r\n    if (type.toConfig != null) {\r\n        return type.toConfig();\r\n    }\r\n    var typeConfig = {\r\n        name: type.name,\r\n        description: type.description,\r\n        interfaces: type.getInterfaces(),\r\n        fields: fieldMapToConfig(type.getFields()),\r\n        isTypeOf: type.isTypeOf,\r\n        extensions: type.extensions,\r\n        astNode: type.astNode,\r\n        extensionASTNodes: type.extensionASTNodes != null ? type.extensionASTNodes : [],\r\n    };\r\n    return typeConfig;\r\n}\r\nfunction interfaceTypeToConfig(type) {\r\n    if (type.toConfig != null) {\r\n        return type.toConfig();\r\n    }\r\n    var typeConfig = {\r\n        name: type.name,\r\n        description: type.description,\r\n        fields: fieldMapToConfig(type.getFields()),\r\n        resolveType: type.resolveType,\r\n        extensions: type.extensions,\r\n        astNode: type.astNode,\r\n        extensionASTNodes: type.extensionASTNodes != null ? type.extensionASTNodes : [],\r\n    };\r\n    if (graphqlVersion() >= 15) {\r\n        typeConfig.interfaces = type.getInterfaces();\r\n    }\r\n    return typeConfig;\r\n}\r\nfunction unionTypeToConfig(type) {\r\n    if (type.toConfig != null) {\r\n        return type.toConfig();\r\n    }\r\n    var typeConfig = {\r\n        name: type.name,\r\n        description: type.description,\r\n        types: type.getTypes(),\r\n        resolveType: type.resolveType,\r\n        extensions: type.extensions,\r\n        astNode: type.astNode,\r\n        extensionASTNodes: type.extensionASTNodes != null ? type.extensionASTNodes : [],\r\n    };\r\n    return typeConfig;\r\n}\r\nfunction enumTypeToConfig(type) {\r\n    if (type.toConfig != null) {\r\n        return type.toConfig();\r\n    }\r\n    var newValues = keyValMap(type.getValues(), function (value) { return value.name; }, function (value) { return ({\r\n        description: value.description,\r\n        value: value.value,\r\n        deprecationReason: value.deprecationReason,\r\n        extensions: value.extensions,\r\n        astNode: value.astNode,\r\n    }); });\r\n    var typeConfig = {\r\n        name: type.name,\r\n        description: type.description,\r\n        values: newValues,\r\n        extensions: type.extensions,\r\n        astNode: type.astNode,\r\n        extensionASTNodes: type.extensionASTNodes != null ? type.extensionASTNodes : [],\r\n    };\r\n    return typeConfig;\r\n}\r\nfunction scalarTypeToConfig(type) {\r\n    if (type.toConfig != null) {\r\n        return type.toConfig();\r\n    }\r\n    var typeConfig = {\r\n        name: type.name,\r\n        description: type.description,\r\n        serialize: graphqlVersion() >= 14 || hasOwnProperty(type, 'serialize')\r\n            ? type.serialize\r\n            : type._scalarConfig.serialize,\r\n        parseValue: graphqlVersion() >= 14 || hasOwnProperty(type, 'parseValue')\r\n            ? type.parseValue\r\n            : type._scalarConfig.parseValue,\r\n        parseLiteral: graphqlVersion() >= 14 || hasOwnProperty(type, 'parseLiteral')\r\n            ? type.parseLiteral\r\n            : type._scalarConfig.parseLiteral,\r\n        extensions: type.extensions,\r\n        astNode: type.astNode,\r\n        extensionASTNodes: type.extensionASTNodes != null ? type.extensionASTNodes : [],\r\n    };\r\n    return typeConfig;\r\n}\r\nfunction inputObjectTypeToConfig(type) {\r\n    if (type.toConfig != null) {\r\n        return type.toConfig();\r\n    }\r\n    var typeConfig = {\r\n        name: type.name,\r\n        description: type.description,\r\n        fields: inputFieldMapToConfig(type.getFields()),\r\n        extensions: type.extensions,\r\n        astNode: type.astNode,\r\n        extensionASTNodes: type.extensionASTNodes != null ? type.extensionASTNodes : [],\r\n    };\r\n    return typeConfig;\r\n}\r\nfunction inputFieldMapToConfig(fields) {\r\n    return keyValMap(Object.keys(fields), function (fieldName) { return fieldName; }, function (fieldName) { return toConfig(fields[fieldName]); });\r\n}\r\nfunction inputFieldToConfig(field) {\r\n    return {\r\n        description: field.description,\r\n        type: field.type,\r\n        defaultValue: field.defaultValue,\r\n        extensions: field.extensions,\r\n        astNode: field.astNode,\r\n    };\r\n}\r\nfunction directiveToConfig(directive) {\r\n    if (directive.toConfig != null) {\r\n        return directive.toConfig();\r\n    }\r\n    var directiveConfig = {\r\n        name: directive.name,\r\n        description: directive.description,\r\n        locations: directive.locations,\r\n        args: argumentMapToConfig(directive.args),\r\n        isRepeatable: directive.isRepeatable,\r\n        extensions: directive.extensions,\r\n        astNode: directive.astNode,\r\n    };\r\n    return directiveConfig;\r\n}\r\nfunction fieldMapToConfig(fields) {\r\n    return keyValMap(Object.keys(fields), function (fieldName) { return fieldName; }, function (fieldName) { return toConfig(fields[fieldName]); });\r\n}\r\nfunction fieldToConfig(field) {\r\n    return {\r\n        description: field.description,\r\n        type: field.type,\r\n        args: argumentMapToConfig(field.args),\r\n        resolve: field.resolve,\r\n        subscribe: field.subscribe,\r\n        deprecationReason: field.deprecationReason,\r\n        extensions: field.extensions,\r\n        astNode: field.astNode,\r\n    };\r\n}\r\nfunction argumentMapToConfig(args) {\r\n    var newArguments = {};\r\n    args.forEach(function (arg) {\r\n        newArguments[arg.name] = argumentToConfig(arg);\r\n    });\r\n    return newArguments;\r\n}\r\nfunction argumentToConfig(arg) {\r\n    return {\r\n        description: arg.description,\r\n        type: arg.type,\r\n        defaultValue: arg.defaultValue,\r\n        extensions: arg.extensions,\r\n        astNode: arg.astNode,\r\n    };\r\n}\n\nfunction isSpecifiedScalarType(type) {\r\n    return (isNamedType(type) &&\r\n        // Would prefer to use specifiedScalarTypes.some(), however %checks needs\r\n        // a simple expression.\r\n        (type.name === GraphQLString.name ||\r\n            type.name === GraphQLInt.name ||\r\n            type.name === GraphQLFloat.name ||\r\n            type.name === GraphQLBoolean.name ||\r\n            type.name === GraphQLID.name));\r\n}\n\nfunction mapSchema(schema, schemaMapper) {\r\n    if (schemaMapper === void 0) { schemaMapper = {}; }\r\n    var originalTypeMap = schema.getTypeMap();\r\n    var newTypeMap = Object.create(null);\r\n    Object.keys(originalTypeMap).forEach(function (typeName) {\r\n        if (!typeName.startsWith('__')) {\r\n            var typeMapper = getMapper(schema, schemaMapper, originalTypeMap[typeName]);\r\n            if (typeMapper != null) {\r\n                var newType = typeMapper(originalTypeMap[typeName], schema);\r\n                newTypeMap[typeName] =\r\n                    newType !== undefined ? newType : originalTypeMap[typeName];\r\n            }\r\n            else {\r\n                newTypeMap[typeName] = originalTypeMap[typeName];\r\n            }\r\n        }\r\n    });\r\n    var queryType = schema.getQueryType();\r\n    var mutationType = schema.getMutationType();\r\n    var subscriptionType = schema.getSubscriptionType();\r\n    var newQueryTypeName = queryType != null\r\n        ? newTypeMap[queryType.name] != null\r\n            ? newTypeMap[queryType.name].name\r\n            : undefined\r\n        : undefined;\r\n    var newMutationTypeName = mutationType != null\r\n        ? newTypeMap[mutationType.name] != null\r\n            ? newTypeMap[mutationType.name].name\r\n            : undefined\r\n        : undefined;\r\n    var newSubscriptionTypeName = subscriptionType != null\r\n        ? newTypeMap[subscriptionType.name] != null\r\n            ? newTypeMap[subscriptionType.name].name\r\n            : undefined\r\n        : undefined;\r\n    var originalDirectives = schema.getDirectives();\r\n    var newDirectives = [];\r\n    originalDirectives.forEach(function (directive) {\r\n        var directiveMapper = getMapper(schema, schemaMapper, directive);\r\n        if (directiveMapper != null) {\r\n            var newDirective = directiveMapper(directive, schema);\r\n            if (newDirective != null) {\r\n                newDirectives.push(newDirective);\r\n            }\r\n        }\r\n        else {\r\n            newDirectives.push(directive);\r\n        }\r\n    });\r\n    var _a = rewireTypes(newTypeMap, newDirectives), typeMap = _a.typeMap, directives = _a.directives;\r\n    return new GraphQLSchema(__assign(__assign({}, toConfig(schema)), { query: newQueryTypeName\r\n            ? typeMap[newQueryTypeName]\r\n            : undefined, mutation: newMutationTypeName\r\n            ? typeMap[newMutationTypeName]\r\n            : undefined, subscription: newSubscriptionTypeName != null\r\n            ? typeMap[newSubscriptionTypeName]\r\n            : undefined, types: Object.keys(typeMap).map(function (typeName) { return typeMap[typeName]; }), directives: directives }));\r\n}\r\nfunction getTypeSpecifiers(type, schema) {\r\n    var specifiers = [MapperKind.TYPE];\r\n    if (isObjectType(type)) {\r\n        specifiers.push(MapperKind.COMPOSITE_TYPE, MapperKind.OBJECT_TYPE);\r\n        var query = schema.getQueryType();\r\n        var mutation = schema.getMutationType();\r\n        var subscription = schema.getSubscriptionType();\r\n        if (type === query) {\r\n            specifiers.push(MapperKind.ROOT_OBJECT, MapperKind.QUERY);\r\n        }\r\n        else if (type === mutation) {\r\n            specifiers.push(MapperKind.ROOT_OBJECT, MapperKind.MUTATION);\r\n        }\r\n        else if (type === subscription) {\r\n            specifiers.push(MapperKind.ROOT_OBJECT, MapperKind.SUBSCRIPTION);\r\n        }\r\n    }\r\n    else if (isInputType(type)) {\r\n        specifiers.push(MapperKind.INPUT_OBJECT_TYPE);\r\n    }\r\n    else if (isInterfaceType(type)) {\r\n        specifiers.push(MapperKind.COMPOSITE_TYPE, MapperKind.ABSTRACT_TYPE, MapperKind.INTERFACE_TYPE);\r\n    }\r\n    else if (isUnionType(type)) {\r\n        specifiers.push(MapperKind.COMPOSITE_TYPE, MapperKind.ABSTRACT_TYPE, MapperKind.UNION_TYPE);\r\n    }\r\n    else if (isEnumType(type)) {\r\n        specifiers.push(MapperKind.ENUM_TYPE);\r\n    }\r\n    else if (isScalarType(type)) {\r\n        specifiers.push(MapperKind.SCALAR_TYPE);\r\n    }\r\n    return specifiers;\r\n}\r\nfunction getMapper(schema, schemaMapper, typeOrDirective) {\r\n    if (isNamedType(typeOrDirective)) {\r\n        var specifiers = getTypeSpecifiers(typeOrDirective, schema);\r\n        var typeMapper = void 0;\r\n        var stack = __spreadArrays(specifiers);\r\n        while (!typeMapper && stack.length > 0) {\r\n            var next = stack.pop();\r\n            typeMapper = schemaMapper[next];\r\n        }\r\n        return typeMapper != null ? typeMapper : null;\r\n    }\r\n    else if (isDirective(typeOrDirective)) {\r\n        var directiveMapper = schemaMapper[MapperKind.DIRECTIVE];\r\n        return directiveMapper != null ? directiveMapper : null;\r\n    }\r\n}\r\nfunction rewireTypes(originalTypeMap, directives) {\r\n    var newTypeMap = Object.create(null);\r\n    Object.keys(originalTypeMap).forEach(function (typeName) {\r\n        var namedType = originalTypeMap[typeName];\r\n        if (namedType == null || typeName.startsWith('__')) {\r\n            return;\r\n        }\r\n        var newName = namedType.name;\r\n        if (newName.startsWith('__')) {\r\n            return;\r\n        }\r\n        if (newTypeMap[newName] != null) {\r\n            throw new Error(\"Duplicate schema type name \" + newName);\r\n        }\r\n        newTypeMap[newName] = namedType;\r\n    });\r\n    Object.keys(newTypeMap).forEach(function (typeName) {\r\n        newTypeMap[typeName] = rewireNamedType(newTypeMap[typeName]);\r\n    });\r\n    var newDirectives = directives.map(function (directive) {\r\n        return rewireDirective(directive);\r\n    });\r\n    return pruneTypes(newTypeMap, newDirectives);\r\n    function rewireDirective(directive) {\r\n        var directiveConfig = toConfig(directive);\r\n        directiveConfig.args = rewireArgs(directiveConfig.args);\r\n        return new GraphQLDirective(directiveConfig);\r\n    }\r\n    function rewireArgs(args) {\r\n        var rewiredArgs = {};\r\n        Object.keys(args).forEach(function (argName) {\r\n            var arg = args[argName];\r\n            var rewiredArgType = rewireType(arg.type);\r\n            if (rewiredArgType != null) {\r\n                arg.type = rewiredArgType;\r\n                rewiredArgs[argName] = arg;\r\n            }\r\n        });\r\n        return rewiredArgs;\r\n    }\r\n    function rewireNamedType(type) {\r\n        if (isObjectType(type)) {\r\n            var config_1 = toConfig(type);\r\n            var newConfig = __assign(__assign({}, config_1), { fields: function () { return rewireFields(config_1.fields); }, interfaces: function () { return rewireNamedTypes(config_1.interfaces); } });\r\n            return new GraphQLObjectType(newConfig);\r\n        }\r\n        else if (isInterfaceType(type)) {\r\n            var config_2 = toConfig(type);\r\n            var newConfig = __assign(__assign({}, config_2), { fields: function () { return rewireFields(config_2.fields); } });\r\n            if (graphqlVersion() >= 15) {\r\n                newConfig.interfaces = function () { return rewireNamedTypes(config_2.interfaces); };\r\n            }\r\n            return new GraphQLInterfaceType(newConfig);\r\n        }\r\n        else if (isUnionType(type)) {\r\n            var config_3 = toConfig(type);\r\n            var newConfig = __assign(__assign({}, config_3), { types: function () { return rewireNamedTypes(config_3.types); } });\r\n            return new GraphQLUnionType(newConfig);\r\n        }\r\n        else if (isInputObjectType(type)) {\r\n            var config_4 = toConfig(type);\r\n            var newConfig = __assign(__assign({}, config_4), { fields: function () { return rewireInputFields(config_4.fields); } });\r\n            return new GraphQLInputObjectType(newConfig);\r\n        }\r\n        else if (isEnumType(type)) {\r\n            var enumConfig = toConfig(type);\r\n            return new GraphQLEnumType(enumConfig);\r\n        }\r\n        else if (isScalarType(type)) {\r\n            if (isSpecifiedScalarType(type)) {\r\n                return type;\r\n            }\r\n            var scalarConfig = toConfig(type);\r\n            return new GraphQLScalarType(scalarConfig);\r\n        }\r\n        throw new Error(\"Unexpected schema type: \" + type);\r\n    }\r\n    function rewireFields(fields) {\r\n        var rewiredFields = {};\r\n        Object.keys(fields).forEach(function (fieldName) {\r\n            var field = fields[fieldName];\r\n            var rewiredFieldType = rewireType(field.type);\r\n            if (rewiredFieldType != null) {\r\n                field.type = rewiredFieldType;\r\n                field.args = rewireArgs(field.args);\r\n                rewiredFields[fieldName] = field;\r\n            }\r\n        });\r\n        return rewiredFields;\r\n    }\r\n    function rewireInputFields(fields) {\r\n        var rewiredFields = {};\r\n        Object.keys(fields).forEach(function (fieldName) {\r\n            var field = fields[fieldName];\r\n            var rewiredFieldType = rewireType(field.type);\r\n            if (rewiredFieldType != null) {\r\n                field.type = rewiredFieldType;\r\n                rewiredFields[fieldName] = field;\r\n            }\r\n        });\r\n        return rewiredFields;\r\n    }\r\n    function rewireNamedTypes(namedTypes) {\r\n        var rewiredTypes = [];\r\n        namedTypes.forEach(function (namedType) {\r\n            var rewiredType = rewireType(namedType);\r\n            if (rewiredType != null) {\r\n                rewiredTypes.push(rewiredType);\r\n            }\r\n        });\r\n        return rewiredTypes;\r\n    }\r\n    function rewireType(type) {\r\n        if (isListType(type)) {\r\n            var rewiredType = rewireType(type.ofType);\r\n            return rewiredType != null ? new GraphQLList(rewiredType) : null;\r\n        }\r\n        else if (isNonNullType(type)) {\r\n            var rewiredType = rewireType(type.ofType);\r\n            return rewiredType != null\r\n                ? new GraphQLNonNull(rewiredType)\r\n                : null;\r\n        }\r\n        else if (isNamedType(type)) {\r\n            var originalType = originalTypeMap[type.name];\r\n            return originalType != null ? newTypeMap[originalType.name] : null;\r\n        }\r\n        return null;\r\n    }\r\n}\r\nfunction pruneTypes(typeMap, directives) {\r\n    var newTypeMap = {};\r\n    var implementedInterfaces = {};\r\n    Object.keys(typeMap).forEach(function (typeName) {\r\n        var namedType = typeMap[typeName];\r\n        if (isObjectType(namedType) ||\r\n            (graphqlVersion() >= 15 && isInterfaceType(namedType))) {\r\n            namedType.getInterfaces().forEach(function (iface) {\r\n                implementedInterfaces[iface.name] = true;\r\n            });\r\n        }\r\n    });\r\n    var prunedTypeMap = false;\r\n    var typeNames = Object.keys(typeMap);\r\n    for (var i = 0; i < typeNames.length; i++) {\r\n        var typeName = typeNames[i];\r\n        var type = typeMap[typeName];\r\n        if (isObjectType(type) || isInputObjectType(type)) {\r\n            // prune types with no fields\r\n            if (Object.keys(type.getFields()).length) {\r\n                newTypeMap[typeName] = type;\r\n            }\r\n            else {\r\n                prunedTypeMap = true;\r\n            }\r\n        }\r\n        else if (isUnionType(type)) {\r\n            // prune unions without underlying types\r\n            if (type.getTypes().length) {\r\n                newTypeMap[typeName] = type;\r\n            }\r\n            else {\r\n                prunedTypeMap = true;\r\n            }\r\n        }\r\n        else if (isInterfaceType(type)) {\r\n            // prune interfaces without fields or without implementations\r\n            if (Object.keys(type.getFields()).length &&\r\n                implementedInterfaces[type.name]) {\r\n                newTypeMap[typeName] = type;\r\n            }\r\n            else {\r\n                prunedTypeMap = true;\r\n            }\r\n        }\r\n        else {\r\n            newTypeMap[typeName] = type;\r\n        }\r\n    }\r\n    // every prune requires another round of healing\r\n    return prunedTypeMap\r\n        ? rewireTypes(newTypeMap, directives)\r\n        : { typeMap: typeMap, directives: directives };\r\n}\n\nfunction filterSchema(_a) {\r\n    var _b;\r\n    var schema = _a.schema, _c = _a.rootFieldFilter, rootFieldFilter = _c === void 0 ? function () { return true; } : _c, _d = _a.typeFilter, typeFilter = _d === void 0 ? function () { return true; } : _d, _e = _a.fieldFilter, fieldFilter = _e === void 0 ? function () { return true; } : _e;\r\n    var filteredSchema = mapSchema(schema, (_b = {},\r\n        _b[MapperKind.QUERY] = function (type) {\r\n            return filterRootFields(type, 'Query', rootFieldFilter);\r\n        },\r\n        _b[MapperKind.MUTATION] = function (type) {\r\n            return filterRootFields(type, 'Mutation', rootFieldFilter);\r\n        },\r\n        _b[MapperKind.SUBSCRIPTION] = function (type) {\r\n            return filterRootFields(type, 'Subscription', rootFieldFilter);\r\n        },\r\n        _b[MapperKind.OBJECT_TYPE] = function (type) {\r\n            return typeFilter(type.name, type)\r\n                ? filterObjectFields(type, fieldFilter)\r\n                : null;\r\n        },\r\n        _b[MapperKind.INTERFACE_TYPE] = function (type) {\r\n            return typeFilter(type.name, type) ? undefined : null;\r\n        },\r\n        _b[MapperKind.UNION_TYPE] = function (type) {\r\n            return typeFilter(type.name, type) ? undefined : null;\r\n        },\r\n        _b[MapperKind.INPUT_OBJECT_TYPE] = function (type) {\r\n            return typeFilter(type.name, type) ? undefined : null;\r\n        },\r\n        _b[MapperKind.ENUM_TYPE] = function (type) {\r\n            return typeFilter(type.name, type) ? undefined : null;\r\n        },\r\n        _b[MapperKind.SCALAR_TYPE] = function (type) {\r\n            return typeFilter(type.name, type) ? undefined : null;\r\n        },\r\n        _b));\r\n    filteredSchema.transforms = schema.transforms;\r\n    return filteredSchema;\r\n}\r\nfunction filterRootFields(type, operation, rootFieldFilter) {\r\n    var config = toConfig(type);\r\n    Object.keys(config.fields).forEach(function (fieldName) {\r\n        if (!rootFieldFilter(operation, fieldName, config.fields[fieldName])) {\r\n            delete config.fields[fieldName];\r\n        }\r\n    });\r\n    return new GraphQLObjectType(config);\r\n}\r\nfunction filterObjectFields(type, fieldFilter) {\r\n    var config = toConfig(type);\r\n    Object.keys(config.fields).forEach(function (fieldName) {\r\n        if (!fieldFilter(type.name, fieldName, config.fields[fieldName])) {\r\n            delete config.fields[fieldName];\r\n        }\r\n    });\r\n    return new GraphQLObjectType(config);\r\n}\n\nfunction cloneDirective(directive) {\r\n    return new GraphQLDirective(toConfig(directive));\r\n}\r\nfunction cloneType(type) {\r\n    if (isObjectType(type)) {\r\n        var config = toConfig(type);\r\n        return new GraphQLObjectType(__assign(__assign({}, config), { interfaces: typeof config.interfaces === 'function'\r\n                ? config.interfaces\r\n                : config.interfaces.slice() }));\r\n    }\r\n    else if (isInterfaceType(type)) {\r\n        var config = toConfig(type);\r\n        var newConfig = __assign(__assign({}, config), { interfaces: graphqlVersion() >= 15\r\n                ? typeof config.interfaces === 'function'\r\n                    ? config.interfaces\r\n                    : config.interfaces.slice()\r\n                : undefined });\r\n        return new GraphQLInterfaceType(newConfig);\r\n    }\r\n    else if (isUnionType(type)) {\r\n        var config = toConfig(type);\r\n        return new GraphQLUnionType(__assign(__assign({}, config), { types: config.types.slice() }));\r\n    }\r\n    else if (isInputObjectType(type)) {\r\n        return new GraphQLInputObjectType(toConfig(type));\r\n    }\r\n    else if (isEnumType(type)) {\r\n        return new GraphQLEnumType(toConfig(type));\r\n    }\r\n    else if (isScalarType(type)) {\r\n        return isSpecifiedScalarType(type)\r\n            ? type\r\n            : new GraphQLScalarType(toConfig(type));\r\n    }\r\n    throw new Error(\"Invalid type \" + type);\r\n}\r\nfunction cloneSchema(schema) {\r\n    return mapSchema(schema);\r\n}\n\n// polyfill for graphql prior to v13 which do not pass options to buildASTSchema\r\nfunction buildSchema(ast, buildSchemaOptions) {\r\n    return buildASTSchema(parse(ast), buildSchemaOptions);\r\n}\n\nfunction getResolversFromSchema(schema) {\r\n    var resolvers = Object.create({});\r\n    var typeMap = schema.getTypeMap();\r\n    Object.keys(typeMap).forEach(function (typeName) {\r\n        var type = typeMap[typeName];\r\n        if (isScalarType(type)) {\r\n            if (!isSpecifiedScalarType(type)) {\r\n                resolvers[typeName] = cloneType(type);\r\n            }\r\n        }\r\n        else if (isEnumType(type)) {\r\n            resolvers[typeName] = {};\r\n            var values = type.getValues();\r\n            values.forEach(function (value) {\r\n                resolvers[typeName][value.name] = value.value;\r\n            });\r\n        }\r\n        else if (isInterfaceType(type)) {\r\n            if (type.resolveType != null) {\r\n                resolvers[typeName] = {\r\n                    __resolveType: type.resolveType,\r\n                };\r\n            }\r\n        }\r\n        else if (isUnionType(type)) {\r\n            if (type.resolveType != null) {\r\n                resolvers[typeName] = {\r\n                    __resolveType: type.resolveType,\r\n                };\r\n            }\r\n        }\r\n        else if (isObjectType(type)) {\r\n            resolvers[typeName] = {};\r\n            if (type.isTypeOf != null) {\r\n                resolvers[typeName].__isTypeOf = type.isTypeOf;\r\n            }\r\n            var fields_1 = type.getFields();\r\n            Object.keys(fields_1).forEach(function (fieldName) {\r\n                var field = fields_1[fieldName];\r\n                resolvers[typeName][fieldName] = {\r\n                    resolve: field.resolve,\r\n                    subscribe: field.subscribe,\r\n                };\r\n            });\r\n        }\r\n    });\r\n    return resolvers;\r\n}\n\n// polyfill for graphql < v14.2 which does not support subscriptions\r\nfunction extendSchema(schema, extension, options) {\r\n    var subscriptionType = schema.getSubscriptionType();\r\n    if (subscriptionType == null) {\r\n        return extendSchema$1(schema, extension, options);\r\n    }\r\n    var resolvers = getResolversFromSchema(schema);\r\n    var subscriptionTypeName = subscriptionType.name;\r\n    var subscriptionResolvers = resolvers[subscriptionTypeName];\r\n    var extendedSchema = extendSchema$1(schema, extension, options);\r\n    var fields = extendedSchema.getSubscriptionType().getFields();\r\n    Object.keys(subscriptionResolvers).forEach(function (fieldName) {\r\n        fields[fieldName].subscribe = subscriptionResolvers[fieldName].subscribe;\r\n    });\r\n    return extendedSchema;\r\n}\n\n// A generic updater function for arrays or objects.\r\nfunction updateEachKey(arrayOrObject, \r\n// The callback can return nothing or undefined to leave the key untouched, null to remove\r\n// the key from the array or object, or a non-null V to replace the value.\r\nupdater) {\r\n    var deletedCount = 0;\r\n    Object.keys(arrayOrObject).forEach(function (key) {\r\n        var result = updater(arrayOrObject[key], key);\r\n        if (typeof result === 'undefined') {\r\n            return;\r\n        }\r\n        if (result === null) {\r\n            delete arrayOrObject[key];\r\n            deletedCount++;\r\n            return;\r\n        }\r\n        arrayOrObject[key] = result;\r\n    });\r\n    if (deletedCount > 0 && Array.isArray(arrayOrObject)) {\r\n        // Remove any holes from the array due to deleted elements.\r\n        arrayOrObject.splice(0).forEach(function (elem) {\r\n            arrayOrObject.push(elem);\r\n        });\r\n    }\r\n}\n\nfunction createNamedStub(name, type) {\r\n    var constructor;\r\n    if (type === 'object') {\r\n        constructor = GraphQLObjectType;\r\n    }\r\n    else if (type === 'interface') {\r\n        constructor = GraphQLInterfaceType;\r\n    }\r\n    else {\r\n        constructor = GraphQLInputObjectType;\r\n    }\r\n    return new constructor({\r\n        name: name,\r\n        fields: {\r\n            __fake: {\r\n                type: GraphQLString,\r\n            },\r\n        },\r\n    });\r\n}\r\nfunction createStub(node, type) {\r\n    switch (node.kind) {\r\n        case Kind.LIST_TYPE:\r\n            return new GraphQLList(createStub(node.type, type));\r\n        case Kind.NON_NULL_TYPE:\r\n            return new GraphQLNonNull(createStub(node.type, type));\r\n        default:\r\n            if (type === 'output') {\r\n                return createNamedStub(node.name.value, 'object');\r\n            }\r\n            return createNamedStub(node.name.value, 'input');\r\n    }\r\n}\r\nfunction isNamedStub(type) {\r\n    if (isObjectType(type) || isInterfaceType(type) || isInputObjectType(type)) {\r\n        var fields = type.getFields();\r\n        var fieldNames = Object.keys(fields);\r\n        return fieldNames.length === 1 && fields[fieldNames[0]].name === '__fake';\r\n    }\r\n    return false;\r\n}\r\nfunction getBuiltInForStub(type) {\r\n    switch (type.name) {\r\n        case GraphQLInt.name:\r\n            return GraphQLInt;\r\n        case GraphQLFloat.name:\r\n            return GraphQLFloat;\r\n        case GraphQLString.name:\r\n            return GraphQLString;\r\n        case GraphQLBoolean.name:\r\n            return GraphQLBoolean;\r\n        case GraphQLID.name:\r\n            return GraphQLID;\r\n        default:\r\n            return type;\r\n    }\r\n}\n\n// Update any references to named schema types that disagree with the named\r\n// types found in schema.getTypeMap().\r\nfunction healSchema(schema) {\r\n    var typeMap = schema.getTypeMap();\r\n    var directives = schema.getDirectives();\r\n    var queryType = schema.getQueryType();\r\n    var mutationType = schema.getMutationType();\r\n    var subscriptionType = schema.getSubscriptionType();\r\n    var newQueryTypeName = queryType != null\r\n        ? typeMap[queryType.name] != null\r\n            ? typeMap[queryType.name].name\r\n            : undefined\r\n        : undefined;\r\n    var newMutationTypeName = mutationType != null\r\n        ? typeMap[mutationType.name] != null\r\n            ? typeMap[mutationType.name].name\r\n            : undefined\r\n        : undefined;\r\n    var newSubscriptionTypeName = subscriptionType != null\r\n        ? typeMap[subscriptionType.name] != null\r\n            ? typeMap[subscriptionType.name].name\r\n            : undefined\r\n        : undefined;\r\n    healTypes(typeMap, directives);\r\n    var filteredTypeMap = {};\r\n    Object.keys(typeMap).forEach(function (typeName) {\r\n        if (!typeName.startsWith('__')) {\r\n            filteredTypeMap[typeName] = typeMap[typeName];\r\n        }\r\n    });\r\n    var healedSchema = new GraphQLSchema(__assign(__assign({}, toConfig(schema)), { query: newQueryTypeName ? filteredTypeMap[newQueryTypeName] : undefined, mutation: newMutationTypeName\r\n            ? filteredTypeMap[newMutationTypeName]\r\n            : undefined, subscription: newSubscriptionTypeName\r\n            ? filteredTypeMap[newSubscriptionTypeName]\r\n            : undefined, types: Object.keys(filteredTypeMap).map(function (typeName) { return filteredTypeMap[typeName]; }), directives: directives.slice() }));\r\n    // Reconstruct the schema to reinitialize private variables\r\n    // e.g. the stored implementation map and the proper root types.\r\n    Object.assign(schema, healedSchema);\r\n    return schema;\r\n}\r\nfunction healTypes(originalTypeMap, directives, config) {\r\n    if (config === void 0) { config = {\r\n        skipPruning: false,\r\n    }; }\r\n    var actualNamedTypeMap = Object.create(null);\r\n    // If any of the .name properties of the GraphQLNamedType objects in\r\n    // schema.getTypeMap() have changed, the keys of the type map need to\r\n    // be updated accordingly.\r\n    Object.entries(originalTypeMap).forEach(function (_a) {\r\n        var typeName = _a[0], namedType = _a[1];\r\n        if (namedType == null || typeName.startsWith('__')) {\r\n            return;\r\n        }\r\n        var actualName = namedType.name;\r\n        if (actualName.startsWith('__')) {\r\n            return;\r\n        }\r\n        if (actualName in actualNamedTypeMap) {\r\n            throw new Error(\"Duplicate schema type name \" + actualName);\r\n        }\r\n        actualNamedTypeMap[actualName] = namedType;\r\n        // Note: we are deliberately leaving namedType in the schema by its\r\n        // original name (which might be different from actualName), so that\r\n        // references by that name can be healed.\r\n    });\r\n    // Now add back every named type by its actual name.\r\n    Object.entries(actualNamedTypeMap).forEach(function (_a) {\r\n        var typeName = _a[0], namedType = _a[1];\r\n        originalTypeMap[typeName] = namedType;\r\n    });\r\n    // Directive declaration argument types can refer to named types.\r\n    directives.forEach(function (decl) {\r\n        updateEachKey(decl.args, function (arg) {\r\n            arg.type = healType(arg.type);\r\n            return arg.type === null ? null : arg;\r\n        });\r\n    });\r\n    Object.entries(originalTypeMap).forEach(function (_a) {\r\n        var typeName = _a[0], namedType = _a[1];\r\n        // Heal all named types, except for dangling references, kept only to redirect.\r\n        if (!typeName.startsWith('__') && typeName in actualNamedTypeMap) {\r\n            if (namedType != null) {\r\n                healNamedType(namedType);\r\n            }\r\n        }\r\n    });\r\n    updateEachKey(originalTypeMap, function (_namedType, typeName) {\r\n        // Dangling references to renamed types should remain in the schema\r\n        // during healing, but must be removed now, so that the following\r\n        // invariant holds for all names: schema.getType(name).name === name\r\n        if (!typeName.startsWith('__') && !(typeName in actualNamedTypeMap)) {\r\n            return null;\r\n        }\r\n    });\r\n    if (!config.skipPruning) {\r\n        pruneTypes$1(originalTypeMap, directives);\r\n    }\r\n    function healNamedType(type) {\r\n        if (isObjectType(type)) {\r\n            healFields(type);\r\n            healInterfaces(type);\r\n            return;\r\n        }\r\n        else if (isInterfaceType(type)) {\r\n            healFields(type);\r\n            if (graphqlVersion() >= 15) {\r\n                healInterfaces(type);\r\n            }\r\n            return;\r\n        }\r\n        else if (isUnionType(type)) {\r\n            healUnderlyingTypes(type);\r\n            return;\r\n        }\r\n        else if (isInputObjectType(type)) {\r\n            healInputFields(type);\r\n            return;\r\n        }\r\n        else if (isLeafType(type)) {\r\n            return;\r\n        }\r\n        throw new Error(\"Unexpected schema type: \" + type);\r\n    }\r\n    function healFields(type) {\r\n        updateEachKey(type.getFields(), function (field) {\r\n            updateEachKey(field.args, function (arg) {\r\n                arg.type = healType(arg.type);\r\n                return arg.type === null ? null : arg;\r\n            });\r\n            field.type = healType(field.type);\r\n            return field.type === null ? null : field;\r\n        });\r\n    }\r\n    function healInterfaces(type) {\r\n        updateEachKey(type.getInterfaces(), function (iface) {\r\n            var healedType = healType(iface);\r\n            return healedType;\r\n        });\r\n    }\r\n    function healInputFields(type) {\r\n        updateEachKey(type.getFields(), function (field) {\r\n            field.type = healType(field.type);\r\n            return field.type === null ? null : field;\r\n        });\r\n    }\r\n    function healUnderlyingTypes(type) {\r\n        updateEachKey(type.getTypes(), function (t) {\r\n            var healedType = healType(t);\r\n            return healedType;\r\n        });\r\n    }\r\n    function healType(type) {\r\n        // Unwrap the two known wrapper types\r\n        if (isListType(type)) {\r\n            var healedType = healType(type.ofType);\r\n            return healedType != null ? new GraphQLList(healedType) : null;\r\n        }\r\n        else if (isNonNullType(type)) {\r\n            var healedType = healType(type.ofType);\r\n            return healedType != null ? new GraphQLNonNull(healedType) : null;\r\n        }\r\n        else if (isNamedType(type)) {\r\n            // If a type annotation on a field or an argument or a union member is\r\n            // any `GraphQLNamedType` with a `name`, then it must end up identical\r\n            // to `schema.getType(name)`, since `schema.getTypeMap()` is the source\r\n            // of truth for all named schema types.\r\n            // Note that new types can still be simply added by adding a field, as\r\n            // the official type will be undefined, not null.\r\n            var officialType = originalTypeMap[type.name];\r\n            if (officialType === undefined) {\r\n                if (isNamedStub(type)) {\r\n                    officialType = getBuiltInForStub(type);\r\n                }\r\n                else {\r\n                    officialType = type;\r\n                }\r\n                originalTypeMap[type.name] = officialType;\r\n            }\r\n            return officialType;\r\n        }\r\n        return null;\r\n    }\r\n}\r\nfunction pruneTypes$1(typeMap, directives) {\r\n    var implementedInterfaces = {};\r\n    Object.values(typeMap).forEach(function (namedType) {\r\n        if (isObjectType(namedType) ||\r\n            (graphqlVersion() >= 15 && isInterfaceType(namedType))) {\r\n            namedType.getInterfaces().forEach(function (iface) {\r\n                implementedInterfaces[iface.name] = true;\r\n            });\r\n        }\r\n    });\r\n    var prunedTypeMap = false;\r\n    var typeNames = Object.keys(typeMap);\r\n    for (var i = 0; i < typeNames.length; i++) {\r\n        var typeName = typeNames[i];\r\n        var type = typeMap[typeName];\r\n        if (isObjectType(type) || isInputObjectType(type)) {\r\n            // prune types with no fields\r\n            if (!Object.keys(type.getFields()).length) {\r\n                typeMap[typeName] = null;\r\n                prunedTypeMap = true;\r\n            }\r\n        }\r\n        else if (isUnionType(type)) {\r\n            // prune unions without underlying types\r\n            if (!type.getTypes().length) {\r\n                typeMap[typeName] = null;\r\n                prunedTypeMap = true;\r\n            }\r\n        }\r\n        else if (isInterfaceType(type)) {\r\n            // prune interfaces without fields or without implementations\r\n            if (!Object.keys(type.getFields()).length ||\r\n                !(type.name in implementedInterfaces)) {\r\n                typeMap[typeName] = null;\r\n                prunedTypeMap = true;\r\n            }\r\n        }\r\n    }\r\n    // every prune requires another round of healing\r\n    if (prunedTypeMap) {\r\n        healTypes(typeMap, directives);\r\n    }\r\n}\n\n// Abstract base class of any visitor implementation, defining the available\r\n// visitor methods along with their parameter types, and providing a static\r\n// helper function for determining whether a subclass implements a given\r\n// visitor method, as opposed to inheriting one of the stubs defined here.\r\nvar SchemaVisitor = /** @class */ (function () {\r\n    function SchemaVisitor() {\r\n    }\r\n    // Determine if this SchemaVisitor (sub)class implements a particular\r\n    // visitor method.\r\n    SchemaVisitor.implementsVisitorMethod = function (methodName) {\r\n        if (!methodName.startsWith('visit')) {\r\n            return false;\r\n        }\r\n        var method = this.prototype[methodName];\r\n        if (typeof method !== 'function') {\r\n            return false;\r\n        }\r\n        if (this === SchemaVisitor) {\r\n            // The SchemaVisitor class implements every visitor method.\r\n            return true;\r\n        }\r\n        var stub = SchemaVisitor.prototype[methodName];\r\n        if (method === stub) {\r\n            // If this.prototype[methodName] was just inherited from SchemaVisitor,\r\n            // then this class does not really implement the method.\r\n            return false;\r\n        }\r\n        return true;\r\n    };\r\n    // Concrete subclasses of SchemaVisitor should override one or more of these\r\n    // visitor methods, in order to express their interest in handling certain\r\n    // schema types/locations. Each method may return null to remove the given\r\n    // type from the schema, a non-null value of the same type to update the\r\n    // type in the schema, or nothing to leave the type as it was.\r\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\r\n    SchemaVisitor.prototype.visitSchema = function (_schema) { };\r\n    SchemaVisitor.prototype.visitScalar = function (_scalar) { };\r\n    SchemaVisitor.prototype.visitObject = function (_object) { };\r\n    SchemaVisitor.prototype.visitFieldDefinition = function (_field, _details) { };\r\n    SchemaVisitor.prototype.visitArgumentDefinition = function (_argument, _details) { };\r\n    SchemaVisitor.prototype.visitInterface = function (_iface) { };\r\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\r\n    SchemaVisitor.prototype.visitUnion = function (_union) { };\r\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\r\n    SchemaVisitor.prototype.visitEnum = function (_type) { };\r\n    SchemaVisitor.prototype.visitEnumValue = function (_value, _details) { };\r\n    SchemaVisitor.prototype.visitInputObject = function (_object) { };\r\n    SchemaVisitor.prototype.visitInputFieldDefinition = function (_field, _details) { };\r\n    return SchemaVisitor;\r\n}());\n\n/**\r\n * Creates a keyed JS object from an array, given a function to produce the keys\r\n * for each value in the array.\r\n *\r\n * This provides a convenient lookup for the array items if the key function\r\n * produces unique results.\r\n *\r\n *     const phoneBook = [\r\n *       { name: 'Jon', num: '555-1234' },\r\n *       { name: 'Jenny', num: '867-5309' }\r\n *     ]\r\n *\r\n *     // { Jon: { name: 'Jon', num: '555-1234' },\r\n *     //   Jenny: { name: 'Jenny', num: '867-5309' } }\r\n *     const entriesByName = keyMap(\r\n *       phoneBook,\r\n *       entry => entry.name\r\n *     )\r\n *\r\n *     // { name: 'Jenny', num: '857-6309' }\r\n *     const jennyEntry = entriesByName['Jenny']\r\n *\r\n */\r\nfunction keyMap(list, keyFn) {\r\n    return list.reduce(function (map, item) {\r\n        map[keyFn(item)] = item;\r\n        return map;\r\n    }, Object.create(null));\r\n}\n\n// Similar to the graphql-js function of the same name, slightly simplified:\r\n// https://github.com/graphql/graphql-js/blob/master/src/utilities/valueFromASTUntyped.js\r\nfunction valueFromASTUntyped(valueNode) {\r\n    switch (valueNode.kind) {\r\n        case Kind.NULL:\r\n            return null;\r\n        case Kind.INT:\r\n            return parseInt(valueNode.value, 10);\r\n        case Kind.FLOAT:\r\n            return parseFloat(valueNode.value);\r\n        case Kind.STRING:\r\n        case Kind.ENUM:\r\n        case Kind.BOOLEAN:\r\n            return valueNode.value;\r\n        case Kind.LIST:\r\n            return valueNode.values.map(valueFromASTUntyped);\r\n        case Kind.OBJECT: {\r\n            return keyValMap(valueNode.fields, function (field) { return field.name.value; }, function (field) { return valueFromASTUntyped(field.value); });\r\n        }\r\n        /* istanbul ignore next */\r\n        default:\r\n            throw new Error('Unexpected value kind: ' + valueNode.kind);\r\n    }\r\n}\n\n// Generic function for visiting GraphQLSchema objects.\r\nfunction visitSchema(schema, \r\n// To accommodate as many different visitor patterns as possible, the\r\n// visitSchema function does not simply accept a single instance of the\r\n// SchemaVisitor class, but instead accepts a function that takes the\r\n// current VisitableSchemaType object and the name of a visitor method and\r\n// returns an array of SchemaVisitor instances that implement the visitor\r\n// method and have an interest in handling the given VisitableSchemaType\r\n// object. In the simplest case, this function can always return an array\r\n// containing a single visitor object, without even looking at the type or\r\n// methodName parameters. In other cases, this function might sometimes\r\n// return an empty array to indicate there are no visitors that should be\r\n// applied to the given VisitableSchemaType object. For an example of a\r\n// visitor pattern that benefits from this abstraction, see the\r\n// SchemaDirectiveVisitor class below.\r\nvisitorOrVisitorSelector) {\r\n    var visitorSelector = typeof visitorOrVisitorSelector === 'function'\r\n        ? visitorOrVisitorSelector\r\n        : function () { return visitorOrVisitorSelector; };\r\n    // Helper function that calls visitorSelector and applies the resulting\r\n    // visitors to the given type, with arguments [type, ...args].\r\n    function callMethod(methodName, type) {\r\n        var args = [];\r\n        for (var _i = 2; _i < arguments.length; _i++) {\r\n            args[_i - 2] = arguments[_i];\r\n        }\r\n        var visitors = visitorSelector(type, methodName);\r\n        visitors = Array.isArray(visitors) ? visitors : [visitors];\r\n        var finalType = type;\r\n        visitors.every(function (visitorOrVisitorDef) {\r\n            var newType;\r\n            if (visitorOrVisitorDef instanceof SchemaVisitor) {\r\n                newType = visitorOrVisitorDef[methodName].apply(visitorOrVisitorDef, __spreadArrays([finalType], args));\r\n            }\r\n            else if (isNamedType(finalType) &&\r\n                (methodName === 'visitScalar' ||\r\n                    methodName === 'visitEnum' ||\r\n                    methodName === 'visitObject' ||\r\n                    methodName === 'visitInputObject' ||\r\n                    methodName === 'visitUnion' ||\r\n                    methodName === 'visitInterface')) {\r\n                var specifiers = getTypeSpecifiers$1(finalType, schema);\r\n                var typeVisitor = getVisitor(visitorOrVisitorDef, specifiers);\r\n                newType =\r\n                    typeVisitor != null ? typeVisitor(finalType, schema) : undefined;\r\n            }\r\n            if (typeof newType === 'undefined') {\r\n                // Keep going without modifying type.\r\n                return true;\r\n            }\r\n            if (methodName === 'visitSchema' || isSchema(finalType)) {\r\n                throw new Error(\"Method \" + methodName + \" cannot replace schema with \" + newType);\r\n            }\r\n            if (newType === null) {\r\n                // Stop the loop and return null form callMethod, which will cause\r\n                // the type to be removed from the schema.\r\n                finalType = null;\r\n                return false;\r\n            }\r\n            // Update type to the new type returned by the visitor method, so that\r\n            // later directives will see the new type, and callMethod will return\r\n            // the final type.\r\n            finalType = newType;\r\n            return true;\r\n        });\r\n        // If there were no directives for this type object, or if all visitor\r\n        // methods returned nothing, type will be returned unmodified.\r\n        return finalType;\r\n    }\r\n    // Recursive helper function that calls any appropriate visitor methods for\r\n    // each object in the schema, then traverses the object's children (if any).\r\n    function visit(type) {\r\n        if (isSchema(type)) {\r\n            // Unlike the other types, the root GraphQLSchema object cannot be\r\n            // replaced by visitor methods, because that would make life very hard\r\n            // for SchemaVisitor subclasses that rely on the original schema object.\r\n            callMethod('visitSchema', type);\r\n            var typeMap_1 = type.getTypeMap();\r\n            Object.entries(typeMap_1).forEach(function (_a) {\r\n                var typeName = _a[0], namedType = _a[1];\r\n                if (!typeName.startsWith('__') && namedType != null) {\r\n                    // Call visit recursively to let it determine which concrete\r\n                    // subclass of GraphQLNamedType we found in the type map.\r\n                    // We do not use updateEachKey because we want to preserve\r\n                    // deleted types in the typeMap so that other types that reference\r\n                    // the deleted types can be healed.\r\n                    typeMap_1[typeName] = visit(namedType);\r\n                }\r\n            });\r\n            return type;\r\n        }\r\n        if (isObjectType(type)) {\r\n            // Note that callMethod('visitObject', type) may not actually call any\r\n            // methods, if there are no @directive annotations associated with this\r\n            // type, or if this SchemaDirectiveVisitor subclass does not override\r\n            // the visitObject method.\r\n            var newObject = callMethod('visitObject', type);\r\n            if (newObject != null) {\r\n                visitFields(newObject);\r\n            }\r\n            return newObject;\r\n        }\r\n        if (isInterfaceType(type)) {\r\n            var newInterface = callMethod('visitInterface', type);\r\n            if (newInterface != null) {\r\n                visitFields(newInterface);\r\n            }\r\n            return newInterface;\r\n        }\r\n        if (isInputObjectType(type)) {\r\n            var newInputObject_1 = callMethod('visitInputObject', type);\r\n            if (newInputObject_1 != null) {\r\n                var fieldMap = newInputObject_1.getFields();\r\n                updateEachKey(fieldMap, function (field) {\r\n                    return callMethod('visitInputFieldDefinition', field, {\r\n                        // Since we call a different method for input object fields, we\r\n                        // can't reuse the visitFields function here.\r\n                        objectType: newInputObject_1,\r\n                    });\r\n                });\r\n            }\r\n            return newInputObject_1;\r\n        }\r\n        if (isScalarType(type)) {\r\n            return callMethod('visitScalar', type);\r\n        }\r\n        if (isUnionType(type)) {\r\n            return callMethod('visitUnion', type);\r\n        }\r\n        if (isEnumType(type)) {\r\n            var newEnum_1 = callMethod('visitEnum', type);\r\n            if (newEnum_1 != null) {\r\n                updateEachKey(newEnum_1.getValues(), function (value) {\r\n                    return callMethod('visitEnumValue', value, {\r\n                        enumType: newEnum_1,\r\n                    });\r\n                });\r\n            }\r\n            return newEnum_1;\r\n        }\r\n        throw new Error(\"Unexpected schema type: \" + type);\r\n    }\r\n    function visitFields(type) {\r\n        updateEachKey(type.getFields(), function (field) {\r\n            // It would be nice if we could call visit(field) recursively here, but\r\n            // GraphQLField is merely a type, not a value that can be detected using\r\n            // an instanceof check, so we have to visit the fields in this lexical\r\n            // context, so that TypeScript can validate the call to\r\n            // visitFieldDefinition.\r\n            var newField = callMethod('visitFieldDefinition', field, {\r\n                // While any field visitor needs a reference to the field object, some\r\n                // field visitors may also need to know the enclosing (parent) type,\r\n                // perhaps to determine if the parent is a GraphQLObjectType or a\r\n                // GraphQLInterfaceType. To obtain a reference to the parent, a\r\n                // visitor method can have a second parameter, which will be an object\r\n                // with an .objectType property referring to the parent.\r\n                objectType: type,\r\n            });\r\n            if (newField.args != null) {\r\n                updateEachKey(newField.args, function (arg) {\r\n                    return callMethod('visitArgumentDefinition', arg, {\r\n                        // Like visitFieldDefinition, visitArgumentDefinition takes a\r\n                        // second parameter that provides additional context, namely the\r\n                        // parent .field and grandparent .objectType. Remember that the\r\n                        // current GraphQLSchema is always available via this.schema.\r\n                        field: newField,\r\n                        objectType: type,\r\n                    });\r\n                });\r\n            }\r\n            return newField;\r\n        });\r\n    }\r\n    visit(schema);\r\n    // Automatically update any references to named schema types replaced\r\n    // during the traversal, so implementors don't have to worry about that.\r\n    healSchema(schema);\r\n    // Return schema for convenience, even though schema parameter has all updated types.\r\n    return schema;\r\n}\r\nfunction getTypeSpecifiers$1(type, schema) {\r\n    var specifiers = [VisitSchemaKind.TYPE];\r\n    if (isObjectType(type)) {\r\n        specifiers.push(VisitSchemaKind.COMPOSITE_TYPE, VisitSchemaKind.OBJECT_TYPE);\r\n        var query = schema.getQueryType();\r\n        var mutation = schema.getMutationType();\r\n        var subscription = schema.getSubscriptionType();\r\n        if (type === query) {\r\n            specifiers.push(VisitSchemaKind.ROOT_OBJECT, VisitSchemaKind.QUERY);\r\n        }\r\n        else if (type === mutation) {\r\n            specifiers.push(VisitSchemaKind.ROOT_OBJECT, VisitSchemaKind.MUTATION);\r\n        }\r\n        else if (type === subscription) {\r\n            specifiers.push(VisitSchemaKind.ROOT_OBJECT, VisitSchemaKind.SUBSCRIPTION);\r\n        }\r\n    }\r\n    else if (isInputType(type)) {\r\n        specifiers.push(VisitSchemaKind.INPUT_OBJECT_TYPE);\r\n    }\r\n    else if (isInterfaceType(type)) {\r\n        specifiers.push(VisitSchemaKind.COMPOSITE_TYPE, VisitSchemaKind.ABSTRACT_TYPE, VisitSchemaKind.INTERFACE_TYPE);\r\n    }\r\n    else if (isUnionType(type)) {\r\n        specifiers.push(VisitSchemaKind.COMPOSITE_TYPE, VisitSchemaKind.ABSTRACT_TYPE, VisitSchemaKind.UNION_TYPE);\r\n    }\r\n    else if (isEnumType(type)) {\r\n        specifiers.push(VisitSchemaKind.ENUM_TYPE);\r\n    }\r\n    else if (isScalarType(type)) {\r\n        specifiers.push(VisitSchemaKind.SCALAR_TYPE);\r\n    }\r\n    return specifiers;\r\n}\r\nfunction getVisitor(visitorDef, specifiers) {\r\n    var typeVisitor;\r\n    var stack = __spreadArrays(specifiers);\r\n    while (!typeVisitor && stack.length > 0) {\r\n        var next = stack.pop();\r\n        typeVisitor = visitorDef[next];\r\n    }\r\n    return typeVisitor != null ? typeVisitor : null;\r\n}\n\nvar MAX_ARRAY_LENGTH = 10;\r\nvar MAX_RECURSIVE_DEPTH = 2;\r\n/**\r\n * Used to print values in error messages.\r\n */\r\nfunction inspect(value) {\r\n    return formatValue(value, []);\r\n}\r\nfunction formatValue(value, seenValues) {\r\n    switch (typeof value) {\r\n        case 'string':\r\n            return JSON.stringify(value);\r\n        case 'function':\r\n            return value.name\r\n                ? \"[function \" + value.name + \"]\"\r\n                : '[function]';\r\n        case 'object':\r\n            if (value === null) {\r\n                return 'null';\r\n            }\r\n            return formatObjectValue(value, seenValues);\r\n        default:\r\n            return String(value);\r\n    }\r\n}\r\nfunction formatObjectValue(value, previouslySeenValues) {\r\n    if (previouslySeenValues.indexOf(value) !== -1) {\r\n        return '[Circular]';\r\n    }\r\n    var seenValues = __spreadArrays(previouslySeenValues, [value]);\r\n    var customInspectFn = getCustomFn(value);\r\n    if (customInspectFn !== undefined) {\r\n        var customValue = customInspectFn.call(value);\r\n        // check for infinite recursion\r\n        if (customValue !== value) {\r\n            return typeof customValue === 'string'\r\n                ? customValue\r\n                : formatValue(customValue, seenValues);\r\n        }\r\n    }\r\n    else if (Array.isArray(value)) {\r\n        return formatArray(value, seenValues);\r\n    }\r\n    return formatObject(value, seenValues);\r\n}\r\nfunction formatObject(object, seenValues) {\r\n    var keys = Object.keys(object);\r\n    if (keys.length === 0) {\r\n        return '{}';\r\n    }\r\n    if (seenValues.length > MAX_RECURSIVE_DEPTH) {\r\n        return '[' + getObjectTag(object) + ']';\r\n    }\r\n    var properties = keys.map(function (key) {\r\n        var value = formatValue(object[key], seenValues);\r\n        return key + ': ' + value;\r\n    });\r\n    return '{ ' + properties.join(', ') + ' }';\r\n}\r\nfunction formatArray(array, seenValues) {\r\n    if (array.length === 0) {\r\n        return '[]';\r\n    }\r\n    if (seenValues.length > MAX_RECURSIVE_DEPTH) {\r\n        return '[Array]';\r\n    }\r\n    var len = Math.min(MAX_ARRAY_LENGTH, array.length);\r\n    var remaining = array.length - len;\r\n    var items = [];\r\n    for (var i = 0; i < len; ++i) {\r\n        items.push(formatValue(array[i], seenValues));\r\n    }\r\n    if (remaining === 1) {\r\n        items.push('... 1 more item');\r\n    }\r\n    else if (remaining > 1) {\r\n        items.push(\"... \" + remaining.toString(10) + \" more items\");\r\n    }\r\n    return '[' + items.join(', ') + ']';\r\n}\r\nfunction getCustomFn(obj) {\r\n    if (typeof obj.inspect === 'function') {\r\n        return obj.inspect;\r\n    }\r\n}\r\nfunction getObjectTag(obj) {\r\n    var tag = Object.prototype.toString\r\n        .call(obj)\r\n        .replace(/^\\[object /, '')\r\n        .replace(/]$/, '');\r\n    if (tag === 'Object' && typeof obj.constructor === 'function') {\r\n        var name_1 = obj.constructor.name;\r\n        if (typeof name_1 === 'string' && name_1 !== '') {\r\n            return name_1;\r\n        }\r\n    }\r\n    return tag;\r\n}\n\n/**\r\n * Prepares an object map of argument values given a list of argument\r\n * definitions and list of argument AST nodes.\r\n *\r\n * Note: The returned value is a plain Object with a prototype, since it is\r\n * exposed to user code. Care should be taken to not pull values from the\r\n * Object prototype.\r\n */\r\nfunction getArgumentValues(def, node, variableValues) {\r\n    if (variableValues === void 0) { variableValues = {}; }\r\n    var _a;\r\n    var variableMap = toObjMap(variableValues);\r\n    var coercedValues = {};\r\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\r\n    var argumentNodes = (_a = node.arguments) !== null && _a !== void 0 ? _a : [];\r\n    var argNodeMap = keyMap(argumentNodes, function (arg) { return arg.name.value; });\r\n    for (var _i = 0, _b = def.args; _i < _b.length; _i++) {\r\n        var argDef = _b[_i];\r\n        var name_1 = argDef.name;\r\n        var argType = argDef.type;\r\n        var argumentNode = argNodeMap[name_1];\r\n        if (!argumentNode) {\r\n            if (argDef.defaultValue !== undefined) {\r\n                coercedValues[name_1] = argDef.defaultValue;\r\n            }\r\n            else if (isNonNullType(argType)) {\r\n                throw new GraphQLError(\"Argument \\\"\" + name_1 + \"\\\" of required type \\\"\" + inspect(argType) + \"\\\" \" +\r\n                    'was not provided.', node);\r\n            }\r\n            continue;\r\n        }\r\n        var valueNode = argumentNode.value;\r\n        var isNull = valueNode.kind === Kind.NULL;\r\n        if (valueNode.kind === Kind.VARIABLE) {\r\n            var variableName = valueNode.name.value;\r\n            if (variableValues == null || !(variableName in variableMap)) {\r\n                if (argDef.defaultValue !== undefined) {\r\n                    coercedValues[name_1] = argDef.defaultValue;\r\n                }\r\n                else if (isNonNullType(argType)) {\r\n                    throw new GraphQLError(\"Argument \\\"\" + name_1 + \"\\\" of required type \\\"\" + inspect(argType) + \"\\\" \" +\r\n                        (\"was provided the variable \\\"$\" + variableName + \"\\\" which was not provided a runtime value.\"), valueNode);\r\n                }\r\n                continue;\r\n            }\r\n            isNull = variableValues[variableName] == null;\r\n        }\r\n        if (isNull && isNonNullType(argType)) {\r\n            throw new GraphQLError(\"Argument \\\"\" + name_1 + \"\\\" of non-null type \\\"\" + inspect(argType) + \"\\\" \" +\r\n                'must not be null.', valueNode);\r\n        }\r\n        var coercedValue = valueFromAST(valueNode, argType, variableValues);\r\n        if (coercedValue === undefined) {\r\n            // Note: ValuesOfCorrectTypeRule validation should catch this before\r\n            // execution. This is a runtime check to ensure execution does not\r\n            // continue with an invalid argument value.\r\n            throw new GraphQLError(\"Argument \\\"\" + name_1 + \"\\\" has invalid value \" + print(valueNode) + \".\", valueNode);\r\n        }\r\n        coercedValues[name_1] = coercedValue;\r\n    }\r\n    return coercedValues;\r\n}\n\n// This class represents a reusable implementation of a @directive that may\r\n// appear in a GraphQL schema written in Schema Definition Language.\r\n//\r\n// By overriding one or more visit{Object,Union,...} methods, a subclass\r\n// registers interest in certain schema types, such as GraphQLObjectType,\r\n// GraphQLUnionType, etc. When SchemaDirectiveVisitor.visitSchemaDirectives is\r\n// called with a GraphQLSchema object and a map of visitor subclasses, the\r\n// overidden methods of those subclasses allow the visitors to obtain\r\n// references to any type objects that have @directives attached to them,\r\n// enabling visitors to inspect or modify the schema as appropriate.\r\n//\r\n// For example, if a directive called @rest(url: \"...\") appears after a field\r\n// definition, a SchemaDirectiveVisitor subclass could provide meaning to that\r\n// directive by overriding the visitFieldDefinition method (which receives a\r\n// GraphQLField parameter), and then the body of that visitor method could\r\n// manipulate the field's resolver function to fetch data from a REST endpoint\r\n// described by the url argument passed to the @rest directive:\r\n//\r\n//   const typeDefs = `\r\n//   type Query {\r\n//     people: [Person] @rest(url: \"/api/v1/people\")\r\n//   }`;\r\n//\r\n//   const schema = makeExecutableSchema({ typeDefs });\r\n//\r\n//   SchemaDirectiveVisitor.visitSchemaDirectives(schema, {\r\n//     rest: class extends SchemaDirectiveVisitor {\r\n//       public visitFieldDefinition(field: GraphQLField<any, any>) {\r\n//         const { url } = this.args;\r\n//         field.resolve = () => fetch(url);\r\n//       }\r\n//     }\r\n//   });\r\n//\r\n// The subclass in this example is defined as an anonymous class expression,\r\n// for brevity. A truly reusable SchemaDirectiveVisitor would most likely be\r\n// defined in a library using a named class declaration, and then exported for\r\n// consumption by other modules and packages.\r\n//\r\n// See below for a complete list of overridable visitor methods, their\r\n// parameter types, and more details about the properties exposed by instances\r\n// of the SchemaDirectiveVisitor class.\r\nvar SchemaDirectiveVisitor = /** @class */ (function (_super) {\r\n    __extends(SchemaDirectiveVisitor, _super);\r\n    // Mark the constructor protected to enforce passing SchemaDirectiveVisitor\r\n    // subclasses (not instances) to visitSchemaDirectives.\r\n    function SchemaDirectiveVisitor(config) {\r\n        var _this = _super.call(this) || this;\r\n        _this.name = config.name;\r\n        _this.args = config.args;\r\n        _this.visitedType = config.visitedType;\r\n        _this.schema = config.schema;\r\n        _this.context = config.context;\r\n        return _this;\r\n    }\r\n    // Override this method to return a custom GraphQLDirective (or modify one\r\n    // already present in the schema) to enforce argument types, provide default\r\n    // argument values, or specify schema locations where this @directive may\r\n    // appear. By default, any declaration found in the schema will be returned.\r\n    SchemaDirectiveVisitor.getDirectiveDeclaration = function (directiveName, schema) {\r\n        return schema.getDirective(directiveName);\r\n    };\r\n    // Call SchemaDirectiveVisitor.visitSchemaDirectives to visit every\r\n    // @directive in the schema and create an appropriate SchemaDirectiveVisitor\r\n    // instance to visit the object decorated by the @directive.\r\n    SchemaDirectiveVisitor.visitSchemaDirectives = function (schema, \r\n    // The keys of this object correspond to directive names as they appear\r\n    // in the schema, and the values should be subclasses (not instances!)\r\n    // of the SchemaDirectiveVisitor class. This distinction is important\r\n    // because a new SchemaDirectiveVisitor instance will be created each\r\n    // time a matching directive is found in the schema AST, with arguments\r\n    // and other metadata specific to that occurrence. To help prevent the\r\n    // mistake of passing instances, the SchemaDirectiveVisitor constructor\r\n    // method is marked as protected.\r\n    directiveVisitors, \r\n    // Optional context object that will be available to all visitor instances\r\n    // via this.context. Defaults to an empty null-prototype object.\r\n    context) {\r\n        if (context === void 0) { context = Object.create(null); }\r\n        // If the schema declares any directives for public consumption, record\r\n        // them here so that we can properly coerce arguments when/if we encounter\r\n        // an occurrence of the directive while walking the schema below.\r\n        var declaredDirectives = this.getDeclaredDirectives(schema, directiveVisitors);\r\n        // Map from directive names to lists of SchemaDirectiveVisitor instances\r\n        // created while visiting the schema.\r\n        var createdVisitors = keyValMap(Object.keys(directiveVisitors), function (item) { return item; }, function () { return []; });\r\n        var directiveVisitorMap = toObjMap(directiveVisitors);\r\n        function visitorSelector(type, methodName) {\r\n            var directiveNodes = type.astNode != null ? type.astNode.directives : [];\r\n            var extensionASTNodes = type.extensionASTNodes;\r\n            if (extensionASTNodes != null) {\r\n                extensionASTNodes.forEach(function (extensionASTNode) {\r\n                    directiveNodes = directiveNodes.concat(extensionASTNode.directives);\r\n                });\r\n            }\r\n            var visitors = [];\r\n            directiveNodes.forEach(function (directiveNode) {\r\n                var directiveName = directiveNode.name.value;\r\n                if (!(directiveName in directiveVisitorMap)) {\r\n                    return;\r\n                }\r\n                var visitorClass = directiveVisitorMap[directiveName];\r\n                // Avoid creating visitor objects if visitorClass does not override\r\n                // the visitor method named by methodName.\r\n                if (!visitorClass.implementsVisitorMethod(methodName)) {\r\n                    return;\r\n                }\r\n                var decl = declaredDirectives[directiveName];\r\n                var args;\r\n                if (decl != null) {\r\n                    // If this directive was explicitly declared, use the declared\r\n                    // argument types (and any default values) to check, coerce, and/or\r\n                    // supply default values for the given arguments.\r\n                    args = getArgumentValues(decl, directiveNode);\r\n                }\r\n                else {\r\n                    // If this directive was not explicitly declared, just convert the\r\n                    // argument nodes to their corresponding JavaScript values.\r\n                    args = Object.create(null);\r\n                    if (directiveNode.arguments != null) {\r\n                        directiveNode.arguments.forEach(function (arg) {\r\n                            args[arg.name.value] = valueFromASTUntyped(arg.value);\r\n                        });\r\n                    }\r\n                }\r\n                // As foretold in comments near the top of the visitSchemaDirectives\r\n                // method, this is where instances of the SchemaDirectiveVisitor class\r\n                // get created and assigned names. While subclasses could override the\r\n                // constructor method, the constructor is marked as protected, so\r\n                // these are the only arguments that will ever be passed.\r\n                visitors.push(new visitorClass({\r\n                    name: directiveName,\r\n                    args: args,\r\n                    visitedType: type,\r\n                    schema: schema,\r\n                    context: context,\r\n                }));\r\n            });\r\n            if (visitors.length > 0) {\r\n                visitors.forEach(function (visitor) {\r\n                    createdVisitors[visitor.name].push(visitor);\r\n                });\r\n            }\r\n            return visitors;\r\n        }\r\n        visitSchema(schema, visitorSelector);\r\n        return createdVisitors;\r\n    };\r\n    SchemaDirectiveVisitor.getDeclaredDirectives = function (schema, directiveVisitors) {\r\n        var directiveVisitorMap = toObjMap(directiveVisitors);\r\n        var declaredDirectives = keyMap(schema.getDirectives(), function (d) { return d.name; });\r\n        // If the visitor subclass overrides getDirectiveDeclaration, and it\r\n        // returns a non-null GraphQLDirective, use that instead of any directive\r\n        // declared in the schema itself. Reasoning: if a SchemaDirectiveVisitor\r\n        // goes to the trouble of implementing getDirectiveDeclaration, it should\r\n        // be able to rely on that implementation.\r\n        Object.entries(directiveVisitors).forEach(function (_a) {\r\n            var directiveName = _a[0], visitorClass = _a[1];\r\n            var decl = visitorClass.getDirectiveDeclaration(directiveName, schema);\r\n            if (decl != null) {\r\n                declaredDirectives[directiveName] = decl;\r\n            }\r\n        });\r\n        Object.entries(declaredDirectives).forEach(function (_a) {\r\n            var name = _a[0], decl = _a[1];\r\n            if (!(name in directiveVisitorMap)) {\r\n                // SchemaDirectiveVisitors.visitSchemaDirectives might be called\r\n                // multiple times with partial directiveVisitors maps, so it's not\r\n                // necessarily an error for directiveVisitors to be missing an\r\n                // implementation of a directive that was declared in the schema.\r\n                return;\r\n            }\r\n            var visitorClass = directiveVisitorMap[name];\r\n            decl.locations.forEach(function (loc) {\r\n                var visitorMethodName = directiveLocationToVisitorMethodName(loc);\r\n                if (SchemaVisitor.implementsVisitorMethod(visitorMethodName) &&\r\n                    !visitorClass.implementsVisitorMethod(visitorMethodName)) {\r\n                    // While visitor subclasses may implement extra visitor methods,\r\n                    // it's definitely a mistake if the GraphQLDirective declares itself\r\n                    // applicable to certain schema locations, and the visitor subclass\r\n                    // does not implement all the corresponding methods.\r\n                    throw new Error(\"SchemaDirectiveVisitor for @\" + name + \" must implement \" + visitorMethodName + \" method\");\r\n                }\r\n            });\r\n        });\r\n        return declaredDirectives;\r\n    };\r\n    return SchemaDirectiveVisitor;\r\n}(SchemaVisitor));\r\n// Convert a string like \"FIELD_DEFINITION\" to \"visitFieldDefinition\".\r\nfunction directiveLocationToVisitorMethodName(loc) {\r\n    return ('visit' +\r\n        loc.replace(/([^_]*)_?/g, function (_wholeMatch, part) {\r\n            return part.charAt(0).toUpperCase() + part.slice(1).toLowerCase();\r\n        }));\r\n}\n\nfunction forEachField(schema, fn) {\r\n    var typeMap = schema.getTypeMap();\r\n    Object.keys(typeMap).forEach(function (typeName) {\r\n        var type = typeMap[typeName];\r\n        // TODO: maybe have an option to include these?\r\n        if (!getNamedType(type).name.startsWith('__') && isObjectType(type)) {\r\n            var fields_1 = type.getFields();\r\n            Object.keys(fields_1).forEach(function (fieldName) {\r\n                var field = fields_1[fieldName];\r\n                fn(field, typeName, fieldName);\r\n            });\r\n        }\r\n    });\r\n}\n\nfunction forEachDefaultValue(schema, fn) {\r\n    var typeMap = schema.getTypeMap();\r\n    Object.keys(typeMap).forEach(function (typeName) {\r\n        var type = typeMap[typeName];\r\n        if (!getNamedType(type).name.startsWith('__')) {\r\n            if (isObjectType(type)) {\r\n                var fields_1 = type.getFields();\r\n                Object.keys(fields_1).forEach(function (fieldName) {\r\n                    var field = fields_1[fieldName];\r\n                    field.args.forEach(function (arg) {\r\n                        arg.defaultValue = fn(arg.type, arg.defaultValue);\r\n                    });\r\n                });\r\n            }\r\n            else if (isInputObjectType(type)) {\r\n                var fields_2 = type.getFields();\r\n                Object.keys(fields_2).forEach(function (fieldName) {\r\n                    var field = fields_2[fieldName];\r\n                    field.defaultValue = fn(field.type, field.defaultValue);\r\n                });\r\n            }\r\n        }\r\n    });\r\n}\n\nfunction applySchemaTransforms(originalSchema, transforms) {\r\n    return transforms.reduce(function (schema, transform) {\r\n        return transform.transformSchema != null\r\n            ? transform.transformSchema(cloneSchema(schema))\r\n            : schema;\r\n    }, originalSchema);\r\n}\r\nfunction applyRequestTransforms(originalRequest, transforms) {\r\n    return transforms.reduce(function (request, transform) {\r\n        return transform.transformRequest != null\r\n            ? transform.transformRequest(request)\r\n            : request;\r\n    }, originalRequest);\r\n}\r\nfunction applyResultTransforms(originalResult, transforms) {\r\n    return transforms.reduceRight(function (result, transform) {\r\n        return transform.transformResult != null\r\n            ? transform.transformResult(result)\r\n            : result;\r\n    }, originalResult);\r\n}\n\nfunction linkToFetcher(link) {\r\n    return function (fetcherOperation) {\r\n        return toPromise(execute(link, fetcherOperation));\r\n    };\r\n}\n\nfunction observableToAsyncIterable(observable) {\r\n    var _a;\r\n    var pullQueue = [];\r\n    var pushQueue = [];\r\n    var listening = true;\r\n    var pushValue = function (value) {\r\n        if (pullQueue.length !== 0) {\r\n            pullQueue.shift()({ value: value, done: false });\r\n        }\r\n        else {\r\n            pushQueue.push({ value: value });\r\n        }\r\n    };\r\n    var pushError = function (error) {\r\n        if (pullQueue.length !== 0) {\r\n            pullQueue.shift()({ value: { errors: [error] }, done: false });\r\n        }\r\n        else {\r\n            pushQueue.push({ value: { errors: [error] } });\r\n        }\r\n    };\r\n    var pullValue = function () {\r\n        return new Promise(function (resolve) {\r\n            if (pushQueue.length !== 0) {\r\n                var element = pushQueue.shift();\r\n                // either {value: {errors: [...]}} or {value: ...}\r\n                resolve(__assign(__assign({}, element), { done: false }));\r\n            }\r\n            else {\r\n                pullQueue.push(resolve);\r\n            }\r\n        });\r\n    };\r\n    var subscription = observable.subscribe({\r\n        next: function (value) {\r\n            pushValue(value);\r\n        },\r\n        error: function (err) {\r\n            pushError(err);\r\n        },\r\n    });\r\n    var emptyQueue = function () {\r\n        if (listening) {\r\n            listening = false;\r\n            subscription.unsubscribe();\r\n            pullQueue.forEach(function (resolve) { return resolve({ value: undefined, done: true }); });\r\n            pullQueue.length = 0;\r\n            pushQueue.length = 0;\r\n        }\r\n    };\r\n    return _a = {\r\n            next: function () {\r\n                return listening ? pullValue() : this.return();\r\n            },\r\n            return: function () {\r\n                emptyQueue();\r\n                return Promise.resolve({ value: undefined, done: true });\r\n            },\r\n            throw: function (error) {\r\n                emptyQueue();\r\n                return Promise.reject(error);\r\n            }\r\n        },\r\n        _a[$$asyncIterator] = function () {\r\n            return this;\r\n        },\r\n        _a;\r\n}\n\n/**\r\n * Given an AsyncIterable and a callback function, return an AsyncIterator\r\n * which produces values mapped via calling the callback function.\r\n */\r\nfunction mapAsyncIterator(iterator, callback, rejectCallback) {\r\n    var _a;\r\n    var $return;\r\n    var abruptClose;\r\n    if (typeof iterator.return === 'function') {\r\n        $return = iterator.return;\r\n        abruptClose = function (error) {\r\n            var rethrow = function () { return Promise.reject(error); };\r\n            return $return.call(iterator).then(rethrow, rethrow);\r\n        };\r\n    }\r\n    function mapResult(result) {\r\n        return result.done\r\n            ? result\r\n            : asyncMapValue(result.value, callback).then(iteratorResult, abruptClose);\r\n    }\r\n    var mapReject;\r\n    if (rejectCallback) {\r\n        // Capture rejectCallback to ensure it cannot be null.\r\n        var reject_1 = rejectCallback;\r\n        mapReject = function (error) {\r\n            return asyncMapValue(error, reject_1).then(iteratorResult, abruptClose);\r\n        };\r\n    }\r\n    return _a = {\r\n            next: function () {\r\n                return iterator.next().then(mapResult, mapReject);\r\n            },\r\n            return: function () {\r\n                return $return\r\n                    ? $return.call(iterator).then(mapResult, mapReject)\r\n                    : Promise.resolve({ value: undefined, done: true });\r\n            },\r\n            throw: function (error) {\r\n                if (typeof iterator.throw === 'function') {\r\n                    return iterator.throw(error).then(mapResult, mapReject);\r\n                }\r\n                return Promise.reject(error).catch(abruptClose);\r\n            }\r\n        },\r\n        _a[$$asyncIterator] = function () {\r\n            return this;\r\n        },\r\n        _a;\r\n}\r\nfunction asyncMapValue(value, callback) {\r\n    return new Promise(function (resolve) { return resolve(callback(value)); });\r\n}\r\nfunction iteratorResult(value) {\r\n    return { value: value, done: false };\r\n}\n\nfunction getDelegatingOperation(parentType, schema) {\r\n    if (parentType === schema.getMutationType()) {\r\n        return 'mutation';\r\n    }\r\n    else if (parentType === schema.getSubscriptionType()) {\r\n        return 'subscription';\r\n    }\r\n    return 'query';\r\n}\r\nfunction createRequestFromInfo(_a) {\r\n    var info = _a.info, _b = _a.operation, operation = _b === void 0 ? getDelegatingOperation(info.parentType, info.schema) : _b, _c = _a.fieldName, fieldName = _c === void 0 ? info.fieldName : _c, selectionSet = _a.selectionSet, fieldNodes = _a.fieldNodes;\r\n    return createRequest({\r\n        sourceSchema: info.schema,\r\n        sourceParentType: info.parentType,\r\n        sourceFieldName: info.fieldName,\r\n        fragments: info.fragments,\r\n        variableDefinitions: info.operation.variableDefinitions,\r\n        variableValues: info.variableValues,\r\n        targetOperation: operation,\r\n        targetFieldName: fieldName,\r\n        selectionSet: selectionSet,\r\n        fieldNodes: selectionSet != null\r\n            ? undefined\r\n            : fieldNodes != null\r\n                ? fieldNodes\r\n                : info.fieldNodes,\r\n    });\r\n}\r\nfunction createRequest(_a) {\r\n    var sourceSchema = _a.sourceSchema, sourceParentType = _a.sourceParentType, sourceFieldName = _a.sourceFieldName, fragments = _a.fragments, variableDefinitions = _a.variableDefinitions, variableValues = _a.variableValues, targetOperation = _a.targetOperation, targetFieldName = _a.targetFieldName, selectionSet = _a.selectionSet, fieldNodes = _a.fieldNodes;\r\n    var argumentNodes;\r\n    var newSelectionSet = selectionSet;\r\n    if (!selectionSet && fieldNodes != null) {\r\n        var selections = fieldNodes.reduce(function (acc, fieldNode) {\r\n            return fieldNode.selectionSet != null\r\n                ? acc.concat(fieldNode.selectionSet.selections)\r\n                : acc;\r\n        }, []);\r\n        newSelectionSet = selections.length\r\n            ? {\r\n                kind: Kind.SELECTION_SET,\r\n                selections: selections,\r\n            }\r\n            : undefined;\r\n        argumentNodes = fieldNodes[0].arguments;\r\n    }\r\n    else {\r\n        argumentNodes = [];\r\n    }\r\n    var newVariables = Object.create(null);\r\n    var variableDefinitionMap = Object.create(null);\r\n    variableDefinitions.forEach(function (def) {\r\n        var varName = def.variable.name.value;\r\n        variableDefinitionMap[varName] = def;\r\n        var varType = typeFromAST$1(sourceSchema, def.type);\r\n        newVariables[varName] = serializeInputValue(varType, variableValues[varName]);\r\n    });\r\n    var argumentNodeMap = keyMap(argumentNodes, function (arg) { return arg.name.value; });\r\n    updateArgumentsWithDefaults(sourceParentType, sourceFieldName, argumentNodeMap, variableDefinitionMap, newVariables);\r\n    var rootfieldNode = {\r\n        kind: Kind.FIELD,\r\n        alias: null,\r\n        arguments: Object.keys(argumentNodeMap).map(function (argName) { return argumentNodeMap[argName]; }),\r\n        selectionSet: newSelectionSet,\r\n        name: {\r\n            kind: Kind.NAME,\r\n            value: targetFieldName || fieldNodes[0].name.value,\r\n        },\r\n    };\r\n    var operationDefinition = {\r\n        kind: Kind.OPERATION_DEFINITION,\r\n        operation: targetOperation,\r\n        variableDefinitions: Object.keys(variableDefinitionMap).map(function (varName) { return variableDefinitionMap[varName]; }),\r\n        selectionSet: {\r\n            kind: Kind.SELECTION_SET,\r\n            selections: [rootfieldNode],\r\n        },\r\n    };\r\n    var fragmentDefinitions = Object.keys(fragments).map(function (fragmentName) { return fragments[fragmentName]; });\r\n    var document = {\r\n        kind: Kind.DOCUMENT,\r\n        definitions: __spreadArrays([operationDefinition], fragmentDefinitions),\r\n    };\r\n    return {\r\n        document: document,\r\n        variables: newVariables,\r\n    };\r\n}\r\nfunction updateArgumentsWithDefaults(sourceParentType, sourceFieldName, argumentNodeMap, variableDefinitionMap, variableValues) {\r\n    var sourceField = sourceParentType.getFields()[sourceFieldName];\r\n    sourceField.args.forEach(function (argument) {\r\n        var argName = argument.name;\r\n        var sourceArgType = argument.type;\r\n        if (argumentNodeMap[argName] === undefined) {\r\n            var defaultValue = argument.defaultValue;\r\n            if (defaultValue !== undefined) {\r\n                updateArgument(argName, sourceArgType, argumentNodeMap, variableDefinitionMap, variableValues, serializeInputValue(sourceArgType, defaultValue));\r\n            }\r\n        }\r\n    });\r\n}\n\nfunction delegateToSchema(options) {\r\n    if (isSchema(options)) {\r\n        throw new Error('Passing positional arguments to delegateToSchema is deprecated. ' +\r\n            'Please pass named parameters instead.');\r\n    }\r\n    var info = options.info, _a = options.operation, operation = _a === void 0 ? getDelegatingOperation(info.parentType, info.schema) : _a, _b = options.fieldName, fieldName = _b === void 0 ? info.fieldName : _b, _c = options.returnType, returnType = _c === void 0 ? info.returnType : _c, selectionSet = options.selectionSet, fieldNodes = options.fieldNodes;\r\n    var request = createRequestFromInfo({\r\n        info: info,\r\n        operation: operation,\r\n        fieldName: fieldName,\r\n        selectionSet: selectionSet,\r\n        fieldNodes: fieldNodes,\r\n    });\r\n    return delegateRequest(__assign(__assign({}, options), { request: request,\r\n        operation: operation,\r\n        fieldName: fieldName,\r\n        returnType: returnType }));\r\n}\r\nfunction buildDelegationTransforms(subschemaOrSubschemaConfig, info, context, targetSchema, fieldName, args, returnType, transforms, skipTypeMerging) {\r\n    var delegationTransforms = [\r\n        new CheckResultAndHandleErrors(info, fieldName, subschemaOrSubschemaConfig, context, returnType, skipTypeMerging),\r\n    ];\r\n    if (info.mergeInfo != null) {\r\n        delegationTransforms.push(new AddReplacementSelectionSets(info.schema, info.mergeInfo.replacementSelectionSets), new AddMergedTypeFragments(info.schema, info.mergeInfo.mergedTypes));\r\n    }\r\n    delegationTransforms = delegationTransforms.concat(transforms);\r\n    delegationTransforms.push(new ExpandAbstractTypes(info.schema, targetSchema));\r\n    if (info.mergeInfo != null) {\r\n        delegationTransforms.push(new AddReplacementFragments(targetSchema, info.mergeInfo.replacementFragments));\r\n    }\r\n    if (args != null) {\r\n        delegationTransforms.push(new AddArgumentsAsVariables(targetSchema, args));\r\n    }\r\n    delegationTransforms.push(new FilterToSchema(targetSchema), new AddTypenameToAbstract(targetSchema));\r\n    return delegationTransforms;\r\n}\r\nfunction delegateRequest(_a) {\r\n    var request = _a.request, subschemaOrSubschemaConfig = _a.schema, rootValue = _a.rootValue, info = _a.info, _b = _a.operation, operation = _b === void 0 ? getDelegatingOperation(info.parentType, info.schema) : _b, _c = _a.fieldName, fieldName = _c === void 0 ? info.fieldName : _c, args = _a.args, _d = _a.returnType, returnType = _d === void 0 ? info.returnType : _d, context = _a.context, _e = _a.transforms, transforms = _e === void 0 ? [] : _e, skipValidation = _a.skipValidation, skipTypeMerging = _a.skipTypeMerging;\r\n    var targetSchema;\r\n    var targetRootValue;\r\n    var requestTransforms = transforms.slice();\r\n    var subschemaConfig;\r\n    if (isSubschemaConfig(subschemaOrSubschemaConfig)) {\r\n        subschemaConfig = subschemaOrSubschemaConfig;\r\n        targetSchema = subschemaConfig.schema;\r\n        targetRootValue =\r\n            rootValue != null\r\n                ? rootValue\r\n                : subschemaConfig.rootValue != null\r\n                    ? subschemaConfig.rootValue\r\n                    : info.rootValue;\r\n        if (subschemaConfig.transforms != null) {\r\n            requestTransforms = requestTransforms.concat(subschemaConfig.transforms);\r\n        }\r\n    }\r\n    else {\r\n        targetSchema = subschemaOrSubschemaConfig;\r\n        targetRootValue = rootValue != null ? rootValue : info.rootValue;\r\n    }\r\n    var delegationTransforms = buildDelegationTransforms(subschemaOrSubschemaConfig, info, context, targetSchema, fieldName, args, returnType, requestTransforms.reverse(), skipTypeMerging);\r\n    var processedRequest = applyRequestTransforms(request, delegationTransforms);\r\n    if (!skipValidation) {\r\n        var errors = validate(targetSchema, processedRequest.document);\r\n        if (errors.length > 0) {\r\n            var combinedError = combineErrors(errors);\r\n            throw combinedError;\r\n        }\r\n    }\r\n    if (operation === 'query' || operation === 'mutation') {\r\n        var executor = createExecutor(targetSchema, targetRootValue, context, subschemaConfig);\r\n        var executionResult = executor({\r\n            document: processedRequest.document,\r\n            context: context,\r\n            variables: processedRequest.variables,\r\n        });\r\n        if (executionResult instanceof Promise) {\r\n            return executionResult.then(function (originalResult) {\r\n                return applyResultTransforms(originalResult, delegationTransforms);\r\n            });\r\n        }\r\n        return applyResultTransforms(executionResult, delegationTransforms);\r\n    }\r\n    var subscriber = createSubscriber(targetSchema, targetRootValue, context, subschemaConfig);\r\n    return subscriber({\r\n        document: processedRequest.document,\r\n        context: context,\r\n        variables: processedRequest.variables,\r\n    }).then(function (subscriptionResult) {\r\n        if (isAsyncIterable(subscriptionResult)) {\r\n            // \"subscribe\" to the subscription result and map the result through the transforms\r\n            return mapAsyncIterator(subscriptionResult, function (result) {\r\n                var _a;\r\n                var transformedResult = applyResultTransforms(result, delegationTransforms);\r\n                // wrap with fieldName to return for an additional round of resolutioon\r\n                // with payload as rootValue\r\n                return _a = {},\r\n                    _a[info.fieldName] = transformedResult,\r\n                    _a;\r\n            });\r\n        }\r\n        return applyResultTransforms(subscriptionResult, delegationTransforms);\r\n    });\r\n}\r\nfunction createExecutor(schema, rootValue, context, subschemaConfig) {\r\n    var fetcher;\r\n    var targetRootValue = rootValue;\r\n    if (subschemaConfig != null) {\r\n        if (subschemaConfig.dispatcher != null) {\r\n            var dynamicLinkOrFetcher = subschemaConfig.dispatcher(context);\r\n            fetcher =\r\n                typeof dynamicLinkOrFetcher === 'function'\r\n                    ? dynamicLinkOrFetcher\r\n                    : linkToFetcher(dynamicLinkOrFetcher);\r\n        }\r\n        else if (subschemaConfig.link != null) {\r\n            fetcher = linkToFetcher(subschemaConfig.link);\r\n        }\r\n        else if (subschemaConfig.fetcher != null) {\r\n            fetcher = subschemaConfig.fetcher;\r\n        }\r\n        if (!fetcher && !rootValue && subschemaConfig.rootValue != null) {\r\n            targetRootValue = subschemaConfig.rootValue;\r\n        }\r\n    }\r\n    if (fetcher != null) {\r\n        return function (_a) {\r\n            var document = _a.document, graphqlContext = _a.context, variables = _a.variables;\r\n            return fetcher({\r\n                query: document,\r\n                variables: variables,\r\n                context: { graphqlContext: graphqlContext },\r\n            });\r\n        };\r\n    }\r\n    return function (_a) {\r\n        var document = _a.document, graphqlContext = _a.context, variables = _a.variables;\r\n        return execute$1({\r\n            schema: schema,\r\n            document: document,\r\n            rootValue: targetRootValue,\r\n            contextValue: graphqlContext,\r\n            variableValues: variables,\r\n        });\r\n    };\r\n}\r\nfunction createSubscriber(schema, rootValue, context, subschemaConfig) {\r\n    var link;\r\n    var targetRootValue = rootValue;\r\n    if (subschemaConfig != null) {\r\n        if (subschemaConfig.dispatcher != null) {\r\n            link = subschemaConfig.dispatcher(context);\r\n        }\r\n        else if (subschemaConfig.link != null) {\r\n            link = subschemaConfig.link;\r\n        }\r\n        if (!link && !rootValue && subschemaConfig.rootValue != null) {\r\n            targetRootValue = subschemaConfig.rootValue;\r\n        }\r\n    }\r\n    if (link != null) {\r\n        return function (_a) {\r\n            var document = _a.document, graphqlContext = _a.context, variables = _a.variables;\r\n            var operation = {\r\n                query: document,\r\n                variables: variables,\r\n                context: { graphqlContext: graphqlContext },\r\n            };\r\n            var observable = execute(link, operation);\r\n            return Promise.resolve(observableToAsyncIterable(observable));\r\n        };\r\n    }\r\n    return function (_a) {\r\n        var document = _a.document, graphqlContext = _a.context, variables = _a.variables;\r\n        return subscribe({\r\n            schema: schema,\r\n            document: document,\r\n            rootValue: targetRootValue,\r\n            contextValue: graphqlContext,\r\n            variableValues: variables,\r\n        });\r\n    };\r\n}\n\n// @schemaDefinition: A GraphQL type schema in shorthand\r\n// @resolvers: Definitions for resolvers to be merged with schema\r\nvar SchemaError = /** @class */ (function (_super) {\r\n    __extends(SchemaError, _super);\r\n    function SchemaError(message) {\r\n        var _this = _super.call(this, message) || this;\r\n        _this.message = message;\r\n        Error.captureStackTrace(_this, _this.constructor);\r\n        return _this;\r\n    }\r\n    return SchemaError;\r\n}(Error));\n\n// If we have any union or interface types throw if no there is no resolveType or isTypeOf resolvers\r\nfunction checkForResolveTypeResolver(schema, requireResolversForResolveType) {\r\n    Object.keys(schema.getTypeMap())\r\n        .map(function (typeName) { return schema.getType(typeName); })\r\n        .forEach(function (type) {\r\n        if (!isAbstractType(type)) {\r\n            return;\r\n        }\r\n        if (!type.resolveType) {\r\n            if (!requireResolversForResolveType) {\r\n                return;\r\n            }\r\n            throw new SchemaError(\"Type \\\"\" + type.name + \"\\\" is missing a \\\"__resolveType\\\" resolver. Pass false into \" +\r\n                '\"resolverValidationOptions.requireResolversForResolveType\" to disable this error.');\r\n        }\r\n    });\r\n}\n\nfunction extendResolversFromInterfaces(schema, resolvers) {\r\n    var typeNames = Object.keys(__assign(__assign({}, schema.getTypeMap()), resolvers));\r\n    var extendedResolvers = {};\r\n    typeNames.forEach(function (typeName) {\r\n        var typeResolvers = resolvers[typeName];\r\n        var type = schema.getType(typeName);\r\n        if (isObjectType(type) ||\r\n            (graphqlVersion() >= 15 && isInterfaceType(type))) {\r\n            var interfaceResolvers = type\r\n                .getInterfaces()\r\n                .map(function (iFace) { return resolvers[iFace.name]; });\r\n            extendedResolvers[typeName] = Object.assign.apply(Object, __spreadArrays([{}], interfaceResolvers, [typeResolvers]));\r\n        }\r\n        else if (typeResolvers != null) {\r\n            extendedResolvers[typeName] = typeResolvers;\r\n        }\r\n    });\r\n    return extendedResolvers;\r\n}\n\nfunction addResolversToSchema(schemaOrOptions, legacyInputResolvers, legacyInputValidationOptions) {\r\n    var options = isSchema(schemaOrOptions)\r\n        ? {\r\n            schema: schemaOrOptions,\r\n            resolvers: legacyInputResolvers,\r\n            resolverValidationOptions: legacyInputValidationOptions,\r\n        }\r\n        : schemaOrOptions;\r\n    var schema = options.schema, inputResolvers = options.resolvers, defaultFieldResolver = options.defaultFieldResolver, _a = options.resolverValidationOptions, resolverValidationOptions = _a === void 0 ? {} : _a, _b = options.inheritResolversFromInterfaces, inheritResolversFromInterfaces = _b === void 0 ? false : _b;\r\n    var _c = resolverValidationOptions.allowResolversNotInSchema, allowResolversNotInSchema = _c === void 0 ? false : _c, requireResolversForResolveType = resolverValidationOptions.requireResolversForResolveType;\r\n    var resolvers = inheritResolversFromInterfaces\r\n        ? extendResolversFromInterfaces(schema, inputResolvers)\r\n        : inputResolvers;\r\n    var typeMap = schema.getTypeMap();\r\n    Object.keys(resolvers).forEach(function (typeName) {\r\n        var resolverValue = resolvers[typeName];\r\n        var resolverType = typeof resolverValue;\r\n        if (resolverType !== 'object' && resolverType !== 'function') {\r\n            throw new SchemaError(\"\\\"\" + typeName + \"\\\" defined in resolvers, but has invalid value \\\"\" + resolverValue + \"\\\". A resolver's value must be of type object or function.\");\r\n        }\r\n        var type = schema.getType(typeName);\r\n        if (!type && typeName !== '__schema') {\r\n            if (allowResolversNotInSchema) {\r\n                return;\r\n            }\r\n            throw new SchemaError(\"\\\"\" + typeName + \"\\\" defined in resolvers, but not in schema\");\r\n        }\r\n        if (isScalarType(type)) {\r\n            // Support -- without recommending -- overriding default scalar types\r\n            Object.keys(resolverValue).forEach(function (fieldName) {\r\n                if (fieldName.startsWith('__')) {\r\n                    type[fieldName.substring(2)] = resolverValue[fieldName];\r\n                }\r\n                else {\r\n                    type[fieldName] = resolverValue[fieldName];\r\n                }\r\n            });\r\n        }\r\n        else if (isEnumType(type)) {\r\n            // We've encountered an enum resolver that is being used to provide an\r\n            // internal enum value.\r\n            // Reference: https://www.apollographql.com/docs/graphql-tools/scalars.html#internal-values\r\n            Object.keys(resolverValue).forEach(function (fieldName) {\r\n                if (!type.getValue(fieldName)) {\r\n                    if (allowResolversNotInSchema) {\r\n                        return;\r\n                    }\r\n                    throw new SchemaError(typeName + \".\" + fieldName + \" was defined in resolvers, but enum is not in schema\");\r\n                }\r\n            });\r\n            var config = toConfig(type);\r\n            var values = type.getValues();\r\n            var newValues = keyValMap(values, function (value) { return value.name; }, function (value) {\r\n                var newValue = Object.keys(resolverValue).includes(value.name)\r\n                    ? resolverValue[value.name]\r\n                    : value.name;\r\n                return {\r\n                    value: newValue,\r\n                    deprecationReason: value.deprecationReason,\r\n                    description: value.description,\r\n                    astNode: value.astNode,\r\n                };\r\n            });\r\n            // healSchema called later to update all fields to new type\r\n            typeMap[typeName] = new GraphQLEnumType(__assign(__assign({}, config), { values: newValues }));\r\n        }\r\n        else if (isUnionType(type)) {\r\n            Object.keys(resolverValue).forEach(function (fieldName) {\r\n                if (fieldName.startsWith('__')) {\r\n                    // this is for isTypeOf and resolveType and all the other stuff.\r\n                    type[fieldName.substring(2)] = resolverValue[fieldName];\r\n                    return;\r\n                }\r\n                if (allowResolversNotInSchema) {\r\n                    return;\r\n                }\r\n                throw new SchemaError(typeName + \" was defined in resolvers, but it's not an object\");\r\n            });\r\n        }\r\n        else if (isObjectType(type) || isInterfaceType(type)) {\r\n            Object.keys(resolverValue).forEach(function (fieldName) {\r\n                if (fieldName.startsWith('__')) {\r\n                    // this is for isTypeOf and resolveType and all the other stuff.\r\n                    type[fieldName.substring(2)] = resolverValue[fieldName];\r\n                    return;\r\n                }\r\n                var fields = type.getFields();\r\n                var field = fields[fieldName];\r\n                if (field == null) {\r\n                    if (allowResolversNotInSchema) {\r\n                        return;\r\n                    }\r\n                    throw new SchemaError(typeName + \".\" + fieldName + \" defined in resolvers, but not in schema\");\r\n                }\r\n                var fieldResolve = resolverValue[fieldName];\r\n                if (typeof fieldResolve === 'function') {\r\n                    // for convenience. Allows shorter syntax in resolver definition file\r\n                    field.resolve = fieldResolve;\r\n                }\r\n                else {\r\n                    if (typeof fieldResolve !== 'object') {\r\n                        throw new SchemaError(\"Resolver \" + typeName + \".\" + fieldName + \" must be object or function\");\r\n                    }\r\n                    setFieldProperties(field, fieldResolve);\r\n                }\r\n            });\r\n        }\r\n    });\r\n    checkForResolveTypeResolver(schema, requireResolversForResolveType);\r\n    // serialize all default values prior to healing fields with new scalar/enum types.\r\n    forEachDefaultValue(schema, serializeInputValue);\r\n    // schema may have new scalar/enum types that require healing\r\n    healSchema(schema);\r\n    // reparse all default values with new parsing functions.\r\n    forEachDefaultValue(schema, parseInputValue);\r\n    if (defaultFieldResolver != null) {\r\n        forEachField(schema, function (field) {\r\n            if (!field.resolve) {\r\n                field.resolve = defaultFieldResolver;\r\n            }\r\n        });\r\n    }\r\n    return schema;\r\n}\r\nfunction setFieldProperties(field, propertiesObj) {\r\n    Object.keys(propertiesObj).forEach(function (propertyName) {\r\n        field[propertyName] = propertiesObj[propertyName];\r\n    });\r\n}\n\n// wraps all resolvers of query, mutation or subscription fields\r\n// with the provided function to simulate a root schema level resolver\r\nfunction addSchemaLevelResolver(schema, fn) {\r\n    // TODO test that schema is a schema, fn is a function\r\n    var rootTypes = [\r\n        schema.getQueryType(),\r\n        schema.getMutationType(),\r\n        schema.getSubscriptionType(),\r\n    ].filter(function (x) { return Boolean(x); });\r\n    rootTypes.forEach(function (type) {\r\n        if (type != null) {\r\n            // XXX this should run at most once per request to simulate a true root resolver\r\n            // for graphql-js this is an approximation that works with queries but not mutations\r\n            var rootResolveFn_1 = runAtMostOncePerRequest(fn);\r\n            var fields_1 = type.getFields();\r\n            Object.keys(fields_1).forEach(function (fieldName) {\r\n                // XXX if the type is a subscription, a same query AST will be ran multiple times so we\r\n                // deactivate here the runOnce if it's a subscription. This may not be optimal though...\r\n                if (type === schema.getSubscriptionType()) {\r\n                    fields_1[fieldName].resolve = wrapResolver(fields_1[fieldName].resolve, fn);\r\n                }\r\n                else {\r\n                    fields_1[fieldName].resolve = wrapResolver(fields_1[fieldName].resolve, rootResolveFn_1);\r\n                }\r\n            });\r\n        }\r\n    });\r\n}\r\n// XXX badly named function. this doesn't really wrap, it just chains resolvers...\r\nfunction wrapResolver(innerResolver, outerResolver) {\r\n    return function (obj, args, ctx, info) {\r\n        return Promise.resolve(outerResolver(obj, args, ctx, info)).then(function (root) {\r\n            if (innerResolver != null) {\r\n                return innerResolver(root, args, ctx, info);\r\n            }\r\n            return defaultFieldResolver(root, args, ctx, info);\r\n        });\r\n    };\r\n}\r\n// XXX this function only works for resolvers\r\n// XXX very hacky way to remember if the function\r\n// already ran for this request. This will only work\r\n// if people don't actually cache the operation.\r\n// if they do cache the operation, they will have to\r\n// manually remove the __runAtMostOnce before every request.\r\nfunction runAtMostOncePerRequest(fn) {\r\n    var value;\r\n    var randomNumber = Math.random();\r\n    return function (root, args, ctx, info) {\r\n        if (!info.operation['__runAtMostOnce']) {\r\n            info.operation['__runAtMostOnce'] = {};\r\n        }\r\n        if (!info.operation['__runAtMostOnce'][randomNumber]) {\r\n            info.operation['__runAtMostOnce'][randomNumber] = true;\r\n            value = fn(root, args, ctx, info);\r\n        }\r\n        return value;\r\n    };\r\n}\n\nfunction assertResolversPresent(schema, resolverValidationOptions) {\r\n    if (resolverValidationOptions === void 0) { resolverValidationOptions = {}; }\r\n    var _a = resolverValidationOptions.requireResolversForArgs, requireResolversForArgs = _a === void 0 ? false : _a, _b = resolverValidationOptions.requireResolversForNonScalar, requireResolversForNonScalar = _b === void 0 ? false : _b, _c = resolverValidationOptions.requireResolversForAllFields, requireResolversForAllFields = _c === void 0 ? false : _c;\r\n    if (requireResolversForAllFields &&\r\n        (requireResolversForArgs || requireResolversForNonScalar)) {\r\n        throw new TypeError('requireResolversForAllFields takes precedence over the more specific assertions. ' +\r\n            'Please configure either requireResolversForAllFields or requireResolversForArgs / ' +\r\n            'requireResolversForNonScalar, but not a combination of them.');\r\n    }\r\n    forEachField(schema, function (field, typeName, fieldName) {\r\n        // requires a resolver for *every* field.\r\n        if (requireResolversForAllFields) {\r\n            expectResolver(field, typeName, fieldName);\r\n        }\r\n        // requires a resolver on every field that has arguments\r\n        if (requireResolversForArgs && field.args.length > 0) {\r\n            expectResolver(field, typeName, fieldName);\r\n        }\r\n        // requires a resolver on every field that returns a non-scalar type\r\n        if (requireResolversForNonScalar &&\r\n            !isScalarType(getNamedType(field.type))) {\r\n            expectResolver(field, typeName, fieldName);\r\n        }\r\n    });\r\n}\r\nfunction expectResolver(field, typeName, fieldName) {\r\n    if (!field.resolve) {\r\n        // eslint-disable-next-line no-console\r\n        console.warn(\"Resolver missing for \\\"\" + typeName + \".\" + fieldName + \"\\\". To disable this warning check https://github.com/apollostack/graphql-tools/issues/131\");\r\n        return;\r\n    }\r\n    if (typeof field.resolve !== 'function') {\r\n        throw new SchemaError(\"Resolver \\\"\" + typeName + \".\" + fieldName + \"\\\" must be a function\");\r\n    }\r\n}\n\nfunction attachDirectiveResolvers(schema, directiveResolvers) {\r\n    if (typeof directiveResolvers !== 'object') {\r\n        throw new Error(\"Expected directiveResolvers to be of type object, got \" + typeof directiveResolvers);\r\n    }\r\n    if (Array.isArray(directiveResolvers)) {\r\n        throw new Error('Expected directiveResolvers to be of type object, got Array');\r\n    }\r\n    var schemaDirectives = Object.create(null);\r\n    Object.keys(directiveResolvers).forEach(function (directiveName) {\r\n        schemaDirectives[directiveName] = /** @class */ (function (_super) {\r\n            __extends(class_1, _super);\r\n            function class_1() {\r\n                return _super !== null && _super.apply(this, arguments) || this;\r\n            }\r\n            class_1.prototype.visitFieldDefinition = function (field) {\r\n                var resolver = directiveResolvers[directiveName];\r\n                var originalResolver = field.resolve != null ? field.resolve : defaultFieldResolver;\r\n                var directiveArgs = this.args;\r\n                field.resolve = function () {\r\n                    var args = [];\r\n                    for (var _i = 0; _i < arguments.length; _i++) {\r\n                        args[_i] = arguments[_i];\r\n                    }\r\n                    var source = args[0] /* original args */, context = args[2], info = args[3];\r\n                    return resolver(function () {\r\n                        return new Promise(function (resolve, reject) {\r\n                            var result = originalResolver.apply(field, args);\r\n                            if (result instanceof Error) {\r\n                                reject(result);\r\n                            }\r\n                            resolve(result);\r\n                        });\r\n                    }, source, directiveArgs, context, info);\r\n                };\r\n            };\r\n            return class_1;\r\n        }(SchemaDirectiveVisitor));\r\n    });\r\n    SchemaDirectiveVisitor.visitSchemaDirectives(schema, schemaDirectives);\r\n}\n\n// takes a GraphQL-JS schema and an object of connectors, then attaches\r\n// the connectors to the context by wrapping each query or mutation resolve\r\n// function with a function that attaches connectors if they don't exist.\r\n// attaches connectors only once to make sure they are singletons\r\nvar attachConnectorsToContext = deprecated({\r\n    version: '0.7.0',\r\n    url: 'https://github.com/apollostack/graphql-tools/issues/140',\r\n}, function (schema, connectors) {\r\n    if (!schema || !isSchema(schema)) {\r\n        throw new Error('schema must be an instance of GraphQLSchema. ' +\r\n            'This error could be caused by installing more than one version of GraphQL-JS');\r\n    }\r\n    if (typeof connectors !== 'object') {\r\n        var connectorType = typeof connectors;\r\n        throw new Error(\"Expected connectors to be of type object, got \" + connectorType);\r\n    }\r\n    if (Object.keys(connectors).length === 0) {\r\n        throw new Error('Expected connectors to not be an empty object');\r\n    }\r\n    if (Array.isArray(connectors)) {\r\n        throw new Error('Expected connectors to be of type object, got Array');\r\n    }\r\n    if (schema['_apolloConnectorsAttached']) {\r\n        throw new Error('Connectors already attached to context, cannot attach more than once');\r\n    }\r\n    schema['_apolloConnectorsAttached'] = true;\r\n    var attachconnectorFn = function (root, _args, ctx) {\r\n        if (typeof ctx !== 'object') {\r\n            // if in any way possible, we should throw an error when the attachconnectors\r\n            // function is called, not when a query is executed.\r\n            var contextType = typeof ctx;\r\n            throw new Error(\"Cannot attach connector because context is not an object: \" + contextType);\r\n        }\r\n        if (typeof ctx.connectors === 'undefined') {\r\n            ctx.connectors = {};\r\n        }\r\n        Object.keys(connectors).forEach(function (connectorName) {\r\n            var connector = connectors[connectorName];\r\n            if (connector.prototype != null) {\r\n                ctx.connectors[connectorName] = new connector(ctx);\r\n            }\r\n            else {\r\n                throw new Error('Connector must be a function or an class');\r\n            }\r\n        });\r\n        return root;\r\n    };\r\n    addSchemaLevelResolver(schema, attachconnectorFn);\r\n});\n\nfunction extractExtensionDefinitions(ast) {\r\n    var extensionDefs = ast.definitions.filter(function (def) {\r\n        return def.kind === Kind.OBJECT_TYPE_EXTENSION ||\r\n            (graphqlVersion() >= 13 && def.kind === Kind.INTERFACE_TYPE_EXTENSION) ||\r\n            def.kind === Kind.INPUT_OBJECT_TYPE_EXTENSION ||\r\n            def.kind === Kind.UNION_TYPE_EXTENSION ||\r\n            def.kind === Kind.ENUM_TYPE_EXTENSION ||\r\n            def.kind === Kind.SCALAR_TYPE_EXTENSION ||\r\n            def.kind === Kind.SCHEMA_EXTENSION;\r\n    });\r\n    return __assign(__assign({}, ast), { definitions: extensionDefs });\r\n}\r\nfunction filterExtensionDefinitions(ast) {\r\n    var extensionDefs = ast.definitions.filter(function (def) {\r\n        return def.kind !== Kind.OBJECT_TYPE_EXTENSION &&\r\n            def.kind !== Kind.INTERFACE_TYPE_EXTENSION &&\r\n            def.kind !== Kind.INPUT_OBJECT_TYPE_EXTENSION &&\r\n            def.kind !== Kind.UNION_TYPE_EXTENSION &&\r\n            def.kind !== Kind.ENUM_TYPE_EXTENSION &&\r\n            def.kind !== Kind.SCALAR_TYPE_EXTENSION &&\r\n            def.kind !== Kind.SCHEMA_EXTENSION;\r\n    });\r\n    return __assign(__assign({}, ast), { definitions: extensionDefs });\r\n}\n\nfunction concatenateTypeDefs(typeDefinitionsAry, calledFunctionRefs) {\r\n    if (calledFunctionRefs === void 0) { calledFunctionRefs = []; }\r\n    var resolvedTypeDefinitions = [];\r\n    typeDefinitionsAry.forEach(function (typeDef) {\r\n        if (typeof typeDef === 'function') {\r\n            if (calledFunctionRefs.indexOf(typeDef) === -1) {\r\n                calledFunctionRefs.push(typeDef);\r\n                resolvedTypeDefinitions = resolvedTypeDefinitions.concat(concatenateTypeDefs(typeDef(), calledFunctionRefs));\r\n            }\r\n        }\r\n        else if (typeof typeDef === 'string') {\r\n            resolvedTypeDefinitions.push(typeDef.trim());\r\n        }\r\n        else if (typeDef.kind !== undefined) {\r\n            resolvedTypeDefinitions.push(print(typeDef).trim());\r\n        }\r\n        else {\r\n            var type = typeof typeDef;\r\n            throw new SchemaError(\"typeDef array must contain only strings and functions, got \" + type);\r\n        }\r\n    });\r\n    return uniq(resolvedTypeDefinitions.map(function (x) { return x.trim(); })).join('\\n');\r\n}\r\nfunction uniq(array) {\r\n    return array.reduce(function (accumulator, currentValue) {\r\n        return accumulator.indexOf(currentValue) === -1\r\n            ? __spreadArrays(accumulator, [currentValue]) : accumulator;\r\n    }, []);\r\n}\n\nfunction buildSchemaFromTypeDefinitions(typeDefinitions, parseOptions) {\r\n    // TODO: accept only array here, otherwise interfaces get confusing.\r\n    var myDefinitions = typeDefinitions;\r\n    var astDocument;\r\n    if (isDocumentNode(typeDefinitions)) {\r\n        astDocument = typeDefinitions;\r\n    }\r\n    else if (typeof myDefinitions !== 'string') {\r\n        if (!Array.isArray(myDefinitions)) {\r\n            var type = typeof myDefinitions;\r\n            throw new SchemaError(\"typeDefs must be a string, array or schema AST, got \" + type);\r\n        }\r\n        myDefinitions = concatenateTypeDefs(myDefinitions);\r\n    }\r\n    if (typeof myDefinitions === 'string') {\r\n        astDocument = parse(myDefinitions, parseOptions);\r\n    }\r\n    var typesAst = filterExtensionDefinitions(astDocument);\r\n    var backcompatOptions = { commentDescriptions: true };\r\n    var schema = buildASTSchema(typesAst, backcompatOptions);\r\n    var extensionsAst = extractExtensionDefinitions(astDocument);\r\n    if (extensionsAst.definitions.length > 0) {\r\n        schema = extendSchema$1(schema, extensionsAst, backcompatOptions);\r\n    }\r\n    return schema;\r\n}\r\nfunction isDocumentNode(typeDefinitions) {\r\n    return typeDefinitions.kind !== undefined;\r\n}\n\nfunction chainResolvers(resolvers) {\r\n    return function (root, args, ctx, info) {\r\n        return resolvers.reduce(function (prev, curResolver) {\r\n            if (curResolver != null) {\r\n                return curResolver(prev, args, ctx, info);\r\n            }\r\n            return defaultFieldResolver(prev, args, ctx, info);\r\n        }, root);\r\n    };\r\n}\n\n/*\r\n * fn: The function to decorate with the logger\r\n * logger: an object instance of type Logger\r\n * hint: an optional hint to add to the error's message\r\n */\r\nfunction decorateWithLogger(fn, logger, hint) {\r\n    var resolver = fn != null ? fn : defaultFieldResolver;\r\n    var logError = function (e) {\r\n        // TODO: clone the error properly\r\n        var newE = new Error();\r\n        newE.stack = e.stack;\r\n        /* istanbul ignore else: always get the hint from addErrorLoggingToSchema */\r\n        if (hint) {\r\n            newE['originalMessage'] = e.message;\r\n            newE['message'] = \"Error in resolver \" + hint + \"\\n\" + e.message;\r\n        }\r\n        logger.log(newE);\r\n    };\r\n    return function (root, args, ctx, info) {\r\n        try {\r\n            var result = resolver(root, args, ctx, info);\r\n            // If the resolver returns a Promise log any Promise rejects.\r\n            if (result &&\r\n                typeof result.then === 'function' &&\r\n                typeof result.catch === 'function') {\r\n                result.catch(function (reason) {\r\n                    // make sure that it's an error we're logging.\r\n                    var error = reason instanceof Error ? reason : new Error(reason);\r\n                    logError(error);\r\n                    // We don't want to leave an unhandled exception so pass on error.\r\n                    return reason;\r\n                });\r\n            }\r\n            return result;\r\n        }\r\n        catch (e) {\r\n            logError(e);\r\n            // we want to pass on the error, just in case.\r\n            throw e;\r\n        }\r\n    };\r\n}\n\nfunction makeExecutableSchema(_a) {\r\n    var typeDefs = _a.typeDefs, _b = _a.resolvers, resolvers = _b === void 0 ? {} : _b, connectors = _a.connectors, logger = _a.logger, _c = _a.allowUndefinedInResolve, allowUndefinedInResolve = _c === void 0 ? true : _c, _d = _a.resolverValidationOptions, resolverValidationOptions = _d === void 0 ? {} : _d, directiveResolvers = _a.directiveResolvers, schemaDirectives = _a.schemaDirectives, _e = _a.parseOptions, parseOptions = _e === void 0 ? {} : _e, _f = _a.inheritResolversFromInterfaces, inheritResolversFromInterfaces = _f === void 0 ? false : _f;\r\n    // Validate and clean up arguments\r\n    if (typeof resolverValidationOptions !== 'object') {\r\n        throw new SchemaError('Expected `resolverValidationOptions` to be an object');\r\n    }\r\n    if (!typeDefs) {\r\n        throw new SchemaError('Must provide typeDefs');\r\n    }\r\n    // We allow passing in an array of resolver maps, in which case we merge them\r\n    var resolverMap = Array.isArray(resolvers)\r\n        ? resolvers\r\n            .filter(function (resolverObj) { return typeof resolverObj === 'object'; })\r\n            .reduce(mergeDeep, {})\r\n        : resolvers;\r\n    // Arguments are now validated and cleaned up\r\n    var schema = buildSchemaFromTypeDefinitions(typeDefs, parseOptions);\r\n    addResolversToSchema({\r\n        schema: schema,\r\n        resolvers: resolverMap,\r\n        resolverValidationOptions: resolverValidationOptions,\r\n        inheritResolversFromInterfaces: inheritResolversFromInterfaces,\r\n    });\r\n    assertResolversPresent(schema, resolverValidationOptions);\r\n    if (!allowUndefinedInResolve) {\r\n        addCatchUndefinedToSchema(schema);\r\n    }\r\n    if (logger != null) {\r\n        addErrorLoggingToSchema(schema, logger);\r\n    }\r\n    if (typeof resolvers['__schema'] === 'function') {\r\n        // TODO a bit of a hack now, better rewrite generateSchema to attach it there.\r\n        // not doing that now, because I'd have to rewrite a lot of tests.\r\n        addSchemaLevelResolver(schema, resolvers['__schema']);\r\n    }\r\n    if (connectors != null) {\r\n        // connectors are optional, at least for now. That means you can just import them in the resolve\r\n        // function if you want.\r\n        attachConnectorsToContext(schema, connectors);\r\n    }\r\n    if (directiveResolvers != null) {\r\n        attachDirectiveResolvers(schema, directiveResolvers);\r\n    }\r\n    if (schemaDirectives != null) {\r\n        SchemaDirectiveVisitor.visitSchemaDirectives(schema, schemaDirectives);\r\n    }\r\n    return schema;\r\n}\r\nfunction decorateToCatchUndefined(fn, hint) {\r\n    var resolve = fn == null ? defaultFieldResolver : fn;\r\n    return function (root, args, ctx, info) {\r\n        var result = resolve(root, args, ctx, info);\r\n        if (typeof result === 'undefined') {\r\n            throw new Error(\"Resolver for \\\"\" + hint + \"\\\" returned undefined\");\r\n        }\r\n        return result;\r\n    };\r\n}\r\nfunction addCatchUndefinedToSchema(schema) {\r\n    forEachField(schema, function (field, typeName, fieldName) {\r\n        var errorHint = typeName + \".\" + fieldName;\r\n        field.resolve = decorateToCatchUndefined(field.resolve, errorHint);\r\n    });\r\n}\r\nfunction addErrorLoggingToSchema(schema, logger) {\r\n    if (!logger) {\r\n        throw new Error('Must provide a logger');\r\n    }\r\n    if (typeof logger.log !== 'function') {\r\n        throw new Error('Logger.log must be a function');\r\n    }\r\n    forEachField(schema, function (field, typeName, fieldName) {\r\n        var errorHint = typeName + \".\" + fieldName;\r\n        field.resolve = decorateWithLogger(field.resolve, logger, errorHint);\r\n    });\r\n}\n\n// These functions are preserved for backwards compatibility.\r\n// They are not simply rexported with new (old) names so as to allow\r\n// typedoc to annotate them.\r\nfunction addResolveFunctionsToSchema(schemaOrOptions, legacyInputResolvers, legacyInputValidationOptions) {\r\n    return addResolversToSchema(schemaOrOptions, legacyInputResolvers, legacyInputValidationOptions);\r\n}\r\nfunction addSchemaLevelResolveFunction(schema, fn) {\r\n    addSchemaLevelResolver(schema, fn);\r\n}\r\nfunction assertResolveFunctionsPresent(schema, resolverValidationOptions) {\r\n    if (resolverValidationOptions === void 0) { resolverValidationOptions = {}; }\r\n    assertResolversPresent(schema, resolverValidationOptions);\r\n}\n\nfunction getFinalPromise(object) {\r\n    return Promise.resolve(object).then(function (resolvedObject) {\r\n        if (resolvedObject == null) {\r\n            return resolvedObject;\r\n        }\r\n        if (Array.isArray(resolvedObject)) {\r\n            return Promise.all(resolvedObject.map(function (o) { return getFinalPromise(o); }));\r\n        }\r\n        else if (typeof resolvedObject === 'object') {\r\n            var keys_1 = Object.keys(resolvedObject);\r\n            return Promise.all(keys_1.map(function (key) { return getFinalPromise(resolvedObject[key]); })).then(function (awaitedValues) {\r\n                for (var i = 0; i < keys_1.length; i++) {\r\n                    resolvedObject[keys_1[i]] = awaitedValues[i];\r\n                }\r\n                return resolvedObject;\r\n            });\r\n        }\r\n        return resolvedObject;\r\n    });\r\n}\r\nvar AwaitVariablesLink = /** @class */ (function (_super) {\r\n    __extends(AwaitVariablesLink, _super);\r\n    function AwaitVariablesLink() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    AwaitVariablesLink.prototype.request = function (operation, forward) {\r\n        return new Observable(function (observer) {\r\n            var subscription;\r\n            getFinalPromise(operation.variables)\r\n                .then(function (resolvedVariables) {\r\n                operation.variables = resolvedVariables;\r\n                subscription = forward(operation).subscribe({\r\n                    next: observer.next.bind(observer),\r\n                    error: observer.error.bind(observer),\r\n                    complete: observer.complete.bind(observer),\r\n                });\r\n            })\r\n                .catch(observer.error.bind(observer));\r\n            return function () {\r\n                if (subscription != null) {\r\n                    subscription.unsubscribe();\r\n                }\r\n            };\r\n        });\r\n    };\r\n    return AwaitVariablesLink;\r\n}(ApolloLink));\n\n/* eslint-disable import/no-nodejs-modules */\r\nvar FormDataWithStreamSupport = /** @class */ (function (_super) {\r\n    __extends(FormDataWithStreamSupport, _super);\r\n    function FormDataWithStreamSupport(options) {\r\n        var _this = _super.call(this, options) || this;\r\n        _this.hasUnknowableLength = false;\r\n        return _this;\r\n    }\r\n    FormDataWithStreamSupport.prototype.append = function (key, value, optionsOrFilename) {\r\n        if (optionsOrFilename === void 0) { optionsOrFilename = {}; }\r\n        // allow filename as single option\r\n        var options = typeof optionsOrFilename === 'string'\r\n            ? { filename: optionsOrFilename }\r\n            : optionsOrFilename;\r\n        // empty or either doesn't have path or not an http response\r\n        if (!options.knownLength &&\r\n            !Buffer.isBuffer(value) &&\r\n            typeof value !== 'string' &&\r\n            !value.path &&\r\n            !(value.readable && hasOwnProperty(value, 'httpVersion'))) {\r\n            this.hasUnknowableLength = true;\r\n        }\r\n        _super.prototype.append.call(this, key, value, options);\r\n    };\r\n    FormDataWithStreamSupport.prototype.getLength = function (callback) {\r\n        if (this.hasUnknowableLength) {\r\n            return null;\r\n        }\r\n        return _super.prototype.getLength.call(this, callback);\r\n    };\r\n    FormDataWithStreamSupport.prototype.getLengthSync = function () {\r\n        if (this.hasUnknowableLength) {\r\n            return null;\r\n        }\r\n        // eslint-disable-next-line no-sync\r\n        return _super.prototype.getLengthSync.call(this);\r\n    };\r\n    return FormDataWithStreamSupport;\r\n}(FormData));\r\nvar createServerHttpLink = function (options) {\r\n    return concat(new AwaitVariablesLink(), createUploadLink(__assign(__assign({}, options), { fetch: fetch, FormData: FormDataWithStreamSupport, isExtractableFile: function (value) {\r\n            return isExtractableFile(value) || (value === null || value === void 0 ? void 0 : value.createReadStream);\r\n        }, formDataAppendFile: function (form, index, file) {\r\n            if (file.createReadStream != null) {\r\n                form.append(index, file.createReadStream(), {\r\n                    filename: file.filename,\r\n                    contentType: file.mimetype,\r\n                });\r\n            }\r\n            else {\r\n                formDataAppendFile(form, index, file);\r\n            }\r\n        } })));\r\n};\n\n/**\r\n * This function wraps addMocksToSchema for more convenience\r\n */\r\nfunction mockServer(schema, mocks, preserveResolvers) {\r\n    if (preserveResolvers === void 0) { preserveResolvers = false; }\r\n    var mySchema;\r\n    if (!isSchema(schema)) {\r\n        // TODO: provide useful error messages here if this fails\r\n        mySchema = buildSchemaFromTypeDefinitions(schema);\r\n    }\r\n    else {\r\n        mySchema = schema;\r\n    }\r\n    addMocksToSchema({ schema: mySchema, mocks: mocks, preserveResolvers: preserveResolvers });\r\n    return { query: function (query, vars) { return graphql(mySchema, query, {}, {}, vars); } };\r\n}\r\nvar defaultMockMap = new Map();\r\ndefaultMockMap.set('Int', function () { return Math.round(Math.random() * 200) - 100; });\r\ndefaultMockMap.set('Float', function () { return Math.random() * 200 - 100; });\r\ndefaultMockMap.set('String', function () { return 'Hello World'; });\r\ndefaultMockMap.set('Boolean', function () { return Math.random() > 0.5; });\r\ndefaultMockMap.set('ID', function () { return v4(); });\r\n// TODO allow providing a seed such that lengths of list could be deterministic\r\n// this could be done by using casual to get a random list length if the casual\r\n// object is global.\r\nfunction addMocksToSchema(_a) {\r\n    var schema = _a.schema, _b = _a.mocks, mocks = _b === void 0 ? {} : _b, _c = _a.preserveResolvers, preserveResolvers = _c === void 0 ? false : _c;\r\n    if (!schema) {\r\n        throw new Error('Must provide schema to mock');\r\n    }\r\n    if (!isSchema(schema)) {\r\n        throw new Error('Value at \"schema\" must be of type GraphQLSchema');\r\n    }\r\n    if (!isObject$1(mocks)) {\r\n        throw new Error('mocks must be of type Object');\r\n    }\r\n    // use Map internally, because that API is nicer.\r\n    var mockFunctionMap = new Map();\r\n    Object.keys(mocks).forEach(function (typeName) {\r\n        mockFunctionMap.set(typeName, mocks[typeName]);\r\n    });\r\n    mockFunctionMap.forEach(function (mockFunction, mockTypeName) {\r\n        if (typeof mockFunction !== 'function') {\r\n            throw new Error(\"mockFunctionMap[\" + mockTypeName + \"] must be a function\");\r\n        }\r\n    });\r\n    var mockType = function (type, _typeName, fieldName) {\r\n        // order of precendence for mocking:\r\n        // 1. if the object passed in already has fieldName, just use that\r\n        // --> if it's a function, that becomes your resolver\r\n        // --> if it's a value, the mock resolver will return that\r\n        // 2. if the nullableType is a list, recurse\r\n        // 2. if there's a mock defined for this typeName, that will be used\r\n        // 3. if there's no mock defined, use the default mocks for this type\r\n        return function (root, args, context, info) {\r\n            // nullability doesn't matter for the purpose of mocking.\r\n            var fieldType = getNullableType(type);\r\n            var namedFieldType = getNamedType(fieldType);\r\n            if (fieldName && root && typeof root[fieldName] !== 'undefined') {\r\n                var result = void 0;\r\n                // if we're here, the field is already defined\r\n                if (typeof root[fieldName] === 'function') {\r\n                    result = root[fieldName](root, args, context, info);\r\n                    if (result instanceof MockList) {\r\n                        result = result.mock(root, args, context, info, fieldType, mockType);\r\n                    }\r\n                }\r\n                else {\r\n                    result = root[fieldName];\r\n                }\r\n                // Now we merge the result with the default mock for this type.\r\n                // This allows overriding defaults while writing very little code.\r\n                if (mockFunctionMap.has(namedFieldType.name)) {\r\n                    var mock = mockFunctionMap.get(namedFieldType.name);\r\n                    result = mergeMocks(mock.bind(null, root, args, context, info), result);\r\n                }\r\n                return result;\r\n            }\r\n            if (isListType(fieldType)) {\r\n                return [\r\n                    mockType(fieldType.ofType)(root, args, context, info),\r\n                    mockType(fieldType.ofType)(root, args, context, info),\r\n                ];\r\n            }\r\n            if (mockFunctionMap.has(fieldType.name) && !isAbstractType(fieldType)) {\r\n                // the object passed doesn't have this field, so we apply the default mock\r\n                var mock = mockFunctionMap.get(fieldType.name);\r\n                return mock(root, args, context, info);\r\n            }\r\n            if (isObjectType(fieldType)) {\r\n                // objects don't return actual data, we only need to mock scalars!\r\n                return {};\r\n            }\r\n            // if a mock function is provided for unionType or interfaceType, execute it to resolve the concrete type\r\n            // otherwise randomly pick a type from all implementation types\r\n            if (isAbstractType(fieldType)) {\r\n                var implementationType = void 0;\r\n                if (mockFunctionMap.has(fieldType.name)) {\r\n                    var mock = mockFunctionMap.get(fieldType.name);\r\n                    var interfaceMockObj = mock(root, args, context, info);\r\n                    if (!interfaceMockObj || !interfaceMockObj.__typename) {\r\n                        return Error(\"Please return a __typename in \\\"\" + fieldType.name + \"\\\"\");\r\n                    }\r\n                    implementationType = schema.getType(interfaceMockObj.__typename);\r\n                }\r\n                else {\r\n                    var possibleTypes = schema.getPossibleTypes(fieldType);\r\n                    implementationType = getRandomElement(possibleTypes);\r\n                }\r\n                return __assign({ __typename: implementationType }, mockType(implementationType)(root, args, context, info));\r\n            }\r\n            if (isEnumType(fieldType)) {\r\n                return getRandomElement(fieldType.getValues()).value;\r\n            }\r\n            if (defaultMockMap.has(fieldType.name)) {\r\n                var defaultMock = defaultMockMap.get(fieldType.name);\r\n                return defaultMock(root, args, context, info);\r\n            }\r\n            // if we get to here, we don't have a value, and we don't have a mock for this type,\r\n            // we could return undefined, but that would be hard to debug, so we throw instead.\r\n            // however, we returning it instead of throwing it, so preserveResolvers can handle the failures.\r\n            return Error(\"No mock defined for type \\\"\" + fieldType.name + \"\\\"\");\r\n        };\r\n    };\r\n    forEachField(schema, function (field, typeName, fieldName) {\r\n        assignResolveType(field.type, preserveResolvers);\r\n        var mockResolver = mockType(field.type, typeName, fieldName);\r\n        // we have to handle the root mutation and root query types differently,\r\n        // because no resolver is called at the root.\r\n        var queryType = schema.getQueryType();\r\n        var isOnQueryType = queryType != null && queryType.name === typeName;\r\n        var mutationType = schema.getMutationType();\r\n        var isOnMutationType = mutationType != null && mutationType.name === typeName;\r\n        if (isOnQueryType || isOnMutationType) {\r\n            if (mockFunctionMap.has(typeName)) {\r\n                var rootMock_1 = mockFunctionMap.get(typeName);\r\n                // XXX: BUG in here, need to provide proper signature for rootMock.\r\n                if (typeof rootMock_1(undefined, {}, {}, {})[fieldName] ===\r\n                    'function') {\r\n                    mockResolver = function (root, args, context, info) {\r\n                        var updatedRoot = root !== null && root !== void 0 ? root : {}; // TODO: should we clone instead?\r\n                        updatedRoot[fieldName] = rootMock_1(root, args, context, info)[fieldName];\r\n                        // XXX this is a bit of a hack to still use mockType, which\r\n                        // lets you mock lists etc. as well\r\n                        // otherwise we could just set field.resolve to rootMock()[fieldName]\r\n                        // it's like pretending there was a resolver that ran before\r\n                        // the root resolver.\r\n                        return mockType(field.type, typeName, fieldName)(updatedRoot, args, context, info);\r\n                    };\r\n                }\r\n            }\r\n        }\r\n        if (!preserveResolvers || !field.resolve) {\r\n            field.resolve = mockResolver;\r\n        }\r\n        else {\r\n            var oldResolver_1 = field.resolve;\r\n            field.resolve = function (rootObject, args, context, info) {\r\n                return Promise.all([\r\n                    mockResolver(rootObject, args, context, info),\r\n                    oldResolver_1(rootObject, args, context, info),\r\n                ]).then(function (values) {\r\n                    var mockedValue = values[0], resolvedValue = values[1];\r\n                    // In case we couldn't mock\r\n                    if (mockedValue instanceof Error) {\r\n                        // only if value was not resolved, populate the error.\r\n                        if (undefined === resolvedValue) {\r\n                            throw mockedValue;\r\n                        }\r\n                        return resolvedValue;\r\n                    }\r\n                    if (resolvedValue instanceof Date && mockedValue instanceof Date) {\r\n                        return undefined !== resolvedValue ? resolvedValue : mockedValue;\r\n                    }\r\n                    if (isObject$1(mockedValue) && isObject$1(resolvedValue)) {\r\n                        // Object.assign() won't do here, as we need to all properties, including\r\n                        // the non-enumerable ones and defined using Object.defineProperty\r\n                        var emptyObject = Object.create(Object.getPrototypeOf(resolvedValue));\r\n                        return copyOwnProps(emptyObject, resolvedValue, mockedValue);\r\n                    }\r\n                    return undefined !== resolvedValue ? resolvedValue : mockedValue;\r\n                });\r\n            };\r\n        }\r\n    });\r\n}\r\nfunction isObject$1(thing) {\r\n    return thing === Object(thing) && !Array.isArray(thing);\r\n}\r\n// returns a random element from that ary\r\nfunction getRandomElement(ary) {\r\n    var sample = Math.floor(Math.random() * ary.length);\r\n    return ary[sample];\r\n}\r\nfunction mergeObjects(a, b) {\r\n    return Object.assign(a, b);\r\n}\r\nfunction copyOwnPropsIfNotPresent(target, source) {\r\n    Object.getOwnPropertyNames(source).forEach(function (prop) {\r\n        if (!Object.getOwnPropertyDescriptor(target, prop)) {\r\n            var propertyDescriptor = Object.getOwnPropertyDescriptor(source, prop);\r\n            Object.defineProperty(target, prop, propertyDescriptor == null ? {} : propertyDescriptor);\r\n        }\r\n    });\r\n}\r\nfunction copyOwnProps(target) {\r\n    var sources = [];\r\n    for (var _i = 1; _i < arguments.length; _i++) {\r\n        sources[_i - 1] = arguments[_i];\r\n    }\r\n    sources.forEach(function (source) {\r\n        var chain = source;\r\n        while (chain != null) {\r\n            copyOwnPropsIfNotPresent(target, chain);\r\n            chain = Object.getPrototypeOf(chain);\r\n        }\r\n    });\r\n    return target;\r\n}\r\n// takes either an object or a (possibly nested) array\r\n// and completes the customMock object with any fields\r\n// defined on genericMock\r\n// only merges objects or arrays. Scalars are returned as is\r\nfunction mergeMocks(genericMockFunction, customMock) {\r\n    if (Array.isArray(customMock)) {\r\n        return customMock.map(function (el) { return mergeMocks(genericMockFunction, el); });\r\n    }\r\n    if (isObject$1(customMock)) {\r\n        return mergeObjects(genericMockFunction(), customMock);\r\n    }\r\n    return customMock;\r\n}\r\nfunction getResolveType(namedFieldType) {\r\n    if (isAbstractType(namedFieldType)) {\r\n        return namedFieldType.resolveType;\r\n    }\r\n}\r\nfunction assignResolveType(type, preserveResolvers) {\r\n    var fieldType = getNullableType(type);\r\n    var namedFieldType = getNamedType(fieldType);\r\n    var oldResolveType = getResolveType(namedFieldType);\r\n    if (preserveResolvers && oldResolveType != null && oldResolveType.length) {\r\n        return;\r\n    }\r\n    if (isInterfaceType(namedFieldType) || isUnionType(namedFieldType)) {\r\n        // the default `resolveType` always returns null. We add a fallback\r\n        // resolution that works with how unions and interface are mocked\r\n        namedFieldType.resolveType = function (data, _context, info) { return info.schema.getType(data.__typename); };\r\n    }\r\n}\r\nvar MockList = /** @class */ (function () {\r\n    // wrappedFunction can return another MockList or a value\r\n    function MockList(len, wrappedFunction) {\r\n        this.len = len;\r\n        if (typeof wrappedFunction !== 'undefined') {\r\n            if (typeof wrappedFunction !== 'function') {\r\n                throw new Error('Second argument to MockList must be a function or undefined');\r\n            }\r\n            this.wrappedFunction = wrappedFunction;\r\n        }\r\n    }\r\n    MockList.prototype.mock = function (root, args, context, info, fieldType, mockTypeFunc) {\r\n        var arr;\r\n        if (Array.isArray(this.len)) {\r\n            arr = new Array(this.randint(this.len[0], this.len[1]));\r\n        }\r\n        else {\r\n            arr = new Array(this.len);\r\n        }\r\n        for (var i = 0; i < arr.length; i++) {\r\n            if (typeof this.wrappedFunction === 'function') {\r\n                var res = this.wrappedFunction(root, args, context, info);\r\n                if (res instanceof MockList) {\r\n                    var nullableType = getNullableType(fieldType.ofType);\r\n                    arr[i] = res.mock(root, args, context, info, nullableType, mockTypeFunc);\r\n                }\r\n                else {\r\n                    arr[i] = res;\r\n                }\r\n            }\r\n            else {\r\n                arr[i] = mockTypeFunc(fieldType.ofType)(root, args, context, info);\r\n            }\r\n        }\r\n        return arr;\r\n    };\r\n    MockList.prototype.randint = function (low, high) {\r\n        return Math.floor(Math.random() * (high - low + 1) + low);\r\n    };\r\n    return MockList;\r\n}());\r\n// retain addMockFunctionsToSchema for backwards compatibility\r\nfunction addMockFunctionsToSchema(_a) {\r\n    var schema = _a.schema, _b = _a.mocks, mocks = _b === void 0 ? {} : _b, _c = _a.preserveResolvers, preserveResolvers = _c === void 0 ? false : _c;\r\n    addMocksToSchema({ schema: schema, mocks: mocks, preserveResolvers: preserveResolvers });\r\n}\n\nvar GraphQLUpload = new GraphQLScalarType({\r\n    name: 'Upload',\r\n    description: 'The `Upload` scalar type represents a file upload.',\r\n    parseValue: function (value) {\r\n        if (value != null && value.promise instanceof Promise) {\r\n            // graphql-upload v10\r\n            return value.promise;\r\n        }\r\n        else if (value instanceof Promise) {\r\n            // graphql-upload v9\r\n            return value;\r\n        }\r\n        throw new GraphQLError('Upload value invalid.');\r\n    },\r\n    // serialization requires to support schema stitching\r\n    serialize: function (value) { return value; },\r\n    parseLiteral: function (ast) {\r\n        throw new GraphQLError('Upload literal unsupported.', ast);\r\n    },\r\n});\n\nvar parsedIntrospectionQuery = parse(getIntrospectionQuery());\r\nfunction introspectSchema(linkOrFetcher, linkContext) {\r\n    var fetcher = typeof linkOrFetcher === 'function'\r\n        ? linkOrFetcher\r\n        : linkToFetcher(linkOrFetcher);\r\n    return fetcher({\r\n        query: parsedIntrospectionQuery,\r\n        context: linkContext,\r\n    }).then(function (introspectionResult) {\r\n        if ((Array.isArray(introspectionResult.errors) &&\r\n            introspectionResult.errors.length) ||\r\n            !introspectionResult.data.__schema) {\r\n            if (Array.isArray(introspectionResult.errors)) {\r\n                var combinedError = combineErrors(introspectionResult.errors);\r\n                throw combinedError;\r\n            }\r\n            else {\r\n                throw new Error('Could not obtain introspection result, received: ' +\r\n                    JSON.stringify(introspectionResult));\r\n            }\r\n        }\r\n        else {\r\n            var schema = buildClientSchema(introspectionResult.data);\r\n            return schema;\r\n        }\r\n    });\r\n}\n\n/**\r\n * Resolver that knows how to:\r\n * a) handle aliases for proxied schemas\r\n * b) handle errors from proxied schemas\r\n * c) handle external to internal enum coversion\r\n */\r\nfunction defaultMergedResolver(parent, args, context, info) {\r\n    if (!parent) {\r\n        return null;\r\n    }\r\n    var responseKey = getResponseKeyFromInfo(info);\r\n    var errors = getErrors(parent, responseKey);\r\n    // check to see if parent is not a proxied result, i.e. if parent resolver was manually overwritten\r\n    // See https://github.com/apollographql/graphql-tools/issues/967\r\n    if (!errors) {\r\n        return defaultFieldResolver(parent, args, context, info);\r\n    }\r\n    var result = parent[responseKey];\r\n    var subschema = getSubschema(parent, responseKey);\r\n    return handleResult(result, errors, subschema, context, info);\r\n}\n\nfunction makeMergedType(type) {\r\n    if (isObjectType(type)) {\r\n        type.isTypeOf = undefined;\r\n        var fieldMap_1 = type.getFields();\r\n        Object.keys(fieldMap_1).forEach(function (fieldName) {\r\n            fieldMap_1[fieldName].resolve = defaultMergedResolver;\r\n            fieldMap_1[fieldName].subscribe = null;\r\n        });\r\n    }\r\n    else if (isAbstractType(type)) {\r\n        type.resolveType = function (parent) { return resolveFromParentTypename(parent); };\r\n    }\r\n}\n\nfunction generateProxyingResolvers(_a) {\r\n    var subschemaConfig = _a.subschemaConfig, transforms = _a.transforms;\r\n    var targetSchema = subschemaConfig.schema;\r\n    var operationTypes = {\r\n        query: targetSchema.getQueryType(),\r\n        mutation: targetSchema.getMutationType(),\r\n        subscription: targetSchema.getSubscriptionType(),\r\n    };\r\n    var createProxyingResolver = subschemaConfig.createProxyingResolver != null\r\n        ? subschemaConfig.createProxyingResolver\r\n        : defaultCreateProxyingResolver;\r\n    var resolvers = {};\r\n    Object.keys(operationTypes).forEach(function (operation) {\r\n        var resolveField = operation === 'subscription' ? 'subscribe' : 'resolve';\r\n        var rootType = operationTypes[operation];\r\n        if (rootType != null) {\r\n            var typeName_1 = rootType.name;\r\n            var fields = rootType.getFields();\r\n            resolvers[typeName_1] = {};\r\n            Object.keys(fields).forEach(function (fieldName) {\r\n                var _a;\r\n                var proxyingResolver = createProxyingResolver(subschemaConfig, transforms, operation, fieldName);\r\n                var finalResolver = createPossiblyNestedProxyingResolver(subschemaConfig, proxyingResolver);\r\n                resolvers[typeName_1][fieldName] = (_a = {},\r\n                    _a[resolveField] = finalResolver,\r\n                    _a);\r\n            });\r\n        }\r\n    });\r\n    return resolvers;\r\n}\r\nfunction createPossiblyNestedProxyingResolver(subschemaConfig, proxyingResolver) {\r\n    return function (parent, args, context, info) {\r\n        if (parent != null) {\r\n            var responseKey = getResponseKeyFromInfo(info);\r\n            var errors = getErrors(parent, responseKey);\r\n            // Check to see if the parent contains a proxied result\r\n            if (errors != null) {\r\n                var subschema = getSubschema(parent, responseKey);\r\n                // If there is a proxied result from this subschema, return it\r\n                // This can happen even for a root field when the root type ia\r\n                // also nested as a field within a different type.\r\n                if (subschemaConfig === subschema) {\r\n                    return handleResult(parent[responseKey], errors, subschema, context, info);\r\n                }\r\n            }\r\n        }\r\n        return proxyingResolver(parent, args, context, info);\r\n    };\r\n}\r\nfunction defaultCreateProxyingResolver(schema, transforms) {\r\n    return function (_parent, _args, context, info) {\r\n        return delegateToSchema({\r\n            schema: schema,\r\n            context: context,\r\n            info: info,\r\n            transforms: transforms,\r\n        });\r\n    };\r\n}\r\nfunction stripResolvers(schema) {\r\n    var typeMap = schema.getTypeMap();\r\n    Object.keys(typeMap).forEach(function (typeName) {\r\n        if (!typeName.startsWith('__')) {\r\n            makeMergedType(typeMap[typeName]);\r\n        }\r\n    });\r\n}\n\nfunction wrapSchema(subschemaOrSubschemaConfig, transforms) {\r\n    var subschemaConfig = isSubschemaConfig(subschemaOrSubschemaConfig)\r\n        ? subschemaOrSubschemaConfig\r\n        : { schema: subschemaOrSubschemaConfig };\r\n    var schema = cloneSchema(subschemaConfig.schema);\r\n    stripResolvers(schema);\r\n    var resolvers = generateProxyingResolvers({\r\n        subschemaConfig: subschemaConfig,\r\n        transforms: transforms,\r\n    });\r\n    addResolversToSchema({ schema: schema, resolvers: resolvers });\r\n    var schemaTransforms = [];\r\n    if (subschemaConfig.transforms != null) {\r\n        schemaTransforms = schemaTransforms.concat(subschemaConfig.transforms);\r\n    }\r\n    if (transforms != null) {\r\n        schemaTransforms = schemaTransforms.concat(transforms);\r\n    }\r\n    return applySchemaTransforms(schema, schemaTransforms);\r\n}\n\nvar backcompatOptions = { commentDescriptions: true };\r\nfunction typeFromAST(node) {\r\n    switch (node.kind) {\r\n        case Kind.OBJECT_TYPE_DEFINITION:\r\n            return makeObjectType(node);\r\n        case Kind.INTERFACE_TYPE_DEFINITION:\r\n            return makeInterfaceType(node);\r\n        case Kind.ENUM_TYPE_DEFINITION:\r\n            return makeEnumType(node);\r\n        case Kind.UNION_TYPE_DEFINITION:\r\n            return makeUnionType(node);\r\n        case Kind.SCALAR_TYPE_DEFINITION:\r\n            return makeScalarType(node);\r\n        case Kind.INPUT_OBJECT_TYPE_DEFINITION:\r\n            return makeInputObjectType(node);\r\n        case Kind.DIRECTIVE_DEFINITION:\r\n            return makeDirective(node);\r\n        default:\r\n            return null;\r\n    }\r\n}\r\nfunction makeObjectType(node) {\r\n    var config = {\r\n        name: node.name.value,\r\n        fields: function () { return makeFields(node.fields); },\r\n        interfaces: function () {\r\n            return node.interfaces.map(function (iface) {\r\n                return createNamedStub(iface.name.value, 'interface');\r\n            });\r\n        },\r\n        description: getDescription(node, backcompatOptions),\r\n    };\r\n    return new GraphQLObjectType(config);\r\n}\r\nfunction makeInterfaceType(node) {\r\n    var config = {\r\n        name: node.name.value,\r\n        fields: function () { return makeFields(node.fields); },\r\n        interfaces: graphqlVersion() >= 15\r\n            ? function () {\r\n                return node.interfaces.map(function (iface) {\r\n                    return createNamedStub(iface.name.value, 'interface');\r\n                });\r\n            }\r\n            : undefined,\r\n        description: getDescription(node, backcompatOptions),\r\n        resolveType: function (parent) { return resolveFromParentTypename(parent); },\r\n    };\r\n    return new GraphQLInterfaceType(config);\r\n}\r\nfunction makeEnumType(node) {\r\n    var values = keyValMap(node.values, function (value) { return value.name.value; }, function (value) { return ({\r\n        description: getDescription(value, backcompatOptions),\r\n    }); });\r\n    return new GraphQLEnumType({\r\n        name: node.name.value,\r\n        values: values,\r\n        description: getDescription(node, backcompatOptions),\r\n    });\r\n}\r\nfunction makeUnionType(node) {\r\n    return new GraphQLUnionType({\r\n        name: node.name.value,\r\n        types: function () {\r\n            return node.types.map(function (type) { return createNamedStub(type.name.value, 'object'); });\r\n        },\r\n        description: getDescription(node, backcompatOptions),\r\n        resolveType: function (parent) { return resolveFromParentTypename(parent); },\r\n    });\r\n}\r\nfunction makeScalarType(node) {\r\n    return new GraphQLScalarType({\r\n        name: node.name.value,\r\n        description: getDescription(node, backcompatOptions),\r\n        serialize: function () { return null; },\r\n        // Note: validation calls the parse functions to determine if a\r\n        // literal value is correct. Returning null would cause use of custom\r\n        // scalars to always fail validation. Returning false causes them to\r\n        // always pass validation.\r\n        parseValue: function () { return false; },\r\n        parseLiteral: function () { return false; },\r\n    });\r\n}\r\nfunction makeInputObjectType(node) {\r\n    return new GraphQLInputObjectType({\r\n        name: node.name.value,\r\n        fields: function () { return makeValues(node.fields); },\r\n        description: getDescription(node, backcompatOptions),\r\n    });\r\n}\r\nfunction makeFields(nodes) {\r\n    return keyValMap(nodes, function (node) { return node.name.value; }, function (node) {\r\n        var deprecatedDirective = node.directives.find(function (directive) { return directive.name.value === 'deprecated'; });\r\n        var deprecationReason;\r\n        if (deprecatedDirective != null) {\r\n            var deprecatedArgument = deprecatedDirective.arguments.find(function (arg) { return arg.name.value === 'reason'; });\r\n            deprecationReason = deprecatedArgument.value.value;\r\n        }\r\n        return {\r\n            type: createStub(node.type, 'output'),\r\n            args: makeValues(node.arguments),\r\n            description: getDescription(node, backcompatOptions),\r\n            deprecationReason: deprecationReason,\r\n        };\r\n    });\r\n}\r\nfunction makeValues(nodes) {\r\n    return keyValMap(nodes, function (node) { return node.name.value; }, function (node) {\r\n        var type = createStub(node.type, 'input');\r\n        return {\r\n            type: type,\r\n            defaultValue: node.defaultValue,\r\n            description: getDescription(node, backcompatOptions),\r\n        };\r\n    });\r\n}\r\nfunction makeDirective(node) {\r\n    var locations = [];\r\n    node.locations.forEach(function (location) {\r\n        if (location.value in DirectiveLocation) {\r\n            locations.push(location.value);\r\n        }\r\n    });\r\n    return new GraphQLDirective({\r\n        name: node.name.value,\r\n        description: node.description != null ? node.description.value : null,\r\n        args: makeValues(node.arguments),\r\n        locations: locations,\r\n    });\r\n}\r\n// graphql < v13 does not export getDescription\r\nfunction getDescription(node, options) {\r\n    if (node.description != null) {\r\n        return node.description.value;\r\n    }\r\n    if (options.commentDescriptions) {\r\n        var rawValue = getLeadingCommentBlock(node);\r\n        if (rawValue !== undefined) {\r\n            return dedentBlockStringValue(\"\\n\" + rawValue);\r\n        }\r\n    }\r\n}\r\nfunction getLeadingCommentBlock(node) {\r\n    var loc = node.loc;\r\n    if (!loc) {\r\n        return;\r\n    }\r\n    var comments = [];\r\n    var token = loc.startToken.prev;\r\n    while (token != null &&\r\n        token.kind === TokenKind.COMMENT &&\r\n        token.next != null &&\r\n        token.prev != null &&\r\n        token.line + 1 === token.next.line &&\r\n        token.line !== token.prev.line) {\r\n        var value = String(token.value);\r\n        comments.push(value);\r\n        token = token.prev;\r\n    }\r\n    return comments.length > 0 ? comments.reverse().join('\\n') : undefined;\r\n}\r\nfunction dedentBlockStringValue(rawString) {\r\n    // Expand a block string's raw value into independent lines.\r\n    var lines = rawString.split(/\\r\\n|[\\n\\r]/g);\r\n    // Remove common indentation from all lines but first.\r\n    var commonIndent = getBlockStringIndentation(lines);\r\n    if (commonIndent !== 0) {\r\n        for (var i = 1; i < lines.length; i++) {\r\n            lines[i] = lines[i].slice(commonIndent);\r\n        }\r\n    }\r\n    // Remove leading and trailing blank lines.\r\n    while (lines.length > 0 && isBlank(lines[0])) {\r\n        lines.shift();\r\n    }\r\n    while (lines.length > 0 && isBlank(lines[lines.length - 1])) {\r\n        lines.pop();\r\n    }\r\n    // Return a string of the lines joined with U+000A.\r\n    return lines.join('\\n');\r\n}\r\n/**\r\n * @internal\r\n */\r\nfunction getBlockStringIndentation(lines) {\r\n    var commonIndent = null;\r\n    for (var i = 1; i < lines.length; i++) {\r\n        var line = lines[i];\r\n        var indent = leadingWhitespace(line);\r\n        if (indent === line.length) {\r\n            continue; // skip empty lines\r\n        }\r\n        if (commonIndent === null || indent < commonIndent) {\r\n            commonIndent = indent;\r\n            if (commonIndent === 0) {\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    return commonIndent === null ? 0 : commonIndent;\r\n}\r\nfunction leadingWhitespace(str) {\r\n    var i = 0;\r\n    while (i < str.length && (str[i] === ' ' || str[i] === '\\t')) {\r\n        i++;\r\n    }\r\n    return i;\r\n}\r\nfunction isBlank(str) {\r\n    return leadingWhitespace(str) === str.length;\r\n}\n\nfunction concatInlineFragments(type, fragments) {\r\n    var fragmentSelections = fragments.reduce(function (selections, fragment) {\r\n        return selections.concat(fragment.selectionSet.selections);\r\n    }, []);\r\n    var deduplicatedFragmentSelection = deduplicateSelection(fragmentSelections);\r\n    return {\r\n        kind: Kind.INLINE_FRAGMENT,\r\n        typeCondition: {\r\n            kind: Kind.NAMED_TYPE,\r\n            name: {\r\n                kind: Kind.NAME,\r\n                value: type,\r\n            },\r\n        },\r\n        selectionSet: {\r\n            kind: Kind.SELECTION_SET,\r\n            selections: deduplicatedFragmentSelection,\r\n        },\r\n    };\r\n}\r\nfunction deduplicateSelection(nodes) {\r\n    var selectionMap = nodes.reduce(function (map, node) {\r\n        var _a, _b, _c;\r\n        switch (node.kind) {\r\n            case 'Field': {\r\n                if (node.alias != null) {\r\n                    if (node.alias.value in map) {\r\n                        return map;\r\n                    }\r\n                    return __assign(__assign({}, map), (_a = {}, _a[node.alias.value] = node, _a));\r\n                }\r\n                if (node.name.value in map) {\r\n                    return map;\r\n                }\r\n                return __assign(__assign({}, map), (_b = {}, _b[node.name.value] = node, _b));\r\n            }\r\n            case 'FragmentSpread': {\r\n                if (node.name.value in map) {\r\n                    return map;\r\n                }\r\n                return __assign(__assign({}, map), (_c = {}, _c[node.name.value] = node, _c));\r\n            }\r\n            case 'InlineFragment': {\r\n                if (map.__fragment != null) {\r\n                    var fragment = map.__fragment;\r\n                    return __assign(__assign({}, map), { __fragment: concatInlineFragments(fragment.typeCondition.name.value, [fragment, node]) });\r\n                }\r\n                return __assign(__assign({}, map), { __fragment: node });\r\n            }\r\n            default: {\r\n                return map;\r\n            }\r\n        }\r\n    }, Object.create(null));\r\n    var selection = Object.keys(selectionMap).reduce(function (selectionList, node) { return selectionList.concat(selectionMap[node]); }, []);\r\n    return selection;\r\n}\r\nfunction parseFragmentToInlineFragment(definitions) {\r\n    if (definitions.trim().startsWith('fragment')) {\r\n        var document_1 = parse(definitions);\r\n        for (var _i = 0, _a = document_1.definitions; _i < _a.length; _i++) {\r\n            var definition = _a[_i];\r\n            if (definition.kind === Kind.FRAGMENT_DEFINITION) {\r\n                return {\r\n                    kind: Kind.INLINE_FRAGMENT,\r\n                    typeCondition: definition.typeCondition,\r\n                    selectionSet: definition.selectionSet,\r\n                };\r\n            }\r\n        }\r\n    }\r\n    var query = parse(\"{\" + definitions + \"}\")\r\n        .definitions[0];\r\n    for (var _b = 0, _c = query.selectionSet.selections; _b < _c.length; _b++) {\r\n        var selection = _c[_b];\r\n        if (selection.kind === Kind.INLINE_FRAGMENT) {\r\n            return selection;\r\n        }\r\n    }\r\n    throw new Error('Could not parse fragment');\r\n}\n\nfunction parseSelectionSet(selectionSet) {\r\n    var query = parse(selectionSet).definitions[0];\r\n    return query.selectionSet;\r\n}\r\nfunction typeContainsSelectionSet(type, selectionSet) {\r\n    var fields = type.getFields();\r\n    for (var _i = 0, _a = selectionSet.selections; _i < _a.length; _i++) {\r\n        var selection = _a[_i];\r\n        if (selection.kind === Kind.FIELD) {\r\n            var field = fields[selection.name.value];\r\n            if (field == null) {\r\n                return false;\r\n            }\r\n            if (selection.selectionSet != null) {\r\n                return typeContainsSelectionSet(getNamedType(field.type), selection.selectionSet);\r\n            }\r\n        }\r\n        else if (selection.kind === Kind.INLINE_FRAGMENT) {\r\n            var containsSelectionSet = typeContainsSelectionSet(type, selection.selectionSet);\r\n            if (!containsSelectionSet) {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n    return true;\r\n}\n\nfunction createMergeInfo(allSchemas, typeCandidates, mergeTypes) {\r\n    return {\r\n        delegate: function (operation, fieldName, args, context, info, transforms) {\r\n            if (transforms === void 0) { transforms = []; }\r\n            var schema = guessSchemaByRootField(allSchemas, operation, fieldName);\r\n            var expandTransforms = new ExpandAbstractTypes(info.schema, schema);\r\n            var fragmentTransform = new AddReplacementFragments(schema, info.mergeInfo.replacementFragments);\r\n            return delegateToSchema({\r\n                schema: schema,\r\n                operation: operation,\r\n                fieldName: fieldName,\r\n                args: args,\r\n                context: context,\r\n                info: info,\r\n                transforms: __spreadArrays(transforms, [expandTransforms, fragmentTransform]),\r\n            });\r\n        },\r\n        delegateToSchema: function (options) {\r\n            return delegateToSchema(__assign(__assign({}, options), { transforms: options.transforms }));\r\n        },\r\n        fragments: [],\r\n        replacementSelectionSets: undefined,\r\n        replacementFragments: undefined,\r\n        mergedTypes: createMergedTypes(typeCandidates, mergeTypes),\r\n    };\r\n}\r\nfunction createMergedTypes(typeCandidates, mergeTypes) {\r\n    var mergedTypes = Object.create(null);\r\n    Object.keys(typeCandidates).forEach(function (typeName) {\r\n        if (isObjectType(typeCandidates[typeName][0].type)) {\r\n            var mergedTypeCandidates = typeCandidates[typeName].filter(function (typeCandidate) {\r\n                return typeCandidate.subschema != null &&\r\n                    isSubschemaConfig(typeCandidate.subschema) &&\r\n                    typeCandidate.subschema.merge != null &&\r\n                    hasOwnProperty(typeCandidate.subschema.merge, typeName);\r\n            });\r\n            if (mergeTypes === true ||\r\n                (typeof mergeTypes === 'function' &&\r\n                    mergeTypes(typeName, typeCandidates[typeName])) ||\r\n                (Array.isArray(mergeTypes) && mergeTypes.includes(typeName)) ||\r\n                mergedTypeCandidates.length) {\r\n                var subschemas_1 = [];\r\n                var requiredSelections_1 = [\r\n                    parseSelectionSet('{ __typename }').selections[0],\r\n                ];\r\n                var fields_1 = Object.create({});\r\n                var typeMaps_1 = new Map();\r\n                var selectionSets_1 = new Map();\r\n                mergedTypeCandidates.forEach(function (typeCandidate) {\r\n                    var subschemaConfig = typeCandidate.subschema;\r\n                    var transformedSubschema = typeCandidate.transformedSubschema;\r\n                    typeMaps_1.set(subschemaConfig, transformedSubschema.getTypeMap());\r\n                    var type = transformedSubschema.getType(typeName);\r\n                    var fieldMap = type.getFields();\r\n                    Object.keys(fieldMap).forEach(function (fieldName) {\r\n                        if (!(fieldName in fields_1)) {\r\n                            fields_1[fieldName] = [];\r\n                        }\r\n                        fields_1[fieldName].push(subschemaConfig);\r\n                    });\r\n                    var mergedTypeConfig = subschemaConfig.merge[typeName];\r\n                    if (mergedTypeConfig.selectionSet) {\r\n                        var selectionSet = parseSelectionSet(mergedTypeConfig.selectionSet);\r\n                        requiredSelections_1 = requiredSelections_1.concat(selectionSet.selections);\r\n                        selectionSets_1.set(subschemaConfig, selectionSet);\r\n                    }\r\n                    if (!mergedTypeConfig.resolve) {\r\n                        mergedTypeConfig.resolve = function (originalResult, context, info, subschema, selectionSet) {\r\n                            return delegateToSchema({\r\n                                schema: subschema,\r\n                                operation: 'query',\r\n                                fieldName: mergedTypeConfig.fieldName,\r\n                                args: mergedTypeConfig.args(originalResult),\r\n                                selectionSet: selectionSet,\r\n                                context: context,\r\n                                info: info,\r\n                                skipTypeMerging: true,\r\n                            });\r\n                        };\r\n                    }\r\n                    subschemas_1.push(subschemaConfig);\r\n                });\r\n                mergedTypes[typeName] = {\r\n                    subschemas: subschemas_1,\r\n                    typeMaps: typeMaps_1,\r\n                    selectionSets: selectionSets_1,\r\n                    containsSelectionSet: new Map(),\r\n                    uniqueFields: Object.create({}),\r\n                    nonUniqueFields: Object.create({}),\r\n                };\r\n                subschemas_1.forEach(function (subschema) {\r\n                    var type = typeMaps_1.get(subschema)[typeName];\r\n                    var subschemaMap = new Map();\r\n                    subschemas_1\r\n                        .filter(function (s) { return s !== subschema; })\r\n                        .forEach(function (s) {\r\n                        var selectionSet = selectionSets_1.get(s);\r\n                        if (selectionSet != null &&\r\n                            typeContainsSelectionSet(type, selectionSet)) {\r\n                            subschemaMap.set(selectionSet, true);\r\n                        }\r\n                    });\r\n                    mergedTypes[typeName].containsSelectionSet.set(subschema, subschemaMap);\r\n                });\r\n                Object.keys(fields_1).forEach(function (fieldName) {\r\n                    var supportedBySubschemas = fields_1[fieldName];\r\n                    if (supportedBySubschemas.length === 1) {\r\n                        mergedTypes[typeName].uniqueFields[fieldName] =\r\n                            supportedBySubschemas[0];\r\n                    }\r\n                    else {\r\n                        mergedTypes[typeName].nonUniqueFields[fieldName] = supportedBySubschemas;\r\n                    }\r\n                });\r\n                mergedTypes[typeName].selectionSet = {\r\n                    kind: Kind.SELECTION_SET,\r\n                    selections: requiredSelections_1,\r\n                };\r\n            }\r\n        }\r\n    });\r\n    return mergedTypes;\r\n}\r\nfunction completeMergeInfo(mergeInfo, resolvers) {\r\n    var replacementSelectionSets = Object.create(null);\r\n    Object.keys(resolvers).forEach(function (typeName) {\r\n        var type = resolvers[typeName];\r\n        if (isScalarType(type)) {\r\n            return;\r\n        }\r\n        Object.keys(type).forEach(function (fieldName) {\r\n            var field = type[fieldName];\r\n            if (field.selectionSet) {\r\n                var selectionSet = parseSelectionSet(field.selectionSet);\r\n                if (!(typeName in replacementSelectionSets)) {\r\n                    replacementSelectionSets[typeName] = Object.create(null);\r\n                }\r\n                var typeReplacementSelectionSets = replacementSelectionSets[typeName];\r\n                if (!(fieldName in typeReplacementSelectionSets)) {\r\n                    typeReplacementSelectionSets[fieldName] = {\r\n                        kind: Kind.SELECTION_SET,\r\n                        selections: [],\r\n                    };\r\n                }\r\n                typeReplacementSelectionSets[fieldName].selections = typeReplacementSelectionSets[fieldName].selections.concat(selectionSet.selections);\r\n            }\r\n            if (field.fragment) {\r\n                mergeInfo.fragments.push({\r\n                    field: fieldName,\r\n                    fragment: field.fragment,\r\n                });\r\n            }\r\n        });\r\n    });\r\n    var mapping = Object.create(null);\r\n    mergeInfo.fragments.forEach(function (_a) {\r\n        var field = _a.field, fragment = _a.fragment;\r\n        var parsedFragment = parseFragmentToInlineFragment(fragment);\r\n        var actualTypeName = parsedFragment.typeCondition.name.value;\r\n        if (!(actualTypeName in mapping)) {\r\n            mapping[actualTypeName] = Object.create(null);\r\n        }\r\n        var typeMapping = mapping[actualTypeName];\r\n        if (!(field in typeMapping)) {\r\n            typeMapping[field] = [];\r\n        }\r\n        typeMapping[field].push(parsedFragment);\r\n    });\r\n    var replacementFragments = Object.create(null);\r\n    Object.keys(mapping).forEach(function (typeName) {\r\n        Object.keys(mapping[typeName]).forEach(function (field) {\r\n            if (!(typeName in replacementFragments)) {\r\n                replacementFragments[typeName] = Object.create(null);\r\n            }\r\n            var typeReplacementFragments = replacementFragments[typeName];\r\n            typeReplacementFragments[field] = concatInlineFragments(typeName, mapping[typeName][field]);\r\n        });\r\n    });\r\n    mergeInfo.replacementSelectionSets = replacementSelectionSets;\r\n    mergeInfo.replacementFragments = replacementFragments;\r\n    return mergeInfo;\r\n}\r\nfunction operationToRootType(operation, schema) {\r\n    if (operation === 'subscription') {\r\n        return schema.getSubscriptionType();\r\n    }\r\n    else if (operation === 'mutation') {\r\n        return schema.getMutationType();\r\n    }\r\n    return schema.getQueryType();\r\n}\r\nfunction guessSchemaByRootField(schemas, operation, fieldName) {\r\n    for (var _i = 0, schemas_1 = schemas; _i < schemas_1.length; _i++) {\r\n        var schema = schemas_1[_i];\r\n        var rootObject = operationToRootType(operation, schema);\r\n        if (rootObject != null) {\r\n            var fields = rootObject.getFields();\r\n            if (fieldName in fields) {\r\n                return schema;\r\n            }\r\n        }\r\n    }\r\n    throw new Error(\"Could not find subschema with field `\" + operation + \".\" + fieldName + \"`\");\r\n}\n\nfunction mergeSchemas(_a) {\r\n    var _b = _a.subschemas, subschemas = _b === void 0 ? [] : _b, _c = _a.types, types = _c === void 0 ? [] : _c, typeDefs = _a.typeDefs, _d = _a.schemas, schemaLikeObjects = _d === void 0 ? [] : _d, onTypeConflict = _a.onTypeConflict, _e = _a.resolvers, resolvers = _e === void 0 ? {} : _e, schemaDirectives = _a.schemaDirectives, inheritResolversFromInterfaces = _a.inheritResolversFromInterfaces, _f = _a.mergeTypes, mergeTypes = _f === void 0 ? false : _f, mergeDirectives = _a.mergeDirectives, _g = _a.queryTypeName, queryTypeName = _g === void 0 ? 'Query' : _g, _h = _a.mutationTypeName, mutationTypeName = _h === void 0 ? 'Mutation' : _h, _j = _a.subscriptionTypeName, subscriptionTypeName = _j === void 0 ? 'Subscription' : _j;\r\n    var allSchemas = [];\r\n    var typeCandidates = Object.create(null);\r\n    var typeMap = Object.create(null);\r\n    var extensions = [];\r\n    var directives = [];\r\n    var schemas = __spreadArrays(subschemas);\r\n    if (typeDefs) {\r\n        schemas.push(typeDefs);\r\n    }\r\n    if (types != null) {\r\n        schemas.push(types);\r\n    }\r\n    schemas = __spreadArrays(schemas, schemaLikeObjects);\r\n    schemas.forEach(function (schemaLikeObject) {\r\n        var _a;\r\n        if (isSchema(schemaLikeObject) || isSubschemaConfig(schemaLikeObject)) {\r\n            var schema_1 = wrapSchema(schemaLikeObject);\r\n            allSchemas.push(schema_1);\r\n            var operationTypes_1 = (_a = {},\r\n                _a[queryTypeName] = schema_1.getQueryType(),\r\n                _a[mutationTypeName] = schema_1.getMutationType(),\r\n                _a[subscriptionTypeName] = schema_1.getSubscriptionType(),\r\n                _a);\r\n            Object.keys(operationTypes_1).forEach(function (typeName) {\r\n                if (operationTypes_1[typeName] != null) {\r\n                    addTypeCandidate(typeCandidates, typeName, {\r\n                        schema: schema_1,\r\n                        type: operationTypes_1[typeName],\r\n                        subschema: schemaLikeObject,\r\n                        transformedSubschema: schema_1,\r\n                    });\r\n                }\r\n            });\r\n            if (mergeDirectives) {\r\n                var directiveInstances = schema_1.getDirectives();\r\n                directiveInstances.forEach(function (directive) {\r\n                    directives.push(directive);\r\n                });\r\n            }\r\n            var originalTypeMap_1 = schema_1.getTypeMap();\r\n            Object.keys(originalTypeMap_1).forEach(function (typeName) {\r\n                var type = originalTypeMap_1[typeName];\r\n                if (isNamedType(type) &&\r\n                    getNamedType(type).name.slice(0, 2) !== '__' &&\r\n                    type !== operationTypes_1.Query &&\r\n                    type !== operationTypes_1.Mutation &&\r\n                    type !== operationTypes_1.Subscription) {\r\n                    addTypeCandidate(typeCandidates, type.name, {\r\n                        schema: schema_1,\r\n                        type: type,\r\n                        subschema: schemaLikeObject,\r\n                        transformedSubschema: schema_1,\r\n                    });\r\n                }\r\n            });\r\n        }\r\n        else if (typeof schemaLikeObject === 'string' ||\r\n            (schemaLikeObject != null &&\r\n                schemaLikeObject.kind === Kind.DOCUMENT)) {\r\n            var parsedSchemaDocument = typeof schemaLikeObject === 'string'\r\n                ? parse(schemaLikeObject)\r\n                : schemaLikeObject;\r\n            parsedSchemaDocument.definitions.forEach(function (def) {\r\n                var type = typeFromAST(def);\r\n                if (isDirective(type) && mergeDirectives) {\r\n                    directives.push(type);\r\n                }\r\n                else if (type != null && !isDirective(type)) {\r\n                    addTypeCandidate(typeCandidates, type.name, {\r\n                        type: type,\r\n                    });\r\n                }\r\n            });\r\n            var extensionsDocument = extractExtensionDefinitions(parsedSchemaDocument);\r\n            if (extensionsDocument.definitions.length > 0) {\r\n                extensions.push(extensionsDocument);\r\n            }\r\n        }\r\n        else if (Array.isArray(schemaLikeObject)) {\r\n            schemaLikeObject.forEach(function (type) {\r\n                addTypeCandidate(typeCandidates, type.name, {\r\n                    type: type,\r\n                });\r\n            });\r\n        }\r\n        else {\r\n            throw new Error('Invalid schema passed');\r\n        }\r\n    });\r\n    var mergeInfo = createMergeInfo(allSchemas, typeCandidates, mergeTypes);\r\n    var finalResolvers;\r\n    if (typeof resolvers === 'function') {\r\n        finalResolvers = resolvers(mergeInfo);\r\n    }\r\n    else if (Array.isArray(resolvers)) {\r\n        finalResolvers = resolvers.reduce(function (left, right) {\r\n            return mergeDeep(left, typeof right === 'function' ? right(mergeInfo) : right);\r\n        }, {});\r\n        if (Array.isArray(resolvers)) {\r\n            finalResolvers = resolvers.reduce(mergeDeep, {});\r\n        }\r\n    }\r\n    else {\r\n        finalResolvers = resolvers;\r\n    }\r\n    if (finalResolvers == null) {\r\n        finalResolvers = {};\r\n    }\r\n    mergeInfo = completeMergeInfo(mergeInfo, finalResolvers);\r\n    Object.keys(typeCandidates).forEach(function (typeName) {\r\n        if (typeName === queryTypeName ||\r\n            typeName === mutationTypeName ||\r\n            typeName === subscriptionTypeName ||\r\n            (mergeTypes === true &&\r\n                !isScalarType(typeCandidates[typeName][0].type)) ||\r\n            (typeof mergeTypes === 'function' &&\r\n                mergeTypes(typeName, typeCandidates[typeName])) ||\r\n            (Array.isArray(mergeTypes) && mergeTypes.includes(typeName)) ||\r\n            typeName in mergeInfo.mergedTypes) {\r\n            typeMap[typeName] = merge(typeName, typeCandidates[typeName]);\r\n        }\r\n        else {\r\n            var candidateSelector = onTypeConflict != null\r\n                ? onTypeConflictToCandidateSelector(onTypeConflict)\r\n                : function (cands) { return cands[cands.length - 1]; };\r\n            typeMap[typeName] = candidateSelector(typeCandidates[typeName]).type;\r\n        }\r\n    });\r\n    healTypes(typeMap, directives, { skipPruning: true });\r\n    var mergedSchema = new GraphQLSchema({\r\n        query: typeMap[queryTypeName],\r\n        mutation: typeMap[mutationTypeName],\r\n        subscription: typeMap[subscriptionTypeName],\r\n        types: Object.keys(typeMap).map(function (key) { return typeMap[key]; }),\r\n        directives: directives.length\r\n            ? directives.map(function (directive) { return cloneDirective(directive); })\r\n            : undefined,\r\n    });\r\n    extensions.forEach(function (extension) {\r\n        mergedSchema = extendSchema(mergedSchema, extension, {\r\n            commentDescriptions: true,\r\n        });\r\n    });\r\n    addResolversToSchema({\r\n        schema: mergedSchema,\r\n        resolvers: finalResolvers,\r\n        inheritResolversFromInterfaces: inheritResolversFromInterfaces,\r\n    });\r\n    forEachField(mergedSchema, function (field) {\r\n        if (field.resolve != null) {\r\n            var fieldResolver_1 = field.resolve;\r\n            field.resolve = function (parent, args, context, info) {\r\n                var newInfo = __assign(__assign({}, info), { mergeInfo: mergeInfo });\r\n                return fieldResolver_1(parent, args, context, newInfo);\r\n            };\r\n        }\r\n        if (field.subscribe != null) {\r\n            var fieldResolver_2 = field.subscribe;\r\n            field.subscribe = function (parent, args, context, info) {\r\n                var newInfo = __assign(__assign({}, info), { mergeInfo: mergeInfo });\r\n                return fieldResolver_2(parent, args, context, newInfo);\r\n            };\r\n        }\r\n    });\r\n    if (schemaDirectives != null) {\r\n        SchemaDirectiveVisitor.visitSchemaDirectives(mergedSchema, schemaDirectives);\r\n    }\r\n    return mergedSchema;\r\n}\r\nfunction addTypeCandidate(typeCandidates, name, typeCandidate) {\r\n    if (!(name in typeCandidates)) {\r\n        typeCandidates[name] = [];\r\n    }\r\n    typeCandidates[name].push(typeCandidate);\r\n}\r\nfunction onTypeConflictToCandidateSelector(onTypeConflict) {\r\n    return function (cands) {\r\n        return cands.reduce(function (prev, next) {\r\n            var type = onTypeConflict(prev.type, next.type, {\r\n                left: {\r\n                    schema: prev.schema,\r\n                },\r\n                right: {\r\n                    schema: next.schema,\r\n                },\r\n            });\r\n            if (prev.type === type) {\r\n                return prev;\r\n            }\r\n            else if (next.type === type) {\r\n                return next;\r\n            }\r\n            return {\r\n                schemaName: 'unknown',\r\n                type: type,\r\n            };\r\n        });\r\n    };\r\n}\r\nfunction merge(typeName, candidates) {\r\n    var initialCandidateType = candidates[0].type;\r\n    if (candidates.some(function (candidate) {\r\n        return candidate.type.constructor !== initialCandidateType.constructor;\r\n    })) {\r\n        throw new Error(\"Cannot merge different type categories into common type \" + typeName + \".\");\r\n    }\r\n    if (isObjectType(initialCandidateType)) {\r\n        return new GraphQLObjectType({\r\n            name: typeName,\r\n            fields: candidates.reduce(function (acc, candidate) { return (__assign(__assign({}, acc), toConfig(candidate.type).fields)); }, {}),\r\n            interfaces: candidates.reduce(function (acc, candidate) {\r\n                var interfaces = toConfig(candidate.type).interfaces;\r\n                return interfaces != null ? acc.concat(interfaces) : acc;\r\n            }, []),\r\n        });\r\n    }\r\n    else if (isInterfaceType(initialCandidateType)) {\r\n        var config = {\r\n            name: typeName,\r\n            fields: candidates.reduce(function (acc, candidate) { return (__assign(__assign({}, acc), toConfig(candidate.type).fields)); }, {}),\r\n            interfaces: graphqlVersion() >= 15\r\n                ? candidates.reduce(function (acc, candidate) {\r\n                    var interfaces = toConfig(candidate.type).interfaces;\r\n                    return interfaces != null ? acc.concat(interfaces) : acc;\r\n                }, [])\r\n                : undefined,\r\n        };\r\n        return new GraphQLInterfaceType(config);\r\n    }\r\n    else if (isUnionType(initialCandidateType)) {\r\n        return new GraphQLUnionType({\r\n            name: typeName,\r\n            types: candidates.reduce(function (acc, candidate) { return acc.concat(toConfig(candidate.type).types); }, []),\r\n        });\r\n    }\r\n    else if (isEnumType(initialCandidateType)) {\r\n        return new GraphQLEnumType({\r\n            name: typeName,\r\n            values: candidates.reduce(function (acc, candidate) { return (__assign(__assign({}, acc), toConfig(candidate.type).values)); }, {}),\r\n        });\r\n    }\r\n    else if (isScalarType(initialCandidateType)) {\r\n        throw new Error(\"Cannot merge type \" + typeName + \". Merging not supported for GraphQLScalarType.\");\r\n    }\r\n    else {\r\n        // not reachable.\r\n        throw new Error(\"Type \" + typeName + \" has unknown GraphQL type.\");\r\n    }\r\n}\n\n// This function is deprecated in favor of wrapSchema as the name is misleading.\r\n// transformSchema does not just \"transform\" a schema, it wraps a schema with transforms\r\n// using a round of delegation.\r\n// The applySchemaTransforms function actually \"transforms\" the schema and is used during wrapping.\r\nfunction transformSchema(subschemaOrSubschemaConfig, transforms) {\r\n    var schema = wrapSchema(subschemaOrSubschemaConfig, transforms);\r\n    schema.transforms = transforms.slice().reverse();\r\n    return schema;\r\n}\n\nvar RenameTypes = /** @class */ (function () {\r\n    function RenameTypes(renamer, options) {\r\n        this.renamer = renamer;\r\n        this.map = Object.create(null);\r\n        this.reverseMap = Object.create(null);\r\n        var _a = options != null ? options : {}, _b = _a.renameBuiltins, renameBuiltins = _b === void 0 ? false : _b, _c = _a.renameScalars, renameScalars = _c === void 0 ? true : _c;\r\n        this.renameBuiltins = renameBuiltins;\r\n        this.renameScalars = renameScalars;\r\n    }\r\n    RenameTypes.prototype.transformSchema = function (originalSchema) {\r\n        var _a;\r\n        var _this = this;\r\n        return mapSchema(originalSchema, (_a = {},\r\n            _a[MapperKind.TYPE] = function (type) {\r\n                if (isSpecifiedScalarType(type) && !_this.renameBuiltins) {\r\n                    return undefined;\r\n                }\r\n                if (isScalarType(type) && !_this.renameScalars) {\r\n                    return undefined;\r\n                }\r\n                var oldName = type.name;\r\n                var newName = _this.renamer(oldName);\r\n                if (newName !== undefined && newName !== oldName) {\r\n                    _this.map[oldName] = newName;\r\n                    _this.reverseMap[newName] = oldName;\r\n                    var newConfig = __assign(__assign({}, toConfig(type)), { name: newName });\r\n                    if (isObjectType(type)) {\r\n                        return new GraphQLObjectType(newConfig);\r\n                    }\r\n                    else if (isInterfaceType(type)) {\r\n                        return new GraphQLInterfaceType(newConfig);\r\n                    }\r\n                    else if (isUnionType(type)) {\r\n                        return new GraphQLUnionType(newConfig);\r\n                    }\r\n                    else if (isInputObjectType(type)) {\r\n                        return new GraphQLInputObjectType(newConfig);\r\n                    }\r\n                    else if (isEnumType(type)) {\r\n                        return new GraphQLEnumType(newConfig);\r\n                    }\r\n                    else if (isScalarType(type)) {\r\n                        return new GraphQLScalarType(newConfig);\r\n                    }\r\n                    throw new Error(\"Unknown type \" + type + \".\");\r\n                }\r\n            },\r\n            _a[MapperKind.ROOT_OBJECT] = function () {\r\n                return undefined;\r\n            },\r\n            _a));\r\n    };\r\n    RenameTypes.prototype.transformRequest = function (originalRequest) {\r\n        var _a;\r\n        var _this = this;\r\n        var newDocument = visit(originalRequest.document, (_a = {},\r\n            _a[Kind.NAMED_TYPE] = function (node) {\r\n                var name = node.name.value;\r\n                if (name in _this.reverseMap) {\r\n                    return __assign(__assign({}, node), { name: {\r\n                            kind: Kind.NAME,\r\n                            value: _this.reverseMap[name],\r\n                        } });\r\n                }\r\n            },\r\n            _a));\r\n        return {\r\n            document: newDocument,\r\n            variables: originalRequest.variables,\r\n        };\r\n    };\r\n    RenameTypes.prototype.transformResult = function (result) {\r\n        return __assign(__assign({}, result), { data: this.transformData(result.data) });\r\n    };\r\n    RenameTypes.prototype.transformData = function (data) {\r\n        var _this = this;\r\n        if (data == null) {\r\n            return data;\r\n        }\r\n        else if (Array.isArray(data)) {\r\n            return data.map(function (value) { return _this.transformData(value); });\r\n        }\r\n        else if (typeof data === 'object') {\r\n            return this.transformObject(data);\r\n        }\r\n        return data;\r\n    };\r\n    RenameTypes.prototype.transformObject = function (object) {\r\n        var _this = this;\r\n        Object.keys(object).forEach(function (key) {\r\n            var value = object[key];\r\n            if (key === '__typename') {\r\n                if (value in _this.map) {\r\n                    object[key] = _this.map[value];\r\n                }\r\n            }\r\n            else {\r\n                object[key] = _this.transformData(value);\r\n            }\r\n        });\r\n        return object;\r\n    };\r\n    return RenameTypes;\r\n}());\n\nvar FilterTypes = /** @class */ (function () {\r\n    function FilterTypes(filter) {\r\n        this.filter = filter;\r\n    }\r\n    FilterTypes.prototype.transformSchema = function (schema) {\r\n        var _a;\r\n        var _this = this;\r\n        return mapSchema(schema, (_a = {},\r\n            _a[MapperKind.TYPE] = function (type) {\r\n                if (_this.filter(type)) {\r\n                    return undefined;\r\n                }\r\n                return null;\r\n            },\r\n            _a));\r\n    };\r\n    return FilterTypes;\r\n}());\n\nvar RenameRootTypes = /** @class */ (function () {\r\n    function RenameRootTypes(renamer) {\r\n        this.renamer = renamer;\r\n        this.map = Object.create(null);\r\n        this.reverseMap = Object.create(null);\r\n    }\r\n    RenameRootTypes.prototype.transformSchema = function (originalSchema) {\r\n        var _a;\r\n        var _this = this;\r\n        return mapSchema(originalSchema, (_a = {},\r\n            _a[MapperKind.ROOT_OBJECT] = function (type) {\r\n                var oldName = type.name;\r\n                var newName = _this.renamer(oldName);\r\n                if (newName !== undefined && newName !== oldName) {\r\n                    _this.map[oldName] = newName;\r\n                    _this.reverseMap[newName] = oldName;\r\n                    return new GraphQLObjectType(__assign(__assign({}, toConfig(type)), { name: newName }));\r\n                }\r\n            },\r\n            _a));\r\n    };\r\n    RenameRootTypes.prototype.transformRequest = function (originalRequest) {\r\n        var _a;\r\n        var _this = this;\r\n        var newDocument = visit(originalRequest.document, (_a = {},\r\n            _a[Kind.NAMED_TYPE] = function (node) {\r\n                var name = node.name.value;\r\n                if (name in _this.reverseMap) {\r\n                    return __assign(__assign({}, node), { name: {\r\n                            kind: Kind.NAME,\r\n                            value: _this.reverseMap[name],\r\n                        } });\r\n                }\r\n            },\r\n            _a));\r\n        return {\r\n            document: newDocument,\r\n            variables: originalRequest.variables,\r\n        };\r\n    };\r\n    RenameRootTypes.prototype.transformResult = function (result) {\r\n        return __assign(__assign({}, result), { data: this.transformData(result.data) });\r\n    };\r\n    RenameRootTypes.prototype.transformData = function (data) {\r\n        var _this = this;\r\n        if (data == null) {\r\n            return data;\r\n        }\r\n        else if (Array.isArray(data)) {\r\n            return data.map(function (value) { return _this.transformData(value); });\r\n        }\r\n        else if (typeof data === 'object') {\r\n            return this.transformObject(data);\r\n        }\r\n        return data;\r\n    };\r\n    RenameRootTypes.prototype.transformObject = function (object) {\r\n        var _this = this;\r\n        Object.keys(object).forEach(function (key) {\r\n            var value = object[key];\r\n            if (key === '__typename') {\r\n                if (value in _this.map) {\r\n                    object[key] = _this.map[value];\r\n                }\r\n            }\r\n            else {\r\n                object[key] = _this.transformData(value);\r\n            }\r\n        });\r\n        return object;\r\n    };\r\n    return RenameRootTypes;\r\n}());\n\nfunction isEmptyObject(obj) {\r\n    if (obj == null) {\r\n        return true;\r\n    }\r\n    return Object.keys(obj).length === 0;\r\n}\n\nvar TransformCompositeFields = /** @class */ (function () {\r\n    function TransformCompositeFields(fieldTransformer, fieldNodeTransformer) {\r\n        this.fieldTransformer = fieldTransformer;\r\n        this.fieldNodeTransformer = fieldNodeTransformer;\r\n        this.mapping = {};\r\n    }\r\n    TransformCompositeFields.prototype.transformSchema = function (originalSchema) {\r\n        var _a;\r\n        var _this = this;\r\n        this.transformedSchema = mapSchema(originalSchema, (_a = {},\r\n            _a[MapperKind.OBJECT_TYPE] = function (type) {\r\n                return _this.transformFields(type, _this.fieldTransformer);\r\n            },\r\n            _a[MapperKind.INTERFACE_TYPE] = function (type) {\r\n                return _this.transformFields(type, _this.fieldTransformer);\r\n            },\r\n            _a));\r\n        return this.transformedSchema;\r\n    };\r\n    TransformCompositeFields.prototype.transformRequest = function (originalRequest) {\r\n        var fragments = Object.create(null);\r\n        originalRequest.document.definitions\r\n            .filter(function (def) { return def.kind === Kind.FRAGMENT_DEFINITION; })\r\n            .forEach(function (def) {\r\n            fragments[def.name.value] = def;\r\n        });\r\n        var document = this.transformDocument(originalRequest.document, this.mapping, this.fieldNodeTransformer, fragments);\r\n        return __assign(__assign({}, originalRequest), { document: document });\r\n    };\r\n    TransformCompositeFields.prototype.transformFields = function (type, fieldTransformer) {\r\n        var _this = this;\r\n        var typeConfig = toConfig(type);\r\n        var fields = type.getFields();\r\n        var newFields = {};\r\n        Object.keys(fields).forEach(function (fieldName) {\r\n            var field = fields[fieldName];\r\n            var transformedField = fieldTransformer(type.name, fieldName, field);\r\n            if (typeof transformedField === 'undefined') {\r\n                newFields[fieldName] = typeConfig.fields[fieldName];\r\n            }\r\n            else if (transformedField !== null) {\r\n                var newName = transformedField.name;\r\n                if (newName) {\r\n                    newFields[newName] =\r\n                        transformedField.field != null\r\n                            ? transformedField.field\r\n                            : typeConfig.fields[fieldName];\r\n                    if (newName !== fieldName) {\r\n                        var typeName = type.name;\r\n                        if (!(typeName in _this.mapping)) {\r\n                            _this.mapping[typeName] = {};\r\n                        }\r\n                        _this.mapping[typeName][newName] = fieldName;\r\n                    }\r\n                }\r\n                else {\r\n                    newFields[fieldName] = transformedField;\r\n                }\r\n            }\r\n        });\r\n        if (isEmptyObject(newFields)) {\r\n            return null;\r\n        }\r\n        if (isObjectType(type)) {\r\n            return new GraphQLObjectType(__assign(__assign({}, toConfig(type)), { fields: newFields }));\r\n        }\r\n        else if (isInterfaceType(type)) {\r\n            return new GraphQLInterfaceType(__assign(__assign({}, toConfig(type)), { fields: newFields }));\r\n        }\r\n    };\r\n    TransformCompositeFields.prototype.transformDocument = function (document, mapping, fieldNodeTransformer, fragments) {\r\n        var _a;\r\n        if (fragments === void 0) { fragments = {}; }\r\n        var typeInfo = new TypeInfo(this.transformedSchema);\r\n        var newDocument = visit(document, visitWithTypeInfo(typeInfo, {\r\n            leave: (_a = {},\r\n                _a[Kind.SELECTION_SET] = function (node) {\r\n                    var parentType = typeInfo.getParentType();\r\n                    if (parentType != null) {\r\n                        var parentTypeName_1 = parentType.name;\r\n                        var newSelections_1 = [];\r\n                        node.selections.forEach(function (selection) {\r\n                            if (selection.kind !== Kind.FIELD) {\r\n                                newSelections_1.push(selection);\r\n                                return;\r\n                            }\r\n                            var newName = selection.name.value;\r\n                            var transformedSelection = fieldNodeTransformer != null\r\n                                ? fieldNodeTransformer(parentTypeName_1, newName, selection, fragments)\r\n                                : selection;\r\n                            if (Array.isArray(transformedSelection)) {\r\n                                newSelections_1 = newSelections_1.concat(transformedSelection);\r\n                                return;\r\n                            }\r\n                            if (transformedSelection.kind !== Kind.FIELD) {\r\n                                newSelections_1.push(transformedSelection);\r\n                                return;\r\n                            }\r\n                            var typeMapping = mapping[parentTypeName_1];\r\n                            if (typeMapping == null) {\r\n                                newSelections_1.push(transformedSelection);\r\n                                return;\r\n                            }\r\n                            var oldName = mapping[parentTypeName_1][newName];\r\n                            if (oldName == null) {\r\n                                newSelections_1.push(transformedSelection);\r\n                                return;\r\n                            }\r\n                            newSelections_1.push(__assign(__assign({}, transformedSelection), { name: {\r\n                                    kind: Kind.NAME,\r\n                                    value: oldName,\r\n                                }, alias: {\r\n                                    kind: Kind.NAME,\r\n                                    value: newName,\r\n                                } }));\r\n                        });\r\n                        return __assign(__assign({}, node), { selections: newSelections_1 });\r\n                    }\r\n                },\r\n                _a),\r\n        }));\r\n        return newDocument;\r\n    };\r\n    return TransformCompositeFields;\r\n}());\n\nvar TransformObjectFields = /** @class */ (function () {\r\n    function TransformObjectFields(objectFieldTransformer, fieldNodeTransformer) {\r\n        this.objectFieldTransformer = objectFieldTransformer;\r\n        this.fieldNodeTransformer = fieldNodeTransformer;\r\n    }\r\n    TransformObjectFields.prototype.transformSchema = function (originalSchema) {\r\n        var _this = this;\r\n        var compositeToObjectFieldTransformer = function (typeName, fieldName, field) {\r\n            if (isObjectType(originalSchema.getType(typeName))) {\r\n                return _this.objectFieldTransformer(typeName, fieldName, field);\r\n            }\r\n            return undefined;\r\n        };\r\n        this.transformer = new TransformCompositeFields(compositeToObjectFieldTransformer, this.fieldNodeTransformer);\r\n        return this.transformer.transformSchema(originalSchema);\r\n    };\r\n    TransformObjectFields.prototype.transformRequest = function (originalRequest) {\r\n        return this.transformer.transformRequest(originalRequest);\r\n    };\r\n    return TransformObjectFields;\r\n}());\n\nvar TransformRootFields = /** @class */ (function () {\r\n    function TransformRootFields(rootFieldTransformer, fieldNodeTransformer) {\r\n        var rootToObjectFieldTransformer = function (typeName, fieldName, field) {\r\n            if (typeName === 'Query' ||\r\n                typeName === 'Mutation' ||\r\n                typeName === 'Subscription') {\r\n                return rootFieldTransformer(typeName, fieldName, field);\r\n            }\r\n            return undefined;\r\n        };\r\n        this.transformer = new TransformObjectFields(rootToObjectFieldTransformer, fieldNodeTransformer);\r\n    }\r\n    TransformRootFields.prototype.transformSchema = function (originalSchema) {\r\n        return this.transformer.transformSchema(originalSchema);\r\n    };\r\n    TransformRootFields.prototype.transformRequest = function (originalRequest) {\r\n        return this.transformer.transformRequest(originalRequest);\r\n    };\r\n    return TransformRootFields;\r\n}());\n\nvar RenameRootFields = /** @class */ (function () {\r\n    function RenameRootFields(renamer) {\r\n        this.transformer = new TransformRootFields(function (operation, fieldName, field) { return ({\r\n            name: renamer(operation, fieldName, field),\r\n        }); });\r\n    }\r\n    RenameRootFields.prototype.transformSchema = function (originalSchema) {\r\n        return this.transformer.transformSchema(originalSchema);\r\n    };\r\n    RenameRootFields.prototype.transformRequest = function (originalRequest) {\r\n        return this.transformer.transformRequest(originalRequest);\r\n    };\r\n    return RenameRootFields;\r\n}());\n\nvar FilterRootFields = /** @class */ (function () {\r\n    function FilterRootFields(filter) {\r\n        this.transformer = new TransformRootFields(function (operation, fieldName, field) {\r\n            if (filter(operation, fieldName, field)) {\r\n                return undefined;\r\n            }\r\n            return null;\r\n        });\r\n    }\r\n    FilterRootFields.prototype.transformSchema = function (originalSchema) {\r\n        return this.transformer.transformSchema(originalSchema);\r\n    };\r\n    return FilterRootFields;\r\n}());\n\nvar RenameObjectFields = /** @class */ (function () {\r\n    function RenameObjectFields(renamer) {\r\n        this.transformer = new TransformObjectFields(function (typeName, fieldName, field) { return ({\r\n            name: renamer(typeName, fieldName, field),\r\n        }); });\r\n    }\r\n    RenameObjectFields.prototype.transformSchema = function (originalSchema) {\r\n        return this.transformer.transformSchema(originalSchema);\r\n    };\r\n    RenameObjectFields.prototype.transformRequest = function (originalRequest) {\r\n        return this.transformer.transformRequest(originalRequest);\r\n    };\r\n    return RenameObjectFields;\r\n}());\n\nvar FilterObjectFields = /** @class */ (function () {\r\n    function FilterObjectFields(filter) {\r\n        this.transformer = new TransformObjectFields(function (typeName, fieldName, field) {\r\n            return filter(typeName, fieldName, field) ? undefined : null;\r\n        });\r\n    }\r\n    FilterObjectFields.prototype.transformSchema = function (originalSchema) {\r\n        return this.transformer.transformSchema(originalSchema);\r\n    };\r\n    return FilterObjectFields;\r\n}());\n\nvar TransformInterfaceFields = /** @class */ (function () {\r\n    function TransformInterfaceFields(interfaceFieldTransformer, fieldNodeTransformer) {\r\n        this.interfaceFieldTransformer = interfaceFieldTransformer;\r\n        this.fieldNodeTransformer = fieldNodeTransformer;\r\n    }\r\n    TransformInterfaceFields.prototype.transformSchema = function (originalSchema) {\r\n        var _this = this;\r\n        var compositeToObjectFieldTransformer = function (typeName, fieldName, field) {\r\n            if (isInterfaceType(originalSchema.getType(typeName))) {\r\n                return _this.interfaceFieldTransformer(typeName, fieldName, field);\r\n            }\r\n            return undefined;\r\n        };\r\n        this.transformer = new TransformCompositeFields(compositeToObjectFieldTransformer, this.fieldNodeTransformer);\r\n        return this.transformer.transformSchema(originalSchema);\r\n    };\r\n    TransformInterfaceFields.prototype.transformRequest = function (originalRequest) {\r\n        return this.transformer.transformRequest(originalRequest);\r\n    };\r\n    return TransformInterfaceFields;\r\n}());\n\nvar RenameInterfaceFields = /** @class */ (function () {\r\n    function RenameInterfaceFields(renamer) {\r\n        this.transformer = new TransformInterfaceFields(function (typeName, fieldName, field) { return ({\r\n            name: renamer(typeName, fieldName, field),\r\n        }); });\r\n    }\r\n    RenameInterfaceFields.prototype.transformSchema = function (originalSchema) {\r\n        return this.transformer.transformSchema(originalSchema);\r\n    };\r\n    RenameInterfaceFields.prototype.transformRequest = function (originalRequest) {\r\n        return this.transformer.transformRequest(originalRequest);\r\n    };\r\n    return RenameInterfaceFields;\r\n}());\n\nvar FilterInterfaceFields = /** @class */ (function () {\r\n    function FilterInterfaceFields(filter) {\r\n        this.transformer = new TransformInterfaceFields(function (typeName, fieldName, field) {\r\n            return filter(typeName, fieldName, field) ? undefined : null;\r\n        });\r\n    }\r\n    FilterInterfaceFields.prototype.transformSchema = function (originalSchema) {\r\n        return this.transformer.transformSchema(originalSchema);\r\n    };\r\n    return FilterInterfaceFields;\r\n}());\n\nvar TransformQuery = /** @class */ (function () {\r\n    function TransformQuery(_a) {\r\n        var path = _a.path, queryTransformer = _a.queryTransformer, _b = _a.resultTransformer, resultTransformer = _b === void 0 ? function (result) { return result; } : _b, _c = _a.errorPathTransformer, errorPathTransformer = _c === void 0 ? function (errorPath) { return [].concat(errorPath); } : _c, _d = _a.fragments, fragments = _d === void 0 ? {} : _d;\r\n        this.path = path;\r\n        this.queryTransformer = queryTransformer;\r\n        this.resultTransformer = resultTransformer;\r\n        this.errorPathTransformer = errorPathTransformer;\r\n        this.fragments = fragments;\r\n    }\r\n    TransformQuery.prototype.transformRequest = function (originalRequest) {\r\n        var _a;\r\n        var _this = this;\r\n        var document = originalRequest.document;\r\n        var pathLength = this.path.length;\r\n        var index = 0;\r\n        var newDocument = visit(document, (_a = {},\r\n            _a[Kind.FIELD] = {\r\n                enter: function (node) {\r\n                    if (index === pathLength || node.name.value !== _this.path[index]) {\r\n                        return false;\r\n                    }\r\n                    index++;\r\n                    if (index === pathLength) {\r\n                        var selectionSet = _this.queryTransformer(node.selectionSet, _this.fragments);\r\n                        return __assign(__assign({}, node), { selectionSet: selectionSet });\r\n                    }\r\n                },\r\n                leave: function () {\r\n                    index--;\r\n                },\r\n            },\r\n            _a));\r\n        return __assign(__assign({}, originalRequest), { document: newDocument });\r\n    };\r\n    TransformQuery.prototype.transformResult = function (originalResult) {\r\n        var data = this.transformData(originalResult.data);\r\n        var errors = originalResult.errors;\r\n        return {\r\n            data: data,\r\n            errors: errors != null ? this.transformErrors(errors) : undefined,\r\n        };\r\n    };\r\n    TransformQuery.prototype.transformData = function (data) {\r\n        var leafIndex = this.path.length - 1;\r\n        var index = 0;\r\n        var newData = data;\r\n        if (newData) {\r\n            var next = this.path[index];\r\n            while (index < leafIndex) {\r\n                if (data[next]) {\r\n                    newData = newData[next];\r\n                }\r\n                else {\r\n                    break;\r\n                }\r\n                index++;\r\n                next = this.path[index];\r\n            }\r\n            newData[next] = this.resultTransformer(newData[next]);\r\n        }\r\n        return newData;\r\n    };\r\n    TransformQuery.prototype.transformErrors = function (errors) {\r\n        var _this = this;\r\n        return errors.map(function (error) {\r\n            var path = error.path;\r\n            var match = true;\r\n            var index = 0;\r\n            while (index < _this.path.length) {\r\n                if (path[index] !== _this.path[index]) {\r\n                    match = false;\r\n                    break;\r\n                }\r\n                index++;\r\n            }\r\n            var newPath = match\r\n                ? path\r\n                    .slice(0, index)\r\n                    .concat(_this.errorPathTransformer(path.slice(index)))\r\n                : path;\r\n            return new GraphQLError(error.message, error.nodes, error.source, error.positions, newPath, error.originalError, error.extensions);\r\n        });\r\n    };\r\n    return TransformQuery;\r\n}());\n\nvar MapFields = /** @class */ (function () {\r\n    function MapFields(fieldNodeTransformerMap) {\r\n        this.transformer = new TransformObjectFields(function (_typeName, _fieldName, field) { return toConfig(field); }, function (typeName, fieldName, fieldNode, fragments) {\r\n            var typeTransformers = fieldNodeTransformerMap[typeName];\r\n            if (typeTransformers == null) {\r\n                return fieldNode;\r\n            }\r\n            var fieldNodeTransformer = typeTransformers[fieldName];\r\n            if (fieldNodeTransformer == null) {\r\n                return fieldNode;\r\n            }\r\n            return fieldNodeTransformer(fieldNode, fragments);\r\n        });\r\n    }\r\n    MapFields.prototype.transformSchema = function (schema) {\r\n        return this.transformer.transformSchema(schema);\r\n    };\r\n    MapFields.prototype.transformRequest = function (request) {\r\n        return this.transformer.transformRequest(request);\r\n    };\r\n    return MapFields;\r\n}());\n\nvar ExtendSchema = /** @class */ (function () {\r\n    function ExtendSchema(_a) {\r\n        var typeDefs = _a.typeDefs, _b = _a.resolvers, resolvers = _b === void 0 ? {} : _b, defaultFieldResolver = _a.defaultFieldResolver, fieldNodeTransformerMap = _a.fieldNodeTransformerMap;\r\n        this.typeDefs = typeDefs;\r\n        this.resolvers = resolvers;\r\n        this.defaultFieldResolver =\r\n            defaultFieldResolver != null\r\n                ? defaultFieldResolver\r\n                : defaultMergedResolver;\r\n        this.transformer = new MapFields(fieldNodeTransformerMap != null ? fieldNodeTransformerMap : {});\r\n    }\r\n    ExtendSchema.prototype.transformSchema = function (schema) {\r\n        this.transformer.transformSchema(schema);\r\n        return addResolversToSchema({\r\n            schema: this.typeDefs\r\n                ? extendSchema$1(schema, parse(this.typeDefs))\r\n                : schema,\r\n            resolvers: this.resolvers != null ? this.resolvers : {},\r\n            defaultFieldResolver: this.defaultFieldResolver,\r\n        });\r\n    };\r\n    ExtendSchema.prototype.transformRequest = function (originalRequest) {\r\n        return this.transformer.transformRequest(originalRequest);\r\n    };\r\n    return ExtendSchema;\r\n}());\n\nfunction renameFieldNode(fieldNode, name) {\r\n    return __assign(__assign({}, fieldNode), { alias: {\r\n            kind: Kind.NAME,\r\n            value: fieldNode.alias != null ? fieldNode.alias.value : fieldNode.name.value,\r\n        }, name: {\r\n            kind: Kind.NAME,\r\n            value: name,\r\n        } });\r\n}\r\nfunction preAliasFieldNode(fieldNode, str) {\r\n    return __assign(__assign({}, fieldNode), { alias: {\r\n            kind: Kind.NAME,\r\n            value: \"\" + str + (fieldNode.alias != null ? fieldNode.alias.value : fieldNode.name.value),\r\n        } });\r\n}\r\nfunction wrapFieldNode(fieldNode, path) {\r\n    var newFieldNode = fieldNode;\r\n    path.forEach(function (fieldName) {\r\n        newFieldNode = {\r\n            kind: Kind.FIELD,\r\n            name: {\r\n                kind: Kind.NAME,\r\n                value: fieldName,\r\n            },\r\n            selectionSet: {\r\n                kind: Kind.SELECTION_SET,\r\n                selections: [fieldNode],\r\n            },\r\n        };\r\n    });\r\n    return newFieldNode;\r\n}\r\nfunction collectFields$1(selectionSet, fragments, fields, visitedFragmentNames) {\r\n    if (fields === void 0) { fields = []; }\r\n    if (visitedFragmentNames === void 0) { visitedFragmentNames = {}; }\r\n    if (selectionSet != null) {\r\n        selectionSet.selections.forEach(function (selection) {\r\n            switch (selection.kind) {\r\n                case Kind.FIELD:\r\n                    fields.push(selection);\r\n                    break;\r\n                case Kind.INLINE_FRAGMENT:\r\n                    collectFields$1(selection.selectionSet, fragments, fields, visitedFragmentNames);\r\n                    break;\r\n                case Kind.FRAGMENT_SPREAD: {\r\n                    var fragmentName = selection.name.value;\r\n                    if (!visitedFragmentNames[fragmentName]) {\r\n                        visitedFragmentNames[fragmentName] = true;\r\n                        collectFields$1(fragments[fragmentName].selectionSet, fragments, fields, visitedFragmentNames);\r\n                    }\r\n                    break;\r\n                }\r\n            }\r\n        });\r\n    }\r\n    return fields;\r\n}\r\nfunction hoistFieldNodes(_a) {\r\n    var fieldNode = _a.fieldNode, fieldNames = _a.fieldNames, _b = _a.path, path = _b === void 0 ? [] : _b, _c = _a.delimeter, delimeter = _c === void 0 ? '__gqltf__' : _c, fragments = _a.fragments;\r\n    var alias = fieldNode.alias != null ? fieldNode.alias.value : fieldNode.name.value;\r\n    var newFieldNodes = [];\r\n    if (path.length) {\r\n        var remainingPathSegments_1 = path.slice();\r\n        var initialPathSegment_1 = remainingPathSegments_1.shift();\r\n        collectFields$1(fieldNode.selectionSet, fragments).forEach(function (possibleFieldNode) {\r\n            if (possibleFieldNode.name.value === initialPathSegment_1) {\r\n                newFieldNodes = newFieldNodes.concat(hoistFieldNodes({\r\n                    fieldNode: preAliasFieldNode(possibleFieldNode, \"\" + alias + delimeter),\r\n                    fieldNames: fieldNames,\r\n                    path: remainingPathSegments_1,\r\n                    delimeter: delimeter,\r\n                    fragments: fragments,\r\n                }));\r\n            }\r\n        });\r\n    }\r\n    else {\r\n        collectFields$1(fieldNode.selectionSet, fragments).forEach(function (possibleFieldNode) {\r\n            if (!fieldNames || fieldNames.includes(possibleFieldNode.name.value)) {\r\n                newFieldNodes.push(preAliasFieldNode(possibleFieldNode, \"\" + alias + delimeter));\r\n            }\r\n        });\r\n    }\r\n    return newFieldNodes;\r\n}\n\nfunction appendFields(typeMap, typeName, fields) {\r\n    var type = typeMap[typeName];\r\n    if (type != null) {\r\n        var typeConfig = toConfig(type);\r\n        var newFields_1 = toObjMap(typeConfig.fields);\r\n        Object.keys(fields).forEach(function (fieldName) {\r\n            newFields_1[fieldName] = fields[fieldName];\r\n        });\r\n        type = new GraphQLObjectType(__assign(__assign({}, typeConfig), { fields: newFields_1 }));\r\n    }\r\n    else {\r\n        type = new GraphQLObjectType({\r\n            name: typeName,\r\n            fields: fields,\r\n        });\r\n    }\r\n    typeMap[typeName] = type;\r\n}\r\nfunction removeFields(typeMap, typeName, testFn) {\r\n    var type = typeMap[typeName];\r\n    var typeConfig = toConfig(type);\r\n    var originalFields = typeConfig.fields;\r\n    var newFields = {};\r\n    var removedFields = {};\r\n    Object.keys(originalFields).forEach(function (fieldName) {\r\n        if (testFn(fieldName, originalFields[fieldName])) {\r\n            removedFields[fieldName] = originalFields[fieldName];\r\n        }\r\n        else {\r\n            newFields[fieldName] = originalFields[fieldName];\r\n        }\r\n    });\r\n    type = new GraphQLObjectType(__assign(__assign({}, typeConfig), { fields: newFields }));\r\n    typeMap[typeName] = type;\r\n    return removedFields;\r\n}\n\nfunction createMergedResolver(_a) {\r\n    var fromPath = _a.fromPath, dehoist = _a.dehoist, _b = _a.delimeter, delimeter = _b === void 0 ? '__gqltf__' : _b;\r\n    var parentErrorResolver = function (parent, args, context, info) {\r\n        return parent instanceof Error\r\n            ? parent\r\n            : defaultMergedResolver(parent, args, context, info);\r\n    };\r\n    var unwrappingResolver = fromPath != null\r\n        ? function (parent, args, context, info) {\r\n            return parentErrorResolver(unwrapResult(parent, info, fromPath), args, context, info);\r\n        }\r\n        : parentErrorResolver;\r\n    var dehoistingResolver = dehoist\r\n        ? function (parent, args, context, info) {\r\n            return unwrappingResolver(dehoistResult(parent, delimeter), args, context, info);\r\n        }\r\n        : unwrappingResolver;\r\n    var noParentResolver = function (parent, args, context, info) { return (parent ? dehoistingResolver(parent, args, context, info) : {}); };\r\n    return noParentResolver;\r\n}\n\nvar WrapFields = /** @class */ (function () {\r\n    function WrapFields(outerTypeName, wrappingFieldNames, wrappingTypeNames, fieldNames) {\r\n        var _a, _b;\r\n        var _this = this;\r\n        this.outerTypeName = outerTypeName;\r\n        this.wrappingFieldNames = wrappingFieldNames;\r\n        this.wrappingTypeNames = wrappingTypeNames;\r\n        this.numWraps = wrappingFieldNames.length;\r\n        this.fieldNames = fieldNames;\r\n        var remainingWrappingFieldNames = this.wrappingFieldNames.slice();\r\n        var outerMostWrappingFieldName = remainingWrappingFieldNames.shift();\r\n        this.transformer = new MapFields((_a = {},\r\n            _a[outerTypeName] = (_b = {},\r\n                _b[outerMostWrappingFieldName] = function (fieldNode, fragments) {\r\n                    return hoistFieldNodes({\r\n                        fieldNode: fieldNode,\r\n                        path: remainingWrappingFieldNames,\r\n                        fieldNames: _this.fieldNames,\r\n                        fragments: fragments,\r\n                    });\r\n                },\r\n                _b),\r\n            _a));\r\n    }\r\n    WrapFields.prototype.transformSchema = function (schema) {\r\n        var _a, _b;\r\n        var _this = this;\r\n        var typeMap = schema.getTypeMap();\r\n        var targetFields = removeFields(typeMap, this.outerTypeName, !this.fieldNames\r\n            ? function () { return true; }\r\n            : function (fieldName) { return _this.fieldNames.includes(fieldName); });\r\n        var wrapIndex = this.numWraps - 1;\r\n        var innerMostWrappingTypeName = this.wrappingTypeNames[wrapIndex];\r\n        appendFields(typeMap, innerMostWrappingTypeName, targetFields);\r\n        for (wrapIndex--; wrapIndex > -1; wrapIndex--) {\r\n            appendFields(typeMap, this.wrappingTypeNames[wrapIndex], (_a = {},\r\n                _a[this.wrappingFieldNames[wrapIndex + 1]] = {\r\n                    type: typeMap[this.wrappingTypeNames[wrapIndex + 1]],\r\n                    resolve: defaultMergedResolver,\r\n                },\r\n                _a));\r\n        }\r\n        appendFields(typeMap, this.outerTypeName, (_b = {},\r\n            _b[this.wrappingFieldNames[0]] = {\r\n                type: typeMap[this.wrappingTypeNames[0]],\r\n                resolve: createMergedResolver({ dehoist: true }),\r\n            },\r\n            _b));\r\n        healSchema(schema);\r\n        return this.transformer.transformSchema(schema);\r\n    };\r\n    WrapFields.prototype.transformRequest = function (originalRequest) {\r\n        return this.transformer.transformRequest(originalRequest);\r\n    };\r\n    return WrapFields;\r\n}());\n\nvar WrapType = /** @class */ (function () {\r\n    function WrapType(outerTypeName, innerTypeName, fieldName) {\r\n        this.transformer = new WrapFields(outerTypeName, [fieldName], [innerTypeName], undefined);\r\n    }\r\n    WrapType.prototype.transformSchema = function (schema) {\r\n        return this.transformer.transformSchema(schema);\r\n    };\r\n    WrapType.prototype.transformRequest = function (originalRequest) {\r\n        return this.transformer.transformRequest(originalRequest);\r\n    };\r\n    return WrapType;\r\n}());\n\nvar HoistField = /** @class */ (function () {\r\n    function HoistField(typeName, path, newFieldName) {\r\n        var _a, _b;\r\n        var _this = this;\r\n        this.typeName = typeName;\r\n        this.path = path;\r\n        this.newFieldName = newFieldName;\r\n        this.pathToField = this.path.slice();\r\n        this.oldFieldName = this.pathToField.pop();\r\n        this.transformer = new MapFields((_a = {},\r\n            _a[typeName] = (_b = {},\r\n                _b[newFieldName] = function (fieldNode) {\r\n                    return wrapFieldNode(renameFieldNode(fieldNode, _this.oldFieldName), _this.pathToField);\r\n                },\r\n                _b),\r\n            _a));\r\n    }\r\n    HoistField.prototype.transformSchema = function (schema) {\r\n        var _a;\r\n        var _this = this;\r\n        var typeMap = schema.getTypeMap();\r\n        var innerType = this.pathToField.reduce(function (acc, pathSegment) {\r\n            return getNullableType(acc.getFields()[pathSegment].type);\r\n        }, typeMap[this.typeName]);\r\n        var targetField = removeFields(typeMap, innerType.name, function (fieldName) { return fieldName === _this.oldFieldName; })[this.oldFieldName];\r\n        var targetType = targetField.type;\r\n        appendFields(typeMap, this.typeName, (_a = {},\r\n            _a[this.newFieldName] = {\r\n                type: targetType,\r\n                resolve: createMergedResolver({ fromPath: this.pathToField }),\r\n            },\r\n            _a));\r\n        healSchema(schema);\r\n        return this.transformer.transformSchema(schema);\r\n    };\r\n    HoistField.prototype.transformRequest = function (originalRequest) {\r\n        return this.transformer.transformRequest(originalRequest);\r\n    };\r\n    return HoistField;\r\n}());\n\nvar ReplaceFieldWithFragment = /** @class */ (function () {\r\n    function ReplaceFieldWithFragment(targetSchema, fragments) {\r\n        this.targetSchema = targetSchema;\r\n        this.mapping = {};\r\n        for (var _i = 0, fragments_1 = fragments; _i < fragments_1.length; _i++) {\r\n            var _a = fragments_1[_i], field = _a.field, fragment = _a.fragment;\r\n            var parsedFragment = parseFragmentToInlineFragment$1(fragment);\r\n            var actualTypeName = parsedFragment.typeCondition.name.value;\r\n            if (!(actualTypeName in this.mapping)) {\r\n                this.mapping[actualTypeName] = Object.create(null);\r\n            }\r\n            var typeMapping = this.mapping[actualTypeName];\r\n            if (!(field in typeMapping)) {\r\n                typeMapping[field] = [parsedFragment];\r\n            }\r\n            else {\r\n                typeMapping[field].push(parsedFragment);\r\n            }\r\n        }\r\n    }\r\n    ReplaceFieldWithFragment.prototype.transformRequest = function (originalRequest) {\r\n        var document = replaceFieldsWithFragments$1(this.targetSchema, originalRequest.document, this.mapping);\r\n        return __assign(__assign({}, originalRequest), { document: document });\r\n    };\r\n    return ReplaceFieldWithFragment;\r\n}());\r\nfunction replaceFieldsWithFragments$1(targetSchema, document, mapping) {\r\n    var _a;\r\n    var typeInfo = new TypeInfo(targetSchema);\r\n    return visit(document, visitWithTypeInfo(typeInfo, (_a = {},\r\n        _a[Kind.SELECTION_SET] = function (node) {\r\n            var parentType = typeInfo.getParentType();\r\n            if (parentType != null) {\r\n                var parentTypeName_1 = parentType.name;\r\n                var selections_1 = node.selections;\r\n                if (parentTypeName_1 in mapping) {\r\n                    node.selections.forEach(function (selection) {\r\n                        if (selection.kind === Kind.FIELD) {\r\n                            var name_1 = selection.name.value;\r\n                            var fragments = mapping[parentTypeName_1][name_1];\r\n                            if (fragments != null && fragments.length > 0) {\r\n                                var fragment = concatInlineFragments(parentTypeName_1, fragments);\r\n                                selections_1 = selections_1.concat(fragment);\r\n                            }\r\n                        }\r\n                    });\r\n                }\r\n                if (selections_1 !== node.selections) {\r\n                    return __assign(__assign({}, node), { selections: selections_1 });\r\n                }\r\n            }\r\n        },\r\n        _a)));\r\n}\r\nfunction parseFragmentToInlineFragment$1(definitions) {\r\n    if (definitions.trim().startsWith('fragment')) {\r\n        var document_1 = parse(definitions);\r\n        for (var _i = 0, _a = document_1.definitions; _i < _a.length; _i++) {\r\n            var definition = _a[_i];\r\n            if (definition.kind === Kind.FRAGMENT_DEFINITION) {\r\n                return {\r\n                    kind: Kind.INLINE_FRAGMENT,\r\n                    typeCondition: definition.typeCondition,\r\n                    selectionSet: definition.selectionSet,\r\n                };\r\n            }\r\n        }\r\n    }\r\n    var query = parse(\"{\" + definitions + \"}\")\r\n        .definitions[0];\r\n    for (var _b = 0, _c = query.selectionSet.selections; _b < _c.length; _b++) {\r\n        var selection = _c[_b];\r\n        if (selection.kind === Kind.INLINE_FRAGMENT) {\r\n            return selection;\r\n        }\r\n    }\r\n    throw new Error('Could not parse fragment');\r\n}\n\nvar WrapQuery = /** @class */ (function () {\r\n    function WrapQuery(path, wrapper, extractor) {\r\n        this.path = path;\r\n        this.wrapper = wrapper;\r\n        this.extractor = extractor;\r\n    }\r\n    WrapQuery.prototype.transformRequest = function (originalRequest) {\r\n        var _a;\r\n        var _this = this;\r\n        var document = originalRequest.document;\r\n        var fieldPath = [];\r\n        var ourPath = JSON.stringify(this.path);\r\n        var newDocument = visit(document, (_a = {},\r\n            _a[Kind.FIELD] = {\r\n                enter: function (node) {\r\n                    fieldPath.push(node.name.value);\r\n                    if (ourPath === JSON.stringify(fieldPath)) {\r\n                        var wrapResult = _this.wrapper(node.selectionSet);\r\n                        // Selection can be either a single selection or a selection set. If it's just one selection,\r\n                        // let's wrap it in a selection set. Otherwise, keep it as is.\r\n                        var selectionSet = wrapResult != null && wrapResult.kind === Kind.SELECTION_SET\r\n                            ? wrapResult\r\n                            : {\r\n                                kind: Kind.SELECTION_SET,\r\n                                selections: [wrapResult],\r\n                            };\r\n                        return __assign(__assign({}, node), { selectionSet: selectionSet });\r\n                    }\r\n                },\r\n                leave: function () {\r\n                    fieldPath.pop();\r\n                },\r\n            },\r\n            _a));\r\n        return __assign(__assign({}, originalRequest), { document: newDocument });\r\n    };\r\n    WrapQuery.prototype.transformResult = function (originalResult) {\r\n        var rootData = originalResult.data;\r\n        if (rootData != null) {\r\n            var data = rootData;\r\n            var path = __spreadArrays(this.path);\r\n            while (path.length > 1) {\r\n                var next = path.shift();\r\n                if (data[next]) {\r\n                    data = data[next];\r\n                }\r\n            }\r\n            data[path[0]] = this.extractor(data[path[0]]);\r\n        }\r\n        return {\r\n            data: rootData,\r\n            errors: originalResult.errors,\r\n        };\r\n    };\r\n    return WrapQuery;\r\n}());\n\nvar ExtractField = /** @class */ (function () {\r\n    function ExtractField(_a) {\r\n        var from = _a.from, to = _a.to;\r\n        this.from = from;\r\n        this.to = to;\r\n    }\r\n    ExtractField.prototype.transformRequest = function (originalRequest) {\r\n        var _a, _b;\r\n        var fromSelection;\r\n        var ourPathFrom = JSON.stringify(this.from);\r\n        var ourPathTo = JSON.stringify(this.to);\r\n        var fieldPath = [];\r\n        visit(originalRequest.document, (_a = {},\r\n            _a[Kind.FIELD] = {\r\n                enter: function (node) {\r\n                    fieldPath.push(node.name.value);\r\n                    if (ourPathFrom === JSON.stringify(fieldPath)) {\r\n                        fromSelection = node.selectionSet;\r\n                        return BREAK;\r\n                    }\r\n                },\r\n                leave: function () {\r\n                    fieldPath.pop();\r\n                },\r\n            },\r\n            _a));\r\n        fieldPath = [];\r\n        var newDocument = visit(originalRequest.document, (_b = {},\r\n            _b[Kind.FIELD] = {\r\n                enter: function (node) {\r\n                    fieldPath.push(node.name.value);\r\n                    if (ourPathTo === JSON.stringify(fieldPath) &&\r\n                        fromSelection != null) {\r\n                        return __assign(__assign({}, node), { selectionSet: fromSelection });\r\n                    }\r\n                },\r\n                leave: function () {\r\n                    fieldPath.pop();\r\n                },\r\n            },\r\n            _b));\r\n        return __assign(__assign({}, originalRequest), { document: newDocument });\r\n    };\r\n    return ExtractField;\r\n}());\n\nfunction makeRemoteExecutableSchema(_a) {\r\n    var schemaOrTypeDefs = _a.schema, link = _a.link, fetcher = _a.fetcher, _b = _a.createResolver, createResolver = _b === void 0 ? defaultCreateRemoteResolver : _b, _c = _a.createSubscriptionResolver, createSubscriptionResolver = _c === void 0 ? defaultCreateRemoteSubscriptionResolver : _c, buildSchemaOptions = _a.buildSchemaOptions;\r\n    var finalFetcher = fetcher;\r\n    if (finalFetcher == null && link != null) {\r\n        finalFetcher = linkToFetcher(link);\r\n    }\r\n    var targetSchema = typeof schemaOrTypeDefs === 'string'\r\n        ? buildSchema(schemaOrTypeDefs, buildSchemaOptions)\r\n        : schemaOrTypeDefs;\r\n    return wrapSchema({\r\n        schema: targetSchema,\r\n        createProxyingResolver: function (_schema, _transforms, operation) {\r\n            if (operation === 'query' || operation === 'mutation') {\r\n                return createResolver(finalFetcher);\r\n            }\r\n            return createSubscriptionResolver(link);\r\n        },\r\n    });\r\n}\r\nfunction defaultCreateRemoteResolver(fetcher) {\r\n    return function (_parent, _args, context, info) {\r\n        return delegateToSchema({\r\n            schema: { schema: info.schema, fetcher: fetcher },\r\n            context: context,\r\n            info: info,\r\n        });\r\n    };\r\n}\r\nfunction defaultCreateRemoteSubscriptionResolver(link) {\r\n    return function (_parent, _args, context, info) {\r\n        return delegateToSchema({\r\n            schema: { schema: info.schema, link: link },\r\n            context: context,\r\n            info: info,\r\n        });\r\n    };\r\n}\n\nexport { AddArgumentsAsVariables, AddMergedTypeFragments as AddMergedTypeSelectionSets, AddReplacementFragments, AddReplacementSelectionSets, AddTypenameToAbstract, AwaitVariablesLink, CheckResultAndHandleErrors, ExpandAbstractTypes, ExtendSchema, ExtractField, FilterInterfaceFields, FilterObjectFields, FilterRootFields, FilterToSchema, FilterTypes, GraphQLUpload, HoistField, MapFields, MapperKind, MockList, RenameInterfaceFields, RenameObjectFields, RenameRootFields, RenameRootTypes, RenameTypes, ReplaceFieldWithFragment, SchemaDirectiveVisitor, SchemaError, SchemaVisitor, TransformCompositeFields, TransformInterfaceFields, TransformObjectFields, TransformQuery, TransformRootFields, VisitSchemaKind, WrapFields, WrapQuery, WrapType, addCatchUndefinedToSchema, addErrorLoggingToSchema, addMockFunctionsToSchema, addMocksToSchema, addResolveFunctionsToSchema, addResolversToSchema, addSchemaLevelResolveFunction, addSchemaLevelResolver, argumentMapToConfig, argumentToConfig, assertResolveFunctionsPresent, assertResolversPresent, attachConnectorsToContext, attachDirectiveResolvers, buildSchema, buildSchemaFromTypeDefinitions, chainResolvers, checkForResolveTypeResolver, cloneDirective, cloneSchema, cloneType, concatenateTypeDefs, createRequest, createRequestFromInfo, createServerHttpLink, decorateWithLogger, defaultCreateProxyingResolver, defaultCreateRemoteResolver, defaultCreateRemoteSubscriptionResolver, defaultMergedResolver, delegateRequest, delegateToSchema, directiveToConfig, enumTypeToConfig, extendResolversFromInterfaces, extendSchema, extractExtensionDefinitions, fieldMapToConfig, fieldToConfig, filterExtensionDefinitions, filterSchema, forEachDefaultValue, forEachField, getResolversFromSchema, graphqlVersion, healSchema, healTypes, inputFieldMapToConfig, inputFieldToConfig, inputObjectTypeToConfig, interfaceTypeToConfig, introspectSchema, isSpecifiedScalarType, isSubschemaConfig, makeExecutableSchema, makeRemoteExecutableSchema, mapSchema, mergeSchemas, mockServer, objectTypeToConfig, scalarTypeToConfig, schemaToConfig, toConfig, transformSchema, typeToConfig, unionTypeToConfig, visitSchema, wrapSchema };\n//# sourceMappingURL=index.esm.js.map\n","import { __spreadArrays, __assign, __extends, __rest } from 'tslib';\nimport { $$asyncIterator, isAsyncIterable } from 'iterall';\nimport { toPromise, execute, Observable, ApolloLink, concat } from 'apollo-link';\nimport { isCompositeType, doTypesOverlap, visit, visitWithTypeInfo, Kind, getNamedType, TypeInfo, isAbstractType, isObjectType, isInterfaceType, TypeNameMetaFieldDef, GraphQLError, getDirectiveValues, GraphQLSkipDirective, GraphQLIncludeDirective, typeFromAST as typeFromAST$1, responsePathAsArray, getNullableType, isLeafType, isListType, isInputObjectType, isNonNullType, versionInfo, getOperationRootType, lexicographicSortSchema, printError, isSchema, isDirective, isNamedType, isUnionType, isEnumType, isScalarType, GraphQLString, GraphQLInt, GraphQLFloat, GraphQLBoolean, GraphQLID, GraphQLSchema, GraphQLDirective, GraphQLObjectType, GraphQLInterfaceType, GraphQLUnionType, GraphQLInputObjectType, GraphQLEnumType, GraphQLScalarType, GraphQLList, GraphQLNonNull, isInputType, buildASTSchema, parse, extendSchema as extendSchema$1, valueFromAST, print, validate, execute as execute$1, subscribe, defaultFieldResolver, graphql, buildClientSchema, getIntrospectionQuery, DirectiveLocation, TokenKind, BREAK } from 'graphql';\nimport { deprecated } from 'deprecated-decorator';\nimport { createUploadLink, isExtractableFile, formDataAppendFile } from 'apollo-upload-client';\nimport FormData from 'form-data';\nimport fetch from 'node-fetch';\nimport { v4 } from 'uuid';\n\nfunction isSubschemaConfig(value) {\r\n    return Boolean(value.schema);\r\n}\r\nvar VisitSchemaKind;\r\n(function (VisitSchemaKind) {\r\n    VisitSchemaKind[\"TYPE\"] = \"VisitSchemaKind.TYPE\";\r\n    VisitSchemaKind[\"SCALAR_TYPE\"] = \"VisitSchemaKind.SCALAR_TYPE\";\r\n    VisitSchemaKind[\"ENUM_TYPE\"] = \"VisitSchemaKind.ENUM_TYPE\";\r\n    VisitSchemaKind[\"COMPOSITE_TYPE\"] = \"VisitSchemaKind.COMPOSITE_TYPE\";\r\n    VisitSchemaKind[\"OBJECT_TYPE\"] = \"VisitSchemaKind.OBJECT_TYPE\";\r\n    VisitSchemaKind[\"INPUT_OBJECT_TYPE\"] = \"VisitSchemaKind.INPUT_OBJECT_TYPE\";\r\n    VisitSchemaKind[\"ABSTRACT_TYPE\"] = \"VisitSchemaKind.ABSTRACT_TYPE\";\r\n    VisitSchemaKind[\"UNION_TYPE\"] = \"VisitSchemaKind.UNION_TYPE\";\r\n    VisitSchemaKind[\"INTERFACE_TYPE\"] = \"VisitSchemaKind.INTERFACE_TYPE\";\r\n    VisitSchemaKind[\"ROOT_OBJECT\"] = \"VisitSchemaKind.ROOT_OBJECT\";\r\n    VisitSchemaKind[\"QUERY\"] = \"VisitSchemaKind.QUERY\";\r\n    VisitSchemaKind[\"MUTATION\"] = \"VisitSchemaKind.MUTATION\";\r\n    VisitSchemaKind[\"SUBSCRIPTION\"] = \"VisitSchemaKind.SUBSCRIPTION\";\r\n})(VisitSchemaKind || (VisitSchemaKind = {}));\r\nvar MapperKind;\r\n(function (MapperKind) {\r\n    MapperKind[\"TYPE\"] = \"MapperKind.TYPE\";\r\n    MapperKind[\"SCALAR_TYPE\"] = \"MapperKind.SCALAR_TYPE\";\r\n    MapperKind[\"ENUM_TYPE\"] = \"MapperKind.ENUM_TYPE\";\r\n    MapperKind[\"COMPOSITE_TYPE\"] = \"MapperKind.COMPOSITE_TYPE\";\r\n    MapperKind[\"OBJECT_TYPE\"] = \"MapperKind.OBJECT_TYPE\";\r\n    MapperKind[\"INPUT_OBJECT_TYPE\"] = \"MapperKind.INPUT_OBJECT_TYPE\";\r\n    MapperKind[\"ABSTRACT_TYPE\"] = \"MapperKind.ABSTRACT_TYPE\";\r\n    MapperKind[\"UNION_TYPE\"] = \"MapperKind.UNION_TYPE\";\r\n    MapperKind[\"INTERFACE_TYPE\"] = \"MapperKind.INTERFACE_TYPE\";\r\n    MapperKind[\"ROOT_OBJECT\"] = \"MapperKind.ROOT_OBJECT\";\r\n    MapperKind[\"QUERY\"] = \"MapperKind.QUERY\";\r\n    MapperKind[\"MUTATION\"] = \"MapperKind.MUTATION\";\r\n    MapperKind[\"SUBSCRIPTION\"] = \"MapperKind.SUBSCRIPTION\";\r\n    MapperKind[\"DIRECTIVE\"] = \"MapperKind.DIRECTIVE\";\r\n})(MapperKind || (MapperKind = {}));\n\nfunction implementsAbstractType(schema, typeA, typeB) {\r\n    if (typeA === typeB) {\r\n        return true;\r\n    }\r\n    else if (isCompositeType(typeA) && isCompositeType(typeB)) {\r\n        return doTypesOverlap(schema, typeA, typeB);\r\n    }\r\n    return false;\r\n}\n\nvar ExpandAbstractTypes = /** @class */ (function () {\r\n    function ExpandAbstractTypes(sourceSchema, targetSchema) {\r\n        this.targetSchema = targetSchema;\r\n        this.mapping = extractPossibleTypes(sourceSchema, targetSchema);\r\n        this.reverseMapping = flipMapping(this.mapping);\r\n    }\r\n    ExpandAbstractTypes.prototype.transformRequest = function (originalRequest) {\r\n        var document = expandAbstractTypes(this.targetSchema, this.mapping, this.reverseMapping, originalRequest.document);\r\n        return __assign(__assign({}, originalRequest), { document: document });\r\n    };\r\n    return ExpandAbstractTypes;\r\n}());\r\nfunction extractPossibleTypes(sourceSchema, targetSchema) {\r\n    var typeMap = sourceSchema.getTypeMap();\r\n    var mapping = Object.create(null);\r\n    Object.keys(typeMap).forEach(function (typeName) {\r\n        var type = typeMap[typeName];\r\n        if (isAbstractType(type)) {\r\n            var targetType = targetSchema.getType(typeName);\r\n            if (!isAbstractType(targetType)) {\r\n                var implementations = sourceSchema.getPossibleTypes(type);\r\n                mapping[typeName] = implementations\r\n                    .filter(function (impl) { return targetSchema.getType(impl.name); })\r\n                    .map(function (impl) { return impl.name; });\r\n            }\r\n        }\r\n    });\r\n    return mapping;\r\n}\r\nfunction flipMapping(mapping) {\r\n    var result = Object.create(null);\r\n    Object.keys(mapping).forEach(function (typeName) {\r\n        var toTypeNames = mapping[typeName];\r\n        toTypeNames.forEach(function (toTypeName) {\r\n            if (!(toTypeName in result)) {\r\n                result[toTypeName] = [];\r\n            }\r\n            result[toTypeName].push(typeName);\r\n        });\r\n    });\r\n    return result;\r\n}\r\nfunction expandAbstractTypes(targetSchema, mapping, reverseMapping, document) {\r\n    var _a;\r\n    var operations = document.definitions.filter(function (def) { return def.kind === Kind.OPERATION_DEFINITION; });\r\n    var fragments = document.definitions.filter(function (def) { return def.kind === Kind.FRAGMENT_DEFINITION; });\r\n    var existingFragmentNames = fragments.map(function (fragment) { return fragment.name.value; });\r\n    var fragmentCounter = 0;\r\n    var generateFragmentName = function (typeName) {\r\n        var fragmentName;\r\n        do {\r\n            fragmentName = \"_\" + typeName + \"_Fragment\" + fragmentCounter.toString();\r\n            fragmentCounter++;\r\n        } while (existingFragmentNames.indexOf(fragmentName) !== -1);\r\n        return fragmentName;\r\n    };\r\n    var newFragments = [];\r\n    var fragmentReplacements = Object.create(null);\r\n    fragments.forEach(function (fragment) {\r\n        newFragments.push(fragment);\r\n        var possibleTypes = mapping[fragment.typeCondition.name.value];\r\n        if (possibleTypes != null) {\r\n            fragmentReplacements[fragment.name.value] = [];\r\n            possibleTypes.forEach(function (possibleTypeName) {\r\n                var name = generateFragmentName(possibleTypeName);\r\n                existingFragmentNames.push(name);\r\n                var newFragment = {\r\n                    kind: Kind.FRAGMENT_DEFINITION,\r\n                    name: {\r\n                        kind: Kind.NAME,\r\n                        value: name,\r\n                    },\r\n                    typeCondition: {\r\n                        kind: Kind.NAMED_TYPE,\r\n                        name: {\r\n                            kind: Kind.NAME,\r\n                            value: possibleTypeName,\r\n                        },\r\n                    },\r\n                    selectionSet: fragment.selectionSet,\r\n                };\r\n                newFragments.push(newFragment);\r\n                fragmentReplacements[fragment.name.value].push({\r\n                    fragmentName: name,\r\n                    typeName: possibleTypeName,\r\n                });\r\n            });\r\n        }\r\n    });\r\n    var newDocument = __assign(__assign({}, document), { definitions: __spreadArrays(operations, newFragments) });\r\n    var typeInfo = new TypeInfo(targetSchema);\r\n    return visit(newDocument, visitWithTypeInfo(typeInfo, (_a = {},\r\n        _a[Kind.SELECTION_SET] = function (node) {\r\n            var newSelections = __spreadArrays(node.selections);\r\n            var maybeType = typeInfo.getParentType();\r\n            if (maybeType != null) {\r\n                var parentType_1 = getNamedType(maybeType);\r\n                node.selections.forEach(function (selection) {\r\n                    if (selection.kind === Kind.INLINE_FRAGMENT) {\r\n                        if (selection.typeCondition != null) {\r\n                            var possibleTypes = mapping[selection.typeCondition.name.value];\r\n                            if (possibleTypes != null) {\r\n                                possibleTypes.forEach(function (possibleType) {\r\n                                    var maybePossibleType = targetSchema.getType(possibleType);\r\n                                    if (maybePossibleType != null &&\r\n                                        implementsAbstractType(targetSchema, parentType_1, maybePossibleType)) {\r\n                                        newSelections.push({\r\n                                            kind: Kind.INLINE_FRAGMENT,\r\n                                            typeCondition: {\r\n                                                kind: Kind.NAMED_TYPE,\r\n                                                name: {\r\n                                                    kind: Kind.NAME,\r\n                                                    value: possibleType,\r\n                                                },\r\n                                            },\r\n                                            selectionSet: selection.selectionSet,\r\n                                        });\r\n                                    }\r\n                                });\r\n                            }\r\n                        }\r\n                    }\r\n                    else if (selection.kind === Kind.FRAGMENT_SPREAD) {\r\n                        var fragmentName = selection.name.value;\r\n                        if (fragmentName in fragmentReplacements) {\r\n                            fragmentReplacements[fragmentName].forEach(function (replacement) {\r\n                                var typeName = replacement.typeName;\r\n                                var maybeReplacementType = targetSchema.getType(typeName);\r\n                                if (maybeReplacementType != null &&\r\n                                    implementsAbstractType(targetSchema, parentType_1, maybeType)) {\r\n                                    newSelections.push({\r\n                                        kind: Kind.FRAGMENT_SPREAD,\r\n                                        name: {\r\n                                            kind: Kind.NAME,\r\n                                            value: replacement.fragmentName,\r\n                                        },\r\n                                    });\r\n                                }\r\n                            });\r\n                        }\r\n                    }\r\n                });\r\n                if (parentType_1.name in reverseMapping) {\r\n                    newSelections.push({\r\n                        kind: Kind.FIELD,\r\n                        name: {\r\n                            kind: Kind.NAME,\r\n                            value: '__typename',\r\n                        },\r\n                    });\r\n                }\r\n            }\r\n            if (newSelections.length !== node.selections.length) {\r\n                return __assign(__assign({}, node), { selections: newSelections });\r\n            }\r\n        },\r\n        _a)));\r\n}\n\n/**\r\n * Creates a keyed JS object from an array, given a function to produce the keys\r\n * and a function to produce the values from each item in the array.\r\n *\r\n *     const phoneBook = [\r\n *       { name: 'Jon', num: '555-1234' },\r\n *       { name: 'Jenny', num: '867-5309' }\r\n *     ]\r\n *\r\n *     // { Jon: '555-1234', Jenny: '867-5309' }\r\n *     const phonesByName = keyValMap(\r\n *       phoneBook,\r\n *       entry => entry.name,\r\n *       entry => entry.num\r\n *     )\r\n *\r\n */\r\nfunction keyValMap(list, keyFn, valFn) {\r\n    return list.reduce(function (map, item) {\r\n        map[keyFn(item)] = valFn(item);\r\n        return map;\r\n    }, Object.create(null));\r\n}\n\nvar FilterToSchema = /** @class */ (function () {\r\n    function FilterToSchema(targetSchema) {\r\n        this.targetSchema = targetSchema;\r\n    }\r\n    FilterToSchema.prototype.transformRequest = function (originalRequest) {\r\n        return __assign(__assign({}, originalRequest), filterToSchema(this.targetSchema, originalRequest.document, originalRequest.variables));\r\n    };\r\n    return FilterToSchema;\r\n}());\r\nfunction filterToSchema(targetSchema, document, variables) {\r\n    var operations = document.definitions.filter(function (def) { return def.kind === Kind.OPERATION_DEFINITION; });\r\n    var fragments = document.definitions.filter(function (def) { return def.kind === Kind.FRAGMENT_DEFINITION; });\r\n    var usedVariables = [];\r\n    var usedFragments = [];\r\n    var newOperations = [];\r\n    var newFragments = [];\r\n    var validFragments = fragments.filter(function (fragment) {\r\n        var typeName = fragment.typeCondition.name.value;\r\n        return Boolean(targetSchema.getType(typeName));\r\n    });\r\n    var validFragmentsWithType = keyValMap(validFragments, function (fragment) { return fragment.name.value; }, function (fragment) { return targetSchema.getType(fragment.typeCondition.name.value); });\r\n    var fragmentSet = Object.create(null);\r\n    operations.forEach(function (operation) {\r\n        var type;\r\n        if (operation.operation === 'subscription') {\r\n            type = targetSchema.getSubscriptionType();\r\n        }\r\n        else if (operation.operation === 'mutation') {\r\n            type = targetSchema.getMutationType();\r\n        }\r\n        else {\r\n            type = targetSchema.getQueryType();\r\n        }\r\n        var _a = filterSelectionSet(targetSchema, type, validFragmentsWithType, operation.selectionSet), selectionSet = _a.selectionSet, operationUsedFragments = _a.usedFragments, operationUsedVariables = _a.usedVariables;\r\n        usedFragments = union(usedFragments, operationUsedFragments);\r\n        var _b = collectFragmentVariables(targetSchema, fragmentSet, validFragments, validFragmentsWithType, usedFragments), collectedUsedVariables = _b.usedVariables, collectedNewFragments = _b.newFragments, collectedFragmentSet = _b.fragmentSet;\r\n        var operationOrFragmentVariables = union(operationUsedVariables, collectedUsedVariables);\r\n        usedVariables = union(usedVariables, operationOrFragmentVariables);\r\n        newFragments = collectedNewFragments;\r\n        fragmentSet = collectedFragmentSet;\r\n        var variableDefinitions = operation.variableDefinitions.filter(function (variable) {\r\n            return operationOrFragmentVariables.indexOf(variable.variable.name.value) !==\r\n                -1;\r\n        });\r\n        newOperations.push({\r\n            kind: Kind.OPERATION_DEFINITION,\r\n            operation: operation.operation,\r\n            name: operation.name,\r\n            directives: operation.directives,\r\n            variableDefinitions: variableDefinitions,\r\n            selectionSet: selectionSet,\r\n        });\r\n    });\r\n    var newVariables = usedVariables.reduce(function (acc, variableName) {\r\n        acc[variableName] = variables[variableName];\r\n        return acc;\r\n    }, {});\r\n    return {\r\n        document: {\r\n            kind: Kind.DOCUMENT,\r\n            definitions: __spreadArrays(newOperations, newFragments),\r\n        },\r\n        variables: newVariables,\r\n    };\r\n}\r\nfunction collectFragmentVariables(targetSchema, fragmentSet, validFragments, validFragmentsWithType, usedFragments) {\r\n    var remainingFragments = usedFragments.slice();\r\n    var usedVariables = [];\r\n    var newFragments = [];\r\n    var _loop_1 = function () {\r\n        var nextFragmentName = remainingFragments.pop();\r\n        var fragment = validFragments.find(function (fr) { return fr.name.value === nextFragmentName; });\r\n        if (fragment != null) {\r\n            var name_1 = nextFragmentName;\r\n            var typeName = fragment.typeCondition.name.value;\r\n            var type = targetSchema.getType(typeName);\r\n            var _a = filterSelectionSet(targetSchema, type, validFragmentsWithType, fragment.selectionSet), selectionSet = _a.selectionSet, fragmentUsedFragments = _a.usedFragments, fragmentUsedVariables = _a.usedVariables;\r\n            remainingFragments = union(remainingFragments, fragmentUsedFragments);\r\n            usedVariables = union(usedVariables, fragmentUsedVariables);\r\n            if (!(name_1 in fragmentSet)) {\r\n                fragmentSet[name_1] = true;\r\n                newFragments.push({\r\n                    kind: Kind.FRAGMENT_DEFINITION,\r\n                    name: {\r\n                        kind: Kind.NAME,\r\n                        value: name_1,\r\n                    },\r\n                    typeCondition: fragment.typeCondition,\r\n                    selectionSet: selectionSet,\r\n                });\r\n            }\r\n        }\r\n    };\r\n    while (remainingFragments.length !== 0) {\r\n        _loop_1();\r\n    }\r\n    return {\r\n        usedVariables: usedVariables,\r\n        newFragments: newFragments,\r\n        fragmentSet: fragmentSet,\r\n    };\r\n}\r\nfunction filterSelectionSet(schema, type, validFragments, selectionSet) {\r\n    var _a;\r\n    var usedFragments = [];\r\n    var usedVariables = [];\r\n    var typeInfo = new TypeInfo(schema, undefined, type);\r\n    var filteredSelectionSet = visit(selectionSet, visitWithTypeInfo(typeInfo, (_a = {},\r\n        _a[Kind.FIELD] = {\r\n            enter: function (node) {\r\n                var parentType = typeInfo.getParentType();\r\n                if (isObjectType(parentType) || isInterfaceType(parentType)) {\r\n                    var fields = parentType.getFields();\r\n                    var field = node.name.value === '__typename'\r\n                        ? TypeNameMetaFieldDef\r\n                        : fields[node.name.value];\r\n                    if (!field) {\r\n                        return null;\r\n                    }\r\n                    var argNames_1 = (field.args != null ? field.args : []).map(function (arg) { return arg.name; });\r\n                    if (node.arguments != null) {\r\n                        var args = node.arguments.filter(function (arg) { return argNames_1.indexOf(arg.name.value) !== -1; });\r\n                        if (args.length !== node.arguments.length) {\r\n                            return __assign(__assign({}, node), { arguments: args });\r\n                        }\r\n                    }\r\n                }\r\n            },\r\n            leave: function (node) {\r\n                var _a;\r\n                var resolvedType = getNamedType(typeInfo.getType());\r\n                if (isObjectType(resolvedType) || isInterfaceType(resolvedType)) {\r\n                    var selections = node.selectionSet != null ? node.selectionSet.selections : null;\r\n                    if (selections == null || selections.length === 0) {\r\n                        // need to remove any added variables. Is there a better way to do this?\r\n                        visit(node, (_a = {},\r\n                            _a[Kind.VARIABLE] = function (variableNode) {\r\n                                var index = usedVariables.indexOf(variableNode.name.value);\r\n                                if (index !== -1) {\r\n                                    usedVariables.splice(index, 1);\r\n                                }\r\n                            },\r\n                            _a));\r\n                        return null;\r\n                    }\r\n                }\r\n            },\r\n        },\r\n        _a[Kind.FRAGMENT_SPREAD] = function (node) {\r\n            if (node.name.value in validFragments) {\r\n                var parentType = typeInfo.getParentType();\r\n                var innerType = validFragments[node.name.value];\r\n                if (!implementsAbstractType(schema, parentType, innerType)) {\r\n                    return null;\r\n                }\r\n                usedFragments.push(node.name.value);\r\n                return;\r\n            }\r\n            return null;\r\n        },\r\n        _a[Kind.INLINE_FRAGMENT] = {\r\n            enter: function (node) {\r\n                if (node.typeCondition != null) {\r\n                    var parentType = typeInfo.getParentType();\r\n                    var innerType = schema.getType(node.typeCondition.name.value);\r\n                    if (!implementsAbstractType(schema, parentType, innerType)) {\r\n                        return null;\r\n                    }\r\n                }\r\n            },\r\n        },\r\n        _a[Kind.VARIABLE] = function (node) {\r\n            usedVariables.push(node.name.value);\r\n        },\r\n        _a)));\r\n    return {\r\n        selectionSet: filteredSelectionSet,\r\n        usedFragments: usedFragments,\r\n        usedVariables: usedVariables,\r\n    };\r\n}\r\nfunction union() {\r\n    var arrays = [];\r\n    for (var _i = 0; _i < arguments.length; _i++) {\r\n        arrays[_i] = arguments[_i];\r\n    }\r\n    var cache = Object.create(null);\r\n    var result = [];\r\n    arrays.forEach(function (array) {\r\n        array.forEach(function (item) {\r\n            if (!(item in cache)) {\r\n                cache[item] = true;\r\n                result.push(item);\r\n            }\r\n        });\r\n    });\r\n    return result;\r\n}\n\nvar AddReplacementSelectionSets = /** @class */ (function () {\r\n    function AddReplacementSelectionSets(schema, mapping) {\r\n        this.schema = schema;\r\n        this.mapping = mapping;\r\n    }\r\n    AddReplacementSelectionSets.prototype.transformRequest = function (originalRequest) {\r\n        var document = replaceFieldsWithSelectionSet(this.schema, originalRequest.document, this.mapping);\r\n        return __assign(__assign({}, originalRequest), { document: document });\r\n    };\r\n    return AddReplacementSelectionSets;\r\n}());\r\nfunction replaceFieldsWithSelectionSet(schema, document, mapping) {\r\n    var _a;\r\n    var typeInfo = new TypeInfo(schema);\r\n    return visit(document, visitWithTypeInfo(typeInfo, (_a = {},\r\n        _a[Kind.SELECTION_SET] = function (node) {\r\n            var parentType = typeInfo.getParentType();\r\n            if (parentType != null) {\r\n                var parentTypeName_1 = parentType.name;\r\n                var selections_1 = node.selections;\r\n                if (parentTypeName_1 in mapping) {\r\n                    node.selections.forEach(function (selection) {\r\n                        if (selection.kind === Kind.FIELD) {\r\n                            var name_1 = selection.name.value;\r\n                            var selectionSet = mapping[parentTypeName_1][name_1];\r\n                            if (selectionSet != null) {\r\n                                selections_1 = selections_1.concat(selectionSet.selections);\r\n                            }\r\n                        }\r\n                    });\r\n                }\r\n                if (selections_1 !== node.selections) {\r\n                    return __assign(__assign({}, node), { selections: selections_1 });\r\n                }\r\n            }\r\n        },\r\n        _a)));\r\n}\n\nvar AddReplacementFragments = /** @class */ (function () {\r\n    function AddReplacementFragments(targetSchema, mapping) {\r\n        this.targetSchema = targetSchema;\r\n        this.mapping = mapping;\r\n    }\r\n    AddReplacementFragments.prototype.transformRequest = function (originalRequest) {\r\n        var document = replaceFieldsWithFragments(this.targetSchema, originalRequest.document, this.mapping);\r\n        return __assign(__assign({}, originalRequest), { document: document });\r\n    };\r\n    return AddReplacementFragments;\r\n}());\r\nfunction replaceFieldsWithFragments(targetSchema, document, mapping) {\r\n    var _a;\r\n    var typeInfo = new TypeInfo(targetSchema);\r\n    return visit(document, visitWithTypeInfo(typeInfo, (_a = {},\r\n        _a[Kind.SELECTION_SET] = function (node) {\r\n            var parentType = typeInfo.getParentType();\r\n            if (parentType != null) {\r\n                var parentTypeName_1 = parentType.name;\r\n                var selections_1 = node.selections;\r\n                if (parentTypeName_1 in mapping) {\r\n                    node.selections.forEach(function (selection) {\r\n                        if (selection.kind === Kind.FIELD) {\r\n                            var name_1 = selection.name.value;\r\n                            var fragment = mapping[parentTypeName_1][name_1];\r\n                            if (fragment != null) {\r\n                                selections_1 = selections_1.concat(fragment);\r\n                            }\r\n                        }\r\n                    });\r\n                }\r\n                if (selections_1 !== node.selections) {\r\n                    return __assign(__assign({}, node), { selections: selections_1 });\r\n                }\r\n            }\r\n        },\r\n        _a)));\r\n}\n\nvar AddMergedTypeFragments = /** @class */ (function () {\r\n    function AddMergedTypeFragments(targetSchema, mapping) {\r\n        this.targetSchema = targetSchema;\r\n        this.mapping = mapping;\r\n    }\r\n    AddMergedTypeFragments.prototype.transformRequest = function (originalRequest) {\r\n        var document = addMergedTypeSelectionSets(this.targetSchema, originalRequest.document, this.mapping);\r\n        return __assign(__assign({}, originalRequest), { document: document });\r\n    };\r\n    return AddMergedTypeFragments;\r\n}());\r\nfunction addMergedTypeSelectionSets(targetSchema, document, mapping) {\r\n    var _a;\r\n    var typeInfo = new TypeInfo(targetSchema);\r\n    return visit(document, visitWithTypeInfo(typeInfo, (_a = {},\r\n        _a[Kind.SELECTION_SET] = function (node) {\r\n            var parentType = typeInfo.getParentType();\r\n            if (parentType != null) {\r\n                var parentTypeName = parentType.name;\r\n                var selections = node.selections;\r\n                if (parentTypeName in mapping) {\r\n                    var selectionSet = mapping[parentTypeName].selectionSet;\r\n                    if (selectionSet != null) {\r\n                        selections = selections.concat(selectionSet.selections);\r\n                    }\r\n                }\r\n                if (selections !== node.selections) {\r\n                    return __assign(__assign({}, node), { selections: selections });\r\n                }\r\n            }\r\n        },\r\n        _a)));\r\n}\n\nfunction addTypenameToAbstract(targetSchema, document) {\r\n    var _a;\r\n    var typeInfo = new TypeInfo(targetSchema);\r\n    return visit(document, visitWithTypeInfo(typeInfo, (_a = {},\r\n        _a[Kind.SELECTION_SET] = function (node) {\r\n            var parentType = typeInfo.getParentType();\r\n            var selections = node.selections;\r\n            if (parentType != null && isAbstractType(parentType)) {\r\n                selections = selections.concat({\r\n                    kind: Kind.FIELD,\r\n                    name: {\r\n                        kind: Kind.NAME,\r\n                        value: '__typename',\r\n                    },\r\n                });\r\n            }\r\n            if (selections !== node.selections) {\r\n                return __assign(__assign({}, node), { selections: selections });\r\n            }\r\n        },\r\n        _a)));\r\n}\n\nvar AddTypenameToAbstract = /** @class */ (function () {\r\n    function AddTypenameToAbstract(targetSchema) {\r\n        this.targetSchema = targetSchema;\r\n    }\r\n    AddTypenameToAbstract.prototype.transformRequest = function (originalRequest) {\r\n        var document = addTypenameToAbstract(this.targetSchema, originalRequest.document);\r\n        return __assign(__assign({}, originalRequest), { document: document });\r\n    };\r\n    return AddTypenameToAbstract;\r\n}());\n\n/**\r\n * Get the key under which the result of this resolver will be placed in the response JSON. Basically, just\r\n * resolves aliases.\r\n * @param info The info argument to the resolver.\r\n */\r\nfunction getResponseKeyFromInfo(info) {\r\n    return info.fieldNodes[0].alias != null\r\n        ? info.fieldNodes[0].alias.value\r\n        : info.fieldName;\r\n}\n\nvar hasSymbol = (typeof global !== 'undefined' && 'Symbol' in global) ||\r\n    // eslint-disable-next-line no-undef\r\n    (typeof window !== 'undefined' && 'Symbol' in window);\r\nvar OBJECT_SUBSCHEMA_SYMBOL = hasSymbol\r\n    ? Symbol('initialSubschema')\r\n    : '@@__initialSubschema';\r\nvar FIELD_SUBSCHEMA_MAP_SYMBOL = hasSymbol\r\n    ? Symbol('subschemaMap')\r\n    : '@@__subschemaMap';\r\nvar ERROR_SYMBOL = hasSymbol\r\n    ? Symbol('subschemaErrors')\r\n    : '@@__subschemaErrors';\n\nfunction relocatedError(originalError, nodes, path) {\r\n    if (Array.isArray(originalError.path)) {\r\n        return new GraphQLError(originalError.message, originalError.nodes, originalError.source, originalError.positions, path != null ? path : originalError.path, originalError.originalError, originalError.extensions);\r\n    }\r\n    if (originalError == null) {\r\n        return new GraphQLError(undefined, nodes, undefined, undefined, path, originalError);\r\n    }\r\n    return new GraphQLError(originalError.message, originalError.nodes != null\r\n        ? originalError.nodes\r\n        : nodes, originalError.source, originalError.positions, path, originalError);\r\n}\r\nfunction slicedError(originalError) {\r\n    return relocatedError(originalError, originalError.nodes, originalError.path != null ? originalError.path.slice(1) : undefined);\r\n}\r\nfunction getErrorsByPathSegment(errors) {\r\n    var record = Object.create(null);\r\n    errors.forEach(function (error) {\r\n        if (!error.path || error.path.length < 2) {\r\n            return;\r\n        }\r\n        var pathSegment = error.path[1];\r\n        var current = pathSegment in record ? record[pathSegment] : [];\r\n        current.push(slicedError(error));\r\n        record[pathSegment] = current;\r\n    });\r\n    return record;\r\n}\r\nvar CombinedError = /** @class */ (function (_super) {\r\n    __extends(CombinedError, _super);\r\n    function CombinedError(message, errors) {\r\n        var _this = _super.call(this, message) || this;\r\n        _this.errors = errors;\r\n        return _this;\r\n    }\r\n    return CombinedError;\r\n}(Error));\r\nfunction combineErrors(errors) {\r\n    if (errors.length === 1) {\r\n        return new GraphQLError(errors[0].message, errors[0].nodes, errors[0].source, errors[0].positions, errors[0].path, errors[0].originalError, errors[0].extensions);\r\n    }\r\n    return new CombinedError(errors.map(function (error) { return error.message; }).join('\\n'), errors);\r\n}\r\nfunction setErrors(result, errors) {\r\n    result[ERROR_SYMBOL] = errors;\r\n}\r\nfunction getErrors(result, pathSegment) {\r\n    var errors = result != null ? result[ERROR_SYMBOL] : result;\r\n    if (!Array.isArray(errors)) {\r\n        return null;\r\n    }\r\n    var fieldErrors = [];\r\n    for (var _i = 0, errors_1 = errors; _i < errors_1.length; _i++) {\r\n        var error = errors_1[_i];\r\n        if (!error.path || error.path[0] === pathSegment) {\r\n            fieldErrors.push(error);\r\n        }\r\n    }\r\n    return fieldErrors;\r\n}\n\nfunction handleNull(fieldNodes, path, errors) {\r\n    if (errors.length) {\r\n        if (errors.some(function (error) { return !error.path || error.path.length < 2; })) {\r\n            return relocatedError(combineErrors(errors), fieldNodes, path);\r\n        }\r\n        else if (errors.some(function (error) { return typeof error.path[1] === 'string'; })) {\r\n            var childErrors_1 = getErrorsByPathSegment(errors);\r\n            var result_1 = {};\r\n            Object.keys(childErrors_1).forEach(function (pathSegment) {\r\n                result_1[pathSegment] = handleNull(fieldNodes, __spreadArrays(path, [pathSegment]), childErrors_1[pathSegment]);\r\n            });\r\n            return result_1;\r\n        }\r\n        var childErrors_2 = getErrorsByPathSegment(errors);\r\n        var result_2 = [];\r\n        Object.keys(childErrors_2).forEach(function (pathSegment) {\r\n            result_2.push(handleNull(fieldNodes, __spreadArrays(path, [parseInt(pathSegment, 10)]), childErrors_2[pathSegment]));\r\n        });\r\n        return result_2;\r\n    }\r\n    return null;\r\n}\n\n/**\r\n * Given a selectionSet, adds all of the fields in that selection to\r\n * the passed in map of fields, and returns it at the end.\r\n *\r\n * CollectFields requires the \"runtime type\" of an object. For a field which\r\n * returns an Interface or Union type, the \"runtime type\" will be the actual\r\n * Object type returned by that field.\r\n *\r\n * @internal\r\n */\r\nfunction collectFields(exeContext, runtimeType, selectionSet, fields, visitedFragmentNames) {\r\n    for (var _i = 0, _a = selectionSet.selections; _i < _a.length; _i++) {\r\n        var selection = _a[_i];\r\n        switch (selection.kind) {\r\n            case Kind.FIELD: {\r\n                if (!shouldIncludeNode(exeContext, selection)) {\r\n                    continue;\r\n                }\r\n                var name_1 = getFieldEntryKey(selection);\r\n                if (!(name_1 in fields)) {\r\n                    fields[name_1] = [];\r\n                }\r\n                fields[name_1].push(selection);\r\n                break;\r\n            }\r\n            case Kind.INLINE_FRAGMENT: {\r\n                if (!shouldIncludeNode(exeContext, selection) ||\r\n                    !doesFragmentConditionMatch(exeContext, selection, runtimeType)) {\r\n                    continue;\r\n                }\r\n                collectFields(exeContext, runtimeType, selection.selectionSet, fields, visitedFragmentNames);\r\n                break;\r\n            }\r\n            case Kind.FRAGMENT_SPREAD: {\r\n                var fragName = selection.name.value;\r\n                if (visitedFragmentNames[fragName] ||\r\n                    !shouldIncludeNode(exeContext, selection)) {\r\n                    continue;\r\n                }\r\n                visitedFragmentNames[fragName] = true;\r\n                var fragment = exeContext.fragments[fragName];\r\n                if (!fragment ||\r\n                    !doesFragmentConditionMatch(exeContext, fragment, runtimeType)) {\r\n                    continue;\r\n                }\r\n                collectFields(exeContext, runtimeType, fragment.selectionSet, fields, visitedFragmentNames);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    return fields;\r\n}\r\n/**\r\n * Determines if a field should be included based on the @include and @skip\r\n * directives, where @skip has higher precedence than @include.\r\n */\r\nfunction shouldIncludeNode(exeContext, node) {\r\n    var skip = getDirectiveValues(GraphQLSkipDirective, node, exeContext.variableValues);\r\n    if ((skip === null || skip === void 0 ? void 0 : skip.if) === true) {\r\n        return false;\r\n    }\r\n    var include = getDirectiveValues(GraphQLIncludeDirective, node, exeContext.variableValues);\r\n    if ((include === null || include === void 0 ? void 0 : include.if) === false) {\r\n        return false;\r\n    }\r\n    return true;\r\n}\r\n/**\r\n * Determines if a fragment is applicable to the given type.\r\n */\r\nfunction doesFragmentConditionMatch(exeContext, fragment, type) {\r\n    var typeConditionNode = fragment.typeCondition;\r\n    if (!typeConditionNode) {\r\n        return true;\r\n    }\r\n    var conditionalType = typeFromAST$1(exeContext.schema, typeConditionNode);\r\n    if (conditionalType === type) {\r\n        return true;\r\n    }\r\n    if (isAbstractType(conditionalType)) {\r\n        return exeContext.schema.isPossibleType(conditionalType, type);\r\n    }\r\n    return false;\r\n}\r\n/**\r\n * Implements the logic to compute the key of a given field's entry\r\n */\r\nfunction getFieldEntryKey(node) {\r\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\r\n    return node.alias ? node.alias.value : node.name.value;\r\n}\n\nfunction getSubschema(result, responseKey) {\r\n    var subschema = result[FIELD_SUBSCHEMA_MAP_SYMBOL] &&\r\n        result[FIELD_SUBSCHEMA_MAP_SYMBOL][responseKey];\r\n    return subschema ? subschema : result[OBJECT_SUBSCHEMA_SYMBOL];\r\n}\r\nfunction setObjectSubschema(result, subschema) {\r\n    result[OBJECT_SUBSCHEMA_SYMBOL] = subschema;\r\n}\n\nfunction resolveFromParentTypename(parent) {\r\n    var parentTypename = parent['__typename'];\r\n    if (!parentTypename) {\r\n        throw new Error('Did not fetch typename for object, unable to resolve interface.');\r\n    }\r\n    return parentTypename;\r\n}\n\nfunction mergeDeep(target) {\r\n    var sources = [];\r\n    for (var _i = 1; _i < arguments.length; _i++) {\r\n        sources[_i - 1] = arguments[_i];\r\n    }\r\n    var output = __assign({}, target);\r\n    sources.forEach(function (source) {\r\n        if (isObject(target) && isObject(source)) {\r\n            Object.keys(source).forEach(function (key) {\r\n                var _a, _b;\r\n                if (isObject(source[key])) {\r\n                    if (!(key in target)) {\r\n                        Object.assign(output, (_a = {}, _a[key] = source[key], _a));\r\n                    }\r\n                    else {\r\n                        output[key] = mergeDeep(target[key], source[key]);\r\n                    }\r\n                }\r\n                else {\r\n                    Object.assign(output, (_b = {}, _b[key] = source[key], _b));\r\n                }\r\n            });\r\n        }\r\n    });\r\n    return output;\r\n}\r\nfunction isObject(item) {\r\n    return item && typeof item === 'object' && !Array.isArray(item);\r\n}\n\nfunction unwrapResult(parent, info, path) {\r\n    var newParent = parent;\r\n    var pathLength = path.length;\r\n    for (var i = 0; i < pathLength; i++) {\r\n        var responseKey = path[i];\r\n        var errors = getErrors(newParent, responseKey);\r\n        var subschema = getSubschema(newParent, responseKey);\r\n        var object = newParent[responseKey];\r\n        if (object == null) {\r\n            return handleNull(info.fieldNodes, responsePathAsArray(info.path), errors);\r\n        }\r\n        setErrors(object, errors.map(function (error) {\r\n            return relocatedError(error, error.nodes, error.path != null ? error.path.slice(1) : undefined);\r\n        }));\r\n        setObjectSubschema(object, subschema);\r\n        newParent = object;\r\n    }\r\n    return newParent;\r\n}\r\nfunction dehoistResult(parent, delimeter) {\r\n    if (delimeter === void 0) { delimeter = '__gqltf__'; }\r\n    var result = Object.create(null);\r\n    Object.keys(parent).forEach(function (alias) {\r\n        var obj = result;\r\n        var fieldNames = alias.split(delimeter);\r\n        var fieldName = fieldNames.pop();\r\n        fieldNames.forEach(function (key) {\r\n            obj = obj[key] = obj[key] || Object.create(null);\r\n        });\r\n        obj[fieldName] = parent[alias];\r\n    });\r\n    result[ERROR_SYMBOL] = parent[ERROR_SYMBOL].map(function (error) {\r\n        if (error.path != null) {\r\n            var path = error.path.slice();\r\n            var pathSegment = path.shift();\r\n            var expandedPathSegment = pathSegment.split(delimeter);\r\n            return relocatedError(error, error.nodes, expandedPathSegment.concat(path));\r\n        }\r\n        return error;\r\n    });\r\n    result[OBJECT_SUBSCHEMA_SYMBOL] = parent[OBJECT_SUBSCHEMA_SYMBOL];\r\n    return result;\r\n}\r\nfunction mergeProxiedResults(target) {\r\n    var sources = [];\r\n    for (var _i = 1; _i < arguments.length; _i++) {\r\n        sources[_i - 1] = arguments[_i];\r\n    }\r\n    var errors = target[ERROR_SYMBOL].concat(sources.map(function (source) { return source[ERROR_SYMBOL]; }));\r\n    var fieldSubschemaMap = sources.reduce(function (acc, source) {\r\n        var subschema = source[OBJECT_SUBSCHEMA_SYMBOL];\r\n        Object.keys(source).forEach(function (key) {\r\n            acc[key] = subschema;\r\n        });\r\n        return acc;\r\n    }, {});\r\n    var result = mergeDeep.apply(void 0, __spreadArrays([target], sources));\r\n    result[ERROR_SYMBOL] = errors;\r\n    result[FIELD_SUBSCHEMA_MAP_SYMBOL] = target[FIELD_SUBSCHEMA_MAP_SYMBOL]\r\n        ? mergeDeep(target[FIELD_SUBSCHEMA_MAP_SYMBOL], fieldSubschemaMap)\r\n        : fieldSubschemaMap;\r\n    return result;\r\n}\n\nfunction buildDelegationPlan(mergedTypeInfo, originalSelections, sourceSubschemas, targetSubschemas) {\r\n    // 1.  calculate if possible to delegate to given subschema\r\n    //    TODO: change logic so that required selection set can be spread across multiple subschemas?\r\n    var proxiableSubschemas = [];\r\n    var nonProxiableSubschemas = [];\r\n    targetSubschemas.forEach(function (t) {\r\n        if (sourceSubschemas.some(function (s) {\r\n            var selectionSet = mergedTypeInfo.selectionSets.get(t);\r\n            return mergedTypeInfo.containsSelectionSet.get(s).get(selectionSet);\r\n        })) {\r\n            proxiableSubschemas.push(t);\r\n        }\r\n        else {\r\n            nonProxiableSubschemas.push(t);\r\n        }\r\n    });\r\n    var uniqueFields = mergedTypeInfo.uniqueFields, nonUniqueFields = mergedTypeInfo.nonUniqueFields;\r\n    var unproxiableSelections = [];\r\n    // 2. for each selection:\r\n    var delegationMap = new Map();\r\n    originalSelections.forEach(function (selection) {\r\n        // 2a. use uniqueFields map to assign fields to subschema if one of possible subschemas\r\n        var uniqueSubschema = uniqueFields[selection.name.value];\r\n        if (uniqueSubschema != null) {\r\n            if (proxiableSubschemas.includes(uniqueSubschema)) {\r\n                var existingSubschema = delegationMap.get(uniqueSubschema);\r\n                if (existingSubschema != null) {\r\n                    existingSubschema.push(selection);\r\n                }\r\n                else {\r\n                    delegationMap.set(uniqueSubschema, [selection]);\r\n                }\r\n            }\r\n            else {\r\n                unproxiableSelections.push(selection);\r\n            }\r\n        }\r\n        else {\r\n            // 2b. use nonUniqueFields to assign to a possible subschema,\r\n            //     preferring one of the subschemas already targets of delegation\r\n            var nonUniqueSubschemas = nonUniqueFields[selection.name.value];\r\n            nonUniqueSubschemas = nonUniqueSubschemas.filter(function (s) {\r\n                return proxiableSubschemas.includes(s);\r\n            });\r\n            if (nonUniqueSubschemas != null) {\r\n                var subschemas_1 = Array.from(delegationMap.keys());\r\n                var existingSubschema = nonUniqueSubschemas.find(function (s) {\r\n                    return subschemas_1.includes(s);\r\n                });\r\n                if (existingSubschema != null) {\r\n                    delegationMap.get(existingSubschema).push(selection);\r\n                }\r\n                else {\r\n                    delegationMap.set(nonUniqueSubschemas[0], [selection]);\r\n                }\r\n            }\r\n            else {\r\n                unproxiableSelections.push(selection);\r\n            }\r\n        }\r\n    });\r\n    return {\r\n        delegationMap: delegationMap,\r\n        unproxiableSelections: unproxiableSelections,\r\n        proxiableSubschemas: proxiableSubschemas,\r\n        nonProxiableSubschemas: nonProxiableSubschemas,\r\n    };\r\n}\r\nfunction mergeFields(mergedTypeInfo, typeName, object, originalSelections, sourceSubschemas, targetSubschemas, context, info) {\r\n    if (!originalSelections.length) {\r\n        return object;\r\n    }\r\n    var _a = buildDelegationPlan(mergedTypeInfo, originalSelections, sourceSubschemas, targetSubschemas), delegationMap = _a.delegationMap, unproxiableSelections = _a.unproxiableSelections, proxiableSubschemas = _a.proxiableSubschemas, nonProxiableSubschemas = _a.nonProxiableSubschemas;\r\n    if (!delegationMap.size) {\r\n        return object;\r\n    }\r\n    var maybePromises = [];\r\n    delegationMap.forEach(function (selections, s) {\r\n        var maybePromise = s.merge[typeName].resolve(object, context, info, s, {\r\n            kind: Kind.SELECTION_SET,\r\n            selections: selections,\r\n        });\r\n        maybePromises.push(maybePromise);\r\n    });\r\n    var containsPromises = false;\r\n    for (var _i = 0, maybePromises_1 = maybePromises; _i < maybePromises_1.length; _i++) {\r\n        var maybePromise = maybePromises_1[_i];\r\n        if (maybePromise instanceof Promise) {\r\n            containsPromises = true;\r\n            break;\r\n        }\r\n    }\r\n    return containsPromises\r\n        ? Promise.all(maybePromises).then(function (results) {\r\n            return mergeFields(mergedTypeInfo, typeName, mergeProxiedResults.apply(void 0, __spreadArrays([object], results)), unproxiableSelections, sourceSubschemas.concat(proxiableSubschemas), nonProxiableSubschemas, context, info);\r\n        })\r\n        : mergeFields(mergedTypeInfo, typeName, mergeProxiedResults.apply(void 0, __spreadArrays([object], maybePromises)), unproxiableSelections, sourceSubschemas.concat(proxiableSubschemas), nonProxiableSubschemas, context, info);\r\n}\n\nfunction handleObject(type, object, errors, subschema, context, info, skipTypeMerging) {\r\n    setErrors(object, errors.map(function (error) {\r\n        return relocatedError(error, error.nodes, error.path != null ? error.path.slice(1) : undefined);\r\n    }));\r\n    setObjectSubschema(object, subschema);\r\n    if (skipTypeMerging || !info.mergeInfo) {\r\n        return object;\r\n    }\r\n    var typeName = isAbstractType(type)\r\n        ? info.schema.getTypeMap()[resolveFromParentTypename(object)].name\r\n        : type.name;\r\n    var mergedTypeInfo = info.mergeInfo.mergedTypes[typeName];\r\n    var targetSubschemas;\r\n    if (mergedTypeInfo != null) {\r\n        targetSubschemas = mergedTypeInfo.subschemas;\r\n    }\r\n    if (!targetSubschemas) {\r\n        return object;\r\n    }\r\n    targetSubschemas = targetSubschemas.filter(function (s) { return s !== subschema; });\r\n    if (!targetSubschemas.length) {\r\n        return object;\r\n    }\r\n    var subFields = collectSubFields(info, object.__typename);\r\n    var selections = getFieldsNotInSubschema(subFields, subschema, mergedTypeInfo, object.__typename);\r\n    return mergeFields(mergedTypeInfo, typeName, object, selections, [subschema], targetSubschemas, context, info);\r\n}\r\nfunction collectSubFields(info, typeName) {\r\n    var subFieldNodes = Object.create(null);\r\n    var visitedFragmentNames = Object.create(null);\r\n    info.fieldNodes.forEach(function (fieldNode) {\r\n        subFieldNodes = collectFields({\r\n            schema: info.schema,\r\n            variableValues: info.variableValues,\r\n            fragments: info.fragments,\r\n        }, info.schema.getType(typeName), fieldNode.selectionSet, subFieldNodes, visitedFragmentNames);\r\n    });\r\n    return subFieldNodes;\r\n}\r\nfunction getFieldsNotInSubschema(subFieldNodes, subschema, mergedTypeInfo, typeName) {\r\n    var typeMap = isSubschemaConfig(subschema)\r\n        ? mergedTypeInfo.typeMaps.get(subschema)\r\n        : subschema.getTypeMap();\r\n    var fields = typeMap[typeName].getFields();\r\n    var fieldsNotInSchema = [];\r\n    Object.keys(subFieldNodes).forEach(function (responseName) {\r\n        subFieldNodes[responseName].forEach(function (subFieldNode) {\r\n            if (!(subFieldNode.name.value in fields)) {\r\n                fieldsNotInSchema.push(subFieldNode);\r\n            }\r\n        });\r\n    });\r\n    return fieldsNotInSchema;\r\n}\n\nfunction handleList(type, list, errors, subschema, context, info, skipTypeMerging) {\r\n    var childErrors = getErrorsByPathSegment(errors);\r\n    return list.map(function (listMember, index) {\r\n        return handleListMember(getNullableType(type.ofType), listMember, index, index in childErrors ? childErrors[index] : [], subschema, context, info, skipTypeMerging);\r\n    });\r\n}\r\nfunction handleListMember(type, listMember, index, errors, subschema, context, info, skipTypeMerging) {\r\n    if (listMember == null) {\r\n        return handleNull(info.fieldNodes, __spreadArrays(responsePathAsArray(info.path), [index]), errors);\r\n    }\r\n    if (isLeafType(type)) {\r\n        return type.parseValue(listMember);\r\n    }\r\n    else if (isCompositeType(type)) {\r\n        return handleObject(type, listMember, errors, subschema, context, info, skipTypeMerging);\r\n    }\r\n    else if (isListType(type)) {\r\n        return handleList(type, listMember, errors, subschema, context, info, skipTypeMerging);\r\n    }\r\n}\n\nfunction checkResultAndHandleErrors(result, context, info, responseKey, subschema, returnType, skipTypeMerging) {\r\n    if (responseKey === void 0) { responseKey = getResponseKeyFromInfo(info); }\r\n    if (returnType === void 0) { returnType = info.returnType; }\r\n    var errors = result.errors != null ? result.errors : [];\r\n    var data = result.data != null ? result.data[responseKey] : undefined;\r\n    return handleResult(data, errors, subschema, context, info, returnType, skipTypeMerging);\r\n}\r\nfunction handleResult(result, errors, subschema, context, info, returnType, skipTypeMerging) {\r\n    if (returnType === void 0) { returnType = info.returnType; }\r\n    var type = getNullableType(returnType);\r\n    if (result == null) {\r\n        return handleNull(info.fieldNodes, responsePathAsArray(info.path), errors);\r\n    }\r\n    if (isLeafType(type)) {\r\n        return type.parseValue(result);\r\n    }\r\n    else if (isCompositeType(type)) {\r\n        return handleObject(type, result, errors, subschema, context, info, skipTypeMerging);\r\n    }\r\n    else if (isListType(type)) {\r\n        return handleList(type, result, errors, subschema, context, info, skipTypeMerging);\r\n    }\r\n}\n\nvar CheckResultAndHandleErrors = /** @class */ (function () {\r\n    function CheckResultAndHandleErrors(info, fieldName, subschema, context, returnType, typeMerge) {\r\n        if (returnType === void 0) { returnType = info.returnType; }\r\n        this.context = context;\r\n        this.info = info;\r\n        this.fieldName = fieldName;\r\n        this.subschema = subschema;\r\n        this.returnType = returnType;\r\n        this.typeMerge = typeMerge;\r\n    }\r\n    CheckResultAndHandleErrors.prototype.transformResult = function (result) {\r\n        return checkResultAndHandleErrors(result, this.context != null ? this.context : {}, this.info, this.fieldName, this.subschema, this.returnType, this.typeMerge);\r\n    };\r\n    return CheckResultAndHandleErrors;\r\n}());\n\nfunction transformInputValue(type, value, transformer) {\r\n    if (value == null) {\r\n        return value;\r\n    }\r\n    var nullableType = getNullableType(type);\r\n    if (isLeafType(nullableType)) {\r\n        return transformer(nullableType, value);\r\n    }\r\n    else if (isListType(nullableType)) {\r\n        return value.map(function (listMember) {\r\n            return transformInputValue(nullableType.ofType, listMember, transformer);\r\n        });\r\n    }\r\n    else if (isInputObjectType(nullableType)) {\r\n        var fields_1 = nullableType.getFields();\r\n        return keyValMap(Object.keys(value), function (key) { return key; }, function (key) { return transformInputValue(fields_1[key].type, value[key], transformer); });\r\n    }\r\n    // unreachable, no other possible return value\r\n}\r\nfunction serializeInputValue(type, value) {\r\n    return transformInputValue(type, value, function (t, v) { return t.serialize(v); });\r\n}\r\nfunction parseInputValue(type, value) {\r\n    return transformInputValue(type, value, function (t, v) { return t.parseValue(v); });\r\n}\n\nfunction astFromType(type) {\r\n    if (isNonNullType(type)) {\r\n        var innerType = astFromType(type.ofType);\r\n        if (innerType.kind === Kind.NON_NULL_TYPE) {\r\n            throw new Error(\"Invalid type node \" + JSON.stringify(type) + \". Inner type of non-null type cannot be a non-null type.\");\r\n        }\r\n        return {\r\n            kind: Kind.NON_NULL_TYPE,\r\n            type: innerType,\r\n        };\r\n    }\r\n    else if (isListType(type)) {\r\n        return {\r\n            kind: Kind.LIST_TYPE,\r\n            type: astFromType(type.ofType),\r\n        };\r\n    }\r\n    return {\r\n        kind: Kind.NAMED_TYPE,\r\n        name: {\r\n            kind: Kind.NAME,\r\n            value: type.name,\r\n        },\r\n    };\r\n}\n\nfunction updateArgument(argName, argType, argumentNodes, variableDefinitionsMap, variableValues, newArg) {\r\n    var varName;\r\n    var numGeneratedVariables = 0;\r\n    do {\r\n        varName = \"_v\" + (numGeneratedVariables++).toString() + \"_\" + argName;\r\n    } while (varName in variableDefinitionsMap);\r\n    argumentNodes[argName] = {\r\n        kind: Kind.ARGUMENT,\r\n        name: {\r\n            kind: Kind.NAME,\r\n            value: argName,\r\n        },\r\n        value: {\r\n            kind: Kind.VARIABLE,\r\n            name: {\r\n                kind: Kind.NAME,\r\n                value: varName,\r\n            },\r\n        },\r\n    };\r\n    variableDefinitionsMap[varName] = {\r\n        kind: Kind.VARIABLE_DEFINITION,\r\n        variable: {\r\n            kind: Kind.VARIABLE,\r\n            name: {\r\n                kind: Kind.NAME,\r\n                value: varName,\r\n            },\r\n        },\r\n        type: astFromType(argType),\r\n    };\r\n    variableValues[varName] = newArg;\r\n}\n\nfunction toObjMap(obj) {\r\n    if (Object.getPrototypeOf(obj) === null) {\r\n        return obj;\r\n    }\r\n    return Object.entries(obj).reduce(function (map, _a) {\r\n        var key = _a[0], value = _a[1];\r\n        map[key] = value;\r\n        return map;\r\n    }, Object.create(null));\r\n}\n\nvar AddArgumentsAsVariables = /** @class */ (function () {\r\n    function AddArgumentsAsVariables(targetSchema, args) {\r\n        this.targetSchema = targetSchema;\r\n        this.args = toObjMap(args);\r\n    }\r\n    AddArgumentsAsVariables.prototype.transformRequest = function (originalRequest) {\r\n        var _a = addVariablesToRootField(this.targetSchema, originalRequest, this.args), document = _a.document, newVariables = _a.newVariables;\r\n        return {\r\n            document: document,\r\n            variables: newVariables,\r\n        };\r\n    };\r\n    return AddArgumentsAsVariables;\r\n}());\r\nfunction addVariablesToRootField(targetSchema, originalRequest, args) {\r\n    var document = originalRequest.document;\r\n    var variableValues = originalRequest.variables;\r\n    var operations = document.definitions.filter(function (def) { return def.kind === Kind.OPERATION_DEFINITION; });\r\n    var fragments = document.definitions.filter(function (def) { return def.kind === Kind.FRAGMENT_DEFINITION; });\r\n    var newOperations = operations.map(function (operation) {\r\n        var variableDefinitionMap = keyValMap(operation.variableDefinitions, function (def) { return def.variable.name.value; }, function (def) { return def; });\r\n        var type;\r\n        if (operation.operation === 'subscription') {\r\n            type = targetSchema.getSubscriptionType();\r\n        }\r\n        else if (operation.operation === 'mutation') {\r\n            type = targetSchema.getMutationType();\r\n        }\r\n        else {\r\n            type = targetSchema.getQueryType();\r\n        }\r\n        var newSelectionSet = [];\r\n        operation.selectionSet.selections.forEach(function (selection) {\r\n            if (selection.kind === Kind.FIELD) {\r\n                var argumentNodes = selection.arguments;\r\n                var argumentNodeMap_1 = keyValMap(argumentNodes, function (argument) { return argument.name.value; }, function (argument) { return argument; });\r\n                var targetField = type.getFields()[selection.name.value];\r\n                // excludes __typename\r\n                if (targetField != null) {\r\n                    updateArguments(targetField, argumentNodeMap_1, variableDefinitionMap, variableValues, args);\r\n                }\r\n                newSelectionSet.push(__assign(__assign({}, selection), { arguments: Object.keys(argumentNodeMap_1).map(function (argName) { return argumentNodeMap_1[argName]; }) }));\r\n            }\r\n            else {\r\n                newSelectionSet.push(selection);\r\n            }\r\n        });\r\n        return __assign(__assign({}, operation), { variableDefinitions: Object.keys(variableDefinitionMap).map(function (varName) { return variableDefinitionMap[varName]; }), selectionSet: {\r\n                kind: Kind.SELECTION_SET,\r\n                selections: newSelectionSet,\r\n            } });\r\n    });\r\n    return {\r\n        document: __assign(__assign({}, document), { definitions: __spreadArrays(newOperations, fragments) }),\r\n        newVariables: variableValues,\r\n    };\r\n}\r\nfunction updateArguments(targetField, argumentNodeMap, variableDefinitionMap, variableValues, newArgs) {\r\n    targetField.args.forEach(function (argument) {\r\n        var argName = argument.name;\r\n        var argType = argument.type;\r\n        if (argName in newArgs) {\r\n            updateArgument(argName, argType, argumentNodeMap, variableDefinitionMap, variableValues, serializeInputValue(argType, newArgs[argName]));\r\n        }\r\n    });\r\n}\n\nvar version;\r\nif (versionInfo != null && versionInfo.major >= 15) {\r\n    version = 15;\r\n}\r\nelse if (getOperationRootType != null) {\r\n    version = 14;\r\n}\r\nelse if (lexicographicSortSchema != null) {\r\n    version = 13;\r\n}\r\nelse if (printError != null) {\r\n    version = 12;\r\n}\r\nelse {\r\n    version = 11;\r\n}\r\nfunction graphqlVersion() {\r\n    return version;\r\n}\n\nvar hasOwn = Object.prototype.hasOwnProperty;\r\nfunction hasOwnProperty(object, propertyName) {\r\n    return hasOwn.call(object, propertyName);\r\n}\n\n// graphql <v14.2 does not support toConfig\r\nfunction schemaToConfig(schema) {\r\n    if (schema.toConfig != null) {\r\n        return schema.toConfig();\r\n    }\r\n    var newTypes = [];\r\n    var types = schema.getTypeMap();\r\n    Object.keys(types).forEach(function (typeName) {\r\n        newTypes.push(types[typeName]);\r\n    });\r\n    var schemaConfig = {\r\n        query: schema.getQueryType(),\r\n        mutation: schema.getMutationType(),\r\n        subscription: schema.getSubscriptionType(),\r\n        types: newTypes,\r\n        directives: schema.getDirectives().slice(),\r\n        extensions: schema.extensions,\r\n        astNode: schema.astNode,\r\n        extensionASTNodes: schema.extensionASTNodes != null ? schema.extensionASTNodes : [],\r\n        assumeValid: schema.__validationErrors !==\r\n            undefined,\r\n    };\r\n    if (graphqlVersion() >= 15) {\r\n        schemaConfig.description = schema.description;\r\n    }\r\n    return schemaConfig;\r\n}\r\nfunction toConfig(graphqlObject) {\r\n    if (isSchema(graphqlObject)) {\r\n        return schemaToConfig(graphqlObject);\r\n    }\r\n    else if (isDirective(graphqlObject)) {\r\n        return directiveToConfig(graphqlObject);\r\n    }\r\n    else if (isNamedType(graphqlObject)) {\r\n        return typeToConfig(graphqlObject);\r\n    }\r\n    // Input and output fields do not have predicates defined, but using duck typing,\r\n    // type is defined for input and output fields\r\n    if (graphqlObject.type != null) {\r\n        if (graphqlObject.args != null ||\r\n            graphqlObject.resolve != null ||\r\n            graphqlObject.subscribe != null) {\r\n            return fieldToConfig(graphqlObject);\r\n        }\r\n        else if (graphqlObject.defaultValue !== undefined) {\r\n            return inputFieldToConfig(graphqlObject);\r\n        }\r\n        // Not all input and output fields can be checked by above in older versions\r\n        // of graphql, but almost all properties on the field and config are identical.\r\n        // In particular, just name and isDeprecated should be removed.\r\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n        var name_1 = graphqlObject.name, isDeprecated = graphqlObject.isDeprecated, rest = __rest(graphqlObject, [\"name\", \"isDeprecated\"]);\r\n        return __assign({}, rest);\r\n    }\r\n    throw new Error(\"Unknown graphql object \" + graphqlObject);\r\n}\r\nfunction typeToConfig(type) {\r\n    if (isObjectType(type)) {\r\n        return objectTypeToConfig(type);\r\n    }\r\n    else if (isInterfaceType(type)) {\r\n        return interfaceTypeToConfig(type);\r\n    }\r\n    else if (isUnionType(type)) {\r\n        return unionTypeToConfig(type);\r\n    }\r\n    else if (isEnumType(type)) {\r\n        return enumTypeToConfig(type);\r\n    }\r\n    else if (isScalarType(type)) {\r\n        return scalarTypeToConfig(type);\r\n    }\r\n    else if (isInputObjectType(type)) {\r\n        return inputObjectTypeToConfig(type);\r\n    }\r\n    throw new Error(\"Unknown type \" + type);\r\n}\r\nfunction objectTypeToConfig(type) {\r\n    if (type.toConfig != null) {\r\n        return type.toConfig();\r\n    }\r\n    var typeConfig = {\r\n        name: type.name,\r\n        description: type.description,\r\n        interfaces: type.getInterfaces(),\r\n        fields: fieldMapToConfig(type.getFields()),\r\n        isTypeOf: type.isTypeOf,\r\n        extensions: type.extensions,\r\n        astNode: type.astNode,\r\n        extensionASTNodes: type.extensionASTNodes != null ? type.extensionASTNodes : [],\r\n    };\r\n    return typeConfig;\r\n}\r\nfunction interfaceTypeToConfig(type) {\r\n    if (type.toConfig != null) {\r\n        return type.toConfig();\r\n    }\r\n    var typeConfig = {\r\n        name: type.name,\r\n        description: type.description,\r\n        fields: fieldMapToConfig(type.getFields()),\r\n        resolveType: type.resolveType,\r\n        extensions: type.extensions,\r\n        astNode: type.astNode,\r\n        extensionASTNodes: type.extensionASTNodes != null ? type.extensionASTNodes : [],\r\n    };\r\n    if (graphqlVersion() >= 15) {\r\n        typeConfig.interfaces = type.getInterfaces();\r\n    }\r\n    return typeConfig;\r\n}\r\nfunction unionTypeToConfig(type) {\r\n    if (type.toConfig != null) {\r\n        return type.toConfig();\r\n    }\r\n    var typeConfig = {\r\n        name: type.name,\r\n        description: type.description,\r\n        types: type.getTypes(),\r\n        resolveType: type.resolveType,\r\n        extensions: type.extensions,\r\n        astNode: type.astNode,\r\n        extensionASTNodes: type.extensionASTNodes != null ? type.extensionASTNodes : [],\r\n    };\r\n    return typeConfig;\r\n}\r\nfunction enumTypeToConfig(type) {\r\n    if (type.toConfig != null) {\r\n        return type.toConfig();\r\n    }\r\n    var newValues = keyValMap(type.getValues(), function (value) { return value.name; }, function (value) { return ({\r\n        description: value.description,\r\n        value: value.value,\r\n        deprecationReason: value.deprecationReason,\r\n        extensions: value.extensions,\r\n        astNode: value.astNode,\r\n    }); });\r\n    var typeConfig = {\r\n        name: type.name,\r\n        description: type.description,\r\n        values: newValues,\r\n        extensions: type.extensions,\r\n        astNode: type.astNode,\r\n        extensionASTNodes: type.extensionASTNodes != null ? type.extensionASTNodes : [],\r\n    };\r\n    return typeConfig;\r\n}\r\nfunction scalarTypeToConfig(type) {\r\n    if (type.toConfig != null) {\r\n        return type.toConfig();\r\n    }\r\n    var typeConfig = {\r\n        name: type.name,\r\n        description: type.description,\r\n        serialize: graphqlVersion() >= 14 || hasOwnProperty(type, 'serialize')\r\n            ? type.serialize\r\n            : type._scalarConfig.serialize,\r\n        parseValue: graphqlVersion() >= 14 || hasOwnProperty(type, 'parseValue')\r\n            ? type.parseValue\r\n            : type._scalarConfig.parseValue,\r\n        parseLiteral: graphqlVersion() >= 14 || hasOwnProperty(type, 'parseLiteral')\r\n            ? type.parseLiteral\r\n            : type._scalarConfig.parseLiteral,\r\n        extensions: type.extensions,\r\n        astNode: type.astNode,\r\n        extensionASTNodes: type.extensionASTNodes != null ? type.extensionASTNodes : [],\r\n    };\r\n    return typeConfig;\r\n}\r\nfunction inputObjectTypeToConfig(type) {\r\n    if (type.toConfig != null) {\r\n        return type.toConfig();\r\n    }\r\n    var typeConfig = {\r\n        name: type.name,\r\n        description: type.description,\r\n        fields: inputFieldMapToConfig(type.getFields()),\r\n        extensions: type.extensions,\r\n        astNode: type.astNode,\r\n        extensionASTNodes: type.extensionASTNodes != null ? type.extensionASTNodes : [],\r\n    };\r\n    return typeConfig;\r\n}\r\nfunction inputFieldMapToConfig(fields) {\r\n    return keyValMap(Object.keys(fields), function (fieldName) { return fieldName; }, function (fieldName) { return toConfig(fields[fieldName]); });\r\n}\r\nfunction inputFieldToConfig(field) {\r\n    return {\r\n        description: field.description,\r\n        type: field.type,\r\n        defaultValue: field.defaultValue,\r\n        extensions: field.extensions,\r\n        astNode: field.astNode,\r\n    };\r\n}\r\nfunction directiveToConfig(directive) {\r\n    if (directive.toConfig != null) {\r\n        return directive.toConfig();\r\n    }\r\n    var directiveConfig = {\r\n        name: directive.name,\r\n        description: directive.description,\r\n        locations: directive.locations,\r\n        args: argumentMapToConfig(directive.args),\r\n        isRepeatable: directive.isRepeatable,\r\n        extensions: directive.extensions,\r\n        astNode: directive.astNode,\r\n    };\r\n    return directiveConfig;\r\n}\r\nfunction fieldMapToConfig(fields) {\r\n    return keyValMap(Object.keys(fields), function (fieldName) { return fieldName; }, function (fieldName) { return toConfig(fields[fieldName]); });\r\n}\r\nfunction fieldToConfig(field) {\r\n    return {\r\n        description: field.description,\r\n        type: field.type,\r\n        args: argumentMapToConfig(field.args),\r\n        resolve: field.resolve,\r\n        subscribe: field.subscribe,\r\n        deprecationReason: field.deprecationReason,\r\n        extensions: field.extensions,\r\n        astNode: field.astNode,\r\n    };\r\n}\r\nfunction argumentMapToConfig(args) {\r\n    var newArguments = {};\r\n    args.forEach(function (arg) {\r\n        newArguments[arg.name] = argumentToConfig(arg);\r\n    });\r\n    return newArguments;\r\n}\r\nfunction argumentToConfig(arg) {\r\n    return {\r\n        description: arg.description,\r\n        type: arg.type,\r\n        defaultValue: arg.defaultValue,\r\n        extensions: arg.extensions,\r\n        astNode: arg.astNode,\r\n    };\r\n}\n\nfunction isSpecifiedScalarType(type) {\r\n    return (isNamedType(type) &&\r\n        // Would prefer to use specifiedScalarTypes.some(), however %checks needs\r\n        // a simple expression.\r\n        (type.name === GraphQLString.name ||\r\n            type.name === GraphQLInt.name ||\r\n            type.name === GraphQLFloat.name ||\r\n            type.name === GraphQLBoolean.name ||\r\n            type.name === GraphQLID.name));\r\n}\n\nfunction mapSchema(schema, schemaMapper) {\r\n    if (schemaMapper === void 0) { schemaMapper = {}; }\r\n    var originalTypeMap = schema.getTypeMap();\r\n    var newTypeMap = Object.create(null);\r\n    Object.keys(originalTypeMap).forEach(function (typeName) {\r\n        if (!typeName.startsWith('__')) {\r\n            var typeMapper = getMapper(schema, schemaMapper, originalTypeMap[typeName]);\r\n            if (typeMapper != null) {\r\n                var newType = typeMapper(originalTypeMap[typeName], schema);\r\n                newTypeMap[typeName] =\r\n                    newType !== undefined ? newType : originalTypeMap[typeName];\r\n            }\r\n            else {\r\n                newTypeMap[typeName] = originalTypeMap[typeName];\r\n            }\r\n        }\r\n    });\r\n    var queryType = schema.getQueryType();\r\n    var mutationType = schema.getMutationType();\r\n    var subscriptionType = schema.getSubscriptionType();\r\n    var newQueryTypeName = queryType != null\r\n        ? newTypeMap[queryType.name] != null\r\n            ? newTypeMap[queryType.name].name\r\n            : undefined\r\n        : undefined;\r\n    var newMutationTypeName = mutationType != null\r\n        ? newTypeMap[mutationType.name] != null\r\n            ? newTypeMap[mutationType.name].name\r\n            : undefined\r\n        : undefined;\r\n    var newSubscriptionTypeName = subscriptionType != null\r\n        ? newTypeMap[subscriptionType.name] != null\r\n            ? newTypeMap[subscriptionType.name].name\r\n            : undefined\r\n        : undefined;\r\n    var originalDirectives = schema.getDirectives();\r\n    var newDirectives = [];\r\n    originalDirectives.forEach(function (directive) {\r\n        var directiveMapper = getMapper(schema, schemaMapper, directive);\r\n        if (directiveMapper != null) {\r\n            var newDirective = directiveMapper(directive, schema);\r\n            if (newDirective != null) {\r\n                newDirectives.push(newDirective);\r\n            }\r\n        }\r\n        else {\r\n            newDirectives.push(directive);\r\n        }\r\n    });\r\n    var _a = rewireTypes(newTypeMap, newDirectives), typeMap = _a.typeMap, directives = _a.directives;\r\n    return new GraphQLSchema(__assign(__assign({}, toConfig(schema)), { query: newQueryTypeName\r\n            ? typeMap[newQueryTypeName]\r\n            : undefined, mutation: newMutationTypeName\r\n            ? typeMap[newMutationTypeName]\r\n            : undefined, subscription: newSubscriptionTypeName != null\r\n            ? typeMap[newSubscriptionTypeName]\r\n            : undefined, types: Object.keys(typeMap).map(function (typeName) { return typeMap[typeName]; }), directives: directives }));\r\n}\r\nfunction getTypeSpecifiers(type, schema) {\r\n    var specifiers = [MapperKind.TYPE];\r\n    if (isObjectType(type)) {\r\n        specifiers.push(MapperKind.COMPOSITE_TYPE, MapperKind.OBJECT_TYPE);\r\n        var query = schema.getQueryType();\r\n        var mutation = schema.getMutationType();\r\n        var subscription = schema.getSubscriptionType();\r\n        if (type === query) {\r\n            specifiers.push(MapperKind.ROOT_OBJECT, MapperKind.QUERY);\r\n        }\r\n        else if (type === mutation) {\r\n            specifiers.push(MapperKind.ROOT_OBJECT, MapperKind.MUTATION);\r\n        }\r\n        else if (type === subscription) {\r\n            specifiers.push(MapperKind.ROOT_OBJECT, MapperKind.SUBSCRIPTION);\r\n        }\r\n    }\r\n    else if (isInputType(type)) {\r\n        specifiers.push(MapperKind.INPUT_OBJECT_TYPE);\r\n    }\r\n    else if (isInterfaceType(type)) {\r\n        specifiers.push(MapperKind.COMPOSITE_TYPE, MapperKind.ABSTRACT_TYPE, MapperKind.INTERFACE_TYPE);\r\n    }\r\n    else if (isUnionType(type)) {\r\n        specifiers.push(MapperKind.COMPOSITE_TYPE, MapperKind.ABSTRACT_TYPE, MapperKind.UNION_TYPE);\r\n    }\r\n    else if (isEnumType(type)) {\r\n        specifiers.push(MapperKind.ENUM_TYPE);\r\n    }\r\n    else if (isScalarType(type)) {\r\n        specifiers.push(MapperKind.SCALAR_TYPE);\r\n    }\r\n    return specifiers;\r\n}\r\nfunction getMapper(schema, schemaMapper, typeOrDirective) {\r\n    if (isNamedType(typeOrDirective)) {\r\n        var specifiers = getTypeSpecifiers(typeOrDirective, schema);\r\n        var typeMapper = void 0;\r\n        var stack = __spreadArrays(specifiers);\r\n        while (!typeMapper && stack.length > 0) {\r\n            var next = stack.pop();\r\n            typeMapper = schemaMapper[next];\r\n        }\r\n        return typeMapper != null ? typeMapper : null;\r\n    }\r\n    else if (isDirective(typeOrDirective)) {\r\n        var directiveMapper = schemaMapper[MapperKind.DIRECTIVE];\r\n        return directiveMapper != null ? directiveMapper : null;\r\n    }\r\n}\r\nfunction rewireTypes(originalTypeMap, directives) {\r\n    var newTypeMap = Object.create(null);\r\n    Object.keys(originalTypeMap).forEach(function (typeName) {\r\n        var namedType = originalTypeMap[typeName];\r\n        if (namedType == null || typeName.startsWith('__')) {\r\n            return;\r\n        }\r\n        var newName = namedType.name;\r\n        if (newName.startsWith('__')) {\r\n            return;\r\n        }\r\n        if (newTypeMap[newName] != null) {\r\n            throw new Error(\"Duplicate schema type name \" + newName);\r\n        }\r\n        newTypeMap[newName] = namedType;\r\n    });\r\n    Object.keys(newTypeMap).forEach(function (typeName) {\r\n        newTypeMap[typeName] = rewireNamedType(newTypeMap[typeName]);\r\n    });\r\n    var newDirectives = directives.map(function (directive) {\r\n        return rewireDirective(directive);\r\n    });\r\n    return pruneTypes(newTypeMap, newDirectives);\r\n    function rewireDirective(directive) {\r\n        var directiveConfig = toConfig(directive);\r\n        directiveConfig.args = rewireArgs(directiveConfig.args);\r\n        return new GraphQLDirective(directiveConfig);\r\n    }\r\n    function rewireArgs(args) {\r\n        var rewiredArgs = {};\r\n        Object.keys(args).forEach(function (argName) {\r\n            var arg = args[argName];\r\n            var rewiredArgType = rewireType(arg.type);\r\n            if (rewiredArgType != null) {\r\n                arg.type = rewiredArgType;\r\n                rewiredArgs[argName] = arg;\r\n            }\r\n        });\r\n        return rewiredArgs;\r\n    }\r\n    function rewireNamedType(type) {\r\n        if (isObjectType(type)) {\r\n            var config_1 = toConfig(type);\r\n            var newConfig = __assign(__assign({}, config_1), { fields: function () { return rewireFields(config_1.fields); }, interfaces: function () { return rewireNamedTypes(config_1.interfaces); } });\r\n            return new GraphQLObjectType(newConfig);\r\n        }\r\n        else if (isInterfaceType(type)) {\r\n            var config_2 = toConfig(type);\r\n            var newConfig = __assign(__assign({}, config_2), { fields: function () { return rewireFields(config_2.fields); } });\r\n            if (graphqlVersion() >= 15) {\r\n                newConfig.interfaces = function () { return rewireNamedTypes(config_2.interfaces); };\r\n            }\r\n            return new GraphQLInterfaceType(newConfig);\r\n        }\r\n        else if (isUnionType(type)) {\r\n            var config_3 = toConfig(type);\r\n            var newConfig = __assign(__assign({}, config_3), { types: function () { return rewireNamedTypes(config_3.types); } });\r\n            return new GraphQLUnionType(newConfig);\r\n        }\r\n        else if (isInputObjectType(type)) {\r\n            var config_4 = toConfig(type);\r\n            var newConfig = __assign(__assign({}, config_4), { fields: function () { return rewireInputFields(config_4.fields); } });\r\n            return new GraphQLInputObjectType(newConfig);\r\n        }\r\n        else if (isEnumType(type)) {\r\n            var enumConfig = toConfig(type);\r\n            return new GraphQLEnumType(enumConfig);\r\n        }\r\n        else if (isScalarType(type)) {\r\n            if (isSpecifiedScalarType(type)) {\r\n                return type;\r\n            }\r\n            var scalarConfig = toConfig(type);\r\n            return new GraphQLScalarType(scalarConfig);\r\n        }\r\n        throw new Error(\"Unexpected schema type: \" + type);\r\n    }\r\n    function rewireFields(fields) {\r\n        var rewiredFields = {};\r\n        Object.keys(fields).forEach(function (fieldName) {\r\n            var field = fields[fieldName];\r\n            var rewiredFieldType = rewireType(field.type);\r\n            if (rewiredFieldType != null) {\r\n                field.type = rewiredFieldType;\r\n                field.args = rewireArgs(field.args);\r\n                rewiredFields[fieldName] = field;\r\n            }\r\n        });\r\n        return rewiredFields;\r\n    }\r\n    function rewireInputFields(fields) {\r\n        var rewiredFields = {};\r\n        Object.keys(fields).forEach(function (fieldName) {\r\n            var field = fields[fieldName];\r\n            var rewiredFieldType = rewireType(field.type);\r\n            if (rewiredFieldType != null) {\r\n                field.type = rewiredFieldType;\r\n                rewiredFields[fieldName] = field;\r\n            }\r\n        });\r\n        return rewiredFields;\r\n    }\r\n    function rewireNamedTypes(namedTypes) {\r\n        var rewiredTypes = [];\r\n        namedTypes.forEach(function (namedType) {\r\n            var rewiredType = rewireType(namedType);\r\n            if (rewiredType != null) {\r\n                rewiredTypes.push(rewiredType);\r\n            }\r\n        });\r\n        return rewiredTypes;\r\n    }\r\n    function rewireType(type) {\r\n        if (isListType(type)) {\r\n            var rewiredType = rewireType(type.ofType);\r\n            return rewiredType != null ? new GraphQLList(rewiredType) : null;\r\n        }\r\n        else if (isNonNullType(type)) {\r\n            var rewiredType = rewireType(type.ofType);\r\n            return rewiredType != null\r\n                ? new GraphQLNonNull(rewiredType)\r\n                : null;\r\n        }\r\n        else if (isNamedType(type)) {\r\n            var originalType = originalTypeMap[type.name];\r\n            return originalType != null ? newTypeMap[originalType.name] : null;\r\n        }\r\n        return null;\r\n    }\r\n}\r\nfunction pruneTypes(typeMap, directives) {\r\n    var newTypeMap = {};\r\n    var implementedInterfaces = {};\r\n    Object.keys(typeMap).forEach(function (typeName) {\r\n        var namedType = typeMap[typeName];\r\n        if (isObjectType(namedType) ||\r\n            (graphqlVersion() >= 15 && isInterfaceType(namedType))) {\r\n            namedType.getInterfaces().forEach(function (iface) {\r\n                implementedInterfaces[iface.name] = true;\r\n            });\r\n        }\r\n    });\r\n    var prunedTypeMap = false;\r\n    var typeNames = Object.keys(typeMap);\r\n    for (var i = 0; i < typeNames.length; i++) {\r\n        var typeName = typeNames[i];\r\n        var type = typeMap[typeName];\r\n        if (isObjectType(type) || isInputObjectType(type)) {\r\n            // prune types with no fields\r\n            if (Object.keys(type.getFields()).length) {\r\n                newTypeMap[typeName] = type;\r\n            }\r\n            else {\r\n                prunedTypeMap = true;\r\n            }\r\n        }\r\n        else if (isUnionType(type)) {\r\n            // prune unions without underlying types\r\n            if (type.getTypes().length) {\r\n                newTypeMap[typeName] = type;\r\n            }\r\n            else {\r\n                prunedTypeMap = true;\r\n            }\r\n        }\r\n        else if (isInterfaceType(type)) {\r\n            // prune interfaces without fields or without implementations\r\n            if (Object.keys(type.getFields()).length &&\r\n                implementedInterfaces[type.name]) {\r\n                newTypeMap[typeName] = type;\r\n            }\r\n            else {\r\n                prunedTypeMap = true;\r\n            }\r\n        }\r\n        else {\r\n            newTypeMap[typeName] = type;\r\n        }\r\n    }\r\n    // every prune requires another round of healing\r\n    return prunedTypeMap\r\n        ? rewireTypes(newTypeMap, directives)\r\n        : { typeMap: typeMap, directives: directives };\r\n}\n\nfunction filterSchema(_a) {\r\n    var _b;\r\n    var schema = _a.schema, _c = _a.rootFieldFilter, rootFieldFilter = _c === void 0 ? function () { return true; } : _c, _d = _a.typeFilter, typeFilter = _d === void 0 ? function () { return true; } : _d, _e = _a.fieldFilter, fieldFilter = _e === void 0 ? function () { return true; } : _e;\r\n    var filteredSchema = mapSchema(schema, (_b = {},\r\n        _b[MapperKind.QUERY] = function (type) {\r\n            return filterRootFields(type, 'Query', rootFieldFilter);\r\n        },\r\n        _b[MapperKind.MUTATION] = function (type) {\r\n            return filterRootFields(type, 'Mutation', rootFieldFilter);\r\n        },\r\n        _b[MapperKind.SUBSCRIPTION] = function (type) {\r\n            return filterRootFields(type, 'Subscription', rootFieldFilter);\r\n        },\r\n        _b[MapperKind.OBJECT_TYPE] = function (type) {\r\n            return typeFilter(type.name, type)\r\n                ? filterObjectFields(type, fieldFilter)\r\n                : null;\r\n        },\r\n        _b[MapperKind.INTERFACE_TYPE] = function (type) {\r\n            return typeFilter(type.name, type) ? undefined : null;\r\n        },\r\n        _b[MapperKind.UNION_TYPE] = function (type) {\r\n            return typeFilter(type.name, type) ? undefined : null;\r\n        },\r\n        _b[MapperKind.INPUT_OBJECT_TYPE] = function (type) {\r\n            return typeFilter(type.name, type) ? undefined : null;\r\n        },\r\n        _b[MapperKind.ENUM_TYPE] = function (type) {\r\n            return typeFilter(type.name, type) ? undefined : null;\r\n        },\r\n        _b[MapperKind.SCALAR_TYPE] = function (type) {\r\n            return typeFilter(type.name, type) ? undefined : null;\r\n        },\r\n        _b));\r\n    filteredSchema.transforms = schema.transforms;\r\n    return filteredSchema;\r\n}\r\nfunction filterRootFields(type, operation, rootFieldFilter) {\r\n    var config = toConfig(type);\r\n    Object.keys(config.fields).forEach(function (fieldName) {\r\n        if (!rootFieldFilter(operation, fieldName, config.fields[fieldName])) {\r\n            delete config.fields[fieldName];\r\n        }\r\n    });\r\n    return new GraphQLObjectType(config);\r\n}\r\nfunction filterObjectFields(type, fieldFilter) {\r\n    var config = toConfig(type);\r\n    Object.keys(config.fields).forEach(function (fieldName) {\r\n        if (!fieldFilter(type.name, fieldName, config.fields[fieldName])) {\r\n            delete config.fields[fieldName];\r\n        }\r\n    });\r\n    return new GraphQLObjectType(config);\r\n}\n\nfunction cloneDirective(directive) {\r\n    return new GraphQLDirective(toConfig(directive));\r\n}\r\nfunction cloneType(type) {\r\n    if (isObjectType(type)) {\r\n        var config = toConfig(type);\r\n        return new GraphQLObjectType(__assign(__assign({}, config), { interfaces: typeof config.interfaces === 'function'\r\n                ? config.interfaces\r\n                : config.interfaces.slice() }));\r\n    }\r\n    else if (isInterfaceType(type)) {\r\n        var config = toConfig(type);\r\n        var newConfig = __assign(__assign({}, config), { interfaces: graphqlVersion() >= 15\r\n                ? typeof config.interfaces === 'function'\r\n                    ? config.interfaces\r\n                    : config.interfaces.slice()\r\n                : undefined });\r\n        return new GraphQLInterfaceType(newConfig);\r\n    }\r\n    else if (isUnionType(type)) {\r\n        var config = toConfig(type);\r\n        return new GraphQLUnionType(__assign(__assign({}, config), { types: config.types.slice() }));\r\n    }\r\n    else if (isInputObjectType(type)) {\r\n        return new GraphQLInputObjectType(toConfig(type));\r\n    }\r\n    else if (isEnumType(type)) {\r\n        return new GraphQLEnumType(toConfig(type));\r\n    }\r\n    else if (isScalarType(type)) {\r\n        return isSpecifiedScalarType(type)\r\n            ? type\r\n            : new GraphQLScalarType(toConfig(type));\r\n    }\r\n    throw new Error(\"Invalid type \" + type);\r\n}\r\nfunction cloneSchema(schema) {\r\n    return mapSchema(schema);\r\n}\n\n// polyfill for graphql prior to v13 which do not pass options to buildASTSchema\r\nfunction buildSchema(ast, buildSchemaOptions) {\r\n    return buildASTSchema(parse(ast), buildSchemaOptions);\r\n}\n\nfunction getResolversFromSchema(schema) {\r\n    var resolvers = Object.create({});\r\n    var typeMap = schema.getTypeMap();\r\n    Object.keys(typeMap).forEach(function (typeName) {\r\n        var type = typeMap[typeName];\r\n        if (isScalarType(type)) {\r\n            if (!isSpecifiedScalarType(type)) {\r\n                resolvers[typeName] = cloneType(type);\r\n            }\r\n        }\r\n        else if (isEnumType(type)) {\r\n            resolvers[typeName] = {};\r\n            var values = type.getValues();\r\n            values.forEach(function (value) {\r\n                resolvers[typeName][value.name] = value.value;\r\n            });\r\n        }\r\n        else if (isInterfaceType(type)) {\r\n            if (type.resolveType != null) {\r\n                resolvers[typeName] = {\r\n                    __resolveType: type.resolveType,\r\n                };\r\n            }\r\n        }\r\n        else if (isUnionType(type)) {\r\n            if (type.resolveType != null) {\r\n                resolvers[typeName] = {\r\n                    __resolveType: type.resolveType,\r\n                };\r\n            }\r\n        }\r\n        else if (isObjectType(type)) {\r\n            resolvers[typeName] = {};\r\n            if (type.isTypeOf != null) {\r\n                resolvers[typeName].__isTypeOf = type.isTypeOf;\r\n            }\r\n            var fields_1 = type.getFields();\r\n            Object.keys(fields_1).forEach(function (fieldName) {\r\n                var field = fields_1[fieldName];\r\n                resolvers[typeName][fieldName] = {\r\n                    resolve: field.resolve,\r\n                    subscribe: field.subscribe,\r\n                };\r\n            });\r\n        }\r\n    });\r\n    return resolvers;\r\n}\n\n// polyfill for graphql < v14.2 which does not support subscriptions\r\nfunction extendSchema(schema, extension, options) {\r\n    var subscriptionType = schema.getSubscriptionType();\r\n    if (subscriptionType == null) {\r\n        return extendSchema$1(schema, extension, options);\r\n    }\r\n    var resolvers = getResolversFromSchema(schema);\r\n    var subscriptionTypeName = subscriptionType.name;\r\n    var subscriptionResolvers = resolvers[subscriptionTypeName];\r\n    var extendedSchema = extendSchema$1(schema, extension, options);\r\n    var fields = extendedSchema.getSubscriptionType().getFields();\r\n    Object.keys(subscriptionResolvers).forEach(function (fieldName) {\r\n        fields[fieldName].subscribe = subscriptionResolvers[fieldName].subscribe;\r\n    });\r\n    return extendedSchema;\r\n}\n\n// A generic updater function for arrays or objects.\r\nfunction updateEachKey(arrayOrObject, \r\n// The callback can return nothing or undefined to leave the key untouched, null to remove\r\n// the key from the array or object, or a non-null V to replace the value.\r\nupdater) {\r\n    var deletedCount = 0;\r\n    Object.keys(arrayOrObject).forEach(function (key) {\r\n        var result = updater(arrayOrObject[key], key);\r\n        if (typeof result === 'undefined') {\r\n            return;\r\n        }\r\n        if (result === null) {\r\n            delete arrayOrObject[key];\r\n            deletedCount++;\r\n            return;\r\n        }\r\n        arrayOrObject[key] = result;\r\n    });\r\n    if (deletedCount > 0 && Array.isArray(arrayOrObject)) {\r\n        // Remove any holes from the array due to deleted elements.\r\n        arrayOrObject.splice(0).forEach(function (elem) {\r\n            arrayOrObject.push(elem);\r\n        });\r\n    }\r\n}\n\nfunction createNamedStub(name, type) {\r\n    var constructor;\r\n    if (type === 'object') {\r\n        constructor = GraphQLObjectType;\r\n    }\r\n    else if (type === 'interface') {\r\n        constructor = GraphQLInterfaceType;\r\n    }\r\n    else {\r\n        constructor = GraphQLInputObjectType;\r\n    }\r\n    return new constructor({\r\n        name: name,\r\n        fields: {\r\n            __fake: {\r\n                type: GraphQLString,\r\n            },\r\n        },\r\n    });\r\n}\r\nfunction createStub(node, type) {\r\n    switch (node.kind) {\r\n        case Kind.LIST_TYPE:\r\n            return new GraphQLList(createStub(node.type, type));\r\n        case Kind.NON_NULL_TYPE:\r\n            return new GraphQLNonNull(createStub(node.type, type));\r\n        default:\r\n            if (type === 'output') {\r\n                return createNamedStub(node.name.value, 'object');\r\n            }\r\n            return createNamedStub(node.name.value, 'input');\r\n    }\r\n}\r\nfunction isNamedStub(type) {\r\n    if (isObjectType(type) || isInterfaceType(type) || isInputObjectType(type)) {\r\n        var fields = type.getFields();\r\n        var fieldNames = Object.keys(fields);\r\n        return fieldNames.length === 1 && fields[fieldNames[0]].name === '__fake';\r\n    }\r\n    return false;\r\n}\r\nfunction getBuiltInForStub(type) {\r\n    switch (type.name) {\r\n        case GraphQLInt.name:\r\n            return GraphQLInt;\r\n        case GraphQLFloat.name:\r\n            return GraphQLFloat;\r\n        case GraphQLString.name:\r\n            return GraphQLString;\r\n        case GraphQLBoolean.name:\r\n            return GraphQLBoolean;\r\n        case GraphQLID.name:\r\n            return GraphQLID;\r\n        default:\r\n            return type;\r\n    }\r\n}\n\n// Update any references to named schema types that disagree with the named\r\n// types found in schema.getTypeMap().\r\nfunction healSchema(schema) {\r\n    var typeMap = schema.getTypeMap();\r\n    var directives = schema.getDirectives();\r\n    var queryType = schema.getQueryType();\r\n    var mutationType = schema.getMutationType();\r\n    var subscriptionType = schema.getSubscriptionType();\r\n    var newQueryTypeName = queryType != null\r\n        ? typeMap[queryType.name] != null\r\n            ? typeMap[queryType.name].name\r\n            : undefined\r\n        : undefined;\r\n    var newMutationTypeName = mutationType != null\r\n        ? typeMap[mutationType.name] != null\r\n            ? typeMap[mutationType.name].name\r\n            : undefined\r\n        : undefined;\r\n    var newSubscriptionTypeName = subscriptionType != null\r\n        ? typeMap[subscriptionType.name] != null\r\n            ? typeMap[subscriptionType.name].name\r\n            : undefined\r\n        : undefined;\r\n    healTypes(typeMap, directives);\r\n    var filteredTypeMap = {};\r\n    Object.keys(typeMap).forEach(function (typeName) {\r\n        if (!typeName.startsWith('__')) {\r\n            filteredTypeMap[typeName] = typeMap[typeName];\r\n        }\r\n    });\r\n    var healedSchema = new GraphQLSchema(__assign(__assign({}, toConfig(schema)), { query: newQueryTypeName ? filteredTypeMap[newQueryTypeName] : undefined, mutation: newMutationTypeName\r\n            ? filteredTypeMap[newMutationTypeName]\r\n            : undefined, subscription: newSubscriptionTypeName\r\n            ? filteredTypeMap[newSubscriptionTypeName]\r\n            : undefined, types: Object.keys(filteredTypeMap).map(function (typeName) { return filteredTypeMap[typeName]; }), directives: directives.slice() }));\r\n    // Reconstruct the schema to reinitialize private variables\r\n    // e.g. the stored implementation map and the proper root types.\r\n    Object.assign(schema, healedSchema);\r\n    return schema;\r\n}\r\nfunction healTypes(originalTypeMap, directives, config) {\r\n    if (config === void 0) { config = {\r\n        skipPruning: false,\r\n    }; }\r\n    var actualNamedTypeMap = Object.create(null);\r\n    // If any of the .name properties of the GraphQLNamedType objects in\r\n    // schema.getTypeMap() have changed, the keys of the type map need to\r\n    // be updated accordingly.\r\n    Object.entries(originalTypeMap).forEach(function (_a) {\r\n        var typeName = _a[0], namedType = _a[1];\r\n        if (namedType == null || typeName.startsWith('__')) {\r\n            return;\r\n        }\r\n        var actualName = namedType.name;\r\n        if (actualName.startsWith('__')) {\r\n            return;\r\n        }\r\n        if (actualName in actualNamedTypeMap) {\r\n            throw new Error(\"Duplicate schema type name \" + actualName);\r\n        }\r\n        actualNamedTypeMap[actualName] = namedType;\r\n        // Note: we are deliberately leaving namedType in the schema by its\r\n        // original name (which might be different from actualName), so that\r\n        // references by that name can be healed.\r\n    });\r\n    // Now add back every named type by its actual name.\r\n    Object.entries(actualNamedTypeMap).forEach(function (_a) {\r\n        var typeName = _a[0], namedType = _a[1];\r\n        originalTypeMap[typeName] = namedType;\r\n    });\r\n    // Directive declaration argument types can refer to named types.\r\n    directives.forEach(function (decl) {\r\n        updateEachKey(decl.args, function (arg) {\r\n            arg.type = healType(arg.type);\r\n            return arg.type === null ? null : arg;\r\n        });\r\n    });\r\n    Object.entries(originalTypeMap).forEach(function (_a) {\r\n        var typeName = _a[0], namedType = _a[1];\r\n        // Heal all named types, except for dangling references, kept only to redirect.\r\n        if (!typeName.startsWith('__') && typeName in actualNamedTypeMap) {\r\n            if (namedType != null) {\r\n                healNamedType(namedType);\r\n            }\r\n        }\r\n    });\r\n    updateEachKey(originalTypeMap, function (_namedType, typeName) {\r\n        // Dangling references to renamed types should remain in the schema\r\n        // during healing, but must be removed now, so that the following\r\n        // invariant holds for all names: schema.getType(name).name === name\r\n        if (!typeName.startsWith('__') && !(typeName in actualNamedTypeMap)) {\r\n            return null;\r\n        }\r\n    });\r\n    if (!config.skipPruning) {\r\n        pruneTypes$1(originalTypeMap, directives);\r\n    }\r\n    function healNamedType(type) {\r\n        if (isObjectType(type)) {\r\n            healFields(type);\r\n            healInterfaces(type);\r\n            return;\r\n        }\r\n        else if (isInterfaceType(type)) {\r\n            healFields(type);\r\n            if (graphqlVersion() >= 15) {\r\n                healInterfaces(type);\r\n            }\r\n            return;\r\n        }\r\n        else if (isUnionType(type)) {\r\n            healUnderlyingTypes(type);\r\n            return;\r\n        }\r\n        else if (isInputObjectType(type)) {\r\n            healInputFields(type);\r\n            return;\r\n        }\r\n        else if (isLeafType(type)) {\r\n            return;\r\n        }\r\n        throw new Error(\"Unexpected schema type: \" + type);\r\n    }\r\n    function healFields(type) {\r\n        updateEachKey(type.getFields(), function (field) {\r\n            updateEachKey(field.args, function (arg) {\r\n                arg.type = healType(arg.type);\r\n                return arg.type === null ? null : arg;\r\n            });\r\n            field.type = healType(field.type);\r\n            return field.type === null ? null : field;\r\n        });\r\n    }\r\n    function healInterfaces(type) {\r\n        updateEachKey(type.getInterfaces(), function (iface) {\r\n            var healedType = healType(iface);\r\n            return healedType;\r\n        });\r\n    }\r\n    function healInputFields(type) {\r\n        updateEachKey(type.getFields(), function (field) {\r\n            field.type = healType(field.type);\r\n            return field.type === null ? null : field;\r\n        });\r\n    }\r\n    function healUnderlyingTypes(type) {\r\n        updateEachKey(type.getTypes(), function (t) {\r\n            var healedType = healType(t);\r\n            return healedType;\r\n        });\r\n    }\r\n    function healType(type) {\r\n        // Unwrap the two known wrapper types\r\n        if (isListType(type)) {\r\n            var healedType = healType(type.ofType);\r\n            return healedType != null ? new GraphQLList(healedType) : null;\r\n        }\r\n        else if (isNonNullType(type)) {\r\n            var healedType = healType(type.ofType);\r\n            return healedType != null ? new GraphQLNonNull(healedType) : null;\r\n        }\r\n        else if (isNamedType(type)) {\r\n            // If a type annotation on a field or an argument or a union member is\r\n            // any `GraphQLNamedType` with a `name`, then it must end up identical\r\n            // to `schema.getType(name)`, since `schema.getTypeMap()` is the source\r\n            // of truth for all named schema types.\r\n            // Note that new types can still be simply added by adding a field, as\r\n            // the official type will be undefined, not null.\r\n            var officialType = originalTypeMap[type.name];\r\n            if (officialType === undefined) {\r\n                if (isNamedStub(type)) {\r\n                    officialType = getBuiltInForStub(type);\r\n                }\r\n                else {\r\n                    officialType = type;\r\n                }\r\n                originalTypeMap[type.name] = officialType;\r\n            }\r\n            return officialType;\r\n        }\r\n        return null;\r\n    }\r\n}\r\nfunction pruneTypes$1(typeMap, directives) {\r\n    var implementedInterfaces = {};\r\n    Object.values(typeMap).forEach(function (namedType) {\r\n        if (isObjectType(namedType) ||\r\n            (graphqlVersion() >= 15 && isInterfaceType(namedType))) {\r\n            namedType.getInterfaces().forEach(function (iface) {\r\n                implementedInterfaces[iface.name] = true;\r\n            });\r\n        }\r\n    });\r\n    var prunedTypeMap = false;\r\n    var typeNames = Object.keys(typeMap);\r\n    for (var i = 0; i < typeNames.length; i++) {\r\n        var typeName = typeNames[i];\r\n        var type = typeMap[typeName];\r\n        if (isObjectType(type) || isInputObjectType(type)) {\r\n            // prune types with no fields\r\n            if (!Object.keys(type.getFields()).length) {\r\n                typeMap[typeName] = null;\r\n                prunedTypeMap = true;\r\n            }\r\n        }\r\n        else if (isUnionType(type)) {\r\n            // prune unions without underlying types\r\n            if (!type.getTypes().length) {\r\n                typeMap[typeName] = null;\r\n                prunedTypeMap = true;\r\n            }\r\n        }\r\n        else if (isInterfaceType(type)) {\r\n            // prune interfaces without fields or without implementations\r\n            if (!Object.keys(type.getFields()).length ||\r\n                !(type.name in implementedInterfaces)) {\r\n                typeMap[typeName] = null;\r\n                prunedTypeMap = true;\r\n            }\r\n        }\r\n    }\r\n    // every prune requires another round of healing\r\n    if (prunedTypeMap) {\r\n        healTypes(typeMap, directives);\r\n    }\r\n}\n\n// Abstract base class of any visitor implementation, defining the available\r\n// visitor methods along with their parameter types, and providing a static\r\n// helper function for determining whether a subclass implements a given\r\n// visitor method, as opposed to inheriting one of the stubs defined here.\r\nvar SchemaVisitor = /** @class */ (function () {\r\n    function SchemaVisitor() {\r\n    }\r\n    // Determine if this SchemaVisitor (sub)class implements a particular\r\n    // visitor method.\r\n    SchemaVisitor.implementsVisitorMethod = function (methodName) {\r\n        if (!methodName.startsWith('visit')) {\r\n            return false;\r\n        }\r\n        var method = this.prototype[methodName];\r\n        if (typeof method !== 'function') {\r\n            return false;\r\n        }\r\n        if (this === SchemaVisitor) {\r\n            // The SchemaVisitor class implements every visitor method.\r\n            return true;\r\n        }\r\n        var stub = SchemaVisitor.prototype[methodName];\r\n        if (method === stub) {\r\n            // If this.prototype[methodName] was just inherited from SchemaVisitor,\r\n            // then this class does not really implement the method.\r\n            return false;\r\n        }\r\n        return true;\r\n    };\r\n    // Concrete subclasses of SchemaVisitor should override one or more of these\r\n    // visitor methods, in order to express their interest in handling certain\r\n    // schema types/locations. Each method may return null to remove the given\r\n    // type from the schema, a non-null value of the same type to update the\r\n    // type in the schema, or nothing to leave the type as it was.\r\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\r\n    SchemaVisitor.prototype.visitSchema = function (_schema) { };\r\n    SchemaVisitor.prototype.visitScalar = function (_scalar) { };\r\n    SchemaVisitor.prototype.visitObject = function (_object) { };\r\n    SchemaVisitor.prototype.visitFieldDefinition = function (_field, _details) { };\r\n    SchemaVisitor.prototype.visitArgumentDefinition = function (_argument, _details) { };\r\n    SchemaVisitor.prototype.visitInterface = function (_iface) { };\r\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\r\n    SchemaVisitor.prototype.visitUnion = function (_union) { };\r\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\r\n    SchemaVisitor.prototype.visitEnum = function (_type) { };\r\n    SchemaVisitor.prototype.visitEnumValue = function (_value, _details) { };\r\n    SchemaVisitor.prototype.visitInputObject = function (_object) { };\r\n    SchemaVisitor.prototype.visitInputFieldDefinition = function (_field, _details) { };\r\n    return SchemaVisitor;\r\n}());\n\n/**\r\n * Creates a keyed JS object from an array, given a function to produce the keys\r\n * for each value in the array.\r\n *\r\n * This provides a convenient lookup for the array items if the key function\r\n * produces unique results.\r\n *\r\n *     const phoneBook = [\r\n *       { name: 'Jon', num: '555-1234' },\r\n *       { name: 'Jenny', num: '867-5309' }\r\n *     ]\r\n *\r\n *     // { Jon: { name: 'Jon', num: '555-1234' },\r\n *     //   Jenny: { name: 'Jenny', num: '867-5309' } }\r\n *     const entriesByName = keyMap(\r\n *       phoneBook,\r\n *       entry => entry.name\r\n *     )\r\n *\r\n *     // { name: 'Jenny', num: '857-6309' }\r\n *     const jennyEntry = entriesByName['Jenny']\r\n *\r\n */\r\nfunction keyMap(list, keyFn) {\r\n    return list.reduce(function (map, item) {\r\n        map[keyFn(item)] = item;\r\n        return map;\r\n    }, Object.create(null));\r\n}\n\n// Similar to the graphql-js function of the same name, slightly simplified:\r\n// https://github.com/graphql/graphql-js/blob/master/src/utilities/valueFromASTUntyped.js\r\nfunction valueFromASTUntyped(valueNode) {\r\n    switch (valueNode.kind) {\r\n        case Kind.NULL:\r\n            return null;\r\n        case Kind.INT:\r\n            return parseInt(valueNode.value, 10);\r\n        case Kind.FLOAT:\r\n            return parseFloat(valueNode.value);\r\n        case Kind.STRING:\r\n        case Kind.ENUM:\r\n        case Kind.BOOLEAN:\r\n            return valueNode.value;\r\n        case Kind.LIST:\r\n            return valueNode.values.map(valueFromASTUntyped);\r\n        case Kind.OBJECT: {\r\n            return keyValMap(valueNode.fields, function (field) { return field.name.value; }, function (field) { return valueFromASTUntyped(field.value); });\r\n        }\r\n        /* istanbul ignore next */\r\n        default:\r\n            throw new Error('Unexpected value kind: ' + valueNode.kind);\r\n    }\r\n}\n\n// Generic function for visiting GraphQLSchema objects.\r\nfunction visitSchema(schema, \r\n// To accommodate as many different visitor patterns as possible, the\r\n// visitSchema function does not simply accept a single instance of the\r\n// SchemaVisitor class, but instead accepts a function that takes the\r\n// current VisitableSchemaType object and the name of a visitor method and\r\n// returns an array of SchemaVisitor instances that implement the visitor\r\n// method and have an interest in handling the given VisitableSchemaType\r\n// object. In the simplest case, this function can always return an array\r\n// containing a single visitor object, without even looking at the type or\r\n// methodName parameters. In other cases, this function might sometimes\r\n// return an empty array to indicate there are no visitors that should be\r\n// applied to the given VisitableSchemaType object. For an example of a\r\n// visitor pattern that benefits from this abstraction, see the\r\n// SchemaDirectiveVisitor class below.\r\nvisitorOrVisitorSelector) {\r\n    var visitorSelector = typeof visitorOrVisitorSelector === 'function'\r\n        ? visitorOrVisitorSelector\r\n        : function () { return visitorOrVisitorSelector; };\r\n    // Helper function that calls visitorSelector and applies the resulting\r\n    // visitors to the given type, with arguments [type, ...args].\r\n    function callMethod(methodName, type) {\r\n        var args = [];\r\n        for (var _i = 2; _i < arguments.length; _i++) {\r\n            args[_i - 2] = arguments[_i];\r\n        }\r\n        var visitors = visitorSelector(type, methodName);\r\n        visitors = Array.isArray(visitors) ? visitors : [visitors];\r\n        var finalType = type;\r\n        visitors.every(function (visitorOrVisitorDef) {\r\n            var newType;\r\n            if (visitorOrVisitorDef instanceof SchemaVisitor) {\r\n                newType = visitorOrVisitorDef[methodName].apply(visitorOrVisitorDef, __spreadArrays([finalType], args));\r\n            }\r\n            else if (isNamedType(finalType) &&\r\n                (methodName === 'visitScalar' ||\r\n                    methodName === 'visitEnum' ||\r\n                    methodName === 'visitObject' ||\r\n                    methodName === 'visitInputObject' ||\r\n                    methodName === 'visitUnion' ||\r\n                    methodName === 'visitInterface')) {\r\n                var specifiers = getTypeSpecifiers$1(finalType, schema);\r\n                var typeVisitor = getVisitor(visitorOrVisitorDef, specifiers);\r\n                newType =\r\n                    typeVisitor != null ? typeVisitor(finalType, schema) : undefined;\r\n            }\r\n            if (typeof newType === 'undefined') {\r\n                // Keep going without modifying type.\r\n                return true;\r\n            }\r\n            if (methodName === 'visitSchema' || isSchema(finalType)) {\r\n                throw new Error(\"Method \" + methodName + \" cannot replace schema with \" + newType);\r\n            }\r\n            if (newType === null) {\r\n                // Stop the loop and return null form callMethod, which will cause\r\n                // the type to be removed from the schema.\r\n                finalType = null;\r\n                return false;\r\n            }\r\n            // Update type to the new type returned by the visitor method, so that\r\n            // later directives will see the new type, and callMethod will return\r\n            // the final type.\r\n            finalType = newType;\r\n            return true;\r\n        });\r\n        // If there were no directives for this type object, or if all visitor\r\n        // methods returned nothing, type will be returned unmodified.\r\n        return finalType;\r\n    }\r\n    // Recursive helper function that calls any appropriate visitor methods for\r\n    // each object in the schema, then traverses the object's children (if any).\r\n    function visit(type) {\r\n        if (isSchema(type)) {\r\n            // Unlike the other types, the root GraphQLSchema object cannot be\r\n            // replaced by visitor methods, because that would make life very hard\r\n            // for SchemaVisitor subclasses that rely on the original schema object.\r\n            callMethod('visitSchema', type);\r\n            var typeMap_1 = type.getTypeMap();\r\n            Object.entries(typeMap_1).forEach(function (_a) {\r\n                var typeName = _a[0], namedType = _a[1];\r\n                if (!typeName.startsWith('__') && namedType != null) {\r\n                    // Call visit recursively to let it determine which concrete\r\n                    // subclass of GraphQLNamedType we found in the type map.\r\n                    // We do not use updateEachKey because we want to preserve\r\n                    // deleted types in the typeMap so that other types that reference\r\n                    // the deleted types can be healed.\r\n                    typeMap_1[typeName] = visit(namedType);\r\n                }\r\n            });\r\n            return type;\r\n        }\r\n        if (isObjectType(type)) {\r\n            // Note that callMethod('visitObject', type) may not actually call any\r\n            // methods, if there are no @directive annotations associated with this\r\n            // type, or if this SchemaDirectiveVisitor subclass does not override\r\n            // the visitObject method.\r\n            var newObject = callMethod('visitObject', type);\r\n            if (newObject != null) {\r\n                visitFields(newObject);\r\n            }\r\n            return newObject;\r\n        }\r\n        if (isInterfaceType(type)) {\r\n            var newInterface = callMethod('visitInterface', type);\r\n            if (newInterface != null) {\r\n                visitFields(newInterface);\r\n            }\r\n            return newInterface;\r\n        }\r\n        if (isInputObjectType(type)) {\r\n            var newInputObject_1 = callMethod('visitInputObject', type);\r\n            if (newInputObject_1 != null) {\r\n                var fieldMap = newInputObject_1.getFields();\r\n                updateEachKey(fieldMap, function (field) {\r\n                    return callMethod('visitInputFieldDefinition', field, {\r\n                        // Since we call a different method for input object fields, we\r\n                        // can't reuse the visitFields function here.\r\n                        objectType: newInputObject_1,\r\n                    });\r\n                });\r\n            }\r\n            return newInputObject_1;\r\n        }\r\n        if (isScalarType(type)) {\r\n            return callMethod('visitScalar', type);\r\n        }\r\n        if (isUnionType(type)) {\r\n            return callMethod('visitUnion', type);\r\n        }\r\n        if (isEnumType(type)) {\r\n            var newEnum_1 = callMethod('visitEnum', type);\r\n            if (newEnum_1 != null) {\r\n                updateEachKey(newEnum_1.getValues(), function (value) {\r\n                    return callMethod('visitEnumValue', value, {\r\n                        enumType: newEnum_1,\r\n                    });\r\n                });\r\n            }\r\n            return newEnum_1;\r\n        }\r\n        throw new Error(\"Unexpected schema type: \" + type);\r\n    }\r\n    function visitFields(type) {\r\n        updateEachKey(type.getFields(), function (field) {\r\n            // It would be nice if we could call visit(field) recursively here, but\r\n            // GraphQLField is merely a type, not a value that can be detected using\r\n            // an instanceof check, so we have to visit the fields in this lexical\r\n            // context, so that TypeScript can validate the call to\r\n            // visitFieldDefinition.\r\n            var newField = callMethod('visitFieldDefinition', field, {\r\n                // While any field visitor needs a reference to the field object, some\r\n                // field visitors may also need to know the enclosing (parent) type,\r\n                // perhaps to determine if the parent is a GraphQLObjectType or a\r\n                // GraphQLInterfaceType. To obtain a reference to the parent, a\r\n                // visitor method can have a second parameter, which will be an object\r\n                // with an .objectType property referring to the parent.\r\n                objectType: type,\r\n            });\r\n            if (newField.args != null) {\r\n                updateEachKey(newField.args, function (arg) {\r\n                    return callMethod('visitArgumentDefinition', arg, {\r\n                        // Like visitFieldDefinition, visitArgumentDefinition takes a\r\n                        // second parameter that provides additional context, namely the\r\n                        // parent .field and grandparent .objectType. Remember that the\r\n                        // current GraphQLSchema is always available via this.schema.\r\n                        field: newField,\r\n                        objectType: type,\r\n                    });\r\n                });\r\n            }\r\n            return newField;\r\n        });\r\n    }\r\n    visit(schema);\r\n    // Automatically update any references to named schema types replaced\r\n    // during the traversal, so implementors don't have to worry about that.\r\n    healSchema(schema);\r\n    // Return schema for convenience, even though schema parameter has all updated types.\r\n    return schema;\r\n}\r\nfunction getTypeSpecifiers$1(type, schema) {\r\n    var specifiers = [VisitSchemaKind.TYPE];\r\n    if (isObjectType(type)) {\r\n        specifiers.push(VisitSchemaKind.COMPOSITE_TYPE, VisitSchemaKind.OBJECT_TYPE);\r\n        var query = schema.getQueryType();\r\n        var mutation = schema.getMutationType();\r\n        var subscription = schema.getSubscriptionType();\r\n        if (type === query) {\r\n            specifiers.push(VisitSchemaKind.ROOT_OBJECT, VisitSchemaKind.QUERY);\r\n        }\r\n        else if (type === mutation) {\r\n            specifiers.push(VisitSchemaKind.ROOT_OBJECT, VisitSchemaKind.MUTATION);\r\n        }\r\n        else if (type === subscription) {\r\n            specifiers.push(VisitSchemaKind.ROOT_OBJECT, VisitSchemaKind.SUBSCRIPTION);\r\n        }\r\n    }\r\n    else if (isInputType(type)) {\r\n        specifiers.push(VisitSchemaKind.INPUT_OBJECT_TYPE);\r\n    }\r\n    else if (isInterfaceType(type)) {\r\n        specifiers.push(VisitSchemaKind.COMPOSITE_TYPE, VisitSchemaKind.ABSTRACT_TYPE, VisitSchemaKind.INTERFACE_TYPE);\r\n    }\r\n    else if (isUnionType(type)) {\r\n        specifiers.push(VisitSchemaKind.COMPOSITE_TYPE, VisitSchemaKind.ABSTRACT_TYPE, VisitSchemaKind.UNION_TYPE);\r\n    }\r\n    else if (isEnumType(type)) {\r\n        specifiers.push(VisitSchemaKind.ENUM_TYPE);\r\n    }\r\n    else if (isScalarType(type)) {\r\n        specifiers.push(VisitSchemaKind.SCALAR_TYPE);\r\n    }\r\n    return specifiers;\r\n}\r\nfunction getVisitor(visitorDef, specifiers) {\r\n    var typeVisitor;\r\n    var stack = __spreadArrays(specifiers);\r\n    while (!typeVisitor && stack.length > 0) {\r\n        var next = stack.pop();\r\n        typeVisitor = visitorDef[next];\r\n    }\r\n    return typeVisitor != null ? typeVisitor : null;\r\n}\n\nvar MAX_ARRAY_LENGTH = 10;\r\nvar MAX_RECURSIVE_DEPTH = 2;\r\n/**\r\n * Used to print values in error messages.\r\n */\r\nfunction inspect(value) {\r\n    return formatValue(value, []);\r\n}\r\nfunction formatValue(value, seenValues) {\r\n    switch (typeof value) {\r\n        case 'string':\r\n            return JSON.stringify(value);\r\n        case 'function':\r\n            return value.name\r\n                ? \"[function \" + value.name + \"]\"\r\n                : '[function]';\r\n        case 'object':\r\n            if (value === null) {\r\n                return 'null';\r\n            }\r\n            return formatObjectValue(value, seenValues);\r\n        default:\r\n            return String(value);\r\n    }\r\n}\r\nfunction formatObjectValue(value, previouslySeenValues) {\r\n    if (previouslySeenValues.indexOf(value) !== -1) {\r\n        return '[Circular]';\r\n    }\r\n    var seenValues = __spreadArrays(previouslySeenValues, [value]);\r\n    var customInspectFn = getCustomFn(value);\r\n    if (customInspectFn !== undefined) {\r\n        var customValue = customInspectFn.call(value);\r\n        // check for infinite recursion\r\n        if (customValue !== value) {\r\n            return typeof customValue === 'string'\r\n                ? customValue\r\n                : formatValue(customValue, seenValues);\r\n        }\r\n    }\r\n    else if (Array.isArray(value)) {\r\n        return formatArray(value, seenValues);\r\n    }\r\n    return formatObject(value, seenValues);\r\n}\r\nfunction formatObject(object, seenValues) {\r\n    var keys = Object.keys(object);\r\n    if (keys.length === 0) {\r\n        return '{}';\r\n    }\r\n    if (seenValues.length > MAX_RECURSIVE_DEPTH) {\r\n        return '[' + getObjectTag(object) + ']';\r\n    }\r\n    var properties = keys.map(function (key) {\r\n        var value = formatValue(object[key], seenValues);\r\n        return key + ': ' + value;\r\n    });\r\n    return '{ ' + properties.join(', ') + ' }';\r\n}\r\nfunction formatArray(array, seenValues) {\r\n    if (array.length === 0) {\r\n        return '[]';\r\n    }\r\n    if (seenValues.length > MAX_RECURSIVE_DEPTH) {\r\n        return '[Array]';\r\n    }\r\n    var len = Math.min(MAX_ARRAY_LENGTH, array.length);\r\n    var remaining = array.length - len;\r\n    var items = [];\r\n    for (var i = 0; i < len; ++i) {\r\n        items.push(formatValue(array[i], seenValues));\r\n    }\r\n    if (remaining === 1) {\r\n        items.push('... 1 more item');\r\n    }\r\n    else if (remaining > 1) {\r\n        items.push(\"... \" + remaining.toString(10) + \" more items\");\r\n    }\r\n    return '[' + items.join(', ') + ']';\r\n}\r\nfunction getCustomFn(obj) {\r\n    if (typeof obj.inspect === 'function') {\r\n        return obj.inspect;\r\n    }\r\n}\r\nfunction getObjectTag(obj) {\r\n    var tag = Object.prototype.toString\r\n        .call(obj)\r\n        .replace(/^\\[object /, '')\r\n        .replace(/]$/, '');\r\n    if (tag === 'Object' && typeof obj.constructor === 'function') {\r\n        var name_1 = obj.constructor.name;\r\n        if (typeof name_1 === 'string' && name_1 !== '') {\r\n            return name_1;\r\n        }\r\n    }\r\n    return tag;\r\n}\n\n/**\r\n * Prepares an object map of argument values given a list of argument\r\n * definitions and list of argument AST nodes.\r\n *\r\n * Note: The returned value is a plain Object with a prototype, since it is\r\n * exposed to user code. Care should be taken to not pull values from the\r\n * Object prototype.\r\n */\r\nfunction getArgumentValues(def, node, variableValues) {\r\n    if (variableValues === void 0) { variableValues = {}; }\r\n    var _a;\r\n    var variableMap = toObjMap(variableValues);\r\n    var coercedValues = {};\r\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\r\n    var argumentNodes = (_a = node.arguments) !== null && _a !== void 0 ? _a : [];\r\n    var argNodeMap = keyMap(argumentNodes, function (arg) { return arg.name.value; });\r\n    for (var _i = 0, _b = def.args; _i < _b.length; _i++) {\r\n        var argDef = _b[_i];\r\n        var name_1 = argDef.name;\r\n        var argType = argDef.type;\r\n        var argumentNode = argNodeMap[name_1];\r\n        if (!argumentNode) {\r\n            if (argDef.defaultValue !== undefined) {\r\n                coercedValues[name_1] = argDef.defaultValue;\r\n            }\r\n            else if (isNonNullType(argType)) {\r\n                throw new GraphQLError(\"Argument \\\"\" + name_1 + \"\\\" of required type \\\"\" + inspect(argType) + \"\\\" \" +\r\n                    'was not provided.', node);\r\n            }\r\n            continue;\r\n        }\r\n        var valueNode = argumentNode.value;\r\n        var isNull = valueNode.kind === Kind.NULL;\r\n        if (valueNode.kind === Kind.VARIABLE) {\r\n            var variableName = valueNode.name.value;\r\n            if (variableValues == null || !(variableName in variableMap)) {\r\n                if (argDef.defaultValue !== undefined) {\r\n                    coercedValues[name_1] = argDef.defaultValue;\r\n                }\r\n                else if (isNonNullType(argType)) {\r\n                    throw new GraphQLError(\"Argument \\\"\" + name_1 + \"\\\" of required type \\\"\" + inspect(argType) + \"\\\" \" +\r\n                        (\"was provided the variable \\\"$\" + variableName + \"\\\" which was not provided a runtime value.\"), valueNode);\r\n                }\r\n                continue;\r\n            }\r\n            isNull = variableValues[variableName] == null;\r\n        }\r\n        if (isNull && isNonNullType(argType)) {\r\n            throw new GraphQLError(\"Argument \\\"\" + name_1 + \"\\\" of non-null type \\\"\" + inspect(argType) + \"\\\" \" +\r\n                'must not be null.', valueNode);\r\n        }\r\n        var coercedValue = valueFromAST(valueNode, argType, variableValues);\r\n        if (coercedValue === undefined) {\r\n            // Note: ValuesOfCorrectTypeRule validation should catch this before\r\n            // execution. This is a runtime check to ensure execution does not\r\n            // continue with an invalid argument value.\r\n            throw new GraphQLError(\"Argument \\\"\" + name_1 + \"\\\" has invalid value \" + print(valueNode) + \".\", valueNode);\r\n        }\r\n        coercedValues[name_1] = coercedValue;\r\n    }\r\n    return coercedValues;\r\n}\n\n// This class represents a reusable implementation of a @directive that may\r\n// appear in a GraphQL schema written in Schema Definition Language.\r\n//\r\n// By overriding one or more visit{Object,Union,...} methods, a subclass\r\n// registers interest in certain schema types, such as GraphQLObjectType,\r\n// GraphQLUnionType, etc. When SchemaDirectiveVisitor.visitSchemaDirectives is\r\n// called with a GraphQLSchema object and a map of visitor subclasses, the\r\n// overidden methods of those subclasses allow the visitors to obtain\r\n// references to any type objects that have @directives attached to them,\r\n// enabling visitors to inspect or modify the schema as appropriate.\r\n//\r\n// For example, if a directive called @rest(url: \"...\") appears after a field\r\n// definition, a SchemaDirectiveVisitor subclass could provide meaning to that\r\n// directive by overriding the visitFieldDefinition method (which receives a\r\n// GraphQLField parameter), and then the body of that visitor method could\r\n// manipulate the field's resolver function to fetch data from a REST endpoint\r\n// described by the url argument passed to the @rest directive:\r\n//\r\n//   const typeDefs = `\r\n//   type Query {\r\n//     people: [Person] @rest(url: \"/api/v1/people\")\r\n//   }`;\r\n//\r\n//   const schema = makeExecutableSchema({ typeDefs });\r\n//\r\n//   SchemaDirectiveVisitor.visitSchemaDirectives(schema, {\r\n//     rest: class extends SchemaDirectiveVisitor {\r\n//       public visitFieldDefinition(field: GraphQLField<any, any>) {\r\n//         const { url } = this.args;\r\n//         field.resolve = () => fetch(url);\r\n//       }\r\n//     }\r\n//   });\r\n//\r\n// The subclass in this example is defined as an anonymous class expression,\r\n// for brevity. A truly reusable SchemaDirectiveVisitor would most likely be\r\n// defined in a library using a named class declaration, and then exported for\r\n// consumption by other modules and packages.\r\n//\r\n// See below for a complete list of overridable visitor methods, their\r\n// parameter types, and more details about the properties exposed by instances\r\n// of the SchemaDirectiveVisitor class.\r\nvar SchemaDirectiveVisitor = /** @class */ (function (_super) {\r\n    __extends(SchemaDirectiveVisitor, _super);\r\n    // Mark the constructor protected to enforce passing SchemaDirectiveVisitor\r\n    // subclasses (not instances) to visitSchemaDirectives.\r\n    function SchemaDirectiveVisitor(config) {\r\n        var _this = _super.call(this) || this;\r\n        _this.name = config.name;\r\n        _this.args = config.args;\r\n        _this.visitedType = config.visitedType;\r\n        _this.schema = config.schema;\r\n        _this.context = config.context;\r\n        return _this;\r\n    }\r\n    // Override this method to return a custom GraphQLDirective (or modify one\r\n    // already present in the schema) to enforce argument types, provide default\r\n    // argument values, or specify schema locations where this @directive may\r\n    // appear. By default, any declaration found in the schema will be returned.\r\n    SchemaDirectiveVisitor.getDirectiveDeclaration = function (directiveName, schema) {\r\n        return schema.getDirective(directiveName);\r\n    };\r\n    // Call SchemaDirectiveVisitor.visitSchemaDirectives to visit every\r\n    // @directive in the schema and create an appropriate SchemaDirectiveVisitor\r\n    // instance to visit the object decorated by the @directive.\r\n    SchemaDirectiveVisitor.visitSchemaDirectives = function (schema, \r\n    // The keys of this object correspond to directive names as they appear\r\n    // in the schema, and the values should be subclasses (not instances!)\r\n    // of the SchemaDirectiveVisitor class. This distinction is important\r\n    // because a new SchemaDirectiveVisitor instance will be created each\r\n    // time a matching directive is found in the schema AST, with arguments\r\n    // and other metadata specific to that occurrence. To help prevent the\r\n    // mistake of passing instances, the SchemaDirectiveVisitor constructor\r\n    // method is marked as protected.\r\n    directiveVisitors, \r\n    // Optional context object that will be available to all visitor instances\r\n    // via this.context. Defaults to an empty null-prototype object.\r\n    context) {\r\n        if (context === void 0) { context = Object.create(null); }\r\n        // If the schema declares any directives for public consumption, record\r\n        // them here so that we can properly coerce arguments when/if we encounter\r\n        // an occurrence of the directive while walking the schema below.\r\n        var declaredDirectives = this.getDeclaredDirectives(schema, directiveVisitors);\r\n        // Map from directive names to lists of SchemaDirectiveVisitor instances\r\n        // created while visiting the schema.\r\n        var createdVisitors = keyValMap(Object.keys(directiveVisitors), function (item) { return item; }, function () { return []; });\r\n        var directiveVisitorMap = toObjMap(directiveVisitors);\r\n        function visitorSelector(type, methodName) {\r\n            var directiveNodes = type.astNode != null ? type.astNode.directives : [];\r\n            var extensionASTNodes = type.extensionASTNodes;\r\n            if (extensionASTNodes != null) {\r\n                extensionASTNodes.forEach(function (extensionASTNode) {\r\n                    directiveNodes = directiveNodes.concat(extensionASTNode.directives);\r\n                });\r\n            }\r\n            var visitors = [];\r\n            directiveNodes.forEach(function (directiveNode) {\r\n                var directiveName = directiveNode.name.value;\r\n                if (!(directiveName in directiveVisitorMap)) {\r\n                    return;\r\n                }\r\n                var visitorClass = directiveVisitorMap[directiveName];\r\n                // Avoid creating visitor objects if visitorClass does not override\r\n                // the visitor method named by methodName.\r\n                if (!visitorClass.implementsVisitorMethod(methodName)) {\r\n                    return;\r\n                }\r\n                var decl = declaredDirectives[directiveName];\r\n                var args;\r\n                if (decl != null) {\r\n                    // If this directive was explicitly declared, use the declared\r\n                    // argument types (and any default values) to check, coerce, and/or\r\n                    // supply default values for the given arguments.\r\n                    args = getArgumentValues(decl, directiveNode);\r\n                }\r\n                else {\r\n                    // If this directive was not explicitly declared, just convert the\r\n                    // argument nodes to their corresponding JavaScript values.\r\n                    args = Object.create(null);\r\n                    if (directiveNode.arguments != null) {\r\n                        directiveNode.arguments.forEach(function (arg) {\r\n                            args[arg.name.value] = valueFromASTUntyped(arg.value);\r\n                        });\r\n                    }\r\n                }\r\n                // As foretold in comments near the top of the visitSchemaDirectives\r\n                // method, this is where instances of the SchemaDirectiveVisitor class\r\n                // get created and assigned names. While subclasses could override the\r\n                // constructor method, the constructor is marked as protected, so\r\n                // these are the only arguments that will ever be passed.\r\n                visitors.push(new visitorClass({\r\n                    name: directiveName,\r\n                    args: args,\r\n                    visitedType: type,\r\n                    schema: schema,\r\n                    context: context,\r\n                }));\r\n            });\r\n            if (visitors.length > 0) {\r\n                visitors.forEach(function (visitor) {\r\n                    createdVisitors[visitor.name].push(visitor);\r\n                });\r\n            }\r\n            return visitors;\r\n        }\r\n        visitSchema(schema, visitorSelector);\r\n        return createdVisitors;\r\n    };\r\n    SchemaDirectiveVisitor.getDeclaredDirectives = function (schema, directiveVisitors) {\r\n        var directiveVisitorMap = toObjMap(directiveVisitors);\r\n        var declaredDirectives = keyMap(schema.getDirectives(), function (d) { return d.name; });\r\n        // If the visitor subclass overrides getDirectiveDeclaration, and it\r\n        // returns a non-null GraphQLDirective, use that instead of any directive\r\n        // declared in the schema itself. Reasoning: if a SchemaDirectiveVisitor\r\n        // goes to the trouble of implementing getDirectiveDeclaration, it should\r\n        // be able to rely on that implementation.\r\n        Object.entries(directiveVisitors).forEach(function (_a) {\r\n            var directiveName = _a[0], visitorClass = _a[1];\r\n            var decl = visitorClass.getDirectiveDeclaration(directiveName, schema);\r\n            if (decl != null) {\r\n                declaredDirectives[directiveName] = decl;\r\n            }\r\n        });\r\n        Object.entries(declaredDirectives).forEach(function (_a) {\r\n            var name = _a[0], decl = _a[1];\r\n            if (!(name in directiveVisitorMap)) {\r\n                // SchemaDirectiveVisitors.visitSchemaDirectives might be called\r\n                // multiple times with partial directiveVisitors maps, so it's not\r\n                // necessarily an error for directiveVisitors to be missing an\r\n                // implementation of a directive that was declared in the schema.\r\n                return;\r\n            }\r\n            var visitorClass = directiveVisitorMap[name];\r\n            decl.locations.forEach(function (loc) {\r\n                var visitorMethodName = directiveLocationToVisitorMethodName(loc);\r\n                if (SchemaVisitor.implementsVisitorMethod(visitorMethodName) &&\r\n                    !visitorClass.implementsVisitorMethod(visitorMethodName)) {\r\n                    // While visitor subclasses may implement extra visitor methods,\r\n                    // it's definitely a mistake if the GraphQLDirective declares itself\r\n                    // applicable to certain schema locations, and the visitor subclass\r\n                    // does not implement all the corresponding methods.\r\n                    throw new Error(\"SchemaDirectiveVisitor for @\" + name + \" must implement \" + visitorMethodName + \" method\");\r\n                }\r\n            });\r\n        });\r\n        return declaredDirectives;\r\n    };\r\n    return SchemaDirectiveVisitor;\r\n}(SchemaVisitor));\r\n// Convert a string like \"FIELD_DEFINITION\" to \"visitFieldDefinition\".\r\nfunction directiveLocationToVisitorMethodName(loc) {\r\n    return ('visit' +\r\n        loc.replace(/([^_]*)_?/g, function (_wholeMatch, part) {\r\n            return part.charAt(0).toUpperCase() + part.slice(1).toLowerCase();\r\n        }));\r\n}\n\nfunction forEachField(schema, fn) {\r\n    var typeMap = schema.getTypeMap();\r\n    Object.keys(typeMap).forEach(function (typeName) {\r\n        var type = typeMap[typeName];\r\n        // TODO: maybe have an option to include these?\r\n        if (!getNamedType(type).name.startsWith('__') && isObjectType(type)) {\r\n            var fields_1 = type.getFields();\r\n            Object.keys(fields_1).forEach(function (fieldName) {\r\n                var field = fields_1[fieldName];\r\n                fn(field, typeName, fieldName);\r\n            });\r\n        }\r\n    });\r\n}\n\nfunction forEachDefaultValue(schema, fn) {\r\n    var typeMap = schema.getTypeMap();\r\n    Object.keys(typeMap).forEach(function (typeName) {\r\n        var type = typeMap[typeName];\r\n        if (!getNamedType(type).name.startsWith('__')) {\r\n            if (isObjectType(type)) {\r\n                var fields_1 = type.getFields();\r\n                Object.keys(fields_1).forEach(function (fieldName) {\r\n                    var field = fields_1[fieldName];\r\n                    field.args.forEach(function (arg) {\r\n                        arg.defaultValue = fn(arg.type, arg.defaultValue);\r\n                    });\r\n                });\r\n            }\r\n            else if (isInputObjectType(type)) {\r\n                var fields_2 = type.getFields();\r\n                Object.keys(fields_2).forEach(function (fieldName) {\r\n                    var field = fields_2[fieldName];\r\n                    field.defaultValue = fn(field.type, field.defaultValue);\r\n                });\r\n            }\r\n        }\r\n    });\r\n}\n\nfunction applySchemaTransforms(originalSchema, transforms) {\r\n    return transforms.reduce(function (schema, transform) {\r\n        return transform.transformSchema != null\r\n            ? transform.transformSchema(cloneSchema(schema))\r\n            : schema;\r\n    }, originalSchema);\r\n}\r\nfunction applyRequestTransforms(originalRequest, transforms) {\r\n    return transforms.reduce(function (request, transform) {\r\n        return transform.transformRequest != null\r\n            ? transform.transformRequest(request)\r\n            : request;\r\n    }, originalRequest);\r\n}\r\nfunction applyResultTransforms(originalResult, transforms) {\r\n    return transforms.reduceRight(function (result, transform) {\r\n        return transform.transformResult != null\r\n            ? transform.transformResult(result)\r\n            : result;\r\n    }, originalResult);\r\n}\n\nfunction linkToFetcher(link) {\r\n    return function (fetcherOperation) {\r\n        return toPromise(execute(link, fetcherOperation));\r\n    };\r\n}\n\nfunction observableToAsyncIterable(observable) {\r\n    var _a;\r\n    var pullQueue = [];\r\n    var pushQueue = [];\r\n    var listening = true;\r\n    var pushValue = function (value) {\r\n        if (pullQueue.length !== 0) {\r\n            pullQueue.shift()({ value: value, done: false });\r\n        }\r\n        else {\r\n            pushQueue.push({ value: value });\r\n        }\r\n    };\r\n    var pushError = function (error) {\r\n        if (pullQueue.length !== 0) {\r\n            pullQueue.shift()({ value: { errors: [error] }, done: false });\r\n        }\r\n        else {\r\n            pushQueue.push({ value: { errors: [error] } });\r\n        }\r\n    };\r\n    var pullValue = function () {\r\n        return new Promise(function (resolve) {\r\n            if (pushQueue.length !== 0) {\r\n                var element = pushQueue.shift();\r\n                // either {value: {errors: [...]}} or {value: ...}\r\n                resolve(__assign(__assign({}, element), { done: false }));\r\n            }\r\n            else {\r\n                pullQueue.push(resolve);\r\n            }\r\n        });\r\n    };\r\n    var subscription = observable.subscribe({\r\n        next: function (value) {\r\n            pushValue(value);\r\n        },\r\n        error: function (err) {\r\n            pushError(err);\r\n        },\r\n    });\r\n    var emptyQueue = function () {\r\n        if (listening) {\r\n            listening = false;\r\n            subscription.unsubscribe();\r\n            pullQueue.forEach(function (resolve) { return resolve({ value: undefined, done: true }); });\r\n            pullQueue.length = 0;\r\n            pushQueue.length = 0;\r\n        }\r\n    };\r\n    return _a = {\r\n            next: function () {\r\n                return listening ? pullValue() : this.return();\r\n            },\r\n            return: function () {\r\n                emptyQueue();\r\n                return Promise.resolve({ value: undefined, done: true });\r\n            },\r\n            throw: function (error) {\r\n                emptyQueue();\r\n                return Promise.reject(error);\r\n            }\r\n        },\r\n        _a[$$asyncIterator] = function () {\r\n            return this;\r\n        },\r\n        _a;\r\n}\n\n/**\r\n * Given an AsyncIterable and a callback function, return an AsyncIterator\r\n * which produces values mapped via calling the callback function.\r\n */\r\nfunction mapAsyncIterator(iterator, callback, rejectCallback) {\r\n    var _a;\r\n    var $return;\r\n    var abruptClose;\r\n    if (typeof iterator.return === 'function') {\r\n        $return = iterator.return;\r\n        abruptClose = function (error) {\r\n            var rethrow = function () { return Promise.reject(error); };\r\n            return $return.call(iterator).then(rethrow, rethrow);\r\n        };\r\n    }\r\n    function mapResult(result) {\r\n        return result.done\r\n            ? result\r\n            : asyncMapValue(result.value, callback).then(iteratorResult, abruptClose);\r\n    }\r\n    var mapReject;\r\n    if (rejectCallback) {\r\n        // Capture rejectCallback to ensure it cannot be null.\r\n        var reject_1 = rejectCallback;\r\n        mapReject = function (error) {\r\n            return asyncMapValue(error, reject_1).then(iteratorResult, abruptClose);\r\n        };\r\n    }\r\n    return _a = {\r\n            next: function () {\r\n                return iterator.next().then(mapResult, mapReject);\r\n            },\r\n            return: function () {\r\n                return $return\r\n                    ? $return.call(iterator).then(mapResult, mapReject)\r\n                    : Promise.resolve({ value: undefined, done: true });\r\n            },\r\n            throw: function (error) {\r\n                if (typeof iterator.throw === 'function') {\r\n                    return iterator.throw(error).then(mapResult, mapReject);\r\n                }\r\n                return Promise.reject(error).catch(abruptClose);\r\n            }\r\n        },\r\n        _a[$$asyncIterator] = function () {\r\n            return this;\r\n        },\r\n        _a;\r\n}\r\nfunction asyncMapValue(value, callback) {\r\n    return new Promise(function (resolve) { return resolve(callback(value)); });\r\n}\r\nfunction iteratorResult(value) {\r\n    return { value: value, done: false };\r\n}\n\nfunction getDelegatingOperation(parentType, schema) {\r\n    if (parentType === schema.getMutationType()) {\r\n        return 'mutation';\r\n    }\r\n    else if (parentType === schema.getSubscriptionType()) {\r\n        return 'subscription';\r\n    }\r\n    return 'query';\r\n}\r\nfunction createRequestFromInfo(_a) {\r\n    var info = _a.info, _b = _a.operation, operation = _b === void 0 ? getDelegatingOperation(info.parentType, info.schema) : _b, _c = _a.fieldName, fieldName = _c === void 0 ? info.fieldName : _c, selectionSet = _a.selectionSet, fieldNodes = _a.fieldNodes;\r\n    return createRequest({\r\n        sourceSchema: info.schema,\r\n        sourceParentType: info.parentType,\r\n        sourceFieldName: info.fieldName,\r\n        fragments: info.fragments,\r\n        variableDefinitions: info.operation.variableDefinitions,\r\n        variableValues: info.variableValues,\r\n        targetOperation: operation,\r\n        targetFieldName: fieldName,\r\n        selectionSet: selectionSet,\r\n        fieldNodes: selectionSet != null\r\n            ? undefined\r\n            : fieldNodes != null\r\n                ? fieldNodes\r\n                : info.fieldNodes,\r\n    });\r\n}\r\nfunction createRequest(_a) {\r\n    var sourceSchema = _a.sourceSchema, sourceParentType = _a.sourceParentType, sourceFieldName = _a.sourceFieldName, fragments = _a.fragments, variableDefinitions = _a.variableDefinitions, variableValues = _a.variableValues, targetOperation = _a.targetOperation, targetFieldName = _a.targetFieldName, selectionSet = _a.selectionSet, fieldNodes = _a.fieldNodes;\r\n    var argumentNodes;\r\n    var newSelectionSet = selectionSet;\r\n    if (!selectionSet && fieldNodes != null) {\r\n        var selections = fieldNodes.reduce(function (acc, fieldNode) {\r\n            return fieldNode.selectionSet != null\r\n                ? acc.concat(fieldNode.selectionSet.selections)\r\n                : acc;\r\n        }, []);\r\n        newSelectionSet = selections.length\r\n            ? {\r\n                kind: Kind.SELECTION_SET,\r\n                selections: selections,\r\n            }\r\n            : undefined;\r\n        argumentNodes = fieldNodes[0].arguments;\r\n    }\r\n    else {\r\n        argumentNodes = [];\r\n    }\r\n    var newVariables = Object.create(null);\r\n    var variableDefinitionMap = Object.create(null);\r\n    variableDefinitions.forEach(function (def) {\r\n        var varName = def.variable.name.value;\r\n        variableDefinitionMap[varName] = def;\r\n        var varType = typeFromAST$1(sourceSchema, def.type);\r\n        newVariables[varName] = serializeInputValue(varType, variableValues[varName]);\r\n    });\r\n    var argumentNodeMap = keyMap(argumentNodes, function (arg) { return arg.name.value; });\r\n    updateArgumentsWithDefaults(sourceParentType, sourceFieldName, argumentNodeMap, variableDefinitionMap, newVariables);\r\n    var rootfieldNode = {\r\n        kind: Kind.FIELD,\r\n        alias: null,\r\n        arguments: Object.keys(argumentNodeMap).map(function (argName) { return argumentNodeMap[argName]; }),\r\n        selectionSet: newSelectionSet,\r\n        name: {\r\n            kind: Kind.NAME,\r\n            value: targetFieldName || fieldNodes[0].name.value,\r\n        },\r\n    };\r\n    var operationDefinition = {\r\n        kind: Kind.OPERATION_DEFINITION,\r\n        operation: targetOperation,\r\n        variableDefinitions: Object.keys(variableDefinitionMap).map(function (varName) { return variableDefinitionMap[varName]; }),\r\n        selectionSet: {\r\n            kind: Kind.SELECTION_SET,\r\n            selections: [rootfieldNode],\r\n        },\r\n    };\r\n    var fragmentDefinitions = Object.keys(fragments).map(function (fragmentName) { return fragments[fragmentName]; });\r\n    var document = {\r\n        kind: Kind.DOCUMENT,\r\n        definitions: __spreadArrays([operationDefinition], fragmentDefinitions),\r\n    };\r\n    return {\r\n        document: document,\r\n        variables: newVariables,\r\n    };\r\n}\r\nfunction updateArgumentsWithDefaults(sourceParentType, sourceFieldName, argumentNodeMap, variableDefinitionMap, variableValues) {\r\n    var sourceField = sourceParentType.getFields()[sourceFieldName];\r\n    sourceField.args.forEach(function (argument) {\r\n        var argName = argument.name;\r\n        var sourceArgType = argument.type;\r\n        if (argumentNodeMap[argName] === undefined) {\r\n            var defaultValue = argument.defaultValue;\r\n            if (defaultValue !== undefined) {\r\n                updateArgument(argName, sourceArgType, argumentNodeMap, variableDefinitionMap, variableValues, serializeInputValue(sourceArgType, defaultValue));\r\n            }\r\n        }\r\n    });\r\n}\n\nfunction delegateToSchema(options) {\r\n    if (isSchema(options)) {\r\n        throw new Error('Passing positional arguments to delegateToSchema is deprecated. ' +\r\n            'Please pass named parameters instead.');\r\n    }\r\n    var info = options.info, _a = options.operation, operation = _a === void 0 ? getDelegatingOperation(info.parentType, info.schema) : _a, _b = options.fieldName, fieldName = _b === void 0 ? info.fieldName : _b, _c = options.returnType, returnType = _c === void 0 ? info.returnType : _c, selectionSet = options.selectionSet, fieldNodes = options.fieldNodes;\r\n    var request = createRequestFromInfo({\r\n        info: info,\r\n        operation: operation,\r\n        fieldName: fieldName,\r\n        selectionSet: selectionSet,\r\n        fieldNodes: fieldNodes,\r\n    });\r\n    return delegateRequest(__assign(__assign({}, options), { request: request,\r\n        operation: operation,\r\n        fieldName: fieldName,\r\n        returnType: returnType }));\r\n}\r\nfunction buildDelegationTransforms(subschemaOrSubschemaConfig, info, context, targetSchema, fieldName, args, returnType, transforms, skipTypeMerging) {\r\n    var delegationTransforms = [\r\n        new CheckResultAndHandleErrors(info, fieldName, subschemaOrSubschemaConfig, context, returnType, skipTypeMerging),\r\n    ];\r\n    if (info.mergeInfo != null) {\r\n        delegationTransforms.push(new AddReplacementSelectionSets(info.schema, info.mergeInfo.replacementSelectionSets), new AddMergedTypeFragments(info.schema, info.mergeInfo.mergedTypes));\r\n    }\r\n    delegationTransforms = delegationTransforms.concat(transforms);\r\n    delegationTransforms.push(new ExpandAbstractTypes(info.schema, targetSchema));\r\n    if (info.mergeInfo != null) {\r\n        delegationTransforms.push(new AddReplacementFragments(targetSchema, info.mergeInfo.replacementFragments));\r\n    }\r\n    if (args != null) {\r\n        delegationTransforms.push(new AddArgumentsAsVariables(targetSchema, args));\r\n    }\r\n    delegationTransforms.push(new FilterToSchema(targetSchema), new AddTypenameToAbstract(targetSchema));\r\n    return delegationTransforms;\r\n}\r\nfunction delegateRequest(_a) {\r\n    var request = _a.request, subschemaOrSubschemaConfig = _a.schema, rootValue = _a.rootValue, info = _a.info, _b = _a.operation, operation = _b === void 0 ? getDelegatingOperation(info.parentType, info.schema) : _b, _c = _a.fieldName, fieldName = _c === void 0 ? info.fieldName : _c, args = _a.args, _d = _a.returnType, returnType = _d === void 0 ? info.returnType : _d, context = _a.context, _e = _a.transforms, transforms = _e === void 0 ? [] : _e, skipValidation = _a.skipValidation, skipTypeMerging = _a.skipTypeMerging;\r\n    var targetSchema;\r\n    var targetRootValue;\r\n    var requestTransforms = transforms.slice();\r\n    var subschemaConfig;\r\n    if (isSubschemaConfig(subschemaOrSubschemaConfig)) {\r\n        subschemaConfig = subschemaOrSubschemaConfig;\r\n        targetSchema = subschemaConfig.schema;\r\n        targetRootValue =\r\n            rootValue != null\r\n                ? rootValue\r\n                : subschemaConfig.rootValue != null\r\n                    ? subschemaConfig.rootValue\r\n                    : info.rootValue;\r\n        if (subschemaConfig.transforms != null) {\r\n            requestTransforms = requestTransforms.concat(subschemaConfig.transforms);\r\n        }\r\n    }\r\n    else {\r\n        targetSchema = subschemaOrSubschemaConfig;\r\n        targetRootValue = rootValue != null ? rootValue : info.rootValue;\r\n    }\r\n    var delegationTransforms = buildDelegationTransforms(subschemaOrSubschemaConfig, info, context, targetSchema, fieldName, args, returnType, requestTransforms.reverse(), skipTypeMerging);\r\n    var processedRequest = applyRequestTransforms(request, delegationTransforms);\r\n    if (!skipValidation) {\r\n        var errors = validate(targetSchema, processedRequest.document);\r\n        if (errors.length > 0) {\r\n            var combinedError = combineErrors(errors);\r\n            throw combinedError;\r\n        }\r\n    }\r\n    if (operation === 'query' || operation === 'mutation') {\r\n        var executor = createExecutor(targetSchema, targetRootValue, context, subschemaConfig);\r\n        var executionResult = executor({\r\n            document: processedRequest.document,\r\n            context: context,\r\n            variables: processedRequest.variables,\r\n        });\r\n        if (executionResult instanceof Promise) {\r\n            return executionResult.then(function (originalResult) {\r\n                return applyResultTransforms(originalResult, delegationTransforms);\r\n            });\r\n        }\r\n        return applyResultTransforms(executionResult, delegationTransforms);\r\n    }\r\n    var subscriber = createSubscriber(targetSchema, targetRootValue, context, subschemaConfig);\r\n    return subscriber({\r\n        document: processedRequest.document,\r\n        context: context,\r\n        variables: processedRequest.variables,\r\n    }).then(function (subscriptionResult) {\r\n        if (isAsyncIterable(subscriptionResult)) {\r\n            // \"subscribe\" to the subscription result and map the result through the transforms\r\n            return mapAsyncIterator(subscriptionResult, function (result) {\r\n                var _a;\r\n                var transformedResult = applyResultTransforms(result, delegationTransforms);\r\n                // wrap with fieldName to return for an additional round of resolutioon\r\n                // with payload as rootValue\r\n                return _a = {},\r\n                    _a[info.fieldName] = transformedResult,\r\n                    _a;\r\n            });\r\n        }\r\n        return applyResultTransforms(subscriptionResult, delegationTransforms);\r\n    });\r\n}\r\nfunction createExecutor(schema, rootValue, context, subschemaConfig) {\r\n    var fetcher;\r\n    var targetRootValue = rootValue;\r\n    if (subschemaConfig != null) {\r\n        if (subschemaConfig.dispatcher != null) {\r\n            var dynamicLinkOrFetcher = subschemaConfig.dispatcher(context);\r\n            fetcher =\r\n                typeof dynamicLinkOrFetcher === 'function'\r\n                    ? dynamicLinkOrFetcher\r\n                    : linkToFetcher(dynamicLinkOrFetcher);\r\n        }\r\n        else if (subschemaConfig.link != null) {\r\n            fetcher = linkToFetcher(subschemaConfig.link);\r\n        }\r\n        else if (subschemaConfig.fetcher != null) {\r\n            fetcher = subschemaConfig.fetcher;\r\n        }\r\n        if (!fetcher && !rootValue && subschemaConfig.rootValue != null) {\r\n            targetRootValue = subschemaConfig.rootValue;\r\n        }\r\n    }\r\n    if (fetcher != null) {\r\n        return function (_a) {\r\n            var document = _a.document, graphqlContext = _a.context, variables = _a.variables;\r\n            return fetcher({\r\n                query: document,\r\n                variables: variables,\r\n                context: { graphqlContext: graphqlContext },\r\n            });\r\n        };\r\n    }\r\n    return function (_a) {\r\n        var document = _a.document, graphqlContext = _a.context, variables = _a.variables;\r\n        return execute$1({\r\n            schema: schema,\r\n            document: document,\r\n            rootValue: targetRootValue,\r\n            contextValue: graphqlContext,\r\n            variableValues: variables,\r\n        });\r\n    };\r\n}\r\nfunction createSubscriber(schema, rootValue, context, subschemaConfig) {\r\n    var link;\r\n    var targetRootValue = rootValue;\r\n    if (subschemaConfig != null) {\r\n        if (subschemaConfig.dispatcher != null) {\r\n            link = subschemaConfig.dispatcher(context);\r\n        }\r\n        else if (subschemaConfig.link != null) {\r\n            link = subschemaConfig.link;\r\n        }\r\n        if (!link && !rootValue && subschemaConfig.rootValue != null) {\r\n            targetRootValue = subschemaConfig.rootValue;\r\n        }\r\n    }\r\n    if (link != null) {\r\n        return function (_a) {\r\n            var document = _a.document, graphqlContext = _a.context, variables = _a.variables;\r\n            var operation = {\r\n                query: document,\r\n                variables: variables,\r\n                context: { graphqlContext: graphqlContext },\r\n            };\r\n            var observable = execute(link, operation);\r\n            return Promise.resolve(observableToAsyncIterable(observable));\r\n        };\r\n    }\r\n    return function (_a) {\r\n        var document = _a.document, graphqlContext = _a.context, variables = _a.variables;\r\n        return subscribe({\r\n            schema: schema,\r\n            document: document,\r\n            rootValue: targetRootValue,\r\n            contextValue: graphqlContext,\r\n            variableValues: variables,\r\n        });\r\n    };\r\n}\n\n// @schemaDefinition: A GraphQL type schema in shorthand\r\n// @resolvers: Definitions for resolvers to be merged with schema\r\nvar SchemaError = /** @class */ (function (_super) {\r\n    __extends(SchemaError, _super);\r\n    function SchemaError(message) {\r\n        var _this = _super.call(this, message) || this;\r\n        _this.message = message;\r\n        Error.captureStackTrace(_this, _this.constructor);\r\n        return _this;\r\n    }\r\n    return SchemaError;\r\n}(Error));\n\n// If we have any union or interface types throw if no there is no resolveType or isTypeOf resolvers\r\nfunction checkForResolveTypeResolver(schema, requireResolversForResolveType) {\r\n    Object.keys(schema.getTypeMap())\r\n        .map(function (typeName) { return schema.getType(typeName); })\r\n        .forEach(function (type) {\r\n        if (!isAbstractType(type)) {\r\n            return;\r\n        }\r\n        if (!type.resolveType) {\r\n            if (!requireResolversForResolveType) {\r\n                return;\r\n            }\r\n            throw new SchemaError(\"Type \\\"\" + type.name + \"\\\" is missing a \\\"__resolveType\\\" resolver. Pass false into \" +\r\n                '\"resolverValidationOptions.requireResolversForResolveType\" to disable this error.');\r\n        }\r\n    });\r\n}\n\nfunction extendResolversFromInterfaces(schema, resolvers) {\r\n    var typeNames = Object.keys(__assign(__assign({}, schema.getTypeMap()), resolvers));\r\n    var extendedResolvers = {};\r\n    typeNames.forEach(function (typeName) {\r\n        var typeResolvers = resolvers[typeName];\r\n        var type = schema.getType(typeName);\r\n        if (isObjectType(type) ||\r\n            (graphqlVersion() >= 15 && isInterfaceType(type))) {\r\n            var interfaceResolvers = type\r\n                .getInterfaces()\r\n                .map(function (iFace) { return resolvers[iFace.name]; });\r\n            extendedResolvers[typeName] = Object.assign.apply(Object, __spreadArrays([{}], interfaceResolvers, [typeResolvers]));\r\n        }\r\n        else if (typeResolvers != null) {\r\n            extendedResolvers[typeName] = typeResolvers;\r\n        }\r\n    });\r\n    return extendedResolvers;\r\n}\n\nfunction addResolversToSchema(schemaOrOptions, legacyInputResolvers, legacyInputValidationOptions) {\r\n    var options = isSchema(schemaOrOptions)\r\n        ? {\r\n            schema: schemaOrOptions,\r\n            resolvers: legacyInputResolvers,\r\n            resolverValidationOptions: legacyInputValidationOptions,\r\n        }\r\n        : schemaOrOptions;\r\n    var schema = options.schema, inputResolvers = options.resolvers, defaultFieldResolver = options.defaultFieldResolver, _a = options.resolverValidationOptions, resolverValidationOptions = _a === void 0 ? {} : _a, _b = options.inheritResolversFromInterfaces, inheritResolversFromInterfaces = _b === void 0 ? false : _b;\r\n    var _c = resolverValidationOptions.allowResolversNotInSchema, allowResolversNotInSchema = _c === void 0 ? false : _c, requireResolversForResolveType = resolverValidationOptions.requireResolversForResolveType;\r\n    var resolvers = inheritResolversFromInterfaces\r\n        ? extendResolversFromInterfaces(schema, inputResolvers)\r\n        : inputResolvers;\r\n    var typeMap = schema.getTypeMap();\r\n    Object.keys(resolvers).forEach(function (typeName) {\r\n        var resolverValue = resolvers[typeName];\r\n        var resolverType = typeof resolverValue;\r\n        if (resolverType !== 'object' && resolverType !== 'function') {\r\n            throw new SchemaError(\"\\\"\" + typeName + \"\\\" defined in resolvers, but has invalid value \\\"\" + resolverValue + \"\\\". A resolver's value must be of type object or function.\");\r\n        }\r\n        var type = schema.getType(typeName);\r\n        if (!type && typeName !== '__schema') {\r\n            if (allowResolversNotInSchema) {\r\n                return;\r\n            }\r\n            throw new SchemaError(\"\\\"\" + typeName + \"\\\" defined in resolvers, but not in schema\");\r\n        }\r\n        if (isScalarType(type)) {\r\n            // Support -- without recommending -- overriding default scalar types\r\n            Object.keys(resolverValue).forEach(function (fieldName) {\r\n                if (fieldName.startsWith('__')) {\r\n                    type[fieldName.substring(2)] = resolverValue[fieldName];\r\n                }\r\n                else {\r\n                    type[fieldName] = resolverValue[fieldName];\r\n                }\r\n            });\r\n        }\r\n        else if (isEnumType(type)) {\r\n            // We've encountered an enum resolver that is being used to provide an\r\n            // internal enum value.\r\n            // Reference: https://www.apollographql.com/docs/graphql-tools/scalars.html#internal-values\r\n            Object.keys(resolverValue).forEach(function (fieldName) {\r\n                if (!type.getValue(fieldName)) {\r\n                    if (allowResolversNotInSchema) {\r\n                        return;\r\n                    }\r\n                    throw new SchemaError(typeName + \".\" + fieldName + \" was defined in resolvers, but enum is not in schema\");\r\n                }\r\n            });\r\n            var config = toConfig(type);\r\n            var values = type.getValues();\r\n            var newValues = keyValMap(values, function (value) { return value.name; }, function (value) {\r\n                var newValue = Object.keys(resolverValue).includes(value.name)\r\n                    ? resolverValue[value.name]\r\n                    : value.name;\r\n                return {\r\n                    value: newValue,\r\n                    deprecationReason: value.deprecationReason,\r\n                    description: value.description,\r\n                    astNode: value.astNode,\r\n                };\r\n            });\r\n            // healSchema called later to update all fields to new type\r\n            typeMap[typeName] = new GraphQLEnumType(__assign(__assign({}, config), { values: newValues }));\r\n        }\r\n        else if (isUnionType(type)) {\r\n            Object.keys(resolverValue).forEach(function (fieldName) {\r\n                if (fieldName.startsWith('__')) {\r\n                    // this is for isTypeOf and resolveType and all the other stuff.\r\n                    type[fieldName.substring(2)] = resolverValue[fieldName];\r\n                    return;\r\n                }\r\n                if (allowResolversNotInSchema) {\r\n                    return;\r\n                }\r\n                throw new SchemaError(typeName + \" was defined in resolvers, but it's not an object\");\r\n            });\r\n        }\r\n        else if (isObjectType(type) || isInterfaceType(type)) {\r\n            Object.keys(resolverValue).forEach(function (fieldName) {\r\n                if (fieldName.startsWith('__')) {\r\n                    // this is for isTypeOf and resolveType and all the other stuff.\r\n                    type[fieldName.substring(2)] = resolverValue[fieldName];\r\n                    return;\r\n                }\r\n                var fields = type.getFields();\r\n                var field = fields[fieldName];\r\n                if (field == null) {\r\n                    if (allowResolversNotInSchema) {\r\n                        return;\r\n                    }\r\n                    throw new SchemaError(typeName + \".\" + fieldName + \" defined in resolvers, but not in schema\");\r\n                }\r\n                var fieldResolve = resolverValue[fieldName];\r\n                if (typeof fieldResolve === 'function') {\r\n                    // for convenience. Allows shorter syntax in resolver definition file\r\n                    field.resolve = fieldResolve;\r\n                }\r\n                else {\r\n                    if (typeof fieldResolve !== 'object') {\r\n                        throw new SchemaError(\"Resolver \" + typeName + \".\" + fieldName + \" must be object or function\");\r\n                    }\r\n                    setFieldProperties(field, fieldResolve);\r\n                }\r\n            });\r\n        }\r\n    });\r\n    checkForResolveTypeResolver(schema, requireResolversForResolveType);\r\n    // serialize all default values prior to healing fields with new scalar/enum types.\r\n    forEachDefaultValue(schema, serializeInputValue);\r\n    // schema may have new scalar/enum types that require healing\r\n    healSchema(schema);\r\n    // reparse all default values with new parsing functions.\r\n    forEachDefaultValue(schema, parseInputValue);\r\n    if (defaultFieldResolver != null) {\r\n        forEachField(schema, function (field) {\r\n            if (!field.resolve) {\r\n                field.resolve = defaultFieldResolver;\r\n            }\r\n        });\r\n    }\r\n    return schema;\r\n}\r\nfunction setFieldProperties(field, propertiesObj) {\r\n    Object.keys(propertiesObj).forEach(function (propertyName) {\r\n        field[propertyName] = propertiesObj[propertyName];\r\n    });\r\n}\n\n// wraps all resolvers of query, mutation or subscription fields\r\n// with the provided function to simulate a root schema level resolver\r\nfunction addSchemaLevelResolver(schema, fn) {\r\n    // TODO test that schema is a schema, fn is a function\r\n    var rootTypes = [\r\n        schema.getQueryType(),\r\n        schema.getMutationType(),\r\n        schema.getSubscriptionType(),\r\n    ].filter(function (x) { return Boolean(x); });\r\n    rootTypes.forEach(function (type) {\r\n        if (type != null) {\r\n            // XXX this should run at most once per request to simulate a true root resolver\r\n            // for graphql-js this is an approximation that works with queries but not mutations\r\n            var rootResolveFn_1 = runAtMostOncePerRequest(fn);\r\n            var fields_1 = type.getFields();\r\n            Object.keys(fields_1).forEach(function (fieldName) {\r\n                // XXX if the type is a subscription, a same query AST will be ran multiple times so we\r\n                // deactivate here the runOnce if it's a subscription. This may not be optimal though...\r\n                if (type === schema.getSubscriptionType()) {\r\n                    fields_1[fieldName].resolve = wrapResolver(fields_1[fieldName].resolve, fn);\r\n                }\r\n                else {\r\n                    fields_1[fieldName].resolve = wrapResolver(fields_1[fieldName].resolve, rootResolveFn_1);\r\n                }\r\n            });\r\n        }\r\n    });\r\n}\r\n// XXX badly named function. this doesn't really wrap, it just chains resolvers...\r\nfunction wrapResolver(innerResolver, outerResolver) {\r\n    return function (obj, args, ctx, info) {\r\n        return Promise.resolve(outerResolver(obj, args, ctx, info)).then(function (root) {\r\n            if (innerResolver != null) {\r\n                return innerResolver(root, args, ctx, info);\r\n            }\r\n            return defaultFieldResolver(root, args, ctx, info);\r\n        });\r\n    };\r\n}\r\n// XXX this function only works for resolvers\r\n// XXX very hacky way to remember if the function\r\n// already ran for this request. This will only work\r\n// if people don't actually cache the operation.\r\n// if they do cache the operation, they will have to\r\n// manually remove the __runAtMostOnce before every request.\r\nfunction runAtMostOncePerRequest(fn) {\r\n    var value;\r\n    var randomNumber = Math.random();\r\n    return function (root, args, ctx, info) {\r\n        if (!info.operation['__runAtMostOnce']) {\r\n            info.operation['__runAtMostOnce'] = {};\r\n        }\r\n        if (!info.operation['__runAtMostOnce'][randomNumber]) {\r\n            info.operation['__runAtMostOnce'][randomNumber] = true;\r\n            value = fn(root, args, ctx, info);\r\n        }\r\n        return value;\r\n    };\r\n}\n\nfunction assertResolversPresent(schema, resolverValidationOptions) {\r\n    if (resolverValidationOptions === void 0) { resolverValidationOptions = {}; }\r\n    var _a = resolverValidationOptions.requireResolversForArgs, requireResolversForArgs = _a === void 0 ? false : _a, _b = resolverValidationOptions.requireResolversForNonScalar, requireResolversForNonScalar = _b === void 0 ? false : _b, _c = resolverValidationOptions.requireResolversForAllFields, requireResolversForAllFields = _c === void 0 ? false : _c;\r\n    if (requireResolversForAllFields &&\r\n        (requireResolversForArgs || requireResolversForNonScalar)) {\r\n        throw new TypeError('requireResolversForAllFields takes precedence over the more specific assertions. ' +\r\n            'Please configure either requireResolversForAllFields or requireResolversForArgs / ' +\r\n            'requireResolversForNonScalar, but not a combination of them.');\r\n    }\r\n    forEachField(schema, function (field, typeName, fieldName) {\r\n        // requires a resolver for *every* field.\r\n        if (requireResolversForAllFields) {\r\n            expectResolver(field, typeName, fieldName);\r\n        }\r\n        // requires a resolver on every field that has arguments\r\n        if (requireResolversForArgs && field.args.length > 0) {\r\n            expectResolver(field, typeName, fieldName);\r\n        }\r\n        // requires a resolver on every field that returns a non-scalar type\r\n        if (requireResolversForNonScalar &&\r\n            !isScalarType(getNamedType(field.type))) {\r\n            expectResolver(field, typeName, fieldName);\r\n        }\r\n    });\r\n}\r\nfunction expectResolver(field, typeName, fieldName) {\r\n    if (!field.resolve) {\r\n        // eslint-disable-next-line no-console\r\n        console.warn(\"Resolver missing for \\\"\" + typeName + \".\" + fieldName + \"\\\". To disable this warning check https://github.com/apollostack/graphql-tools/issues/131\");\r\n        return;\r\n    }\r\n    if (typeof field.resolve !== 'function') {\r\n        throw new SchemaError(\"Resolver \\\"\" + typeName + \".\" + fieldName + \"\\\" must be a function\");\r\n    }\r\n}\n\nfunction attachDirectiveResolvers(schema, directiveResolvers) {\r\n    if (typeof directiveResolvers !== 'object') {\r\n        throw new Error(\"Expected directiveResolvers to be of type object, got \" + typeof directiveResolvers);\r\n    }\r\n    if (Array.isArray(directiveResolvers)) {\r\n        throw new Error('Expected directiveResolvers to be of type object, got Array');\r\n    }\r\n    var schemaDirectives = Object.create(null);\r\n    Object.keys(directiveResolvers).forEach(function (directiveName) {\r\n        schemaDirectives[directiveName] = /** @class */ (function (_super) {\r\n            __extends(class_1, _super);\r\n            function class_1() {\r\n                return _super !== null && _super.apply(this, arguments) || this;\r\n            }\r\n            class_1.prototype.visitFieldDefinition = function (field) {\r\n                var resolver = directiveResolvers[directiveName];\r\n                var originalResolver = field.resolve != null ? field.resolve : defaultFieldResolver;\r\n                var directiveArgs = this.args;\r\n                field.resolve = function () {\r\n                    var args = [];\r\n                    for (var _i = 0; _i < arguments.length; _i++) {\r\n                        args[_i] = arguments[_i];\r\n                    }\r\n                    var source = args[0] /* original args */, context = args[2], info = args[3];\r\n                    return resolver(function () {\r\n                        return new Promise(function (resolve, reject) {\r\n                            var result = originalResolver.apply(field, args);\r\n                            if (result instanceof Error) {\r\n                                reject(result);\r\n                            }\r\n                            resolve(result);\r\n                        });\r\n                    }, source, directiveArgs, context, info);\r\n                };\r\n            };\r\n            return class_1;\r\n        }(SchemaDirectiveVisitor));\r\n    });\r\n    SchemaDirectiveVisitor.visitSchemaDirectives(schema, schemaDirectives);\r\n}\n\n// takes a GraphQL-JS schema and an object of connectors, then attaches\r\n// the connectors to the context by wrapping each query or mutation resolve\r\n// function with a function that attaches connectors if they don't exist.\r\n// attaches connectors only once to make sure they are singletons\r\nvar attachConnectorsToContext = deprecated({\r\n    version: '0.7.0',\r\n    url: 'https://github.com/apollostack/graphql-tools/issues/140',\r\n}, function (schema, connectors) {\r\n    if (!schema || !isSchema(schema)) {\r\n        throw new Error('schema must be an instance of GraphQLSchema. ' +\r\n            'This error could be caused by installing more than one version of GraphQL-JS');\r\n    }\r\n    if (typeof connectors !== 'object') {\r\n        var connectorType = typeof connectors;\r\n        throw new Error(\"Expected connectors to be of type object, got \" + connectorType);\r\n    }\r\n    if (Object.keys(connectors).length === 0) {\r\n        throw new Error('Expected connectors to not be an empty object');\r\n    }\r\n    if (Array.isArray(connectors)) {\r\n        throw new Error('Expected connectors to be of type object, got Array');\r\n    }\r\n    if (schema['_apolloConnectorsAttached']) {\r\n        throw new Error('Connectors already attached to context, cannot attach more than once');\r\n    }\r\n    schema['_apolloConnectorsAttached'] = true;\r\n    var attachconnectorFn = function (root, _args, ctx) {\r\n        if (typeof ctx !== 'object') {\r\n            // if in any way possible, we should throw an error when the attachconnectors\r\n            // function is called, not when a query is executed.\r\n            var contextType = typeof ctx;\r\n            throw new Error(\"Cannot attach connector because context is not an object: \" + contextType);\r\n        }\r\n        if (typeof ctx.connectors === 'undefined') {\r\n            ctx.connectors = {};\r\n        }\r\n        Object.keys(connectors).forEach(function (connectorName) {\r\n            var connector = connectors[connectorName];\r\n            if (connector.prototype != null) {\r\n                ctx.connectors[connectorName] = new connector(ctx);\r\n            }\r\n            else {\r\n                throw new Error('Connector must be a function or an class');\r\n            }\r\n        });\r\n        return root;\r\n    };\r\n    addSchemaLevelResolver(schema, attachconnectorFn);\r\n});\n\nfunction extractExtensionDefinitions(ast) {\r\n    var extensionDefs = ast.definitions.filter(function (def) {\r\n        return def.kind === Kind.OBJECT_TYPE_EXTENSION ||\r\n            (graphqlVersion() >= 13 && def.kind === Kind.INTERFACE_TYPE_EXTENSION) ||\r\n            def.kind === Kind.INPUT_OBJECT_TYPE_EXTENSION ||\r\n            def.kind === Kind.UNION_TYPE_EXTENSION ||\r\n            def.kind === Kind.ENUM_TYPE_EXTENSION ||\r\n            def.kind === Kind.SCALAR_TYPE_EXTENSION ||\r\n            def.kind === Kind.SCHEMA_EXTENSION;\r\n    });\r\n    return __assign(__assign({}, ast), { definitions: extensionDefs });\r\n}\r\nfunction filterExtensionDefinitions(ast) {\r\n    var extensionDefs = ast.definitions.filter(function (def) {\r\n        return def.kind !== Kind.OBJECT_TYPE_EXTENSION &&\r\n            def.kind !== Kind.INTERFACE_TYPE_EXTENSION &&\r\n            def.kind !== Kind.INPUT_OBJECT_TYPE_EXTENSION &&\r\n            def.kind !== Kind.UNION_TYPE_EXTENSION &&\r\n            def.kind !== Kind.ENUM_TYPE_EXTENSION &&\r\n            def.kind !== Kind.SCALAR_TYPE_EXTENSION &&\r\n            def.kind !== Kind.SCHEMA_EXTENSION;\r\n    });\r\n    return __assign(__assign({}, ast), { definitions: extensionDefs });\r\n}\n\nfunction concatenateTypeDefs(typeDefinitionsAry, calledFunctionRefs) {\r\n    if (calledFunctionRefs === void 0) { calledFunctionRefs = []; }\r\n    var resolvedTypeDefinitions = [];\r\n    typeDefinitionsAry.forEach(function (typeDef) {\r\n        if (typeof typeDef === 'function') {\r\n            if (calledFunctionRefs.indexOf(typeDef) === -1) {\r\n                calledFunctionRefs.push(typeDef);\r\n                resolvedTypeDefinitions = resolvedTypeDefinitions.concat(concatenateTypeDefs(typeDef(), calledFunctionRefs));\r\n            }\r\n        }\r\n        else if (typeof typeDef === 'string') {\r\n            resolvedTypeDefinitions.push(typeDef.trim());\r\n        }\r\n        else if (typeDef.kind !== undefined) {\r\n            resolvedTypeDefinitions.push(print(typeDef).trim());\r\n        }\r\n        else {\r\n            var type = typeof typeDef;\r\n            throw new SchemaError(\"typeDef array must contain only strings and functions, got \" + type);\r\n        }\r\n    });\r\n    return uniq(resolvedTypeDefinitions.map(function (x) { return x.trim(); })).join('\\n');\r\n}\r\nfunction uniq(array) {\r\n    return array.reduce(function (accumulator, currentValue) {\r\n        return accumulator.indexOf(currentValue) === -1\r\n            ? __spreadArrays(accumulator, [currentValue]) : accumulator;\r\n    }, []);\r\n}\n\nfunction buildSchemaFromTypeDefinitions(typeDefinitions, parseOptions) {\r\n    // TODO: accept only array here, otherwise interfaces get confusing.\r\n    var myDefinitions = typeDefinitions;\r\n    var astDocument;\r\n    if (isDocumentNode(typeDefinitions)) {\r\n        astDocument = typeDefinitions;\r\n    }\r\n    else if (typeof myDefinitions !== 'string') {\r\n        if (!Array.isArray(myDefinitions)) {\r\n            var type = typeof myDefinitions;\r\n            throw new SchemaError(\"typeDefs must be a string, array or schema AST, got \" + type);\r\n        }\r\n        myDefinitions = concatenateTypeDefs(myDefinitions);\r\n    }\r\n    if (typeof myDefinitions === 'string') {\r\n        astDocument = parse(myDefinitions, parseOptions);\r\n    }\r\n    var typesAst = filterExtensionDefinitions(astDocument);\r\n    var backcompatOptions = { commentDescriptions: true };\r\n    var schema = buildASTSchema(typesAst, backcompatOptions);\r\n    var extensionsAst = extractExtensionDefinitions(astDocument);\r\n    if (extensionsAst.definitions.length > 0) {\r\n        schema = extendSchema$1(schema, extensionsAst, backcompatOptions);\r\n    }\r\n    return schema;\r\n}\r\nfunction isDocumentNode(typeDefinitions) {\r\n    return typeDefinitions.kind !== undefined;\r\n}\n\nfunction chainResolvers(resolvers) {\r\n    return function (root, args, ctx, info) {\r\n        return resolvers.reduce(function (prev, curResolver) {\r\n            if (curResolver != null) {\r\n                return curResolver(prev, args, ctx, info);\r\n            }\r\n            return defaultFieldResolver(prev, args, ctx, info);\r\n        }, root);\r\n    };\r\n}\n\n/*\r\n * fn: The function to decorate with the logger\r\n * logger: an object instance of type Logger\r\n * hint: an optional hint to add to the error's message\r\n */\r\nfunction decorateWithLogger(fn, logger, hint) {\r\n    var resolver = fn != null ? fn : defaultFieldResolver;\r\n    var logError = function (e) {\r\n        // TODO: clone the error properly\r\n        var newE = new Error();\r\n        newE.stack = e.stack;\r\n        /* istanbul ignore else: always get the hint from addErrorLoggingToSchema */\r\n        if (hint) {\r\n            newE['originalMessage'] = e.message;\r\n            newE['message'] = \"Error in resolver \" + hint + \"\\n\" + e.message;\r\n        }\r\n        logger.log(newE);\r\n    };\r\n    return function (root, args, ctx, info) {\r\n        try {\r\n            var result = resolver(root, args, ctx, info);\r\n            // If the resolver returns a Promise log any Promise rejects.\r\n            if (result &&\r\n                typeof result.then === 'function' &&\r\n                typeof result.catch === 'function') {\r\n                result.catch(function (reason) {\r\n                    // make sure that it's an error we're logging.\r\n                    var error = reason instanceof Error ? reason : new Error(reason);\r\n                    logError(error);\r\n                    // We don't want to leave an unhandled exception so pass on error.\r\n                    return reason;\r\n                });\r\n            }\r\n            return result;\r\n        }\r\n        catch (e) {\r\n            logError(e);\r\n            // we want to pass on the error, just in case.\r\n            throw e;\r\n        }\r\n    };\r\n}\n\nfunction makeExecutableSchema(_a) {\r\n    var typeDefs = _a.typeDefs, _b = _a.resolvers, resolvers = _b === void 0 ? {} : _b, connectors = _a.connectors, logger = _a.logger, _c = _a.allowUndefinedInResolve, allowUndefinedInResolve = _c === void 0 ? true : _c, _d = _a.resolverValidationOptions, resolverValidationOptions = _d === void 0 ? {} : _d, directiveResolvers = _a.directiveResolvers, schemaDirectives = _a.schemaDirectives, _e = _a.parseOptions, parseOptions = _e === void 0 ? {} : _e, _f = _a.inheritResolversFromInterfaces, inheritResolversFromInterfaces = _f === void 0 ? false : _f;\r\n    // Validate and clean up arguments\r\n    if (typeof resolverValidationOptions !== 'object') {\r\n        throw new SchemaError('Expected `resolverValidationOptions` to be an object');\r\n    }\r\n    if (!typeDefs) {\r\n        throw new SchemaError('Must provide typeDefs');\r\n    }\r\n    // We allow passing in an array of resolver maps, in which case we merge them\r\n    var resolverMap = Array.isArray(resolvers)\r\n        ? resolvers\r\n            .filter(function (resolverObj) { return typeof resolverObj === 'object'; })\r\n            .reduce(mergeDeep, {})\r\n        : resolvers;\r\n    // Arguments are now validated and cleaned up\r\n    var schema = buildSchemaFromTypeDefinitions(typeDefs, parseOptions);\r\n    addResolversToSchema({\r\n        schema: schema,\r\n        resolvers: resolverMap,\r\n        resolverValidationOptions: resolverValidationOptions,\r\n        inheritResolversFromInterfaces: inheritResolversFromInterfaces,\r\n    });\r\n    assertResolversPresent(schema, resolverValidationOptions);\r\n    if (!allowUndefinedInResolve) {\r\n        addCatchUndefinedToSchema(schema);\r\n    }\r\n    if (logger != null) {\r\n        addErrorLoggingToSchema(schema, logger);\r\n    }\r\n    if (typeof resolvers['__schema'] === 'function') {\r\n        // TODO a bit of a hack now, better rewrite generateSchema to attach it there.\r\n        // not doing that now, because I'd have to rewrite a lot of tests.\r\n        addSchemaLevelResolver(schema, resolvers['__schema']);\r\n    }\r\n    if (connectors != null) {\r\n        // connectors are optional, at least for now. That means you can just import them in the resolve\r\n        // function if you want.\r\n        attachConnectorsToContext(schema, connectors);\r\n    }\r\n    if (directiveResolvers != null) {\r\n        attachDirectiveResolvers(schema, directiveResolvers);\r\n    }\r\n    if (schemaDirectives != null) {\r\n        SchemaDirectiveVisitor.visitSchemaDirectives(schema, schemaDirectives);\r\n    }\r\n    return schema;\r\n}\r\nfunction decorateToCatchUndefined(fn, hint) {\r\n    var resolve = fn == null ? defaultFieldResolver : fn;\r\n    return function (root, args, ctx, info) {\r\n        var result = resolve(root, args, ctx, info);\r\n        if (typeof result === 'undefined') {\r\n            throw new Error(\"Resolver for \\\"\" + hint + \"\\\" returned undefined\");\r\n        }\r\n        return result;\r\n    };\r\n}\r\nfunction addCatchUndefinedToSchema(schema) {\r\n    forEachField(schema, function (field, typeName, fieldName) {\r\n        var errorHint = typeName + \".\" + fieldName;\r\n        field.resolve = decorateToCatchUndefined(field.resolve, errorHint);\r\n    });\r\n}\r\nfunction addErrorLoggingToSchema(schema, logger) {\r\n    if (!logger) {\r\n        throw new Error('Must provide a logger');\r\n    }\r\n    if (typeof logger.log !== 'function') {\r\n        throw new Error('Logger.log must be a function');\r\n    }\r\n    forEachField(schema, function (field, typeName, fieldName) {\r\n        var errorHint = typeName + \".\" + fieldName;\r\n        field.resolve = decorateWithLogger(field.resolve, logger, errorHint);\r\n    });\r\n}\n\n// These functions are preserved for backwards compatibility.\r\n// They are not simply rexported with new (old) names so as to allow\r\n// typedoc to annotate them.\r\nfunction addResolveFunctionsToSchema(schemaOrOptions, legacyInputResolvers, legacyInputValidationOptions) {\r\n    return addResolversToSchema(schemaOrOptions, legacyInputResolvers, legacyInputValidationOptions);\r\n}\r\nfunction addSchemaLevelResolveFunction(schema, fn) {\r\n    addSchemaLevelResolver(schema, fn);\r\n}\r\nfunction assertResolveFunctionsPresent(schema, resolverValidationOptions) {\r\n    if (resolverValidationOptions === void 0) { resolverValidationOptions = {}; }\r\n    assertResolversPresent(schema, resolverValidationOptions);\r\n}\n\nfunction getFinalPromise(object) {\r\n    return Promise.resolve(object).then(function (resolvedObject) {\r\n        if (resolvedObject == null) {\r\n            return resolvedObject;\r\n        }\r\n        if (Array.isArray(resolvedObject)) {\r\n            return Promise.all(resolvedObject.map(function (o) { return getFinalPromise(o); }));\r\n        }\r\n        else if (typeof resolvedObject === 'object') {\r\n            var keys_1 = Object.keys(resolvedObject);\r\n            return Promise.all(keys_1.map(function (key) { return getFinalPromise(resolvedObject[key]); })).then(function (awaitedValues) {\r\n                for (var i = 0; i < keys_1.length; i++) {\r\n                    resolvedObject[keys_1[i]] = awaitedValues[i];\r\n                }\r\n                return resolvedObject;\r\n            });\r\n        }\r\n        return resolvedObject;\r\n    });\r\n}\r\nvar AwaitVariablesLink = /** @class */ (function (_super) {\r\n    __extends(AwaitVariablesLink, _super);\r\n    function AwaitVariablesLink() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    AwaitVariablesLink.prototype.request = function (operation, forward) {\r\n        return new Observable(function (observer) {\r\n            var subscription;\r\n            getFinalPromise(operation.variables)\r\n                .then(function (resolvedVariables) {\r\n                operation.variables = resolvedVariables;\r\n                subscription = forward(operation).subscribe({\r\n                    next: observer.next.bind(observer),\r\n                    error: observer.error.bind(observer),\r\n                    complete: observer.complete.bind(observer),\r\n                });\r\n            })\r\n                .catch(observer.error.bind(observer));\r\n            return function () {\r\n                if (subscription != null) {\r\n                    subscription.unsubscribe();\r\n                }\r\n            };\r\n        });\r\n    };\r\n    return AwaitVariablesLink;\r\n}(ApolloLink));\n\n/* eslint-disable import/no-nodejs-modules */\r\nvar FormDataWithStreamSupport = /** @class */ (function (_super) {\r\n    __extends(FormDataWithStreamSupport, _super);\r\n    function FormDataWithStreamSupport(options) {\r\n        var _this = _super.call(this, options) || this;\r\n        _this.hasUnknowableLength = false;\r\n        return _this;\r\n    }\r\n    FormDataWithStreamSupport.prototype.append = function (key, value, optionsOrFilename) {\r\n        if (optionsOrFilename === void 0) { optionsOrFilename = {}; }\r\n        // allow filename as single option\r\n        var options = typeof optionsOrFilename === 'string'\r\n            ? { filename: optionsOrFilename }\r\n            : optionsOrFilename;\r\n        // empty or either doesn't have path or not an http response\r\n        if (!options.knownLength &&\r\n            !Buffer.isBuffer(value) &&\r\n            typeof value !== 'string' &&\r\n            !value.path &&\r\n            !(value.readable && hasOwnProperty(value, 'httpVersion'))) {\r\n            this.hasUnknowableLength = true;\r\n        }\r\n        _super.prototype.append.call(this, key, value, options);\r\n    };\r\n    FormDataWithStreamSupport.prototype.getLength = function (callback) {\r\n        if (this.hasUnknowableLength) {\r\n            return null;\r\n        }\r\n        return _super.prototype.getLength.call(this, callback);\r\n    };\r\n    FormDataWithStreamSupport.prototype.getLengthSync = function () {\r\n        if (this.hasUnknowableLength) {\r\n            return null;\r\n        }\r\n        // eslint-disable-next-line no-sync\r\n        return _super.prototype.getLengthSync.call(this);\r\n    };\r\n    return FormDataWithStreamSupport;\r\n}(FormData));\r\nvar createServerHttpLink = function (options) {\r\n    return concat(new AwaitVariablesLink(), createUploadLink(__assign(__assign({}, options), { fetch: fetch, FormData: FormDataWithStreamSupport, isExtractableFile: function (value) {\r\n            return isExtractableFile(value) || (value === null || value === void 0 ? void 0 : value.createReadStream);\r\n        }, formDataAppendFile: function (form, index, file) {\r\n            if (file.createReadStream != null) {\r\n                form.append(index, file.createReadStream(), {\r\n                    filename: file.filename,\r\n                    contentType: file.mimetype,\r\n                });\r\n            }\r\n            else {\r\n                formDataAppendFile(form, index, file);\r\n            }\r\n        } })));\r\n};\n\n/**\r\n * This function wraps addMocksToSchema for more convenience\r\n */\r\nfunction mockServer(schema, mocks, preserveResolvers) {\r\n    if (preserveResolvers === void 0) { preserveResolvers = false; }\r\n    var mySchema;\r\n    if (!isSchema(schema)) {\r\n        // TODO: provide useful error messages here if this fails\r\n        mySchema = buildSchemaFromTypeDefinitions(schema);\r\n    }\r\n    else {\r\n        mySchema = schema;\r\n    }\r\n    addMocksToSchema({ schema: mySchema, mocks: mocks, preserveResolvers: preserveResolvers });\r\n    return { query: function (query, vars) { return graphql(mySchema, query, {}, {}, vars); } };\r\n}\r\nvar defaultMockMap = new Map();\r\ndefaultMockMap.set('Int', function () { return Math.round(Math.random() * 200) - 100; });\r\ndefaultMockMap.set('Float', function () { return Math.random() * 200 - 100; });\r\ndefaultMockMap.set('String', function () { return 'Hello World'; });\r\ndefaultMockMap.set('Boolean', function () { return Math.random() > 0.5; });\r\ndefaultMockMap.set('ID', function () { return v4(); });\r\n// TODO allow providing a seed such that lengths of list could be deterministic\r\n// this could be done by using casual to get a random list length if the casual\r\n// object is global.\r\nfunction addMocksToSchema(_a) {\r\n    var schema = _a.schema, _b = _a.mocks, mocks = _b === void 0 ? {} : _b, _c = _a.preserveResolvers, preserveResolvers = _c === void 0 ? false : _c;\r\n    if (!schema) {\r\n        throw new Error('Must provide schema to mock');\r\n    }\r\n    if (!isSchema(schema)) {\r\n        throw new Error('Value at \"schema\" must be of type GraphQLSchema');\r\n    }\r\n    if (!isObject$1(mocks)) {\r\n        throw new Error('mocks must be of type Object');\r\n    }\r\n    // use Map internally, because that API is nicer.\r\n    var mockFunctionMap = new Map();\r\n    Object.keys(mocks).forEach(function (typeName) {\r\n        mockFunctionMap.set(typeName, mocks[typeName]);\r\n    });\r\n    mockFunctionMap.forEach(function (mockFunction, mockTypeName) {\r\n        if (typeof mockFunction !== 'function') {\r\n            throw new Error(\"mockFunctionMap[\" + mockTypeName + \"] must be a function\");\r\n        }\r\n    });\r\n    var mockType = function (type, _typeName, fieldName) {\r\n        // order of precendence for mocking:\r\n        // 1. if the object passed in already has fieldName, just use that\r\n        // --> if it's a function, that becomes your resolver\r\n        // --> if it's a value, the mock resolver will return that\r\n        // 2. if the nullableType is a list, recurse\r\n        // 2. if there's a mock defined for this typeName, that will be used\r\n        // 3. if there's no mock defined, use the default mocks for this type\r\n        return function (root, args, context, info) {\r\n            // nullability doesn't matter for the purpose of mocking.\r\n            var fieldType = getNullableType(type);\r\n            var namedFieldType = getNamedType(fieldType);\r\n            if (fieldName && root && typeof root[fieldName] !== 'undefined') {\r\n                var result = void 0;\r\n                // if we're here, the field is already defined\r\n                if (typeof root[fieldName] === 'function') {\r\n                    result = root[fieldName](root, args, context, info);\r\n                    if (result instanceof MockList) {\r\n                        result = result.mock(root, args, context, info, fieldType, mockType);\r\n                    }\r\n                }\r\n                else {\r\n                    result = root[fieldName];\r\n                }\r\n                // Now we merge the result with the default mock for this type.\r\n                // This allows overriding defaults while writing very little code.\r\n                if (mockFunctionMap.has(namedFieldType.name)) {\r\n                    var mock = mockFunctionMap.get(namedFieldType.name);\r\n                    result = mergeMocks(mock.bind(null, root, args, context, info), result);\r\n                }\r\n                return result;\r\n            }\r\n            if (isListType(fieldType)) {\r\n                return [\r\n                    mockType(fieldType.ofType)(root, args, context, info),\r\n                    mockType(fieldType.ofType)(root, args, context, info),\r\n                ];\r\n            }\r\n            if (mockFunctionMap.has(fieldType.name) && !isAbstractType(fieldType)) {\r\n                // the object passed doesn't have this field, so we apply the default mock\r\n                var mock = mockFunctionMap.get(fieldType.name);\r\n                return mock(root, args, context, info);\r\n            }\r\n            if (isObjectType(fieldType)) {\r\n                // objects don't return actual data, we only need to mock scalars!\r\n                return {};\r\n            }\r\n            // if a mock function is provided for unionType or interfaceType, execute it to resolve the concrete type\r\n            // otherwise randomly pick a type from all implementation types\r\n            if (isAbstractType(fieldType)) {\r\n                var implementationType = void 0;\r\n                if (mockFunctionMap.has(fieldType.name)) {\r\n                    var mock = mockFunctionMap.get(fieldType.name);\r\n                    var interfaceMockObj = mock(root, args, context, info);\r\n                    if (!interfaceMockObj || !interfaceMockObj.__typename) {\r\n                        return Error(\"Please return a __typename in \\\"\" + fieldType.name + \"\\\"\");\r\n                    }\r\n                    implementationType = schema.getType(interfaceMockObj.__typename);\r\n                }\r\n                else {\r\n                    var possibleTypes = schema.getPossibleTypes(fieldType);\r\n                    implementationType = getRandomElement(possibleTypes);\r\n                }\r\n                return __assign({ __typename: implementationType }, mockType(implementationType)(root, args, context, info));\r\n            }\r\n            if (isEnumType(fieldType)) {\r\n                return getRandomElement(fieldType.getValues()).value;\r\n            }\r\n            if (defaultMockMap.has(fieldType.name)) {\r\n                var defaultMock = defaultMockMap.get(fieldType.name);\r\n                return defaultMock(root, args, context, info);\r\n            }\r\n            // if we get to here, we don't have a value, and we don't have a mock for this type,\r\n            // we could return undefined, but that would be hard to debug, so we throw instead.\r\n            // however, we returning it instead of throwing it, so preserveResolvers can handle the failures.\r\n            return Error(\"No mock defined for type \\\"\" + fieldType.name + \"\\\"\");\r\n        };\r\n    };\r\n    forEachField(schema, function (field, typeName, fieldName) {\r\n        assignResolveType(field.type, preserveResolvers);\r\n        var mockResolver = mockType(field.type, typeName, fieldName);\r\n        // we have to handle the root mutation and root query types differently,\r\n        // because no resolver is called at the root.\r\n        var queryType = schema.getQueryType();\r\n        var isOnQueryType = queryType != null && queryType.name === typeName;\r\n        var mutationType = schema.getMutationType();\r\n        var isOnMutationType = mutationType != null && mutationType.name === typeName;\r\n        if (isOnQueryType || isOnMutationType) {\r\n            if (mockFunctionMap.has(typeName)) {\r\n                var rootMock_1 = mockFunctionMap.get(typeName);\r\n                // XXX: BUG in here, need to provide proper signature for rootMock.\r\n                if (typeof rootMock_1(undefined, {}, {}, {})[fieldName] ===\r\n                    'function') {\r\n                    mockResolver = function (root, args, context, info) {\r\n                        var updatedRoot = root !== null && root !== void 0 ? root : {}; // TODO: should we clone instead?\r\n                        updatedRoot[fieldName] = rootMock_1(root, args, context, info)[fieldName];\r\n                        // XXX this is a bit of a hack to still use mockType, which\r\n                        // lets you mock lists etc. as well\r\n                        // otherwise we could just set field.resolve to rootMock()[fieldName]\r\n                        // it's like pretending there was a resolver that ran before\r\n                        // the root resolver.\r\n                        return mockType(field.type, typeName, fieldName)(updatedRoot, args, context, info);\r\n                    };\r\n                }\r\n            }\r\n        }\r\n        if (!preserveResolvers || !field.resolve) {\r\n            field.resolve = mockResolver;\r\n        }\r\n        else {\r\n            var oldResolver_1 = field.resolve;\r\n            field.resolve = function (rootObject, args, context, info) {\r\n                return Promise.all([\r\n                    mockResolver(rootObject, args, context, info),\r\n                    oldResolver_1(rootObject, args, context, info),\r\n                ]).then(function (values) {\r\n                    var mockedValue = values[0], resolvedValue = values[1];\r\n                    // In case we couldn't mock\r\n                    if (mockedValue instanceof Error) {\r\n                        // only if value was not resolved, populate the error.\r\n                        if (undefined === resolvedValue) {\r\n                            throw mockedValue;\r\n                        }\r\n                        return resolvedValue;\r\n                    }\r\n                    if (resolvedValue instanceof Date && mockedValue instanceof Date) {\r\n                        return undefined !== resolvedValue ? resolvedValue : mockedValue;\r\n                    }\r\n                    if (isObject$1(mockedValue) && isObject$1(resolvedValue)) {\r\n                        // Object.assign() won't do here, as we need to all properties, including\r\n                        // the non-enumerable ones and defined using Object.defineProperty\r\n                        var emptyObject = Object.create(Object.getPrototypeOf(resolvedValue));\r\n                        return copyOwnProps(emptyObject, resolvedValue, mockedValue);\r\n                    }\r\n                    return undefined !== resolvedValue ? resolvedValue : mockedValue;\r\n                });\r\n            };\r\n        }\r\n    });\r\n}\r\nfunction isObject$1(thing) {\r\n    return thing === Object(thing) && !Array.isArray(thing);\r\n}\r\n// returns a random element from that ary\r\nfunction getRandomElement(ary) {\r\n    var sample = Math.floor(Math.random() * ary.length);\r\n    return ary[sample];\r\n}\r\nfunction mergeObjects(a, b) {\r\n    return Object.assign(a, b);\r\n}\r\nfunction copyOwnPropsIfNotPresent(target, source) {\r\n    Object.getOwnPropertyNames(source).forEach(function (prop) {\r\n        if (!Object.getOwnPropertyDescriptor(target, prop)) {\r\n            var propertyDescriptor = Object.getOwnPropertyDescriptor(source, prop);\r\n            Object.defineProperty(target, prop, propertyDescriptor == null ? {} : propertyDescriptor);\r\n        }\r\n    });\r\n}\r\nfunction copyOwnProps(target) {\r\n    var sources = [];\r\n    for (var _i = 1; _i < arguments.length; _i++) {\r\n        sources[_i - 1] = arguments[_i];\r\n    }\r\n    sources.forEach(function (source) {\r\n        var chain = source;\r\n        while (chain != null) {\r\n            copyOwnPropsIfNotPresent(target, chain);\r\n            chain = Object.getPrototypeOf(chain);\r\n        }\r\n    });\r\n    return target;\r\n}\r\n// takes either an object or a (possibly nested) array\r\n// and completes the customMock object with any fields\r\n// defined on genericMock\r\n// only merges objects or arrays. Scalars are returned as is\r\nfunction mergeMocks(genericMockFunction, customMock) {\r\n    if (Array.isArray(customMock)) {\r\n        return customMock.map(function (el) { return mergeMocks(genericMockFunction, el); });\r\n    }\r\n    if (isObject$1(customMock)) {\r\n        return mergeObjects(genericMockFunction(), customMock);\r\n    }\r\n    return customMock;\r\n}\r\nfunction getResolveType(namedFieldType) {\r\n    if (isAbstractType(namedFieldType)) {\r\n        return namedFieldType.resolveType;\r\n    }\r\n}\r\nfunction assignResolveType(type, preserveResolvers) {\r\n    var fieldType = getNullableType(type);\r\n    var namedFieldType = getNamedType(fieldType);\r\n    var oldResolveType = getResolveType(namedFieldType);\r\n    if (preserveResolvers && oldResolveType != null && oldResolveType.length) {\r\n        return;\r\n    }\r\n    if (isInterfaceType(namedFieldType) || isUnionType(namedFieldType)) {\r\n        // the default `resolveType` always returns null. We add a fallback\r\n        // resolution that works with how unions and interface are mocked\r\n        namedFieldType.resolveType = function (data, _context, info) { return info.schema.getType(data.__typename); };\r\n    }\r\n}\r\nvar MockList = /** @class */ (function () {\r\n    // wrappedFunction can return another MockList or a value\r\n    function MockList(len, wrappedFunction) {\r\n        this.len = len;\r\n        if (typeof wrappedFunction !== 'undefined') {\r\n            if (typeof wrappedFunction !== 'function') {\r\n                throw new Error('Second argument to MockList must be a function or undefined');\r\n            }\r\n            this.wrappedFunction = wrappedFunction;\r\n        }\r\n    }\r\n    MockList.prototype.mock = function (root, args, context, info, fieldType, mockTypeFunc) {\r\n        var arr;\r\n        if (Array.isArray(this.len)) {\r\n            arr = new Array(this.randint(this.len[0], this.len[1]));\r\n        }\r\n        else {\r\n            arr = new Array(this.len);\r\n        }\r\n        for (var i = 0; i < arr.length; i++) {\r\n            if (typeof this.wrappedFunction === 'function') {\r\n                var res = this.wrappedFunction(root, args, context, info);\r\n                if (res instanceof MockList) {\r\n                    var nullableType = getNullableType(fieldType.ofType);\r\n                    arr[i] = res.mock(root, args, context, info, nullableType, mockTypeFunc);\r\n                }\r\n                else {\r\n                    arr[i] = res;\r\n                }\r\n            }\r\n            else {\r\n                arr[i] = mockTypeFunc(fieldType.ofType)(root, args, context, info);\r\n            }\r\n        }\r\n        return arr;\r\n    };\r\n    MockList.prototype.randint = function (low, high) {\r\n        return Math.floor(Math.random() * (high - low + 1) + low);\r\n    };\r\n    return MockList;\r\n}());\r\n// retain addMockFunctionsToSchema for backwards compatibility\r\nfunction addMockFunctionsToSchema(_a) {\r\n    var schema = _a.schema, _b = _a.mocks, mocks = _b === void 0 ? {} : _b, _c = _a.preserveResolvers, preserveResolvers = _c === void 0 ? false : _c;\r\n    addMocksToSchema({ schema: schema, mocks: mocks, preserveResolvers: preserveResolvers });\r\n}\n\nvar GraphQLUpload = new GraphQLScalarType({\r\n    name: 'Upload',\r\n    description: 'The `Upload` scalar type represents a file upload.',\r\n    parseValue: function (value) {\r\n        if (value != null && value.promise instanceof Promise) {\r\n            // graphql-upload v10\r\n            return value.promise;\r\n        }\r\n        else if (value instanceof Promise) {\r\n            // graphql-upload v9\r\n            return value;\r\n        }\r\n        throw new GraphQLError('Upload value invalid.');\r\n    },\r\n    // serialization requires to support schema stitching\r\n    serialize: function (value) { return value; },\r\n    parseLiteral: function (ast) {\r\n        throw new GraphQLError('Upload literal unsupported.', ast);\r\n    },\r\n});\n\nvar parsedIntrospectionQuery = parse(getIntrospectionQuery());\r\nfunction introspectSchema(linkOrFetcher, linkContext) {\r\n    var fetcher = typeof linkOrFetcher === 'function'\r\n        ? linkOrFetcher\r\n        : linkToFetcher(linkOrFetcher);\r\n    return fetcher({\r\n        query: parsedIntrospectionQuery,\r\n        context: linkContext,\r\n    }).then(function (introspectionResult) {\r\n        if ((Array.isArray(introspectionResult.errors) &&\r\n            introspectionResult.errors.length) ||\r\n            !introspectionResult.data.__schema) {\r\n            if (Array.isArray(introspectionResult.errors)) {\r\n                var combinedError = combineErrors(introspectionResult.errors);\r\n                throw combinedError;\r\n            }\r\n            else {\r\n                throw new Error('Could not obtain introspection result, received: ' +\r\n                    JSON.stringify(introspectionResult));\r\n            }\r\n        }\r\n        else {\r\n            var schema = buildClientSchema(introspectionResult.data);\r\n            return schema;\r\n        }\r\n    });\r\n}\n\n/**\r\n * Resolver that knows how to:\r\n * a) handle aliases for proxied schemas\r\n * b) handle errors from proxied schemas\r\n * c) handle external to internal enum coversion\r\n */\r\nfunction defaultMergedResolver(parent, args, context, info) {\r\n    if (!parent) {\r\n        return null;\r\n    }\r\n    var responseKey = getResponseKeyFromInfo(info);\r\n    var errors = getErrors(parent, responseKey);\r\n    // check to see if parent is not a proxied result, i.e. if parent resolver was manually overwritten\r\n    // See https://github.com/apollographql/graphql-tools/issues/967\r\n    if (!errors) {\r\n        return defaultFieldResolver(parent, args, context, info);\r\n    }\r\n    var result = parent[responseKey];\r\n    var subschema = getSubschema(parent, responseKey);\r\n    return handleResult(result, errors, subschema, context, info);\r\n}\n\nfunction makeMergedType(type) {\r\n    if (isObjectType(type)) {\r\n        type.isTypeOf = undefined;\r\n        var fieldMap_1 = type.getFields();\r\n        Object.keys(fieldMap_1).forEach(function (fieldName) {\r\n            fieldMap_1[fieldName].resolve = defaultMergedResolver;\r\n            fieldMap_1[fieldName].subscribe = null;\r\n        });\r\n    }\r\n    else if (isAbstractType(type)) {\r\n        type.resolveType = function (parent) { return resolveFromParentTypename(parent); };\r\n    }\r\n}\n\nfunction generateProxyingResolvers(_a) {\r\n    var subschemaConfig = _a.subschemaConfig, transforms = _a.transforms;\r\n    var targetSchema = subschemaConfig.schema;\r\n    var operationTypes = {\r\n        query: targetSchema.getQueryType(),\r\n        mutation: targetSchema.getMutationType(),\r\n        subscription: targetSchema.getSubscriptionType(),\r\n    };\r\n    var createProxyingResolver = subschemaConfig.createProxyingResolver != null\r\n        ? subschemaConfig.createProxyingResolver\r\n        : defaultCreateProxyingResolver;\r\n    var resolvers = {};\r\n    Object.keys(operationTypes).forEach(function (operation) {\r\n        var resolveField = operation === 'subscription' ? 'subscribe' : 'resolve';\r\n        var rootType = operationTypes[operation];\r\n        if (rootType != null) {\r\n            var typeName_1 = rootType.name;\r\n            var fields = rootType.getFields();\r\n            resolvers[typeName_1] = {};\r\n            Object.keys(fields).forEach(function (fieldName) {\r\n                var _a;\r\n                var proxyingResolver = createProxyingResolver(subschemaConfig, transforms, operation, fieldName);\r\n                var finalResolver = createPossiblyNestedProxyingResolver(subschemaConfig, proxyingResolver);\r\n                resolvers[typeName_1][fieldName] = (_a = {},\r\n                    _a[resolveField] = finalResolver,\r\n                    _a);\r\n            });\r\n        }\r\n    });\r\n    return resolvers;\r\n}\r\nfunction createPossiblyNestedProxyingResolver(subschemaConfig, proxyingResolver) {\r\n    return function (parent, args, context, info) {\r\n        if (parent != null) {\r\n            var responseKey = getResponseKeyFromInfo(info);\r\n            var errors = getErrors(parent, responseKey);\r\n            // Check to see if the parent contains a proxied result\r\n            if (errors != null) {\r\n                var subschema = getSubschema(parent, responseKey);\r\n                // If there is a proxied result from this subschema, return it\r\n                // This can happen even for a root field when the root type ia\r\n                // also nested as a field within a different type.\r\n                if (subschemaConfig === subschema) {\r\n                    return handleResult(parent[responseKey], errors, subschema, context, info);\r\n                }\r\n            }\r\n        }\r\n        return proxyingResolver(parent, args, context, info);\r\n    };\r\n}\r\nfunction defaultCreateProxyingResolver(schema, transforms) {\r\n    return function (_parent, _args, context, info) {\r\n        return delegateToSchema({\r\n            schema: schema,\r\n            context: context,\r\n            info: info,\r\n            transforms: transforms,\r\n        });\r\n    };\r\n}\r\nfunction stripResolvers(schema) {\r\n    var typeMap = schema.getTypeMap();\r\n    Object.keys(typeMap).forEach(function (typeName) {\r\n        if (!typeName.startsWith('__')) {\r\n            makeMergedType(typeMap[typeName]);\r\n        }\r\n    });\r\n}\n\nfunction wrapSchema(subschemaOrSubschemaConfig, transforms) {\r\n    var subschemaConfig = isSubschemaConfig(subschemaOrSubschemaConfig)\r\n        ? subschemaOrSubschemaConfig\r\n        : { schema: subschemaOrSubschemaConfig };\r\n    var schema = cloneSchema(subschemaConfig.schema);\r\n    stripResolvers(schema);\r\n    var resolvers = generateProxyingResolvers({\r\n        subschemaConfig: subschemaConfig,\r\n        transforms: transforms,\r\n    });\r\n    addResolversToSchema({ schema: schema, resolvers: resolvers });\r\n    var schemaTransforms = [];\r\n    if (subschemaConfig.transforms != null) {\r\n        schemaTransforms = schemaTransforms.concat(subschemaConfig.transforms);\r\n    }\r\n    if (transforms != null) {\r\n        schemaTransforms = schemaTransforms.concat(transforms);\r\n    }\r\n    return applySchemaTransforms(schema, schemaTransforms);\r\n}\n\nvar backcompatOptions = { commentDescriptions: true };\r\nfunction typeFromAST(node) {\r\n    switch (node.kind) {\r\n        case Kind.OBJECT_TYPE_DEFINITION:\r\n            return makeObjectType(node);\r\n        case Kind.INTERFACE_TYPE_DEFINITION:\r\n            return makeInterfaceType(node);\r\n        case Kind.ENUM_TYPE_DEFINITION:\r\n            return makeEnumType(node);\r\n        case Kind.UNION_TYPE_DEFINITION:\r\n            return makeUnionType(node);\r\n        case Kind.SCALAR_TYPE_DEFINITION:\r\n            return makeScalarType(node);\r\n        case Kind.INPUT_OBJECT_TYPE_DEFINITION:\r\n            return makeInputObjectType(node);\r\n        case Kind.DIRECTIVE_DEFINITION:\r\n            return makeDirective(node);\r\n        default:\r\n            return null;\r\n    }\r\n}\r\nfunction makeObjectType(node) {\r\n    var config = {\r\n        name: node.name.value,\r\n        fields: function () { return makeFields(node.fields); },\r\n        interfaces: function () {\r\n            return node.interfaces.map(function (iface) {\r\n                return createNamedStub(iface.name.value, 'interface');\r\n            });\r\n        },\r\n        description: getDescription(node, backcompatOptions),\r\n    };\r\n    return new GraphQLObjectType(config);\r\n}\r\nfunction makeInterfaceType(node) {\r\n    var config = {\r\n        name: node.name.value,\r\n        fields: function () { return makeFields(node.fields); },\r\n        interfaces: graphqlVersion() >= 15\r\n            ? function () {\r\n                return node.interfaces.map(function (iface) {\r\n                    return createNamedStub(iface.name.value, 'interface');\r\n                });\r\n            }\r\n            : undefined,\r\n        description: getDescription(node, backcompatOptions),\r\n        resolveType: function (parent) { return resolveFromParentTypename(parent); },\r\n    };\r\n    return new GraphQLInterfaceType(config);\r\n}\r\nfunction makeEnumType(node) {\r\n    var values = keyValMap(node.values, function (value) { return value.name.value; }, function (value) { return ({\r\n        description: getDescription(value, backcompatOptions),\r\n    }); });\r\n    return new GraphQLEnumType({\r\n        name: node.name.value,\r\n        values: values,\r\n        description: getDescription(node, backcompatOptions),\r\n    });\r\n}\r\nfunction makeUnionType(node) {\r\n    return new GraphQLUnionType({\r\n        name: node.name.value,\r\n        types: function () {\r\n            return node.types.map(function (type) { return createNamedStub(type.name.value, 'object'); });\r\n        },\r\n        description: getDescription(node, backcompatOptions),\r\n        resolveType: function (parent) { return resolveFromParentTypename(parent); },\r\n    });\r\n}\r\nfunction makeScalarType(node) {\r\n    return new GraphQLScalarType({\r\n        name: node.name.value,\r\n        description: getDescription(node, backcompatOptions),\r\n        serialize: function () { return null; },\r\n        // Note: validation calls the parse functions to determine if a\r\n        // literal value is correct. Returning null would cause use of custom\r\n        // scalars to always fail validation. Returning false causes them to\r\n        // always pass validation.\r\n        parseValue: function () { return false; },\r\n        parseLiteral: function () { return false; },\r\n    });\r\n}\r\nfunction makeInputObjectType(node) {\r\n    return new GraphQLInputObjectType({\r\n        name: node.name.value,\r\n        fields: function () { return makeValues(node.fields); },\r\n        description: getDescription(node, backcompatOptions),\r\n    });\r\n}\r\nfunction makeFields(nodes) {\r\n    return keyValMap(nodes, function (node) { return node.name.value; }, function (node) {\r\n        var deprecatedDirective = node.directives.find(function (directive) { return directive.name.value === 'deprecated'; });\r\n        var deprecationReason;\r\n        if (deprecatedDirective != null) {\r\n            var deprecatedArgument = deprecatedDirective.arguments.find(function (arg) { return arg.name.value === 'reason'; });\r\n            deprecationReason = deprecatedArgument.value.value;\r\n        }\r\n        return {\r\n            type: createStub(node.type, 'output'),\r\n            args: makeValues(node.arguments),\r\n            description: getDescription(node, backcompatOptions),\r\n            deprecationReason: deprecationReason,\r\n        };\r\n    });\r\n}\r\nfunction makeValues(nodes) {\r\n    return keyValMap(nodes, function (node) { return node.name.value; }, function (node) {\r\n        var type = createStub(node.type, 'input');\r\n        return {\r\n            type: type,\r\n            defaultValue: node.defaultValue,\r\n            description: getDescription(node, backcompatOptions),\r\n        };\r\n    });\r\n}\r\nfunction makeDirective(node) {\r\n    var locations = [];\r\n    node.locations.forEach(function (location) {\r\n        if (location.value in DirectiveLocation) {\r\n            locations.push(location.value);\r\n        }\r\n    });\r\n    return new GraphQLDirective({\r\n        name: node.name.value,\r\n        description: node.description != null ? node.description.value : null,\r\n        args: makeValues(node.arguments),\r\n        locations: locations,\r\n    });\r\n}\r\n// graphql < v13 does not export getDescription\r\nfunction getDescription(node, options) {\r\n    if (node.description != null) {\r\n        return node.description.value;\r\n    }\r\n    if (options.commentDescriptions) {\r\n        var rawValue = getLeadingCommentBlock(node);\r\n        if (rawValue !== undefined) {\r\n            return dedentBlockStringValue(\"\\n\" + rawValue);\r\n        }\r\n    }\r\n}\r\nfunction getLeadingCommentBlock(node) {\r\n    var loc = node.loc;\r\n    if (!loc) {\r\n        return;\r\n    }\r\n    var comments = [];\r\n    var token = loc.startToken.prev;\r\n    while (token != null &&\r\n        token.kind === TokenKind.COMMENT &&\r\n        token.next != null &&\r\n        token.prev != null &&\r\n        token.line + 1 === token.next.line &&\r\n        token.line !== token.prev.line) {\r\n        var value = String(token.value);\r\n        comments.push(value);\r\n        token = token.prev;\r\n    }\r\n    return comments.length > 0 ? comments.reverse().join('\\n') : undefined;\r\n}\r\nfunction dedentBlockStringValue(rawString) {\r\n    // Expand a block string's raw value into independent lines.\r\n    var lines = rawString.split(/\\r\\n|[\\n\\r]/g);\r\n    // Remove common indentation from all lines but first.\r\n    var commonIndent = getBlockStringIndentation(lines);\r\n    if (commonIndent !== 0) {\r\n        for (var i = 1; i < lines.length; i++) {\r\n            lines[i] = lines[i].slice(commonIndent);\r\n        }\r\n    }\r\n    // Remove leading and trailing blank lines.\r\n    while (lines.length > 0 && isBlank(lines[0])) {\r\n        lines.shift();\r\n    }\r\n    while (lines.length > 0 && isBlank(lines[lines.length - 1])) {\r\n        lines.pop();\r\n    }\r\n    // Return a string of the lines joined with U+000A.\r\n    return lines.join('\\n');\r\n}\r\n/**\r\n * @internal\r\n */\r\nfunction getBlockStringIndentation(lines) {\r\n    var commonIndent = null;\r\n    for (var i = 1; i < lines.length; i++) {\r\n        var line = lines[i];\r\n        var indent = leadingWhitespace(line);\r\n        if (indent === line.length) {\r\n            continue; // skip empty lines\r\n        }\r\n        if (commonIndent === null || indent < commonIndent) {\r\n            commonIndent = indent;\r\n            if (commonIndent === 0) {\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    return commonIndent === null ? 0 : commonIndent;\r\n}\r\nfunction leadingWhitespace(str) {\r\n    var i = 0;\r\n    while (i < str.length && (str[i] === ' ' || str[i] === '\\t')) {\r\n        i++;\r\n    }\r\n    return i;\r\n}\r\nfunction isBlank(str) {\r\n    return leadingWhitespace(str) === str.length;\r\n}\n\nfunction concatInlineFragments(type, fragments) {\r\n    var fragmentSelections = fragments.reduce(function (selections, fragment) {\r\n        return selections.concat(fragment.selectionSet.selections);\r\n    }, []);\r\n    var deduplicatedFragmentSelection = deduplicateSelection(fragmentSelections);\r\n    return {\r\n        kind: Kind.INLINE_FRAGMENT,\r\n        typeCondition: {\r\n            kind: Kind.NAMED_TYPE,\r\n            name: {\r\n                kind: Kind.NAME,\r\n                value: type,\r\n            },\r\n        },\r\n        selectionSet: {\r\n            kind: Kind.SELECTION_SET,\r\n            selections: deduplicatedFragmentSelection,\r\n        },\r\n    };\r\n}\r\nfunction deduplicateSelection(nodes) {\r\n    var selectionMap = nodes.reduce(function (map, node) {\r\n        var _a, _b, _c;\r\n        switch (node.kind) {\r\n            case 'Field': {\r\n                if (node.alias != null) {\r\n                    if (node.alias.value in map) {\r\n                        return map;\r\n                    }\r\n                    return __assign(__assign({}, map), (_a = {}, _a[node.alias.value] = node, _a));\r\n                }\r\n                if (node.name.value in map) {\r\n                    return map;\r\n                }\r\n                return __assign(__assign({}, map), (_b = {}, _b[node.name.value] = node, _b));\r\n            }\r\n            case 'FragmentSpread': {\r\n                if (node.name.value in map) {\r\n                    return map;\r\n                }\r\n                return __assign(__assign({}, map), (_c = {}, _c[node.name.value] = node, _c));\r\n            }\r\n            case 'InlineFragment': {\r\n                if (map.__fragment != null) {\r\n                    var fragment = map.__fragment;\r\n                    return __assign(__assign({}, map), { __fragment: concatInlineFragments(fragment.typeCondition.name.value, [fragment, node]) });\r\n                }\r\n                return __assign(__assign({}, map), { __fragment: node });\r\n            }\r\n            default: {\r\n                return map;\r\n            }\r\n        }\r\n    }, Object.create(null));\r\n    var selection = Object.keys(selectionMap).reduce(function (selectionList, node) { return selectionList.concat(selectionMap[node]); }, []);\r\n    return selection;\r\n}\r\nfunction parseFragmentToInlineFragment(definitions) {\r\n    if (definitions.trim().startsWith('fragment')) {\r\n        var document_1 = parse(definitions);\r\n        for (var _i = 0, _a = document_1.definitions; _i < _a.length; _i++) {\r\n            var definition = _a[_i];\r\n            if (definition.kind === Kind.FRAGMENT_DEFINITION) {\r\n                return {\r\n                    kind: Kind.INLINE_FRAGMENT,\r\n                    typeCondition: definition.typeCondition,\r\n                    selectionSet: definition.selectionSet,\r\n                };\r\n            }\r\n        }\r\n    }\r\n    var query = parse(\"{\" + definitions + \"}\")\r\n        .definitions[0];\r\n    for (var _b = 0, _c = query.selectionSet.selections; _b < _c.length; _b++) {\r\n        var selection = _c[_b];\r\n        if (selection.kind === Kind.INLINE_FRAGMENT) {\r\n            return selection;\r\n        }\r\n    }\r\n    throw new Error('Could not parse fragment');\r\n}\n\nfunction parseSelectionSet(selectionSet) {\r\n    var query = parse(selectionSet).definitions[0];\r\n    return query.selectionSet;\r\n}\r\nfunction typeContainsSelectionSet(type, selectionSet) {\r\n    var fields = type.getFields();\r\n    for (var _i = 0, _a = selectionSet.selections; _i < _a.length; _i++) {\r\n        var selection = _a[_i];\r\n        if (selection.kind === Kind.FIELD) {\r\n            var field = fields[selection.name.value];\r\n            if (field == null) {\r\n                return false;\r\n            }\r\n            if (selection.selectionSet != null) {\r\n                return typeContainsSelectionSet(getNamedType(field.type), selection.selectionSet);\r\n            }\r\n        }\r\n        else if (selection.kind === Kind.INLINE_FRAGMENT) {\r\n            var containsSelectionSet = typeContainsSelectionSet(type, selection.selectionSet);\r\n            if (!containsSelectionSet) {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n    return true;\r\n}\n\nfunction createMergeInfo(allSchemas, typeCandidates, mergeTypes) {\r\n    return {\r\n        delegate: function (operation, fieldName, args, context, info, transforms) {\r\n            if (transforms === void 0) { transforms = []; }\r\n            var schema = guessSchemaByRootField(allSchemas, operation, fieldName);\r\n            var expandTransforms = new ExpandAbstractTypes(info.schema, schema);\r\n            var fragmentTransform = new AddReplacementFragments(schema, info.mergeInfo.replacementFragments);\r\n            return delegateToSchema({\r\n                schema: schema,\r\n                operation: operation,\r\n                fieldName: fieldName,\r\n                args: args,\r\n                context: context,\r\n                info: info,\r\n                transforms: __spreadArrays(transforms, [expandTransforms, fragmentTransform]),\r\n            });\r\n        },\r\n        delegateToSchema: function (options) {\r\n            return delegateToSchema(__assign(__assign({}, options), { transforms: options.transforms }));\r\n        },\r\n        fragments: [],\r\n        replacementSelectionSets: undefined,\r\n        replacementFragments: undefined,\r\n        mergedTypes: createMergedTypes(typeCandidates, mergeTypes),\r\n    };\r\n}\r\nfunction createMergedTypes(typeCandidates, mergeTypes) {\r\n    var mergedTypes = Object.create(null);\r\n    Object.keys(typeCandidates).forEach(function (typeName) {\r\n        if (isObjectType(typeCandidates[typeName][0].type)) {\r\n            var mergedTypeCandidates = typeCandidates[typeName].filter(function (typeCandidate) {\r\n                return typeCandidate.subschema != null &&\r\n                    isSubschemaConfig(typeCandidate.subschema) &&\r\n                    typeCandidate.subschema.merge != null &&\r\n                    hasOwnProperty(typeCandidate.subschema.merge, typeName);\r\n            });\r\n            if (mergeTypes === true ||\r\n                (typeof mergeTypes === 'function' &&\r\n                    mergeTypes(typeName, typeCandidates[typeName])) ||\r\n                (Array.isArray(mergeTypes) && mergeTypes.includes(typeName)) ||\r\n                mergedTypeCandidates.length) {\r\n                var subschemas_1 = [];\r\n                var requiredSelections_1 = [\r\n                    parseSelectionSet('{ __typename }').selections[0],\r\n                ];\r\n                var fields_1 = Object.create({});\r\n                var typeMaps_1 = new Map();\r\n                var selectionSets_1 = new Map();\r\n                mergedTypeCandidates.forEach(function (typeCandidate) {\r\n                    var subschemaConfig = typeCandidate.subschema;\r\n                    var transformedSubschema = typeCandidate.transformedSubschema;\r\n                    typeMaps_1.set(subschemaConfig, transformedSubschema.getTypeMap());\r\n                    var type = transformedSubschema.getType(typeName);\r\n                    var fieldMap = type.getFields();\r\n                    Object.keys(fieldMap).forEach(function (fieldName) {\r\n                        if (!(fieldName in fields_1)) {\r\n                            fields_1[fieldName] = [];\r\n                        }\r\n                        fields_1[fieldName].push(subschemaConfig);\r\n                    });\r\n                    var mergedTypeConfig = subschemaConfig.merge[typeName];\r\n                    if (mergedTypeConfig.selectionSet) {\r\n                        var selectionSet = parseSelectionSet(mergedTypeConfig.selectionSet);\r\n                        requiredSelections_1 = requiredSelections_1.concat(selectionSet.selections);\r\n                        selectionSets_1.set(subschemaConfig, selectionSet);\r\n                    }\r\n                    if (!mergedTypeConfig.resolve) {\r\n                        mergedTypeConfig.resolve = function (originalResult, context, info, subschema, selectionSet) {\r\n                            return delegateToSchema({\r\n                                schema: subschema,\r\n                                operation: 'query',\r\n                                fieldName: mergedTypeConfig.fieldName,\r\n                                args: mergedTypeConfig.args(originalResult),\r\n                                selectionSet: selectionSet,\r\n                                context: context,\r\n                                info: info,\r\n                                skipTypeMerging: true,\r\n                            });\r\n                        };\r\n                    }\r\n                    subschemas_1.push(subschemaConfig);\r\n                });\r\n                mergedTypes[typeName] = {\r\n                    subschemas: subschemas_1,\r\n                    typeMaps: typeMaps_1,\r\n                    selectionSets: selectionSets_1,\r\n                    containsSelectionSet: new Map(),\r\n                    uniqueFields: Object.create({}),\r\n                    nonUniqueFields: Object.create({}),\r\n                };\r\n                subschemas_1.forEach(function (subschema) {\r\n                    var type = typeMaps_1.get(subschema)[typeName];\r\n                    var subschemaMap = new Map();\r\n                    subschemas_1\r\n                        .filter(function (s) { return s !== subschema; })\r\n                        .forEach(function (s) {\r\n                        var selectionSet = selectionSets_1.get(s);\r\n                        if (selectionSet != null &&\r\n                            typeContainsSelectionSet(type, selectionSet)) {\r\n                            subschemaMap.set(selectionSet, true);\r\n                        }\r\n                    });\r\n                    mergedTypes[typeName].containsSelectionSet.set(subschema, subschemaMap);\r\n                });\r\n                Object.keys(fields_1).forEach(function (fieldName) {\r\n                    var supportedBySubschemas = fields_1[fieldName];\r\n                    if (supportedBySubschemas.length === 1) {\r\n                        mergedTypes[typeName].uniqueFields[fieldName] =\r\n                            supportedBySubschemas[0];\r\n                    }\r\n                    else {\r\n                        mergedTypes[typeName].nonUniqueFields[fieldName] = supportedBySubschemas;\r\n                    }\r\n                });\r\n                mergedTypes[typeName].selectionSet = {\r\n                    kind: Kind.SELECTION_SET,\r\n                    selections: requiredSelections_1,\r\n                };\r\n            }\r\n        }\r\n    });\r\n    return mergedTypes;\r\n}\r\nfunction completeMergeInfo(mergeInfo, resolvers) {\r\n    var replacementSelectionSets = Object.create(null);\r\n    Object.keys(resolvers).forEach(function (typeName) {\r\n        var type = resolvers[typeName];\r\n        if (isScalarType(type)) {\r\n            return;\r\n        }\r\n        Object.keys(type).forEach(function (fieldName) {\r\n            var field = type[fieldName];\r\n            if (field.selectionSet) {\r\n                var selectionSet = parseSelectionSet(field.selectionSet);\r\n                if (!(typeName in replacementSelectionSets)) {\r\n                    replacementSelectionSets[typeName] = Object.create(null);\r\n                }\r\n                var typeReplacementSelectionSets = replacementSelectionSets[typeName];\r\n                if (!(fieldName in typeReplacementSelectionSets)) {\r\n                    typeReplacementSelectionSets[fieldName] = {\r\n                        kind: Kind.SELECTION_SET,\r\n                        selections: [],\r\n                    };\r\n                }\r\n                typeReplacementSelectionSets[fieldName].selections = typeReplacementSelectionSets[fieldName].selections.concat(selectionSet.selections);\r\n            }\r\n            if (field.fragment) {\r\n                mergeInfo.fragments.push({\r\n                    field: fieldName,\r\n                    fragment: field.fragment,\r\n                });\r\n            }\r\n        });\r\n    });\r\n    var mapping = Object.create(null);\r\n    mergeInfo.fragments.forEach(function (_a) {\r\n        var field = _a.field, fragment = _a.fragment;\r\n        var parsedFragment = parseFragmentToInlineFragment(fragment);\r\n        var actualTypeName = parsedFragment.typeCondition.name.value;\r\n        if (!(actualTypeName in mapping)) {\r\n            mapping[actualTypeName] = Object.create(null);\r\n        }\r\n        var typeMapping = mapping[actualTypeName];\r\n        if (!(field in typeMapping)) {\r\n            typeMapping[field] = [];\r\n        }\r\n        typeMapping[field].push(parsedFragment);\r\n    });\r\n    var replacementFragments = Object.create(null);\r\n    Object.keys(mapping).forEach(function (typeName) {\r\n        Object.keys(mapping[typeName]).forEach(function (field) {\r\n            if (!(typeName in replacementFragments)) {\r\n                replacementFragments[typeName] = Object.create(null);\r\n            }\r\n            var typeReplacementFragments = replacementFragments[typeName];\r\n            typeReplacementFragments[field] = concatInlineFragments(typeName, mapping[typeName][field]);\r\n        });\r\n    });\r\n    mergeInfo.replacementSelectionSets = replacementSelectionSets;\r\n    mergeInfo.replacementFragments = replacementFragments;\r\n    return mergeInfo;\r\n}\r\nfunction operationToRootType(operation, schema) {\r\n    if (operation === 'subscription') {\r\n        return schema.getSubscriptionType();\r\n    }\r\n    else if (operation === 'mutation') {\r\n        return schema.getMutationType();\r\n    }\r\n    return schema.getQueryType();\r\n}\r\nfunction guessSchemaByRootField(schemas, operation, fieldName) {\r\n    for (var _i = 0, schemas_1 = schemas; _i < schemas_1.length; _i++) {\r\n        var schema = schemas_1[_i];\r\n        var rootObject = operationToRootType(operation, schema);\r\n        if (rootObject != null) {\r\n            var fields = rootObject.getFields();\r\n            if (fieldName in fields) {\r\n                return schema;\r\n            }\r\n        }\r\n    }\r\n    throw new Error(\"Could not find subschema with field `\" + operation + \".\" + fieldName + \"`\");\r\n}\n\nfunction mergeSchemas(_a) {\r\n    var _b = _a.subschemas, subschemas = _b === void 0 ? [] : _b, _c = _a.types, types = _c === void 0 ? [] : _c, typeDefs = _a.typeDefs, _d = _a.schemas, schemaLikeObjects = _d === void 0 ? [] : _d, onTypeConflict = _a.onTypeConflict, _e = _a.resolvers, resolvers = _e === void 0 ? {} : _e, schemaDirectives = _a.schemaDirectives, inheritResolversFromInterfaces = _a.inheritResolversFromInterfaces, _f = _a.mergeTypes, mergeTypes = _f === void 0 ? false : _f, mergeDirectives = _a.mergeDirectives, _g = _a.queryTypeName, queryTypeName = _g === void 0 ? 'Query' : _g, _h = _a.mutationTypeName, mutationTypeName = _h === void 0 ? 'Mutation' : _h, _j = _a.subscriptionTypeName, subscriptionTypeName = _j === void 0 ? 'Subscription' : _j;\r\n    var allSchemas = [];\r\n    var typeCandidates = Object.create(null);\r\n    var typeMap = Object.create(null);\r\n    var extensions = [];\r\n    var directives = [];\r\n    var schemas = __spreadArrays(subschemas);\r\n    if (typeDefs) {\r\n        schemas.push(typeDefs);\r\n    }\r\n    if (types != null) {\r\n        schemas.push(types);\r\n    }\r\n    schemas = __spreadArrays(schemas, schemaLikeObjects);\r\n    schemas.forEach(function (schemaLikeObject) {\r\n        var _a;\r\n        if (isSchema(schemaLikeObject) || isSubschemaConfig(schemaLikeObject)) {\r\n            var schema_1 = wrapSchema(schemaLikeObject);\r\n            allSchemas.push(schema_1);\r\n            var operationTypes_1 = (_a = {},\r\n                _a[queryTypeName] = schema_1.getQueryType(),\r\n                _a[mutationTypeName] = schema_1.getMutationType(),\r\n                _a[subscriptionTypeName] = schema_1.getSubscriptionType(),\r\n                _a);\r\n            Object.keys(operationTypes_1).forEach(function (typeName) {\r\n                if (operationTypes_1[typeName] != null) {\r\n                    addTypeCandidate(typeCandidates, typeName, {\r\n                        schema: schema_1,\r\n                        type: operationTypes_1[typeName],\r\n                        subschema: schemaLikeObject,\r\n                        transformedSubschema: schema_1,\r\n                    });\r\n                }\r\n            });\r\n            if (mergeDirectives) {\r\n                var directiveInstances = schema_1.getDirectives();\r\n                directiveInstances.forEach(function (directive) {\r\n                    directives.push(directive);\r\n                });\r\n            }\r\n            var originalTypeMap_1 = schema_1.getTypeMap();\r\n            Object.keys(originalTypeMap_1).forEach(function (typeName) {\r\n                var type = originalTypeMap_1[typeName];\r\n                if (isNamedType(type) &&\r\n                    getNamedType(type).name.slice(0, 2) !== '__' &&\r\n                    type !== operationTypes_1.Query &&\r\n                    type !== operationTypes_1.Mutation &&\r\n                    type !== operationTypes_1.Subscription) {\r\n                    addTypeCandidate(typeCandidates, type.name, {\r\n                        schema: schema_1,\r\n                        type: type,\r\n                        subschema: schemaLikeObject,\r\n                        transformedSubschema: schema_1,\r\n                    });\r\n                }\r\n            });\r\n        }\r\n        else if (typeof schemaLikeObject === 'string' ||\r\n            (schemaLikeObject != null &&\r\n                schemaLikeObject.kind === Kind.DOCUMENT)) {\r\n            var parsedSchemaDocument = typeof schemaLikeObject === 'string'\r\n                ? parse(schemaLikeObject)\r\n                : schemaLikeObject;\r\n            parsedSchemaDocument.definitions.forEach(function (def) {\r\n                var type = typeFromAST(def);\r\n                if (isDirective(type) && mergeDirectives) {\r\n                    directives.push(type);\r\n                }\r\n                else if (type != null && !isDirective(type)) {\r\n                    addTypeCandidate(typeCandidates, type.name, {\r\n                        type: type,\r\n                    });\r\n                }\r\n            });\r\n            var extensionsDocument = extractExtensionDefinitions(parsedSchemaDocument);\r\n            if (extensionsDocument.definitions.length > 0) {\r\n                extensions.push(extensionsDocument);\r\n            }\r\n        }\r\n        else if (Array.isArray(schemaLikeObject)) {\r\n            schemaLikeObject.forEach(function (type) {\r\n                addTypeCandidate(typeCandidates, type.name, {\r\n                    type: type,\r\n                });\r\n            });\r\n        }\r\n        else {\r\n            throw new Error('Invalid schema passed');\r\n        }\r\n    });\r\n    var mergeInfo = createMergeInfo(allSchemas, typeCandidates, mergeTypes);\r\n    var finalResolvers;\r\n    if (typeof resolvers === 'function') {\r\n        finalResolvers = resolvers(mergeInfo);\r\n    }\r\n    else if (Array.isArray(resolvers)) {\r\n        finalResolvers = resolvers.reduce(function (left, right) {\r\n            return mergeDeep(left, typeof right === 'function' ? right(mergeInfo) : right);\r\n        }, {});\r\n        if (Array.isArray(resolvers)) {\r\n            finalResolvers = resolvers.reduce(mergeDeep, {});\r\n        }\r\n    }\r\n    else {\r\n        finalResolvers = resolvers;\r\n    }\r\n    if (finalResolvers == null) {\r\n        finalResolvers = {};\r\n    }\r\n    mergeInfo = completeMergeInfo(mergeInfo, finalResolvers);\r\n    Object.keys(typeCandidates).forEach(function (typeName) {\r\n        if (typeName === queryTypeName ||\r\n            typeName === mutationTypeName ||\r\n            typeName === subscriptionTypeName ||\r\n            (mergeTypes === true &&\r\n                !isScalarType(typeCandidates[typeName][0].type)) ||\r\n            (typeof mergeTypes === 'function' &&\r\n                mergeTypes(typeName, typeCandidates[typeName])) ||\r\n            (Array.isArray(mergeTypes) && mergeTypes.includes(typeName)) ||\r\n            typeName in mergeInfo.mergedTypes) {\r\n            typeMap[typeName] = merge(typeName, typeCandidates[typeName]);\r\n        }\r\n        else {\r\n            var candidateSelector = onTypeConflict != null\r\n                ? onTypeConflictToCandidateSelector(onTypeConflict)\r\n                : function (cands) { return cands[cands.length - 1]; };\r\n            typeMap[typeName] = candidateSelector(typeCandidates[typeName]).type;\r\n        }\r\n    });\r\n    healTypes(typeMap, directives, { skipPruning: true });\r\n    var mergedSchema = new GraphQLSchema({\r\n        query: typeMap[queryTypeName],\r\n        mutation: typeMap[mutationTypeName],\r\n        subscription: typeMap[subscriptionTypeName],\r\n        types: Object.keys(typeMap).map(function (key) { return typeMap[key]; }),\r\n        directives: directives.length\r\n            ? directives.map(function (directive) { return cloneDirective(directive); })\r\n            : undefined,\r\n    });\r\n    extensions.forEach(function (extension) {\r\n        mergedSchema = extendSchema(mergedSchema, extension, {\r\n            commentDescriptions: true,\r\n        });\r\n    });\r\n    addResolversToSchema({\r\n        schema: mergedSchema,\r\n        resolvers: finalResolvers,\r\n        inheritResolversFromInterfaces: inheritResolversFromInterfaces,\r\n    });\r\n    forEachField(mergedSchema, function (field) {\r\n        if (field.resolve != null) {\r\n            var fieldResolver_1 = field.resolve;\r\n            field.resolve = function (parent, args, context, info) {\r\n                var newInfo = __assign(__assign({}, info), { mergeInfo: mergeInfo });\r\n                return fieldResolver_1(parent, args, context, newInfo);\r\n            };\r\n        }\r\n        if (field.subscribe != null) {\r\n            var fieldResolver_2 = field.subscribe;\r\n            field.subscribe = function (parent, args, context, info) {\r\n                var newInfo = __assign(__assign({}, info), { mergeInfo: mergeInfo });\r\n                return fieldResolver_2(parent, args, context, newInfo);\r\n            };\r\n        }\r\n    });\r\n    if (schemaDirectives != null) {\r\n        SchemaDirectiveVisitor.visitSchemaDirectives(mergedSchema, schemaDirectives);\r\n    }\r\n    return mergedSchema;\r\n}\r\nfunction addTypeCandidate(typeCandidates, name, typeCandidate) {\r\n    if (!(name in typeCandidates)) {\r\n        typeCandidates[name] = [];\r\n    }\r\n    typeCandidates[name].push(typeCandidate);\r\n}\r\nfunction onTypeConflictToCandidateSelector(onTypeConflict) {\r\n    return function (cands) {\r\n        return cands.reduce(function (prev, next) {\r\n            var type = onTypeConflict(prev.type, next.type, {\r\n                left: {\r\n                    schema: prev.schema,\r\n                },\r\n                right: {\r\n                    schema: next.schema,\r\n                },\r\n            });\r\n            if (prev.type === type) {\r\n                return prev;\r\n            }\r\n            else if (next.type === type) {\r\n                return next;\r\n            }\r\n            return {\r\n                schemaName: 'unknown',\r\n                type: type,\r\n            };\r\n        });\r\n    };\r\n}\r\nfunction merge(typeName, candidates) {\r\n    var initialCandidateType = candidates[0].type;\r\n    if (candidates.some(function (candidate) {\r\n        return candidate.type.constructor !== initialCandidateType.constructor;\r\n    })) {\r\n        throw new Error(\"Cannot merge different type categories into common type \" + typeName + \".\");\r\n    }\r\n    if (isObjectType(initialCandidateType)) {\r\n        return new GraphQLObjectType({\r\n            name: typeName,\r\n            fields: candidates.reduce(function (acc, candidate) { return (__assign(__assign({}, acc), toConfig(candidate.type).fields)); }, {}),\r\n            interfaces: candidates.reduce(function (acc, candidate) {\r\n                var interfaces = toConfig(candidate.type).interfaces;\r\n                return interfaces != null ? acc.concat(interfaces) : acc;\r\n            }, []),\r\n        });\r\n    }\r\n    else if (isInterfaceType(initialCandidateType)) {\r\n        var config = {\r\n            name: typeName,\r\n            fields: candidates.reduce(function (acc, candidate) { return (__assign(__assign({}, acc), toConfig(candidate.type).fields)); }, {}),\r\n            interfaces: graphqlVersion() >= 15\r\n                ? candidates.reduce(function (acc, candidate) {\r\n                    var interfaces = toConfig(candidate.type).interfaces;\r\n                    return interfaces != null ? acc.concat(interfaces) : acc;\r\n                }, [])\r\n                : undefined,\r\n        };\r\n        return new GraphQLInterfaceType(config);\r\n    }\r\n    else if (isUnionType(initialCandidateType)) {\r\n        return new GraphQLUnionType({\r\n            name: typeName,\r\n            types: candidates.reduce(function (acc, candidate) { return acc.concat(toConfig(candidate.type).types); }, []),\r\n        });\r\n    }\r\n    else if (isEnumType(initialCandidateType)) {\r\n        return new GraphQLEnumType({\r\n            name: typeName,\r\n            values: candidates.reduce(function (acc, candidate) { return (__assign(__assign({}, acc), toConfig(candidate.type).values)); }, {}),\r\n        });\r\n    }\r\n    else if (isScalarType(initialCandidateType)) {\r\n        throw new Error(\"Cannot merge type \" + typeName + \". Merging not supported for GraphQLScalarType.\");\r\n    }\r\n    else {\r\n        // not reachable.\r\n        throw new Error(\"Type \" + typeName + \" has unknown GraphQL type.\");\r\n    }\r\n}\n\n// This function is deprecated in favor of wrapSchema as the name is misleading.\r\n// transformSchema does not just \"transform\" a schema, it wraps a schema with transforms\r\n// using a round of delegation.\r\n// The applySchemaTransforms function actually \"transforms\" the schema and is used during wrapping.\r\nfunction transformSchema(subschemaOrSubschemaConfig, transforms) {\r\n    var schema = wrapSchema(subschemaOrSubschemaConfig, transforms);\r\n    schema.transforms = transforms.slice().reverse();\r\n    return schema;\r\n}\n\nvar RenameTypes = /** @class */ (function () {\r\n    function RenameTypes(renamer, options) {\r\n        this.renamer = renamer;\r\n        this.map = Object.create(null);\r\n        this.reverseMap = Object.create(null);\r\n        var _a = options != null ? options : {}, _b = _a.renameBuiltins, renameBuiltins = _b === void 0 ? false : _b, _c = _a.renameScalars, renameScalars = _c === void 0 ? true : _c;\r\n        this.renameBuiltins = renameBuiltins;\r\n        this.renameScalars = renameScalars;\r\n    }\r\n    RenameTypes.prototype.transformSchema = function (originalSchema) {\r\n        var _a;\r\n        var _this = this;\r\n        return mapSchema(originalSchema, (_a = {},\r\n            _a[MapperKind.TYPE] = function (type) {\r\n                if (isSpecifiedScalarType(type) && !_this.renameBuiltins) {\r\n                    return undefined;\r\n                }\r\n                if (isScalarType(type) && !_this.renameScalars) {\r\n                    return undefined;\r\n                }\r\n                var oldName = type.name;\r\n                var newName = _this.renamer(oldName);\r\n                if (newName !== undefined && newName !== oldName) {\r\n                    _this.map[oldName] = newName;\r\n                    _this.reverseMap[newName] = oldName;\r\n                    var newConfig = __assign(__assign({}, toConfig(type)), { name: newName });\r\n                    if (isObjectType(type)) {\r\n                        return new GraphQLObjectType(newConfig);\r\n                    }\r\n                    else if (isInterfaceType(type)) {\r\n                        return new GraphQLInterfaceType(newConfig);\r\n                    }\r\n                    else if (isUnionType(type)) {\r\n                        return new GraphQLUnionType(newConfig);\r\n                    }\r\n                    else if (isInputObjectType(type)) {\r\n                        return new GraphQLInputObjectType(newConfig);\r\n                    }\r\n                    else if (isEnumType(type)) {\r\n                        return new GraphQLEnumType(newConfig);\r\n                    }\r\n                    else if (isScalarType(type)) {\r\n                        return new GraphQLScalarType(newConfig);\r\n                    }\r\n                    throw new Error(\"Unknown type \" + type + \".\");\r\n                }\r\n            },\r\n            _a[MapperKind.ROOT_OBJECT] = function () {\r\n                return undefined;\r\n            },\r\n            _a));\r\n    };\r\n    RenameTypes.prototype.transformRequest = function (originalRequest) {\r\n        var _a;\r\n        var _this = this;\r\n        var newDocument = visit(originalRequest.document, (_a = {},\r\n            _a[Kind.NAMED_TYPE] = function (node) {\r\n                var name = node.name.value;\r\n                if (name in _this.reverseMap) {\r\n                    return __assign(__assign({}, node), { name: {\r\n                            kind: Kind.NAME,\r\n                            value: _this.reverseMap[name],\r\n                        } });\r\n                }\r\n            },\r\n            _a));\r\n        return {\r\n            document: newDocument,\r\n            variables: originalRequest.variables,\r\n        };\r\n    };\r\n    RenameTypes.prototype.transformResult = function (result) {\r\n        return __assign(__assign({}, result), { data: this.transformData(result.data) });\r\n    };\r\n    RenameTypes.prototype.transformData = function (data) {\r\n        var _this = this;\r\n        if (data == null) {\r\n            return data;\r\n        }\r\n        else if (Array.isArray(data)) {\r\n            return data.map(function (value) { return _this.transformData(value); });\r\n        }\r\n        else if (typeof data === 'object') {\r\n            return this.transformObject(data);\r\n        }\r\n        return data;\r\n    };\r\n    RenameTypes.prototype.transformObject = function (object) {\r\n        var _this = this;\r\n        Object.keys(object).forEach(function (key) {\r\n            var value = object[key];\r\n            if (key === '__typename') {\r\n                if (value in _this.map) {\r\n                    object[key] = _this.map[value];\r\n                }\r\n            }\r\n            else {\r\n                object[key] = _this.transformData(value);\r\n            }\r\n        });\r\n        return object;\r\n    };\r\n    return RenameTypes;\r\n}());\n\nvar FilterTypes = /** @class */ (function () {\r\n    function FilterTypes(filter) {\r\n        this.filter = filter;\r\n    }\r\n    FilterTypes.prototype.transformSchema = function (schema) {\r\n        var _a;\r\n        var _this = this;\r\n        return mapSchema(schema, (_a = {},\r\n            _a[MapperKind.TYPE] = function (type) {\r\n                if (_this.filter(type)) {\r\n                    return undefined;\r\n                }\r\n                return null;\r\n            },\r\n            _a));\r\n    };\r\n    return FilterTypes;\r\n}());\n\nvar RenameRootTypes = /** @class */ (function () {\r\n    function RenameRootTypes(renamer) {\r\n        this.renamer = renamer;\r\n        this.map = Object.create(null);\r\n        this.reverseMap = Object.create(null);\r\n    }\r\n    RenameRootTypes.prototype.transformSchema = function (originalSchema) {\r\n        var _a;\r\n        var _this = this;\r\n        return mapSchema(originalSchema, (_a = {},\r\n            _a[MapperKind.ROOT_OBJECT] = function (type) {\r\n                var oldName = type.name;\r\n                var newName = _this.renamer(oldName);\r\n                if (newName !== undefined && newName !== oldName) {\r\n                    _this.map[oldName] = newName;\r\n                    _this.reverseMap[newName] = oldName;\r\n                    return new GraphQLObjectType(__assign(__assign({}, toConfig(type)), { name: newName }));\r\n                }\r\n            },\r\n            _a));\r\n    };\r\n    RenameRootTypes.prototype.transformRequest = function (originalRequest) {\r\n        var _a;\r\n        var _this = this;\r\n        var newDocument = visit(originalRequest.document, (_a = {},\r\n            _a[Kind.NAMED_TYPE] = function (node) {\r\n                var name = node.name.value;\r\n                if (name in _this.reverseMap) {\r\n                    return __assign(__assign({}, node), { name: {\r\n                            kind: Kind.NAME,\r\n                            value: _this.reverseMap[name],\r\n                        } });\r\n                }\r\n            },\r\n            _a));\r\n        return {\r\n            document: newDocument,\r\n            variables: originalRequest.variables,\r\n        };\r\n    };\r\n    RenameRootTypes.prototype.transformResult = function (result) {\r\n        return __assign(__assign({}, result), { data: this.transformData(result.data) });\r\n    };\r\n    RenameRootTypes.prototype.transformData = function (data) {\r\n        var _this = this;\r\n        if (data == null) {\r\n            return data;\r\n        }\r\n        else if (Array.isArray(data)) {\r\n            return data.map(function (value) { return _this.transformData(value); });\r\n        }\r\n        else if (typeof data === 'object') {\r\n            return this.transformObject(data);\r\n        }\r\n        return data;\r\n    };\r\n    RenameRootTypes.prototype.transformObject = function (object) {\r\n        var _this = this;\r\n        Object.keys(object).forEach(function (key) {\r\n            var value = object[key];\r\n            if (key === '__typename') {\r\n                if (value in _this.map) {\r\n                    object[key] = _this.map[value];\r\n                }\r\n            }\r\n            else {\r\n                object[key] = _this.transformData(value);\r\n            }\r\n        });\r\n        return object;\r\n    };\r\n    return RenameRootTypes;\r\n}());\n\nfunction isEmptyObject(obj) {\r\n    if (obj == null) {\r\n        return true;\r\n    }\r\n    return Object.keys(obj).length === 0;\r\n}\n\nvar TransformCompositeFields = /** @class */ (function () {\r\n    function TransformCompositeFields(fieldTransformer, fieldNodeTransformer) {\r\n        this.fieldTransformer = fieldTransformer;\r\n        this.fieldNodeTransformer = fieldNodeTransformer;\r\n        this.mapping = {};\r\n    }\r\n    TransformCompositeFields.prototype.transformSchema = function (originalSchema) {\r\n        var _a;\r\n        var _this = this;\r\n        this.transformedSchema = mapSchema(originalSchema, (_a = {},\r\n            _a[MapperKind.OBJECT_TYPE] = function (type) {\r\n                return _this.transformFields(type, _this.fieldTransformer);\r\n            },\r\n            _a[MapperKind.INTERFACE_TYPE] = function (type) {\r\n                return _this.transformFields(type, _this.fieldTransformer);\r\n            },\r\n            _a));\r\n        return this.transformedSchema;\r\n    };\r\n    TransformCompositeFields.prototype.transformRequest = function (originalRequest) {\r\n        var fragments = Object.create(null);\r\n        originalRequest.document.definitions\r\n            .filter(function (def) { return def.kind === Kind.FRAGMENT_DEFINITION; })\r\n            .forEach(function (def) {\r\n            fragments[def.name.value] = def;\r\n        });\r\n        var document = this.transformDocument(originalRequest.document, this.mapping, this.fieldNodeTransformer, fragments);\r\n        return __assign(__assign({}, originalRequest), { document: document });\r\n    };\r\n    TransformCompositeFields.prototype.transformFields = function (type, fieldTransformer) {\r\n        var _this = this;\r\n        var typeConfig = toConfig(type);\r\n        var fields = type.getFields();\r\n        var newFields = {};\r\n        Object.keys(fields).forEach(function (fieldName) {\r\n            var field = fields[fieldName];\r\n            var transformedField = fieldTransformer(type.name, fieldName, field);\r\n            if (typeof transformedField === 'undefined') {\r\n                newFields[fieldName] = typeConfig.fields[fieldName];\r\n            }\r\n            else if (transformedField !== null) {\r\n                var newName = transformedField.name;\r\n                if (newName) {\r\n                    newFields[newName] =\r\n                        transformedField.field != null\r\n                            ? transformedField.field\r\n                            : typeConfig.fields[fieldName];\r\n                    if (newName !== fieldName) {\r\n                        var typeName = type.name;\r\n                        if (!(typeName in _this.mapping)) {\r\n                            _this.mapping[typeName] = {};\r\n                        }\r\n                        _this.mapping[typeName][newName] = fieldName;\r\n                    }\r\n                }\r\n                else {\r\n                    newFields[fieldName] = transformedField;\r\n                }\r\n            }\r\n        });\r\n        if (isEmptyObject(newFields)) {\r\n            return null;\r\n        }\r\n        if (isObjectType(type)) {\r\n            return new GraphQLObjectType(__assign(__assign({}, toConfig(type)), { fields: newFields }));\r\n        }\r\n        else if (isInterfaceType(type)) {\r\n            return new GraphQLInterfaceType(__assign(__assign({}, toConfig(type)), { fields: newFields }));\r\n        }\r\n    };\r\n    TransformCompositeFields.prototype.transformDocument = function (document, mapping, fieldNodeTransformer, fragments) {\r\n        var _a;\r\n        if (fragments === void 0) { fragments = {}; }\r\n        var typeInfo = new TypeInfo(this.transformedSchema);\r\n        var newDocument = visit(document, visitWithTypeInfo(typeInfo, {\r\n            leave: (_a = {},\r\n                _a[Kind.SELECTION_SET] = function (node) {\r\n                    var parentType = typeInfo.getParentType();\r\n                    if (parentType != null) {\r\n                        var parentTypeName_1 = parentType.name;\r\n                        var newSelections_1 = [];\r\n                        node.selections.forEach(function (selection) {\r\n                            if (selection.kind !== Kind.FIELD) {\r\n                                newSelections_1.push(selection);\r\n                                return;\r\n                            }\r\n                            var newName = selection.name.value;\r\n                            var transformedSelection = fieldNodeTransformer != null\r\n                                ? fieldNodeTransformer(parentTypeName_1, newName, selection, fragments)\r\n                                : selection;\r\n                            if (Array.isArray(transformedSelection)) {\r\n                                newSelections_1 = newSelections_1.concat(transformedSelection);\r\n                                return;\r\n                            }\r\n                            if (transformedSelection.kind !== Kind.FIELD) {\r\n                                newSelections_1.push(transformedSelection);\r\n                                return;\r\n                            }\r\n                            var typeMapping = mapping[parentTypeName_1];\r\n                            if (typeMapping == null) {\r\n                                newSelections_1.push(transformedSelection);\r\n                                return;\r\n                            }\r\n                            var oldName = mapping[parentTypeName_1][newName];\r\n                            if (oldName == null) {\r\n                                newSelections_1.push(transformedSelection);\r\n                                return;\r\n                            }\r\n                            newSelections_1.push(__assign(__assign({}, transformedSelection), { name: {\r\n                                    kind: Kind.NAME,\r\n                                    value: oldName,\r\n                                }, alias: {\r\n                                    kind: Kind.NAME,\r\n                                    value: newName,\r\n                                } }));\r\n                        });\r\n                        return __assign(__assign({}, node), { selections: newSelections_1 });\r\n                    }\r\n                },\r\n                _a),\r\n        }));\r\n        return newDocument;\r\n    };\r\n    return TransformCompositeFields;\r\n}());\n\nvar TransformObjectFields = /** @class */ (function () {\r\n    function TransformObjectFields(objectFieldTransformer, fieldNodeTransformer) {\r\n        this.objectFieldTransformer = objectFieldTransformer;\r\n        this.fieldNodeTransformer = fieldNodeTransformer;\r\n    }\r\n    TransformObjectFields.prototype.transformSchema = function (originalSchema) {\r\n        var _this = this;\r\n        var compositeToObjectFieldTransformer = function (typeName, fieldName, field) {\r\n            if (isObjectType(originalSchema.getType(typeName))) {\r\n                return _this.objectFieldTransformer(typeName, fieldName, field);\r\n            }\r\n            return undefined;\r\n        };\r\n        this.transformer = new TransformCompositeFields(compositeToObjectFieldTransformer, this.fieldNodeTransformer);\r\n        return this.transformer.transformSchema(originalSchema);\r\n    };\r\n    TransformObjectFields.prototype.transformRequest = function (originalRequest) {\r\n        return this.transformer.transformRequest(originalRequest);\r\n    };\r\n    return TransformObjectFields;\r\n}());\n\nvar TransformRootFields = /** @class */ (function () {\r\n    function TransformRootFields(rootFieldTransformer, fieldNodeTransformer) {\r\n        var rootToObjectFieldTransformer = function (typeName, fieldName, field) {\r\n            if (typeName === 'Query' ||\r\n                typeName === 'Mutation' ||\r\n                typeName === 'Subscription') {\r\n                return rootFieldTransformer(typeName, fieldName, field);\r\n            }\r\n            return undefined;\r\n        };\r\n        this.transformer = new TransformObjectFields(rootToObjectFieldTransformer, fieldNodeTransformer);\r\n    }\r\n    TransformRootFields.prototype.transformSchema = function (originalSchema) {\r\n        return this.transformer.transformSchema(originalSchema);\r\n    };\r\n    TransformRootFields.prototype.transformRequest = function (originalRequest) {\r\n        return this.transformer.transformRequest(originalRequest);\r\n    };\r\n    return TransformRootFields;\r\n}());\n\nvar RenameRootFields = /** @class */ (function () {\r\n    function RenameRootFields(renamer) {\r\n        this.transformer = new TransformRootFields(function (operation, fieldName, field) { return ({\r\n            name: renamer(operation, fieldName, field),\r\n        }); });\r\n    }\r\n    RenameRootFields.prototype.transformSchema = function (originalSchema) {\r\n        return this.transformer.transformSchema(originalSchema);\r\n    };\r\n    RenameRootFields.prototype.transformRequest = function (originalRequest) {\r\n        return this.transformer.transformRequest(originalRequest);\r\n    };\r\n    return RenameRootFields;\r\n}());\n\nvar FilterRootFields = /** @class */ (function () {\r\n    function FilterRootFields(filter) {\r\n        this.transformer = new TransformRootFields(function (operation, fieldName, field) {\r\n            if (filter(operation, fieldName, field)) {\r\n                return undefined;\r\n            }\r\n            return null;\r\n        });\r\n    }\r\n    FilterRootFields.prototype.transformSchema = function (originalSchema) {\r\n        return this.transformer.transformSchema(originalSchema);\r\n    };\r\n    return FilterRootFields;\r\n}());\n\nvar RenameObjectFields = /** @class */ (function () {\r\n    function RenameObjectFields(renamer) {\r\n        this.transformer = new TransformObjectFields(function (typeName, fieldName, field) { return ({\r\n            name: renamer(typeName, fieldName, field),\r\n        }); });\r\n    }\r\n    RenameObjectFields.prototype.transformSchema = function (originalSchema) {\r\n        return this.transformer.transformSchema(originalSchema);\r\n    };\r\n    RenameObjectFields.prototype.transformRequest = function (originalRequest) {\r\n        return this.transformer.transformRequest(originalRequest);\r\n    };\r\n    return RenameObjectFields;\r\n}());\n\nvar FilterObjectFields = /** @class */ (function () {\r\n    function FilterObjectFields(filter) {\r\n        this.transformer = new TransformObjectFields(function (typeName, fieldName, field) {\r\n            return filter(typeName, fieldName, field) ? undefined : null;\r\n        });\r\n    }\r\n    FilterObjectFields.prototype.transformSchema = function (originalSchema) {\r\n        return this.transformer.transformSchema(originalSchema);\r\n    };\r\n    return FilterObjectFields;\r\n}());\n\nvar TransformInterfaceFields = /** @class */ (function () {\r\n    function TransformInterfaceFields(interfaceFieldTransformer, fieldNodeTransformer) {\r\n        this.interfaceFieldTransformer = interfaceFieldTransformer;\r\n        this.fieldNodeTransformer = fieldNodeTransformer;\r\n    }\r\n    TransformInterfaceFields.prototype.transformSchema = function (originalSchema) {\r\n        var _this = this;\r\n        var compositeToObjectFieldTransformer = function (typeName, fieldName, field) {\r\n            if (isInterfaceType(originalSchema.getType(typeName))) {\r\n                return _this.interfaceFieldTransformer(typeName, fieldName, field);\r\n            }\r\n            return undefined;\r\n        };\r\n        this.transformer = new TransformCompositeFields(compositeToObjectFieldTransformer, this.fieldNodeTransformer);\r\n        return this.transformer.transformSchema(originalSchema);\r\n    };\r\n    TransformInterfaceFields.prototype.transformRequest = function (originalRequest) {\r\n        return this.transformer.transformRequest(originalRequest);\r\n    };\r\n    return TransformInterfaceFields;\r\n}());\n\nvar RenameInterfaceFields = /** @class */ (function () {\r\n    function RenameInterfaceFields(renamer) {\r\n        this.transformer = new TransformInterfaceFields(function (typeName, fieldName, field) { return ({\r\n            name: renamer(typeName, fieldName, field),\r\n        }); });\r\n    }\r\n    RenameInterfaceFields.prototype.transformSchema = function (originalSchema) {\r\n        return this.transformer.transformSchema(originalSchema);\r\n    };\r\n    RenameInterfaceFields.prototype.transformRequest = function (originalRequest) {\r\n        return this.transformer.transformRequest(originalRequest);\r\n    };\r\n    return RenameInterfaceFields;\r\n}());\n\nvar FilterInterfaceFields = /** @class */ (function () {\r\n    function FilterInterfaceFields(filter) {\r\n        this.transformer = new TransformInterfaceFields(function (typeName, fieldName, field) {\r\n            return filter(typeName, fieldName, field) ? undefined : null;\r\n        });\r\n    }\r\n    FilterInterfaceFields.prototype.transformSchema = function (originalSchema) {\r\n        return this.transformer.transformSchema(originalSchema);\r\n    };\r\n    return FilterInterfaceFields;\r\n}());\n\nvar TransformQuery = /** @class */ (function () {\r\n    function TransformQuery(_a) {\r\n        var path = _a.path, queryTransformer = _a.queryTransformer, _b = _a.resultTransformer, resultTransformer = _b === void 0 ? function (result) { return result; } : _b, _c = _a.errorPathTransformer, errorPathTransformer = _c === void 0 ? function (errorPath) { return [].concat(errorPath); } : _c, _d = _a.fragments, fragments = _d === void 0 ? {} : _d;\r\n        this.path = path;\r\n        this.queryTransformer = queryTransformer;\r\n        this.resultTransformer = resultTransformer;\r\n        this.errorPathTransformer = errorPathTransformer;\r\n        this.fragments = fragments;\r\n    }\r\n    TransformQuery.prototype.transformRequest = function (originalRequest) {\r\n        var _a;\r\n        var _this = this;\r\n        var document = originalRequest.document;\r\n        var pathLength = this.path.length;\r\n        var index = 0;\r\n        var newDocument = visit(document, (_a = {},\r\n            _a[Kind.FIELD] = {\r\n                enter: function (node) {\r\n                    if (index === pathLength || node.name.value !== _this.path[index]) {\r\n                        return false;\r\n                    }\r\n                    index++;\r\n                    if (index === pathLength) {\r\n                        var selectionSet = _this.queryTransformer(node.selectionSet, _this.fragments);\r\n                        return __assign(__assign({}, node), { selectionSet: selectionSet });\r\n                    }\r\n                },\r\n                leave: function () {\r\n                    index--;\r\n                },\r\n            },\r\n            _a));\r\n        return __assign(__assign({}, originalRequest), { document: newDocument });\r\n    };\r\n    TransformQuery.prototype.transformResult = function (originalResult) {\r\n        var data = this.transformData(originalResult.data);\r\n        var errors = originalResult.errors;\r\n        return {\r\n            data: data,\r\n            errors: errors != null ? this.transformErrors(errors) : undefined,\r\n        };\r\n    };\r\n    TransformQuery.prototype.transformData = function (data) {\r\n        var leafIndex = this.path.length - 1;\r\n        var index = 0;\r\n        var newData = data;\r\n        if (newData) {\r\n            var next = this.path[index];\r\n            while (index < leafIndex) {\r\n                if (data[next]) {\r\n                    newData = newData[next];\r\n                }\r\n                else {\r\n                    break;\r\n                }\r\n                index++;\r\n                next = this.path[index];\r\n            }\r\n            newData[next] = this.resultTransformer(newData[next]);\r\n        }\r\n        return newData;\r\n    };\r\n    TransformQuery.prototype.transformErrors = function (errors) {\r\n        var _this = this;\r\n        return errors.map(function (error) {\r\n            var path = error.path;\r\n            var match = true;\r\n            var index = 0;\r\n            while (index < _this.path.length) {\r\n                if (path[index] !== _this.path[index]) {\r\n                    match = false;\r\n                    break;\r\n                }\r\n                index++;\r\n            }\r\n            var newPath = match\r\n                ? path\r\n                    .slice(0, index)\r\n                    .concat(_this.errorPathTransformer(path.slice(index)))\r\n                : path;\r\n            return new GraphQLError(error.message, error.nodes, error.source, error.positions, newPath, error.originalError, error.extensions);\r\n        });\r\n    };\r\n    return TransformQuery;\r\n}());\n\nvar MapFields = /** @class */ (function () {\r\n    function MapFields(fieldNodeTransformerMap) {\r\n        this.transformer = new TransformObjectFields(function (_typeName, _fieldName, field) { return toConfig(field); }, function (typeName, fieldName, fieldNode, fragments) {\r\n            var typeTransformers = fieldNodeTransformerMap[typeName];\r\n            if (typeTransformers == null) {\r\n                return fieldNode;\r\n            }\r\n            var fieldNodeTransformer = typeTransformers[fieldName];\r\n            if (fieldNodeTransformer == null) {\r\n                return fieldNode;\r\n            }\r\n            return fieldNodeTransformer(fieldNode, fragments);\r\n        });\r\n    }\r\n    MapFields.prototype.transformSchema = function (schema) {\r\n        return this.transformer.transformSchema(schema);\r\n    };\r\n    MapFields.prototype.transformRequest = function (request) {\r\n        return this.transformer.transformRequest(request);\r\n    };\r\n    return MapFields;\r\n}());\n\nvar ExtendSchema = /** @class */ (function () {\r\n    function ExtendSchema(_a) {\r\n        var typeDefs = _a.typeDefs, _b = _a.resolvers, resolvers = _b === void 0 ? {} : _b, defaultFieldResolver = _a.defaultFieldResolver, fieldNodeTransformerMap = _a.fieldNodeTransformerMap;\r\n        this.typeDefs = typeDefs;\r\n        this.resolvers = resolvers;\r\n        this.defaultFieldResolver =\r\n            defaultFieldResolver != null\r\n                ? defaultFieldResolver\r\n                : defaultMergedResolver;\r\n        this.transformer = new MapFields(fieldNodeTransformerMap != null ? fieldNodeTransformerMap : {});\r\n    }\r\n    ExtendSchema.prototype.transformSchema = function (schema) {\r\n        this.transformer.transformSchema(schema);\r\n        return addResolversToSchema({\r\n            schema: this.typeDefs\r\n                ? extendSchema$1(schema, parse(this.typeDefs))\r\n                : schema,\r\n            resolvers: this.resolvers != null ? this.resolvers : {},\r\n            defaultFieldResolver: this.defaultFieldResolver,\r\n        });\r\n    };\r\n    ExtendSchema.prototype.transformRequest = function (originalRequest) {\r\n        return this.transformer.transformRequest(originalRequest);\r\n    };\r\n    return ExtendSchema;\r\n}());\n\nfunction renameFieldNode(fieldNode, name) {\r\n    return __assign(__assign({}, fieldNode), { alias: {\r\n            kind: Kind.NAME,\r\n            value: fieldNode.alias != null ? fieldNode.alias.value : fieldNode.name.value,\r\n        }, name: {\r\n            kind: Kind.NAME,\r\n            value: name,\r\n        } });\r\n}\r\nfunction preAliasFieldNode(fieldNode, str) {\r\n    return __assign(__assign({}, fieldNode), { alias: {\r\n            kind: Kind.NAME,\r\n            value: \"\" + str + (fieldNode.alias != null ? fieldNode.alias.value : fieldNode.name.value),\r\n        } });\r\n}\r\nfunction wrapFieldNode(fieldNode, path) {\r\n    var newFieldNode = fieldNode;\r\n    path.forEach(function (fieldName) {\r\n        newFieldNode = {\r\n            kind: Kind.FIELD,\r\n            name: {\r\n                kind: Kind.NAME,\r\n                value: fieldName,\r\n            },\r\n            selectionSet: {\r\n                kind: Kind.SELECTION_SET,\r\n                selections: [fieldNode],\r\n            },\r\n        };\r\n    });\r\n    return newFieldNode;\r\n}\r\nfunction collectFields$1(selectionSet, fragments, fields, visitedFragmentNames) {\r\n    if (fields === void 0) { fields = []; }\r\n    if (visitedFragmentNames === void 0) { visitedFragmentNames = {}; }\r\n    if (selectionSet != null) {\r\n        selectionSet.selections.forEach(function (selection) {\r\n            switch (selection.kind) {\r\n                case Kind.FIELD:\r\n                    fields.push(selection);\r\n                    break;\r\n                case Kind.INLINE_FRAGMENT:\r\n                    collectFields$1(selection.selectionSet, fragments, fields, visitedFragmentNames);\r\n                    break;\r\n                case Kind.FRAGMENT_SPREAD: {\r\n                    var fragmentName = selection.name.value;\r\n                    if (!visitedFragmentNames[fragmentName]) {\r\n                        visitedFragmentNames[fragmentName] = true;\r\n                        collectFields$1(fragments[fragmentName].selectionSet, fragments, fields, visitedFragmentNames);\r\n                    }\r\n                    break;\r\n                }\r\n            }\r\n        });\r\n    }\r\n    return fields;\r\n}\r\nfunction hoistFieldNodes(_a) {\r\n    var fieldNode = _a.fieldNode, fieldNames = _a.fieldNames, _b = _a.path, path = _b === void 0 ? [] : _b, _c = _a.delimeter, delimeter = _c === void 0 ? '__gqltf__' : _c, fragments = _a.fragments;\r\n    var alias = fieldNode.alias != null ? fieldNode.alias.value : fieldNode.name.value;\r\n    var newFieldNodes = [];\r\n    if (path.length) {\r\n        var remainingPathSegments_1 = path.slice();\r\n        var initialPathSegment_1 = remainingPathSegments_1.shift();\r\n        collectFields$1(fieldNode.selectionSet, fragments).forEach(function (possibleFieldNode) {\r\n            if (possibleFieldNode.name.value === initialPathSegment_1) {\r\n                newFieldNodes = newFieldNodes.concat(hoistFieldNodes({\r\n                    fieldNode: preAliasFieldNode(possibleFieldNode, \"\" + alias + delimeter),\r\n                    fieldNames: fieldNames,\r\n                    path: remainingPathSegments_1,\r\n                    delimeter: delimeter,\r\n                    fragments: fragments,\r\n                }));\r\n            }\r\n        });\r\n    }\r\n    else {\r\n        collectFields$1(fieldNode.selectionSet, fragments).forEach(function (possibleFieldNode) {\r\n            if (!fieldNames || fieldNames.includes(possibleFieldNode.name.value)) {\r\n                newFieldNodes.push(preAliasFieldNode(possibleFieldNode, \"\" + alias + delimeter));\r\n            }\r\n        });\r\n    }\r\n    return newFieldNodes;\r\n}\n\nfunction appendFields(typeMap, typeName, fields) {\r\n    var type = typeMap[typeName];\r\n    if (type != null) {\r\n        var typeConfig = toConfig(type);\r\n        var newFields_1 = toObjMap(typeConfig.fields);\r\n        Object.keys(fields).forEach(function (fieldName) {\r\n            newFields_1[fieldName] = fields[fieldName];\r\n        });\r\n        type = new GraphQLObjectType(__assign(__assign({}, typeConfig), { fields: newFields_1 }));\r\n    }\r\n    else {\r\n        type = new GraphQLObjectType({\r\n            name: typeName,\r\n            fields: fields,\r\n        });\r\n    }\r\n    typeMap[typeName] = type;\r\n}\r\nfunction removeFields(typeMap, typeName, testFn) {\r\n    var type = typeMap[typeName];\r\n    var typeConfig = toConfig(type);\r\n    var originalFields = typeConfig.fields;\r\n    var newFields = {};\r\n    var removedFields = {};\r\n    Object.keys(originalFields).forEach(function (fieldName) {\r\n        if (testFn(fieldName, originalFields[fieldName])) {\r\n            removedFields[fieldName] = originalFields[fieldName];\r\n        }\r\n        else {\r\n            newFields[fieldName] = originalFields[fieldName];\r\n        }\r\n    });\r\n    type = new GraphQLObjectType(__assign(__assign({}, typeConfig), { fields: newFields }));\r\n    typeMap[typeName] = type;\r\n    return removedFields;\r\n}\n\nfunction createMergedResolver(_a) {\r\n    var fromPath = _a.fromPath, dehoist = _a.dehoist, _b = _a.delimeter, delimeter = _b === void 0 ? '__gqltf__' : _b;\r\n    var parentErrorResolver = function (parent, args, context, info) {\r\n        return parent instanceof Error\r\n            ? parent\r\n            : defaultMergedResolver(parent, args, context, info);\r\n    };\r\n    var unwrappingResolver = fromPath != null\r\n        ? function (parent, args, context, info) {\r\n            return parentErrorResolver(unwrapResult(parent, info, fromPath), args, context, info);\r\n        }\r\n        : parentErrorResolver;\r\n    var dehoistingResolver = dehoist\r\n        ? function (parent, args, context, info) {\r\n            return unwrappingResolver(dehoistResult(parent, delimeter), args, context, info);\r\n        }\r\n        : unwrappingResolver;\r\n    var noParentResolver = function (parent, args, context, info) { return (parent ? dehoistingResolver(parent, args, context, info) : {}); };\r\n    return noParentResolver;\r\n}\n\nvar WrapFields = /** @class */ (function () {\r\n    function WrapFields(outerTypeName, wrappingFieldNames, wrappingTypeNames, fieldNames) {\r\n        var _a, _b;\r\n        var _this = this;\r\n        this.outerTypeName = outerTypeName;\r\n        this.wrappingFieldNames = wrappingFieldNames;\r\n        this.wrappingTypeNames = wrappingTypeNames;\r\n        this.numWraps = wrappingFieldNames.length;\r\n        this.fieldNames = fieldNames;\r\n        var remainingWrappingFieldNames = this.wrappingFieldNames.slice();\r\n        var outerMostWrappingFieldName = remainingWrappingFieldNames.shift();\r\n        this.transformer = new MapFields((_a = {},\r\n            _a[outerTypeName] = (_b = {},\r\n                _b[outerMostWrappingFieldName] = function (fieldNode, fragments) {\r\n                    return hoistFieldNodes({\r\n                        fieldNode: fieldNode,\r\n                        path: remainingWrappingFieldNames,\r\n                        fieldNames: _this.fieldNames,\r\n                        fragments: fragments,\r\n                    });\r\n                },\r\n                _b),\r\n            _a));\r\n    }\r\n    WrapFields.prototype.transformSchema = function (schema) {\r\n        var _a, _b;\r\n        var _this = this;\r\n        var typeMap = schema.getTypeMap();\r\n        var targetFields = removeFields(typeMap, this.outerTypeName, !this.fieldNames\r\n            ? function () { return true; }\r\n            : function (fieldName) { return _this.fieldNames.includes(fieldName); });\r\n        var wrapIndex = this.numWraps - 1;\r\n        var innerMostWrappingTypeName = this.wrappingTypeNames[wrapIndex];\r\n        appendFields(typeMap, innerMostWrappingTypeName, targetFields);\r\n        for (wrapIndex--; wrapIndex > -1; wrapIndex--) {\r\n            appendFields(typeMap, this.wrappingTypeNames[wrapIndex], (_a = {},\r\n                _a[this.wrappingFieldNames[wrapIndex + 1]] = {\r\n                    type: typeMap[this.wrappingTypeNames[wrapIndex + 1]],\r\n                    resolve: defaultMergedResolver,\r\n                },\r\n                _a));\r\n        }\r\n        appendFields(typeMap, this.outerTypeName, (_b = {},\r\n            _b[this.wrappingFieldNames[0]] = {\r\n                type: typeMap[this.wrappingTypeNames[0]],\r\n                resolve: createMergedResolver({ dehoist: true }),\r\n            },\r\n            _b));\r\n        healSchema(schema);\r\n        return this.transformer.transformSchema(schema);\r\n    };\r\n    WrapFields.prototype.transformRequest = function (originalRequest) {\r\n        return this.transformer.transformRequest(originalRequest);\r\n    };\r\n    return WrapFields;\r\n}());\n\nvar WrapType = /** @class */ (function () {\r\n    function WrapType(outerTypeName, innerTypeName, fieldName) {\r\n        this.transformer = new WrapFields(outerTypeName, [fieldName], [innerTypeName], undefined);\r\n    }\r\n    WrapType.prototype.transformSchema = function (schema) {\r\n        return this.transformer.transformSchema(schema);\r\n    };\r\n    WrapType.prototype.transformRequest = function (originalRequest) {\r\n        return this.transformer.transformRequest(originalRequest);\r\n    };\r\n    return WrapType;\r\n}());\n\nvar HoistField = /** @class */ (function () {\r\n    function HoistField(typeName, path, newFieldName) {\r\n        var _a, _b;\r\n        var _this = this;\r\n        this.typeName = typeName;\r\n        this.path = path;\r\n        this.newFieldName = newFieldName;\r\n        this.pathToField = this.path.slice();\r\n        this.oldFieldName = this.pathToField.pop();\r\n        this.transformer = new MapFields((_a = {},\r\n            _a[typeName] = (_b = {},\r\n                _b[newFieldName] = function (fieldNode) {\r\n                    return wrapFieldNode(renameFieldNode(fieldNode, _this.oldFieldName), _this.pathToField);\r\n                },\r\n                _b),\r\n            _a));\r\n    }\r\n    HoistField.prototype.transformSchema = function (schema) {\r\n        var _a;\r\n        var _this = this;\r\n        var typeMap = schema.getTypeMap();\r\n        var innerType = this.pathToField.reduce(function (acc, pathSegment) {\r\n            return getNullableType(acc.getFields()[pathSegment].type);\r\n        }, typeMap[this.typeName]);\r\n        var targetField = removeFields(typeMap, innerType.name, function (fieldName) { return fieldName === _this.oldFieldName; })[this.oldFieldName];\r\n        var targetType = targetField.type;\r\n        appendFields(typeMap, this.typeName, (_a = {},\r\n            _a[this.newFieldName] = {\r\n                type: targetType,\r\n                resolve: createMergedResolver({ fromPath: this.pathToField }),\r\n            },\r\n            _a));\r\n        healSchema(schema);\r\n        return this.transformer.transformSchema(schema);\r\n    };\r\n    HoistField.prototype.transformRequest = function (originalRequest) {\r\n        return this.transformer.transformRequest(originalRequest);\r\n    };\r\n    return HoistField;\r\n}());\n\nvar ReplaceFieldWithFragment = /** @class */ (function () {\r\n    function ReplaceFieldWithFragment(targetSchema, fragments) {\r\n        this.targetSchema = targetSchema;\r\n        this.mapping = {};\r\n        for (var _i = 0, fragments_1 = fragments; _i < fragments_1.length; _i++) {\r\n            var _a = fragments_1[_i], field = _a.field, fragment = _a.fragment;\r\n            var parsedFragment = parseFragmentToInlineFragment$1(fragment);\r\n            var actualTypeName = parsedFragment.typeCondition.name.value;\r\n            if (!(actualTypeName in this.mapping)) {\r\n                this.mapping[actualTypeName] = Object.create(null);\r\n            }\r\n            var typeMapping = this.mapping[actualTypeName];\r\n            if (!(field in typeMapping)) {\r\n                typeMapping[field] = [parsedFragment];\r\n            }\r\n            else {\r\n                typeMapping[field].push(parsedFragment);\r\n            }\r\n        }\r\n    }\r\n    ReplaceFieldWithFragment.prototype.transformRequest = function (originalRequest) {\r\n        var document = replaceFieldsWithFragments$1(this.targetSchema, originalRequest.document, this.mapping);\r\n        return __assign(__assign({}, originalRequest), { document: document });\r\n    };\r\n    return ReplaceFieldWithFragment;\r\n}());\r\nfunction replaceFieldsWithFragments$1(targetSchema, document, mapping) {\r\n    var _a;\r\n    var typeInfo = new TypeInfo(targetSchema);\r\n    return visit(document, visitWithTypeInfo(typeInfo, (_a = {},\r\n        _a[Kind.SELECTION_SET] = function (node) {\r\n            var parentType = typeInfo.getParentType();\r\n            if (parentType != null) {\r\n                var parentTypeName_1 = parentType.name;\r\n                var selections_1 = node.selections;\r\n                if (parentTypeName_1 in mapping) {\r\n                    node.selections.forEach(function (selection) {\r\n                        if (selection.kind === Kind.FIELD) {\r\n                            var name_1 = selection.name.value;\r\n                            var fragments = mapping[parentTypeName_1][name_1];\r\n                            if (fragments != null && fragments.length > 0) {\r\n                                var fragment = concatInlineFragments(parentTypeName_1, fragments);\r\n                                selections_1 = selections_1.concat(fragment);\r\n                            }\r\n                        }\r\n                    });\r\n                }\r\n                if (selections_1 !== node.selections) {\r\n                    return __assign(__assign({}, node), { selections: selections_1 });\r\n                }\r\n            }\r\n        },\r\n        _a)));\r\n}\r\nfunction parseFragmentToInlineFragment$1(definitions) {\r\n    if (definitions.trim().startsWith('fragment')) {\r\n        var document_1 = parse(definitions);\r\n        for (var _i = 0, _a = document_1.definitions; _i < _a.length; _i++) {\r\n            var definition = _a[_i];\r\n            if (definition.kind === Kind.FRAGMENT_DEFINITION) {\r\n                return {\r\n                    kind: Kind.INLINE_FRAGMENT,\r\n                    typeCondition: definition.typeCondition,\r\n                    selectionSet: definition.selectionSet,\r\n                };\r\n            }\r\n        }\r\n    }\r\n    var query = parse(\"{\" + definitions + \"}\")\r\n        .definitions[0];\r\n    for (var _b = 0, _c = query.selectionSet.selections; _b < _c.length; _b++) {\r\n        var selection = _c[_b];\r\n        if (selection.kind === Kind.INLINE_FRAGMENT) {\r\n            return selection;\r\n        }\r\n    }\r\n    throw new Error('Could not parse fragment');\r\n}\n\nvar WrapQuery = /** @class */ (function () {\r\n    function WrapQuery(path, wrapper, extractor) {\r\n        this.path = path;\r\n        this.wrapper = wrapper;\r\n        this.extractor = extractor;\r\n    }\r\n    WrapQuery.prototype.transformRequest = function (originalRequest) {\r\n        var _a;\r\n        var _this = this;\r\n        var document = originalRequest.document;\r\n        var fieldPath = [];\r\n        var ourPath = JSON.stringify(this.path);\r\n        var newDocument = visit(document, (_a = {},\r\n            _a[Kind.FIELD] = {\r\n                enter: function (node) {\r\n                    fieldPath.push(node.name.value);\r\n                    if (ourPath === JSON.stringify(fieldPath)) {\r\n                        var wrapResult = _this.wrapper(node.selectionSet);\r\n                        // Selection can be either a single selection or a selection set. If it's just one selection,\r\n                        // let's wrap it in a selection set. Otherwise, keep it as is.\r\n                        var selectionSet = wrapResult != null && wrapResult.kind === Kind.SELECTION_SET\r\n                            ? wrapResult\r\n                            : {\r\n                                kind: Kind.SELECTION_SET,\r\n                                selections: [wrapResult],\r\n                            };\r\n                        return __assign(__assign({}, node), { selectionSet: selectionSet });\r\n                    }\r\n                },\r\n                leave: function () {\r\n                    fieldPath.pop();\r\n                },\r\n            },\r\n            _a));\r\n        return __assign(__assign({}, originalRequest), { document: newDocument });\r\n    };\r\n    WrapQuery.prototype.transformResult = function (originalResult) {\r\n        var rootData = originalResult.data;\r\n        if (rootData != null) {\r\n            var data = rootData;\r\n            var path = __spreadArrays(this.path);\r\n            while (path.length > 1) {\r\n                var next = path.shift();\r\n                if (data[next]) {\r\n                    data = data[next];\r\n                }\r\n            }\r\n            data[path[0]] = this.extractor(data[path[0]]);\r\n        }\r\n        return {\r\n            data: rootData,\r\n            errors: originalResult.errors,\r\n        };\r\n    };\r\n    return WrapQuery;\r\n}());\n\nvar ExtractField = /** @class */ (function () {\r\n    function ExtractField(_a) {\r\n        var from = _a.from, to = _a.to;\r\n        this.from = from;\r\n        this.to = to;\r\n    }\r\n    ExtractField.prototype.transformRequest = function (originalRequest) {\r\n        var _a, _b;\r\n        var fromSelection;\r\n        var ourPathFrom = JSON.stringify(this.from);\r\n        var ourPathTo = JSON.stringify(this.to);\r\n        var fieldPath = [];\r\n        visit(originalRequest.document, (_a = {},\r\n            _a[Kind.FIELD] = {\r\n                enter: function (node) {\r\n                    fieldPath.push(node.name.value);\r\n                    if (ourPathFrom === JSON.stringify(fieldPath)) {\r\n                        fromSelection = node.selectionSet;\r\n                        return BREAK;\r\n                    }\r\n                },\r\n                leave: function () {\r\n                    fieldPath.pop();\r\n                },\r\n            },\r\n            _a));\r\n        fieldPath = [];\r\n        var newDocument = visit(originalRequest.document, (_b = {},\r\n            _b[Kind.FIELD] = {\r\n                enter: function (node) {\r\n                    fieldPath.push(node.name.value);\r\n                    if (ourPathTo === JSON.stringify(fieldPath) &&\r\n                        fromSelection != null) {\r\n                        return __assign(__assign({}, node), { selectionSet: fromSelection });\r\n                    }\r\n                },\r\n                leave: function () {\r\n                    fieldPath.pop();\r\n                },\r\n            },\r\n            _b));\r\n        return __assign(__assign({}, originalRequest), { document: newDocument });\r\n    };\r\n    return ExtractField;\r\n}());\n\nfunction makeRemoteExecutableSchema(_a) {\r\n    var schemaOrTypeDefs = _a.schema, link = _a.link, fetcher = _a.fetcher, _b = _a.createResolver, createResolver = _b === void 0 ? defaultCreateRemoteResolver : _b, _c = _a.createSubscriptionResolver, createSubscriptionResolver = _c === void 0 ? defaultCreateRemoteSubscriptionResolver : _c, buildSchemaOptions = _a.buildSchemaOptions;\r\n    var finalFetcher = fetcher;\r\n    if (finalFetcher == null && link != null) {\r\n        finalFetcher = linkToFetcher(link);\r\n    }\r\n    var targetSchema = typeof schemaOrTypeDefs === 'string'\r\n        ? buildSchema(schemaOrTypeDefs, buildSchemaOptions)\r\n        : schemaOrTypeDefs;\r\n    return wrapSchema({\r\n        schema: targetSchema,\r\n        createProxyingResolver: function (_schema, _transforms, operation) {\r\n            if (operation === 'query' || operation === 'mutation') {\r\n                return createResolver(finalFetcher);\r\n            }\r\n            return createSubscriptionResolver(link);\r\n        },\r\n    });\r\n}\r\nfunction defaultCreateRemoteResolver(fetcher) {\r\n    return function (_parent, _args, context, info) {\r\n        return delegateToSchema({\r\n            schema: { schema: info.schema, fetcher: fetcher },\r\n            context: context,\r\n            info: info,\r\n        });\r\n    };\r\n}\r\nfunction defaultCreateRemoteSubscriptionResolver(link) {\r\n    return function (_parent, _args, context, info) {\r\n        return delegateToSchema({\r\n            schema: { schema: info.schema, link: link },\r\n            context: context,\r\n            info: info,\r\n        });\r\n    };\r\n}\n\nexport { AddArgumentsAsVariables, AddMergedTypeFragments as AddMergedTypeSelectionSets, AddReplacementFragments, AddReplacementSelectionSets, AddTypenameToAbstract, AwaitVariablesLink, CheckResultAndHandleErrors, ExpandAbstractTypes, ExtendSchema, ExtractField, FilterInterfaceFields, FilterObjectFields, FilterRootFields, FilterToSchema, FilterTypes, GraphQLUpload, HoistField, MapFields, MapperKind, MockList, RenameInterfaceFields, RenameObjectFields, RenameRootFields, RenameRootTypes, RenameTypes, ReplaceFieldWithFragment, SchemaDirectiveVisitor, SchemaError, SchemaVisitor, TransformCompositeFields, TransformInterfaceFields, TransformObjectFields, TransformQuery, TransformRootFields, VisitSchemaKind, WrapFields, WrapQuery, WrapType, addCatchUndefinedToSchema, addErrorLoggingToSchema, addMockFunctionsToSchema, addMocksToSchema, addResolveFunctionsToSchema, addResolversToSchema, addSchemaLevelResolveFunction, addSchemaLevelResolver, argumentMapToConfig, argumentToConfig, assertResolveFunctionsPresent, assertResolversPresent, attachConnectorsToContext, attachDirectiveResolvers, buildSchema, buildSchemaFromTypeDefinitions, chainResolvers, checkForResolveTypeResolver, cloneDirective, cloneSchema, cloneType, concatenateTypeDefs, createRequest, createRequestFromInfo, createServerHttpLink, decorateWithLogger, defaultCreateProxyingResolver, defaultCreateRemoteResolver, defaultCreateRemoteSubscriptionResolver, defaultMergedResolver, delegateRequest, delegateToSchema, directiveToConfig, enumTypeToConfig, extendResolversFromInterfaces, extendSchema, extractExtensionDefinitions, fieldMapToConfig, fieldToConfig, filterExtensionDefinitions, filterSchema, forEachDefaultValue, forEachField, getResolversFromSchema, graphqlVersion, healSchema, healTypes, inputFieldMapToConfig, inputFieldToConfig, inputObjectTypeToConfig, interfaceTypeToConfig, introspectSchema, isSpecifiedScalarType, isSubschemaConfig, makeExecutableSchema, makeRemoteExecutableSchema, mapSchema, mergeSchemas, mockServer, objectTypeToConfig, scalarTypeToConfig, schemaToConfig, toConfig, transformSchema, typeToConfig, unionTypeToConfig, visitSchema, wrapSchema };\n//# sourceMappingURL=index.esm.js.map\n","'use strict';\n\nconst crypto = require('crypto');\n\nmodule.exports = typeof crypto.randomUUID === 'function'\n  ? crypto.randomUUID\n  : require('./polyfill');\n","'use strict';\n\nconst crypto = require('crypto');\n\nconst {\n  validateBoolean,\n  validateObject,\n  codes: {\n    ERR_OPERATION_FAILED\n  }\n} = require('./validators');\n\nconst { randomFillSync } = crypto;\n\n// This is a non-cryptographically secure replacement for the native version\n// of the `secureBuffer` function used in Node.js core. This means `randomUUID`\n// should not be used where cryptographically secure uuids are important.\n//\n// Node.js core uses a native version which uses `OPENSSL_secure_malloc`\n// rather than `randomFillSync`.\nfunction secureBuffer (size) {\n  const buf = Buffer.alloc(size);\n  return randomFillSync(buf);\n}\n\n// Implements an RFC 4122 version 4 random UUID.\n// To improve performance, random data is generated in batches\n// large enough to cover kBatchSize UUID's at a time. The uuidData\n// buffer is reused. Each call to randomUUID() consumes 16 bytes\n// from the buffer.\n\nconst kBatchSize = 128;\nlet uuidData;\nlet uuidNotBuffered;\nlet uuidBatch = 0;\n\nlet hexBytesCache;\nfunction getHexBytes () {\n  if (hexBytesCache === undefined) {\n    hexBytesCache = new Array(256);\n    for (let i = 0; i < hexBytesCache.length; i++) {\n      const hex = i.toString(16);\n      hexBytesCache[i] = hex.padStart(2, '0');\n    }\n  }\n  return hexBytesCache;\n}\n\nfunction serializeUUID (buf, offset = 0) {\n  const kHexBytes = getHexBytes();\n  // xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\n  return kHexBytes[buf[offset]] +\n    kHexBytes[buf[offset + 1]] +\n    kHexBytes[buf[offset + 2]] +\n    kHexBytes[buf[offset + 3]] +\n    '-' +\n    kHexBytes[buf[offset + 4]] +\n    kHexBytes[buf[offset + 5]] +\n    '-' +\n    kHexBytes[(buf[offset + 6] & 0x0f) | 0x40] +\n    kHexBytes[buf[offset + 7]] +\n    '-' +\n    kHexBytes[(buf[offset + 8] & 0x3f) | 0x80] +\n    kHexBytes[buf[offset + 9]] +\n    '-' +\n    kHexBytes[buf[offset + 10]] +\n    kHexBytes[buf[offset + 11]] +\n    kHexBytes[buf[offset + 12]] +\n    kHexBytes[buf[offset + 13]] +\n    kHexBytes[buf[offset + 14]] +\n    kHexBytes[buf[offset + 15]];\n}\n\nfunction getBufferedUUID () {\n  if (!uuidData) uuidData = secureBuffer(16 * kBatchSize);\n  if (uuidData === undefined)\n    throw new ERR_OPERATION_FAILED('Out of memory');\n\n  if (uuidBatch === 0) randomFillSync(uuidData);\n  uuidBatch = (uuidBatch + 1) % kBatchSize;\n  return serializeUUID(uuidData, uuidBatch * 16);\n}\n\nfunction getUnbufferedUUID () {\n  if (!uuidNotBuffered) uuidNotBuffered = secureBuffer(16 * kBatchSize);\n  if (uuidNotBuffered === undefined)\n    throw new ERR_OPERATION_FAILED('Out of memory');\n  randomFillSync(uuidNotBuffered);\n  return serializeUUID(uuidNotBuffered);\n}\n\nfunction randomUUID (options) {\n  if (options !== undefined)\n    validateObject(options, 'options');\n  const {\n    disableEntropyCache = false,\n  } = options || {};\n\n  validateBoolean(disableEntropyCache, 'options.disableEntropyCache');\n\n  return disableEntropyCache ? getUnbufferedUUID() : getBufferedUUID();\n}\n\nmodule.exports = randomUUID;\n","'use strict';\n\n// Polyfill relevant Node.js core validators and error types\n\nconst assert = require('assert');\nconst util = require('util');\n\n// Sorted by a rough estimate on most frequently used entries.\nconst kTypes = [\n  'string',\n  'function',\n  'number',\n  'object',\n  // Accept 'Function' and 'Object' as alternative to the lower cased version.\n  'Function',\n  'Object',\n  'boolean',\n  'bigint',\n  'symbol',\n];\n\nclass ERR_OPERATION_FAILED extends TypeError {\n  constructor(message) {\n    super(`Operation failed: ${message}`);\n    this.code = this.constructor.name;\n\n    Object.defineProperties(this, {\n      toString: {\n        value () {\n          return `${this.name} [${this.code}]: ${this.message}`;\n        },\n        enumerable: false,\n        writable: true,\n        configurable: true,\n      },\n    });\n  }\n}\n\nclass ERR_INVALID_ARG_TYPE extends TypeError {\n  constructor(name, expected, actual) {\n    super();\n\n    assert(typeof name === 'string', \"'name' must be a string\");\n    if (!Array.isArray(expected)) {\n      expected = [expected];\n    }\n\n    let msg = 'The ';\n    if (name.endsWith(' argument')) {\n      // For cases like 'first argument'\n      msg += `${name} `;\n    } else {\n      const type = name.includes('.') ? 'property' : 'argument';\n      msg += `\"${name}\" ${type} `;\n    }\n    msg += 'must be ';\n\n    const types = [];\n    const instances = [];\n    const other = [];\n\n    for (const value of expected) {\n      assert(typeof value === 'string',\n        'All expected entries have to be of type string');\n      if (kTypes.includes(value)) {\n        types.push(value.toLowerCase());\n      } else if (classRegExp.test(value)) {\n        instances.push(value);\n      } else {\n        assert(value !== 'object',\n          'The value \"object\" should be written as \"Object\"');\n        other.push(value);\n      }\n    }\n\n    // Special handle `object` in case other instances are allowed to outline\n    // the differences between each other.\n    if (instances.length > 0) {\n      const pos = types.indexOf('object');\n      if (pos !== -1) {\n        types.splice(pos, 1);\n        instances.push('Object');\n      }\n    }\n\n    if (types.length > 0) {\n      if (types.length > 2) {\n        const last = types.pop();\n        msg += `one of type ${types.join(', ')}, or ${last}`;\n      } else if (types.length === 2) {\n        msg += `one of type ${types[0]} or ${types[1]}`;\n      } else {\n        msg += `of type ${types[0]}`;\n      }\n      if (instances.length > 0 || other.length > 0)\n        msg += ' or ';\n    }\n\n    if (instances.length > 0) {\n      if (instances.length > 2) {\n        const last = instances.pop();\n        msg +=\n          `an instance of ${instances.join(', ')}, or ${last}`;\n      } else {\n        msg += `an instance of ${instances[0]}`;\n        if (instances.length === 2) {\n          msg += ` or ${instances[1]}`;\n        }\n      }\n      if (other.length > 0)\n        msg += ' or ';\n    }\n\n    if (other.length > 0) {\n      if (other.length > 2) {\n        const last = other.pop();\n        msg += `one of ${other.join(', ')}, or ${last}`;\n      } else if (other.length === 2) {\n        msg += `one of ${other[0]} or ${other[1]}`;\n      } else {\n        if (other[0].toLowerCase() !== other[0])\n          msg += 'an ';\n        msg += `${other[0]}`;\n      }\n    }\n\n    if (actual == null) {\n      msg += `. Received ${actual}`;\n    } else if (typeof actual === 'function' && actual.name) {\n      msg += `. Received function ${actual.name}`;\n    } else if (typeof actual === 'object') {\n      if (actual.constructor && actual.constructor.name) {\n        msg += `. Received an instance of ${actual.constructor.name}`;\n      } else {\n        const inspected = util.inspect(actual, { depth: -1 });\n        msg += `. Received ${inspected}`;\n      }\n    } else {\n      let inspected = util.inspect(actual, { colors: false });\n      if (inspected.length > 25) {\n        inspected = `${inspected.slice(0, 25)}...`;\n      }\n      msg += `. Received type ${typeof actual} (${inspected})`;\n    }\n\n    this.code = this.constructor.name;\n\n    Object.defineProperties(this, {\n      message: {\n        value: msg,\n        enumerable: false,\n        writable: true,\n        configurable: true,\n      },\n      toString: {\n        value() {\n          return `${this.name} [${this.code}]: ${this.message}`;\n        },\n        enumerable: false,\n        writable: true,\n        configurable: true,\n      },\n    });\n  }\n}\n\nfunction validateBoolean(value, name) {\n  if (typeof value !== 'boolean')\n    throw new ERR_INVALID_ARG_TYPE(name, 'boolean', value);\n}\n\nfunction validateObject(value, name, {\n  nullable = false,\n  allowArray = false,\n  allowFunction = false,\n} = {}) {\n  if ((!nullable && value === null) ||\n    (!allowArray && Array.isArray(value)) ||\n    (typeof value !== 'object' && (\n      !allowFunction || typeof value !== 'function'\n    ))) {\n    throw new ERR_INVALID_ARG_TYPE(name, 'Object', value);\n  }\n};\n\nmodule.exports = {\n  validateBoolean,\n  validateObject,\n  codes: {\n    ERR_OPERATION_FAILED\n  }\n};\n","'use strict'\nmodule.exports = {\n  LOG: 'log',\n  AGENT: 'agent',\n  DATADOG: 'datadog'\n}\n","'use strict'\n\nconst opentracing = require('opentracing')\n\nmodule.exports = {\n  TEXT_MAP: opentracing.FORMAT_TEXT_MAP,\n  HTTP_HEADERS: opentracing.FORMAT_HTTP_HEADERS,\n  BINARY: opentracing.FORMAT_BINARY,\n  LOG: 'log'\n}\n","'use strict'\n\nconst formats = require('./formats')\nconst kinds = require('./kinds')\nconst priority = require('./priority')\nconst tags = require('./tags')\nconst types = require('./types')\nconst exporters = require('./exporters')\n\nmodule.exports = {\n  formats,\n  kinds,\n  priority,\n  tags,\n  types,\n  exporters\n}\n","'use strict'\n\nmodule.exports = {\n  SERVER: 'server',\n  CLIENT: 'client',\n  PRODUCER: 'producer',\n  CONSUMER: 'consumer'\n}\n","'use strict'\n\nmodule.exports = {\n  USER_REJECT: -1,\n  AUTO_REJECT: 0,\n  AUTO_KEEP: 1,\n  USER_KEEP: 2\n}\n","'use strict'\n\nconst tags = {\n  // Common\n  SERVICE_NAME: 'service.name',\n  RESOURCE_NAME: 'resource.name',\n  SPAN_TYPE: 'span.type',\n  SPAN_KIND: 'span.kind',\n  SAMPLING_PRIORITY: 'sampling.priority',\n  ANALYTICS: '_dd1.sr.eausr',\n  ERROR: 'error',\n  MANUAL_KEEP: 'manual.keep',\n  MANUAL_DROP: 'manual.drop',\n  MEASURED: '_dd.measured',\n\n  // HTTP\n  HTTP_URL: 'http.url',\n  HTTP_METHOD: 'http.method',\n  HTTP_STATUS_CODE: 'http.status_code',\n  HTTP_ROUTE: 'http.route',\n  HTTP_REQUEST_HEADERS: 'http.request.headers',\n  HTTP_RESPONSE_HEADERS: 'http.response.headers'\n}\n\n// Deprecated\ntags.ANALYTICS_SAMPLE_RATE = tags.ANALYTICS\n\nmodule.exports = tags\n","'use strict'\n\nmodule.exports = {\n  HTTP: 'http',\n  WEB: 'web'\n}\n","'use strict'\n\nmodule.exports = require('./packages/dd-trace')\n","// A simple implementation of make-array\nfunction makeArray (subject) {\n  return Array.isArray(subject)\n    ? subject\n    : [subject]\n}\n\nconst EMPTY = ''\nconst SPACE = ' '\nconst ESCAPE = '\\\\'\nconst REGEX_TEST_BLANK_LINE = /^\\s+$/\nconst REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION = /^\\\\!/\nconst REGEX_REPLACE_LEADING_EXCAPED_HASH = /^\\\\#/\nconst REGEX_SPLITALL_CRLF = /\\r?\\n/g\n// /foo,\n// ./foo,\n// ../foo,\n// .\n// ..\nconst REGEX_TEST_INVALID_PATH = /^\\.*\\/|^\\.+$/\n\nconst SLASH = '/'\nconst KEY_IGNORE = typeof Symbol !== 'undefined'\n  ? Symbol.for('node-ignore')\n  /* istanbul ignore next */\n  : 'node-ignore'\n\nconst define = (object, key, value) =>\n  Object.defineProperty(object, key, {value})\n\nconst REGEX_REGEXP_RANGE = /([0-z])-([0-z])/g\n\nconst RETURN_FALSE = () => false\n\n// Sanitize the range of a regular expression\n// The cases are complicated, see test cases for details\nconst sanitizeRange = range => range.replace(\n  REGEX_REGEXP_RANGE,\n  (match, from, to) => from.charCodeAt(0) <= to.charCodeAt(0)\n    ? match\n    // Invalid range (out of order) which is ok for gitignore rules but\n    //   fatal for JavaScript regular expression, so eliminate it.\n    : EMPTY\n)\n\n// See fixtures #59\nconst cleanRangeBackSlash = slashes => {\n  const {length} = slashes\n  return slashes.slice(0, length - length % 2)\n}\n\n// > If the pattern ends with a slash,\n// > it is removed for the purpose of the following description,\n// > but it would only find a match with a directory.\n// > In other words, foo/ will match a directory foo and paths underneath it,\n// > but will not match a regular file or a symbolic link foo\n// >  (this is consistent with the way how pathspec works in general in Git).\n// '`foo/`' will not match regular file '`foo`' or symbolic link '`foo`'\n// -> ignore-rules will not deal with it, because it costs extra `fs.stat` call\n//      you could use option `mark: true` with `glob`\n\n// '`foo/`' should not continue with the '`..`'\nconst REPLACERS = [\n\n  // > Trailing spaces are ignored unless they are quoted with backslash (\"\\\")\n  [\n    // (a\\ ) -> (a )\n    // (a  ) -> (a)\n    // (a \\ ) -> (a  )\n    /\\\\?\\s+$/,\n    match => match.indexOf('\\\\') === 0\n      ? SPACE\n      : EMPTY\n  ],\n\n  // replace (\\ ) with ' '\n  [\n    /\\\\\\s/g,\n    () => SPACE\n  ],\n\n  // Escape metacharacters\n  // which is written down by users but means special for regular expressions.\n\n  // > There are 12 characters with special meanings:\n  // > - the backslash \\,\n  // > - the caret ^,\n  // > - the dollar sign $,\n  // > - the period or dot .,\n  // > - the vertical bar or pipe symbol |,\n  // > - the question mark ?,\n  // > - the asterisk or star *,\n  // > - the plus sign +,\n  // > - the opening parenthesis (,\n  // > - the closing parenthesis ),\n  // > - and the opening square bracket [,\n  // > - the opening curly brace {,\n  // > These special characters are often called \"metacharacters\".\n  [\n    /[\\\\$.|*+(){^]/g,\n    match => `\\\\${match}`\n  ],\n\n  [\n    // > a question mark (?) matches a single character\n    /(?!\\\\)\\?/g,\n    () => '[^/]'\n  ],\n\n  // leading slash\n  [\n\n    // > A leading slash matches the beginning of the pathname.\n    // > For example, \"/*.c\" matches \"cat-file.c\" but not \"mozilla-sha1/sha1.c\".\n    // A leading slash matches the beginning of the pathname\n    /^\\//,\n    () => '^'\n  ],\n\n  // replace special metacharacter slash after the leading slash\n  [\n    /\\//g,\n    () => '\\\\/'\n  ],\n\n  [\n    // > A leading \"**\" followed by a slash means match in all directories.\n    // > For example, \"**/foo\" matches file or directory \"foo\" anywhere,\n    // > the same as pattern \"foo\".\n    // > \"**/foo/bar\" matches file or directory \"bar\" anywhere that is directly\n    // >   under directory \"foo\".\n    // Notice that the '*'s have been replaced as '\\\\*'\n    /^\\^*\\\\\\*\\\\\\*\\\\\\//,\n\n    // '**/foo' <-> 'foo'\n    () => '^(?:.*\\\\/)?'\n  ],\n\n  // starting\n  [\n    // there will be no leading '/'\n    //   (which has been replaced by section \"leading slash\")\n    // If starts with '**', adding a '^' to the regular expression also works\n    /^(?=[^^])/,\n    function startingReplacer () {\n      // If has a slash `/` at the beginning or middle\n      return !/\\/(?!$)/.test(this)\n        // > Prior to 2.22.1\n        // > If the pattern does not contain a slash /,\n        // >   Git treats it as a shell glob pattern\n        // Actually, if there is only a trailing slash,\n        //   git also treats it as a shell glob pattern\n\n        // After 2.22.1 (compatible but clearer)\n        // > If there is a separator at the beginning or middle (or both)\n        // > of the pattern, then the pattern is relative to the directory\n        // > level of the particular .gitignore file itself.\n        // > Otherwise the pattern may also match at any level below\n        // > the .gitignore level.\n        ? '(?:^|\\\\/)'\n\n        // > Otherwise, Git treats the pattern as a shell glob suitable for\n        // >   consumption by fnmatch(3)\n        : '^'\n    }\n  ],\n\n  // two globstars\n  [\n    // Use lookahead assertions so that we could match more than one `'/**'`\n    /\\\\\\/\\\\\\*\\\\\\*(?=\\\\\\/|$)/g,\n\n    // Zero, one or several directories\n    // should not use '*', or it will be replaced by the next replacer\n\n    // Check if it is not the last `'/**'`\n    (_, index, str) => index + 6 < str.length\n\n      // case: /**/\n      // > A slash followed by two consecutive asterisks then a slash matches\n      // >   zero or more directories.\n      // > For example, \"a/**/b\" matches \"a/b\", \"a/x/b\", \"a/x/y/b\" and so on.\n      // '/**/'\n      ? '(?:\\\\/[^\\\\/]+)*'\n\n      // case: /**\n      // > A trailing `\"/**\"` matches everything inside.\n\n      // #21: everything inside but it should not include the current folder\n      : '\\\\/.+'\n  ],\n\n  // intermediate wildcards\n  [\n    // Never replace escaped '*'\n    // ignore rule '\\*' will match the path '*'\n\n    // 'abc.*/' -> go\n    // 'abc.*'  -> skip this rule\n    /(^|[^\\\\]+)\\\\\\*(?=.+)/g,\n\n    // '*.js' matches '.js'\n    // '*.js' doesn't match 'abc'\n    (_, p1) => `${p1}[^\\\\/]*`\n  ],\n\n  [\n    // unescape, revert step 3 except for back slash\n    // For example, if a user escape a '\\\\*',\n    // after step 3, the result will be '\\\\\\\\\\\\*'\n    /\\\\\\\\\\\\(?=[$.|*+(){^])/g,\n    () => ESCAPE\n  ],\n\n  [\n    // '\\\\\\\\' -> '\\\\'\n    /\\\\\\\\/g,\n    () => ESCAPE\n  ],\n\n  [\n    // > The range notation, e.g. [a-zA-Z],\n    // > can be used to match one of the characters in a range.\n\n    // `\\` is escaped by step 3\n    /(\\\\)?\\[([^\\]/]*?)(\\\\*)($|\\])/g,\n    (match, leadEscape, range, endEscape, close) => leadEscape === ESCAPE\n      // '\\\\[bar]' -> '\\\\\\\\[bar\\\\]'\n      ? `\\\\[${range}${cleanRangeBackSlash(endEscape)}${close}`\n      : close === ']'\n        ? endEscape.length % 2 === 0\n          // A normal case, and it is a range notation\n          // '[bar]'\n          // '[bar\\\\\\\\]'\n          ? `[${sanitizeRange(range)}${endEscape}]`\n          // Invalid range notaton\n          // '[bar\\\\]' -> '[bar\\\\\\\\]'\n          : '[]'\n        : '[]'\n  ],\n\n  // ending\n  [\n    // 'js' will not match 'js.'\n    // 'ab' will not match 'abc'\n    /(?:[^*])$/,\n\n    // WTF!\n    // https://git-scm.com/docs/gitignore\n    // changes in [2.22.1](https://git-scm.com/docs/gitignore/2.22.1)\n    // which re-fixes #24, #38\n\n    // > If there is a separator at the end of the pattern then the pattern\n    // > will only match directories, otherwise the pattern can match both\n    // > files and directories.\n\n    // 'js*' will not match 'a.js'\n    // 'js/' will not match 'a.js'\n    // 'js' will match 'a.js' and 'a.js/'\n    match => /\\/$/.test(match)\n      // foo/ will not match 'foo'\n      ? `${match}$`\n      // foo matches 'foo' and 'foo/'\n      : `${match}(?=$|\\\\/$)`\n  ],\n\n  // trailing wildcard\n  [\n    /(\\^|\\\\\\/)?\\\\\\*$/,\n    (_, p1) => {\n      const prefix = p1\n        // '\\^':\n        // '/*' does not match EMPTY\n        // '/*' does not match everything\n\n        // '\\\\\\/':\n        // 'abc/*' does not match 'abc/'\n        ? `${p1}[^/]+`\n\n        // 'a*' matches 'a'\n        // 'a*' matches 'aa'\n        : '[^/]*'\n\n      return `${prefix}(?=$|\\\\/$)`\n    }\n  ],\n]\n\n// A simple cache, because an ignore rule only has only one certain meaning\nconst regexCache = Object.create(null)\n\n// @param {pattern}\nconst makeRegex = (pattern, ignoreCase) => {\n  let source = regexCache[pattern]\n\n  if (!source) {\n    source = REPLACERS.reduce(\n      (prev, current) => prev.replace(current[0], current[1].bind(pattern)),\n      pattern\n    )\n    regexCache[pattern] = source\n  }\n\n  return ignoreCase\n    ? new RegExp(source, 'i')\n    : new RegExp(source)\n}\n\nconst isString = subject => typeof subject === 'string'\n\n// > A blank line matches no files, so it can serve as a separator for readability.\nconst checkPattern = pattern => pattern\n  && isString(pattern)\n  && !REGEX_TEST_BLANK_LINE.test(pattern)\n\n  // > A line starting with # serves as a comment.\n  && pattern.indexOf('#') !== 0\n\nconst splitPattern = pattern => pattern.split(REGEX_SPLITALL_CRLF)\n\nclass IgnoreRule {\n  constructor (\n    origin,\n    pattern,\n    negative,\n    regex\n  ) {\n    this.origin = origin\n    this.pattern = pattern\n    this.negative = negative\n    this.regex = regex\n  }\n}\n\nconst createRule = (pattern, ignoreCase) => {\n  const origin = pattern\n  let negative = false\n\n  // > An optional prefix \"!\" which negates the pattern;\n  if (pattern.indexOf('!') === 0) {\n    negative = true\n    pattern = pattern.substr(1)\n  }\n\n  pattern = pattern\n  // > Put a backslash (\"\\\") in front of the first \"!\" for patterns that\n  // >   begin with a literal \"!\", for example, `\"\\!important!.txt\"`.\n  .replace(REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION, '!')\n  // > Put a backslash (\"\\\") in front of the first hash for patterns that\n  // >   begin with a hash.\n  .replace(REGEX_REPLACE_LEADING_EXCAPED_HASH, '#')\n\n  const regex = makeRegex(pattern, ignoreCase)\n\n  return new IgnoreRule(\n    origin,\n    pattern,\n    negative,\n    regex\n  )\n}\n\nconst throwError = (message, Ctor) => {\n  throw new Ctor(message)\n}\n\nconst checkPath = (path, originalPath, doThrow) => {\n  if (!isString(path)) {\n    return doThrow(\n      `path must be a string, but got \\`${originalPath}\\``,\n      TypeError\n    )\n  }\n\n  // We don't know if we should ignore EMPTY, so throw\n  if (!path) {\n    return doThrow(`path must not be empty`, TypeError)\n  }\n\n  // Check if it is a relative path\n  if (checkPath.isNotRelative(path)) {\n    const r = '`path.relative()`d'\n    return doThrow(\n      `path should be a ${r} string, but got \"${originalPath}\"`,\n      RangeError\n    )\n  }\n\n  return true\n}\n\nconst isNotRelative = path => REGEX_TEST_INVALID_PATH.test(path)\n\ncheckPath.isNotRelative = isNotRelative\ncheckPath.convert = p => p\n\nclass Ignore {\n  constructor ({\n    ignorecase = true,\n    ignoreCase = ignorecase,\n    allowRelativePaths = false\n  } = {}) {\n    define(this, KEY_IGNORE, true)\n\n    this._rules = []\n    this._ignoreCase = ignoreCase\n    this._allowRelativePaths = allowRelativePaths\n    this._initCache()\n  }\n\n  _initCache () {\n    this._ignoreCache = Object.create(null)\n    this._testCache = Object.create(null)\n  }\n\n  _addPattern (pattern) {\n    // #32\n    if (pattern && pattern[KEY_IGNORE]) {\n      this._rules = this._rules.concat(pattern._rules)\n      this._added = true\n      return\n    }\n\n    if (checkPattern(pattern)) {\n      const rule = createRule(pattern, this._ignoreCase)\n      this._added = true\n      this._rules.push(rule)\n    }\n  }\n\n  // @param {Array<string> | string | Ignore} pattern\n  add (pattern) {\n    this._added = false\n\n    makeArray(\n      isString(pattern)\n        ? splitPattern(pattern)\n        : pattern\n    ).forEach(this._addPattern, this)\n\n    // Some rules have just added to the ignore,\n    // making the behavior changed.\n    if (this._added) {\n      this._initCache()\n    }\n\n    return this\n  }\n\n  // legacy\n  addPattern (pattern) {\n    return this.add(pattern)\n  }\n\n  //          |           ignored : unignored\n  // negative |   0:0   |   0:1   |   1:0   |   1:1\n  // -------- | ------- | ------- | ------- | --------\n  //     0    |  TEST   |  TEST   |  SKIP   |    X\n  //     1    |  TESTIF |  SKIP   |  TEST   |    X\n\n  // - SKIP: always skip\n  // - TEST: always test\n  // - TESTIF: only test if checkUnignored\n  // - X: that never happen\n\n  // @param {boolean} whether should check if the path is unignored,\n  //   setting `checkUnignored` to `false` could reduce additional\n  //   path matching.\n\n  // @returns {TestResult} true if a file is ignored\n  _testOne (path, checkUnignored) {\n    let ignored = false\n    let unignored = false\n\n    this._rules.forEach(rule => {\n      const {negative} = rule\n      if (\n        unignored === negative && ignored !== unignored\n        || negative && !ignored && !unignored && !checkUnignored\n      ) {\n        return\n      }\n\n      const matched = rule.regex.test(path)\n\n      if (matched) {\n        ignored = !negative\n        unignored = negative\n      }\n    })\n\n    return {\n      ignored,\n      unignored\n    }\n  }\n\n  // @returns {TestResult}\n  _test (originalPath, cache, checkUnignored, slices) {\n    const path = originalPath\n      // Supports nullable path\n      && checkPath.convert(originalPath)\n\n    checkPath(\n      path,\n      originalPath,\n      this._allowRelativePaths\n        ? RETURN_FALSE\n        : throwError\n    )\n\n    return this._t(path, cache, checkUnignored, slices)\n  }\n\n  _t (path, cache, checkUnignored, slices) {\n    if (path in cache) {\n      return cache[path]\n    }\n\n    if (!slices) {\n      // path/to/a.js\n      // ['path', 'to', 'a.js']\n      slices = path.split(SLASH)\n    }\n\n    slices.pop()\n\n    // If the path has no parent directory, just test it\n    if (!slices.length) {\n      return cache[path] = this._testOne(path, checkUnignored)\n    }\n\n    const parent = this._t(\n      slices.join(SLASH) + SLASH,\n      cache,\n      checkUnignored,\n      slices\n    )\n\n    // If the path contains a parent directory, check the parent first\n    return cache[path] = parent.ignored\n      // > It is not possible to re-include a file if a parent directory of\n      // >   that file is excluded.\n      ? parent\n      : this._testOne(path, checkUnignored)\n  }\n\n  ignores (path) {\n    return this._test(path, this._ignoreCache, false).ignored\n  }\n\n  createFilter () {\n    return path => !this.ignores(path)\n  }\n\n  filter (paths) {\n    return makeArray(paths).filter(this.createFilter())\n  }\n\n  // @returns {TestResult}\n  test (path) {\n    return this._test(path, this._testCache, true)\n  }\n}\n\nconst factory = options => new Ignore(options)\n\nconst isPathValid = path =>\n  checkPath(path && checkPath.convert(path), path, RETURN_FALSE)\n\nfactory.isPathValid = isPathValid\n\n// Fixes typescript\nfactory.default = factory\n\nmodule.exports = factory\n\n// Windows\n// --------------------------------------------------------------\n/* istanbul ignore if  */\nif (\n  // Detect `process` so that it can run in browsers.\n  typeof process !== 'undefined'\n  && (\n    process.env && process.env.IGNORE_TEST_WIN32\n    || process.platform === 'win32'\n  )\n) {\n  /* eslint no-control-regex: \"off\" */\n  const makePosix = str => /^\\\\\\\\\\?\\\\/.test(str)\n  || /[\"<>|\\u0000-\\u001F]+/u.test(str)\n    ? str\n    : str.replace(/\\\\/g, '/')\n\n  checkPath.convert = makePosix\n\n  // 'C:\\\\foo'     <- 'C:\\\\foo' has been converted to 'C:/'\n  // 'd:\\\\foo'\n  const REGIX_IS_WINDOWS_PATH_ABSOLUTE = /^[a-z]:\\//i\n  checkPath.isNotRelative = path =>\n    REGIX_IS_WINDOWS_PATH_ABSOLUTE.test(path)\n    || isNotRelative(path)\n}\n","module.exports = require('./lib/retry');","var RetryOperation = require('./retry_operation');\n\nexports.operation = function(options) {\n  var timeouts = exports.timeouts(options);\n  return new RetryOperation(timeouts, {\n      forever: options && options.forever,\n      unref: options && options.unref\n  });\n};\n\nexports.timeouts = function(options) {\n  if (options instanceof Array) {\n    return [].concat(options);\n  }\n\n  var opts = {\n    retries: 10,\n    factor: 2,\n    minTimeout: 1 * 1000,\n    maxTimeout: Infinity,\n    randomize: false\n  };\n  for (var key in options) {\n    opts[key] = options[key];\n  }\n\n  if (opts.minTimeout > opts.maxTimeout) {\n    throw new Error('minTimeout is greater than maxTimeout');\n  }\n\n  var timeouts = [];\n  for (var i = 0; i < opts.retries; i++) {\n    timeouts.push(this.createTimeout(i, opts));\n  }\n\n  if (options && options.forever && !timeouts.length) {\n    timeouts.push(this.createTimeout(i, opts));\n  }\n\n  // sort the array numerically ascending\n  timeouts.sort(function(a,b) {\n    return a - b;\n  });\n\n  return timeouts;\n};\n\nexports.createTimeout = function(attempt, opts) {\n  var random = (opts.randomize)\n    ? (Math.random() + 1)\n    : 1;\n\n  var timeout = Math.round(random * opts.minTimeout * Math.pow(opts.factor, attempt));\n  timeout = Math.min(timeout, opts.maxTimeout);\n\n  return timeout;\n};\n\nexports.wrap = function(obj, options, methods) {\n  if (options instanceof Array) {\n    methods = options;\n    options = null;\n  }\n\n  if (!methods) {\n    methods = [];\n    for (var key in obj) {\n      if (typeof obj[key] === 'function') {\n        methods.push(key);\n      }\n    }\n  }\n\n  for (var i = 0; i < methods.length; i++) {\n    var method   = methods[i];\n    var original = obj[method];\n\n    obj[method] = function retryWrapper() {\n      var op       = exports.operation(options);\n      var args     = Array.prototype.slice.call(arguments);\n      var callback = args.pop();\n\n      args.push(function(err) {\n        if (op.retry(err)) {\n          return;\n        }\n        if (err) {\n          arguments[0] = op.mainError();\n        }\n        callback.apply(this, arguments);\n      });\n\n      op.attempt(function() {\n        original.apply(obj, args);\n      });\n    };\n    obj[method].options = options;\n  }\n};\n","function RetryOperation(timeouts, options) {\n  // Compatibility for the old (timeouts, retryForever) signature\n  if (typeof options === 'boolean') {\n    options = { forever: options };\n  }\n\n  this._timeouts = timeouts;\n  this._options = options || {};\n  this._fn = null;\n  this._errors = [];\n  this._attempts = 1;\n  this._operationTimeout = null;\n  this._operationTimeoutCb = null;\n  this._timeout = null;\n\n  if (this._options.forever) {\n    this._cachedTimeouts = this._timeouts.slice(0);\n  }\n}\nmodule.exports = RetryOperation;\n\nRetryOperation.prototype.stop = function() {\n  if (this._timeout) {\n    clearTimeout(this._timeout);\n  }\n\n  this._timeouts       = [];\n  this._cachedTimeouts = null;\n};\n\nRetryOperation.prototype.retry = function(err) {\n  if (this._timeout) {\n    clearTimeout(this._timeout);\n  }\n\n  if (!err) {\n    return false;\n  }\n\n  this._errors.push(err);\n\n  var timeout = this._timeouts.shift();\n  if (timeout === undefined) {\n    if (this._cachedTimeouts) {\n      // retry forever, only keep last error\n      this._errors.splice(this._errors.length - 1, this._errors.length);\n      this._timeouts = this._cachedTimeouts.slice(0);\n      timeout = this._timeouts.shift();\n    } else {\n      return false;\n    }\n  }\n\n  var self = this;\n  var timer = setTimeout(function() {\n    self._attempts++;\n\n    if (self._operationTimeoutCb) {\n      self._timeout = setTimeout(function() {\n        self._operationTimeoutCb(self._attempts);\n      }, self._operationTimeout);\n\n      if (this._options.unref) {\n          self._timeout.unref();\n      }\n    }\n\n    self._fn(self._attempts);\n  }, timeout);\n\n  if (this._options.unref) {\n      timer.unref();\n  }\n\n  return true;\n};\n\nRetryOperation.prototype.attempt = function(fn, timeoutOps) {\n  this._fn = fn;\n\n  if (timeoutOps) {\n    if (timeoutOps.timeout) {\n      this._operationTimeout = timeoutOps.timeout;\n    }\n    if (timeoutOps.cb) {\n      this._operationTimeoutCb = timeoutOps.cb;\n    }\n  }\n\n  var self = this;\n  if (this._operationTimeoutCb) {\n    this._timeout = setTimeout(function() {\n      self._operationTimeoutCb();\n    }, self._operationTimeout);\n  }\n\n  this._fn(this._attempts);\n};\n\nRetryOperation.prototype.try = function(fn) {\n  console.log('Using RetryOperation.try() is deprecated');\n  this.attempt(fn);\n};\n\nRetryOperation.prototype.start = function(fn) {\n  console.log('Using RetryOperation.start() is deprecated');\n  this.attempt(fn);\n};\n\nRetryOperation.prototype.start = RetryOperation.prototype.try;\n\nRetryOperation.prototype.errors = function() {\n  return this._errors;\n};\n\nRetryOperation.prototype.attempts = function() {\n  return this._attempts;\n};\n\nRetryOperation.prototype.mainError = function() {\n  if (this._errors.length === 0) {\n    return null;\n  }\n\n  var counts = {};\n  var mainError = null;\n  var mainErrorCount = 0;\n\n  for (var i = 0; i < this._errors.length; i++) {\n    var error = this._errors[i];\n    var message = error.message;\n    var count = (counts[message] || 0) + 1;\n\n    counts[message] = count;\n\n    if (count >= mainErrorCount) {\n      mainError = error;\n      mainErrorCount = count;\n    }\n  }\n\n  return mainError;\n};\n","exports = module.exports = SemVer\n\nvar debug\n/* istanbul ignore next */\nif (typeof process === 'object' &&\n    process.env &&\n    process.env.NODE_DEBUG &&\n    /\\bsemver\\b/i.test(process.env.NODE_DEBUG)) {\n  debug = function () {\n    var args = Array.prototype.slice.call(arguments, 0)\n    args.unshift('SEMVER')\n    console.log.apply(console, args)\n  }\n} else {\n  debug = function () {}\n}\n\n// Note: this is the semver.org version of the spec that it implements\n// Not necessarily the package version of this code.\nexports.SEMVER_SPEC_VERSION = '2.0.0'\n\nvar MAX_LENGTH = 256\nvar MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER ||\n  /* istanbul ignore next */ 9007199254740991\n\n// Max safe segment length for coercion.\nvar MAX_SAFE_COMPONENT_LENGTH = 16\n\n// The actual regexps go on exports.re\nvar re = exports.re = []\nvar src = exports.src = []\nvar R = 0\n\n// The following Regular Expressions can be used for tokenizing,\n// validating, and parsing SemVer version strings.\n\n// ## Numeric Identifier\n// A single `0`, or a non-zero digit followed by zero or more digits.\n\nvar NUMERICIDENTIFIER = R++\nsrc[NUMERICIDENTIFIER] = '0|[1-9]\\\\d*'\nvar NUMERICIDENTIFIERLOOSE = R++\nsrc[NUMERICIDENTIFIERLOOSE] = '[0-9]+'\n\n// ## Non-numeric Identifier\n// Zero or more digits, followed by a letter or hyphen, and then zero or\n// more letters, digits, or hyphens.\n\nvar NONNUMERICIDENTIFIER = R++\nsrc[NONNUMERICIDENTIFIER] = '\\\\d*[a-zA-Z-][a-zA-Z0-9-]*'\n\n// ## Main Version\n// Three dot-separated numeric identifiers.\n\nvar MAINVERSION = R++\nsrc[MAINVERSION] = '(' + src[NUMERICIDENTIFIER] + ')\\\\.' +\n                   '(' + src[NUMERICIDENTIFIER] + ')\\\\.' +\n                   '(' + src[NUMERICIDENTIFIER] + ')'\n\nvar MAINVERSIONLOOSE = R++\nsrc[MAINVERSIONLOOSE] = '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\\\.' +\n                        '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\\\.' +\n                        '(' + src[NUMERICIDENTIFIERLOOSE] + ')'\n\n// ## Pre-release Version Identifier\n// A numeric identifier, or a non-numeric identifier.\n\nvar PRERELEASEIDENTIFIER = R++\nsrc[PRERELEASEIDENTIFIER] = '(?:' + src[NUMERICIDENTIFIER] +\n                            '|' + src[NONNUMERICIDENTIFIER] + ')'\n\nvar PRERELEASEIDENTIFIERLOOSE = R++\nsrc[PRERELEASEIDENTIFIERLOOSE] = '(?:' + src[NUMERICIDENTIFIERLOOSE] +\n                                 '|' + src[NONNUMERICIDENTIFIER] + ')'\n\n// ## Pre-release Version\n// Hyphen, followed by one or more dot-separated pre-release version\n// identifiers.\n\nvar PRERELEASE = R++\nsrc[PRERELEASE] = '(?:-(' + src[PRERELEASEIDENTIFIER] +\n                  '(?:\\\\.' + src[PRERELEASEIDENTIFIER] + ')*))'\n\nvar PRERELEASELOOSE = R++\nsrc[PRERELEASELOOSE] = '(?:-?(' + src[PRERELEASEIDENTIFIERLOOSE] +\n                       '(?:\\\\.' + src[PRERELEASEIDENTIFIERLOOSE] + ')*))'\n\n// ## Build Metadata Identifier\n// Any combination of digits, letters, or hyphens.\n\nvar BUILDIDENTIFIER = R++\nsrc[BUILDIDENTIFIER] = '[0-9A-Za-z-]+'\n\n// ## Build Metadata\n// Plus sign, followed by one or more period-separated build metadata\n// identifiers.\n\nvar BUILD = R++\nsrc[BUILD] = '(?:\\\\+(' + src[BUILDIDENTIFIER] +\n             '(?:\\\\.' + src[BUILDIDENTIFIER] + ')*))'\n\n// ## Full Version String\n// A main version, followed optionally by a pre-release version and\n// build metadata.\n\n// Note that the only major, minor, patch, and pre-release sections of\n// the version string are capturing groups.  The build metadata is not a\n// capturing group, because it should not ever be used in version\n// comparison.\n\nvar FULL = R++\nvar FULLPLAIN = 'v?' + src[MAINVERSION] +\n                src[PRERELEASE] + '?' +\n                src[BUILD] + '?'\n\nsrc[FULL] = '^' + FULLPLAIN + '$'\n\n// like full, but allows v1.2.3 and =1.2.3, which people do sometimes.\n// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty\n// common in the npm registry.\nvar LOOSEPLAIN = '[v=\\\\s]*' + src[MAINVERSIONLOOSE] +\n                 src[PRERELEASELOOSE] + '?' +\n                 src[BUILD] + '?'\n\nvar LOOSE = R++\nsrc[LOOSE] = '^' + LOOSEPLAIN + '$'\n\nvar GTLT = R++\nsrc[GTLT] = '((?:<|>)?=?)'\n\n// Something like \"2.*\" or \"1.2.x\".\n// Note that \"x.x\" is a valid xRange identifer, meaning \"any version\"\n// Only the first item is strictly required.\nvar XRANGEIDENTIFIERLOOSE = R++\nsrc[XRANGEIDENTIFIERLOOSE] = src[NUMERICIDENTIFIERLOOSE] + '|x|X|\\\\*'\nvar XRANGEIDENTIFIER = R++\nsrc[XRANGEIDENTIFIER] = src[NUMERICIDENTIFIER] + '|x|X|\\\\*'\n\nvar XRANGEPLAIN = R++\nsrc[XRANGEPLAIN] = '[v=\\\\s]*(' + src[XRANGEIDENTIFIER] + ')' +\n                   '(?:\\\\.(' + src[XRANGEIDENTIFIER] + ')' +\n                   '(?:\\\\.(' + src[XRANGEIDENTIFIER] + ')' +\n                   '(?:' + src[PRERELEASE] + ')?' +\n                   src[BUILD] + '?' +\n                   ')?)?'\n\nvar XRANGEPLAINLOOSE = R++\nsrc[XRANGEPLAINLOOSE] = '[v=\\\\s]*(' + src[XRANGEIDENTIFIERLOOSE] + ')' +\n                        '(?:\\\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' +\n                        '(?:\\\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' +\n                        '(?:' + src[PRERELEASELOOSE] + ')?' +\n                        src[BUILD] + '?' +\n                        ')?)?'\n\nvar XRANGE = R++\nsrc[XRANGE] = '^' + src[GTLT] + '\\\\s*' + src[XRANGEPLAIN] + '$'\nvar XRANGELOOSE = R++\nsrc[XRANGELOOSE] = '^' + src[GTLT] + '\\\\s*' + src[XRANGEPLAINLOOSE] + '$'\n\n// Coercion.\n// Extract anything that could conceivably be a part of a valid semver\nvar COERCE = R++\nsrc[COERCE] = '(?:^|[^\\\\d])' +\n              '(\\\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '})' +\n              '(?:\\\\.(\\\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' +\n              '(?:\\\\.(\\\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' +\n              '(?:$|[^\\\\d])'\n\n// Tilde ranges.\n// Meaning is \"reasonably at or greater than\"\nvar LONETILDE = R++\nsrc[LONETILDE] = '(?:~>?)'\n\nvar TILDETRIM = R++\nsrc[TILDETRIM] = '(\\\\s*)' + src[LONETILDE] + '\\\\s+'\nre[TILDETRIM] = new RegExp(src[TILDETRIM], 'g')\nvar tildeTrimReplace = '$1~'\n\nvar TILDE = R++\nsrc[TILDE] = '^' + src[LONETILDE] + src[XRANGEPLAIN] + '$'\nvar TILDELOOSE = R++\nsrc[TILDELOOSE] = '^' + src[LONETILDE] + src[XRANGEPLAINLOOSE] + '$'\n\n// Caret ranges.\n// Meaning is \"at least and backwards compatible with\"\nvar LONECARET = R++\nsrc[LONECARET] = '(?:\\\\^)'\n\nvar CARETTRIM = R++\nsrc[CARETTRIM] = '(\\\\s*)' + src[LONECARET] + '\\\\s+'\nre[CARETTRIM] = new RegExp(src[CARETTRIM], 'g')\nvar caretTrimReplace = '$1^'\n\nvar CARET = R++\nsrc[CARET] = '^' + src[LONECARET] + src[XRANGEPLAIN] + '$'\nvar CARETLOOSE = R++\nsrc[CARETLOOSE] = '^' + src[LONECARET] + src[XRANGEPLAINLOOSE] + '$'\n\n// A simple gt/lt/eq thing, or just \"\" to indicate \"any version\"\nvar COMPARATORLOOSE = R++\nsrc[COMPARATORLOOSE] = '^' + src[GTLT] + '\\\\s*(' + LOOSEPLAIN + ')$|^$'\nvar COMPARATOR = R++\nsrc[COMPARATOR] = '^' + src[GTLT] + '\\\\s*(' + FULLPLAIN + ')$|^$'\n\n// An expression to strip any whitespace between the gtlt and the thing\n// it modifies, so that `> 1.2.3` ==> `>1.2.3`\nvar COMPARATORTRIM = R++\nsrc[COMPARATORTRIM] = '(\\\\s*)' + src[GTLT] +\n                      '\\\\s*(' + LOOSEPLAIN + '|' + src[XRANGEPLAIN] + ')'\n\n// this one has to use the /g flag\nre[COMPARATORTRIM] = new RegExp(src[COMPARATORTRIM], 'g')\nvar comparatorTrimReplace = '$1$2$3'\n\n// Something like `1.2.3 - 1.2.4`\n// Note that these all use the loose form, because they'll be\n// checked against either the strict or loose comparator form\n// later.\nvar HYPHENRANGE = R++\nsrc[HYPHENRANGE] = '^\\\\s*(' + src[XRANGEPLAIN] + ')' +\n                   '\\\\s+-\\\\s+' +\n                   '(' + src[XRANGEPLAIN] + ')' +\n                   '\\\\s*$'\n\nvar HYPHENRANGELOOSE = R++\nsrc[HYPHENRANGELOOSE] = '^\\\\s*(' + src[XRANGEPLAINLOOSE] + ')' +\n                        '\\\\s+-\\\\s+' +\n                        '(' + src[XRANGEPLAINLOOSE] + ')' +\n                        '\\\\s*$'\n\n// Star ranges basically just allow anything at all.\nvar STAR = R++\nsrc[STAR] = '(<|>)?=?\\\\s*\\\\*'\n\n// Compile to actual regexp objects.\n// All are flag-free, unless they were created above with a flag.\nfor (var i = 0; i < R; i++) {\n  debug(i, src[i])\n  if (!re[i]) {\n    re[i] = new RegExp(src[i])\n  }\n}\n\nexports.parse = parse\nfunction parse (version, options) {\n  if (!options || typeof options !== 'object') {\n    options = {\n      loose: !!options,\n      includePrerelease: false\n    }\n  }\n\n  if (version instanceof SemVer) {\n    return version\n  }\n\n  if (typeof version !== 'string') {\n    return null\n  }\n\n  if (version.length > MAX_LENGTH) {\n    return null\n  }\n\n  var r = options.loose ? re[LOOSE] : re[FULL]\n  if (!r.test(version)) {\n    return null\n  }\n\n  try {\n    return new SemVer(version, options)\n  } catch (er) {\n    return null\n  }\n}\n\nexports.valid = valid\nfunction valid (version, options) {\n  var v = parse(version, options)\n  return v ? v.version : null\n}\n\nexports.clean = clean\nfunction clean (version, options) {\n  var s = parse(version.trim().replace(/^[=v]+/, ''), options)\n  return s ? s.version : null\n}\n\nexports.SemVer = SemVer\n\nfunction SemVer (version, options) {\n  if (!options || typeof options !== 'object') {\n    options = {\n      loose: !!options,\n      includePrerelease: false\n    }\n  }\n  if (version instanceof SemVer) {\n    if (version.loose === options.loose) {\n      return version\n    } else {\n      version = version.version\n    }\n  } else if (typeof version !== 'string') {\n    throw new TypeError('Invalid Version: ' + version)\n  }\n\n  if (version.length > MAX_LENGTH) {\n    throw new TypeError('version is longer than ' + MAX_LENGTH + ' characters')\n  }\n\n  if (!(this instanceof SemVer)) {\n    return new SemVer(version, options)\n  }\n\n  debug('SemVer', version, options)\n  this.options = options\n  this.loose = !!options.loose\n\n  var m = version.trim().match(options.loose ? re[LOOSE] : re[FULL])\n\n  if (!m) {\n    throw new TypeError('Invalid Version: ' + version)\n  }\n\n  this.raw = version\n\n  // these are actually numbers\n  this.major = +m[1]\n  this.minor = +m[2]\n  this.patch = +m[3]\n\n  if (this.major > MAX_SAFE_INTEGER || this.major < 0) {\n    throw new TypeError('Invalid major version')\n  }\n\n  if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {\n    throw new TypeError('Invalid minor version')\n  }\n\n  if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {\n    throw new TypeError('Invalid patch version')\n  }\n\n  // numberify any prerelease numeric ids\n  if (!m[4]) {\n    this.prerelease = []\n  } else {\n    this.prerelease = m[4].split('.').map(function (id) {\n      if (/^[0-9]+$/.test(id)) {\n        var num = +id\n        if (num >= 0 && num < MAX_SAFE_INTEGER) {\n          return num\n        }\n      }\n      return id\n    })\n  }\n\n  this.build = m[5] ? m[5].split('.') : []\n  this.format()\n}\n\nSemVer.prototype.format = function () {\n  this.version = this.major + '.' + this.minor + '.' + this.patch\n  if (this.prerelease.length) {\n    this.version += '-' + this.prerelease.join('.')\n  }\n  return this.version\n}\n\nSemVer.prototype.toString = function () {\n  return this.version\n}\n\nSemVer.prototype.compare = function (other) {\n  debug('SemVer.compare', this.version, this.options, other)\n  if (!(other instanceof SemVer)) {\n    other = new SemVer(other, this.options)\n  }\n\n  return this.compareMain(other) || this.comparePre(other)\n}\n\nSemVer.prototype.compareMain = function (other) {\n  if (!(other instanceof SemVer)) {\n    other = new SemVer(other, this.options)\n  }\n\n  return compareIdentifiers(this.major, other.major) ||\n         compareIdentifiers(this.minor, other.minor) ||\n         compareIdentifiers(this.patch, other.patch)\n}\n\nSemVer.prototype.comparePre = function (other) {\n  if (!(other instanceof SemVer)) {\n    other = new SemVer(other, this.options)\n  }\n\n  // NOT having a prerelease is > having one\n  if (this.prerelease.length && !other.prerelease.length) {\n    return -1\n  } else if (!this.prerelease.length && other.prerelease.length) {\n    return 1\n  } else if (!this.prerelease.length && !other.prerelease.length) {\n    return 0\n  }\n\n  var i = 0\n  do {\n    var a = this.prerelease[i]\n    var b = other.prerelease[i]\n    debug('prerelease compare', i, a, b)\n    if (a === undefined && b === undefined) {\n      return 0\n    } else if (b === undefined) {\n      return 1\n    } else if (a === undefined) {\n      return -1\n    } else if (a === b) {\n      continue\n    } else {\n      return compareIdentifiers(a, b)\n    }\n  } while (++i)\n}\n\n// preminor will bump the version up to the next minor release, and immediately\n// down to pre-release. premajor and prepatch work the same way.\nSemVer.prototype.inc = function (release, identifier) {\n  switch (release) {\n    case 'premajor':\n      this.prerelease.length = 0\n      this.patch = 0\n      this.minor = 0\n      this.major++\n      this.inc('pre', identifier)\n      break\n    case 'preminor':\n      this.prerelease.length = 0\n      this.patch = 0\n      this.minor++\n      this.inc('pre', identifier)\n      break\n    case 'prepatch':\n      // If this is already a prerelease, it will bump to the next version\n      // drop any prereleases that might already exist, since they are not\n      // relevant at this point.\n      this.prerelease.length = 0\n      this.inc('patch', identifier)\n      this.inc('pre', identifier)\n      break\n    // If the input is a non-prerelease version, this acts the same as\n    // prepatch.\n    case 'prerelease':\n      if (this.prerelease.length === 0) {\n        this.inc('patch', identifier)\n      }\n      this.inc('pre', identifier)\n      break\n\n    case 'major':\n      // If this is a pre-major version, bump up to the same major version.\n      // Otherwise increment major.\n      // 1.0.0-5 bumps to 1.0.0\n      // 1.1.0 bumps to 2.0.0\n      if (this.minor !== 0 ||\n          this.patch !== 0 ||\n          this.prerelease.length === 0) {\n        this.major++\n      }\n      this.minor = 0\n      this.patch = 0\n      this.prerelease = []\n      break\n    case 'minor':\n      // If this is a pre-minor version, bump up to the same minor version.\n      // Otherwise increment minor.\n      // 1.2.0-5 bumps to 1.2.0\n      // 1.2.1 bumps to 1.3.0\n      if (this.patch !== 0 || this.prerelease.length === 0) {\n        this.minor++\n      }\n      this.patch = 0\n      this.prerelease = []\n      break\n    case 'patch':\n      // If this is not a pre-release version, it will increment the patch.\n      // If it is a pre-release it will bump up to the same patch version.\n      // 1.2.0-5 patches to 1.2.0\n      // 1.2.0 patches to 1.2.1\n      if (this.prerelease.length === 0) {\n        this.patch++\n      }\n      this.prerelease = []\n      break\n    // This probably shouldn't be used publicly.\n    // 1.0.0 \"pre\" would become 1.0.0-0 which is the wrong direction.\n    case 'pre':\n      if (this.prerelease.length === 0) {\n        this.prerelease = [0]\n      } else {\n        var i = this.prerelease.length\n        while (--i >= 0) {\n          if (typeof this.prerelease[i] === 'number') {\n            this.prerelease[i]++\n            i = -2\n          }\n        }\n        if (i === -1) {\n          // didn't increment anything\n          this.prerelease.push(0)\n        }\n      }\n      if (identifier) {\n        // 1.2.0-beta.1 bumps to 1.2.0-beta.2,\n        // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0\n        if (this.prerelease[0] === identifier) {\n          if (isNaN(this.prerelease[1])) {\n            this.prerelease = [identifier, 0]\n          }\n        } else {\n          this.prerelease = [identifier, 0]\n        }\n      }\n      break\n\n    default:\n      throw new Error('invalid increment argument: ' + release)\n  }\n  this.format()\n  this.raw = this.version\n  return this\n}\n\nexports.inc = inc\nfunction inc (version, release, loose, identifier) {\n  if (typeof (loose) === 'string') {\n    identifier = loose\n    loose = undefined\n  }\n\n  try {\n    return new SemVer(version, loose).inc(release, identifier).version\n  } catch (er) {\n    return null\n  }\n}\n\nexports.diff = diff\nfunction diff (version1, version2) {\n  if (eq(version1, version2)) {\n    return null\n  } else {\n    var v1 = parse(version1)\n    var v2 = parse(version2)\n    var prefix = ''\n    if (v1.prerelease.length || v2.prerelease.length) {\n      prefix = 'pre'\n      var defaultResult = 'prerelease'\n    }\n    for (var key in v1) {\n      if (key === 'major' || key === 'minor' || key === 'patch') {\n        if (v1[key] !== v2[key]) {\n          return prefix + key\n        }\n      }\n    }\n    return defaultResult // may be undefined\n  }\n}\n\nexports.compareIdentifiers = compareIdentifiers\n\nvar numeric = /^[0-9]+$/\nfunction compareIdentifiers (a, b) {\n  var anum = numeric.test(a)\n  var bnum = numeric.test(b)\n\n  if (anum && bnum) {\n    a = +a\n    b = +b\n  }\n\n  return a === b ? 0\n    : (anum && !bnum) ? -1\n    : (bnum && !anum) ? 1\n    : a < b ? -1\n    : 1\n}\n\nexports.rcompareIdentifiers = rcompareIdentifiers\nfunction rcompareIdentifiers (a, b) {\n  return compareIdentifiers(b, a)\n}\n\nexports.major = major\nfunction major (a, loose) {\n  return new SemVer(a, loose).major\n}\n\nexports.minor = minor\nfunction minor (a, loose) {\n  return new SemVer(a, loose).minor\n}\n\nexports.patch = patch\nfunction patch (a, loose) {\n  return new SemVer(a, loose).patch\n}\n\nexports.compare = compare\nfunction compare (a, b, loose) {\n  return new SemVer(a, loose).compare(new SemVer(b, loose))\n}\n\nexports.compareLoose = compareLoose\nfunction compareLoose (a, b) {\n  return compare(a, b, true)\n}\n\nexports.rcompare = rcompare\nfunction rcompare (a, b, loose) {\n  return compare(b, a, loose)\n}\n\nexports.sort = sort\nfunction sort (list, loose) {\n  return list.sort(function (a, b) {\n    return exports.compare(a, b, loose)\n  })\n}\n\nexports.rsort = rsort\nfunction rsort (list, loose) {\n  return list.sort(function (a, b) {\n    return exports.rcompare(a, b, loose)\n  })\n}\n\nexports.gt = gt\nfunction gt (a, b, loose) {\n  return compare(a, b, loose) > 0\n}\n\nexports.lt = lt\nfunction lt (a, b, loose) {\n  return compare(a, b, loose) < 0\n}\n\nexports.eq = eq\nfunction eq (a, b, loose) {\n  return compare(a, b, loose) === 0\n}\n\nexports.neq = neq\nfunction neq (a, b, loose) {\n  return compare(a, b, loose) !== 0\n}\n\nexports.gte = gte\nfunction gte (a, b, loose) {\n  return compare(a, b, loose) >= 0\n}\n\nexports.lte = lte\nfunction lte (a, b, loose) {\n  return compare(a, b, loose) <= 0\n}\n\nexports.cmp = cmp\nfunction cmp (a, op, b, loose) {\n  switch (op) {\n    case '===':\n      if (typeof a === 'object')\n        a = a.version\n      if (typeof b === 'object')\n        b = b.version\n      return a === b\n\n    case '!==':\n      if (typeof a === 'object')\n        a = a.version\n      if (typeof b === 'object')\n        b = b.version\n      return a !== b\n\n    case '':\n    case '=':\n    case '==':\n      return eq(a, b, loose)\n\n    case '!=':\n      return neq(a, b, loose)\n\n    case '>':\n      return gt(a, b, loose)\n\n    case '>=':\n      return gte(a, b, loose)\n\n    case '<':\n      return lt(a, b, loose)\n\n    case '<=':\n      return lte(a, b, loose)\n\n    default:\n      throw new TypeError('Invalid operator: ' + op)\n  }\n}\n\nexports.Comparator = Comparator\nfunction Comparator (comp, options) {\n  if (!options || typeof options !== 'object') {\n    options = {\n      loose: !!options,\n      includePrerelease: false\n    }\n  }\n\n  if (comp instanceof Comparator) {\n    if (comp.loose === !!options.loose) {\n      return comp\n    } else {\n      comp = comp.value\n    }\n  }\n\n  if (!(this instanceof Comparator)) {\n    return new Comparator(comp, options)\n  }\n\n  debug('comparator', comp, options)\n  this.options = options\n  this.loose = !!options.loose\n  this.parse(comp)\n\n  if (this.semver === ANY) {\n    this.value = ''\n  } else {\n    this.value = this.operator + this.semver.version\n  }\n\n  debug('comp', this)\n}\n\nvar ANY = {}\nComparator.prototype.parse = function (comp) {\n  var r = this.options.loose ? re[COMPARATORLOOSE] : re[COMPARATOR]\n  var m = comp.match(r)\n\n  if (!m) {\n    throw new TypeError('Invalid comparator: ' + comp)\n  }\n\n  this.operator = m[1]\n  if (this.operator === '=') {\n    this.operator = ''\n  }\n\n  // if it literally is just '>' or '' then allow anything.\n  if (!m[2]) {\n    this.semver = ANY\n  } else {\n    this.semver = new SemVer(m[2], this.options.loose)\n  }\n}\n\nComparator.prototype.toString = function () {\n  return this.value\n}\n\nComparator.prototype.test = function (version) {\n  debug('Comparator.test', version, this.options.loose)\n\n  if (this.semver === ANY) {\n    return true\n  }\n\n  if (typeof version === 'string') {\n    version = new SemVer(version, this.options)\n  }\n\n  return cmp(version, this.operator, this.semver, this.options)\n}\n\nComparator.prototype.intersects = function (comp, options) {\n  if (!(comp instanceof Comparator)) {\n    throw new TypeError('a Comparator is required')\n  }\n\n  if (!options || typeof options !== 'object') {\n    options = {\n      loose: !!options,\n      includePrerelease: false\n    }\n  }\n\n  var rangeTmp\n\n  if (this.operator === '') {\n    rangeTmp = new Range(comp.value, options)\n    return satisfies(this.value, rangeTmp, options)\n  } else if (comp.operator === '') {\n    rangeTmp = new Range(this.value, options)\n    return satisfies(comp.semver, rangeTmp, options)\n  }\n\n  var sameDirectionIncreasing =\n    (this.operator === '>=' || this.operator === '>') &&\n    (comp.operator === '>=' || comp.operator === '>')\n  var sameDirectionDecreasing =\n    (this.operator === '<=' || this.operator === '<') &&\n    (comp.operator === '<=' || comp.operator === '<')\n  var sameSemVer = this.semver.version === comp.semver.version\n  var differentDirectionsInclusive =\n    (this.operator === '>=' || this.operator === '<=') &&\n    (comp.operator === '>=' || comp.operator === '<=')\n  var oppositeDirectionsLessThan =\n    cmp(this.semver, '<', comp.semver, options) &&\n    ((this.operator === '>=' || this.operator === '>') &&\n    (comp.operator === '<=' || comp.operator === '<'))\n  var oppositeDirectionsGreaterThan =\n    cmp(this.semver, '>', comp.semver, options) &&\n    ((this.operator === '<=' || this.operator === '<') &&\n    (comp.operator === '>=' || comp.operator === '>'))\n\n  return sameDirectionIncreasing || sameDirectionDecreasing ||\n    (sameSemVer && differentDirectionsInclusive) ||\n    oppositeDirectionsLessThan || oppositeDirectionsGreaterThan\n}\n\nexports.Range = Range\nfunction Range (range, options) {\n  if (!options || typeof options !== 'object') {\n    options = {\n      loose: !!options,\n      includePrerelease: false\n    }\n  }\n\n  if (range instanceof Range) {\n    if (range.loose === !!options.loose &&\n        range.includePrerelease === !!options.includePrerelease) {\n      return range\n    } else {\n      return new Range(range.raw, options)\n    }\n  }\n\n  if (range instanceof Comparator) {\n    return new Range(range.value, options)\n  }\n\n  if (!(this instanceof Range)) {\n    return new Range(range, options)\n  }\n\n  this.options = options\n  this.loose = !!options.loose\n  this.includePrerelease = !!options.includePrerelease\n\n  // First, split based on boolean or ||\n  this.raw = range\n  this.set = range.split(/\\s*\\|\\|\\s*/).map(function (range) {\n    return this.parseRange(range.trim())\n  }, this).filter(function (c) {\n    // throw out any that are not relevant for whatever reason\n    return c.length\n  })\n\n  if (!this.set.length) {\n    throw new TypeError('Invalid SemVer Range: ' + range)\n  }\n\n  this.format()\n}\n\nRange.prototype.format = function () {\n  this.range = this.set.map(function (comps) {\n    return comps.join(' ').trim()\n  }).join('||').trim()\n  return this.range\n}\n\nRange.prototype.toString = function () {\n  return this.range\n}\n\nRange.prototype.parseRange = function (range) {\n  var loose = this.options.loose\n  range = range.trim()\n  // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`\n  var hr = loose ? re[HYPHENRANGELOOSE] : re[HYPHENRANGE]\n  range = range.replace(hr, hyphenReplace)\n  debug('hyphen replace', range)\n  // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`\n  range = range.replace(re[COMPARATORTRIM], comparatorTrimReplace)\n  debug('comparator trim', range, re[COMPARATORTRIM])\n\n  // `~ 1.2.3` => `~1.2.3`\n  range = range.replace(re[TILDETRIM], tildeTrimReplace)\n\n  // `^ 1.2.3` => `^1.2.3`\n  range = range.replace(re[CARETTRIM], caretTrimReplace)\n\n  // normalize spaces\n  range = range.split(/\\s+/).join(' ')\n\n  // At this point, the range is completely trimmed and\n  // ready to be split into comparators.\n\n  var compRe = loose ? re[COMPARATORLOOSE] : re[COMPARATOR]\n  var set = range.split(' ').map(function (comp) {\n    return parseComparator(comp, this.options)\n  }, this).join(' ').split(/\\s+/)\n  if (this.options.loose) {\n    // in loose mode, throw out any that are not valid comparators\n    set = set.filter(function (comp) {\n      return !!comp.match(compRe)\n    })\n  }\n  set = set.map(function (comp) {\n    return new Comparator(comp, this.options)\n  }, this)\n\n  return set\n}\n\nRange.prototype.intersects = function (range, options) {\n  if (!(range instanceof Range)) {\n    throw new TypeError('a Range is required')\n  }\n\n  return this.set.some(function (thisComparators) {\n    return thisComparators.every(function (thisComparator) {\n      return range.set.some(function (rangeComparators) {\n        return rangeComparators.every(function (rangeComparator) {\n          return thisComparator.intersects(rangeComparator, options)\n        })\n      })\n    })\n  })\n}\n\n// Mostly just for testing and legacy API reasons\nexports.toComparators = toComparators\nfunction toComparators (range, options) {\n  return new Range(range, options).set.map(function (comp) {\n    return comp.map(function (c) {\n      return c.value\n    }).join(' ').trim().split(' ')\n  })\n}\n\n// comprised of xranges, tildes, stars, and gtlt's at this point.\n// already replaced the hyphen ranges\n// turn into a set of JUST comparators.\nfunction parseComparator (comp, options) {\n  debug('comp', comp, options)\n  comp = replaceCarets(comp, options)\n  debug('caret', comp)\n  comp = replaceTildes(comp, options)\n  debug('tildes', comp)\n  comp = replaceXRanges(comp, options)\n  debug('xrange', comp)\n  comp = replaceStars(comp, options)\n  debug('stars', comp)\n  return comp\n}\n\nfunction isX (id) {\n  return !id || id.toLowerCase() === 'x' || id === '*'\n}\n\n// ~, ~> --> * (any, kinda silly)\n// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0\n// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0\n// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0\n// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0\n// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0\nfunction replaceTildes (comp, options) {\n  return comp.trim().split(/\\s+/).map(function (comp) {\n    return replaceTilde(comp, options)\n  }).join(' ')\n}\n\nfunction replaceTilde (comp, options) {\n  var r = options.loose ? re[TILDELOOSE] : re[TILDE]\n  return comp.replace(r, function (_, M, m, p, pr) {\n    debug('tilde', comp, _, M, m, p, pr)\n    var ret\n\n    if (isX(M)) {\n      ret = ''\n    } else if (isX(m)) {\n      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0'\n    } else if (isX(p)) {\n      // ~1.2 == >=1.2.0 <1.3.0\n      ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0'\n    } else if (pr) {\n      debug('replaceTilde pr', pr)\n      ret = '>=' + M + '.' + m + '.' + p + '-' + pr +\n            ' <' + M + '.' + (+m + 1) + '.0'\n    } else {\n      // ~1.2.3 == >=1.2.3 <1.3.0\n      ret = '>=' + M + '.' + m + '.' + p +\n            ' <' + M + '.' + (+m + 1) + '.0'\n    }\n\n    debug('tilde return', ret)\n    return ret\n  })\n}\n\n// ^ --> * (any, kinda silly)\n// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0\n// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0\n// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0\n// ^1.2.3 --> >=1.2.3 <2.0.0\n// ^1.2.0 --> >=1.2.0 <2.0.0\nfunction replaceCarets (comp, options) {\n  return comp.trim().split(/\\s+/).map(function (comp) {\n    return replaceCaret(comp, options)\n  }).join(' ')\n}\n\nfunction replaceCaret (comp, options) {\n  debug('caret', comp, options)\n  var r = options.loose ? re[CARETLOOSE] : re[CARET]\n  return comp.replace(r, function (_, M, m, p, pr) {\n    debug('caret', comp, _, M, m, p, pr)\n    var ret\n\n    if (isX(M)) {\n      ret = ''\n    } else if (isX(m)) {\n      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0'\n    } else if (isX(p)) {\n      if (M === '0') {\n        ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0'\n      } else {\n        ret = '>=' + M + '.' + m + '.0 <' + (+M + 1) + '.0.0'\n      }\n    } else if (pr) {\n      debug('replaceCaret pr', pr)\n      if (M === '0') {\n        if (m === '0') {\n          ret = '>=' + M + '.' + m + '.' + p + '-' + pr +\n                ' <' + M + '.' + m + '.' + (+p + 1)\n        } else {\n          ret = '>=' + M + '.' + m + '.' + p + '-' + pr +\n                ' <' + M + '.' + (+m + 1) + '.0'\n        }\n      } else {\n        ret = '>=' + M + '.' + m + '.' + p + '-' + pr +\n              ' <' + (+M + 1) + '.0.0'\n      }\n    } else {\n      debug('no pr')\n      if (M === '0') {\n        if (m === '0') {\n          ret = '>=' + M + '.' + m + '.' + p +\n                ' <' + M + '.' + m + '.' + (+p + 1)\n        } else {\n          ret = '>=' + M + '.' + m + '.' + p +\n                ' <' + M + '.' + (+m + 1) + '.0'\n        }\n      } else {\n        ret = '>=' + M + '.' + m + '.' + p +\n              ' <' + (+M + 1) + '.0.0'\n      }\n    }\n\n    debug('caret return', ret)\n    return ret\n  })\n}\n\nfunction replaceXRanges (comp, options) {\n  debug('replaceXRanges', comp, options)\n  return comp.split(/\\s+/).map(function (comp) {\n    return replaceXRange(comp, options)\n  }).join(' ')\n}\n\nfunction replaceXRange (comp, options) {\n  comp = comp.trim()\n  var r = options.loose ? re[XRANGELOOSE] : re[XRANGE]\n  return comp.replace(r, function (ret, gtlt, M, m, p, pr) {\n    debug('xRange', comp, ret, gtlt, M, m, p, pr)\n    var xM = isX(M)\n    var xm = xM || isX(m)\n    var xp = xm || isX(p)\n    var anyX = xp\n\n    if (gtlt === '=' && anyX) {\n      gtlt = ''\n    }\n\n    if (xM) {\n      if (gtlt === '>' || gtlt === '<') {\n        // nothing is allowed\n        ret = '<0.0.0'\n      } else {\n        // nothing is forbidden\n        ret = '*'\n      }\n    } else if (gtlt && anyX) {\n      // we know patch is an x, because we have any x at all.\n      // replace X with 0\n      if (xm) {\n        m = 0\n      }\n      p = 0\n\n      if (gtlt === '>') {\n        // >1 => >=2.0.0\n        // >1.2 => >=1.3.0\n        // >1.2.3 => >= 1.2.4\n        gtlt = '>='\n        if (xm) {\n          M = +M + 1\n          m = 0\n          p = 0\n        } else {\n          m = +m + 1\n          p = 0\n        }\n      } else if (gtlt === '<=') {\n        // <=0.7.x is actually <0.8.0, since any 0.7.x should\n        // pass.  Similarly, <=7.x is actually <8.0.0, etc.\n        gtlt = '<'\n        if (xm) {\n          M = +M + 1\n        } else {\n          m = +m + 1\n        }\n      }\n\n      ret = gtlt + M + '.' + m + '.' + p\n    } else if (xm) {\n      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0'\n    } else if (xp) {\n      ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0'\n    }\n\n    debug('xRange return', ret)\n\n    return ret\n  })\n}\n\n// Because * is AND-ed with everything else in the comparator,\n// and '' means \"any version\", just remove the *s entirely.\nfunction replaceStars (comp, options) {\n  debug('replaceStars', comp, options)\n  // Looseness is ignored here.  star is always as loose as it gets!\n  return comp.trim().replace(re[STAR], '')\n}\n\n// This function is passed to string.replace(re[HYPHENRANGE])\n// M, m, patch, prerelease, build\n// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5\n// 1.2.3 - 3.4 => >=1.2.0 <3.5.0 Any 3.4.x will do\n// 1.2 - 3.4 => >=1.2.0 <3.5.0\nfunction hyphenReplace ($0,\n  from, fM, fm, fp, fpr, fb,\n  to, tM, tm, tp, tpr, tb) {\n  if (isX(fM)) {\n    from = ''\n  } else if (isX(fm)) {\n    from = '>=' + fM + '.0.0'\n  } else if (isX(fp)) {\n    from = '>=' + fM + '.' + fm + '.0'\n  } else {\n    from = '>=' + from\n  }\n\n  if (isX(tM)) {\n    to = ''\n  } else if (isX(tm)) {\n    to = '<' + (+tM + 1) + '.0.0'\n  } else if (isX(tp)) {\n    to = '<' + tM + '.' + (+tm + 1) + '.0'\n  } else if (tpr) {\n    to = '<=' + tM + '.' + tm + '.' + tp + '-' + tpr\n  } else {\n    to = '<=' + to\n  }\n\n  return (from + ' ' + to).trim()\n}\n\n// if ANY of the sets match ALL of its comparators, then pass\nRange.prototype.test = function (version) {\n  if (!version) {\n    return false\n  }\n\n  if (typeof version === 'string') {\n    version = new SemVer(version, this.options)\n  }\n\n  for (var i = 0; i < this.set.length; i++) {\n    if (testSet(this.set[i], version, this.options)) {\n      return true\n    }\n  }\n  return false\n}\n\nfunction testSet (set, version, options) {\n  for (var i = 0; i < set.length; i++) {\n    if (!set[i].test(version)) {\n      return false\n    }\n  }\n\n  if (version.prerelease.length && !options.includePrerelease) {\n    // Find the set of versions that are allowed to have prereleases\n    // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0\n    // That should allow `1.2.3-pr.2` to pass.\n    // However, `1.2.4-alpha.notready` should NOT be allowed,\n    // even though it's within the range set by the comparators.\n    for (i = 0; i < set.length; i++) {\n      debug(set[i].semver)\n      if (set[i].semver === ANY) {\n        continue\n      }\n\n      if (set[i].semver.prerelease.length > 0) {\n        var allowed = set[i].semver\n        if (allowed.major === version.major &&\n            allowed.minor === version.minor &&\n            allowed.patch === version.patch) {\n          return true\n        }\n      }\n    }\n\n    // Version has a -pre, but it's not one of the ones we like.\n    return false\n  }\n\n  return true\n}\n\nexports.satisfies = satisfies\nfunction satisfies (version, range, options) {\n  try {\n    range = new Range(range, options)\n  } catch (er) {\n    return false\n  }\n  return range.test(version)\n}\n\nexports.maxSatisfying = maxSatisfying\nfunction maxSatisfying (versions, range, options) {\n  var max = null\n  var maxSV = null\n  try {\n    var rangeObj = new Range(range, options)\n  } catch (er) {\n    return null\n  }\n  versions.forEach(function (v) {\n    if (rangeObj.test(v)) {\n      // satisfies(v, range, options)\n      if (!max || maxSV.compare(v) === -1) {\n        // compare(max, v, true)\n        max = v\n        maxSV = new SemVer(max, options)\n      }\n    }\n  })\n  return max\n}\n\nexports.minSatisfying = minSatisfying\nfunction minSatisfying (versions, range, options) {\n  var min = null\n  var minSV = null\n  try {\n    var rangeObj = new Range(range, options)\n  } catch (er) {\n    return null\n  }\n  versions.forEach(function (v) {\n    if (rangeObj.test(v)) {\n      // satisfies(v, range, options)\n      if (!min || minSV.compare(v) === 1) {\n        // compare(min, v, true)\n        min = v\n        minSV = new SemVer(min, options)\n      }\n    }\n  })\n  return min\n}\n\nexports.minVersion = minVersion\nfunction minVersion (range, loose) {\n  range = new Range(range, loose)\n\n  var minver = new SemVer('0.0.0')\n  if (range.test(minver)) {\n    return minver\n  }\n\n  minver = new SemVer('0.0.0-0')\n  if (range.test(minver)) {\n    return minver\n  }\n\n  minver = null\n  for (var i = 0; i < range.set.length; ++i) {\n    var comparators = range.set[i]\n\n    comparators.forEach(function (comparator) {\n      // Clone to avoid manipulating the comparator's semver object.\n      var compver = new SemVer(comparator.semver.version)\n      switch (comparator.operator) {\n        case '>':\n          if (compver.prerelease.length === 0) {\n            compver.patch++\n          } else {\n            compver.prerelease.push(0)\n          }\n          compver.raw = compver.format()\n          /* fallthrough */\n        case '':\n        case '>=':\n          if (!minver || gt(minver, compver)) {\n            minver = compver\n          }\n          break\n        case '<':\n        case '<=':\n          /* Ignore maximum versions */\n          break\n        /* istanbul ignore next */\n        default:\n          throw new Error('Unexpected operation: ' + comparator.operator)\n      }\n    })\n  }\n\n  if (minver && range.test(minver)) {\n    return minver\n  }\n\n  return null\n}\n\nexports.validRange = validRange\nfunction validRange (range, options) {\n  try {\n    // Return '*' instead of '' so that truthiness works.\n    // This will throw if it's invalid anyway\n    return new Range(range, options).range || '*'\n  } catch (er) {\n    return null\n  }\n}\n\n// Determine if version is less than all the versions possible in the range\nexports.ltr = ltr\nfunction ltr (version, range, options) {\n  return outside(version, range, '<', options)\n}\n\n// Determine if version is greater than all the versions possible in the range.\nexports.gtr = gtr\nfunction gtr (version, range, options) {\n  return outside(version, range, '>', options)\n}\n\nexports.outside = outside\nfunction outside (version, range, hilo, options) {\n  version = new SemVer(version, options)\n  range = new Range(range, options)\n\n  var gtfn, ltefn, ltfn, comp, ecomp\n  switch (hilo) {\n    case '>':\n      gtfn = gt\n      ltefn = lte\n      ltfn = lt\n      comp = '>'\n      ecomp = '>='\n      break\n    case '<':\n      gtfn = lt\n      ltefn = gte\n      ltfn = gt\n      comp = '<'\n      ecomp = '<='\n      break\n    default:\n      throw new TypeError('Must provide a hilo val of \"<\" or \">\"')\n  }\n\n  // If it satisifes the range it is not outside\n  if (satisfies(version, range, options)) {\n    return false\n  }\n\n  // From now on, variable terms are as if we're in \"gtr\" mode.\n  // but note that everything is flipped for the \"ltr\" function.\n\n  for (var i = 0; i < range.set.length; ++i) {\n    var comparators = range.set[i]\n\n    var high = null\n    var low = null\n\n    comparators.forEach(function (comparator) {\n      if (comparator.semver === ANY) {\n        comparator = new Comparator('>=0.0.0')\n      }\n      high = high || comparator\n      low = low || comparator\n      if (gtfn(comparator.semver, high.semver, options)) {\n        high = comparator\n      } else if (ltfn(comparator.semver, low.semver, options)) {\n        low = comparator\n      }\n    })\n\n    // If the edge version comparator has a operator then our version\n    // isn't outside it\n    if (high.operator === comp || high.operator === ecomp) {\n      return false\n    }\n\n    // If the lowest version comparator has an operator and our version\n    // is less than it then it isn't higher than the range\n    if ((!low.operator || low.operator === comp) &&\n        ltefn(version, low.semver)) {\n      return false\n    } else if (low.operator === ecomp && ltfn(version, low.semver)) {\n      return false\n    }\n  }\n  return true\n}\n\nexports.prerelease = prerelease\nfunction prerelease (version, options) {\n  var parsed = parse(version, options)\n  return (parsed && parsed.prerelease.length) ? parsed.prerelease : null\n}\n\nexports.intersects = intersects\nfunction intersects (r1, r2, options) {\n  r1 = new Range(r1, options)\n  r2 = new Range(r2, options)\n  return r1.intersects(r2)\n}\n\nexports.coerce = coerce\nfunction coerce (version) {\n  if (version instanceof SemVer) {\n    return version\n  }\n\n  if (typeof version !== 'string') {\n    return null\n  }\n\n  var match = version.match(re[COERCE])\n\n  if (match == null) {\n    return null\n  }\n\n  return parse(match[1] +\n    '.' + (match[2] || '0') +\n    '.' + (match[3] || '0'))\n}\n","'use strict'\n\nconst LocalStorage = require('./src/storage')\n\nconst storage = new LocalStorage()\n\nmodule.exports = { storage }\n","'use strict'\n\nconst { createHook, executionAsyncId } = require('async_hooks')\nconst AsyncResourceStorage = require('./async_resource')\n\nclass AsyncHooksStorage extends AsyncResourceStorage {\n  constructor () {\n    super()\n\n    this._resources = new Map()\n  }\n\n  disable () {\n    super.disable()\n\n    this._resources.clear()\n  }\n\n  _createHook () {\n    return createHook({\n      init: this._init.bind(this),\n      destroy: this._destroy.bind(this)\n    })\n  }\n\n  _init (asyncId, type, triggerAsyncId, resource) {\n    super._init.apply(this, arguments)\n\n    this._resources.set(asyncId, resource)\n  }\n\n  _destroy (asyncId) {\n    this._resources.delete(asyncId)\n  }\n\n  _executionAsyncResource () {\n    const asyncId = executionAsyncId()\n\n    let resource = this._resources.get(asyncId)\n\n    if (!resource) {\n      this._resources.set(asyncId, resource = {})\n    }\n\n    return resource\n  }\n}\n\nmodule.exports = AsyncHooksStorage\n","'use strict'\n\nconst { createHook, executionAsyncResource } = require('async_hooks')\n\nclass AsyncResourceStorage {\n  constructor () {\n    this._ddResourceStore = Symbol('ddResourceStore')\n    this._enabled = false\n    this._hook = this._createHook()\n  }\n\n  disable () {\n    if (!this._enabled) return\n\n    this._hook.disable()\n    this._enabled = false\n  }\n\n  getStore () {\n    if (!this._enabled) return\n\n    const resource = this._executionAsyncResource()\n\n    return resource[this._ddResourceStore]\n  }\n\n  enterWith (store) {\n    this._enable()\n\n    const resource = this._executionAsyncResource()\n\n    resource[this._ddResourceStore] = store\n  }\n\n  run (store, callback, ...args) {\n    this._enable()\n\n    const resource = this._executionAsyncResource()\n    const oldStore = resource[this._ddResourceStore]\n\n    resource[this._ddResourceStore] = store\n\n    try {\n      return callback(...args)\n    } finally {\n      resource[this._ddResourceStore] = oldStore\n    }\n  }\n\n  _createHook () {\n    return createHook({\n      init: this._init.bind(this)\n    })\n  }\n\n  _enable () {\n    if (this._enabled) return\n\n    this._enabled = true\n    this._hook.enable()\n  }\n\n  _init (asyncId, type, triggerAsyncId, resource) {\n    const currentResource = this._executionAsyncResource()\n\n    if (Object.prototype.hasOwnProperty.call(currentResource, this._ddResourceStore)) {\n      resource[this._ddResourceStore] = currentResource[this._ddResourceStore]\n    }\n  }\n\n  _executionAsyncResource () {\n    return executionAsyncResource()\n  }\n}\n\nmodule.exports = AsyncResourceStorage\n","'use strict'\n\n// TODO: default to AsyncLocalStorage when it supports triggerAsyncResource\n\nconst semver = require('semver')\n\n// https://github.com/nodejs/node/pull/33801\nconst hasJavaScriptAsyncHooks = semver.satisfies(process.versions.node, '>=14.5 || ^12.19.0')\n\nif (hasJavaScriptAsyncHooks) {\n  module.exports = require('./async_resource')\n} else {\n  module.exports = require('./async_hooks')\n}\n","'use strict'\n\nrequire('./src/amqplib')\nrequire('./src/amqp10')\nrequire('./src/bluebird')\nrequire('./src/bunyan')\nrequire('./src/cassandra-driver')\nrequire('./src/couchbase')\nrequire('./src/cucumber')\nrequire('./src/dns')\nrequire('./src/elasticsearch')\nrequire('./src/generic-pool')\nrequire('./src/http')\nrequire('./src/ioredis')\nrequire('./src/memcached')\nrequire('./src/mongodb-core')\nrequire('./src/mongoose')\nrequire('./src/mysql')\nrequire('./src/mysql2')\nrequire('./src/mocha')\nrequire('./src/net')\nrequire('./src/pino')\nrequire('./src/pg')\nrequire('./src/promise')\nrequire('./src/promise-js')\nrequire('./src/q')\nrequire('./src/redis')\nrequire('./src/rhea')\nrequire('./src/sharedb')\nrequire('./src/tedious')\nrequire('./src/when')\nrequire('./src/winston')\n","'use strict'\n\nconst {\n  channel,\n  addHook,\n  AsyncResource\n} = require('./helpers/instrument')\nconst shimmer = require('../../datadog-shimmer')\n\naddHook({ name: 'amqp10', file: 'lib/sender_link.js', versions: ['>=3'] }, SenderLink => {\n  const startCh = channel('apm:amqp10:send:start')\n  const asyncEndCh = channel('apm:amqp10:send:async-end')\n  const endCh = channel('apm:amqp10:send:end')\n  const errorCh = channel('apm:amqp10:send:error')\n  shimmer.wrap(SenderLink.prototype, 'send', send => function (msg, options) {\n    if (!startCh.hasSubscribers) {\n      return send.apply(this, arguments)\n    }\n    startCh.publish({ link: this })\n    try {\n      const promise = send.apply(this, arguments)\n\n      if (!promise) {\n        finish(asyncEndCh, errorCh)\n        return promise\n      }\n\n      const asyncResource = new AsyncResource('bound-anonymous-fn')\n\n      promise.then(asyncResource.bind(() => finish(asyncEndCh, errorCh)),\n        asyncResource.bind(e => finish(asyncEndCh, errorCh, e)))\n\n      return promise\n    } catch (err) {\n      finish(asyncEndCh, errorCh, err)\n      throw err\n    } finally {\n      endCh.publish(undefined)\n    }\n  })\n  return SenderLink\n})\n\naddHook({ name: 'amqp10', file: 'lib/receiver_link.js', versions: ['>=3'] }, ReceiverLink => {\n  const startCh = channel('apm:amqp10:receive:start')\n  const endCh = channel('apm:amqp10:receive:end')\n  const errorCh = channel('apm:amqp10:receive:error')\n  shimmer.wrap(ReceiverLink.prototype, '_messageReceived', messageReceived => function (transferFrame) {\n    if (!transferFrame || transferFrame.aborted || transferFrame.more) {\n      return messageReceived.apply(this, arguments)\n    }\n    startCh.publish({ link: this })\n    try {\n      return messageReceived.apply(this, arguments)\n    } catch (err) {\n      errorCh.publish(err)\n      throw err\n    } finally {\n      endCh.publish(undefined)\n    }\n  })\n  return ReceiverLink\n})\n\nfunction finish (asyncEndCh, errorCh, error) {\n  if (error) {\n    errorCh.publish(error)\n  }\n  asyncEndCh.publish(undefined)\n}\n","'use strict'\n\nconst {\n  channel,\n  addHook\n} = require('./helpers/instrument')\nconst kebabCase = require('lodash.kebabcase')\nconst shimmer = require('../../datadog-shimmer')\n\nconst startCh = channel('apm:amqplib:command:start')\nconst endCh = channel('apm:amqplib:command:end')\nconst errorCh = channel('apm:amqplib:command:error')\n\nlet methods = {}\n\naddHook({ name: 'amqplib', file: 'lib/defs.js', versions: ['>=0.5'] }, defs => {\n  methods = Object.keys(defs)\n    .filter(key => Number.isInteger(defs[key]))\n    .filter(key => isCamelCase(key))\n    .reduce((acc, key) => Object.assign(acc, { [defs[key]]: kebabCase(key).replace('-', '.') }), {})\n  return defs\n})\n\naddHook({ name: 'amqplib', file: 'lib/channel.js', versions: ['>=0.5'] }, channel => {\n  shimmer.wrap(channel.Channel.prototype, 'sendImmediately', sendImmediately => function (method, fields) {\n    return instrument(sendImmediately, this, arguments, methods[method], fields)\n  })\n\n  shimmer.wrap(channel.Channel.prototype, 'sendMessage', sendMessage => function (fields) {\n    return instrument(sendMessage, this, arguments, 'basic.publish', fields)\n  })\n\n  shimmer.wrap(channel.BaseChannel.prototype, 'dispatchMessage', dispatchMessage => function (fields, message) {\n    return instrument(dispatchMessage, this, arguments, 'basic.deliver', fields, message)\n  })\n  return channel\n})\n\nfunction instrument (send, channel, args, method, fields, message) {\n  if (!startCh.hasSubscribers) {\n    return send.apply(channel, args)\n  }\n  startCh.publish({ channel, method, fields, message })\n\n  try {\n    return send.apply(channel, args)\n  } catch (err) {\n    errorCh.publish(err)\n\n    throw err\n  } finally {\n    endCh.publish(undefined)\n  }\n}\n\nfunction isCamelCase (str) {\n  return /([A-Z][a-z0-9]+)+/.test(str)\n}\n","'use strict'\n\nconst { addHook } = require('./helpers/instrument')\nconst { wrapThen } = require('./helpers/promise')\nconst shimmer = require('../../datadog-shimmer')\n\nfunction createGetNewLibraryCopyWrap (originalLib) {\n  return function wrapGetNewLibraryCopy (getNewLibraryCopy) {\n    return function getNewLibraryCopyWithTrace () {\n      const libraryCopy = getNewLibraryCopy.apply(this, arguments)\n      shimmer.wrap(libraryCopy.prototype, '_then', wrapThen)\n      shimmer.wrap(libraryCopy, 'getNewLibraryCopy', createGetNewLibraryCopyWrap(originalLib))\n      return libraryCopy\n    }\n  }\n}\n\naddHook({ name: 'bluebird', versions: ['>=2.0.2'] }, Promise => {\n  shimmer.wrap(Promise.prototype, '_then', wrapThen)\n  return Promise\n})\n\naddHook({ name: 'bluebird', versions: ['^2.11.0', '^3.4.1'] }, Promise => {\n  shimmer.wrap(Promise, 'getNewLibraryCopy', createGetNewLibraryCopyWrap(Promise))\n  return Promise\n})\n","'use strict'\n\nconst {\n  channel,\n  addHook\n} = require('./helpers/instrument')\nconst shimmer = require('../../datadog-shimmer')\n\naddHook({ name: 'bunyan', versions: ['>=1'] }, Logger => {\n  const logCh = channel('apm:bunyan:log')\n  shimmer.wrap(Logger.prototype, '_emit', emit => {\n    return function wrappedEmit (rec) {\n      if (logCh.hasSubscribers) {\n        const payload = { message: rec }\n        logCh.publish(payload)\n        arguments[0] = payload.message\n      }\n      return emit.apply(this, arguments)\n    }\n  })\n  return Logger\n})\n","'use strict'\n\nconst {\n  channel,\n  addHook,\n  AsyncResource\n} = require('./helpers/instrument')\nconst shimmer = require('../../datadog-shimmer')\n\nconst startCh = channel('apm:cassandra:query:start')\nconst asyncEndCh = channel('apm:cassandra:query:async-end')\nconst endCh = channel('apm:cassandra:query:end')\nconst errorCh = channel('apm:cassandra:query:error')\nconst addConnectionCh = channel(`apm:cassandra:query:addConnection`)\n\naddHook({ name: 'cassandra-driver', versions: ['>=3.0.0'] }, cassandra => {\n  shimmer.wrap(cassandra.Client.prototype, 'batch', batch => function (queries, options, callback) {\n    if (!startCh.hasSubscribers) {\n      return batch.apply(this, arguments)\n    }\n    const asyncResource = new AsyncResource('bound-anonymous-fn')\n    startCh.publish({ keyspace: this.keyspace, query: queries })\n\n    const lastIndex = arguments.length - 1\n    let cb = arguments[lastIndex]\n\n    if (typeof cb === 'function') {\n      cb = asyncResource.bind(cb)\n      arguments[lastIndex] = wrapCallback(asyncEndCh, errorCh, cb)\n    }\n\n    try {\n      const res = batch.apply(this, arguments)\n      if (typeof res === 'function' || !res) {\n        return wrapCallback(asyncEndCh, errorCh, res)\n      } else {\n        const promiseAsyncResource = new AsyncResource('bound-anonymous-fn')\n        return res.then(\n          promiseAsyncResource.bind(() => finish(asyncEndCh, errorCh)),\n          promiseAsyncResource.bind(err => finish(asyncEndCh, errorCh, err))\n        )\n      }\n    } catch (e) {\n      finish(asyncEndCh, errorCh, e)\n      throw e\n    } finally {\n      endCh.publish(undefined)\n    }\n  })\n  return cassandra\n})\n\naddHook({ name: 'cassandra-driver', versions: ['>=4.4'] }, cassandra => {\n  shimmer.wrap(cassandra.Client.prototype, '_execute', _execute => function (query, params, execOptions, callback) {\n    if (!startCh.hasSubscribers) {\n      return _execute.apply(this, arguments)\n    }\n    startCh.publish({ keyspace: this.keyspace, query })\n    const promise = _execute.apply(this, arguments)\n\n    const promiseAsyncResource = new AsyncResource('bound-anonymous-fn')\n\n    promise.then(\n      promiseAsyncResource.bind(() => finish(asyncEndCh, errorCh)),\n      promiseAsyncResource.bind(err => finish(asyncEndCh, errorCh, err))\n    )\n    endCh.publish(undefined)\n    return promise\n  })\n  return cassandra\n})\n\naddHook({ name: 'cassandra-driver', versions: ['3 - 4.3'] }, cassandra => {\n  shimmer.wrap(cassandra.Client.prototype, '_innerExecute', _innerExecute =>\n    function (query, params, execOptions, callback) {\n      if (!startCh.hasSubscribers) {\n        return _innerExecute.apply(this, arguments)\n      }\n      const asyncResource = new AsyncResource('bound-anonymous-fn')\n      const isValid = (args) => {\n        return args.length === 4 || typeof args[3] === 'function'\n      }\n\n      if (!isValid(arguments)) {\n        return _innerExecute.apply(this, arguments)\n      }\n\n      startCh.publish({ keyspace: this.keyspace, query })\n\n      const lastIndex = arguments.length - 1\n      let cb = arguments[lastIndex]\n\n      if (typeof cb === 'function') {\n        cb = asyncResource.bind(cb)\n        arguments[lastIndex] = wrapCallback(asyncEndCh, errorCh, cb)\n      }\n\n      try {\n        return _innerExecute.apply(this, arguments)\n      } catch (e) {\n        finish(asyncEndCh, errorCh, e)\n        throw e\n      } finally {\n        endCh.publish(undefined)\n      }\n    }\n  )\n  return cassandra\n})\n\naddHook({ name: 'cassandra-driver', versions: ['>=3.3'], file: 'lib/request-execution.js' }, RequestExecution => {\n  shimmer.wrap(RequestExecution.prototype, '_sendOnConnection', _sendOnConnection => function () {\n    if (!startCh.hasSubscribers) {\n      return _sendOnConnection.apply(this, arguments)\n    }\n    addConnectionCh.publish({ address: this._connection.address, port: this._connection.port })\n    return _sendOnConnection.apply(this, arguments)\n  })\n  return RequestExecution\n})\n\naddHook({ name: 'cassandra-driver', versions: ['3.3 - 4.3'], file: 'lib/request-execution.js' }, RequestExecution => {\n  shimmer.wrap(RequestExecution.prototype, 'start', start => function (getHostCallback) {\n    if (!startCh.hasSubscribers) {\n      return getHostCallback.apply(this, arguments)\n    }\n    const asyncResource = new AsyncResource('bound-anonymous-fn')\n    const execution = this\n\n    if (!isRequestValid(this, arguments, 1)) {\n      return start.apply(this, arguments)\n    }\n\n    getHostCallback = asyncResource.bind(getHostCallback)\n\n    arguments[0] = AsyncResource.bind(function () {\n      addConnectionCh.publish({ address: execution._connection.address, port: execution._connection.port })\n      return getHostCallback.apply(this, arguments)\n    })\n\n    return start.apply(this, arguments)\n  })\n  return RequestExecution\n})\n\naddHook({ name: 'cassandra-driver', versions: ['3 - 3.2'], file: 'lib/request-handler.js' }, RequestHandler => {\n  shimmer.wrap(RequestHandler.prototype, 'send', send => function (request, options, callback) {\n    if (!startCh.hasSubscribers) {\n      return send.apply(this, arguments)\n    }\n    const handler = this\n\n    if (!isRequestValid(this, arguments, 3)) {\n      return send.apply(this, arguments)\n    }\n    const asyncResource = new AsyncResource('bound-anonymous-fn')\n\n    callback = asyncResource.bind(callback)\n\n    arguments[2] = AsyncResource.bind(function () {\n      addConnectionCh.publish({ address: handler.connection.address, port: handler.connection.port })\n      return callback.apply(this, arguments)\n    })\n\n    return send.apply(this, arguments)\n  })\n  return RequestHandler\n})\n\nfunction finish (asyncEndCh, errorCh, error) {\n  if (error) {\n    errorCh.publish(error)\n  }\n  asyncEndCh.publish(undefined)\n}\n\nfunction wrapCallback (asyncEndCh, errorCh, callback) {\n  return AsyncResource.bind(function (err) {\n    finish(asyncEndCh, errorCh, err)\n    if (callback) {\n      return callback.apply(this, arguments)\n    }\n  })\n}\n\nfunction isRequestValid (exec, args, length) {\n  if (!exec) return false\n  if (args.length !== length || typeof args[length - 1] !== 'function') return false\n\n  return true\n}\n","'use strict'\n\nconst {\n  channel,\n  addHook,\n  AsyncResource\n} = require('./helpers/instrument')\nconst shimmer = require('../../datadog-shimmer')\n\naddHook({ name: 'couchbase', file: 'lib/bucket.js', versions: ['^2.6.5'] }, Bucket => {\n  const startCh = channel('apm:couchbase:query:start')\n  const asyncEndCh = channel('apm:couchbase:query:async-end')\n  const endCh = channel('apm:couchbase:query:end')\n  const errorCh = channel('apm:couchbase:query:error')\n\n  Bucket.prototype._maybeInvoke = wrapMaybeInvoke(Bucket.prototype._maybeInvoke)\n  Bucket.prototype.query = wrapQuery(Bucket.prototype.query)\n\n  shimmer.wrap(Bucket.prototype, '_n1qlReq', _n1qlReq => function (host, q, adhoc, emitter) {\n    if (!startCh.hasSubscribers) {\n      return _n1qlReq.apply(this, arguments)\n    }\n\n    if (!emitter || !emitter.once) return _n1qlReq.apply(this, arguments)\n\n    const n1qlQuery = q && q.statement\n\n    startCh.publish({ resource: n1qlQuery, bucket: this })\n\n    emitter.once('rows', AsyncResource.bind(() => {\n      asyncEndCh.publish(undefined)\n    }))\n\n    emitter.once('error', AsyncResource.bind((error) => {\n      errorCh.publish(error)\n      asyncEndCh.publish(undefined)\n    }))\n\n    try {\n      return _n1qlReq.apply(this, arguments)\n    } catch (err) {\n      err.stack // trigger getting the stack at the original throwing point\n      errorCh.publish(err)\n\n      throw err\n    } finally {\n      endCh.publish(undefined)\n    }\n  })\n\n  Bucket.prototype.upsert = wrap('apm:couchbase:upsert', Bucket.prototype.upsert)\n  Bucket.prototype.insert = wrap('apm:couchbase:insert', Bucket.prototype.insert)\n  Bucket.prototype.replace = wrap('apm:couchbase:replace', Bucket.prototype.replace)\n  Bucket.prototype.append = wrap('apm:couchbase:append', Bucket.prototype.append)\n  Bucket.prototype.prepend = wrap('apm:couchbase:prepend', Bucket.prototype.prepend)\n\n  return Bucket\n})\n\naddHook({ name: 'couchbase', file: 'lib/cluster.js', versions: ['^2.6.5'] }, Cluster => {\n  Cluster.prototype._maybeInvoke = wrapMaybeInvoke(Cluster.prototype._maybeInvoke)\n  Cluster.prototype.query = wrapQuery(Cluster.prototype.query)\n\n  return Cluster\n})\n\nfunction findCallbackIndex (args) {\n  for (let i = args.length - 1; i >= 2; i--) {\n    if (typeof args[i] === 'function') return i\n  }\n  return -1\n}\n\nfunction wrapMaybeInvoke (_maybeInvoke) {\n  const wrapped = function (fn, args) {\n    if (!Array.isArray(args)) return _maybeInvoke.apply(this, arguments)\n\n    const callbackIndex = args.length - 1\n    const callback = args[callbackIndex]\n\n    if (callback instanceof Function) {\n      args[callbackIndex] = AsyncResource.bind(callback)\n    }\n\n    return _maybeInvoke.apply(this, arguments)\n  }\n  return shimmer.wrap(_maybeInvoke, wrapped)\n}\n\nfunction wrapQuery (query) {\n  const wrapped = function (q, params, callback) {\n    callback = AsyncResource.bind(arguments[arguments.length - 1])\n\n    if (typeof callback === 'function') {\n      arguments[arguments.length - 1] = callback\n    }\n\n    const res = query.apply(this, arguments)\n    return res\n  }\n  return shimmer.wrap(query, wrapped)\n}\n\nfunction wrap (prefix, fn) {\n  const startCh = channel(prefix + ':start')\n  const endCh = channel(prefix + ':end')\n  const asyncEndCh = channel(prefix + ':async-end')\n  const errorCh = channel(prefix + ':error')\n\n  const wrapped = function (key, value, options, callback) {\n    if (!startCh.hasSubscribers) {\n      return fn.apply(this, arguments)\n    }\n\n    const callbackIndex = findCallbackIndex(arguments)\n\n    if (callbackIndex < 0) return fn.apply(this, arguments)\n\n    const cb = arguments[callbackIndex]\n\n    startCh.publish({ bucket: this })\n\n    arguments[callbackIndex] = function (error, result) {\n      if (error) {\n        errorCh.publish(error)\n      }\n      asyncEndCh.publish(result)\n      return cb.apply(this, arguments)\n    }\n\n    try {\n      return fn.apply(this, arguments)\n    } catch (error) {\n      error.stack // trigger getting the stack at the original throwing point\n      errorCh.publish(error)\n\n      throw error\n    } finally {\n      endCh.publish(undefined)\n    }\n  }\n  return shimmer.wrap(fn, wrapped)\n}\n","'use strict'\n\nconst { addHook, channel } = require('./helpers/instrument')\nconst shimmer = require('../../datadog-shimmer')\n\nconst runStartCh = channel('ci:cucumber:run:start')\nconst runEndCh = channel('ci:cucumber:run:end')\nconst runAsyncEndCh = channel('ci:cucumber:run:async-end')\nconst runStepStartCh = channel('ci:cucumber:run-step:start')\nconst runStepEndCh = channel('ci:cucumber:run-step:end')\nconst errorCh = channel('ci:cucumber:error')\n\n// TODO: remove in a later major version\nconst patched = new WeakSet()\n\nfunction getStatusFromResult (result) {\n  if (result.status === 1) {\n    return { status: 'pass' }\n  }\n  if (result.status === 2) {\n    return { status: 'skip' }\n  }\n  if (result.status === 4) {\n    return { status: 'skip', skipReason: 'not implemented' }\n  }\n  return { status: 'fail', errorMessage: result.message }\n}\n\nfunction getStatusFromResultLatest (result) {\n  if (result.status === 'PASSED') {\n    return { status: 'pass' }\n  }\n  if (result.status === 'SKIPPED' || result.status === 'PENDING') {\n    return { status: 'skip' }\n  }\n  if (result.status === 'UNDEFINED') {\n    return { status: 'skip', skipReason: 'not implemented' }\n  }\n  return { status: 'fail', errorMessage: result.message }\n}\n\nfunction wrapRun (pl, isLatestVersion) {\n  if (patched.has(pl)) return\n\n  patched.add(pl)\n\n  shimmer.wrap(pl.prototype, 'run', run => function () {\n    if (!runStartCh.hasSubscribers) {\n      return run.apply(this, arguments)\n    }\n\n    runStartCh.publish({ pickleName: this.pickle.name, pickleUri: this.pickle.uri })\n    try {\n      const promise = run.apply(this, arguments)\n      promise.finally(() => {\n        const result = this.getWorstStepResult()\n        const { status, skipReason, errorMessage } = isLatestVersion\n          ? getStatusFromResultLatest(result) : getStatusFromResult(result)\n\n        runAsyncEndCh.publish({ status, skipReason, errorMessage })\n      })\n      return promise\n    } catch (err) {\n      errorCh.publish(err)\n      throw err\n    } finally {\n      runEndCh.publish(undefined)\n    }\n  })\n  shimmer.wrap(pl.prototype, 'runStep', runStep => function () {\n    if (!runStepStartCh.hasSubscribers) {\n      return runStep.apply(this, arguments)\n    }\n    const testStep = arguments[0]\n    let resource\n\n    if (isLatestVersion) {\n      resource = testStep.text\n    } else {\n      resource = testStep.isHook ? 'hook' : testStep.pickleStep.text\n    }\n\n    runStepStartCh.publish({ resource })\n    try {\n      const promise = runStep.apply(this, arguments)\n\n      promise.then((result) => {\n        const { status, skipReason, errorMessage } = isLatestVersion\n          ? getStatusFromResultLatest(result) : getStatusFromResult(result)\n\n        runAsyncEndCh.publish({ isStep: true, status, skipReason, errorMessage })\n      })\n      return promise\n    } catch (err) {\n      errorCh.publish(err)\n      throw err\n    } finally {\n      runStepEndCh.publish(undefined)\n    }\n  })\n}\n\nfunction pickleHook (PickleRunner) {\n  const pl = PickleRunner.default\n\n  wrapRun(pl, false)\n\n  return PickleRunner\n}\n\nfunction testCaseHook (TestCaseRunner) {\n  const pl = TestCaseRunner.default\n\n  wrapRun(pl, true)\n\n  return TestCaseRunner\n}\n\naddHook({\n  name: '@cucumber/cucumber',\n  versions: ['7.0.0 - 7.2.1'],\n  file: 'lib/runtime/pickle_runner.js'\n}, pickleHook)\n\naddHook({\n  name: '@cucumber/cucumber',\n  versions: ['>=7.3.0'],\n  file: 'lib/runtime/test_case_runner.js'\n}, testCaseHook)\n\nmodule.exports = { pickleHook, testCaseHook }\n","'use strict'\n\nconst { channel, addHook, AsyncResource } = require('./helpers/instrument')\nconst shimmer = require('../../datadog-shimmer')\n\nconst rrtypes = {\n  resolveAny: 'ANY',\n  resolve4: 'A',\n  resolve6: 'AAAA',\n  resolveCname: 'CNAME',\n  resolveMx: 'MX',\n  resolveNs: 'NS',\n  resolveTxt: 'TXT',\n  resolveSrv: 'SRV',\n  resolvePtr: 'PTR',\n  resolveNaptr: 'NAPTR',\n  resolveSoa: 'SOA'\n}\n\nconst rrtypeMap = new WeakMap()\n\naddHook({ name: 'dns' }, dns => {\n  dns.lookup = wrap('apm:dns:lookup', dns.lookup, 2)\n  dns.lookupService = wrap('apm:dns:lookup_service', dns.lookupService, 3)\n  dns.resolve = wrap('apm:dns:resolve', dns.resolve, 2)\n  dns.reverse = wrap('apm:dns:reverse', dns.reverse, 2)\n\n  patchResolveShorthands(dns)\n\n  if (dns.Resolver) {\n    dns.Resolver.prototype.resolve = wrap('apm:dns:resolve', dns.Resolver.prototype.resolve, 2)\n    dns.Resolver.prototype.reverse = wrap('apm:dns:reverse', dns.Resolver.prototype.reverse, 2)\n\n    patchResolveShorthands(dns.Resolver.prototype)\n  }\n\n  return dns\n})\n\nfunction patchResolveShorthands (prototype) {\n  Object.keys(rrtypes)\n    .filter(method => !!prototype[method])\n    .forEach(method => {\n      rrtypeMap.set(prototype[method], rrtypes[method])\n      prototype[method] = wrap('apm:dns:resolve', prototype[method], 2, rrtypes[method])\n    })\n}\n\nfunction wrap (prefix, fn, expectedArgs, rrtype) {\n  const startCh = channel(prefix + ':start')\n  const endCh = channel(prefix + ':end')\n  const asyncEndCh = channel(prefix + ':async-end')\n  const errorCh = channel(prefix + ':error')\n\n  const wrapped = function () {\n    const cb = AsyncResource.bind(arguments[arguments.length - 1])\n    if (\n      !startCh.hasSubscribers ||\n      arguments.length < expectedArgs ||\n      typeof cb !== 'function'\n    ) {\n      return fn.apply(this, arguments)\n    }\n\n    const startArgs = Array.from(arguments)\n    startArgs.pop() // gets rid of the callback\n    if (rrtype) {\n      startArgs.push(rrtype)\n    }\n    startCh.publish(startArgs)\n\n    arguments[arguments.length - 1] = function (error, result) {\n      if (error) {\n        errorCh.publish(error)\n      }\n      asyncEndCh.publish(result)\n      cb.apply(this, arguments)\n    }\n\n    try {\n      return fn.apply(this, arguments)\n      // TODO deal with promise versions when we support `dns/promises`\n    } catch (error) {\n      error.stack // trigger getting the stack at the original throwing point\n      errorCh.publish(error)\n\n      throw error\n    } finally {\n      endCh.publish(undefined)\n    }\n  }\n\n  return shimmer.wrap(fn, wrapped)\n}\n","'use strict'\n\nconst {\n  channel,\n  addHook,\n  AsyncResource\n} = require('./helpers/instrument')\nconst shimmer = require('../../datadog-shimmer')\n\nconst startCh = channel('apm:elasticsearch:query:start')\nconst asyncEndCh = channel('apm:elasticsearch:query:async-end')\nconst endCh = channel('apm:elasticsearch:query:end')\nconst errorCh = channel('apm:elasticsearch:query:error')\n\naddHook({ name: '@elastic/transport', file: 'lib/Transport.js', versions: ['>=8'] }, (exports) => {\n  shimmer.wrap(exports.default.prototype, 'request', wrapRequest)\n  return exports\n})\n\naddHook({ name: '@elastic/elasticsearch', file: 'lib/Transport.js', versions: ['>=5.6.16 <8', '>=8'] }, Transport => {\n  shimmer.wrap(Transport.prototype, 'request', wrapRequest)\n  return Transport\n})\n\naddHook({ name: 'elasticsearch', file: 'src/lib/transport.js', versions: ['>=10'] }, Transport => {\n  shimmer.wrap(Transport.prototype, 'request', wrapRequest)\n  return Transport\n})\n\nfunction wrapRequest (request) {\n  return function (params, options, cb) {\n    if (!startCh.hasSubscribers) {\n      return request.apply(this, arguments)\n    }\n\n    if (!params) return request.apply(this, arguments)\n\n    const parentResource = new AsyncResource('bound-anonymous-fn')\n\n    startCh.publish({ params })\n\n    const asyncResource = new AsyncResource('bound-anonymous-fn')\n\n    try {\n      const lastIndex = arguments.length - 1\n      cb = arguments[lastIndex]\n\n      if (typeof cb === 'function') {\n        cb = parentResource.bind(cb)\n\n        arguments[lastIndex] = asyncResource.bind(function (error) {\n          finish(params, error)\n          return cb.apply(null, arguments)\n        })\n        return request.apply(this, arguments)\n      } else {\n        const promise = request.apply(this, arguments)\n        if (promise && typeof promise.then === 'function') {\n          const onResolve = asyncResource.bind(() => finish(params))\n          const onReject = asyncResource.bind(e => finish(params, e))\n\n          promise.then(onResolve, onReject)\n        } else {\n          finish(params)\n        }\n        return promise\n      }\n    } catch (err) {\n      err.stack // trigger getting the stack at the original throwing point\n      errorCh.publish(err)\n\n      throw err\n    } finally {\n      endCh.publish(undefined)\n    }\n  }\n}\n\nfunction finish (params, error) {\n  if (error) {\n    errorCh.publish(error)\n  }\n  asyncEndCh.publish({ params })\n}\n","'use strict'\n\nconst { addHook, AsyncResource } = require('./helpers/instrument')\nconst shimmer = require('../../datadog-shimmer')\n\nfunction createWrapAcquire () {\n  return function wrapAcquire (acquire) {\n    return function acquireWithTrace (callback, priority) {\n      if (typeof callback === 'function') {\n        arguments[0] = AsyncResource.bind(callback)\n      }\n\n      return acquire.apply(this, arguments)\n    }\n  }\n}\n\nfunction createWrapPool () {\n  return function wrapPool (Pool) {\n    if (typeof Pool !== 'function') return Pool\n\n    return function PoolWithTrace (factory) {\n      const pool = Pool.apply(this, arguments)\n\n      if (pool && typeof pool.acquire === 'function') {\n        shimmer.wrap(pool, 'acquire', createWrapAcquire())\n      }\n\n      return pool\n    }\n  }\n}\n\naddHook({\n  name: 'generic-pool',\n  versions: ['^2.4']\n}, genericPool => {\n  shimmer.wrap(genericPool.Pool.prototype, 'acquire', createWrapAcquire())\n  return genericPool\n})\n\naddHook({\n  name: 'generic-pool',\n  versions: ['2 - 2.3']\n}, genericPool => {\n  shimmer.wrap(genericPool, 'Pool', createWrapPool())\n  return genericPool\n})\n","'use strict'\n\nconst path = require('path')\nconst iitm = require('../../../dd-trace/src/iitm')\nconst ritm = require('../../../dd-trace/src/ritm')\n\nfunction Hook (modules, onrequire) {\n  if (!(this instanceof Hook)) return new Hook(modules, onrequire)\n\n  this._patched = Object.create(null)\n\n  const safeHook = (moduleExports, moduleName, moduleBaseDir) => {\n    const parts = [moduleBaseDir, moduleName].filter(v => v)\n    const filename = path.join(...parts)\n\n    if (this._patched[filename]) return moduleExports\n\n    this._patched[filename] = true\n\n    return onrequire(moduleExports, moduleName, moduleBaseDir)\n  }\n\n  this._ritmHook = ritm(modules, {}, safeHook)\n  this._iitmHook = iitm(modules, {}, (moduleExports, moduleName, moduleBaseDir) => {\n    // TODO: Move this logic to import-in-the-middle and only do it for CommonJS\n    // modules and not ESM. In the meantime, all the modules we instrument are\n    // CommonJS modules for which the default export is always moved to\n    // `default` anyway.\n    if (moduleExports && moduleExports.default) {\n      moduleExports.default = safeHook(moduleExports.default, moduleName, moduleBaseDir)\n      return moduleExports\n    } else {\n      return safeHook(moduleExports, moduleName, moduleBaseDir)\n    }\n  })\n}\n\nHook.prototype.unhook = function () {\n  this._ritmHook.unhook()\n  this._iitmHook.unhook()\n  this._patched = Object.create(null)\n}\n\nmodule.exports = Hook\n","'use strict'\n\nconst dc = require('diagnostics_channel')\nconst path = require('path')\nconst semver = require('semver')\nconst Hook = require('./hook')\nconst requirePackageJson = require('../../../dd-trace/src/require-package-json')\nconst { AsyncResource } = require('async_hooks')\nconst log = require('../../../dd-trace/src/log')\n\nconst pathSepExpr = new RegExp(`\\\\${path.sep}`, 'g')\nconst channelMap = {}\nexports.channel = function channel (name) {\n  const maybe = channelMap[name]\n  if (maybe) return maybe\n  const ch = dc.channel(name)\n  channelMap[name] = ch\n  return ch\n}\n\nexports.addHook = function addHook ({ name, versions, file }, hook) {\n  const fullFilename = filename(name, file)\n\n  Hook([name], (moduleExports, moduleName, moduleBaseDir) => {\n    moduleName = moduleName.replace(pathSepExpr, '/')\n\n    if (moduleName !== fullFilename || !matchVersion(getVersion(moduleBaseDir), versions)) {\n      return moduleExports\n    }\n\n    try {\n      return hook(moduleExports)\n    } catch (e) {\n      log.error(e)\n      return moduleExports\n    }\n  })\n}\n\nfunction matchVersion (version, ranges) {\n  return !version || (ranges && ranges.some(range => semver.satisfies(semver.coerce(version), range)))\n}\n\nfunction getVersion (moduleBaseDir) {\n  if (moduleBaseDir) {\n    return requirePackageJson(moduleBaseDir, module).version\n  }\n}\n\nfunction filename (name, file) {\n  return [name, file].filter(val => val).join('/')\n}\n\n// AsyncResource.bind exists and binds `this` properly only from 17.8.0 and up.\n// https://nodejs.org/api/async_context.html#asyncresourcebindfn-thisarg\nif (semver.satisfies(process.versions.node, '>=17.8.0')) {\n  exports.AsyncResource = AsyncResource\n} else {\n  exports.AsyncResource = class extends AsyncResource {\n    static bind (fn, type, thisArg) {\n      type = type || fn.name\n      return (new exports.AsyncResource(type || 'bound-anonymous-fn')).bind(fn, thisArg)\n    }\n\n    bind (fn, thisArg) {\n      let bound\n      if (thisArg === undefined) {\n        const resource = this\n        bound = function (...args) {\n          args.unshift(fn, this)\n          return Reflect.apply(resource.runInAsyncScope, resource, args)\n        }\n      } else {\n        bound = this.runInAsyncScope.bind(this, fn, thisArg)\n      }\n      Object.defineProperties(bound, {\n        'length': {\n          configurable: true,\n          enumerable: false,\n          value: fn.length,\n          writable: false\n        },\n        'asyncResource': {\n          configurable: true,\n          enumerable: true,\n          value: this,\n          writable: true\n        }\n      })\n      return bound\n    }\n  }\n}\n","'use strict'\n\nconst { AsyncResource } = require('async_hooks')\n\nexports.wrapThen = function wrapThen (origThen) {\n  return function then (onFulfilled, onRejected, onProgress) {\n    const ar = new AsyncResource('bound-anonymous-fn')\n\n    arguments[0] = wrapCallback(ar, onFulfilled)\n    arguments[1] = wrapCallback(ar, onRejected)\n\n    // not standard but sometimes supported\n    if (onProgress) {\n      arguments[2] = wrapCallback(ar, onProgress)\n    }\n\n    return origThen.apply(this, arguments)\n  }\n}\n\nfunction wrapCallback (ar, callback) {\n  if (typeof callback !== 'function') return callback\n\n  return function () {\n    return ar.runInAsyncScope(() => {\n      return callback.apply(this, arguments)\n    })\n  }\n}\n","'use strict'\n\nrequire('./http/client')\nrequire('./http/server')\n","'use strict'\n\n/* eslint-disable no-fallthrough */\n\nconst url = require('url')\nconst {\n  channel,\n  addHook,\n  AsyncResource\n} = require('../helpers/instrument')\nconst shimmer = require('../../../datadog-shimmer')\n\nconst log = require('../../../dd-trace/src/log')\n\nconst startClientCh = channel('apm:http:client:request:start')\nconst asyncEndClientCh = channel('apm:http:client:request:async-end')\nconst endClientCh = channel('apm:http:client:request:end')\nconst errorClientCh = channel('apm:http:client:request:error')\n\naddHook({ name: 'https' }, hookFn)\n\naddHook({ name: 'http' }, hookFn)\n\nfunction hookFn (http) {\n  patch(http, 'request')\n  patch(http, 'get')\n\n  return http\n}\n\nfunction patch (http, methodName) {\n  shimmer.wrap(http, methodName, instrumentRequest)\n\n  function instrumentRequest (request) {\n    return function () {\n      if (!startClientCh.hasSubscribers) {\n        return request.apply(this, arguments)\n      }\n      const asyncResource = new AsyncResource('bound-anonymous-fn')\n\n      let args\n\n      try {\n        args = normalizeArgs.apply(null, arguments)\n      } catch (e) {\n        log.error(e)\n        return request.apply(this, arguments)\n      }\n      startClientCh.publish({ args, http })\n\n      const ar = new AsyncResource('bound-anonymous-fn')\n\n      let finished = false\n      let callback = args.callback\n\n      if (callback) {\n        callback = asyncResource.bind(callback)\n      }\n\n      const options = args.options\n      const req = ar.bind(request).call(this, options, callback)\n      const emit = req.emit\n\n      const finish = (req, res) => {\n        if (!finished) {\n          finished = true\n          asyncEndClientCh.publish({ req, res })\n        }\n      }\n\n      req.emit = function (eventName, arg) {\n        ar.runInAsyncScope(() => {\n          switch (eventName) {\n            case 'response': {\n              const res = arg\n              const listener = ar.bind(() => finish(req, res))\n              res.on('end', listener)\n              res.on('error', listener)\n              break\n            }\n            case 'connect':\n            case 'upgrade':\n              finish(req, arg)\n              break\n            case 'error':\n              errorClientCh.publish(arg)\n            case 'abort': // deprecated and replaced by `close` in node 17\n            case 'timeout':\n            case 'close':\n              finish(req)\n          }\n        })\n\n        return emit.apply(this, arguments)\n      }\n\n      endClientCh.publish(undefined)\n\n      return req\n    }\n  }\n\n  function normalizeArgs (inputURL, inputOptions, cb) {\n    inputURL = normalizeOptions(inputURL)\n\n    const [callback, inputOptionsNormalized] = normalizeCallback(inputOptions, cb, inputURL)\n    const options = combineOptions(inputURL, inputOptionsNormalized)\n    normalizeHeaders(options)\n    const uri = url.format(options)\n\n    return { uri, options, callback }\n  }\n\n  function combineOptions (inputURL, inputOptions) {\n    if (typeof inputOptions === 'object') {\n      return Object.assign(inputURL || {}, inputOptions)\n    } else {\n      return inputURL\n    }\n  }\n  function normalizeHeaders (options) {\n    options.headers = options.headers || {}\n  }\n\n  function normalizeCallback (inputOptions, callback, inputURL) {\n    if (typeof inputOptions === 'function') {\n      return [inputOptions, inputURL || {}]\n    } else {\n      return [callback, inputOptions]\n    }\n  }\n\n  function normalizeOptions (inputURL) {\n    if (typeof inputURL === 'string') {\n      try {\n        return urlToOptions(new url.URL(inputURL))\n      } catch (e) {\n        return url.parse(inputURL)\n      }\n    } else if (inputURL instanceof url.URL) {\n      return urlToOptions(inputURL)\n    } else {\n      return inputURL\n    }\n  }\n\n  function urlToOptions (url) {\n    const agent = url.agent || http.globalAgent\n    const options = {\n      protocol: url.protocol || agent.protocol,\n      hostname: typeof url.hostname === 'string' && url.hostname.startsWith('[')\n        ? url.hostname.slice(1, -1)\n        : url.hostname ||\n          url.host ||\n          'localhost',\n      hash: url.hash,\n      search: url.search,\n      pathname: url.pathname,\n      path: `${url.pathname || ''}${url.search || ''}`,\n      href: url.href\n    }\n    if (url.port !== '') {\n      options.port = Number(url.port)\n    }\n    if (url.username || url.password) {\n      options.auth = `${url.username}:${url.password}`\n    }\n    return options\n  }\n}\n","'use strict'\n\nconst {\n  channel,\n  addHook\n} = require('../helpers/instrument')\nconst shimmer = require('../../../datadog-shimmer')\n\nconst startServerCh = channel('apm:http:server:request:start')\nconst endServerCh = channel('apm:http:server:request:end')\nconst errorServerCh = channel('apm:http:server:request:error')\nconst asyncEndServerCh = channel('apm:http:server:request:async-end')\n\naddHook({ name: 'https' }, http => {\n  // http.ServerResponse not present on https\n  shimmer.wrap(http.Server.prototype, 'emit', wrapEmit)\n  return http\n})\n\naddHook({ name: 'http' }, http => {\n  shimmer.wrap(http.ServerResponse.prototype, 'emit', wrapResponseEmit)\n  shimmer.wrap(http.Server.prototype, 'emit', wrapEmit)\n  return http\n})\n\nfunction wrapResponseEmit (emit) {\n  return function (eventName, event) {\n    if (!startServerCh.hasSubscribers) {\n      return emit.apply(this, arguments)\n    }\n\n    if (eventName === 'finish') {\n      asyncEndServerCh.publish({ req: this.req })\n    }\n\n    return emit.apply(this, arguments)\n  }\n}\nfunction wrapEmit (emit) {\n  return function (eventName, req, res) {\n    if (!startServerCh.hasSubscribers) {\n      return emit.apply(this, arguments)\n    }\n\n    if (eventName === 'request') {\n      res.req = req\n      startServerCh.publish({ req, res })\n\n      try {\n        return emit.apply(this, arguments)\n      } catch (err) {\n        errorServerCh.publish(err)\n\n        throw err\n      } finally {\n        endServerCh.publish(undefined)\n      }\n    }\n    return emit.apply(this, arguments)\n  }\n}\n","'use strict'\n\nconst {\n  channel,\n  addHook,\n  AsyncResource\n} = require('./helpers/instrument')\nconst shimmer = require('../../datadog-shimmer')\n\nconst startCh = channel('apm:ioredis:command:start')\nconst asyncEndCh = channel('apm:ioredis:command:async-end')\nconst endCh = channel('apm:ioredis:command:end')\nconst errorCh = channel('apm:ioredis:command:error')\n\naddHook({ name: 'ioredis', versions: ['>=2'] }, Redis => {\n  shimmer.wrap(Redis.prototype, 'sendCommand', sendCommand => function (command, stream) {\n    if (!startCh.hasSubscribers) return sendCommand.apply(this, arguments)\n\n    if (!command || !command.promise) return sendCommand.apply(this, arguments)\n\n    const options = this.options || {}\n    const connectionName = options.connectionName\n    const db = options.db\n    const connectionOptions = { host: options.host, port: options.port }\n\n    startCh.publish({ db, command: command.name, args: command.args, connectionOptions, connectionName })\n\n    const asyncResource = new AsyncResource('bound-anonymous-fn')\n    const onResolve = asyncResource.bind(() => finish(asyncEndCh, errorCh))\n    const onReject = asyncResource.bind(err => finish(asyncEndCh, errorCh, err))\n\n    command.promise.then(onResolve, onReject)\n\n    try {\n      return sendCommand.apply(this, arguments)\n    } catch (err) {\n      errorCh.publish(err)\n\n      throw err\n    } finally {\n      endCh.publish(undefined)\n    }\n  })\n  return Redis\n})\n\nfunction finish (asyncEndCh, errorCh, error) {\n  if (error) {\n    errorCh.publish(error)\n  }\n  asyncEndCh.publish(undefined)\n}\n","'use strict'\n\nconst {\n  channel,\n  addHook,\n  AsyncResource\n} = require('./helpers/instrument')\nconst shimmer = require('../../datadog-shimmer')\n\naddHook({ name: 'memcached', versions: ['>=2.2'] }, Memcached => {\n  const startCh = channel('apm:memcached:command:start')\n  const startWithArgsCh = channel('apm:memcached:command:start:with-args')\n  const asyncEndCh = channel('apm:memcached:command:async-end')\n  const endCh = channel('apm:memcached:command:end')\n  const errorCh = channel('apm:memcached:command:error')\n\n  shimmer.wrap(Memcached.prototype, 'command', command => function (queryCompiler, server) {\n    if (!startCh.hasSubscribers) {\n      return command.apply(this, arguments)\n    }\n\n    const asyncResource = new AsyncResource('bound-anonymous-fn')\n\n    const client = this\n\n    const wrappedQueryCompiler = function () {\n      const query = queryCompiler.apply(this, arguments)\n      const callback = asyncResource.bind(query.callback)\n\n      query.callback = AsyncResource.bind(function (err) {\n        if (err) {\n          errorCh.publish(err)\n        }\n        asyncEndCh.publish(undefined)\n\n        return callback.apply(this, arguments)\n      })\n      startWithArgsCh.publish({ client, server, query })\n\n      return query\n    }\n\n    startCh.publish(undefined)\n\n    arguments[0] = wrappedQueryCompiler\n\n    const result = command.apply(this, arguments)\n    endCh.publish(undefined)\n    return result\n  })\n\n  return Memcached\n})\n","const { addHook, channel, AsyncResource } = require('./helpers/instrument')\nconst shimmer = require('../../datadog-shimmer')\n\nconst testStartCh = channel('ci:mocha:test:start')\nconst errorCh = channel('ci:mocha:test:error')\nconst skipCh = channel('ci:mocha:test:skip')\nconst testEndCh = channel('ci:mocha:test:end')\nconst testAsyncEndCh = channel('ci:mocha:test:async-end')\nconst suiteEndCh = channel('ci:mocha:suite:end')\nconst hookErrorCh = channel('ci:mocha:hook:error')\nconst parameterizedTestCh = channel('ci:mocha:test:parameterize')\nconst testRunEndCh = channel('ci:mocha:run:end')\n\n// TODO: remove when root hooks and fixtures are implemented\nconst patched = new WeakSet()\n\nfunction isRetry (test) {\n  return test._currentRetry !== undefined && test._currentRetry !== 0\n}\n\nfunction getAllTestsInSuite (root) {\n  const tests = []\n  function getTests (suiteOrTest) {\n    suiteOrTest.tests.forEach(test => {\n      tests.push(test)\n    })\n    suiteOrTest.suites.forEach(suite => {\n      getTests(suite)\n    })\n  }\n  getTests(root)\n  return tests\n}\n\nfunction mochaHook (Runner) {\n  if (patched.has(Runner)) return Runner\n\n  patched.add(Runner)\n\n  shimmer.wrap(Runner.prototype, 'runTest', runTest => function () {\n    if (!testStartCh.hasSubscribers) {\n      return runTest.apply(this, arguments)\n    }\n\n    if (!isRetry(this.test)) {\n      testStartCh.publish(this.test)\n    }\n\n    this.once('test end', AsyncResource.bind(() => {\n      let status\n\n      if (this.test.pending) {\n        status = 'skipped'\n      } else if (this.test.state !== 'failed' && !this.test.timedOut) {\n        status = 'pass'\n      } else {\n        status = 'fail'\n      }\n\n      testAsyncEndCh.publish(status)\n    }))\n\n    this.once('fail', AsyncResource.bind((test, err) => {\n      errorCh.publish(err)\n    }))\n\n    this.once('pending', AsyncResource.bind((test) => {\n      skipCh.publish(test)\n    }))\n\n    try {\n      return runTest.apply(this, arguments)\n    } catch (err) {\n      errorCh.publish(err)\n      throw err\n    } finally {\n      testEndCh.publish(undefined)\n    }\n  })\n\n  shimmer.wrap(Runner.prototype, 'runTests', runTests => function () {\n    if (!suiteEndCh.hasSubscribers) {\n      return runTests.apply(this, arguments)\n    }\n    this.once('end', AsyncResource.bind(() => {\n      testRunEndCh.publish(undefined)\n    }))\n    runTests.apply(this, arguments)\n    const suite = arguments[0]\n    // We call `getAllTestsInSuite` with the root suite so every skipped test\n    // should already have an associated test span.\n    const tests = getAllTestsInSuite(suite)\n    suiteEndCh.publish(tests)\n  })\n\n  shimmer.wrap(Runner.prototype, 'fail', fail => function (hook, error) {\n    if (!hookErrorCh.hasSubscribers) {\n      return fail.apply(this, arguments)\n    }\n    if (error && hook.ctx && hook.ctx.currentTest) {\n      error.message = `${hook.title}: ${error.message}`\n      hookErrorCh.publish({ test: hook.ctx.currentTest, error })\n    }\n    return fail.apply(this, arguments)\n  })\n\n  return Runner\n}\n\nfunction mochaEachHook (mochaEach) {\n  if (patched.has(mochaEach)) return mochaEach\n\n  patched.add(mochaEach)\n\n  return shimmer.wrap(mochaEach, function () {\n    const [params] = arguments\n    const { it, ...rest } = mochaEach.apply(this, arguments)\n    return {\n      it: function (name) {\n        parameterizedTestCh.publish({ name, params })\n        it.apply(this, arguments)\n      },\n      ...rest\n    }\n  })\n}\n\naddHook({\n  name: 'mocha',\n  versions: ['>=5.2.0'],\n  file: 'lib/runner.js'\n}, mochaHook)\n\naddHook({\n  name: 'mocha-each',\n  versions: ['>=2.0.1']\n}, mochaEachHook)\n\nmodule.exports = { mochaHook, mochaEachHook }\n","'use strict'\n\nconst {\n  channel,\n  addHook,\n  AsyncResource\n} = require('./helpers/instrument')\nconst shimmer = require('../../datadog-shimmer')\n\nconst startCh = channel(`apm:mongodb:query:start`)\nconst endCh = channel(`apm:mongodb:query:end`)\nconst asyncEndCh = channel(`apm:mongodb:query:async-end`)\nconst errorCh = channel(`apm:mongodb:query:error`)\n\naddHook({ name: 'mongodb-core', versions: ['2 - 3.1.9'] }, Server => {\n  const serverProto = Server.Server.prototype\n  shimmer.wrap(serverProto, 'command', command => wrapCommand(command, 'command'))\n  shimmer.wrap(serverProto, 'insert', insert => wrapCommand(insert, 'insert', 'insert'))\n  shimmer.wrap(serverProto, 'update', update => wrapCommand(update, 'update', 'update'))\n  shimmer.wrap(serverProto, 'remove', remove => wrapCommand(remove, 'remove', 'remove'))\n\n  const cursorProto = Server.Cursor.prototype\n  shimmer.wrap(cursorProto, '_getmore', _getmore => wrapCursor(_getmore, 'getMore', 'getMore'))\n  shimmer.wrap(cursorProto, '_find', _find => wrapQuery(_find, '_find'))\n  shimmer.wrap(cursorProto, 'kill', kill => wrapCursor(kill, 'killCursors', 'killCursors'))\n  return Server\n})\n\naddHook({ name: 'mongodb', versions: ['>=4'], file: 'lib/cmap/connection.js' }, Connection => {\n  const proto = Connection.Connection.prototype\n  shimmer.wrap(proto, 'command', command => wrapConnectionCommand(command, 'command'))\n  shimmer.wrap(proto, 'query', query => wrapConnectionCommand(query, 'query'))\n  return Connection\n})\n\naddHook({ name: 'mongodb', versions: ['>=3.3 <4'], file: 'lib/core/wireprotocol/index.js' }, wp => wrapWp(wp))\n\naddHook({ name: 'mongodb-core', versions: ['>=3.2'], file: 'lib/wireprotocol/index.js' }, wp => wrapWp(wp))\n\naddHook({ name: 'mongodb-core', versions: ['~3.1.10'], file: 'lib/wireprotocol/3_2_support.js' }, WireProtocol => {\n  shimmer.wrap(WireProtocol.prototype, 'command', command => wrapUnifiedCommand(command, 'command'))\n  return WireProtocol\n})\n\naddHook({ name: 'mongodb-core', versions: ['~3.1.10'], file: 'lib/wireprotocol/2_6_support.js' }, WireProtocol => {\n  shimmer.wrap(WireProtocol.prototype, 'command', command => wrapUnifiedCommand(command, 'command'))\n  return WireProtocol\n})\n\naddHook({ name: 'mongodb', versions: ['>=3.5.4'], file: 'lib/utils.js' }, util => {\n  shimmer.wrap(util, 'maybePromise', maybePromise => function (parent, callback, fn) {\n    const asyncResource = new AsyncResource('bound-anonymous-fn')\n    const callbackIndex = arguments.length - 2\n\n    callback = arguments[callbackIndex]\n\n    if (typeof callback === 'function') {\n      arguments[callbackIndex] = asyncResource.bind(callback)\n    }\n\n    return maybePromise.apply(this, arguments)\n  })\n  return util\n})\n\nfunction wrapWp (wp) {\n  shimmer.wrap(wp, 'command', command => wrapUnifiedCommand(command, 'command'))\n  shimmer.wrap(wp, 'insert', insert => wrapUnifiedCommand(insert, 'insert', 'insert'))\n  shimmer.wrap(wp, 'update', update => wrapUnifiedCommand(update, 'update', 'update'))\n  shimmer.wrap(wp, 'remove', remove => wrapUnifiedCommand(remove, 'remove', 'remove'))\n  shimmer.wrap(wp, 'query', query => wrapUnifiedCommand(query, 'query'))\n  shimmer.wrap(wp, 'getMore', getMore => wrapUnifiedCommand(getMore, 'getMore', 'getMore'))\n  shimmer.wrap(wp, 'killCursors', killCursors => wrapUnifiedCommand(killCursors, 'killCursors', 'killCursors'))\n  return wp\n}\n\nfunction wrapUnifiedCommand (command, operation, name) {\n  const wrapped = function (server, ns, ops) {\n    if (!startCh.hasSubscribers) {\n      return command.apply(this, arguments)\n    }\n    const asyncResource = new AsyncResource('bound-anonymous-fn')\n    return instrument(asyncResource, operation, command, this, arguments, server, ns, ops, { name })\n  }\n  return shimmer.wrap(command, wrapped)\n}\n\nfunction wrapConnectionCommand (command, operation, name) {\n  const wrapped = function (ns, ops) {\n    if (!startCh.hasSubscribers) {\n      return command.apply(this, arguments)\n    }\n    const asyncResource = new AsyncResource('bound-anonymous-fn')\n    const hostParts = typeof this.address === 'string' ? this.address.split(':') : ''\n    const options = hostParts.length === 2\n      ? { host: hostParts[0], port: hostParts[1] }\n      : {} // no port means the address is a random UUID so no host either\n    const topology = { s: { options } }\n\n    ns = `${ns.db}.${ns.collection}`\n    return instrument(asyncResource, operation, command, this, arguments, topology, ns, ops, { name })\n  }\n  return shimmer.wrap(command, wrapped)\n}\n\nfunction wrapQuery (query, operation, name) {\n  const wrapped = function () {\n    if (!startCh.hasSubscribers) {\n      return query.apply(this, arguments)\n    }\n    const asyncResource = new AsyncResource('bound-anonymous-fn')\n    const pool = this.server.s.pool\n    const ns = this.ns\n    const ops = this.cmd\n    return instrument(asyncResource, operation, query, this, arguments, pool, ns, ops)\n  }\n\n  return shimmer.wrap(query, wrapped)\n}\n\nfunction wrapCursor (cursor, operation, name) {\n  const wrapped = function () {\n    if (!startCh.hasSubscribers) {\n      return cursor.apply(this, arguments)\n    }\n    const asyncResource = new AsyncResource('bound-anonymous-fn')\n    const pool = this.server.s.pool\n    const ns = this.ns\n    return instrument(asyncResource, operation, cursor, this, arguments, pool, ns, {}, { name })\n  }\n  return shimmer.wrap(cursor, wrapped)\n}\n\nfunction wrapCommand (command, operation, name) {\n  const wrapped = function (ns, ops) {\n    if (!startCh.hasSubscribers) {\n      return command.apply(this, arguments)\n    }\n    const asyncResource = new AsyncResource('bound-anonymous-fn')\n    return instrument(asyncResource, operation, command, this, arguments, this, ns, ops, { name })\n  }\n  return shimmer.wrap(command, wrapped)\n}\n\nfunction instrument (ar, operation, command, ctx, args, server, ns, ops, options = {}) {\n  const name = options.name || (ops && Object.keys(ops)[0])\n  const index = args.length - 1\n  let callback = args[index]\n\n  if (typeof callback !== 'function') return command.apply(ctx, args)\n\n  callback = ar.bind(callback)\n\n  const serverInfo = server && server.s && server.s.options\n\n  startCh.publish({ ns, ops, options: serverInfo, name })\n\n  args[index] = AsyncResource.bind(function (err, res) {\n    if (err) {\n      errorCh.publish(err)\n    }\n\n    asyncEndCh.publish(undefined)\n\n    if (callback) {\n      return callback.apply(this, arguments)\n    }\n  })\n\n  try {\n    return command.apply(ctx, args)\n  } catch (err) {\n    errorCh.publish(err)\n\n    throw err\n  } finally {\n    endCh.publish(undefined)\n  }\n}\n","'use strict'\n\nconst { addHook } = require('./helpers/instrument')\nconst { wrapThen } = require('./helpers/promise')\nconst { AsyncResource } = require('./helpers/instrument')\nconst shimmer = require('../../datadog-shimmer')\n\nfunction wrapAddQueue (addQueue) {\n  return function addQueueWithTrace (name) {\n    if (typeof name === 'function') {\n      arguments[0] = AsyncResource.bind(name)\n    } else if (typeof this[name] === 'function') {\n      arguments[0] = AsyncResource.bind((...args) => this[name](...args))\n    }\n\n    return addQueue.apply(this, arguments)\n  }\n}\n\naddHook({\n  name: 'mongoose',\n  versions: ['>=4.6.4']\n}, mongoose => {\n  if (mongoose.Promise !== global.Promise) {\n    shimmer.wrap(mongoose.Promise.prototype, 'then', wrapThen)\n  }\n\n  shimmer.wrap(mongoose.Collection.prototype, 'addQueue', wrapAddQueue)\n  return mongoose\n})\n","'use strict'\n\nconst {\n  channel,\n  addHook,\n  AsyncResource\n} = require('./helpers/instrument')\nconst shimmer = require('../../datadog-shimmer')\n\naddHook({ name: 'mysql', file: 'lib/Connection.js', versions: ['>=2'] }, Connection => {\n  const startCh = channel('apm:mysql:query:start')\n  const asyncEndCh = channel('apm:mysql:query:async-end')\n  const endCh = channel('apm:mysql:query:end')\n  const errorCh = channel('apm:mysql:query:error')\n\n  shimmer.wrap(Connection.prototype, 'query', query => function () {\n    const asyncResource = new AsyncResource('bound-anonymous-fn')\n    if (!startCh.hasSubscribers) {\n      return query.apply(this, arguments)\n    }\n\n    const sql = arguments[0].sql ? arguments[0].sql : arguments[0]\n    const conf = this.config\n\n    startCh.publish({ sql, conf })\n\n    try {\n      const res = query.apply(this, arguments)\n\n      if (res._callback) {\n        const cb = asyncResource.bind(res._callback)\n        res._callback = AsyncResource.bind(function (error, result) {\n          if (error) {\n            errorCh.publish(error)\n          }\n          asyncEndCh.publish(result)\n\n          return cb.apply(this, arguments)\n        })\n      } else {\n        const cb = AsyncResource.bind(function () {\n          asyncEndCh.publish(undefined)\n        })\n        res.on('end', cb)\n      }\n\n      return res\n    } catch (err) {\n      err.stack // trigger getting the stack at the original throwing point\n      errorCh.publish(err)\n\n      throw err\n    } finally {\n      endCh.publish(undefined)\n    }\n  })\n\n  return Connection\n})\n\naddHook({ name: 'mysql', file: 'lib/Pool.js', versions: ['>=2'] }, Pool => {\n  shimmer.wrap(Pool.prototype, 'getConnection', getConnection => function (cb) {\n    arguments[0] = AsyncResource.bind(cb)\n    return getConnection.apply(this, arguments)\n  })\n  return Pool\n})\n","'use strict'\n\nconst {\n  channel,\n  addHook,\n  AsyncResource\n} = require('./helpers/instrument')\nconst shimmer = require('../../datadog-shimmer')\n\naddHook({ name: 'mysql2', file: 'lib/connection.js', versions: ['>=1'] }, Connection => {\n  const startCh = channel('apm:mysql2:query:start')\n  const asyncEndCh = channel('apm:mysql2:query:async-end')\n  const endCh = channel('apm:mysql2:query:end')\n  const errorCh = channel('apm:mysql2:query:error')\n\n  shimmer.wrap(Connection.prototype, 'addCommand', addCommand => function (cmd) {\n    if (!startCh.hasSubscribers) return addCommand.apply(this, arguments)\n\n    const asyncResource = new AsyncResource('bound-anonymous-fn')\n    const name = cmd && cmd.constructor && cmd.constructor.name\n    const isCommand = typeof cmd.execute === 'function'\n    const isQuery = isCommand && (name === 'Execute' || name === 'Query')\n\n    // TODO: consider supporting all commands and not just queries\n    cmd.execute = isQuery\n      ? wrapExecute(cmd, cmd.execute, asyncResource, this.config)\n      : bindExecute(cmd, cmd.execute, asyncResource)\n\n    return asyncResource.bind(addCommand, this).apply(this, arguments)\n  })\n\n  return Connection\n\n  function bindExecute (cmd, execute, asyncResource) {\n    return asyncResource.bind(function executeWithTrace (packet, connection) {\n      if (this.onResult) {\n        this.onResult = asyncResource.bind(this.onResult)\n      }\n\n      return execute.apply(this, arguments)\n    }, cmd)\n  }\n\n  function wrapExecute (cmd, execute, asyncResource, config) {\n    return asyncResource.bind(function executeWithTrace (packet, connection) {\n      const sql = cmd.statement ? cmd.statement.query : cmd.sql\n\n      startCh.publish({ sql, conf: config })\n\n      if (this.onResult) {\n        const onResult = asyncResource.bind(this.onResult)\n\n        this.onResult = AsyncResource.bind(function (error) {\n          if (error) {\n            errorCh.publish(error)\n          }\n          asyncEndCh.publish(undefined)\n          onResult.apply(this, arguments)\n        }, 'bound-anonymous-fn', this)\n      } else {\n        this.on('error', AsyncResource.bind(error => errorCh.publish(error)))\n        this.on('end', AsyncResource.bind(() => asyncEndCh.publish(undefined)))\n      }\n\n      this.execute = execute\n\n      try {\n        return execute.apply(this, arguments)\n      } catch (err) {\n        errorCh.publish(err)\n      } finally {\n        endCh.publish(undefined)\n      }\n    }, cmd)\n  }\n})\n","'use strict'\n\nconst {\n  channel,\n  addHook,\n  AsyncResource\n} = require('./helpers/instrument')\nconst shimmer = require('../../datadog-shimmer')\n\nconst startICPCh = channel('apm:net:ipc:start')\nconst asyncICPEndCh = channel('apm:net:ipc:async-end')\nconst endICPCh = channel('apm:net:ipc:end')\nconst errorICPCh = channel('apm:net:ipc:error')\n\nconst startTCPCh = channel('apm:net:tcp:start')\nconst asyncTCPEndCh = channel('apm:net:tcp:async-end')\nconst endTCPCh = channel('apm:net:tcp:end')\nconst errorTCPCh = channel('apm:net:tcp:error')\n\nconst connectionCh = channel(`apm:net:tcp:connection`)\n\naddHook({ name: 'net' }, net => {\n  require('dns')\n\n  shimmer.wrap(net.Socket.prototype, 'connect', connect => function () {\n    if (!startICPCh.hasSubscribers || !startTCPCh.hasSubscribers) {\n      return connect.apply(this, arguments)\n    }\n\n    const options = getOptions(arguments)\n    const lastIndex = arguments.length - 1\n    const callback = arguments[lastIndex]\n\n    if (!options) return connect.apply(this, arguments)\n\n    const asyncResource = new AsyncResource('bound-anonymous-fn')\n\n    if (typeof callback === 'function') {\n      arguments[lastIndex] = asyncResource.bind(callback)\n    }\n\n    const protocol = options.path ? 'ipc' : 'tcp'\n\n    if (protocol === 'ipc') {\n      startICPCh.publish({ options })\n      setupListeners(this, 'ipc', asyncResource)\n    } else {\n      startTCPCh.publish({ options })\n      setupListeners(this, 'tcp', asyncResource)\n    }\n\n    try {\n      return connect.apply(this, arguments)\n    } catch (err) {\n      protocol === 'ipc' ? errorICPCh.publish(err) : errorTCPCh.publish(err)\n\n      throw err\n    } finally {\n      protocol === 'ipc' ? endICPCh.publish(undefined) : endTCPCh.publish(undefined)\n    }\n  })\n\n  return net\n})\n\nfunction getOptions (args) {\n  if (!args[0]) return\n\n  switch (typeof args[0]) {\n    case 'object':\n      if (Array.isArray(args[0])) return getOptions(args[0])\n      return args[0]\n    case 'string':\n      if (isNaN(parseFloat(args[0]))) {\n        return {\n          path: args[0]\n        }\n      }\n    case 'number': // eslint-disable-line no-fallthrough\n      return {\n        port: args[0],\n        host: typeof args[1] === 'string' ? args[1] : 'localhost'\n      }\n  }\n}\n\nfunction setupListeners (socket, protocol, ar) {\n  const events = ['connect', 'error', 'close', 'timeout']\n\n  const wrapListener = AsyncResource.bind(function (error) {\n    if (error) {\n      protocol === 'ipc' ? errorICPCh.publish(error) : errorTCPCh.publish(error)\n    }\n    protocol === 'ipc' ? asyncICPEndCh.publish(undefined) : asyncTCPEndCh.publish(undefined)\n  })\n\n  const localListener = AsyncResource.bind(function () {\n    connectionCh.publish({ socket })\n  })\n\n  const cleanupListener = function () {\n    socket.removeListener('connect', localListener)\n    events.forEach(event => {\n      socket.removeListener(event, wrapListener)\n      socket.removeListener(event, cleanupListener)\n    })\n  }\n\n  if (protocol === 'tcp') {\n    socket.once('connect', localListener)\n  }\n\n  events.forEach(event => {\n    socket.once(event, wrapListener)\n    socket.once(event, cleanupListener)\n  })\n}\n","'use strict'\n\nconst {\n  channel,\n  addHook,\n  AsyncResource\n} = require('./helpers/instrument')\nconst shimmer = require('../../datadog-shimmer')\n\nconst startCh = channel('apm:pg:query:start')\nconst asyncEndCh = channel('apm:pg:query:async-end')\nconst endCh = channel('apm:pg:query:end')\nconst errorCh = channel('apm:pg:query:error')\n\naddHook({ name: 'pg', versions: ['>=4'] }, pg => {\n  shimmer.wrap(pg.Client.prototype, 'query', query => wrapQuery(query))\n  return pg\n})\n\naddHook({ name: 'pg', file: 'lib/native/index.js', versions: ['>=4'] }, Client => {\n  shimmer.wrap(Client.prototype, 'query', query => wrapQuery(query))\n  return Client\n})\n\nfunction wrapQuery (query) {\n  return function () {\n    if (!startCh.hasSubscribers) {\n      return query.apply(this, arguments)\n    }\n\n    const asyncResource = new AsyncResource('bound-anonymous-fn')\n\n    const retval = query.apply(this, arguments)\n\n    const queryQueue = this.queryQueue || this._queryQueue\n    const activeQuery = this.activeQuery || this._activeQuery\n    const pgQuery = queryQueue[queryQueue.length - 1] || activeQuery\n\n    if (!pgQuery) {\n      return retval\n    }\n    const statement = pgQuery.text\n\n    startCh.publish({ params: this.connectionParameters, statement })\n\n    const finish = AsyncResource.bind(function (error) {\n      if (error) {\n        errorCh.publish(error)\n      }\n      asyncEndCh.publish(undefined)\n    })\n\n    if (pgQuery.callback) {\n      const originalCallback = asyncResource.bind(pgQuery.callback)\n      pgQuery.callback = function (err, res) {\n        finish(err)\n        return originalCallback.apply(this, arguments)\n      }\n    } else if (pgQuery.once) {\n      pgQuery\n        .once('error', finish)\n        .once('end', () => finish())\n    } else {\n      pgQuery.then(() => finish(), finish)\n    }\n\n    try {\n      return retval\n    } catch (err) {\n      errorCh.publish(err)\n    } finally {\n      endCh.publish(undefined)\n    }\n  }\n}\n","'use strict'\n\nconst {\n  channel,\n  addHook\n} = require('./helpers/instrument')\nconst shimmer = require('../../datadog-shimmer')\n\nfunction wrapPino (symbol, wrapper, pino) {\n  return function pinoWithTrace () {\n    const instance = pino.apply(this, arguments)\n\n    Object.defineProperty(instance, symbol, {\n      configurable: true,\n      enumerable: true,\n      writable: true,\n      value: wrapper(instance[symbol])\n    })\n\n    return instance\n  }\n}\n\nfunction wrapAsJson (asJson) {\n  const ch = channel('apm:pino:log')\n  return function asJsonWithTrace (obj, msg, num, time) {\n    obj = arguments[0] = obj || {}\n\n    const payload = { message: obj }\n    ch.publish(payload)\n    arguments[0] = payload.message\n\n    return asJson.apply(this, arguments)\n  }\n}\n\nfunction wrapMixin (mixin) {\n  const ch = channel('apm:pino:log')\n  return function mixinWithTrace () {\n    let obj = {}\n\n    if (mixin) {\n      obj = mixin.apply(this, arguments)\n    }\n\n    const payload = { message: obj }\n    ch.publish(payload)\n\n    return payload.message\n  }\n}\n\nfunction wrapPrettifyObject (prettifyObject) {\n  const ch = channel('apm:pino:log')\n  return function prettifyObjectWithTrace (input) {\n    const payload = { message: input.input }\n    ch.publish(payload)\n    input.input = payload.message\n    return prettifyObject.apply(this, arguments)\n  }\n}\n\nfunction wrapPrettyFactory (prettyFactory) {\n  const ch = channel('apm:pino:log')\n  return function prettyFactoryWithTrace () {\n    const pretty = prettyFactory.apply(this, arguments)\n    return function prettyWithTrace (obj) {\n      const payload = { message: obj }\n      ch.publish(payload)\n      arguments[0] = payload.message\n      return pretty.apply(this, arguments)\n    }\n  }\n}\n\naddHook({ name: 'pino', versions: ['2 - 3', '4', '>=5 <5.14.0'] }, pino => {\n  const asJsonSym = (pino.symbols && pino.symbols.asJsonSym) || 'asJson'\n\n  return shimmer.wrap(pino, wrapPino(asJsonSym, wrapAsJson, pino))\n})\n\naddHook({ name: 'pino', versions: ['>=5.14.0 <6.8.0'] }, pino => {\n  const mixinSym = pino.symbols.mixinSym\n\n  return shimmer.wrap(pino, wrapPino(mixinSym, wrapMixin, pino))\n})\n\naddHook({ name: 'pino', versions: ['>=6.8.0'] }, pino => {\n  const mixinSym = pino.symbols.mixinSym\n\n  const wrapped = shimmer.wrap(pino, wrapPino(mixinSym, wrapMixin, pino))\n  wrapped.pino = wrapped\n  wrapped.default = wrapped\n\n  return wrapped\n})\n\naddHook({ name: 'pino-pretty', file: 'lib/utils.js', versions: ['>=3'] }, utils => {\n  shimmer.wrap(utils, 'prettifyObject', wrapPrettifyObject)\n  return utils\n})\n\naddHook({ name: 'pino-pretty', versions: ['1 - 2'] }, prettyFactory => {\n  return shimmer.wrap(prettyFactory, wrapPrettyFactory(prettyFactory))\n})\n","'use strict'\n\nconst { addHook } = require('./helpers/instrument')\nconst { wrapThen } = require('./helpers/promise')\nconst shimmer = require('../../datadog-shimmer')\n\naddHook({\n  name: 'promise-js',\n  versions: ['>=0.0.3']\n}, Promise => {\n  if (Promise !== global.Promise) {\n    shimmer.wrap(Promise.prototype, 'then', wrapThen)\n  }\n  return Promise\n})\n","'use strict'\n\nconst { addHook } = require('./helpers/instrument')\nconst { wrapThen } = require('./helpers/promise')\nconst shimmer = require('../../datadog-shimmer')\n\naddHook({\n  name: 'promise',\n  file: 'lib/core.js',\n  versions: ['>=7']\n}, Promise => {\n  shimmer.wrap(Promise.prototype, 'then', wrapThen)\n  return Promise\n})\n","'use strict'\n\nconst { addHook } = require('./helpers/instrument')\nconst { wrapThen } = require('./helpers/promise')\nconst shimmer = require('../../datadog-shimmer')\n\naddHook({\n  name: 'q',\n  versions: ['1']\n}, Q => {\n  shimmer.wrap(Q.makePromise.prototype, 'then', wrapThen)\n  return Q\n})\n\naddHook({\n  name: 'q',\n  versions: ['>=2']\n}, Q => {\n  shimmer.wrap(Q.Promise.prototype, 'then', wrapThen)\n  return Q\n})\n","'use strict'\n\nconst {\n  channel,\n  addHook,\n  AsyncResource\n} = require('./helpers/instrument')\nconst shimmer = require('../../datadog-shimmer')\n\nconst startCh = channel('apm:redis:command:start')\nconst asyncEndCh = channel('apm:redis:command:async-end')\nconst endCh = channel('apm:redis:command:end')\nconst errorCh = channel('apm:redis:command:error')\n\naddHook({ name: '@node-redis/client', file: 'dist/lib/client/commands-queue.js', versions: ['>=1'] }, redis => {\n  shimmer.wrap(redis.default.prototype, 'addCommand', addCommand => function (command) {\n    if (!startCh.hasSubscribers) {\n      return addCommand.apply(this, arguments)\n    }\n\n    const name = command[0]\n    const args = command.slice(1)\n\n    start(this, name, args)\n\n    const res = addCommand.apply(this, arguments)\n    const asyncResource = new AsyncResource('bound-anonymous-fn')\n    const onResolve = asyncResource.bind(() => finish(asyncEndCh, errorCh))\n    const onReject = asyncResource.bind(err => finish(asyncEndCh, errorCh, err))\n\n    res.then(onResolve, onReject)\n    endCh.publish(undefined)\n    return res\n  })\n  return redis\n})\n\naddHook({ name: 'redis', versions: ['>=2.6 <4'] }, redis => {\n  shimmer.wrap(redis.RedisClient.prototype, 'internal_send_command', internalSendCommand => function (options) {\n    if (!startCh.hasSubscribers) return internalSendCommand.apply(this, arguments)\n\n    if (!options.callback) return internalSendCommand.apply(this, arguments)\n\n    const asyncResource = new AsyncResource('bound-anonymous-fn')\n\n    const cb = asyncResource.bind(options.callback)\n\n    start(this, options.command, options.args)\n\n    options.callback = AsyncResource.bind(wrapCallback(asyncEndCh, errorCh, cb))\n\n    try {\n      return internalSendCommand.apply(this, arguments)\n    } catch (err) {\n      errorCh.publish(err)\n\n      throw err\n    } finally {\n      endCh.publish(undefined)\n    }\n  })\n  return redis\n})\n\naddHook({ name: 'redis', versions: ['>=0.12 <2.6'] }, redis => {\n  shimmer.wrap(redis.RedisClient.prototype, 'send_command', sendCommand => function (command, args, callback) {\n    if (!startCh.hasSubscribers) {\n      return sendCommand.apply(this, arguments)\n    }\n\n    const asyncResource = new AsyncResource('bound-anonymous-fn')\n\n    start(this, command, args)\n\n    if (typeof callback === 'function') {\n      const cb = asyncResource.bind(callback)\n      arguments[2] = AsyncResource.bind(wrapCallback(asyncEndCh, errorCh, cb))\n    } else if (Array.isArray(args) && typeof args[args.length - 1] === 'function') {\n      const cb = asyncResource.bind(args[args.length - 1])\n      args[args.length - 1] = AsyncResource.bind(wrapCallback(asyncEndCh, errorCh, cb))\n    } else {\n      arguments[2] = AsyncResource.bind(wrapCallback(asyncEndCh, errorCh))\n    }\n\n    try {\n      return sendCommand.apply(this, arguments)\n    } catch (err) {\n      errorCh.publish(err)\n\n      throw err\n    } finally {\n      endCh.publish(undefined)\n    }\n  })\n  return redis\n})\n\nfunction start (client, command, args) {\n  const db = client.selected_db\n  const connectionOptions = client.connection_options || client.connection_option || client.connectionOption || {}\n  startCh.publish({ db, command, args, connectionOptions })\n}\n\nfunction wrapCallback (asyncEndCh, errorCh, callback) {\n  return function (err) {\n    finish(asyncEndCh, errorCh, err)\n    if (callback) {\n      return callback.apply(this, arguments)\n    }\n  }\n}\n\nfunction finish (asyncEndCh, errorCh, error) {\n  if (error) {\n    errorCh.publish(error)\n  }\n  asyncEndCh.publish(undefined)\n}\n","'use strict'\n\nconst {\n  channel,\n  addHook,\n  AsyncResource\n} = require('./helpers/instrument')\nconst shimmer = require('../../datadog-shimmer')\n\nconst circularBufferConstructor = Symbol('circularBufferConstructor')\nconst inFlightDeliveries = Symbol('inFlightDeliveries')\n\nconst patched = new WeakSet()\nconst dispatchCh = channel('apm:rhea:dispatch')\nconst errorCh = channel('apm:rhea:error')\nconst asyncEndCh = channel('apm:rhea:async-end')\nconst endCh = channel('apm:rhea:end')\n\nconst contexts = new WeakMap()\n\naddHook({ name: 'rhea', versions: ['>=1'], file: 'lib/link.js' }, obj => {\n  const startSendCh = channel('apm:rhea:send:start')\n  const startReceiveCh = channel('apm:rhea:receive:start')\n\n  const Sender = obj.Sender\n  const Receiver = obj.Receiver\n  shimmer.wrap(Sender.prototype, 'send', send => function (msg, tag, format) {\n    if (!canTrace(this)) {\n      // we can't handle disconnects or ending spans, so we can't safely instrument\n      return send.apply(this, arguments)\n    }\n\n    const { host, port } = getHostAndPort(this.connection)\n\n    const targetAddress = this.options && this.options.target &&\n      this.options.target.address ? this.options.target.address : undefined\n\n    startSendCh.publish({ targetAddress, host, port, msg })\n    const delivery = send.apply(this, arguments)\n    const asyncResource = new AsyncResource('bound-anonymous-fn')\n    const context = {\n      asyncResource\n    }\n    contexts.set(delivery, context)\n\n    addToInFlightDeliveries(this.connection, delivery)\n    try {\n      return delivery\n    } catch (err) {\n      errorCh.publish(err)\n\n      throw err\n    } finally {\n      endCh.publish(undefined)\n    }\n  })\n\n  shimmer.wrap(Receiver.prototype, 'dispatch', dispatch => function (eventName, msgObj) {\n    if (!canTrace(this)) {\n      // we can't handle disconnects or ending spans, so we can't safely instrument\n      return dispatch.apply(this, arguments)\n    }\n\n    if (eventName === 'message' && msgObj) {\n      startReceiveCh.publish({ msgObj, connection: this.connection })\n\n      if (msgObj.delivery) {\n        const asyncResource = new AsyncResource('bound-anonymous-fn')\n        const context = {\n          asyncResource\n        }\n        contexts.set(msgObj.delivery, context)\n        msgObj.delivery.update = wrapDeliveryUpdate(msgObj.delivery, msgObj.delivery.update)\n        addToInFlightDeliveries(this.connection, msgObj.delivery)\n      }\n      try {\n        return dispatch.apply(this, arguments)\n      } catch (err) {\n        errorCh.publish(err)\n\n        throw err\n      } finally {\n        endCh.publish(undefined)\n      }\n    }\n\n    return dispatch.apply(this, arguments)\n  })\n  return obj\n})\n\naddHook({ name: 'rhea', versions: ['>=1'], file: 'lib/connection.js' }, Connection => {\n  shimmer.wrap(Connection.prototype, 'dispatch', dispatch => function (eventName, obj) {\n    if (eventName === 'disconnected') {\n      const error = obj.error || this.saved_error\n      if (this[inFlightDeliveries]) {\n        this[inFlightDeliveries].forEach(delivery => {\n          const context = contexts.get(delivery)\n          const asyncResource = context.asyncResource\n          asyncResource.runInAsyncScope(() => {\n            errorCh.publish(error)\n            finish(delivery, null)\n          })\n        })\n      }\n    }\n    return dispatch.apply(this, arguments)\n  })\n  return Connection\n})\n\naddHook({ name: 'rhea', versions: ['>=1'], file: 'lib/session.js' }, (Session) => {\n  patchCircularBuffer(Session.prototype, Session)\n  return Session\n})\n\nfunction canTrace (link) {\n  return link.connection && link.session && link.session.outgoing\n}\n\nfunction getHostAndPort (connection) {\n  let host\n  let port\n  if (connection && connection.options) {\n    host = connection.options.host\n    port = connection.options.port\n  }\n  return { host, port }\n}\n\nfunction wrapDeliveryUpdate (obj, update) {\n  const context = contexts.get(obj)\n  const asyncResource = context.asyncResource\n  if (obj && asyncResource) {\n    const cb = asyncResource.bind(update)\n    return AsyncResource.bind(function wrappedUpdate (settled, stateData) {\n      const state = getStateFromData(stateData)\n      dispatchCh.publish({ state })\n      return cb.apply(this, arguments)\n    })\n  }\n  return function wrappedUpdate (settled, stateData) {\n    return update.apply(this, arguments)\n  }\n}\n\nfunction patchCircularBuffer (proto, Session) {\n  Object.defineProperty(proto, 'outgoing', {\n    configurable: true,\n    get () {},\n    set (outgoing) {\n      delete proto.outgoing // removes the setter on the prototype\n      this.outgoing = outgoing // assigns on the instance, like normal\n      if (outgoing) {\n        let CircularBuffer\n        if (outgoing.deliveries) {\n          CircularBuffer = outgoing.deliveries.constructor\n        }\n        if (CircularBuffer && !patched.has(CircularBuffer.prototype)) {\n          shimmer.wrap(CircularBuffer.prototype, 'pop_if', popIf => function (fn) {\n            arguments[0] = AsyncResource.bind(function (entry) {\n              const context = contexts.get(entry)\n              const asyncResource = context.asyncResource\n              let shouldPop\n              if (asyncResource) {\n                fn = asyncResource.bind(fn, this)\n                shouldPop = fn(entry)\n                if (shouldPop && asyncResource) {\n                  const remoteState = entry.remote_state\n                  const state = remoteState && remoteState.constructor\n                    ? entry.remote_state.constructor.composite_type : undefined\n                  asyncResource.runInAsyncScope(() => {\n                    return finish(entry, state)\n                  })\n                }\n              }\n\n              return shouldPop\n            })\n            return popIf.apply(this, arguments)\n          })\n          patched.add(CircularBuffer.prototype)\n          const Session = proto.constructor\n          if (Session) {\n            Session[circularBufferConstructor] = CircularBuffer\n          }\n        }\n      }\n    }\n  })\n}\n\nfunction addToInFlightDeliveries (connection, delivery) {\n  let deliveries = connection[inFlightDeliveries]\n  if (!deliveries) {\n    deliveries = new Set()\n    connection[inFlightDeliveries] = deliveries\n  }\n  deliveries.add(delivery)\n}\n\nfunction finish (delivery, state) {\n  const obj = contexts.get(delivery)\n  if (obj) {\n    if (state) {\n      dispatchCh.publish({ state })\n    }\n    asyncEndCh.publish(undefined)\n    if (obj.connection && obj.connection[inFlightDeliveries]) {\n      obj.connection[inFlightDeliveries].delete(delivery)\n    }\n  }\n}\n\nfunction getStateFromData (stateData) {\n  if (stateData && stateData.descriptor && stateData.descriptor) {\n    switch (stateData.descriptor.value) {\n      case 0x24: return 'accepted'\n      case 0x25: return 'rejected'\n      case 0x26: return 'released'\n      case 0x27: return 'modified'\n    }\n  }\n}\n","'use strict'\n\nconst {\n  channel,\n  addHook,\n  AsyncResource\n} = require('./helpers/instrument')\nconst shimmer = require('../../datadog-shimmer')\n\n/**\n * @description The enum values in this map are not exposed from ShareDB, so the keys are hard-coded here.\n * The values were derived from: https://github.com/share/sharedb/blob/master/lib/client/connection.js#L196\n */\nconst READABLE_ACTION_NAMES = {\n  hs: 'handshake',\n  qf: 'query-fetch',\n  qs: 'query-subscribe',\n  qu: 'query-unsubscribe',\n  bf: 'bulk-fetch',\n  bs: 'bulk-subscribe',\n  bu: 'bulk-unsubscribe',\n  f: 'fetch',\n  s: 'subscribe',\n  u: 'unsubscribe',\n  op: 'op',\n  nf: 'snapshot-fetch',\n  nt: 'snapshot-fetch-by-ts',\n  p: 'presence-broadcast',\n  pr: 'presence-request',\n  ps: 'presence-subscribe',\n  pu: 'presence-unsubscribe'\n}\n\naddHook({ name: 'sharedb', versions: ['>=1'], file: 'lib/agent.js' }, Agent => {\n  const startCh = channel('apm:sharedb:request:start')\n  const asyncEndCh = channel('apm:sharedb:request:async-end')\n  const endCh = channel('apm:sharedb:request:end')\n  const errorCh = channel('apm:sharedb:request:error')\n\n  shimmer.wrap(Agent.prototype, '_handleMessage', origHandleMessageFn => function (request, callback) {\n    const asyncResource = new AsyncResource('bound-anonymous-fn')\n    const action = request.a\n\n    const actionName = getReadableActionName(action)\n\n    startCh.publish({ actionName, request })\n\n    callback = asyncResource.bind(callback)\n\n    arguments[1] = AsyncResource.bind(function (error, res) {\n      if (error) {\n        errorCh.publish(error)\n      }\n      asyncEndCh.publish({ request, res })\n\n      return callback.apply(this, arguments)\n    })\n\n    try {\n      return origHandleMessageFn.apply(this, arguments)\n    } catch (error) {\n      errorCh.publish(error)\n\n      throw error\n    } finally {\n      endCh.publish(undefined)\n    }\n  })\n  return Agent\n})\n\nfunction getReadableActionName (action) {\n  const actionName = READABLE_ACTION_NAMES[action]\n  if (actionName === undefined) {\n    return action\n  }\n  return actionName\n}\n","'use strict'\n\nconst {\n  channel,\n  addHook,\n  AsyncResource\n} = require('./helpers/instrument')\nconst shimmer = require('../../datadog-shimmer')\n\naddHook({ name: 'tedious', versions: [ '>=1.0.0' ] }, tedious => {\n  const startCh = channel('apm:tedious:request:start')\n  const asyncEndCh = channel('apm:tedious:request:async-end')\n  const endCh = channel('apm:tedious:request:end')\n  const errorCh = channel('apm:tedious:request:error')\n  shimmer.wrap(tedious.Connection.prototype, 'makeRequest', makeRequest => function (request) {\n    if (!startCh.hasSubscribers) {\n      return request.apply(this, arguments)\n    }\n\n    const queryOrProcedure = getQueryOrProcedure(request)\n\n    if (!queryOrProcedure) {\n      return makeRequest.apply(this, arguments)\n    }\n\n    const asyncResource = new AsyncResource('bound-anonymous-fn')\n\n    const connectionConfig = this.config\n\n    startCh.publish({ queryOrProcedure, connectionConfig })\n\n    const cb = asyncResource.bind(request.callback, request)\n    request.callback = AsyncResource.bind(function (error) {\n      if (error) {\n        errorCh.publish(error)\n      }\n      asyncEndCh.publish(undefined)\n\n      return cb.apply(this, arguments)\n    }, null, request)\n\n    try {\n      return makeRequest.apply(this, arguments)\n    } catch (error) {\n      errorCh.publish(error)\n\n      throw error\n    } finally {\n      endCh.publish(undefined)\n    }\n  })\n\n  return tedious\n})\n\nfunction getQueryOrProcedure (request) {\n  if (!request.parameters) return\n\n  const statement = request.parametersByName.statement || request.parametersByName.stmt\n\n  if (!statement) {\n    return request.sqlTextOrProcedure\n  }\n\n  return statement.value\n}\n","'use strict'\n\nconst { addHook } = require('./helpers/instrument')\nconst { wrapThen } = require('./helpers/promise')\nconst shimmer = require('../../datadog-shimmer')\n\naddHook({\n  name: 'when',\n  file: 'lib/Promise.js',\n  versions: ['>=3']\n}, Promise => {\n  shimmer.wrap(Promise.prototype, 'then', wrapThen)\n  return Promise\n})\n","'use strict'\n\nconst {\n  channel,\n  addHook\n} = require('./helpers/instrument')\nconst shimmer = require('../../datadog-shimmer')\n\nconst patched = new WeakSet()\n\naddHook({ name: 'winston', file: 'lib/winston/logger.js', versions: ['>=3'] }, Logger => {\n  const logCh = channel('apm:winston:log')\n  shimmer.wrap(Logger.prototype, 'write', write => {\n    return function wrappedWrite (chunk, enc, cb) {\n      if (logCh.hasSubscribers) {\n        const payload = { message: chunk }\n        logCh.publish(payload)\n        arguments[0] = payload.message\n      }\n      return write.apply(this, arguments)\n    }\n  })\n  return Logger\n})\n\naddHook({ name: 'winston', file: 'lib/winston/logger.js', versions: ['1', '2'] }, logger => {\n  const logCh = channel('apm:winston:log')\n  if (logger.Logger.prototype.configure) {\n    shimmer.wrap(logger.Logger.prototype, 'configure', configure => wrapMethod(configure, logCh))\n  }\n  shimmer.wrap(logger.Logger.prototype, 'add', configure => wrapMethod(configure, logCh))\n  return logger\n})\n\nfunction wrapMethod (method, logCh) {\n  return function methodWithTrace () {\n    const result = method.apply(this, arguments)\n\n    if (logCh.hasSubscribers) {\n      for (const name in this.transports) {\n        const transport = this.transports[name]\n\n        if (patched.has(transport) || typeof transport.log !== 'function') continue\n\n        const log = transport.log\n        transport.log = function wrappedLog (level, msg, meta, callback) {\n          const payload = { message: meta || {} }\n          logCh.publish(payload)\n          arguments[2] = payload.message\n          log.apply(this, arguments)\n        }\n        patched.add(transport)\n      }\n    }\n    return result\n  }\n}\n","'use strict'\n\nconst Plugin = require('../../dd-trace/src/plugins/plugin')\nconst { storage } = require('../../datadog-core')\nconst analyticsSampler = require('../../dd-trace/src/analytics_sampler')\n\nclass Amqp10Plugin extends Plugin {\n  static get name () {\n    return 'amqp10'\n  }\n\n  constructor (...args) {\n    super(...args)\n\n    this.addSub(`apm:amqp10:send:start`, ({ link }) => {\n      const address = getAddress(link)\n      const target = getShortName(link)\n\n      const store = storage.getStore()\n      const childOf = store ? store.span : store\n\n      const span = this.tracer.startSpan('amqp.send', {\n        childOf,\n        tags: {\n          'resource.name': ['send', target].filter(v => v).join(' '),\n          'span.kind': 'producer',\n          'amqp.link.target.address': target,\n          'amqp.link.role': 'sender',\n          'out.host': address.host,\n          'out.port': address.port,\n          'service.name': this.config.service || `${this.tracer._service}-amqp`,\n          'amqp.link.name': link.name,\n          'amqp.link.handle': link.handle,\n          'amqp.connection.host': address.host,\n          'amqp.connection.port': address.port,\n          'amqp.connection.user': address.user\n        }\n      })\n\n      analyticsSampler.sample(span, this.config.measured)\n\n      this.enter(span, store)\n    })\n\n    this.addSub(`apm:amqp10:send:end`, () => {\n      this.exit()\n    })\n\n    this.addSub(`apm:amqp10:send:error`, err => {\n      const span = storage.getStore().span\n      span.setTag('error', err)\n    })\n\n    this.addSub(`apm:amqp10:send:async-end`, () => {\n      const span = storage.getStore().span\n      span.finish()\n    })\n\n    this.addSub(`apm:amqp10:receive:start`, ({ link }) => {\n      const source = getShortName(link)\n      const address = getAddress(link)\n\n      const store = storage.getStore()\n      const childOf = store ? store.span : store\n\n      const span = this.tracer.startSpan('amqp.receive', {\n        childOf,\n        tags: {\n          'resource.name': ['receive', source].filter(v => v).join(' '),\n          'span.kind': 'consumer',\n          'span.type': 'worker',\n          'amqp.link.source.address': source,\n          'amqp.link.role': 'receiver',\n          'service.name': this.config.service || `${this.tracer._service}-amqp`,\n          'amqp.link.name': link.name,\n          'amqp.link.handle': link.handle,\n          'amqp.connection.host': address.host,\n          'amqp.connection.port': address.port,\n          'amqp.connection.user': address.user\n        }\n      })\n\n      analyticsSampler.sample(span, this.config.measured)\n\n      this.enter(span, store)\n    })\n\n    this.addSub(`apm:amqp10:receive:end`, () => {\n      storage.getStore().span.finish()\n      this.exit()\n    })\n\n    this.addSub(`apm:amqp10:receive:error`, err => {\n      const span = storage.getStore().span\n      span.setTag('error', err)\n    })\n  }\n}\n\nfunction getShortName (link) {\n  if (!link || !link.name) return null\n\n  return link.name.split('_').slice(0, -1).join('_')\n}\n\nfunction getAddress (link) {\n  if (!link || !link.session || !link.session.connection) return {}\n\n  return link.session.connection.address || {}\n}\n\nmodule.exports = Amqp10Plugin\n","'use strict'\n\nconst Plugin = require('../../dd-trace/src/plugins/plugin')\nconst { storage } = require('../../datadog-core')\nconst analyticsSampler = require('../../dd-trace/src/analytics_sampler')\nconst { TEXT_MAP } = require('../../../ext/formats')\n\nclass AmqplibPlugin extends Plugin {\n  static get name () {\n    return 'amqplib'\n  }\n\n  constructor (...args) {\n    super(...args)\n\n    this.addSub(`apm:amqplib:command:start`, ({ channel, method, fields, message }) => {\n      const store = storage.getStore()\n      let childOf\n\n      if (method === 'basic.deliver') {\n        childOf = extract(this.tracer, message)\n      } else {\n        fields.headers = fields.headers || {}\n        childOf = store ? store.span : store\n      }\n\n      const span = this.tracer.startSpan('amqp.command', {\n        childOf,\n        tags: {\n          'service.name': this.config.service || `${this.tracer._service}-amqp`,\n          'resource.name': getResourceName(method, fields)\n        }\n      })\n\n      if (channel && channel.connection && channel.connection.stream) {\n        span.addTags({\n          'out.host': channel.connection.stream._host,\n          'out.port': channel.connection.stream.remotePort\n        })\n      }\n      const fieldNames = [\n        'queue',\n        'exchange',\n        'routingKey',\n        'consumerTag',\n        'source',\n        'destination'\n      ]\n\n      switch (method) {\n        case 'basic.publish':\n          span.setTag('span.kind', 'producer')\n          break\n        case 'basic.consume':\n        case 'basic.get':\n        case 'basic.deliver':\n          span.addTags({\n            'span.kind': 'consumer',\n            'span.type': 'worker'\n          })\n          break\n        default:\n          span.setTag('span.kind', 'client')\n      }\n\n      fieldNames.forEach(field => {\n        fields[field] !== undefined && span.setTag(`amqp.${field}`, fields[field])\n      })\n      if (method === 'basic.deliver') {\n        analyticsSampler.sample(span, this.config.measured, true)\n      } else {\n        this.tracer.inject(span, TEXT_MAP, fields.headers)\n        analyticsSampler.sample(span, this.config.measured)\n      }\n\n      this.enter(span, store)\n    })\n\n    this.addSub(`apm:amqplib:command:end`, () => {\n      const span = storage.getStore().span\n      span.finish()\n      this.exit()\n    })\n\n    this.addSub(`apm:amqplib:command:error`, err => {\n      const span = storage.getStore().span\n      span.setTag('error', err)\n    })\n  }\n}\n\nfunction getResourceName (method, fields = {}) {\n  return [\n    method,\n    fields.exchange,\n    fields.routingKey,\n    fields.queue,\n    fields.source,\n    fields.destination\n  ].filter(val => val).join(' ')\n}\n\nfunction extract (tracer, message) {\n  return message\n    ? tracer.extract(TEXT_MAP, message.properties.headers)\n    : null\n}\n\nmodule.exports = AmqplibPlugin\n","'use strict'\n\nconst Tags = require('opentracing').Tags\n\nconst services = {\n  cloudwatchlogs: getService(require('./services/cloudwatchlogs')),\n  dynamodb: getService(require('./services/dynamodb')),\n  kinesis: getService(require('./services/kinesis')),\n  lambda: getService(require('./services/lambda')),\n  s3: getService(require('./services/s3')),\n  redshift: getService(require('./services/redshift')),\n  sns: getService(require('./services/sns')),\n  sqs: getService(require('./services/sqs')),\n  eventbridge: getService(require('./services/eventbridge'))\n}\n\nfunction getService (Service) {\n  return new Service()\n}\n\nconst helpers = {\n  finish (config, span, response, err) {\n    if (err) {\n      span.setTag('error', err)\n\n      if (err.requestId) {\n        span.addTags({ 'aws.response.request_id': err.requestId })\n      }\n    }\n\n    config.hooks.request(span, response)\n\n    span.finish()\n  },\n\n  isEnabled (serviceIdentifier, config, request) {\n    if (typeof config === 'boolean') {\n      return config\n    } else if (!config || typeof config !== 'object' || !services[serviceIdentifier]) {\n      return true\n    }\n\n    return services[serviceIdentifier].isEnabled\n      ? services[serviceIdentifier].isEnabled(config, request)\n      : true\n  },\n\n  addResponseTags (span, response, serviceName) {\n    if (!span) return\n\n    if (response.request) {\n      this.addServicesTags(span, response, serviceName)\n    }\n  },\n\n  addServicesTags (span, response, serviceName) {\n    if (!span) return\n\n    const params = response.request.params\n    const operation = response.request.operation\n    const extraTags = services[serviceName] ? services[serviceName].generateTags(params, operation, response) : {}\n    const tags = Object.assign({\n      'aws.response.request_id': response.requestId,\n      'resource.name': operation,\n      'span.kind': 'client'\n    }, extraTags)\n\n    span.addTags(tags)\n  },\n\n  responseExtract (serviceName, request, response, tracer) {\n    if (services[serviceName] && services[serviceName].responseExtract) {\n      const params = request.params\n      const operation = request.operation\n      return services[serviceName].responseExtract(params, operation, response, tracer)\n    }\n  },\n\n  requestInject (span, request, serviceName, tracer) {\n    if (!span) return\n\n    const service = services[serviceName] && services[serviceName]\n    if (service && service.requestInject) service.requestInject(span, request, tracer)\n  },\n\n  wrapCb (cb, serviceName, tags, request, tracer, childOf) {\n    const awsHelpers = this\n    return function wrappedCb (err, resp) {\n      const maybeChildOf = awsHelpers.responseExtract(serviceName, request, resp, tracer)\n      if (maybeChildOf) {\n        const options = {\n          childOf: maybeChildOf,\n          tags: Object.assign({}, tags, { [Tags.SPAN_KIND]: 'server' })\n        }\n        return tracer.wrap('aws.response', options, cb).apply(this, arguments)\n      } else {\n        return tracer.scope().bind(cb, childOf).apply(this, arguments)\n      }\n    }\n  }\n}\n\nmodule.exports = helpers\n","'use strict'\n\nconst Tags = require('opentracing').Tags\nconst analyticsSampler = require('../../dd-trace/src/analytics_sampler')\nconst awsHelpers = require('./helpers')\n\nfunction createWrapRequest (tracer, config) {\n  config = normalizeConfig(config)\n  return function wrapRequest (send) {\n    return function requestWithTrace (cb) {\n      if (!this.service) return send.apply(this, arguments)\n\n      const serviceIdentifier = this.service.serviceIdentifier\n\n      if (!awsHelpers.isEnabled(serviceIdentifier, config[serviceIdentifier], this)) {\n        return send.apply(this, arguments)\n      }\n\n      const serviceName = getServiceName(serviceIdentifier, tracer, config)\n      const childOf = tracer.scope().active()\n      const tags = {\n        [Tags.SPAN_KIND]: 'client',\n        'service.name': serviceName,\n        'aws.operation': this.operation,\n        'aws.region': this.service.config && this.service.config.region,\n        'aws.service': this.service.api && this.service.api.className,\n        'component': 'aws-sdk'\n      }\n\n      const span = tracer.startSpan('aws.request', {\n        childOf,\n        tags\n      })\n\n      this.on('complete', response => {\n        if (!span) return\n\n        awsHelpers.addResponseTags(span, response, serviceIdentifier, config, tracer)\n        awsHelpers.finish(config, span, response, response.error)\n      })\n\n      analyticsSampler.sample(span, config.measured)\n\n      awsHelpers.requestInject(span, this, serviceIdentifier, tracer)\n\n      const request = this\n\n      return tracer.scope().activate(span, () => {\n        if (typeof cb === 'function') {\n          arguments[0] = awsHelpers.wrapCb(cb, serviceIdentifier, tags, request, tracer, childOf)\n        }\n        return send.apply(this, arguments)\n      })\n    }\n  }\n}\n\nfunction createWrapSetPromisesDependency (tracer, config, instrumenter, AWS) {\n  return function wrapSetPromisesDependency (setPromisesDependency) {\n    return function setPromisesDependencyWithTrace (dep) {\n      const result = setPromisesDependency.apply(this, arguments)\n\n      instrumenter.wrap(AWS.Request.prototype, 'promise', createWrapRequest(tracer, config))\n\n      return result\n    }\n  }\n}\n\nfunction normalizeConfig (config) {\n  const hooks = getHooks(config)\n\n  return Object.assign({}, config, {\n    splitByAwsService: config.splitByAwsService !== false,\n    hooks\n  })\n}\n\nfunction getHooks (config) {\n  const noop = () => {}\n  const request = (config.hooks && config.hooks.request) || noop\n\n  return { request }\n}\n\n// TODO: test splitByAwsService when the test suite is fixed\nfunction getServiceName (serviceIdentifier, tracer, config) {\n  return config.service\n    ? config.service\n    : `${tracer._service}-aws-${serviceIdentifier}`\n}\n\n// <2.1.35 has breaking changes for instrumentation\n// https://github.com/aws/aws-sdk-js/pull/629\nmodule.exports = [\n  {\n    name: 'aws-sdk',\n    versions: ['>=2.3.0'],\n    patch (AWS, tracer, config) {\n      this.wrap(AWS.Request.prototype, 'promise', createWrapRequest(tracer, config))\n      this.wrap(AWS.config, 'setPromisesDependency', createWrapSetPromisesDependency(tracer, config, this, AWS))\n    },\n    unpatch (AWS) {\n      this.unwrap(AWS.Request.prototype, 'promise')\n      this.unwrap(AWS.config, 'setPromisesDependency')\n    }\n  },\n  {\n    name: 'aws-sdk',\n    versions: ['>=2.1.35'],\n    patch (AWS, tracer, config) {\n      this.wrap(AWS.Request.prototype, 'send', createWrapRequest(tracer, config))\n    },\n    unpatch (AWS) {\n      this.unwrap(AWS.Request.prototype, 'send')\n    }\n  }\n]\n","'use strict'\n\nclass CloudwatchLogs {\n  generateTags (params, operation, response) {\n    const tags = {}\n\n    if (!params || !params.logGroupName) return tags\n\n    return Object.assign(tags, {\n      'resource.name': `${operation} ${params.logGroupName}`,\n      'aws.cloudwatch.logs.log_group_name': params.logGroupName\n    })\n  }\n}\n\nmodule.exports = CloudwatchLogs\n","'use strict'\n\nclass DynamoDb {\n  generateTags (params, operation, response) {\n    const tags = {}\n\n    if (params) {\n      if (params.TableName) {\n        Object.assign(tags, {\n          'resource.name': `${operation} ${params.TableName}`,\n          'aws.dynamodb.table_name': params.TableName\n        })\n      }\n\n      // batch operations have different format, collect table name for batch\n      // https://docs.aws.amazon.com/AWSJavaScriptSDK/latest/AWS/DynamoDB.html#batchGetItem-property`\n      // dynamoDB batch TableName\n      if (params.RequestItems) {\n        if (typeof params.RequestItems === 'object') {\n          if (Object.keys(params.RequestItems).length === 1) {\n            const tableName = Object.keys(params.RequestItems)[0]\n\n            // also add span type to match serverless convention\n            Object.assign(tags, {\n              'resource.name': `${operation} ${tableName}`,\n              'aws.dynamodb.table_name': tableName\n            })\n          }\n        }\n      }\n\n      // TODO: DynamoDB.DocumentClient does batches on multiple tables\n      // https://docs.aws.amazon.com/AWSJavaScriptSDK/latest/AWS/DynamoDB/DocumentClient.html#batchGet-property\n      // it may be useful to have a different resource naming convention here to show all table names\n    }\n\n    // also add span type to match serverless convention\n    Object.assign(tags, {\n      'span.type': 'dynamodb'\n    })\n\n    return tags\n  }\n}\n\nmodule.exports = DynamoDb\n","'use strict'\nconst log = require('../../../dd-trace/src/log')\nclass EventBridge {\n  generateTags (params, operation, response) {\n    if (!params || !params.source) return {}\n\n    return {\n      'resource.name': `${operation} ${params.source}`,\n      'aws.eventbridge.source': params.source\n    }\n  }\n\n  /**\n   * requestInject\n   * @param {*} span\n   * @param {*} request\n   * @param {*} tracer\n   *\n   * Docs: https://docs.aws.amazon.com/eventbridge/latest/APIReference/API_PutEventsRequestEntry.html\n   * We cannot use the traceHeader field as that's reserved for X-Ray.\n   * Detail must be a valid JSON string\n   * Max size per event is 256kb (https://docs.aws.amazon.com/eventbridge/latest/userguide/eb-putevent-size.html)\n   */\n  requestInject (span, request, tracer) {\n    const operation = request.operation\n    if (operation === 'putEvents' &&\n      request.params &&\n      request.params.Entries &&\n      request.params.Entries.length > 0 &&\n      request.params.Entries[0].Detail) {\n      try {\n        const details = JSON.parse(request.params.Entries[0].Detail)\n        details._datadog = {}\n        tracer.inject(span, 'text_map', details._datadog)\n        const finalData = JSON.stringify(details)\n        const byteSize = Buffer.byteLength(finalData)\n        if (byteSize >= (1024 * 256)) {\n          log.info('Payload size too large to pass context')\n          return\n        }\n        request.params.Entries[0].Detail = finalData\n      } catch (e) {\n        log.error(e)\n      }\n    }\n  }\n}\nmodule.exports = EventBridge\n","'use strict'\nconst log = require('../../../dd-trace/src/log')\nclass Kinesis {\n  generateTags (params, operation, response) {\n    if (!params || !params.StreamName) return {}\n\n    return {\n      'resource.name': `${operation} ${params.StreamName}`,\n      'aws.kinesis.stream_name': params.StreamName\n    }\n  }\n\n  // AWS-SDK will b64 kinesis payloads\n  // or will accept an already b64 encoded payload\n  // This method handles both\n  _tryParse (body) {\n    try {\n      return JSON.parse(body)\n    } catch (e) {\n      log.info('Not JSON string. Trying Base64 encoded JSON string')\n    }\n    try {\n      return JSON.parse(Buffer.from(body, 'base64').toString('ascii'), true)\n    } catch (e) {\n      return null\n    }\n  }\n\n  requestInject (span, request, tracer) {\n    const operation = request.operation\n    if (operation === 'putRecord' || operation === 'putRecords') {\n      if (!request.params) {\n        return\n      }\n\n      const traceData = {}\n      tracer.inject(span, 'text_map', traceData)\n      let injectPath\n      if (request.params.Records && request.params.Records.length > 0) {\n        injectPath = request.params.Records[0]\n      } else if (request.params.Data) {\n        injectPath = request.params\n      } else {\n        log.error('No valid payload passed, unable to pass trace context')\n        return\n      }\n      const parsedData = this._tryParse(injectPath.Data)\n      if (parsedData) {\n        parsedData._datadog = traceData\n        const finalData = JSON.stringify(parsedData)\n        const byteSize = Buffer.byteLength(finalData, 'ascii')\n        // Kinesis max payload size is 1MB\n        // So we must ensure adding DD context won't go over that (512b is an estimate)\n        if (byteSize >= 1048576) {\n          log.info('Payload size too large to pass context')\n          return\n        }\n        injectPath.Data = finalData\n      } else {\n        log.error('Unable to parse payload, unable to pass trace context')\n      }\n    }\n  }\n}\n\nmodule.exports = Kinesis\n","'use strict'\n\nconst log = require('../../../dd-trace/src/log')\n\nclass Lambda {\n  generateTags (params, operation, response) {\n    const tags = {}\n\n    if (!params || !params.FunctionName) return tags\n\n    return Object.assign(tags, {\n      'resource.name': `${operation} ${params.FunctionName}`,\n      'aws.lambda': params.FunctionName\n    })\n  }\n\n  requestInject (span, request, tracer) {\n    const operation = request.operation\n    if (operation === 'invoke') {\n      if (!request.params) {\n        request.params = {}\n      }\n\n      const isSyncInvocation = !request.params.InvocationType ||\n        request.params.InvocationType === 'RequestResponse'\n\n      if (isSyncInvocation) {\n        try {\n          // Check to see if there's already a config on the request\n          let clientContext = {}\n          if (request.params.ClientContext) {\n            const clientContextJson = Buffer.from(request.params.ClientContext, 'base64').toString('utf-8')\n            clientContext = JSON.parse(clientContextJson)\n          }\n          if (!clientContext.custom) {\n            clientContext.custom = {}\n          }\n          tracer.inject(span, 'text_map', clientContext.custom)\n          const newContextBase64 = Buffer.from(JSON.stringify(clientContext)).toString('base64')\n          request.params.ClientContext = newContextBase64\n        } catch (err) {\n          log.error(err)\n        }\n      }\n    }\n  }\n}\n\nmodule.exports = Lambda\n","'use strict'\n\nclass Redshift {\n  generateTags (params, operation, response) {\n    const tags = {}\n\n    if (!params || !params.ClusterIdentifier) return tags\n\n    return Object.assign(tags, {\n      'resource.name': `${operation} ${params.ClusterIdentifier}`,\n      'aws.redshift.cluster_identifier': params.ClusterIdentifier\n    })\n  }\n}\n\nmodule.exports = Redshift\n","'use strict'\n\nclass S3 {\n  generateTags (params, operation, response) {\n    const tags = {}\n\n    if (!params || !params.Bucket) return tags\n\n    return Object.assign(tags, {\n      'resource.name': `${operation} ${params.Bucket}`,\n      'aws.s3.bucket_name': params.Bucket\n    })\n  }\n}\n\nmodule.exports = S3\n","'use strict'\nconst log = require('../../../dd-trace/src/log')\n\nclass Sns {\n  generateTags (params, operation, response) {\n    if (!params) return {}\n\n    if (!params.TopicArn && !(response.data && response.data.TopicArn)) return {}\n\n    return {\n      'resource.name': `${operation} ${params.TopicArn || response.data.TopicArn}`,\n      'aws.sns.topic_arn': params.TopicArn || response.data.TopicArn\n    }\n\n    // TODO: should arn be sanitized or quantized in some way here,\n    // for example if it contains a phone number?\n  }\n\n  requestInject (span, request, tracer) {\n    const operation = request.operation\n    if (operation === 'publish' || operation === 'publishBatch') {\n      if (!request.params) {\n        request.params = {}\n      }\n      let injectPath\n      if (request.params.PublishBatchRequestEntries && request.params.PublishBatchRequestEntries.length > 0) {\n        injectPath = request.params.PublishBatchRequestEntries[0]\n      } else if (request.params.Message) {\n        injectPath = request.params\n      }\n      if (!injectPath.MessageAttributes) {\n        injectPath.MessageAttributes = {}\n      }\n      if (Object.keys(injectPath.MessageAttributes).length >= 10) { // SNS quota\n        log.info('Message attributes full, skipping trace context injection')\n        return\n      }\n      const ddInfo = {}\n      tracer.inject(span, 'text_map', ddInfo)\n      injectPath.MessageAttributes._datadog = {\n        DataType: 'Binary',\n        BinaryValue: JSON.stringify(ddInfo) // BINARY types are automatically base64 encoded\n      }\n    }\n  }\n}\n\nmodule.exports = Sns\n","'use strict'\n\nconst log = require('../../../dd-trace/src/log')\n\nclass Sqs {\n  isEnabled (config, request) {\n    switch (request.operation) {\n      case 'receiveMessage':\n        return config.consumer !== false\n      case 'sendMessage':\n      case 'sendMessageBatch':\n        return config.producer !== false\n      default:\n        return true\n    }\n  }\n\n  generateTags (params, operation, response) {\n    const tags = {}\n\n    if (!params || (!params.QueueName && !params.QueueUrl)) return tags\n\n    Object.assign(tags, {\n      'resource.name': `${operation} ${params.QueueName || params.QueueUrl}`,\n      'aws.sqs.queue_name': params.QueueName || params.QueueUrl\n    })\n\n    switch (operation) {\n      case 'receiveMessage':\n        tags['span.type'] = 'worker'\n        tags['span.kind'] = 'consumer'\n        break\n      case 'sendMessage':\n      case 'sendMessageBatch':\n        tags['span.kind'] = 'producer'\n        break\n    }\n\n    return tags\n  }\n\n  responseExtract (params, operation, response, tracer) {\n    if (operation === 'receiveMessage') {\n      if (\n        (!params.MaxNumberOfMessages || params.MaxNumberOfMessages === 1) &&\n        response &&\n        response.Messages &&\n        response.Messages[0] &&\n        response.Messages[0].MessageAttributes &&\n        response.Messages[0].MessageAttributes._datadog &&\n        response.Messages[0].MessageAttributes._datadog.StringValue\n      ) {\n        const textMap = response.Messages[0].MessageAttributes._datadog.StringValue\n        try {\n          return tracer.extract('text_map', JSON.parse(textMap))\n        } catch (err) {\n          log.error(err)\n          return undefined\n        }\n      }\n    }\n  }\n\n  requestInject (span, request, tracer) {\n    const operation = request.operation\n    if (operation === 'sendMessage') {\n      if (!request.params) {\n        request.params = {}\n      }\n      if (!request.params.MessageAttributes) {\n        request.params.MessageAttributes = {}\n      } else if (Object.keys(request.params.MessageAttributes).length >= 10) { // SQS quota\n        // TODO: add test when the test suite is fixed\n        return\n      }\n      const ddInfo = {}\n      tracer.inject(span, 'text_map', ddInfo)\n      request.params.MessageAttributes._datadog = {\n        DataType: 'String',\n        StringValue: JSON.stringify(ddInfo)\n      }\n    }\n  }\n}\n\nmodule.exports = Sqs\n","'use strict'\n\nconst LogPlugin = require('../../dd-trace/src/plugins/log_plugin')\n\nclass BunyanPlugin extends LogPlugin {\n  static get name () {\n    return 'bunyan'\n  }\n}\nmodule.exports = BunyanPlugin\n","'use strict'\n\nconst Plugin = require('../../dd-trace/src/plugins/plugin')\nconst { storage } = require('../../datadog-core')\nconst analyticsSampler = require('../../dd-trace/src/analytics_sampler')\n\nclass CassandraDriverPlugin extends Plugin {\n  static get name () {\n    return 'cassandra-driver'\n  }\n  constructor (...args) {\n    super(...args)\n\n    this.addSub(`apm:cassandra:query:start`, ({ keyspace, query, connectionOptions }) => {\n      const store = storage.getStore()\n      const childOf = store ? store.span : store\n\n      if (Array.isArray(query)) {\n        query = combine(query)\n      }\n\n      const span = this.tracer.startSpan('cassandra.query', {\n        childOf,\n        tags: {\n          'service.name': this.config.service || `${this.tracer._service}-cassandra`,\n          'resource.name': trim(query, 5000),\n          'span.type': 'cassandra',\n          'span.kind': 'client',\n          'db.type': 'cassandra',\n          'cassandra.query': query,\n          'cassandra.keyspace': keyspace\n        }\n      })\n\n      if (connectionOptions) {\n        span.addTags({\n          'out.host': connectionOptions.host,\n          'out.port': connectionOptions.port\n        })\n      }\n\n      analyticsSampler.sample(span, this.config.measured)\n      this.enter(span, store)\n    })\n\n    this.addSub(`apm:cassandra:query:end`, () => {\n      this.exit()\n    })\n\n    this.addSub(`apm:cassandra:query:error`, err => {\n      storage.getStore().span.setTag('error', err)\n    })\n\n    this.addSub(`apm:cassandra:query:async-end`, () => {\n      storage.getStore().span.finish()\n    })\n\n    this.addSub(`apm:cassandra:query:addConnection`, connectionOptions => {\n      const store = storage.getStore()\n      if (!store) {\n        return\n      }\n      const span = store.span\n      span.addTags({\n        'out.host': connectionOptions.address,\n        'out.port': connectionOptions.port\n      })\n    })\n  }\n}\n\nfunction combine (queries) {\n  return queries\n    .map(query => (query.query || query).replace(/;?$/, ';'))\n    .join(' ')\n}\n\nfunction trim (str, size) {\n  if (!str || str.length <= size) return str\n\n  return `${str.substr(0, size - 3)}...`\n}\n\nmodule.exports = CassandraDriverPlugin\n","'use strict'\n\nconst web = require('../../dd-trace/src/plugins/util/web')\n\nfunction createWrapConnect (tracer, config) {\n  return function wrapConnect (connect) {\n    if (typeof connect !== 'function') return connect\n\n    return function connectWithTrace () {\n      const app = connect()\n\n      if (!app) return app\n\n      app.use = createWrapUse()(app.use)\n      app.handle = createWrapHandle(tracer, config)(app.handle)\n\n      return app\n    }\n  }\n}\n\nfunction createWrapUse () {\n  return function wrapUse (use) {\n    if (typeof use !== 'function') return use\n\n    return function useWithTrace (route, fn) {\n      const result = use.apply(this, arguments)\n\n      if (!this || !Array.isArray(this.stack)) return result\n\n      const index = this.stack.length - 1\n      const layer = this.stack[index]\n\n      if (layer && layer.handle) {\n        this.stack[index].handle = wrapLayerHandle(layer)\n      }\n\n      return result\n    }\n  }\n}\n\nfunction createWrapHandle (tracer, config) {\n  config = web.normalizeConfig(config)\n\n  return function wrapHandle (handle) {\n    if (typeof handle !== 'function') return handle\n\n    return function handleWithTrace (req, res, out) {\n      return web.instrument(tracer, config, req, res, 'connect.request', () => {\n        return handle.apply(this, arguments)\n      })\n    }\n  }\n}\n\nfunction wrapLayerHandle (layer) {\n  if (typeof layer.handle !== 'function') return layer.handle\n\n  const handle = layer.handle\n\n  if (layer.handle.length === 4) {\n    return function (error, req, res, next) {\n      return callLayerHandle(layer, handle, req, [error, req, res, wrapNext(layer, req, next)])\n    }\n  } else {\n    return function (req, res, next) {\n      return callLayerHandle(layer, handle, req, [req, res, wrapNext(layer, req, next)])\n    }\n  }\n}\n\nfunction callLayerHandle (layer, handle, req, args) {\n  const route = layer.route\n\n  if (route !== '/') {\n    web.enterRoute(req, route)\n  }\n\n  return web.wrapMiddleware(req, handle, 'connect.middleware', () => {\n    return handle.apply(layer, args)\n  })\n}\n\nfunction wrapNext (layer, req, next) {\n  if (typeof next !== 'function' || !web.active(req)) return next\n\n  return function nextWithTrace (error) {\n    if (!error && layer.route !== '/') {\n      web.exitRoute(req)\n    }\n\n    web.finish(req, error)\n\n    next.apply(this, arguments)\n  }\n}\n\nmodule.exports = [\n  {\n    name: 'connect',\n    versions: ['>=3'],\n    patch (connect, tracer, config) {\n      // `connect` is a function so we return a wrapper that will replace its export.\n      return this.wrapExport(connect, createWrapConnect(tracer, config)(connect))\n    },\n    unpatch (connect) {\n      this.unwrapExport(connect)\n    }\n  },\n  {\n    name: 'connect',\n    versions: ['2.2.2'],\n    patch (connect, tracer, config) {\n      this.wrap(connect.proto, 'use', createWrapUse())\n      this.wrap(connect.proto, 'handle', createWrapHandle(tracer, config))\n    },\n    unpatch (connect) {\n      this.unwrap(connect.proto, 'use')\n      this.unwrap(connect.proto, 'handle')\n    }\n  }\n]\n","'use strict'\n\nconst Plugin = require('../../dd-trace/src/plugins/plugin')\nconst { storage } = require('../../datadog-core')\nconst analyticsSampler = require('../../dd-trace/src/analytics_sampler')\n\nclass CouchBasePlugin extends Plugin {\n  static get name () {\n    return 'couchbase'\n  }\n\n  addSubs (func, start, asyncEnd = defaultAsyncEnd) {\n    this.addSub(`apm:couchbase:${func}:start`, start)\n    this.addSub(`apm:couchbase:${func}:end`, this.exit.bind(this))\n    this.addSub(`apm:couchbase:${func}:error`, errorHandler)\n    this.addSub(`apm:couchbase:${func}:async-end`, asyncEnd)\n  }\n\n  startSpan (operation, customTags, store, bucket) {\n    const tags = {\n      'db.type': 'couchbase',\n      'component': 'couchbase',\n      'service.name': this.config.service || `${this.tracer._service}-couchbase`,\n      'resource.name': `couchbase.${operation}`,\n      'span.kind': 'client'\n    }\n\n    for (const tag in customTags) {\n      tags[tag] = customTags[tag]\n    }\n    const span = this.tracer.startSpan(`couchbase.${operation}`, {\n      childOf: store ? store.span : null,\n      tags\n    })\n\n    span.setTag('couchbase.bucket.name', bucket.name || bucket._name)\n\n    analyticsSampler.sample(span, this.config.measured)\n    return span\n  }\n\n  constructor (...args) {\n    super(...args)\n\n    this.addSubs('query', ({ resource, bucket }) => {\n      const store = storage.getStore()\n      const span = this.startSpan('query', { 'span.type': 'sql', 'resource.name': resource }, store, bucket)\n      this.enter(span, store)\n    })\n\n    this._addCommandSubs('upsert')\n    this._addCommandSubs('insert')\n    this._addCommandSubs('replace')\n    this._addCommandSubs('append')\n    this._addCommandSubs('prepend')\n  }\n  _addCommandSubs (name) {\n    this.addSubs(name, ({ bucket }) => {\n      const store = storage.getStore()\n      const span = this.startSpan(name, {}, store, bucket)\n      this.enter(span, store)\n    })\n  }\n}\n\nfunction defaultAsyncEnd () {\n  storage.getStore().span.finish()\n}\n\nfunction errorHandler (error) {\n  storage.getStore().span.setTag('error', error)\n}\n\nmodule.exports = CouchBasePlugin\n","'use strict'\n\nconst Plugin = require('../../dd-trace/src/plugins/plugin')\nconst { storage } = require('../../datadog-core')\n\nconst {\n  CI_APP_ORIGIN,\n  TEST_TYPE,\n  TEST_NAME,\n  TEST_SUITE,\n  TEST_SKIP_REASON,\n  TEST_FRAMEWORK_VERSION,\n  ERROR_MESSAGE,\n  TEST_STATUS,\n  TEST_CODE_OWNERS,\n  finishAllTraceSpans,\n  getTestEnvironmentMetadata,\n  getTestSuitePath,\n  getCodeOwnersFileEntries,\n  getCodeOwnersForFilename\n} = require('../../dd-trace/src/plugins/util/test')\nconst { SPAN_TYPE, RESOURCE_NAME, SAMPLING_PRIORITY } = require('../../../ext/tags')\nconst { SAMPLING_RULE_DECISION } = require('../../dd-trace/src/constants')\nconst { AUTO_KEEP } = require('../../../ext/priority')\n\nclass CucumberPlugin extends Plugin {\n  static get name () {\n    return 'cucumber'\n  }\n\n  constructor (...args) {\n    super(...args)\n\n    const testEnvironmentMetadata = getTestEnvironmentMetadata('cucumber', this.config)\n    const sourceRoot = process.cwd()\n    const codeOwnersEntries = getCodeOwnersFileEntries(sourceRoot)\n\n    this.addSub('ci:cucumber:run:start', ({ pickleName, pickleUri }) => {\n      const store = storage.getStore()\n      const childOf = store ? store.span : store\n      const testSuite = getTestSuitePath(pickleUri, sourceRoot)\n\n      const testSpanMetadata = {\n        [SPAN_TYPE]: 'test',\n        [RESOURCE_NAME]: pickleName,\n        [TEST_TYPE]: 'test',\n        [TEST_NAME]: pickleName,\n        [TEST_SUITE]: testSuite,\n        [SAMPLING_RULE_DECISION]: 1,\n        [SAMPLING_PRIORITY]: AUTO_KEEP,\n        [TEST_FRAMEWORK_VERSION]: this.tracer._version,\n        ...testEnvironmentMetadata\n      }\n\n      const codeOwners = getCodeOwnersForFilename(testSuite, codeOwnersEntries)\n      if (codeOwners) {\n        testSpanMetadata[TEST_CODE_OWNERS] = codeOwners\n      }\n\n      const span = this.tracer.startSpan('cucumber.test', {\n        childOf,\n        tags: testSpanMetadata\n      })\n\n      span.context()._trace.origin = CI_APP_ORIGIN\n      this.enter(span, store)\n    })\n\n    this.addSub('ci:cucumber:run:end', () => {\n      this.exit()\n    })\n\n    this.addSub('ci:cucumber:run-step:start', ({ resource }) => {\n      const store = storage.getStore()\n      const childOf = store ? store.span : store\n      const span = this.tracer.startSpan('cucumber.step', {\n        childOf,\n        tags: {\n          'cucumber.step': resource,\n          [RESOURCE_NAME]: resource\n        }\n      })\n      this.enter(span, store)\n    })\n\n    this.addSub('ci:cucumber:run-step:end', () => {\n      this.exit()\n    })\n\n    this.addSub('ci:cucumber:run:async-end', ({ isStep, status, skipReason, errorMessage }) => {\n      const span = storage.getStore().span\n      const statusTag = isStep ? 'step.status' : TEST_STATUS\n\n      span.setTag(statusTag, status)\n\n      if (skipReason) {\n        span.setTag(TEST_SKIP_REASON, skipReason)\n      }\n\n      if (errorMessage) {\n        span.setTag(ERROR_MESSAGE, errorMessage)\n      }\n\n      span.finish()\n      if (!isStep) {\n        finishAllTraceSpans(span)\n      }\n    })\n\n    this.addSub('ci:cucumber:error', (err) => {\n      if (err) {\n        const span = storage.getStore().span\n        span.setTag('error', err)\n      }\n    })\n  }\n}\n\nmodule.exports = CucumberPlugin\n","const Plugin = require('../../dd-trace/src/plugins/plugin')\n\n// Cypress plugin does not patch any library. This is just a placeholder to\n// follow the structure of the plugins\nclass CypressPlugin extends Plugin {\n  static get name () {\n    return 'cypress'\n  }\n}\n\nmodule.exports = CypressPlugin\n","'use strict'\n\nconst analyticsSampler = require('../../dd-trace/src/analytics_sampler')\nconst Plugin = require('../../dd-trace/src/plugins/plugin')\nconst { storage } = require('../../datadog-core')\n\nclass DNSPlugin extends Plugin {\n  static get name () {\n    return 'dns'\n  }\n\n  addSubs (func, start, asyncEnd = defaultAsyncEnd) {\n    this.addSub(`apm:dns:${func}:start`, start)\n    this.addSub(`apm:dns:${func}:end`, this.exit.bind(this))\n    this.addSub(`apm:dns:${func}:error`, errorHandler)\n    this.addSub(`apm:dns:${func}:async-end`, asyncEnd)\n  }\n\n  startSpan (name, customTags, store) {\n    const tags = {\n      'service.name': this.config.service || this.tracer._service,\n      'span.kind': 'client'\n    }\n    for (const tag in customTags) {\n      tags[tag] = customTags[tag]\n    }\n    const span = this.tracer.startSpan(name, {\n      childOf: store ? store.span : null,\n      tags\n    })\n    analyticsSampler.sample(span, this.config.measured)\n    return span\n  }\n\n  constructor (...args) {\n    super(...args)\n\n    this.addSubs('lookup', ([hostname]) => {\n      const store = storage.getStore()\n      const span = this.startSpan('dns.lookup', {\n        'resource.name': hostname,\n        'dns.hostname': hostname\n      }, store)\n      this.enter(span, store)\n    }, (result) => {\n      const { span } = storage.getStore()\n      span.setTag('dns.address', result)\n      span.finish()\n    })\n\n    this.addSubs('lookup_service', ([address, port]) => {\n      const store = storage.getStore()\n      const span = this.startSpan('dns.lookup_service', {\n        'resource.name': `${address}:${port}`,\n        'dns.address': address,\n        'dns.port': port\n      }, store)\n      this.enter(span, store)\n    })\n\n    this.addSubs('resolve', ([hostname, maybeType]) => {\n      const store = storage.getStore()\n      const rrtype = typeof maybeType === 'string' ? maybeType : 'A'\n      const span = this.startSpan('dns.resolve', {\n        'resource.name': `${rrtype} ${hostname}`,\n        'dns.hostname': hostname,\n        'dns.rrtype': rrtype\n      }, store)\n      this.enter(span, store)\n    })\n\n    this.addSubs('reverse', ([ip]) => {\n      const store = storage.getStore()\n      const span = this.startSpan('dns.reverse', { 'resource.name': ip, 'dns.ip': ip }, store)\n      this.enter(span, store)\n    })\n  }\n}\n\nfunction defaultAsyncEnd () {\n  storage.getStore().span.finish()\n}\n\nfunction errorHandler (error) {\n  storage.getStore().span.setTag('error', error)\n}\n\nmodule.exports = DNSPlugin\n","'use strict'\n\nconst Plugin = require('../../dd-trace/src/plugins/plugin')\nconst { storage } = require('../../datadog-core')\nconst analyticsSampler = require('../../dd-trace/src/analytics_sampler')\n\nclass ElasticsearchPlugin extends Plugin {\n  static get name () {\n    return 'elasticsearch'\n  }\n\n  constructor (...args) {\n    super(...args)\n\n    this.addSub('apm:elasticsearch:query:start', ({ params }) => {\n      const store = storage.getStore()\n      const childOf = store ? store.span : store\n      const body = getBody(params.body || params.bulkBody)\n      const span = this.tracer.startSpan('elasticsearch.query', {\n        childOf,\n        tags: {\n          'db.type': 'elasticsearch',\n          'span.kind': 'client',\n          'service.name': this.config.service || `${this.tracer._service}-elasticsearch`,\n          'resource.name': `${params.method} ${quantizePath(params.path)}`,\n          'span.type': 'elasticsearch',\n          'elasticsearch.url': params.path,\n          'elasticsearch.method': params.method,\n          'elasticsearch.body': body,\n          'elasticsearch.params': JSON.stringify(params.querystring || params.query)\n        }\n      })\n      analyticsSampler.sample(span, this.config.measured)\n      this.enter(span, store)\n    })\n\n    this.addSub('apm:elasticsearch:query:end', () => {\n      this.exit()\n    })\n\n    this.addSub('apm:elasticsearch:query:error', err => {\n      const span = storage.getStore().span\n      span.setTag('error', err)\n    })\n\n    this.addSub('apm:elasticsearch:query:async-end', ({ params }) => {\n      const span = storage.getStore().span\n      this.config.hooks.query(span, params)\n      span.finish()\n    })\n  }\n\n  configure (config) {\n    return super.configure(normalizeConfig(config))\n  }\n}\n\nfunction normalizeConfig (config) {\n  const hooks = getHooks(config)\n\n  return Object.assign({}, config, {\n    hooks\n  })\n}\n\nfunction getHooks (config) {\n  const noop = () => {}\n  const query = (config.hooks && config.hooks.query) || noop\n\n  return { query }\n}\n\nfunction getBody (body) {\n  return body && JSON.stringify(body)\n}\n\nfunction quantizePath (path) {\n  return path && path.replace(/[0-9]+/g, '?')\n}\n\nmodule.exports = ElasticsearchPlugin\n","'use strict'\n\nconst web = require('../../dd-trace/src/plugins/util/web')\nconst routerPlugin = require('../../datadog-plugin-router/src')\n\nfunction createWrapHandle (tracer, config) {\n  config = web.normalizeConfig(config)\n\n  return function wrapHandle (handle) {\n    return function handleWithTrace (req, res) {\n      web.instrument(tracer, config, req, res, 'express.request')\n\n      return handle.apply(this, arguments)\n    }\n  }\n}\n\nfunction patch (express, tracer, config) {\n  this.wrap(express.application, 'handle', createWrapHandle(tracer, config))\n  routerPlugin.patch.call(this, { prototype: express.Router }, tracer, config)\n}\n\nfunction unpatch (express) {\n  this.unwrap(express.application, 'handle')\n  routerPlugin.unpatch.call(this, { prototype: express.Router })\n}\n\nmodule.exports = {\n  name: 'express',\n  versions: ['>=4'],\n  patch,\n  unpatch\n}\n","'use strict'\n\nconst methods = require('methods').concat('all')\nconst web = require('../../dd-trace/src/plugins/util/web')\n\nfunction createWrapFastify (tracer, config) {\n  config = web.normalizeConfig(config)\n\n  return function wrapFastify (fastify) {\n    if (typeof fastify !== 'function') return fastify\n\n    return function fastifyWithTrace () {\n      const app = fastify.apply(this, arguments)\n\n      if (!app) return app\n\n      if (typeof app.addHook === 'function') {\n        app.addHook('onRequest', createOnRequest(tracer, config))\n        app.addHook('preHandler', preHandler)\n        app.addHook = createWrapAddHook(tracer, config)(app.addHook)\n      }\n\n      methods.forEach(method => {\n        app[method] = wrapMethod(app[method])\n      })\n\n      app.route = wrapRoute(app.route)\n\n      return app\n    }\n  }\n}\n\nfunction createWrapAddHook (tracer, config) {\n  return function wrapAddHook (addHook) {\n    return function addHookWithTrace (name, fn) {\n      fn = arguments[arguments.length - 1]\n\n      if (typeof fn !== 'function') return addHook.apply(this, arguments)\n\n      arguments[arguments.length - 1] = safeWrap(fn, function (request, reply, done) {\n        const req = getReq(request)\n\n        if (!req) return fn.apply(this, arguments)\n\n        done = arguments[arguments.length - 1]\n\n        try {\n          if (typeof done === 'function') {\n            arguments[arguments.length - 1] = function (err) {\n              web.addError(req, err)\n              return done.apply(this, arguments)\n            }\n\n            return fn.apply(this, arguments)\n          } else {\n            const promise = fn.apply(this, arguments)\n\n            if (promise && typeof promise.catch === 'function') {\n              return promise.catch(err => {\n                web.addError(req, err)\n                throw err\n              })\n            }\n\n            return promise\n          }\n        } catch (e) {\n          web.addError(req, e)\n          throw e\n        }\n      })\n\n      return addHook.apply(this, arguments)\n    }\n  }\n}\n\nfunction createOnRequest (tracer, config) {\n  return function onRequest (request, reply, next) {\n    if (typeof next !== 'function') return\n\n    const req = getReq(request)\n    const res = getRes(reply)\n    const name = 'fastify.request'\n\n    return web.instrument(tracer, config, req, res, name, () => next())\n  }\n}\n\nfunction preHandler (request, reply, next) {\n  if (typeof next !== 'function') return\n  if (!reply || typeof reply.send !== 'function') return next()\n\n  reply.send = wrapSend(reply.send)\n\n  next()\n}\n\nfunction wrapSend (send) {\n  return function sendWithTrace (payload) {\n    const req = getReq(this && this.request)\n\n    web.addError(req, payload)\n\n    return send.apply(this, arguments)\n  }\n}\n\nfunction wrapRoute (route) {\n  if (typeof route !== 'function') return route\n\n  return function routeWithTrace (opts) {\n    opts.handler = wrapHandler(opts.handler)\n\n    return route.apply(this, arguments)\n  }\n}\n\nfunction wrapMethod (method) {\n  if (typeof method !== 'function') return method\n\n  return function methodWithTrace (url, opts, handler) {\n    const lastIndex = arguments.length - 1\n\n    handler = arguments[lastIndex]\n\n    if (typeof handler === 'function') {\n      arguments[lastIndex] = wrapHandler(handler)\n    } else if (handler) {\n      arguments[lastIndex].handler = wrapHandler(handler.handler)\n    }\n\n    return method.apply(this, arguments)\n  }\n}\n\nfunction wrapHandler (handler) {\n  if (!handler || typeof handler !== 'function' || handler.name === 'handlerWithTrace') {\n    return handler\n  }\n\n  return function handlerWithTrace (request, reply) {\n    const req = getReq(request)\n\n    return web.reactivate(req, () => handler.apply(this, arguments))\n  }\n}\n\n// TODO: move this to a common util\nfunction safeWrap (fn, wrapper) {\n  Object.defineProperty(wrapper, 'length', Object.getOwnPropertyDescriptor(fn, 'length'))\n\n  return wrapper\n}\n\nfunction getReq (request) {\n  return request && (request.raw || request.req || request)\n}\n\nfunction getRes (reply) {\n  return reply && (reply.raw || reply.res || reply)\n}\n\nmodule.exports = [\n  {\n    name: 'fastify',\n    versions: ['>=3'],\n    patch (fastify, tracer, config) {\n      // `fastify` is a function so we return a wrapper that will replace its export.\n      const wrapped = this.wrapExport(fastify, createWrapFastify(tracer, config)(fastify))\n\n      wrapped.fastify = wrapped\n      wrapped.default = wrapped\n\n      return wrapped\n    },\n    unpatch (fastify) {\n      const unwrapped = this.unwrapExport(fastify)\n\n      unwrapped.fastify = unwrapped\n      unwrapped.default = unwrapped\n\n      return unwrapped\n    }\n  },\n  {\n    name: 'fastify',\n    versions: ['1 - 2'],\n    patch (fastify, tracer, config) {\n      // `fastify` is a function so we return a wrapper that will replace its export.\n      return this.wrapExport(fastify, createWrapFastify(tracer, config)(fastify))\n    },\n    unpatch (fastify) {\n      this.unwrapExport(fastify)\n    }\n  }\n]\n","'use strict'\n\nconst web = require('../../dd-trace/src/plugins/util/web')\n\nfunction createWrapOn () {\n  return function wrapOn (on) {\n    return function onWithTrace (method, path, opts) {\n      const index = typeof opts === 'function' ? 2 : 3\n      const handler = arguments[index]\n      const wrapper = function (req) {\n        web.patch(req)\n        web.enterRoute(req, path)\n\n        return handler.apply(this, arguments)\n      }\n\n      if (typeof handler === 'function') {\n        arguments[index] = wrapper\n      }\n\n      return on.apply(this, arguments)\n    }\n  }\n}\n\nmodule.exports = [\n  {\n    name: 'find-my-way',\n    versions: ['>=1'],\n    patch (Router, tracer, config) {\n      this.wrap(Router.prototype, 'on', createWrapOn(tracer, config))\n    },\n    unpatch (Router) {\n      this.unwrap(Router.prototype, 'on')\n    }\n  }\n]\n","'use strict'\n\nmodule.exports = [].concat(\n  require('./fastify'),\n  require('./find-my-way') // TODO make this its own plugin, since restify uses it too\n)\n","'use strict'\n\nconst { storage } = require('../../datadog-core')\n\nlet kDirReadPromisified\nlet kDirClosePromisified\nlet kHandle\n\nconst ddFhSym = Symbol('ddFileHandle')\n\nconst tagMakers = {\n  open: createOpenTags,\n  close: createCloseTags,\n  readFile: createReadFileTags,\n  writeFile: createWriteFileTags,\n  appendFile: createAppendFileTags,\n  access: createPathTags,\n  copyFile: createCopyFileTags,\n  stat: createPathTags,\n  lstat: createPathTags,\n  fstat: createFDTags,\n  readdir: createPathTags,\n  opendir: createPathTags,\n  read: createFDTags,\n  write: createFDTags,\n  writev: createFDTags,\n  chmod: createChmodTags,\n  lchmod: createChmodTags,\n  fchmod: createFchmodTags,\n  chown: createChownTags,\n  lchown: createChownTags,\n  fchown: createFchownTags,\n  realpath: createPathTags,\n  readlink: createPathTags,\n  unlink: createPathTags,\n  symlink: createCopyFileTags,\n  link: createCopyFileTags,\n  rmdir: createPathTags,\n  rename: createCopyFileTags,\n  fsync: createFDTags,\n  fdatasync: createFDTags,\n  mkdir: createPathTags,\n  truncate: createPathTags,\n  ftruncate: createFDTags,\n  utimes: createPathTags,\n  futimes: createFDTags,\n  mkdtemp: createPathTags\n}\n\nconst promisifiable = ['read', 'readv', 'write', 'writev']\n\nconst orphanable = false\n\nfunction createWrapCreateReadStream (config, tracer) {\n  return function wrapCreateReadStream (createReadStream) {\n    return function createReadStreamWithTrace (path, options) {\n      if (!hasParent()) {\n        return createReadStream.apply(this, arguments)\n      }\n      const tags = makeFSFlagTags('ReadStream', path, options, 'r', config, tracer)\n      return tracer.trace('fs.operation', { tags, orphanable }, (span, done) => {\n        const stream = createReadStream.apply(this, arguments)\n        stream.once('end', done)\n        stream.once('error', done)\n        return stream\n      })\n    }\n  }\n}\n\nfunction createWrapCreateWriteStream (config, tracer) {\n  return function wrapCreateWriteStream (createWriteStream) {\n    return function createWriteStreamWithTrace (path, options) {\n      const tags = makeFSFlagTags('WriteStream', path, options, 'w', config, tracer)\n      return tracer.trace('fs.operation', { tags, orphanable }, (span, done) => {\n        const stream = createWriteStream.apply(this, arguments)\n        stream.once('finish', done)\n        stream.once('error', done)\n        return stream\n      })\n    }\n  }\n}\n\nfunction createWrapExists (config, tracer) {\n  return function wrapExists (exists) {\n    const existsWithTrace = function existsWithTrace (path, cb) {\n      if (typeof cb !== 'function') {\n        return exists.apply(this, arguments)\n      }\n      const tags = makeFSTags('exists', path, null, config, tracer)\n      return tracer.trace('fs.operation', { tags, orphanable }, (span, done) => {\n        arguments[1] = function (result) {\n          done()\n          cb.apply(this, arguments)\n        }\n        return exists.apply(this, arguments)\n      })\n    }\n\n    copySymbols(exists, existsWithTrace)\n\n    return existsWithTrace\n  }\n}\n\nfunction createWrapDirRead (config, tracer, sync) {\n  const name = sync ? 'dir.readSync' : 'dir.read'\n  return function wrapDirRead (read) {\n    function options () {\n      const tags = makeFSTags(name, this.path, null, config, tracer)\n      return { tags, orphanable }\n    }\n    return tracer.wrap('fs.operation', options, read, true)\n  }\n}\n\nfunction createWrapDirClose (config, tracer, sync) {\n  const name = sync ? 'dir.closeSync' : 'dir.close'\n  return function wrapDirClose (close) {\n    function options () {\n      const tags = makeFSTags(name, this.path, null, config, tracer)\n      return { tags, orphanable }\n    }\n    return tracer.wrap('fs.operation', options, close, true)\n  }\n}\n\nfunction createWrapDirAsyncIterator (config, tracer, instrumenter) {\n  return function wrapDirAsyncIterator (asyncIterator) {\n    return function asyncIteratorWithTrace () {\n      if (!kDirReadPromisified) {\n        const keys = Reflect.ownKeys(this)\n        for (const key of keys) {\n          if (kDirReadPromisified && kDirClosePromisified) break\n          if (typeof key !== 'symbol') continue\n          if (!kDirReadPromisified && getSymbolName(key).includes('kDirReadPromisified')) {\n            kDirReadPromisified = key\n          }\n          if (!kDirClosePromisified && getSymbolName(key).includes('kDirClosePromisified')) {\n            kDirClosePromisified = key\n          }\n        }\n      }\n      instrumenter.wrap(this, kDirReadPromisified, createWrapDirRead(config, tracer))\n      instrumenter.wrap(this, kDirClosePromisified, createWrapKDirClose(config, tracer, instrumenter))\n      return asyncIterator.apply(this, arguments)\n    }\n  }\n}\n\nfunction createWrapKDirClose (config, tracer, instrumenter) {\n  return function wrapKDirClose (kDirClose) {\n    return function kDirCloseWithTrace () {\n      const tags = makeFSTags('dir.close', this.path, null, config, tracer)\n      return tracer.trace('fs.operation', { tags, orphanable }, (span) => {\n        const p = kDirClose.apply(this, arguments)\n        const unwrapBoth = () => {\n          instrumenter.unwrap(this, kDirReadPromisified)\n          instrumenter.unwrap(this, kDirClosePromisified)\n        }\n        p.then(unwrapBoth, unwrapBoth)\n        return p\n      })\n    }\n  }\n}\n\nfunction createOpenTags (resourceName, config, tracer) {\n  return function openTags (path, flag, mode) {\n    if (!flag || typeof flag === 'function') {\n      flag = null\n    }\n    return makeFSFlagTags(resourceName, path, { flag }, 'r', config, tracer)\n  }\n}\n\nfunction createCloseTags (resourceName, config, tracer) {\n  return function closeTags (fd) {\n    if (typeof fd === 'undefined' && this && this[ddFhSym]) {\n      fd = this[ddFhSym].fd\n    }\n    if (typeof fd !== 'number' || !Number.isInteger(fd)) {\n      return\n    }\n    return makeFSTags(resourceName, fd, null, config, tracer)\n  }\n}\n\nfunction createReadFileTags (resourceName, config, tracer) {\n  return function readFileTags (path, options) {\n    return makeFSFlagTags(resourceName, path, options, 'r', config, tracer)\n  }\n}\n\nfunction createWriteFileTags (resourceName, config, tracer) {\n  return function writeFileTags (path, data, options) {\n    return makeFSFlagTags(resourceName, path, options, 'w', config, tracer)\n  }\n}\n\nfunction createAppendFileTags (resourceName, config, tracer) {\n  return function appendFileTags (path, data, options) {\n    return makeFSFlagTags(resourceName, path, options, 'a', config, tracer)\n  }\n}\n\nfunction createCopyFileTags (resourceName, config, tracer) {\n  return function copyFileTags (src, dest, flag) {\n    return makeFSTags(resourceName, { src, dest }, null, config, tracer)\n  }\n}\n\nfunction createChmodTags (resourceName, config, tracer) {\n  return function chmodTags (fd, mode) {\n    const tags = makeFSTags(resourceName, fd, null, config, tracer)\n    tags['file.mode'] = mode.toString(8)\n    return tags\n  }\n}\n\nfunction createFchmodTags (resourceName, config, tracer) {\n  return function fchmodTags (fd, mode) {\n    if (typeof this === 'object' && this !== null && this.fd) {\n      mode = fd\n      fd = this.fd\n    }\n\n    const tags = makeFSTags(resourceName, fd, null, config, tracer)\n    if (mode) {\n      tags['file.mode'] = mode.toString(8)\n    }\n    return tags\n  }\n}\n\nfunction createPathTags (resourceName, config, tracer) {\n  return function pathTags (path) {\n    return makeFSTags(resourceName, path, null, config, tracer)\n  }\n}\n\nfunction createFDTags (resourceName, config, tracer) {\n  return function fdTags (fd) {\n    if (typeof this === 'object' && this !== null && this.fd) {\n      fd = this.fd\n    }\n    return makeFSTags(resourceName, fd, null, config, tracer)\n  }\n}\n\nfunction createChownTags (resourceName, config, tracer) {\n  return function chownTags (fd, uid, gid) {\n    const tags = makeFSTags(resourceName, fd, null, config, tracer)\n    if (typeof uid === 'number') {\n      tags['file.uid'] = uid.toString()\n    }\n    if (typeof gid === 'number') {\n      tags['file.gid'] = gid.toString()\n    }\n    return tags\n  }\n}\n\nfunction createFchownTags (resourceName, config, tracer) {\n  return function fchownTags (fd, uid, gid) {\n    if (typeof this === 'object' && this !== null && this.fd) {\n      gid = uid\n      uid = fd\n      fd = this.fd\n    }\n    const tags = makeFSTags(resourceName, fd, null, config, tracer)\n    if (typeof uid === 'number') {\n      tags['file.uid'] = uid.toString()\n    }\n    if (typeof gid === 'number') {\n      tags['file.gid'] = gid.toString()\n    }\n    return tags\n  }\n}\n\nfunction getSymbolName (sym) {\n  return sym.description || sym.toString()\n}\n\nfunction hasParent () {\n  const store = storage.getStore()\n\n  return store && store.span && !store.noop\n}\n\nfunction createWrapCb (tracer, config, name, tagMaker) {\n  const makeTags = tagMaker(name, config, tracer)\n  return function wrapFunction (fn) {\n    return tracer.wrap('fs.operation', function () {\n      if (typeof arguments[arguments.length - 1] !== 'function') {\n        return\n      }\n      const tags = makeTags.apply(this, arguments)\n      return tags ? { tags, orphanable } : { orphanable }\n    }, fn, true)\n  }\n}\n\nfunction createWrap (tracer, config, name, tagMaker) {\n  const makeTags = tagMaker(name, config, tracer)\n\n  return function wrapSyncFunction (fn) {\n    return tracer.wrap('fs.operation', function () {\n      const tags = makeTags.apply(this, arguments)\n      return tags ? { tags, orphanable } : { orphanable }\n    }, fn, true)\n  }\n}\n\nfunction makeFSFlagTags (resourceName, path, options, defaultFlag, config, tracer) {\n  const tags = makeFSTags(resourceName, path, options, config, tracer)\n\n  if (tags) {\n    let flag = defaultFlag\n    if (typeof options === 'object' && options !== null) {\n      if (options.flag) {\n        flag = options.flag\n      } else if (options.flags) {\n        flag = options.flags\n      }\n    }\n    tags['file.flag'] = flag\n    return tags\n  }\n}\n\nfunction makeFSTags (resourceName, path, options, config, tracer) {\n  path = options && typeof options === 'object' && 'fd' in options ? options.fd : path\n  const tags = {\n    'component': 'fs',\n    'span.kind': 'internal',\n    'resource.name': resourceName,\n    'service.name': config.service || tracer._service\n  }\n\n  switch (typeof path) {\n    case 'object': {\n      if (path === null) return tags\n      const src = 'src' in path ? path.src : null\n      const dest = 'dest' in path ? path.dest : null\n      if (src || dest) {\n        tags['file.src'] = src\n        tags['file.dest'] = dest\n      } else {\n        tags['file.path'] = path\n      }\n      break\n    }\n    case 'string': {\n      tags['file.path'] = path\n      break\n    }\n    case 'number': {\n      tags['file.descriptor'] = path.toString()\n      break\n    }\n  }\n\n  return tags\n}\n\nfunction copySymbols (from, to) {\n  const props = Object.getOwnPropertyDescriptors(from)\n  const keys = Reflect.ownKeys(props)\n\n  for (const key of keys) {\n    if (typeof key !== 'symbol' || to.hasOwnProperty(key)) continue\n\n    Object.defineProperty(to, key, props[key])\n  }\n}\n\nfunction getFileHandlePrototype (fs) {\n  return fs.promises.open(__filename, 'r')\n    .then(fh => {\n      if (!kHandle) {\n        kHandle = Reflect.ownKeys(fh).find(key => typeof key === 'symbol' && key.toString().includes('kHandle'))\n      }\n      fh.close()\n\n      return Object.getPrototypeOf(fh)\n    })\n}\n\nfunction patchClassicFunctions (fs, tracer, config) {\n  for (const name in fs) {\n    if (!fs[name]) continue\n    const tagMakerName = name.endsWith('Sync') ? name.substr(0, name.length - 4) : name\n    const original = fs[name]\n    if (tagMakerName in tagMakers) {\n      const tagMaker = tagMakers[tagMakerName]\n      if (name.endsWith('Sync')) {\n        this.wrap(fs, name, createWrap(tracer, config, name, tagMaker))\n      } else {\n        this.wrap(fs, name, createWrapCb(tracer, config, name, tagMaker))\n      }\n      if (name in promisifiable) {\n        copySymbols(original, fs[name])\n      }\n    }\n  }\n}\n\nfunction patchFileHandle (fs, tracer, config) {\n  getFileHandlePrototype(fs).then((fileHandlePrototype) => {\n    for (const name of Reflect.ownKeys(fileHandlePrototype)) {\n      if (typeof name !== 'string' || name === 'constructor' || name === 'fd' || name === 'getAsyncId') {\n        continue\n      }\n      let tagMaker\n      const fName = 'f' + name\n      if (fName in tagMakers) {\n        tagMaker = tagMakers[fName]\n      } else {\n        tagMaker = createFDTags\n      }\n\n      const instrumenter = this\n\n      const desc = Reflect.getOwnPropertyDescriptor(fileHandlePrototype, kHandle)\n      if (!desc || !desc.get) {\n        Reflect.defineProperty(fileHandlePrototype, kHandle, {\n          get () {\n            return this[ddFhSym]\n          },\n          set (h) {\n            this[ddFhSym] = h\n            instrumenter.wrap(this, 'close', createWrap(tracer, config, 'filehandle.close', tagMakers.close))\n          },\n          configurable: true\n        })\n      }\n\n      this.wrap(fileHandlePrototype, name, createWrap(tracer, config, 'filehandle.' + name, tagMaker))\n    }\n  })\n}\n\nfunction patchPromiseFunctions (fs, tracer, config) {\n  for (const name in fs.promises) {\n    if (name in tagMakers) {\n      const tagMaker = tagMakers[name]\n      this.wrap(fs.promises, name, createWrap(tracer, config, 'promises.' + name, tagMaker))\n    }\n  }\n}\n\nfunction patchDirFunctions (fs, tracer, config) {\n  this.wrap(fs.Dir.prototype, 'close', createWrapDirClose(config, tracer))\n  this.wrap(fs.Dir.prototype, 'closeSync', createWrapDirClose(config, tracer, true))\n  this.wrap(fs.Dir.prototype, 'read', createWrapDirRead(config, tracer))\n  this.wrap(fs.Dir.prototype, 'readSync', createWrapDirRead(config, tracer, true))\n  this.wrap(fs.Dir.prototype, Symbol.asyncIterator, createWrapDirAsyncIterator(config, tracer, this))\n}\n\nfunction unpatchClassicFunctions (fs) {\n  for (const name in fs) {\n    if (!fs[name]) continue\n    const tagMakerName = name.endsWith('Sync') ? name.substr(0, name.length - 4) : name\n    if (tagMakerName in tagMakers) {\n      this.unwrap(fs, name)\n    }\n  }\n}\n\nfunction unpatchFileHandle (fs) {\n  getFileHandlePrototype(fs).then(fileHandlePrototype => {\n    for (const name of Reflect.ownKeys(fileHandlePrototype)) {\n      if (typeof name !== 'string' || name === 'constructor' || name === 'fd' || name === 'getAsyncId') {\n        continue\n      }\n      this.unwrap(fileHandlePrototype, name)\n    }\n    delete fileHandlePrototype[kHandle]\n  })\n}\n\nfunction unpatchPromiseFunctions (fs) {\n  for (const name in fs.promises) {\n    if (name in tagMakers) {\n      this.unwrap(fs.promises, name)\n    }\n  }\n}\n\nfunction unpatchDirFunctions (fs) {\n  this.unwrap(fs.Dir.prototype, 'close')\n  this.unwrap(fs.Dir.prototype, 'closeSync')\n  this.unwrap(fs.Dir.prototype, 'read')\n  this.unwrap(fs.Dir.prototype, 'readSync')\n  this.unwrap(fs.Dir.prototype, Symbol.asyncIterator)\n}\n\nmodule.exports = {\n  name: 'fs',\n  patch (fs, tracer, config) {\n    const realpathNative = fs.realpath.native\n    const realpathSyncNative = fs.realpathSync.native\n    patchClassicFunctions.call(this, fs, tracer, config)\n    if (fs.promises) {\n      patchFileHandle.call(this, fs, tracer, config)\n      patchPromiseFunctions.call(this, fs, tracer, config)\n    }\n    if (fs.Dir) {\n      patchDirFunctions.call(this, fs, tracer, config)\n    }\n    this.wrap(fs, 'createReadStream', createWrapCreateReadStream(config, tracer))\n    this.wrap(fs, 'createWriteStream', createWrapCreateWriteStream(config, tracer))\n    this.wrap(fs, 'existsSync', createWrap(tracer, config, 'existsSync', createPathTags))\n    this.wrap(fs, 'exists', createWrapExists(config, tracer))\n    if (realpathNative) {\n      fs.realpath.native = createWrapCb(tracer, config, 'realpath.native', createPathTags)(realpathNative)\n    }\n    if (realpathSyncNative) {\n      fs.realpathSync.native = createWrap(tracer, config, 'realpath.native', createPathTags)(realpathSyncNative)\n    }\n  },\n  unpatch (fs) {\n    unpatchClassicFunctions.call(this, fs)\n    if (fs.promises) {\n      unpatchFileHandle.call(this, fs)\n      unpatchPromiseFunctions.call(this, fs)\n    }\n    if (fs.Dir) {\n      unpatchDirFunctions.call(this, fs)\n    }\n    this.unwrap(fs, 'createReadStream')\n    this.unwrap(fs, 'createWriteStream')\n    this.unwrap(fs, 'existsSync')\n    this.unwrap(fs, 'exists')\n  }\n}\n\n/** TODO fs functions:\n\nunwatchFile\nwatch\nwatchFile\n*/\n","'use strict'\n\nconst analyticsSampler = require('../../dd-trace/src/analytics_sampler')\n\nconst messageSpans = new WeakMap()\n\nfunction createWrapRequest (tracer, config) {\n  return function wrapRequest (request) {\n    return function requestWithTrace (cfg = { reqOpts: {} }, cb) {\n      const topic = getTopic(cfg)\n      const tags = {\n        component: '@google-cloud/pubsub',\n        'resource.name': [cfg.method, topic].filter(x => x).join(' '),\n        'service.name': config.service || `${tracer._service}-pubsub`,\n        'span.kind': 'client',\n        'pubsub.method': cfg.method,\n        'gcloud.project_id': this.projectId,\n        'pubsub.topic': topic\n      }\n      if (cfg.method === 'publish') {\n        tags['span.kind'] = 'producer'\n      }\n      cb = tracer.scope().bind(cb)\n      return tracer.trace('pubsub.request', { tags }, (span, done) => {\n        analyticsSampler.sample(span, config.measured)\n\n        if (cfg.reqOpts && cfg.method === 'publish') {\n          for (const msg of cfg.reqOpts.messages) {\n            if (!msg.attributes) {\n              msg.attributes = {}\n            }\n            tracer.inject(span, 'text_map', msg.attributes)\n          }\n        }\n\n        arguments[1] = function (err) {\n          done(err)\n          return cb.apply(this, arguments)\n        }\n\n        return request.apply(this, arguments)\n      })\n    }\n  }\n}\n\nfunction createWrapSubscriptionEmit (tracer, config) {\n  return function wrapSubscriptionEmit (emit) {\n    return function emitWithTrace (eventName, message) {\n      if (eventName !== 'message' || !message) return emit.apply(this, arguments)\n\n      const span = messageSpans.get(message)\n\n      if (!span) return emit.apply(this, arguments)\n\n      return tracer.scope().activate(span, () => {\n        try {\n          return emit.apply(this, arguments)\n        } catch (e) {\n          span.setTag('error', e)\n          throw e\n        }\n      })\n    }\n  }\n}\n\nfunction createWrapLeaseDispense (tracer, config) {\n  return function wrapDispense (dispense) {\n    return function dispenseWithTrace (message) {\n      const subscription = message._subscriber._subscription\n      const topic = subscription.metadata && subscription.metadata.topic\n      const tags = {\n        component: '@google-cloud/pubsub',\n        'resource.name': topic,\n        'service.name': config.service || tracer._service,\n        'gcloud.project_id': subscription.pubsub.projectId,\n        'pubsub.topic': topic,\n        'span.kind': 'consumer',\n        'span.type': 'worker'\n      }\n\n      const childOf = tracer.extract('text_map', message.attributes)\n      const span = tracer.startSpan('pubsub.receive', { tags, childOf })\n\n      analyticsSampler.sample(span, config.measured, true)\n\n      messageSpans.set(message, span)\n\n      return dispense.apply(this, arguments)\n    }\n  }\n}\n\nfunction createWrapLeaseRemove (tracer, config) {\n  return function wrapRemove (remove) {\n    return function removeWithTrace (message) {\n      finish(message)\n\n      return remove.apply(this, arguments)\n    }\n  }\n}\n\nfunction createWrapLeaseClear (tracer, config) {\n  return function wrapClear (clear) {\n    return function clearWithTrace () {\n      for (const message of this._messages) {\n        finish(message)\n      }\n\n      return clear.apply(this, arguments)\n    }\n  }\n}\n\nfunction getTopic (cfg) {\n  if (cfg.reqOpts) {\n    return cfg.reqOpts[cfg.method === 'createTopic' ? 'name' : 'topic']\n  }\n}\n\nfunction finish (message) {\n  const span = messageSpans.get(message)\n\n  if (!span) return\n\n  span.setTag('pubsub.ack', message._handled ? 1 : 0)\n  span.finish()\n}\n\nmodule.exports = [\n  {\n    name: '@google-cloud/pubsub',\n    versions: ['>=1.2'],\n    patch ({ PubSub, Subscription }, tracer, config) {\n      this.wrap(PubSub.prototype, 'request', createWrapRequest(tracer, config))\n      this.wrap(Subscription.prototype, 'emit', createWrapSubscriptionEmit(tracer, config))\n    },\n    unpatch ({ PubSub, Subscription }) {\n      this.unwrap(PubSub.prototype, 'request')\n      this.unwrap(Subscription.prototype, 'emit')\n    }\n  },\n  {\n    name: '@google-cloud/pubsub',\n    versions: ['>=1.2'],\n    file: 'build/src/lease-manager.js',\n    patch ({ LeaseManager }, tracer, config) {\n      this.wrap(LeaseManager.prototype, '_dispense', createWrapLeaseDispense(tracer, config))\n      this.wrap(LeaseManager.prototype, 'remove', createWrapLeaseRemove(tracer, config))\n      this.wrap(LeaseManager.prototype, 'clear', createWrapLeaseClear(tracer, config))\n    },\n    unpatch ({ LeaseManager }) {\n      this.unwrap(LeaseManager.prototype, '_dispense')\n      this.unwrap(LeaseManager.prototype, 'remove')\n      this.unwrap(LeaseManager.prototype, 'clear')\n    }\n  }\n]\n","'use strict'\n\nconst pick = require('lodash.pick')\nconst log = require('../../dd-trace/src/log')\nconst analyticsSampler = require('../../dd-trace/src/analytics_sampler')\n\nconst contexts = new WeakMap()\nconst documentSources = new WeakMap()\nconst patchedTypes = new WeakSet()\nconst patchedResolvers = new WeakSet()\n\nlet tools\n\nfunction createWrapExecute (tracer, config, defaultFieldResolver) {\n  return function wrapExecute (execute) {\n    return function executeWithTrace () {\n      const args = normalizeArgs(arguments, tracer, config, defaultFieldResolver)\n      const schema = args.schema\n      const document = args.document\n      const source = documentSources.get(document)\n      const contextValue = args.contextValue\n      const operation = getOperation(document, args.operationName)\n\n      if (contexts.has(contextValue)) {\n        return execute.apply(this, arguments)\n      }\n\n      if (schema) {\n        wrapFields(schema._queryType, tracer, config)\n        wrapFields(schema._mutationType, tracer, config)\n      }\n\n      const span = startExecutionSpan(tracer, config, operation, args)\n      const context = { source, span, fields: {} }\n\n      contexts.set(contextValue, context)\n\n      return call(execute, span, this, arguments, (err, res) => {\n        finishResolvers(context)\n\n        setError(span, err || (res && res.errors && res.errors[0]))\n        config.hooks.execute(span, args, res)\n        finish(span)\n      })\n    }\n  }\n}\n\nfunction createWrapParse (tracer, config) {\n  return function wrapParse (parse) {\n    return function parseWithTrace (source) {\n      const span = startSpan(tracer, config, 'parse')\n\n      analyticsSampler.sample(span, config.measured, true)\n\n      let document\n      try {\n        document = parse.apply(this, arguments)\n        const operation = getOperation(document)\n\n        if (!operation) return document // skip schema parsing\n\n        if (source) {\n          documentSources.set(document, source.body || source)\n        }\n\n        addDocumentTags(span, document, config)\n\n        return document\n      } catch (e) {\n        setError(span, e)\n        throw e\n      } finally {\n        config.hooks.parse(span, source, document)\n        finish(span)\n      }\n    }\n  }\n}\n\nfunction createWrapValidate (tracer, config) {\n  return function wrapValidate (validate) {\n    return function validateWithTrace (schema, document, rules, typeInfo) {\n      const span = startSpan(tracer, config, 'validate')\n\n      analyticsSampler.sample(span, config.measured, true)\n\n      // skip for schema stitching nested validation\n      if (document && document.loc) {\n        addDocumentTags(span, document, config)\n      }\n\n      let errors\n      try {\n        errors = validate.apply(this, arguments)\n\n        setError(span, errors && errors[0])\n\n        return errors\n      } catch (e) {\n        setError(span, e)\n        throw e\n      } finally {\n        config.hooks.validate(span, document, errors)\n        finish(span)\n      }\n    }\n  }\n}\n\nfunction wrapFields (type, tracer, config) {\n  if (!type || !type._fields || patchedTypes.has(type)) {\n    return\n  }\n\n  patchedTypes.add(type)\n\n  Object.keys(type._fields).forEach(key => {\n    const field = type._fields[key]\n\n    wrapFieldResolve(field, tracer, config)\n    wrapFieldType(field, tracer, config)\n  })\n}\n\nfunction wrapFieldResolve (field, tracer, config) {\n  if (!field || !field.resolve) return\n\n  field.resolve = wrapResolve(field.resolve, tracer, config)\n}\n\nfunction wrapFieldType (field, tracer, config) {\n  if (!field || !field.type) return\n\n  let unwrappedType = field.type\n\n  while (unwrappedType.ofType) {\n    unwrappedType = unwrappedType.ofType\n  }\n\n  wrapFields(unwrappedType, tracer, config)\n}\n\nfunction wrapResolve (resolve, tracer, config) {\n  if (typeof resolve !== 'function' || patchedResolvers.has(resolve)) return resolve\n\n  const responsePathAsArray = config.collapse\n    ? withCollapse(pathToArray)\n    : pathToArray\n\n  function resolveWithTrace (source, args, contextValue, info) {\n    const context = contexts.get(contextValue)\n\n    if (!context) return resolve.apply(this, arguments)\n\n    const path = responsePathAsArray(info && info.path)\n\n    if (config.depth >= 0) {\n      const depth = path.filter(item => typeof item === 'string').length\n\n      if (config.depth < depth) {\n        const parent = getParentField(tracer, context, path)\n\n        return call(resolve, parent.span, this, arguments)\n      }\n    }\n\n    const field = assertField(tracer, config, context, info, path)\n\n    return call(resolve, field.span, this, arguments, err => updateField(field, err))\n  }\n\n  patchedResolvers.add(resolveWithTrace)\n\n  return resolveWithTrace\n}\n\nfunction call (fn, span, thisArg, args, callback) {\n  const scope = span.tracer().scope()\n\n  callback = callback || (() => {})\n\n  try {\n    const result = scope.activate(span, () => fn.apply(thisArg, args))\n\n    if (result && typeof result.then === 'function') {\n      result.then(\n        res => callback(null, res),\n        err => callback(err)\n      )\n    } else {\n      callback(null, result)\n    }\n\n    return result\n  } catch (e) {\n    callback(e)\n    throw e\n  }\n}\n\nfunction getParentField (tracer, context, path) {\n  for (let i = path.length - 1; i > 0; i--) {\n    const field = getField(context, path.slice(0, i))\n\n    if (field) {\n      return field\n    }\n  }\n\n  return {\n    span: context.span\n  }\n}\n\nfunction getField (context, path) {\n  return context.fields[path.join('.')]\n}\n\nfunction normalizeArgs (args, tracer, config, defaultFieldResolver) {\n  if (args.length !== 1) return normalizePositional(args, tracer, config, defaultFieldResolver)\n\n  args[0].contextValue = args[0].contextValue || {}\n  args[0].fieldResolver = wrapResolve(args[0].fieldResolver || defaultFieldResolver, tracer, config)\n\n  return args[0]\n}\n\nfunction normalizePositional (args, tracer, config, defaultFieldResolver) {\n  args[3] = args[3] || {} // contextValue\n  args[6] = wrapResolve(args[6] || defaultFieldResolver, tracer, config) // fieldResolver\n  args.length = Math.max(args.length, 7)\n\n  return {\n    schema: args[0],\n    document: args[1],\n    rootValue: args[2],\n    contextValue: args[3],\n    variableValues: args[4],\n    operationName: args[5],\n    fieldResolver: args[6]\n  }\n}\n\nfunction startExecutionSpan (tracer, config, operation, args) {\n  const span = startSpan(tracer, config, 'execute')\n\n  addExecutionTags(span, config, operation, args.document, args.operationName)\n  addDocumentTags(span, args.document, config)\n  addVariableTags(tracer, config, span, args.variableValues)\n\n  analyticsSampler.sample(span, config.measured, true)\n\n  return span\n}\n\nfunction addExecutionTags (span, config, operation, document, operationName) {\n  const type = operation && operation.operation\n  const name = operation && operation.name && operation.name.value\n  const tags = {\n    'resource.name': getSignature(document, name, type, config.signature)\n  }\n\n  if (type) {\n    tags['graphql.operation.type'] = type\n  }\n\n  if (name) {\n    tags['graphql.operation.name'] = name\n  }\n\n  span.addTags(tags)\n}\n\nfunction addDocumentTags (span, document, config) {\n  const tags = {}\n\n  if (config.source && document) {\n    tags['graphql.source'] = documentSources.get(document)\n  }\n\n  span.addTags(tags)\n}\n\nfunction addVariableTags (tracer, config, span, variableValues) {\n  const tags = {}\n\n  if (variableValues && config.variables) {\n    const variables = config.variables(variableValues)\n    for (const param in variables) {\n      tags[`graphql.variables.${param}`] = variables[param]\n    }\n  }\n\n  span.addTags(tags)\n}\n\nfunction startSpan (tracer, config, name, options) {\n  options = options || {}\n\n  return tracer.startSpan(`graphql.${name}`, {\n    childOf: options.childOf || tracer.scope().active(),\n    startTime: options.startTime,\n    tags: {\n      'service.name': getService(tracer, config),\n      'span.type': 'graphql'\n    }\n  })\n}\n\nfunction startResolveSpan (tracer, config, childOf, path, info, { source }) {\n  const span = startSpan(tracer, config, 'resolve', { childOf })\n  const document = source\n  const fieldNode = info.fieldNodes.find(fieldNode => fieldNode.kind === 'Field')\n\n  analyticsSampler.sample(span, config.measured)\n\n  span.addTags({\n    'resource.name': `${info.fieldName}:${info.returnType}`,\n    'graphql.field.name': info.fieldName,\n    'graphql.field.path': path.join('.'),\n    'graphql.field.type': info.returnType.name\n  })\n\n  if (fieldNode) {\n    if (config.source && document && fieldNode.loc) {\n      span.setTag('graphql.source', document.substring(fieldNode.loc.start, fieldNode.loc.end))\n    }\n\n    if (config.variables && fieldNode.arguments) {\n      const variables = config.variables(info.variableValues)\n\n      fieldNode.arguments\n        .filter(arg => arg.value && arg.value.kind === 'Variable')\n        .filter(arg => arg.value.name && variables[arg.value.name.value])\n        .map(arg => arg.value.name.value)\n        .forEach(name => {\n          span.setTag(`graphql.variables.${name}`, variables[name])\n        })\n    }\n  }\n\n  return span\n}\n\nfunction setError (span, error) {\n  if (error) {\n    span.setTag('error', error)\n  }\n}\n\nfunction finish (span, finishTime) {\n  span.finish(finishTime)\n}\n\nfunction finishResolvers ({ fields }) {\n  Object.keys(fields).reverse().forEach(key => {\n    const field = fields[key]\n\n    setError(field.span, field.error)\n    finish(field.span, field.finishTime)\n  })\n}\n\nfunction updateField (field, error) {\n  // TODO: update this to also work with no-op spans without a hack\n  field.finishTime = field.span._getTime ? field.span._getTime() : 0\n  field.error = field.error || error\n}\n\nfunction withCollapse (responsePathAsArray) {\n  return function () {\n    return responsePathAsArray.apply(this, arguments)\n      .map(segment => typeof segment === 'number' ? '*' : segment)\n  }\n}\n\nfunction assertField (tracer, config, context, info, path) {\n  const pathString = path.join('.')\n  const fields = context.fields\n\n  let field = fields[pathString]\n\n  if (!field) {\n    const parent = getParentField(tracer, context, path)\n\n    field = fields[pathString] = {\n      parent,\n      span: startResolveSpan(tracer, config, parent.span, path, info, context),\n      error: null\n    }\n  }\n\n  return field\n}\n\nfunction getService (tracer, config) {\n  return config.service || tracer._service\n}\n\nfunction getOperation (document, operationName) {\n  if (!document || !Array.isArray(document.definitions)) {\n    return\n  }\n\n  const definitions = document.definitions.filter(def => def)\n  const types = ['query', 'mutation', 'subscription']\n\n  if (operationName) {\n    return definitions\n      .filter(def => types.indexOf(def.operation) !== -1)\n      .find(def => operationName === (def.name && def.name.value))\n  } else {\n    return definitions.find(def => types.indexOf(def.operation) !== -1)\n  }\n}\n\nfunction validateConfig (config) {\n  return Object.assign({}, config, {\n    depth: getDepth(config),\n    variables: getVariablesFilter(config),\n    collapse: config.collapse === undefined || !!config.collapse,\n    hooks: getHooks(config)\n  })\n}\n\nfunction getDepth (config) {\n  if (typeof config.depth === 'number') {\n    return config.depth\n  } else if (config.hasOwnProperty('depth')) {\n    log.error('Expected `depth` to be a integer.')\n  }\n  return -1\n}\n\nfunction getVariablesFilter (config) {\n  if (typeof config.variables === 'function') {\n    return config.variables\n  } else if (config.variables instanceof Array) {\n    return variables => pick(variables, config.variables)\n  } else if (config.hasOwnProperty('variables')) {\n    log.error('Expected `variables` to be an array or function.')\n  }\n  return null\n}\n\nfunction getSignature (document, operationName, operationType, calculate) {\n  if (calculate !== false && tools !== false) {\n    try {\n      try {\n        tools = tools || require('./tools')\n      } catch (e) {\n        tools = false\n        throw e\n      }\n\n      return tools.defaultEngineReportingSignature(document, operationName)\n    } catch (e) {\n      // safety net\n    }\n  }\n\n  return [operationType, operationName].filter(val => val).join(' ')\n}\n\nfunction pathToArray (path) {\n  const flattened = []\n  let curr = path\n  while (curr) {\n    flattened.push(curr.key)\n    curr = curr.prev\n  }\n  return flattened.reverse()\n}\n\nfunction getHooks (config) {\n  const noop = () => {}\n  const execute = (config.hooks && config.hooks.execute) || noop\n  const parse = (config.hooks && config.hooks.parse) || noop\n  const validate = (config.hooks && config.hooks.validate) || noop\n\n  return { execute, parse, validate }\n}\n\nmodule.exports = [\n  {\n    name: 'graphql',\n    file: 'execution/execute.js',\n    versions: ['>=0.10'],\n    patch (execute, tracer, config) {\n      this.wrap(execute, 'execute', createWrapExecute(\n        tracer,\n        validateConfig(config),\n        execute.defaultFieldResolver\n      ))\n    },\n    unpatch (execute) {\n      this.unwrap(execute, 'execute')\n    }\n  },\n  {\n    name: 'graphql',\n    file: 'language/parser.js',\n    versions: ['>=0.10'],\n    patch (parser, tracer, config) {\n      this.wrap(parser, 'parse', createWrapParse(tracer, validateConfig(config)))\n    },\n    unpatch (parser) {\n      this.unwrap(parser, 'parse')\n    }\n  },\n  {\n    name: 'graphql',\n    file: 'validation/validate.js',\n    versions: ['>=0.10'],\n    patch (validate, tracer, config) {\n      this.wrap(validate, 'validate', createWrapValidate(tracer, validateConfig(config)))\n    },\n    unpatch (validate) {\n      this.unwrap(validate, 'validate')\n    }\n  }\n]\n","/* eslint-disable */\n// file mostly untouched from apollo-graphql\n\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar signature_1 = require(\"./signature\");\nexports.defaultEngineReportingSignature = signature_1.defaultEngineReportingSignature;\n","/* eslint-disable */\n// file mostly untouched from apollo-graphql\n\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst transforms_1 = require(\"./transforms\");\nfunction defaultEngineReportingSignature(ast, operationName) {\n    return transforms_1.printWithReducedWhitespace(transforms_1.sortAST(transforms_1.removeAliases(transforms_1.hideLiterals(transforms_1.dropUnusedDefinitions(ast, operationName)))));\n}\nexports.defaultEngineReportingSignature = defaultEngineReportingSignature;\n","/* eslint-disable */\n// file mostly untouched from apollo-graphql\n\n\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst visitor_1 = require(\"graphql/language/visitor\");\nconst printer_1 = require(\"graphql/language/printer\");\nconst utilities_1 = require(\"graphql/utilities\");\nconst lodash_sortby_1 = __importDefault(require(\"lodash.sortby\"));\nfunction hideLiterals(ast) {\n    return visitor_1.visit(ast, {\n        IntValue(node) {\n            return Object.assign({}, node, { value: \"0\" });\n        },\n        FloatValue(node) {\n            return Object.assign({}, node, { value: \"0\" });\n        },\n        StringValue(node) {\n            return Object.assign({}, node, { value: \"\", block: false });\n        },\n        ListValue(node) {\n            return Object.assign({}, node, { values: [] });\n        },\n        ObjectValue(node) {\n            return Object.assign({}, node, { fields: [] });\n        }\n    });\n}\nexports.hideLiterals = hideLiterals;\nfunction hideStringAndNumericLiterals(ast) {\n    return visitor_1.visit(ast, {\n        IntValue(node) {\n            return Object.assign({}, node, { value: \"0\" });\n        },\n        FloatValue(node) {\n            return Object.assign({}, node, { value: \"0\" });\n        },\n        StringValue(node) {\n            return Object.assign({}, node, { value: \"\", block: false });\n        }\n    });\n}\nexports.hideStringAndNumericLiterals = hideStringAndNumericLiterals;\nfunction dropUnusedDefinitions(ast, operationName) {\n    const separated = utilities_1.separateOperations(ast)[operationName];\n    if (!separated) {\n        return ast;\n    }\n    return separated;\n}\nexports.dropUnusedDefinitions = dropUnusedDefinitions;\nfunction sorted(items) {\n    if (items) {\n        return lodash_sortby_1.default.apply(null, arguments);\n    }\n    return undefined;\n}\nfunction sortAST(ast) {\n    return visitor_1.visit(ast, {\n        OperationDefinition(node) {\n            return Object.assign({}, node, { variableDefinitions: sorted(node.variableDefinitions, \"variable.name.value\") });\n        },\n        SelectionSet(node) {\n            return Object.assign({}, node, { selections: lodash_sortby_1.default(node.selections, \"kind\", \"name.value\") });\n        },\n        Field(node) {\n            return Object.assign({}, node, { arguments: sorted(node.arguments, \"name.value\") });\n        },\n        FragmentSpread(node) {\n            return Object.assign({}, node, { directives: sorted(node.directives, \"name.value\") });\n        },\n        InlineFragment(node) {\n            return Object.assign({}, node, { directives: sorted(node.directives, \"name.value\") });\n        },\n        FragmentDefinition(node) {\n            return Object.assign({}, node, { directives: sorted(node.directives, \"name.value\"), variableDefinitions: sorted(node.variableDefinitions, \"variable.name.value\") });\n        },\n        Directive(node) {\n            return Object.assign({}, node, { arguments: sorted(node.arguments, \"name.value\") });\n        }\n    });\n}\nexports.sortAST = sortAST;\nfunction removeAliases(ast) {\n    return visitor_1.visit(ast, {\n        Field(node) {\n            return Object.assign({}, node, { alias: undefined });\n        }\n    });\n}\nexports.removeAliases = removeAliases;\nfunction printWithReducedWhitespace(ast) {\n    const sanitizedAST = visitor_1.visit(ast, {\n        StringValue(node) {\n            return Object.assign({}, node, { value: Buffer.from(node.value, \"utf8\").toString(\"hex\"), block: false });\n        }\n    });\n    const withWhitespace = printer_1.print(sanitizedAST);\n    const minimizedButStillHex = withWhitespace\n        .replace(/\\s+/g, \" \")\n        .replace(/([^_a-zA-Z0-9]) /g, (_, c) => c)\n        .replace(/ ([^_a-zA-Z0-9])/g, (_, c) => c);\n    return minimizedButStillHex.replace(/\"([a-f0-9]+)\"/g, (_, hex) => JSON.stringify(Buffer.from(hex, \"hex\").toString(\"utf8\")));\n}\nexports.printWithReducedWhitespace = printWithReducedWhitespace;\n","'use strict'\n\nconst analyticsSampler = require('../../dd-trace/src/analytics_sampler')\nconst Tags = require('../../../ext/tags')\nconst { TEXT_MAP } = require('../../../ext/formats')\nconst { ERROR } = require('../../../ext/tags')\nconst kinds = require('./kinds')\nconst { addMethodTags, addMetadataTags, getFilter } = require('./util')\n\nconst patched = new WeakSet()\nconst instances = new WeakMap()\n\nfunction createWrapMakeRequest (tracer, config, methodKind) {\n  const filter = getFilter(config, 'metadata')\n\n  return function wrapMakeRequest (makeRequest) {\n    return function makeRequestWithTrace (path) {\n      const args = ensureMetadata(this, arguments, 4)\n\n      return callMethod(tracer, config, this, makeRequest, args, path, args[4], methodKind, filter)\n    }\n  }\n}\n\nfunction createWrapLoadPackageDefinition (tracer, config) {\n  return function wrapLoadPackageDefinition (loadPackageDefinition) {\n    return function loadPackageDefinitionWithTrace (packageDef) {\n      const result = loadPackageDefinition.apply(this, arguments)\n\n      if (!result) return result\n\n      wrapPackageDefinition(tracer, config, result)\n\n      return result\n    }\n  }\n}\n\nfunction createWrapMakeClientConstructor (tracer, config) {\n  return function wrapMakeClientConstructor (makeClientConstructor) {\n    return function makeClientConstructorWithTrace (methods) {\n      const ServiceClient = makeClientConstructor.apply(this, arguments)\n\n      wrapClientConstructor(tracer, config, ServiceClient, methods)\n\n      return ServiceClient\n    }\n  }\n}\n\nfunction wrapPackageDefinition (tracer, config, def) {\n  for (const name in def) {\n    if (def[name].format) continue\n    if (def[name].service && def[name].prototype) {\n      wrapClientConstructor(tracer, config, def[name], def[name].service)\n    } else {\n      wrapPackageDefinition(tracer, config, def[name])\n    }\n  }\n}\n\nfunction wrapClientConstructor (tracer, config, ServiceClient, methods) {\n  const proto = ServiceClient.prototype\n\n  if (typeof methods !== 'object' || 'format' in methods) return\n\n  Object.keys(methods)\n    .forEach(name => {\n      if (!methods[name]) return\n\n      const originalName = methods[name].originalName\n      const path = methods[name].path\n      const methodKind = getMethodKind(methods[name])\n\n      if (methods[name]) {\n        proto[name] = wrapMethod(tracer, config, proto[name], path, methodKind)\n      }\n\n      if (originalName) {\n        proto[originalName] = wrapMethod(tracer, config, proto[originalName], path, methodKind)\n      }\n    })\n}\n\nfunction wrapMethod (tracer, config, method, path, methodKind) {\n  if (typeof method !== 'function' || patched.has(method)) {\n    return method\n  }\n\n  const filter = getFilter(config, 'metadata')\n\n  const methodWithTrace = function methodWithTrace () {\n    const args = ensureMetadata(this, arguments, 1)\n\n    return callMethod(tracer, config, this, method, args, path, args[1], methodKind, filter)\n  }\n\n  Object.assign(methodWithTrace, method)\n\n  patched.add(methodWithTrace)\n\n  return methodWithTrace\n}\n\nfunction wrapCallback (span, callback) {\n  const scope = span.tracer().scope()\n  const parent = scope.active()\n\n  return function (err) {\n    err && span.setTag(ERROR, err)\n\n    if (callback) {\n      return scope.bind(callback, parent).apply(this, arguments)\n    }\n  }\n}\n\nfunction wrapStream (span, call, filter) {\n  if (!call || typeof call.emit !== 'function') return\n\n  const emit = call.emit\n\n  call.emit = function (eventName, ...args) {\n    switch (eventName) {\n      case 'error':\n        span.setTag(ERROR, args[0] || 1)\n\n        break\n      case 'status':\n        if (args[0]) {\n          span.setTag('grpc.status.code', args[0].code)\n\n          addMetadataTags(span, args[0].metadata, filter, 'response')\n        }\n\n        span.finish()\n\n        break\n    }\n\n    return emit.apply(this, arguments)\n  }\n}\n\nfunction callMethod (tracer, config, client, method, args, path, metadata, methodKind, filter) {\n  const length = args.length\n  const callback = args[length - 1]\n  const scope = tracer.scope()\n  const span = startSpan(tracer, config, path, methodKind)\n\n  if (metadata) {\n    addMetadataTags(span, metadata, filter, 'request')\n    inject(tracer, span, metadata)\n  }\n\n  if (methodKind === kinds.unary || methodKind === kinds.client_stream) {\n    if (typeof callback === 'function') {\n      args[length - 1] = wrapCallback(span, callback)\n    } else {\n      args[length] = wrapCallback(span)\n    }\n  }\n\n  const call = scope.bind(method, span).apply(client, args)\n\n  wrapStream(span, call, filter)\n\n  return scope.bind(call)\n}\n\nfunction startSpan (tracer, config, path, methodKind) {\n  const scope = tracer.scope()\n  const childOf = scope.active()\n  const span = tracer.startSpan('grpc.request', {\n    childOf,\n    tags: {\n      [Tags.SPAN_KIND]: 'client',\n      'span.type': 'http',\n      'resource.name': path,\n      'service.name': config.service || `${tracer._service}-grpc-client`,\n      'component': 'grpc'\n    }\n  })\n\n  analyticsSampler.sample(span, config.measured)\n  addMethodTags(span, path, methodKind)\n\n  return span\n}\n\nfunction ensureMetadata (client, args, index) {\n  const grpc = getGrpc(client)\n\n  if (!client || !grpc) return args\n\n  const meta = args[index]\n  const normalized = []\n\n  for (let i = 0; i < index; i++) {\n    normalized.push(args[i])\n  }\n\n  if (!meta || !meta.constructor || meta.constructor.name !== 'Metadata') {\n    normalized.push(new grpc.Metadata())\n  }\n\n  if (meta) {\n    normalized.push(meta)\n  }\n\n  for (let i = index + 1; i < args.length; i++) {\n    normalized.push(args[i])\n  }\n\n  return normalized\n}\n\nfunction inject (tracer, span, metadata) {\n  if (typeof metadata.set !== 'function') return\n\n  const carrier = {}\n\n  tracer.inject(span, TEXT_MAP, carrier)\n\n  for (const key in carrier) {\n    metadata.set(key, carrier[key])\n  }\n}\n\nfunction getMethodKind (definition) {\n  if (definition.requestStream) {\n    if (definition.responseStream) {\n      return kinds.bidi\n    }\n\n    return kinds.client_stream\n  }\n\n  if (definition.responseStream) {\n    return kinds.server_stream\n  }\n\n  return kinds.unary\n}\n\nfunction getGrpc (client) {\n  let proto = client\n\n  do {\n    const instance = instances.get(proto)\n    if (instance) return instance\n  } while ((proto = Object.getPrototypeOf(proto)))\n}\n\nfunction patch (grpc, tracer, config) {\n  if (config.client === false) return\n\n  config = config.client || config\n\n  const proto = grpc.Client.prototype\n\n  instances.set(proto, grpc)\n\n  this.wrap(proto, 'makeBidiStreamRequest', createWrapMakeRequest(tracer, config, kinds.bidi))\n  this.wrap(proto, 'makeClientStreamRequest', createWrapMakeRequest(tracer, config, kinds.clientStream))\n  this.wrap(proto, 'makeServerStreamRequest', createWrapMakeRequest(tracer, config, kinds.serverStream))\n  this.wrap(proto, 'makeUnaryRequest', createWrapMakeRequest(tracer, config, kinds.unary))\n}\n\nfunction unpatch (grpc) {\n  const proto = grpc.Client.prototype\n\n  instances.delete(proto)\n\n  this.unwrap(proto, 'makeBidiStreamRequest')\n  this.unwrap(proto, 'makeClientStreamRequest')\n  this.unwrap(proto, 'makeServerStreamRequest')\n  this.unwrap(proto, 'makeUnaryRequest')\n}\n\nmodule.exports = [\n  {\n    name: 'grpc',\n    versions: ['>=1.20.2'],\n    patch,\n    unpatch\n  },\n  {\n    name: 'grpc',\n    versions: ['>=1.20.2'],\n    file: 'src/client.js',\n    patch (client, tracer, config) {\n      if (config.client === false) return\n\n      config = config.client || config\n\n      this.wrap(client, 'makeClientConstructor', createWrapMakeClientConstructor(tracer, config))\n    },\n    unpatch (client) {\n      this.unwrap(client, 'makeClientConstructor')\n    }\n  },\n  {\n    name: '@grpc/grpc-js',\n    versions: ['>=1.0.3'],\n    patch,\n    unpatch\n  },\n  {\n    name: '@grpc/grpc-js',\n    versions: ['>=1.0.3'],\n    file: 'build/src/make-client.js',\n    patch (client, tracer, config) {\n      if (config.client === false) return\n\n      config = config.client || config\n\n      this.wrap(client, 'makeClientConstructor', createWrapMakeClientConstructor(tracer, config))\n      this.wrap(client, 'loadPackageDefinition', createWrapLoadPackageDefinition(tracer, config))\n    },\n    unpatch (client) {\n      this.unwrap(client, 'makeClientConstructor')\n      this.unwrap(client, 'loadPackageDefinition')\n    }\n  }\n]\n","'use strict'\n\nconst client = require('./client')\nconst server = require('./server')\n\nmodule.exports = [].concat(client, server)\n","'use strict'\n\nmodule.exports = {\n  unary: 'unary',\n  bidi: 'bidi_streaming',\n  client_stream: 'client_streaming',\n  clientStream: 'client_streaming',\n  server_stream: 'server_streaming',\n  serverStream: 'server_streaming'\n}\n","'use strict'\n\nconst analyticsSampler = require('../../dd-trace/src/analytics_sampler')\nconst Tags = require('../../../ext/tags')\nconst { TEXT_MAP } = require('../../../ext/formats')\nconst { ERROR } = require('../../../ext/tags')\nconst kinds = require('./kinds')\nconst { addMethodTags, addMetadataTags, getFilter } = require('./util')\n\n// https://github.com/grpc/grpc/blob/master/doc/statuscodes.md\nconst OK = 0\nconst CANCELLED = 1\n\nfunction createWrapHandler (tracer, config, handler) {\n  const filter = getFilter(config, 'metadata')\n\n  return function wrapHandler (func) {\n    const isValid = (server, args) => {\n      if (!server || !server.type) return false\n      if (!args[0]) return false\n      if (server.type !== 'unary' && !isEmitter(args[0])) return false\n      if (server.type === 'unary' && typeof args[1] !== 'function') return false\n\n      return true\n    }\n\n    return function funcWithTrace (call, callback) {\n      if (!isValid(this, arguments)) return func.apply(this, arguments)\n\n      const metadata = call.metadata\n      const type = this.type\n      const isStream = type !== 'unary'\n      const scope = tracer.scope()\n      const childOf = extract(tracer, metadata)\n      const span = tracer.startSpan('grpc.request', {\n        childOf,\n        tags: {\n          [Tags.SPAN_KIND]: 'server',\n          'span.type': 'web',\n          'resource.name': handler,\n          'service.name': config.service || `${tracer._service}`,\n          'component': 'grpc'\n        }\n      })\n\n      analyticsSampler.sample(span, config.measured, true)\n      addMethodTags(span, handler, kinds[type])\n      addMetadataTags(span, metadata, filter, 'request')\n\n      scope.bind(call)\n\n      // Finish the span if the call was cancelled.\n      call.once('cancelled', () => {\n        span.setTag('grpc.status.code', CANCELLED)\n        span.finish()\n      })\n\n      if (isStream) {\n        wrapStream(span, call)\n      } else {\n        arguments[1] = wrapCallback(span, callback, filter, childOf)\n      }\n\n      return scope.bind(func, span).apply(this, arguments)\n    }\n  }\n}\n\nfunction createWrapRegister (tracer, config) {\n  config = config.server || config\n\n  return function wrapRegister (register) {\n    return function registerWithTrace (name, handler, serialize, deserialize, type) {\n      if (typeof handler === 'function') {\n        arguments[1] = createWrapHandler(tracer, config, name)(handler)\n      }\n\n      return register.apply(this, arguments)\n    }\n  }\n}\n\nfunction wrapStream (span, call, tracer) {\n  const emit = call.emit\n\n  if (call.call && call.call.sendStatus) {\n    call.call.sendStatus = wrapSendStatus(call.call.sendStatus, span)\n  }\n\n  call.emit = function (eventName, ...args) {\n    switch (eventName) {\n      case 'error':\n        span.addTags({\n          [ERROR]: args[0] || 1,\n          'grpc.status.code': args[0] && args[0].code\n        })\n\n        span.finish()\n\n        break\n\n      // Finish the span of the response only if it was successful.\n      // Otherwise it'll be finished in the `error` listener.\n      case 'finish':\n        if (call.status) {\n          span.setTag('grpc.status.code', call.status.code)\n        }\n\n        if (!call.status || call.status.code === 0) {\n          span.finish()\n        }\n\n        break\n    }\n\n    return emit.apply(this, arguments)\n  }\n}\n\nfunction wrapCallback (span, callback, filter, childOf) {\n  const scope = span.tracer().scope()\n\n  return function (err, value, trailer, flags) {\n    if (err instanceof Error) {\n      if (err.code) {\n        span.setTag('grpc.status.code', err.code)\n      }\n\n      span.setTag(ERROR, err)\n    } else {\n      span.setTag('grpc.status.code', OK)\n    }\n\n    if (trailer && filter) {\n      addMetadataTags(span, trailer, filter, 'response')\n    }\n\n    span.finish()\n\n    if (callback) {\n      return scope.bind(callback, childOf).apply(this, arguments)\n    }\n  }\n}\n\nfunction wrapSendStatus (sendStatus, span) {\n  return function sendStatusWithTrace (status) {\n    span.setTag('grpc.status.code', status.code)\n\n    return sendStatus.apply(this, arguments)\n  }\n}\n\nfunction extract (tracer, metadata) {\n  if (!metadata || typeof metadata.getMap !== 'function') return null\n\n  return tracer.extract(TEXT_MAP, metadata.getMap())\n}\n\nfunction isEmitter (obj) {\n  return typeof obj.emit === 'function' && typeof obj.once === 'function'\n}\n\nmodule.exports = [\n  {\n    name: 'grpc',\n    versions: ['>=1.20.2'],\n    file: 'src/server.js',\n    patch (server, tracer, config) {\n      if (config.server === false) return\n      this.wrap(server.Server.prototype, 'register', createWrapRegister(tracer, config))\n    },\n    unpatch (server) {\n      this.unwrap(server.Server.prototype, 'register')\n    }\n  },\n  {\n    name: '@grpc/grpc-js',\n    versions: ['>=1'],\n    file: 'build/src/server.js',\n    patch (server, tracer, config) {\n      if (config.server === false) return\n\n      this.wrap(server.Server.prototype, 'register', createWrapRegister(tracer, config))\n    },\n    unpatch (server) {\n      this.unwrap(server.Server.prototype, 'register')\n    }\n  }\n]\n","'use strict'\n\nconst pick = require('lodash.pick')\nconst log = require('../../dd-trace/src/log')\n\nmodule.exports = {\n  addMethodTags (span, path, kind) {\n    if (typeof path !== 'string') return\n\n    span.addTags({\n      'grpc.method.path': path,\n      'grpc.method.kind': kind\n    })\n\n    const methodParts = path.split('/')\n\n    if (methodParts.length > 2) {\n      const serviceParts = methodParts[1].split('.')\n      const name = methodParts[2]\n      const service = serviceParts.pop()\n      const pkg = serviceParts.join('.')\n\n      span.addTags({\n        'grpc.method.name': name,\n        'grpc.method.service': service,\n        'grpc.method.package': pkg\n      })\n    } else {\n      span.addTags({\n        'grpc.method.name': methodParts[methodParts.length - 1]\n      })\n    }\n  },\n\n  addMetadataTags (span, metadata, filter, type) {\n    if (!metadata || typeof metadata.getMap !== 'function') return\n\n    const values = filter(metadata.getMap())\n\n    for (const key in values) {\n      span.setTag(`grpc.${type}.metadata.${key}`, values[key])\n    }\n  },\n\n  // TODO: extract this to shared utils and add unit tests\n  getFilter (config, filter) {\n    if (typeof config[filter] === 'function') {\n      return config[filter]\n    }\n\n    if (config[filter] instanceof Array) {\n      return element => pick(element, config[filter])\n    }\n\n    if (config.hasOwnProperty(filter)) {\n      log.error(`Expected '${filter}' to be an array or function.`)\n    }\n\n    return () => ({})\n  }\n}\n","'use strict'\n\nconst route = require('./route')\nconst server = require('./server')\n\nmodule.exports = [].concat(route, server)\n","'use strict'\n\nconst web = require('../../dd-trace/src/plugins/util/web')\n\nfunction createWrapRebuild () {\n  return function wrapRebuild (rebuild) {\n    return function rebuildWithTrace (event) {\n      const result = rebuild.apply(this, arguments)\n\n      if (this && Array.isArray(this._cycle)) {\n        this._cycle = this._cycle.map(wrapMiddleware)\n      }\n\n      return result\n    }\n  }\n}\n\nfunction createWrapLifecycle () {\n  return function wrapLifecycle (lifecycle) {\n    return function lifecycleWithTrace () {\n      const result = lifecycle.apply(this, arguments)\n\n      if (Array.isArray(result)) return result.map(wrapMiddleware)\n\n      return result\n    }\n  }\n}\n\nfunction wrapMiddleware (middleware) {\n  if (typeof middleware !== 'function') return middleware\n\n  return function (request, next) {\n    if (!request || !request.raw) return middleware.apply(this, arguments)\n\n    return web.reactivate(request.raw.req, () => middleware.apply(this, arguments))\n  }\n}\n\nmodule.exports = [\n  {\n    name: '@hapi/hapi',\n    versions: ['>=17.9'],\n    file: 'lib/route.js',\n    patch (Route, tracer, config) {\n      this.wrap(Route.prototype, 'rebuild', createWrapRebuild(tracer, config))\n    },\n    unpatch (Route) {\n      this.unwrap(Route.prototype, 'rebuild')\n    }\n  },\n  {\n    name: 'hapi',\n    versions: ['>=10.4'],\n    file: 'lib/route.js',\n    patch (Route, tracer, config) {\n      this.wrap(Route.prototype, 'rebuild', createWrapRebuild(tracer, config))\n    },\n    unpatch (Route) {\n      this.unwrap(Route.prototype, 'rebuild')\n    }\n  },\n  {\n    name: 'hapi',\n    versions: ['2 - 10.3'],\n    file: 'lib/route.js',\n    patch (Route, tracer, config) {\n      this.wrap(Route.prototype, 'lifecycle', createWrapLifecycle(tracer, config))\n    },\n    unpatch (Route) {\n      this.unwrap(Route.prototype, 'lifecycle')\n    }\n  }\n]\n","'use strict'\n\nconst web = require('../../dd-trace/src/plugins/util/web')\n\nfunction createWrapDispatch (tracer, config) {\n  config = web.normalizeConfig(config)\n\n  return function wrapDispatch (dispatch) {\n    return function dispatchWithTrace (options) {\n      const handler = dispatch.apply(this, arguments)\n\n      if (typeof handler !== 'function') return handler\n\n      return function (req, res) {\n        return web.instrument(tracer, config, req, res, 'hapi.request', () => {\n          return handler.apply(this, arguments)\n        })\n      }\n    }\n  }\n}\n\nfunction createWrapServer (tracer) {\n  return function wrapServer (server) {\n    return function serverWithTrace (options) {\n      const app = server.apply(this, arguments)\n\n      if (!app) return app\n\n      if (typeof app.ext === 'function') {\n        app.ext = createWrapExt(tracer)(app.ext)\n      }\n\n      if (typeof app.start === 'function') {\n        app.start = createWrapStart(tracer)(app.start)\n      }\n\n      return app\n    }\n  }\n}\n\nfunction createWrapStart () {\n  return function wrapStart (start) {\n    return function startWithTrace () {\n      if (this && typeof this.ext === 'function') {\n        this.ext('onPreResponse', onPreResponse)\n      }\n\n      return start.apply(this, arguments)\n    }\n  }\n}\n\nfunction createWrapExt () {\n  return function wrapExt (ext) {\n    return function extWithTrace (events, method, options) {\n      if (typeof events === 'object') {\n        arguments[0] = wrapEvents(events)\n      } else {\n        arguments[1] = wrapExtension(method)\n      }\n\n      return ext.apply(this, arguments)\n    }\n  }\n}\n\nfunction wrapExtension (method) {\n  return [].concat(method).map(wrapHandler)\n}\n\nfunction wrapEvents (events) {\n  return [].concat(events).map(event => {\n    if (!event || !event.method) return event\n\n    return Object.assign({}, event, {\n      method: wrapExtension(event.method)\n    })\n  })\n}\n\nfunction wrapHandler (handler) {\n  if (typeof handler !== 'function') return handler\n\n  return function (request, h) {\n    if (!request || !request.raw) return handler.apply(this, arguments)\n\n    return web.reactivate(request.raw.req, () => handler.apply(this, arguments))\n  }\n}\n\nfunction onPreResponse (request, h) {\n  if (!request || !request.raw) return reply(request, h)\n\n  const req = request.raw.req\n\n  web.addError(req, request.response)\n\n  if (request.route) {\n    web.enterRoute(req, request.route.path)\n  }\n\n  return reply(request, h)\n}\n\nfunction reply (request, h) {\n  if (h.continue) {\n    return typeof h.continue === 'function'\n      ? h.continue()\n      : h.continue\n  } else if (typeof h === 'function') {\n    return h()\n  }\n}\n\nmodule.exports = [\n  {\n    name: '@hapi/hapi',\n    versions: ['>=17.9'],\n    patch (hapi, tracer, config) {\n      this.wrap(hapi, ['server', 'Server'], createWrapServer(tracer, config))\n    },\n    unpatch (hapi) {\n      this.unwrap(hapi, ['server', 'Server'])\n    }\n  },\n  {\n    name: 'hapi',\n    versions: ['>=17'],\n    patch (hapi, tracer, config) {\n      this.wrap(hapi, ['server', 'Server'], createWrapServer(tracer, config))\n    },\n    unpatch (hapi) {\n      this.unwrap(hapi, ['server', 'Server'])\n    }\n  },\n  {\n    name: 'hapi',\n    versions: ['2 - 7.1', '8 - 16'],\n    patch (hapi, tracer, config) {\n      this.wrap(hapi.Server.prototype, 'start', createWrapStart(tracer, config))\n      this.wrap(hapi.Server.prototype, 'ext', createWrapExt(tracer, config))\n    },\n    unpatch (hapi) {\n      this.unwrap(hapi.Server.prototype, 'start')\n      this.unwrap(hapi.Server.prototype, 'ext')\n    }\n  },\n  {\n    name: 'hapi',\n    versions: ['^7.2'],\n    patch (hapi, tracer, config) {\n      this.wrap(hapi, 'createServer', createWrapServer(tracer, config))\n    },\n    unpatch (hapi) {\n      this.unwrap(hapi, 'createServer')\n    }\n  },\n  {\n    name: '@hapi/hapi',\n    versions: ['>=17.9'],\n    file: 'lib/core.js',\n    patch (Core, tracer, config) {\n      this.wrap(Core.prototype, '_dispatch', createWrapDispatch(tracer, config))\n    },\n    unpatch (Core) {\n      this.unwrap(Core.prototype, '_dispatch')\n    }\n  },\n  {\n    name: 'hapi',\n    versions: ['7.2 - 16'],\n    file: 'lib/connection.js',\n    patch (Connection, tracer, config) {\n      this.wrap(Connection.prototype, '_dispatch', createWrapDispatch(tracer, config))\n    },\n    unpatch (Connection) {\n      this.unwrap(Connection.prototype, '_dispatch')\n    }\n  },\n  {\n    name: 'hapi',\n    versions: ['>=17'],\n    file: 'lib/core.js',\n    patch (Core, tracer, config) {\n      this.wrap(Core.prototype, '_dispatch', createWrapDispatch(tracer, config))\n    },\n    unpatch (Core) {\n      this.unwrap(Core.prototype, '_dispatch')\n    }\n  },\n  {\n    name: 'hapi',\n    versions: ['2 - 7.1'],\n    file: 'lib/server.js',\n    patch (Server, tracer, config) {\n      this.wrap(Server.prototype, '_dispatch', createWrapDispatch(tracer, config))\n    },\n    unpatch (Server) {\n      this.unwrap(Server.prototype, '_dispatch')\n    }\n  }\n]\n","'use strict'\n\nconst Plugin = require('../../dd-trace/src/plugins/plugin')\nconst { storage } = require('../../datadog-core')\nconst tags = require('../../../ext/tags')\nconst analyticsSampler = require('../../dd-trace/src/analytics_sampler')\nconst formats = require('../../../ext/formats')\nconst HTTP_HEADERS = formats.HTTP_HEADERS\nconst urlFilter = require('../../dd-trace/src/plugins/util/urlfilter')\nconst log = require('../../dd-trace/src/log')\nconst url = require('url')\n\nconst HTTP_STATUS_CODE = tags.HTTP_STATUS_CODE\nconst HTTP_REQUEST_HEADERS = tags.HTTP_REQUEST_HEADERS\nconst HTTP_RESPONSE_HEADERS = tags.HTTP_RESPONSE_HEADERS\n\nclass HttpClientPlugin extends Plugin {\n  static get name () {\n    return 'http'\n  }\n\n  constructor (...args) {\n    super(...args)\n\n    this.addSub('apm:http:client:request:start', ({ args, http }) => {\n      const store = storage.getStore()\n      const options = args.options\n      const agent = options.agent || options._defaultAgent || http.globalAgent\n      const protocol = options.protocol || agent.protocol || 'http:'\n      const hostname = options.hostname || options.host || 'localhost'\n      const host = options.port ? `${hostname}:${options.port}` : hostname\n      const path = options.path ? options.path.split(/[?#]/)[0] : '/'\n      const uri = `${protocol}//${host}${path}`\n\n      const method = (options.method || 'GET').toUpperCase()\n      const childOf = store ? store.span : store\n      const span = this.tracer.startSpan('http.request', {\n        childOf,\n        tags: {\n          'span.kind': 'client',\n          'service.name': getServiceName(this.tracer, this.config, options),\n          'resource.name': method,\n          'span.type': 'http',\n          'http.method': method,\n          'http.url': uri\n        }\n      })\n\n      if (!(hasAmazonSignature(options) || !this.config.propagationFilter(uri))) {\n        this.tracer.inject(span, HTTP_HEADERS, options.headers)\n      }\n\n      analyticsSampler.sample(span, this.config.measured)\n      this.enter(span, store)\n    })\n\n    this.addSub('apm:http:client:request:end', this.exit.bind(this))\n\n    this.addSub('apm:http:client:request:async-end', ({ req, res }) => {\n      const span = storage.getStore().span\n      if (res) {\n        span.setTag(HTTP_STATUS_CODE, res.statusCode)\n\n        if (!this.config.validateStatus(res.statusCode)) {\n          span.setTag('error', 1)\n        }\n\n        addResponseHeaders(res, span, this.config)\n      } else {\n        span.setTag('error', 1)\n      }\n\n      addRequestHeaders(req, span, this.config)\n\n      this.config.hooks.request(span, req, res)\n      span.finish()\n    })\n\n    this.addSub('apm:http:client:request:error', errorHandler)\n  }\n\n  configure (config) {\n    return super.configure(normalizeClientConfig(config))\n  }\n}\n\nfunction errorHandler (err) {\n  const span = storage.getStore().span\n  span.addTags({\n    'error.type': err.name,\n    'error.msg': err.message,\n    'error.stack': err.stack\n  })\n}\n\nfunction addResponseHeaders (res, span, config) {\n  config.headers.forEach(key => {\n    const value = res.headers[key]\n\n    if (value) {\n      span.setTag(`${HTTP_RESPONSE_HEADERS}.${key}`, value)\n    }\n  })\n}\n\nfunction addRequestHeaders (req, span, config) {\n  config.headers.forEach(key => {\n    const value = req.getHeader(key)\n\n    if (value) {\n      span.setTag(`${HTTP_REQUEST_HEADERS}.${key}`, value)\n    }\n  })\n}\n\nfunction normalizeClientConfig (config) {\n  const validateStatus = getStatusValidator(config)\n  const propagationFilter = getFilter({ blocklist: config.propagationBlocklist })\n  const headers = getHeaders(config)\n  const hooks = getHooks(config)\n\n  return Object.assign({}, config, {\n    validateStatus,\n    propagationFilter,\n    headers,\n    hooks\n  })\n}\n\nfunction getStatusValidator (config) {\n  if (typeof config.validateStatus === 'function') {\n    return config.validateStatus\n  } else if (config.hasOwnProperty('validateStatus')) {\n    log.error('Expected `validateStatus` to be a function.')\n  }\n  return code => code < 400 || code >= 500\n}\n\nfunction getFilter (config) {\n  config = Object.assign({}, config, {\n    blocklist: config.blocklist || []\n  })\n\n  return urlFilter.getFilter(config)\n}\n\nfunction getHeaders (config) {\n  if (!Array.isArray(config.headers)) return []\n\n  return config.headers\n    .filter(key => typeof key === 'string')\n    .map(key => key.toLowerCase())\n}\n\nfunction getHooks (config) {\n  const noop = () => {}\n  const request = (config.hooks && config.hooks.request) || noop\n\n  return { request }\n}\n\nfunction hasAmazonSignature (options) {\n  if (!options) {\n    return false\n  }\n\n  if (options.headers) {\n    const headers = Object.keys(options.headers)\n      .reduce((prev, next) => Object.assign(prev, {\n        [next.toLowerCase()]: options.headers[next]\n      }), {})\n\n    if (headers['x-amz-signature']) {\n      return true\n    }\n\n    if ([].concat(headers['authorization']).some(startsWith('AWS4-HMAC-SHA256'))) {\n      return true\n    }\n  }\n\n  return options.path && options.path.toLowerCase().indexOf('x-amz-signature=') !== -1\n}\n\nfunction getServiceName (tracer, config, options) {\n  if (config.splitByDomain) {\n    return getHost(options)\n  } else if (config.service) {\n    return config.service\n  }\n\n  return `${tracer._service}-http-client`\n}\n\nfunction getHost (options) {\n  if (typeof options === 'string') {\n    return url.parse(options).host\n  }\n\n  const hostname = options.hostname || options.host || 'localhost'\n  const port = options.port\n\n  return [hostname, port].filter(val => val).join(':')\n}\n\nfunction startsWith (searchString) {\n  return value => String(value).startsWith(searchString)\n}\n\nmodule.exports = HttpClientPlugin\n","'use strict'\n\nconst Plugin = require('../../dd-trace/src/plugins/plugin')\nconst HttpServerPlugin = require('./server')\nconst HttpClientPlugin = require('./client')\n\nclass HttpPlugin extends Plugin {\n  static get name () {\n    return 'http'\n  }\n  constructor (...args) {\n    super(...args)\n    this.server = new HttpServerPlugin(...args)\n    this.client = new HttpClientPlugin(...args)\n  }\n  configure (config) {\n    const clientConfig = config.client === false ? false : {\n      ...config,\n      ...config.client\n    }\n\n    const serverConfig = config.server === false ? false : {\n      ...config,\n      ...config.server\n    }\n\n    this.server.configure(serverConfig)\n    this.client.configure(clientConfig)\n  }\n}\n\nmodule.exports = HttpPlugin\n","'use strict'\n\nconst Plugin = require('../../dd-trace/src/plugins/plugin')\nconst { storage } = require('../../datadog-core')\nconst web = require('../../dd-trace/src/plugins/util/web')\nconst { incomingHttpRequestStart } = require('../../dd-trace/src/appsec/gateway/channels')\nconst tags = require('../../../ext/tags')\nconst analyticsSampler = require('../../dd-trace/src/analytics_sampler')\nconst SERVICE_NAME = tags.SERVICE_NAME\n\nclass HttpServerPlugin extends Plugin {\n  static get name () {\n    return 'http'\n  }\n\n  constructor (...args) {\n    super(...args)\n\n    this.addSub('apm:http:server:request:start', ({ req, res }) => {\n      const store = storage.getStore()\n      const span = web.startSpan(this.tracer, this.config, req, res, 'http.request')\n\n      if (this.config.service) {\n        span.setTag(SERVICE_NAME, this.config.service)\n      }\n\n      analyticsSampler.sample(span, this.config.measured, true)\n      this.enter(span, store)\n\n      const context = web.getContext(req)\n\n      if (!context.instrumented) {\n        context.res.writeHead = web.wrapWriteHead(context)\n        context.instrumented = true\n      }\n\n      if (incomingHttpRequestStart.hasSubscribers) {\n        incomingHttpRequestStart.publish({ req, res })\n      }\n    })\n\n    this.addSub('apm:http:server:request:end', () => {\n      this.exit()\n    })\n\n    this.addSub('apm:http:server:request:error', (error) => {\n      const span = storage.getStore().span\n      span.addTags({\n        'error.type': error.name,\n        'error.msg': error.message,\n        'error.stack': error.stack\n      })\n    })\n\n    this.addSub('apm:http:server:request:async-end', ({ req }) => {\n      const context = web.getContext(req)\n\n      if (!context) return // Not created by a http.Server instance.\n\n      web.wrapRes(context, context.req, context.res, context.res.end)()\n    })\n  }\n\n  configure (config) {\n    return super.configure(web.normalizeConfig(config))\n  }\n}\n\nmodule.exports = HttpServerPlugin\n","'use strict'\n\nconst URL = require('url').URL\nconst log = require('../../dd-trace/src/log')\nconst tags = require('../../../ext/tags')\nconst kinds = require('../../../ext/kinds')\nconst formats = require('../../../ext/formats')\nconst analyticsSampler = require('../../dd-trace/src/analytics_sampler')\nconst shimmer = require('../../datadog-shimmer')\n\nconst HTTP_HEADERS = formats.HTTP_HEADERS\nconst HTTP_STATUS_CODE = tags.HTTP_STATUS_CODE\nconst HTTP_REQUEST_HEADERS = tags.HTTP_REQUEST_HEADERS\nconst HTTP_RESPONSE_HEADERS = tags.HTTP_RESPONSE_HEADERS\nconst SPAN_KIND = tags.SPAN_KIND\nconst CLIENT = kinds.CLIENT\n\nconst HTTP2_HEADER_METHOD = ':method'\nconst HTTP2_HEADER_PATH = ':path'\nconst HTTP2_HEADER_STATUS = ':status'\nconst HTTP2_METHOD_GET = 'GET'\n\nfunction extractSessionDetails (authority, options) {\n  if (typeof authority === 'string') {\n    authority = new URL(authority)\n  }\n\n  const protocol = authority.protocol || options.protocol || 'https:'\n  let port = '' + (authority.port !== ''\n    ? authority.port : (authority.protocol === 'http:' ? 80 : 443))\n  let host = authority.hostname || authority.host || 'localhost'\n\n  if (protocol === 'https:' && options) {\n    port = options.port || port\n    host = options.host || host\n  }\n\n  return { protocol, port, host }\n}\n\nfunction getFormattedHostString (host, port) {\n  return [host, port].filter(val => val).join(':')\n}\n\nfunction getServiceName (tracer, config, sessionDetails) {\n  if (config.splitByDomain) {\n    return getFormattedHostString(sessionDetails.host, sessionDetails.port)\n  } else if (config.service) {\n    return config.service\n  }\n\n  return `${tracer._service}-http-client`\n}\n\nfunction hasAmazonSignature (headers, path) {\n  if (headers) {\n    headers = Object.keys(headers)\n      .reduce((prev, next) => Object.assign(prev, {\n        [next.toLowerCase()]: headers[next]\n      }), {})\n\n    if (headers['x-amz-signature']) {\n      return true\n    }\n\n    if ([].concat(headers['authorization']).some(startsWith('AWS4-HMAC-SHA256'))) {\n      return true\n    }\n  }\n\n  return path && path.toLowerCase().indexOf('x-amz-signature=') !== -1\n}\n\nfunction startsWith (searchString) {\n  return value => String(value).startsWith(searchString)\n}\n\nfunction getStatusValidator (config) {\n  if (typeof config.validateStatus === 'function') {\n    return config.validateStatus\n  } else if (config.hasOwnProperty('validateStatus')) {\n    log.error('Expected `validateStatus` to be a function.')\n  }\n  return code => code < 400 || code >= 500\n}\n\nfunction normalizeConfig (tracer, config) {\n  config = config.client || config\n\n  const validateStatus = getStatusValidator(config)\n  const headers = getHeaders(config)\n\n  return Object.assign({}, config, {\n    validateStatus,\n    headers\n  })\n}\n\nfunction addResponseTags (headers, span, config) {\n  const status = headers && headers[HTTP2_HEADER_STATUS]\n\n  span.setTag(HTTP_STATUS_CODE, status)\n\n  if (!config.validateStatus(status)) {\n    span.setTag('error', 1)\n  }\n\n  addHeaderTags(span, headers, HTTP_RESPONSE_HEADERS, config)\n}\n\nfunction addRequestTags (headers, span, config) {\n  addHeaderTags(span, headers, HTTP_REQUEST_HEADERS, config)\n}\n\nfunction addErrorTags (span, error) {\n  span.setTag('error', error)\n}\n\nfunction addHeaderTags (span, headers, prefix, config) {\n  if (!headers) return\n\n  config.headers.forEach(key => {\n    const value = headers[key]\n\n    if (value) {\n      span.setTag(`${prefix}.${key}`, value)\n    }\n  })\n}\n\nfunction getHeaders (config) {\n  if (!Array.isArray(config.headers)) return []\n\n  return config.headers\n    .filter(key => typeof key === 'string')\n    .map(key => key.toLowerCase())\n}\n\nfunction startSpan (tracer, config, headers, sessionDetails) {\n  headers = headers || {}\n\n  const scope = tracer.scope()\n  const childOf = scope.active()\n\n  const path = headers[HTTP2_HEADER_PATH] || '/'\n  const method = headers[HTTP2_HEADER_METHOD] || HTTP2_METHOD_GET\n  const url = `${sessionDetails.protocol}//${sessionDetails.host}:${sessionDetails.port}${path}`\n\n  const span = tracer.startSpan('http.request', {\n    childOf,\n    tags: {\n      [SPAN_KIND]: CLIENT,\n      'service.name': getServiceName(tracer, config, sessionDetails),\n      'resource.name': method,\n      'span.type': 'http',\n      'http.method': method,\n      'http.url': url.split('?')[0]\n    }\n  })\n\n  if (!hasAmazonSignature(headers, path)) {\n    tracer.inject(span, HTTP_HEADERS, headers)\n  }\n\n  analyticsSampler.sample(span, config.measured)\n  return span\n}\n\nfunction createWrapEmit (tracer, config, span) {\n  return function wrapEmit (emit) {\n    return function emitWithTrace (event, arg1) {\n      switch (event) {\n        case 'response':\n          addResponseTags(arg1, span, config)\n          break\n        case 'error':\n          addErrorTags(span, arg1)\n        case 'close': // eslint-disable-line no-fallthrough\n          span.finish()\n          break\n      }\n      return emit.apply(this, arguments)\n    }\n  }\n}\n\nfunction createWrapRequest (tracer, config, sessionDetails) {\n  return function wrapRequest (request) {\n    if (!sessionDetails) return request\n\n    return function requestWithTrace (headers, options) {\n      const scope = tracer.scope()\n      const span = startSpan(tracer, config, headers, sessionDetails)\n\n      addRequestTags(headers, span, config)\n\n      const req = scope.bind(request, span).apply(this, arguments)\n\n      shimmer.wrap(req, 'emit', createWrapEmit(tracer, config, span))\n      scope.bind(req)\n\n      return req\n    }\n  }\n}\n\nfunction createWrapConnect (tracer, config) {\n  config = normalizeConfig(tracer, config)\n\n  return function wrapConnect (connect) {\n    return function connectWithTrace (authority, options) {\n      const session = connect.apply(this, arguments)\n\n      const sessionDetails = extractSessionDetails(authority, options)\n\n      shimmer.wrap(session, 'request', createWrapRequest(tracer, config, sessionDetails))\n      return session\n    }\n  }\n}\n\nmodule.exports = [\n  {\n    name: 'http2',\n    patch: function (http2, tracer, config) {\n      if (config.client === false) return\n\n      this.wrap(http2, 'connect', createWrapConnect(tracer, config))\n    },\n    unpatch: function (http2) {\n      this.unwrap(http2, 'connect')\n    }\n  }\n]\n","'use strict'\n\nconst client = require('./client')\nconst server = require('./server')\n\nmodule.exports = [].concat(client, server)\n","'use strict'\n\n// TODO: remove usage of req._datadog when the plugin is re-enabled\n\nconst web = require('../../dd-trace/src/plugins/util/web')\nconst shimmer = require('../../datadog-shimmer')\n\nconst analyticsSampler = require('../../dd-trace/src/analytics_sampler')\nconst tags = require('../../../ext/tags')\nconst types = require('../../../ext/types')\nconst kinds = require('../../../ext/kinds')\n\nconst WEB = types.WEB\nconst SERVER = kinds.SERVER\nconst RESOURCE_NAME = tags.RESOURCE_NAME\nconst SERVICE_NAME = tags.SERVICE_NAME\nconst SPAN_TYPE = tags.SPAN_TYPE\nconst SPAN_KIND = tags.SPAN_KIND\nconst HTTP_METHOD = tags.HTTP_METHOD\nconst HTTP_URL = tags.HTTP_URL\nconst HTTP_STATUS_CODE = tags.HTTP_STATUS_CODE\nconst HTTP_ROUTE = tags.HTTP_ROUTE\nconst HTTP_REQUEST_HEADERS = tags.HTTP_REQUEST_HEADERS\nconst HTTP_RESPONSE_HEADERS = tags.HTTP_RESPONSE_HEADERS\nconst MANUAL_DROP = tags.MANUAL_DROP\n\nconst HTTP_STATUS_OK = 200\nconst HTTP2_HEADER_AUTHORITY = ':authority'\nconst HTTP2_HEADER_SCHEME = ':scheme'\nconst HTTP2_HEADER_METHOD = ':method'\nconst HTTP2_HEADER_PATH = ':path'\nconst HTTP2_HEADER_STATUS = ':status'\n\nfunction createWrapEmit (tracer, config) {\n  return function wrapEmit (emit) {\n    return function emitWithTrace (event, arg1, arg2) {\n      if (event === 'stream') {\n        const stream = arg1\n        const headers = arg2\n        return instrumentStream(tracer, config, stream, headers, 'http.request', () => {\n          return emit.apply(this, arguments)\n        })\n      } else if (event === 'request') {\n        const req = arg1\n        const res = arg2\n        return web.instrument(tracer, config, req, res, 'http.request', () => {\n          return emit.apply(this, arguments)\n        })\n      } else {\n        return emit.apply(this, arguments)\n      }\n    }\n  }\n}\n\nfunction createWrapCreateServer (tracer, config) {\n  config = web.normalizeConfig(config)\n\n  return function wrapCreateServer (createServer) {\n    return function createServerWithTrace (args) {\n      const server = createServer.apply(this, arguments)\n\n      shimmer.wrap(server, 'emit', createWrapEmit(tracer, config))\n\n      return server\n    }\n  }\n}\n\nfunction instrumentStream (tracer, config, stream, headers, name, callback) {\n  if (!stream) return callback()\n\n  headers = headers || {}\n\n  web.patch(stream)\n\n  const span = startStreamSpan(tracer, config, stream, headers, name)\n\n  if (!config.filter(headers[HTTP2_HEADER_PATH])) {\n    span.setTag(MANUAL_DROP, true)\n  }\n\n  if (config.service) {\n    span.setTag(SERVICE_NAME, config.service)\n  }\n\n  analyticsSampler.sample(span, config.measured, true)\n\n  wrapStreamEnd(stream)\n\n  addRequestTags(stream, headers)\n  addRequestHeaders(stream, headers)\n  addResourceTags(stream, headers)\n\n  return callback && tracer.scope().activate(span, () => callback(span))\n}\n\nfunction startStreamSpan (tracer, config, stream, headers, name) {\n  stream._datadog.config = config\n\n  if (stream._datadog.span) {\n    return stream._datadog.span\n  }\n\n  const span = web.startChildSpan(tracer, name, headers)\n\n  stream._datadog.tracer = tracer\n  stream._datadog.span = span\n\n  return span\n}\n\nfunction wrapStreamEnd (stream) {\n  function wrapEnd (end) {\n    return function endWithTrace () {\n      const returnValue = end.apply(this, arguments)\n\n      finishStream(stream)\n      return returnValue\n    }\n  }\n\n  shimmer.wrap(stream, 'end', wrapEnd)\n}\n\nfunction finishStream (stream) {\n  if (stream._datadog.finished) return\n\n  addResponseTags(stream)\n  addResponseHeaders(stream)\n\n  stream._datadog.span.finish()\n  stream._datadog.finished = true\n}\n\nfunction addRequestTags (stream, headers) {\n  const span = stream._datadog.span\n  const url = `${headers[HTTP2_HEADER_SCHEME]}://${headers[HTTP2_HEADER_AUTHORITY]}${headers[HTTP2_HEADER_PATH]}`\n\n  span.addTags({\n    [HTTP_METHOD]: headers[HTTP2_HEADER_METHOD],\n    [HTTP_URL]: url.split('?')[0],\n    [SPAN_KIND]: SERVER,\n    [SPAN_TYPE]: WEB\n  })\n}\n\nfunction addRequestHeaders (stream, headers) {\n  if (!headers) return\n\n  const span = stream._datadog.span\n\n  stream._datadog.config.headers.forEach(key => {\n    const reqHeader = headers[key]\n\n    if (reqHeader) {\n      span.setTag(`${HTTP_REQUEST_HEADERS}.${key}`, reqHeader)\n    }\n  })\n}\n\nfunction addResponseTags (stream) {\n  const span = stream._datadog.span\n  const headers = stream.sentHeaders\n  const statusCode = headers[HTTP2_HEADER_STATUS]\n\n  span.addTags({\n    [HTTP_STATUS_CODE]: statusCode | 0 || HTTP_STATUS_OK\n  })\n\n  web.addStatusError(stream, statusCode)\n}\n\nfunction addResponseHeaders (stream) {\n  if (!stream.sentHeaders) return\n\n  const span = stream._datadog.span\n\n  stream._datadog.config.headers.forEach(key => {\n    const resHeader = stream.sentHeaders && stream.sentHeaders[key]\n\n    if (resHeader) {\n      span.setTag(`${HTTP_RESPONSE_HEADERS}.${key}`, resHeader)\n    }\n  })\n}\n\nfunction addResourceTags (stream, headers) {\n  const span = stream._datadog.span\n  const tags = span.context()._tags\n  const method = headers[HTTP2_HEADER_METHOD]\n\n  if (tags[RESOURCE_NAME]) return\n\n  const resource = [method]\n    .concat(tags[HTTP_ROUTE])\n    .filter(val => val)\n    .join(' ')\n\n  span.setTag(RESOURCE_NAME, resource)\n}\n\nmodule.exports = [\n  {\n    name: 'http2',\n    patch (http2, tracer, config) {\n      if (config.server === false) return\n\n      this.wrap(http2, 'createServer', createWrapCreateServer(tracer, config))\n      this.wrap(http2, 'createSecureServer', createWrapCreateServer(tracer, config))\n    },\n    unpatch (http2) {\n      this.unwrap(http2, 'createServer')\n      this.unwrap(http2, 'createSecureServer')\n    }\n  }\n]\n\nmodule.exports = [] // temporarily disable HTTP2 server plugin\n","'use strict'\n\nconst RedisPlugin = require('../../datadog-plugin-redis/src')\n\nclass IORedisPlugin extends RedisPlugin {\n  static get name () {\n    return 'ioredis'\n  }\n}\n\nmodule.exports = IORedisPlugin\n","const jestEnvironment = require('./jest-environment')\nconst jestJasmine2 = require('./jest-jasmine2')\n\nmodule.exports = [].concat(jestEnvironment, jestJasmine2)\n","const { promisify } = require('util')\n\nconst { RESOURCE_NAME } = require('../../../ext/tags')\nconst {\n  TEST_NAME,\n  TEST_SUITE,\n  TEST_STATUS,\n  TEST_FRAMEWORK_VERSION,\n  JEST_TEST_RUNNER,\n  ERROR_MESSAGE,\n  ERROR_TYPE,\n  TEST_PARAMETERS,\n  CI_APP_ORIGIN,\n  getTestEnvironmentMetadata,\n  getTestParametersString,\n  finishAllTraceSpans,\n  getTestSuitePath\n} = require('../../dd-trace/src/plugins/util/test')\nconst {\n  getFormattedJestTestParameters,\n  getTestSpanTags,\n  setSuppressedErrors\n} = require('./util')\n\nconst originals = new WeakMap()\n\nfunction getVmContext (environment) {\n  if (typeof environment.getVmContext === 'function') {\n    return environment.getVmContext()\n  }\n  return null\n}\n\nfunction wrapEnvironment (BaseEnvironment) {\n  return class DatadogJestEnvironment extends BaseEnvironment {\n    constructor (config, context) {\n      super(config, context)\n      this.testSuite = getTestSuitePath(context.testPath, config.rootDir)\n      this.testSpansByTestName = {}\n      this.originalTestFnByTestName = {}\n    }\n  }\n}\n\nfunction createWrapTeardown (tracer, instrumenter) {\n  return function wrapTeardown (teardown) {\n    return async function teardownWithTrace () {\n      instrumenter.unwrap(this.global.test, 'each')\n      nameToParams = {}\n      // for jest-jasmine2\n      if (this.global.jasmine) {\n        instrumenter.unwrap(this.global.jasmine.Spec.prototype, 'onException')\n        instrumenter.unwrap(this.global, 'it')\n        instrumenter.unwrap(this.global, 'fit')\n        instrumenter.unwrap(this.global, 'xit')\n      }\n\n      instrumenter.unwrap(this.global.test, 'each')\n\n      return teardown.apply(this, arguments).finally(() => {\n        return new Promise(resolve => tracer._exporter._writer.flush(resolve))\n      })\n    }\n  }\n}\n\nlet nameToParams = {}\n\nconst isTimeout = (event) => {\n  return event.error &&\n  typeof event.error === 'string' &&\n  event.error.startsWith('Exceeded timeout')\n}\n\nfunction createHandleTestEvent (tracer, testEnvironmentMetadata, instrumenter) {\n  return async function handleTestEventWithTrace (event) {\n    if (event.name === 'test_retry') {\n      let testName = event.test && event.test.name\n      const context = getVmContext(this)\n      if (context) {\n        const { currentTestName } = context.expect.getState()\n        testName = currentTestName\n      }\n      // If it's a retry, we restore the original test function so that it is not wrapped again\n      if (this.originalTestFnByTestName[testName]) {\n        event.test.fn = this.originalTestFnByTestName[testName]\n      }\n      return\n    }\n    if (event.name === 'test_fn_failure') {\n      if (!isTimeout(event)) {\n        return\n      }\n      const context = getVmContext(this)\n      if (context) {\n        const { currentTestName } = context.expect.getState()\n        const testSpan = this.testSpansByTestName[`${currentTestName}_${event.test.invocations}`]\n        if (testSpan) {\n          testSpan.setTag(ERROR_TYPE, 'Timeout')\n          testSpan.setTag(ERROR_MESSAGE, event.error)\n          testSpan.setTag(TEST_STATUS, 'fail')\n        }\n      }\n      return\n    }\n    if (event.name === 'setup') {\n      instrumenter.wrap(this.global.test, 'each', function (original) {\n        return function () {\n          const testParameters = getFormattedJestTestParameters(arguments)\n          const eachBind = original.apply(this, arguments)\n          return function () {\n            const [testName] = arguments\n            nameToParams[testName] = testParameters\n            return eachBind.apply(this, arguments)\n          }\n        }\n      })\n      return\n    }\n\n    if (event.name !== 'test_skip' &&\n      event.name !== 'test_todo' &&\n      event.name !== 'test_start' &&\n      event.name !== 'hook_failure') {\n      return\n    }\n    // for hook_failure events the test entry might not be defined, because the hook\n    // is not necessarily associated to a test:\n    if (!event.test) {\n      return\n    }\n\n    const { childOf, commonSpanTags } = getTestSpanTags(tracer, testEnvironmentMetadata)\n\n    let testName = event.test.name\n    const context = getVmContext(this)\n\n    if (context) {\n      const { currentTestName } = context.expect.getState()\n      testName = currentTestName\n    }\n    const spanTags = {\n      ...commonSpanTags,\n      [TEST_NAME]: testName,\n      [TEST_SUITE]: this.testSuite,\n      [TEST_FRAMEWORK_VERSION]: tracer._version,\n      [JEST_TEST_RUNNER]: 'jest-circus'\n    }\n\n    const testParametersString = getTestParametersString(nameToParams, event.test.name)\n    if (testParametersString) {\n      spanTags[TEST_PARAMETERS] = testParametersString\n    }\n\n    const resource = `${this.testSuite}.${testName}`\n    if (event.name === 'test_skip' || event.name === 'test_todo') {\n      const testSpan = tracer.startSpan(\n        'jest.test',\n        {\n          childOf,\n          tags: {\n            ...spanTags,\n            [RESOURCE_NAME]: resource,\n            [TEST_STATUS]: 'skip'\n          }\n        }\n      )\n      testSpan.context()._trace.origin = CI_APP_ORIGIN\n      testSpan.finish()\n      return\n    }\n    if (event.name === 'hook_failure') {\n      const testSpan = tracer.startSpan(\n        'jest.test',\n        {\n          childOf,\n          tags: {\n            ...spanTags,\n            [RESOURCE_NAME]: resource,\n            [TEST_STATUS]: 'fail'\n          }\n        }\n      )\n      testSpan.context()._trace.origin = CI_APP_ORIGIN\n      if (event.test.errors && event.test.errors.length) {\n        const error = new Error(event.test.errors[0][0])\n        error.stack = event.test.errors[0][1].stack\n        testSpan.setTag('error', error)\n      }\n      testSpan.finish()\n      return\n    }\n    // event.name === test_start at this point\n    const environment = this\n    environment.originalTestFnByTestName[testName] = event.test.fn\n\n    let specFunction = event.test.fn\n    if (specFunction.length) {\n      specFunction = promisify(specFunction)\n    }\n    event.test.fn = tracer.wrap(\n      'jest.test',\n      {\n        type: 'test',\n        childOf,\n        resource,\n        tags: spanTags\n      },\n      async () => {\n        let result\n        const testSpan = tracer.scope().active()\n        environment.testSpansByTestName[`${testName}_${event.test.invocations}`] = testSpan\n        testSpan.context()._trace.origin = CI_APP_ORIGIN\n        try {\n          result = await specFunction()\n          // it may have been set already if the test timed out\n          let suppressedErrors = []\n          const context = getVmContext(environment)\n          if (context) {\n            suppressedErrors = context.expect.getState().suppressedErrors\n          }\n          setSuppressedErrors(suppressedErrors, testSpan)\n          if (!testSpan._spanContext._tags[TEST_STATUS]) {\n            testSpan.setTag(TEST_STATUS, 'pass')\n          }\n        } catch (error) {\n          testSpan.setTag(TEST_STATUS, 'fail')\n          testSpan.setTag('error', error)\n          throw error\n        } finally {\n          finishAllTraceSpans(testSpan)\n        }\n        return result\n      }\n    )\n  }\n}\n\nfunction patch (Environment, tracer, config) {\n  const testEnvironmentMetadata = getTestEnvironmentMetadata('jest', config)\n  const proto = Environment.prototype\n\n  this.wrap(proto, 'teardown', createWrapTeardown(tracer, this))\n\n  const newHandleTestEvent = createHandleTestEvent(tracer, testEnvironmentMetadata, this)\n  originals.set(newHandleTestEvent, proto.handleTestEvent)\n  proto.handleTestEvent = newHandleTestEvent\n\n  return wrapEnvironment(Environment)\n}\n\nfunction unpatch (Environment) {\n  const proto = Environment.prototype\n\n  this.unwrap(Environment.prototype, 'teardown')\n  proto.handleTestEvent = originals.get(proto.handleTestEvent)\n}\n\nmodule.exports = [\n  {\n    name: 'jest-environment-node',\n    versions: ['>=24.8.0'],\n    patch,\n    unpatch\n  },\n  {\n    name: 'jest-environment-jsdom',\n    versions: ['>=24.8.0'],\n    patch,\n    unpatch\n  }\n]\n","const { promisify } = require('util')\n\nconst { RESOURCE_NAME } = require('../../../ext/tags')\nconst {\n  TEST_NAME,\n  TEST_SUITE,\n  TEST_STATUS,\n  TEST_FRAMEWORK_VERSION,\n  JEST_TEST_RUNNER,\n  CI_APP_ORIGIN,\n  getTestEnvironmentMetadata,\n  finishAllTraceSpans,\n  getTestSuitePath\n} = require('../../dd-trace/src/plugins/util/test')\nconst { getTestSpanTags, setSuppressedErrors } = require('./util')\n\nfunction createWrapIt (tracer, globalConfig, globalInput, testEnvironmentMetadata) {\n  return function wrapIt (it) {\n    return function itWithTrace (description, specFunction, timeout) {\n      let oldSpecFunction = specFunction\n      if (specFunction.length) {\n        oldSpecFunction = promisify(oldSpecFunction)\n      }\n\n      const { childOf, commonSpanTags } = getTestSpanTags(tracer, testEnvironmentMetadata)\n\n      const testSuite = getTestSuitePath(globalInput.jasmine.testPath, globalConfig.rootDir)\n\n      const newSpecFunction = tracer.wrap(\n        'jest.test',\n        {\n          type: 'test',\n          childOf,\n          tags: {\n            ...commonSpanTags,\n            [TEST_SUITE]: testSuite,\n            [TEST_FRAMEWORK_VERSION]: tracer._version,\n            [JEST_TEST_RUNNER]: 'jest-jasmine2'\n          }\n        },\n        async (done) => {\n          const testSpan = tracer.scope().active()\n          const { currentTestName } = globalInput.expect.getState()\n          const resource = `${testSuite}.${currentTestName}`\n          testSpan.setTag(TEST_NAME, currentTestName)\n          testSpan.setTag(RESOURCE_NAME, resource)\n          testSpan.context()._trace.origin = CI_APP_ORIGIN\n          let result\n          globalInput.jasmine.testSpanByTestName[currentTestName] = testSpan\n\n          try {\n            result = await oldSpecFunction()\n            const suppressedErrors = globalInput.expect.getState().suppressedErrors\n            setSuppressedErrors(suppressedErrors, testSpan)\n            if (!testSpan._spanContext._tags[TEST_STATUS]) {\n              testSpan.setTag(TEST_STATUS, 'pass')\n            }\n          } catch (error) {\n            testSpan.setTag(TEST_STATUS, 'fail')\n            testSpan.setTag('error', error)\n            if (done) {\n              done(error)\n            }\n            throw error\n          } finally {\n            finishAllTraceSpans(testSpan)\n          }\n          if (done) {\n            done(result)\n          }\n        }\n      )\n      return it(description, newSpecFunction, timeout)\n    }\n  }\n}\n\nfunction createWrapOnException (tracer, globalInput) {\n  return function wrapOnException (onException) {\n    return function onExceptionWithTrace (err) {\n      let activeTestSpan = tracer.scope().active()\n      if (!activeTestSpan) {\n        activeTestSpan = globalInput.jasmine.testSpanByTestName[this.getFullName()]\n      }\n      if (!activeTestSpan) {\n        return onException.apply(this, arguments)\n      }\n      const {\n        [TEST_NAME]: testName,\n        [TEST_SUITE]: testSuite,\n        [TEST_STATUS]: testStatus\n      } = activeTestSpan._spanContext._tags\n\n      const isActiveSpanFailing = this.getFullName() === testName &&\n        this.result.testPath.endsWith(testSuite)\n\n      if (isActiveSpanFailing && !testStatus) {\n        activeTestSpan.setTag(TEST_STATUS, 'fail')\n        // If we don't do this, jest will show this file on its error message\n        if (err.stack) {\n          const stackFrames = err.stack.split('\\n')\n          const filteredStackFrames = stackFrames.filter(frame => !frame.includes(__dirname)).join('\\n')\n          err.stack = filteredStackFrames\n        }\n        activeTestSpan.setTag('error', err)\n        // need to manually finish, as it will not be caught in `itWithTrace`\n        activeTestSpan.finish()\n      }\n\n      return onException.apply(this, arguments)\n    }\n  }\n}\n\nfunction createWrapItSkip (tracer, globalConfig, globalInput, testEnvironmentMetadata) {\n  return function wrapItSkip (it) {\n    return function itSkipWithTrace () {\n      const { childOf, commonSpanTags } = getTestSpanTags(tracer, testEnvironmentMetadata)\n\n      const testSuite = getTestSuitePath(globalInput.jasmine.testPath, globalConfig.rootDir)\n\n      const spec = it.apply(this, arguments)\n\n      const testName = spec.getFullName()\n      const resource = `${testSuite}.${testName}`\n\n      const testSpan = tracer.startSpan(\n        'jest.test',\n        {\n          childOf,\n          tags: {\n            ...commonSpanTags,\n            [RESOURCE_NAME]: resource,\n            [TEST_NAME]: testName,\n            [TEST_SUITE]: testSuite,\n            [TEST_STATUS]: 'skip',\n            [TEST_FRAMEWORK_VERSION]: tracer._version,\n            [JEST_TEST_RUNNER]: 'jest-jasmine2'\n          }\n        }\n      )\n      testSpan.context()._trace.origin = CI_APP_ORIGIN\n      testSpan.finish()\n\n      return spec\n    }\n  }\n}\n\nfunction createWrapJasmineAsyncInstall (tracer, instrumenter, testEnvironmentMetadata) {\n  return function jasmineAsyncInstallWithTrace (jasmineAsyncInstall) {\n    return function (globalConfig, globalInput) {\n      globalInput.jasmine.testSpanByTestName = {}\n      instrumenter.wrap(globalInput.jasmine.Spec.prototype, 'onException', createWrapOnException(tracer, globalInput))\n      instrumenter.wrap(globalInput, 'it', createWrapIt(tracer, globalConfig, globalInput, testEnvironmentMetadata))\n      // instruments 'it.only'\n      instrumenter.wrap(globalInput, 'fit', createWrapIt(tracer, globalConfig, globalInput, testEnvironmentMetadata))\n      // instruments 'it.skip'\n      instrumenter.wrap(\n        globalInput,\n        'xit',\n        createWrapItSkip(tracer, globalConfig, globalInput, testEnvironmentMetadata)\n      )\n      return jasmineAsyncInstall(globalConfig, globalInput)\n    }\n  }\n}\n\nmodule.exports = [\n  {\n    name: 'jest-jasmine2',\n    versions: ['>=24.8.0'],\n    file: 'build/jasmineAsyncInstall.js',\n    patch: function (jasmineAsyncInstallExport, tracer, config) {\n      const testEnvironmentMetadata = getTestEnvironmentMetadata('jest', config)\n      return this.wrapExport(\n        jasmineAsyncInstallExport.default,\n        createWrapJasmineAsyncInstall(tracer, this, testEnvironmentMetadata)(jasmineAsyncInstallExport.default)\n      )\n    },\n    unpatch: function (jasmineAsyncInstallExport) {\n      this.unwrapExport(jasmineAsyncInstallExport.default)\n    }\n  }\n]\n","const { SAMPLING_RULE_DECISION } = require('../../dd-trace/src/constants')\nconst { SAMPLING_PRIORITY, SPAN_TYPE } = require('../../../ext/tags')\nconst { AUTO_KEEP } = require('../../../ext/priority')\nconst { TEST_TYPE, TEST_STATUS, getTestParentSpan } = require('../../dd-trace/src/plugins/util/test')\n\n/**\n * There are two ways to call `test.each` in `jest`:\n * 1. With an array of arrays: https://jestjs.io/docs/api#1-testeachtablename-fn-timeout\n * 2. With a tagged template literal: https://jestjs.io/docs/api#2-testeachtablename-fn-timeout\n * This function distinguishes between the two and returns the test parameters in different formats:\n * 1. An array of arrays with the different parameters to the test, e.g.\n * [[1, 2, 3], [2, 3, 5]]\n * 2. An array of objects, e.g.\n * [{ a: 1, b: 2, expected: 3 }, { a: 2, b: 3, expected: 5}]\n */\nfunction getFormattedJestTestParameters (testParameters) {\n  if (!testParameters || !testParameters.length) {\n    return\n  }\n  const [parameterArray, ...parameterValues] = testParameters\n  if (parameterValues.length === 0) { // Way 1.\n    return parameterArray\n  }\n  // Way 2.\n  const parameterKeys = parameterArray[0].split('|').map(key => key.trim())\n  const formattedParameters = []\n  for (let index = 0; index < parameterValues.length; index++) {\n    const parameterValue = parameterValues[index]\n    const parameterIndex = index % parameterKeys.length\n    if (!parameterIndex) {\n      formattedParameters.push({})\n    }\n    const parameterKey = parameterKeys[parameterIndex]\n    const lastFormattedParameter = formattedParameters[formattedParameters.length - 1]\n    lastFormattedParameter[parameterKey] = parameterValue\n  }\n\n  return formattedParameters\n}\n\nfunction getTestSpanTags (tracer, testEnvironmentMetadata) {\n  const childOf = getTestParentSpan(tracer)\n\n  const commonSpanTags = {\n    [TEST_TYPE]: 'test',\n    [SAMPLING_RULE_DECISION]: 1,\n    [SAMPLING_PRIORITY]: AUTO_KEEP,\n    [SPAN_TYPE]: 'test',\n    ...testEnvironmentMetadata\n  }\n  return {\n    childOf,\n    commonSpanTags\n  }\n}\n\nfunction setSuppressedErrors (suppressedErrors, testSpan) {\n  if (suppressedErrors && suppressedErrors.length) {\n    testSpan.setTag('error', suppressedErrors[0])\n    testSpan.setTag(TEST_STATUS, 'fail')\n  }\n}\n\nmodule.exports = { getFormattedJestTestParameters, getTestSpanTags, setSuppressedErrors }\n","'use strict'\n\nconst analyticsSampler = require('../../dd-trace/src/analytics_sampler')\n\nfunction createWrapProducer (tracer, config) {\n  return function wrapProducer (createProducer) {\n    return function producerWithTrace () {\n      const serviceName = config.service || `${tracer._service}-kafka`\n      const producer = createProducer.apply(this, arguments)\n\n      const send = producer.send\n\n      const tags = {\n        'service.name': serviceName,\n        'span.kind': 'producer',\n        'component': 'kafkajs'\n      }\n\n      producer.send = tracer.wrap('kafka.produce', { tags }, function (...args) {\n        const { topic, messages = [] } = args[0]\n        const currentSpan = tracer.scope().active()\n\n        analyticsSampler.sample(currentSpan, config.measured)\n\n        currentSpan.addTags({\n          'resource.name': topic,\n          'kafka.topic': topic,\n          'kafka.batch_size': messages.length\n        })\n\n        for (const message of messages) {\n          message.headers = message.headers || {}\n          tracer.inject(currentSpan, 'text_map', message.headers)\n        }\n\n        return send.apply(this, args)\n      })\n\n      return producer\n    }\n  }\n}\n\nfunction createWrapConsumer (tracer, config) {\n  return function wrapConsumer (createConsumer) {\n    return function consumerWithTrace () {\n      const serviceName = config.service || `${tracer._service}-kafka`\n      const consumer = createConsumer.apply(this, arguments)\n      const run = consumer.run\n\n      const tags = {\n        'service.name': serviceName,\n        'span.kind': 'consumer',\n        'span.type': 'worker',\n        'component': 'kafkajs'\n      }\n\n      consumer.run = function ({ eachMessage, ...runArgs }) {\n        if (typeof eachMessage !== 'function') return run({ eachMessage, ...runArgs })\n\n        return run({\n          eachMessage: function (...eachMessageArgs) {\n            const { topic, partition, message } = eachMessageArgs[0]\n            const childOf = extract(tracer, message.headers)\n\n            return tracer.trace('kafka.consume', { childOf, tags }, () => {\n              const currentSpan = tracer.scope().active()\n\n              analyticsSampler.sample(currentSpan, config.measured, true)\n\n              currentSpan.addTags({\n                'resource.name': topic,\n                'kafka.topic': topic,\n                'kafka.partition': partition,\n                'kafka.message.offset': message.offset\n              })\n\n              return eachMessage.apply(this, eachMessageArgs)\n            })\n          },\n          ...runArgs\n        })\n      }\n\n      return consumer\n    }\n  }\n}\n\nfunction extract (tracer, bufferMap) {\n  if (!bufferMap) return null\n\n  const textMap = {}\n\n  for (const key of Object.keys(bufferMap)) {\n    textMap[key] = bufferMap[key].toString()\n  }\n\n  return tracer.extract('text_map', textMap)\n}\n\nmodule.exports = [\n  {\n    name: 'kafkajs',\n    versions: ['>=1.4'],\n    patch ({ Kafka }, tracer, config) {\n      this.wrap(\n        Kafka.prototype,\n        'producer',\n        createWrapProducer(tracer, config)\n      )\n      this.wrap(\n        Kafka.prototype,\n        'consumer',\n        createWrapConsumer(tracer, config)\n      )\n    },\n    unpatch ({ Kafka }) {\n      this.unwrap(Kafka.prototype, 'producer')\n      this.unwrap(Kafka.prototype, 'consumer')\n    }\n  }\n]\n","'use strict'\n\nconst { wrapThen } = require('../../datadog-instrumentations/src/helpers/promise')\n\nfunction createPatch (file) {\n  return {\n    name: 'knex',\n    versions: ['>=0.8.0'],\n    file,\n    patch (Builder) {\n      this.wrap(Builder.prototype, 'then', wrapThen)\n    },\n    unpatch (Builder) {\n      this.unwrap(Builder.prototype, 'then')\n    }\n  }\n}\n\nmodule.exports = [\n  createPatch('lib/query/builder.js'),\n  createPatch('lib/raw.js'),\n  createPatch('lib/schema/builder.js')\n]\n","'use strict'\n\nconst web = require('../../dd-trace/src/plugins/util/web')\n\nconst originals = new WeakMap()\n\nfunction createWrapCallback (tracer, config) {\n  config = web.normalizeConfig(config)\n\n  return function wrapCallback (callback) {\n    return function callbackWithTrace () {\n      const handleRequest = callback.apply(this, arguments)\n\n      if (typeof handleRequest !== 'function') return handleRequest\n\n      return function handleRequestWithTrace (req, res) {\n        web.instrument(tracer, config, req, res, 'koa.request')\n\n        return handleRequest.apply(this, arguments)\n      }\n    }\n  }\n}\n\nfunction createWrapCreateContext () {\n  return function wrapCreateContext (createContext) {\n    return function createContextWithTrace (req, res) {\n      const ctx = createContext.apply(this, arguments)\n\n      if (!ctx) return ctx\n\n      web.patch(req)\n      web.beforeEnd(req, () => {\n        web.enterRoute(req, ctx.routePath)\n      })\n\n      return ctx\n    }\n  }\n}\n\nfunction createWrapUse () {\n  return function wrapUse (use) {\n    return function useWithTrace () {\n      const result = use.apply(this, arguments)\n\n      if (!Array.isArray(this.middleware)) return result\n\n      const fn = this.middleware.pop()\n\n      this.middleware.push(wrapMiddleware(fn))\n\n      return result\n    }\n  }\n}\n\nfunction createWrapRegister (tracer, config) {\n  return function wrapRegister (register) {\n    return function registerWithTrace (path, methods, middleware, opts) {\n      const route = register.apply(this, arguments)\n\n      if (!Array.isArray(path) && route && Array.isArray(route.stack)) {\n        wrapStack(route)\n      }\n\n      return route\n    }\n  }\n}\n\nfunction createWrapRouterUse (tracer, config) {\n  return function wrapUse (use) {\n    return function useWithTrace () {\n      const router = use.apply(this, arguments)\n\n      router.stack.forEach(wrapStack)\n\n      return router\n    }\n  }\n}\n\nfunction wrapStack (layer) {\n  layer.stack = layer.stack.map(middleware => {\n    if (typeof middleware !== 'function') return middleware\n\n    const original = originals.get(middleware)\n\n    middleware = original || middleware\n\n    const wrappedMiddleware = wrapMiddleware(middleware)\n\n    const handler = function (ctx, next) {\n      if (!ctx || !web.active(ctx.req)) return middleware.apply(this, arguments)\n\n      web.exitRoute(ctx.req)\n      web.enterRoute(ctx.req, layer.path)\n\n      return wrappedMiddleware.apply(this, arguments)\n    }\n\n    originals.set(handler, middleware)\n\n    return handler\n  })\n}\n\nfunction wrapMiddleware (fn) {\n  if (typeof fn !== 'function') return fn\n\n  return function (ctx, next) {\n    if (!ctx) return fn.apply(this, arguments)\n\n    return web.wrapMiddleware(ctx.req, fn, 'koa.middleware', () => {\n      try {\n        const result = fn.apply(this, arguments)\n\n        if (result && typeof result.then === 'function') {\n          result.then(\n            () => web.finish(ctx.req),\n            err => web.finish(ctx.req, err)\n          )\n        } else {\n          web.finish(ctx.req)\n        }\n\n        return result\n      } catch (e) {\n        web.finish(ctx.req, e)\n        throw e\n      }\n    })\n  }\n}\n\nmodule.exports = [\n  {\n    name: 'koa',\n    versions: ['>=2'],\n    patch (Koa, tracer, config) {\n      this.wrap(Koa.prototype, 'callback', createWrapCallback(tracer, config))\n      this.wrap(Koa.prototype, 'createContext', createWrapCreateContext(tracer, config))\n      this.wrap(Koa.prototype, 'use', createWrapUse(tracer, config))\n    },\n    unpatch (Koa) {\n      this.unwrap(Koa.prototype, 'callback')\n      this.unwrap(Koa.prototype, 'createContext')\n      this.unwrap(Koa.prototype, 'use')\n    }\n  },\n  {\n    name: '@koa/router',\n    versions: ['>=8'],\n    patch (Router, tracer, config) {\n      this.wrap(Router.prototype, 'register', createWrapRegister(tracer, config))\n      this.wrap(Router.prototype, 'use', createWrapRouterUse(tracer, config))\n    },\n    unpatch (Router) {\n      this.unwrap(Router.prototype, 'register')\n      this.unwrap(Router.prototype, 'use')\n    }\n  },\n  {\n    name: 'koa-router',\n    versions: ['>=7'],\n    patch (Router, tracer, config) {\n      this.wrap(Router.prototype, 'register', createWrapRegister(tracer, config))\n      this.wrap(Router.prototype, 'use', createWrapRouterUse(tracer, config))\n    },\n    unpatch (Router) {\n      this.unwrap(Router.prototype, 'register')\n      this.unwrap(Router.prototype, 'use')\n    }\n  }\n]\n","'use strict'\n\nfunction createWrapRequest (tracer) {\n  const scope = tracer.scope()\n\n  return function wrapRequest (original) {\n    return function requestWithTrace (request, callback) {\n      const index = arguments.length - 1\n\n      arguments[index] = scope.bind(arguments[index])\n\n      return original.apply(this, arguments)\n    }\n  }\n}\n\nmodule.exports = [\n  {\n    name: 'limitd-client',\n    versions: ['>=2.8'],\n    patch (LimitdClient, tracer) {\n      this.wrap(LimitdClient.prototype, '_directRequest', createWrapRequest(tracer))\n      this.wrap(LimitdClient.prototype, '_retriedRequest', createWrapRequest(tracer))\n    },\n    unpatch (LimitdClient) {\n      this.unwrap(LimitdClient.prototype, '_directRequest')\n      this.unwrap(LimitdClient.prototype, '_retriedRequest')\n    }\n  }\n]\n","'use strict'\n\nconst Plugin = require('../../dd-trace/src/plugins/plugin')\nconst { storage } = require('../../datadog-core')\nconst analyticsSampler = require('../../dd-trace/src/analytics_sampler')\n\nclass MemcachedPlugin extends Plugin {\n  static get name () {\n    return 'memcached'\n  }\n\n  constructor (...args) {\n    super(...args)\n\n    this.addSub('apm:memcached:command:start', () => {\n      const store = storage.getStore()\n      const childOf = store ? store.span : store\n      const span = this.tracer.startSpan('memcached.command', {\n        childOf,\n        tags: {\n          'span.kind': 'client',\n          'span.type': 'memcached',\n          'service.name': this.config.service || `${this.tracer._service}-memcached`\n        }\n      })\n\n      analyticsSampler.sample(span, this.config.measured)\n      this.enter(span, store)\n    })\n\n    this.addSub('apm:memcached:command:end', () => {\n      this.exit()\n    })\n\n    this.addSub('apm:memcached:command:start:with-args', ({ client, server, query }) => {\n      const span = storage.getStore().span\n      span.addTags({\n        'resource.name': query.type,\n        'memcached.command': query.command\n      })\n\n      const address = getAddress(client, server, query)\n\n      if (address) {\n        span.addTags({\n          'out.host': address[0],\n          'out.port': address[1]\n        })\n      }\n    })\n\n    this.addSub('apm:memcached:command:error', err => {\n      const span = storage.getStore().span\n      span.setTag('error', err)\n    })\n\n    this.addSub('apm:memcached:command:async-end', () => {\n      const span = storage.getStore().span\n      span.finish()\n    })\n  }\n}\n\nfunction getAddress (client, server, query) {\n  if (!server) {\n    if (client.servers.length === 1) {\n      server = client.servers[0]\n    } else {\n      let redundancy = client.redundancy && client.redundancy < client.servers.length\n      const queryRedundancy = query.redundancyEnabled\n\n      if (redundancy && queryRedundancy) {\n        redundancy = client.HashRing.range(query.key, (client.redundancy + 1), true)\n        server = redundancy.shift()\n      } else {\n        server = client.HashRing.get(query.key)\n      }\n    }\n  }\n\n  return server && server.split(':')\n}\n\nmodule.exports = MemcachedPlugin\n","'use strict'\n\nconst web = require('../../dd-trace/src/plugins/util/web')\n\n// https://docs.apigee.com/api-platform/microgateway/3.1.x/develop-custom-plugins#eventhandlerfunctions\nconst listeners = [\n  'onrequest',\n  'ondata_request',\n  'onend_request',\n  'onclose_request',\n  'onerror_request',\n  'onresponse',\n  'ondata_response',\n  'onend_response',\n  'onclose_response',\n  'onerror_response'\n]\n\nfunction createWrapGateway (tracer, config) {\n  config = web.normalizeConfig(config)\n\n  return function wrapGateway (Gateway) {\n    return function GatewayWithTrace (config) {\n      const gateway = Gateway.apply(this, arguments)\n\n      gateway.addPlugin = wrapAddPlugin(gateway.addPlugin)\n\n      return gateway\n    }\n  }\n}\n\nfunction createWrapConfigProxyFactory (tracer, config) {\n  config = web.normalizeConfig(config)\n\n  return function wrapConfigProxyFactory (configProxyFactory) {\n    return function configProxyFactoryWithTrace () {\n      const configProxy = configProxyFactory.apply(this, arguments)\n\n      return function configProxyWithTrace (req, res, next) {\n        return web.instrument(tracer, config, req, res, 'microgateway.request', () => {\n          web.beforeEnd(req, () => {\n            res.proxy && web.enterRoute(req, res.proxy.base_path)\n          })\n\n          arguments[2] = wrapNext(req, next)\n\n          return configProxy.apply(this, arguments)\n        })\n      }\n    }\n  }\n}\n\nfunction createWrapPluginsFactory (tracer, config) {\n  config = web.normalizeConfig(config)\n\n  return function wrapPluginsFactory (pluginsFactory) {\n    return function pluginsFactoryWithTrace (plugins) {\n      const pluginsMiddleware = pluginsFactory.apply(this, arguments)\n\n      return function pluginsMiddlewareWithTrace (req, res, next) {\n        arguments[2] = wrapNext(req, next)\n\n        return pluginsMiddleware.apply(this, arguments)\n      }\n    }\n  }\n}\n\nfunction wrapAddPlugin (addPlugin) {\n  return function (name, plugin) {\n    if (typeof plugin === 'function') {\n      arguments[1] = wrapPluginInit(plugin)\n    } else if (plugin && typeof plugin.init === 'function') {\n      plugin.init = wrapPluginInit(plugin.init)\n    }\n\n    return addPlugin.apply(this, arguments)\n  }\n}\n\nfunction wrapPluginInit (init) {\n  return function initWithTrace (config, logging, stats) {\n    const handler = init.apply(this, arguments)\n\n    wrapListeners(handler)\n\n    return handler\n  }\n}\n\nfunction wrapNext (req, next) {\n  return function nextWithTrace (err) {\n    web.addError(req, err)\n\n    return next.apply(this, arguments)\n  }\n}\n\nfunction wrapListeners (handler) {\n  for (const name of listeners) {\n    const listener = handler[name]\n\n    if (!listener) continue\n\n    switch (listener.length) {\n      case 3:\n        handler[name] = function handlerWithTrace (req, res, next) {\n          return web.reactivate(req, () => listener.apply(this, arguments))\n        }\n        break\n      case 4:\n        handler[name] = function handlerWithTrace (req, res, data, next) {\n          return web.reactivate(req, () => listener.apply(this, arguments))\n        }\n        break\n    }\n  }\n}\n\nmodule.exports = [\n  {\n    name: 'microgateway-core',\n    versions: ['>=2.1'],\n    patch (Gateway, tracer, config) {\n      return this.wrapExport(Gateway, createWrapGateway(tracer, config)(Gateway))\n    },\n    unpatch (Gateway) {\n      this.unwrapExport(Gateway)\n    }\n  },\n  {\n    name: 'microgateway-core',\n    versions: ['>=2.1'],\n    file: 'lib/config-proxy-middleware.js',\n    patch (configProxyFactory, tracer, config) {\n      const wrapper = createWrapConfigProxyFactory(tracer, config)(configProxyFactory)\n      return this.wrapExport(configProxyFactory, wrapper)\n    },\n    unpatch (configProxyFactory) {\n      this.unwrapExport(configProxyFactory)\n    }\n  },\n  {\n    name: 'microgateway-core',\n    versions: ['>=2.1'],\n    file: 'lib/plugins-middleware.js',\n    patch (pluginsFactory, tracer, config) {\n      const wrapper = createWrapPluginsFactory(tracer, config)(pluginsFactory)\n      return this.wrapExport(pluginsFactory, wrapper)\n    },\n    unpatch (pluginsFactory) {\n      this.unwrapExport(pluginsFactory)\n    }\n  }\n]\n","'use strict'\n\nconst Plugin = require('../../dd-trace/src/plugins/plugin')\nconst { storage } = require('../../datadog-core')\n\nconst {\n  CI_APP_ORIGIN,\n  TEST_CODE_OWNERS,\n  TEST_TYPE,\n  TEST_NAME,\n  TEST_SUITE,\n  TEST_FRAMEWORK_VERSION,\n  TEST_STATUS,\n  TEST_PARAMETERS,\n  finishAllTraceSpans,\n  getTestEnvironmentMetadata,\n  getTestSuitePath,\n  getTestParentSpan,\n  getTestParametersString,\n  getCodeOwnersFileEntries,\n  getCodeOwnersForFilename\n} = require('../../dd-trace/src/plugins/util/test')\nconst { SPAN_TYPE, RESOURCE_NAME, SAMPLING_PRIORITY } = require('../../../ext/tags')\nconst { SAMPLING_RULE_DECISION } = require('../../dd-trace/src/constants')\nconst { AUTO_KEEP } = require('../../../ext/priority')\n\nconst skippedTests = new WeakSet()\n\nfunction getTestSpanMetadata (tracer, test, sourceRoot) {\n  const childOf = getTestParentSpan(tracer)\n\n  const { file: testSuiteAbsolutePath } = test\n  const fullTestName = test.fullTitle()\n  const testSuite = getTestSuitePath(testSuiteAbsolutePath, sourceRoot)\n\n  return {\n    childOf,\n    [SPAN_TYPE]: 'test',\n    [TEST_TYPE]: 'test',\n    [TEST_NAME]: fullTestName,\n    [TEST_SUITE]: testSuite,\n    [SAMPLING_RULE_DECISION]: 1,\n    [SAMPLING_PRIORITY]: AUTO_KEEP,\n    [TEST_FRAMEWORK_VERSION]: tracer._version,\n    [RESOURCE_NAME]: `${testSuite}.${fullTestName}`\n  }\n}\n\nclass MochaPlugin extends Plugin {\n  static get name () {\n    return 'mocha'\n  }\n\n  constructor (...args) {\n    super(...args)\n\n    this._testNameToParams = {}\n    this.testEnvironmentMetadata = getTestEnvironmentMetadata('mocha', this.config)\n    this.sourceRoot = process.cwd()\n    this.codeOwnersEntries = getCodeOwnersFileEntries(this.sourceRoot)\n\n    this.addSub('ci:mocha:test:start', (test) => {\n      const store = storage.getStore()\n      const span = this.startTestSpan(test)\n\n      this.enter(span, store)\n    })\n\n    this.addSub('ci:mocha:test:async-end', (status) => {\n      // if the status is skipped the span has already been finished\n      if (status === 'skipped') {\n        return\n      }\n      const span = storage.getStore().span\n\n      span.setTag(TEST_STATUS, status)\n\n      span.finish()\n      finishAllTraceSpans(span)\n    })\n\n    this.addSub('ci:mocha:test:end', () => {\n      this.exit()\n    })\n\n    // This covers programmatically skipped tests (that do go through `runTest`)\n    this.addSub('ci:mocha:test:skip', () => {\n      const span = storage.getStore().span\n      span.setTag(TEST_STATUS, 'skip')\n      span.finish()\n    })\n\n    this.addSub('ci:mocha:test:error', (err) => {\n      if (err) {\n        const span = storage.getStore().span\n        if (err.constructor.name === 'Pending' && !this.forbidPending) {\n          span.setTag(TEST_STATUS, 'skip')\n        } else {\n          span.setTag(TEST_STATUS, 'fail')\n          span.setTag('error', err)\n        }\n      }\n    })\n\n    this.addSub('ci:mocha:suite:end', tests => {\n      tests.forEach(test => {\n        const { pending: isSkipped } = test\n        // `tests` includes every test, so we need a way to mark\n        // the test as already accounted for. We do this through `skippedTests`.\n        // If the test is already marked as skipped, we don't create an additional test span.\n        if (!isSkipped || skippedTests.has(test)) {\n          return\n        }\n        skippedTests.add(test)\n\n        const testSpan = this.startTestSpan(test)\n\n        testSpan.setTag(TEST_STATUS, 'skip')\n        testSpan.finish()\n      })\n    })\n\n    this.addSub('ci:mocha:hook:error', ({ test, error }) => {\n      const testSpan = this.startTestSpan(test)\n      testSpan.setTag(TEST_STATUS, 'fail')\n      testSpan.setTag('error', error)\n      testSpan.finish()\n    })\n\n    this.addSub('ci:mocha:test:parameterize', ({ name, params }) => {\n      this._testNameToParams[name] = params\n    })\n\n    this.addSub('ci:mocha:run:end', () => {\n      this.tracer._exporter._writer.flush()\n    })\n  }\n\n  startTestSpan (test) {\n    const { childOf, ...testSpanMetadata } = getTestSpanMetadata(this.tracer, test, this.sourceRoot)\n\n    const testParametersString = getTestParametersString(this._testNameToParams, test.title)\n    if (testParametersString) {\n      testSpanMetadata[TEST_PARAMETERS] = testParametersString\n    }\n    const codeOwners = getCodeOwnersForFilename(testSpanMetadata[TEST_SUITE], this.codeOwnersEntries)\n\n    if (codeOwners) {\n      testSpanMetadata[TEST_CODE_OWNERS] = codeOwners\n    }\n\n    const testSpan = this.tracer\n      .startSpan('mocha.test', {\n        childOf,\n        tags: {\n          ...this.testEnvironmentMetadata,\n          ...testSpanMetadata\n        }\n      })\n    testSpan.context()._trace.origin = CI_APP_ORIGIN\n\n    return testSpan\n  }\n}\n\nmodule.exports = MochaPlugin\n","'use strict'\n\nconst { moleculerTags } = require('./util')\n\nfunction createWrapCall (tracer, config) {\n  return function wrapCall (call) {\n    return function callWithTrace (actionName, params, opts) {\n      const options = {\n        service: config.service,\n        resource: actionName,\n        tags: {\n          'span.kind': 'client'\n        }\n      }\n\n      opts = arguments[2] = opts || {}\n      opts.meta = opts.meta || {}\n\n      arguments.length = Math.max(3, arguments.length)\n\n      return tracer.trace('moleculer.call', options, () => {\n        const span = tracer.scope().active()\n\n        tracer.inject(span, 'text_map', opts.meta)\n\n        const promise = call.apply(this, arguments)\n\n        if (promise.ctx) {\n          const endpoint = promise.ctx.endpoint || {}\n          const node = endpoint.node || {}\n\n          span.addTags({\n            'out.host': node.hostname,\n            'out.port': node.port,\n            ...moleculerTags(this, promise.ctx, config)\n          })\n        }\n\n        return promise\n      })\n    }\n  }\n}\n\nmodule.exports = [\n  {\n    name: 'moleculer',\n    versions: ['>=0.14'],\n    patch ({ ServiceBroker }, tracer, config) {\n      if (config.client === false) return\n\n      config = Object.assign({}, config, config.client)\n\n      this.wrap(ServiceBroker.prototype, 'call', createWrapCall(tracer, config))\n    },\n    unpatch ({ ServiceBroker }) {\n      this.unwrap(ServiceBroker.prototype, 'call')\n    }\n  }\n]\n","'use strict'\n\n// TODO: support https://moleculer.services/docs/0.13/actions.html#Streaming\n\nconst client = require('./client')\nconst server = require('./server')\n\nmodule.exports = [].concat(client, server)\n","'use strict'\n\nconst { moleculerTags } = require('./util')\n\nfunction createWrapRegisterMiddlewares (tracer, config) {\n  return function wrapRegisterMiddlewares (registerMiddlewares) {\n    return function registerMiddlewaresWithTrace (userMiddlewares) {\n      if (this.middlewares && this.middlewares.add) {\n        this.middlewares.add(createMiddleware(tracer, config))\n      }\n\n      return registerMiddlewares.apply(this, arguments)\n    }\n  }\n}\n\nfunction createMiddleware (tracer, config) {\n  return {\n    name: 'Datadog',\n\n    localAction (next, action) {\n      const broker = this\n\n      return function datadogMiddleware (ctx) {\n        const childOf = tracer.extract('text_map', ctx.meta)\n        const options = {\n          service: config.service,\n          resource: action.name,\n          type: 'web',\n          tags: {\n            'span.kind': 'server',\n            ...moleculerTags(broker, ctx, config)\n          }\n        }\n\n        if (childOf) {\n          options.childOf = childOf\n        }\n\n        return tracer.trace('moleculer.action', options, () => next(ctx))\n      }\n    }\n  }\n}\n\nmodule.exports = [\n  {\n    name: 'moleculer',\n    versions: ['>=0.14'],\n    patch ({ ServiceBroker }, tracer, config) {\n      if (config.server === false) return\n\n      config = Object.assign({}, config, config.server)\n\n      this.wrap(ServiceBroker.prototype, 'registerMiddlewares', createWrapRegisterMiddlewares(tracer, config))\n    },\n    unpatch ({ ServiceBroker }) {\n      this.unwrap(ServiceBroker.prototype, 'registerMiddlewares')\n    }\n  }\n]\n","'use strict'\n\n// TODO: add ctx.params when nested object properties are deprecated\n\nfunction moleculerTags (broker, ctx, config) {\n  const service = ctx.service || {}\n  const action = ctx.action || {}\n  const meta = config.meta && ctx.meta\n\n  return {\n    'moleculer.context.action': action.name,\n    'moleculer.context.meta': meta,\n    'moleculer.context.node_id': ctx.nodeID,\n    'moleculer.context.request_id': ctx.requestID,\n    'moleculer.context.service': service.name,\n    'moleculer.namespace': broker.namespace,\n    'moleculer.node_id': broker.nodeID\n  }\n}\n\nmodule.exports = { moleculerTags }\n","'use strict'\n\nconst Plugin = require('../../dd-trace/src/plugins/plugin')\nconst { storage } = require('../../datadog-core')\nconst analyticsSampler = require('../../dd-trace/src/analytics_sampler')\n\nclass MongodbCorePlugin extends Plugin {\n  static get name () {\n    return 'mongodb-core'\n  }\n\n  constructor (...args) {\n    super(...args)\n\n    this.addSub(`apm:mongodb:query:start`, ({ ns, ops, options, name }) => {\n      const query = getQuery(ops)\n      const resource = getResource(ns, query, name)\n      const store = storage.getStore()\n      const childOf = store ? store.span : store\n      const span = this.tracer.startSpan('mongodb.query', {\n        childOf,\n        tags: {\n          'service.name': this.config.service || `${this.tracer._service}-mongodb`,\n          'resource.name': resource,\n          'span.type': 'mongodb',\n          'span.kind': 'client',\n          'db.name': ns\n        }\n      })\n\n      if (query) {\n        span.setTag('mongodb.query', query)\n      }\n\n      if (options && options.host && options.port) {\n        span.addTags({\n          'out.host': options.host,\n          'out.port': options.port\n        })\n      }\n\n      analyticsSampler.sample(span, this.config.measured)\n      this.enter(span, store)\n    })\n\n    this.addSub(`apm:mongodb:query:end`, () => {\n      this.exit()\n    })\n\n    this.addSub(`apm:mongodb:query:error`, err => {\n      storage.getStore().span.setTag('error', err)\n    })\n\n    this.addSub(`apm:mongodb:query:async-end`, () => {\n      storage.getStore().span.finish()\n    })\n  }\n}\n\nfunction getQuery (cmd) {\n  if (!cmd || typeof cmd !== 'object' || Array.isArray(cmd)) return\n  if (cmd.query) return JSON.stringify(sanitize(cmd.query))\n  if (cmd.filter) return JSON.stringify(sanitize(cmd.filter))\n}\n\nfunction getResource (ns, query, operationName) {\n  const parts = [operationName, ns]\n\n  if (query) {\n    parts.push(query)\n  }\n\n  return parts.join(' ')\n}\n\nfunction shouldHide (input) {\n  return !isObject(input) || Buffer.isBuffer(input) || isBSON(input)\n}\n\nfunction sanitize (input) {\n  if (shouldHide(input)) return '?'\n\n  const output = {}\n  const queue = [{\n    input,\n    output,\n    depth: 0\n  }]\n\n  while (queue.length) {\n    const {\n      input, output, depth\n    } = queue.pop()\n    const nextDepth = depth + 1\n    for (const key in input) {\n      if (typeof input[key] === 'function') continue\n\n      const child = input[key]\n      if (depth >= 20 || shouldHide(child)) {\n        output[key] = '?'\n      } else {\n        queue.push({\n          input: child,\n          output: output[key] = {},\n          depth: nextDepth\n        })\n      }\n    }\n  }\n\n  return output\n}\n\nfunction isObject (val) {\n  return typeof val === 'object' && val !== null && !(val instanceof Array)\n}\n\nfunction isBSON (val) {\n  return val && val._bsontype\n}\n\nmodule.exports = MongodbCorePlugin\n","'use strict'\n\nconst Plugin = require('../../dd-trace/src/plugins/plugin')\nconst { storage } = require('../../datadog-core')\nconst analyticsSampler = require('../../dd-trace/src/analytics_sampler')\n\nclass MySQLPlugin extends Plugin {\n  static get name () {\n    return 'mysql'\n  }\n\n  constructor (...args) {\n    super(...args)\n\n    this.addSub(`apm:${this.constructor.name}:query:start`, ({ sql, conf }) => {\n      const store = storage.getStore()\n      const childOf = store ? store.span : store\n      const span = this.tracer.startSpan('mysql.query', {\n        childOf,\n        tags: {\n          'service.name': this.config.service || `${this.tracer._service}-mysql`,\n          'span.type': 'sql',\n          'span.kind': 'client',\n          'db.type': 'mysql',\n          'db.user': conf.user,\n          'out.host': conf.host,\n          'out.port': conf.port,\n          'resource.name': sql\n        }\n      })\n\n      if (conf.database) {\n        span.setTag('db.name', conf.database)\n      }\n\n      analyticsSampler.sample(span, this.config.measured)\n      this.enter(span, store)\n    })\n\n    this.addSub(`apm:${this.constructor.name}:query:end`, () => {\n      this.exit()\n    })\n\n    this.addSub(`apm:${this.constructor.name}:query:error`, err => {\n      if (err) {\n        const span = storage.getStore().span\n        span.setTag('error', err)\n      }\n    })\n\n    this.addSub(`apm:${this.constructor.name}:query:async-end`, () => {\n      const span = storage.getStore().span\n      span.finish()\n    })\n  }\n}\n\nmodule.exports = MySQLPlugin\n","'use strict'\n\nconst MySQLPlugin = require('../../datadog-plugin-mysql/src')\n\nclass MySQL2Plugin extends MySQLPlugin {\n  static get name () {\n    return 'mysql2'\n  }\n}\n\nmodule.exports = MySQL2Plugin\n","'use strict'\n\nconst Plugin = require('../../dd-trace/src/plugins/plugin')\nconst { storage } = require('../../datadog-core')\nconst analyticsSampler = require('../../dd-trace/src/analytics_sampler')\n\nclass NetPlugin extends Plugin {\n  static get name () {\n    return 'net'\n  }\n\n  constructor (...args) {\n    super(...args)\n\n    this.addSub(`apm:net:ipc:start`, ({ options }) => {\n      const store = storage.getStore()\n      const childOf = store ? store.span : store\n\n      const span = this.tracer.startSpan('ipc.connect', {\n        childOf,\n        tags: {\n          'resource.name': options.path,\n          'ipc.path': options.path,\n          'span.kind': 'client',\n          'service.name': this.config.service || this.tracer._service\n        }\n      })\n\n      analyticsSampler.sample(span, this.config.measured)\n      this.enter(span, store)\n    })\n\n    this.addSub(`apm:net:ipc:end`, this.exit.bind(this))\n\n    this.addSub(`apm:net:ipc:error`, errorHandler)\n\n    this.addSub(`apm:net:ipc:async-end`, defaultAsyncEnd)\n\n    this.addSub(`apm:net:tcp:start`, ({ options }) => {\n      const store = storage.getStore()\n      const childOf = store ? store.span : store\n\n      const host = options.host || 'localhost'\n      const port = options.port || 0\n      const family = options.family || 4\n\n      const span = this.tracer.startSpan('tcp.connect', {\n        childOf,\n        tags: {\n          'resource.name': [host, port].filter(val => val).join(':'),\n          'tcp.remote.host': host,\n          'tcp.remote.port': port,\n          'tcp.family': `IPv${family}`,\n          'out.host': host,\n          'out.port': port,\n          'span.kind': 'client',\n          'service.name': this.config.service || this.tracer._service\n        }\n      })\n\n      analyticsSampler.sample(span, this.config.measured)\n      this.enter(span, store)\n    })\n\n    this.addSub(`apm:net:tcp:end`, this.exit.bind(this))\n\n    this.addSub(`apm:net:tcp:error`, errorHandler)\n\n    this.addSub(`apm:net:tcp:async-end`, defaultAsyncEnd)\n\n    this.addSub(`apm:net:tcp:connection`, ({ socket }) => {\n      const span = storage.getStore().span\n      span.addTags({\n        'tcp.local.address': socket.localAddress,\n        'tcp.local.port': socket.localPort\n      })\n    })\n  }\n}\n\nfunction defaultAsyncEnd () {\n  storage.getStore().span.finish()\n}\n\nfunction errorHandler (error) {\n  storage.getStore().span.setTag('error', error)\n}\n\nmodule.exports = NetPlugin\n","'use strict'\n\n// TODO: either instrument all or none of the render functions\n\nconst analyticsSampler = require('../../dd-trace/src/analytics_sampler')\n\nconst contexts = new WeakMap()\n\nfunction createWrapHandleRequest (tracer, config) {\n  return function wrapHandleRequest (handleRequest) {\n    return function handleRequestWithTrace (req, res, pathname, query) {\n      return trace(tracer, config, req, res, () => handleRequest.apply(this, arguments))\n    }\n  }\n}\n\nfunction createWrapHandleApiRequest (tracer, config) {\n  return function wrapHandleApiRequest (handleApiRequest) {\n    return function handleApiRequestWithTrace (req, res, pathname, query) {\n      return trace(tracer, config, req, res, () => {\n        const promise = handleApiRequest.apply(this, arguments)\n\n        return promise.then(handled => {\n          if (!handled) return handled\n\n          const page = getPageFromPath(pathname, this.dynamicRoutes)\n\n          addPage(req, page)\n\n          return handled\n        })\n      })\n    }\n  }\n}\n\nfunction createWrapRenderToResponse (tracer, config) {\n  return function wrapRenderToResponse (renderToResponse) {\n    return function renderToResponseWithTrace (ctx) {\n      return trace(tracer, config, ctx.req, ctx.res, () => renderToResponse.apply(this, arguments))\n    }\n  }\n}\n\nfunction createWrapRenderErrorToResponse (tracer, config) {\n  return function wrapRenderErrorToResponse (renderErrorToResponse) {\n    return function renderErrorToResponseWithTrace (ctx) {\n      return trace(tracer, config, ctx.req, ctx.res, () => renderErrorToResponse.apply(this, arguments))\n    }\n  }\n}\n\nfunction createWrapRenderToHTML (tracer, config) {\n  return function wrapRenderToHTML (renderToHTML) {\n    return function renderToHTMLWithTrace (req, res, pathname, query, parsedUrl) {\n      return trace(tracer, config, req, res, () => renderToHTML.apply(this, arguments))\n    }\n  }\n}\n\nfunction createWrapRenderErrorToHTML (tracer, config) {\n  return function wrapRenderErrorToHTML (renderErrorToHTML) {\n    return function renderErrorToHTMLWithTrace (err, req, res, pathname, query) {\n      return trace(tracer, config, req, res, () => renderErrorToHTML.apply(this, arguments))\n    }\n  }\n}\n\nfunction createWrapFindPageComponents (tracer, config) {\n  return function wrapFindPageComponents (findPageComponents) {\n    return function findPageComponentsWithTrace (pathname, query) {\n      const result = findPageComponents.apply(this, arguments)\n      const span = tracer.scope().active()\n      const req = span && span._nextReq\n\n      if (result) {\n        addPage(req, pathname)\n      }\n\n      return result\n    }\n  }\n}\n\nfunction getPageFromPath (page, dynamicRoutes = []) {\n  for (const dynamicRoute of dynamicRoutes) {\n    if (dynamicRoute.page.startsWith('/api') && dynamicRoute.match(page)) {\n      return dynamicRoute.page\n    }\n  }\n\n  return page\n}\n\nfunction trace (tracer, config, req, res, handler) {\n  const scope = tracer.scope()\n  const context = contexts.get(req)\n\n  if (context) return scope.activate(context.span, handler)\n\n  const childOf = scope.active()\n  const tags = {\n    'service.name': config.service || tracer._service,\n    'resource.name': req.method,\n    'span.type': 'web',\n    'span.kind': 'server',\n    'http.method': req.method\n  }\n  const span = tracer.startSpan('next.request', { childOf, tags })\n\n  analyticsSampler.sample(span, config.measured, true)\n\n  contexts.set(req, { span })\n\n  const promise = scope.activate(span, handler)\n\n  // HACK: Store the request object on the span for findPageComponents.\n  // TODO: Use CLS when it will be available in core.\n  span._nextReq = req\n\n  return promise.then(\n    result => finish(span, config, req, res, result),\n    err => finish(span, config, req, res, null, err)\n  )\n}\n\nfunction addPage (req, page) {\n  const context = contexts.get(req)\n\n  if (!context) return\n\n  context.span.addTags({\n    'resource.name': `${req.method} ${page}`.trim(),\n    'next.page': page\n  })\n}\n\nfunction finish (span, config, req, res, result, err) {\n  span.setTag('error', err || !config.validateStatus(res.statusCode))\n  span.addTags({\n    'http.status_code': res.statusCode\n  })\n  config.hooks.request(span, req, res)\n  span.finish()\n\n  return result || err\n}\n\nfunction normalizeConfig (config) {\n  const hooks = getHooks(config)\n  const validateStatus = typeof config.validateStatus === 'function'\n    ? config.validateStatus\n    : code => code < 500\n\n  return Object.assign({}, config, { hooks, validateStatus })\n}\n\nfunction getHooks (config) {\n  const noop = () => {}\n  const request = (config.hooks && config.hooks.request) || noop\n\n  return { request }\n}\n\nmodule.exports = [\n  {\n    name: 'next',\n    versions: ['>=9.5 <11.1'],\n    file: 'dist/next-server/server/next-server.js',\n    patch ({ default: Server }, tracer, config) {\n      config = normalizeConfig(config)\n\n      this.wrap(Server.prototype, 'handleRequest', createWrapHandleRequest(tracer, config))\n      this.wrap(Server.prototype, 'handleApiRequest', createWrapHandleApiRequest(tracer, config))\n      this.wrap(Server.prototype, 'renderToHTML', createWrapRenderToHTML(tracer, config))\n      this.wrap(Server.prototype, 'renderErrorToHTML', createWrapRenderErrorToHTML(tracer, config))\n      this.wrap(Server.prototype, 'findPageComponents', createWrapFindPageComponents(tracer, config))\n    },\n    unpatch ({ default: Server }) {\n      this.unwrap(Server.prototype, 'handleRequest')\n      this.unwrap(Server.prototype, 'handleApiRequest')\n      this.unwrap(Server.prototype, 'renderToHTML')\n      this.unwrap(Server.prototype, 'renderErrorToHTML')\n      this.unwrap(Server.prototype, 'findPageComponents')\n    }\n  },\n\n  {\n    name: 'next',\n    versions: ['>=11.1'],\n    file: 'dist/server/next-server.js',\n    patch ({ default: Server }, tracer, config) {\n      config = normalizeConfig(config)\n\n      this.wrap(Server.prototype, 'handleRequest', createWrapHandleRequest(tracer, config))\n      this.wrap(Server.prototype, 'handleApiRequest', createWrapHandleApiRequest(tracer, config))\n      this.wrap(Server.prototype, 'renderToResponse', createWrapRenderToResponse(tracer, config))\n      this.wrap(Server.prototype, 'renderErrorToResponse', createWrapRenderErrorToResponse(tracer, config))\n      this.wrap(Server.prototype, 'findPageComponents', createWrapFindPageComponents(tracer, config))\n    },\n    unpatch ({ default: Server }) {\n      this.unwrap(Server.prototype, 'handleRequest')\n      this.unwrap(Server.prototype, 'handleApiRequest')\n      this.unwrap(Server.prototype, 'renderToResponse')\n      this.unwrap(Server.prototype, 'renderErrorToResponse')\n      this.unwrap(Server.prototype, 'findPageComponents')\n    }\n  }\n]\n","'use strict'\n\nconst analyticsSampler = require('../../dd-trace/src/analytics_sampler')\n\nconst connectionAttributes = new WeakMap()\nconst poolAttributes = new WeakMap()\n\nfunction createWrapExecute (tracer, config) {\n  return function wrapExecute (execute) {\n    return function executeWithTrace (dbQuery, ...args) {\n      const connAttrs = connectionAttributes.get(this)\n      const service = getServiceName(tracer, config, connAttrs)\n      const connectStringObj = new URL('http://' + connAttrs.connectString)\n      const tags = {\n        'span.kind': 'client',\n        'span.type': 'sql',\n        'sql.query': dbQuery,\n        'db.instance': connectStringObj.pathname.substring(1),\n        'db.hostname': connectStringObj.hostname,\n        'db.user': config.user,\n        'db.port': connectStringObj.port,\n        'resource.name': dbQuery,\n        'service.name': service\n      }\n\n      return tracer.wrap('oracle.query', { tags }, function (...args) {\n        const span = tracer.scope().active()\n\n        analyticsSampler.sample(span, config.measured)\n\n        return execute.apply(this, args)\n      }).apply(this, arguments)\n    }\n  }\n}\n\nfunction createWrapGetConnection (tracer, config) {\n  return function wrapGetConnection (getConnection) {\n    return function getConnectionWithTrace (connAttrs, callback) {\n      if (callback) {\n        arguments[1] = (err, connection) => {\n          if (connection) {\n            connectionAttributes.set(connection, connAttrs)\n          }\n          callback(err, connection)\n        }\n\n        getConnection.apply(this, arguments)\n      } else {\n        return getConnection.apply(this, arguments).then((connection) => {\n          connectionAttributes.set(connection, connAttrs)\n          return connection\n        })\n      }\n    }\n  }\n}\n\nfunction createWrapCreatePool (tracer, config) {\n  return function wrapCreatePool (createPool) {\n    return function createPoolWithTrace (poolAttrs, callback) {\n      if (callback) {\n        arguments[1] = (err, pool) => {\n          if (pool) {\n            poolAttributes.set(pool, poolAttrs)\n          }\n          callback(err, pool)\n        }\n\n        createPool.apply(this, arguments)\n      } else {\n        return createPool.apply(this, arguments).then((pool) => {\n          poolAttributes.set(pool, poolAttrs)\n          return pool\n        })\n      }\n    }\n  }\n}\n\nfunction createWrapPoolGetConnection (tracer, config) {\n  return function wrapPoolGetConnection (getConnection) {\n    return function poolGetConnectionWithTrace () {\n      let callback\n      if (typeof arguments[arguments.length - 1] === 'function') {\n        callback = arguments[arguments.length - 1]\n      }\n      if (callback) {\n        arguments[arguments.length - 1] = (err, connection) => {\n          if (connection) {\n            connectionAttributes.set(connection, poolAttributes.get(this))\n          }\n          callback(err, connection)\n        }\n        getConnection.apply(this, arguments)\n      } else {\n        return getConnection.apply(this, arguments).then((connection) => {\n          connectionAttributes.set(connection, poolAttributes.get(this))\n          return connection\n        })\n      }\n    }\n  }\n}\n\nfunction getServiceName (tracer, config, connAttrs) {\n  if (typeof config.service === 'function') {\n    return config.service(connAttrs)\n  } else if (config.service) {\n    return config.service\n  } else {\n    return `${tracer._service}-oracle`\n  }\n}\n\nmodule.exports = {\n  name: 'oracledb',\n  versions: ['5'],\n  patch (oracledb, tracer, config) {\n    this.wrap(oracledb.Connection.prototype, 'execute', createWrapExecute(tracer, config))\n    this.wrap(oracledb, 'getConnection', createWrapGetConnection(tracer, config))\n    this.wrap(oracledb, 'createPool', createWrapCreatePool(tracer, config))\n    this.wrap(oracledb.Pool.prototype, 'getConnection', createWrapPoolGetConnection(tracer, config))\n  },\n  unpatch (oracledb) {\n    this.unwrap(oracledb.Connection.prototype, 'execute')\n    this.unwrap(oracledb, 'getConnection')\n    this.unwrap(oracledb, 'createPool')\n    this.unwrap(oracledb.Pool.prototype, 'getConnection')\n  }\n}\n","'use strict'\n\nconst web = require('../../dd-trace/src/plugins/util/web')\n\nconst traceRoute = handler => req => {\n  const { original, route } = req\n\n  if (web.active(original)) {\n    web.enterRoute(original, route)\n  }\n\n  return handler(req)\n}\n\nconst wrapLogger = tracer => logger => record => {\n  const span = tracer.scope().active()\n\n  if (!span) return logger(record)\n\n  const correlation = {\n    dd: {\n      trace_id: span.context().toTraceId(),\n      span_id: span.context().toSpanId()\n    }\n  }\n\n  record = record instanceof Error\n    ? Object.assign(record, correlation)\n    : Object.assign({}, record, correlation)\n\n  return logger(record)\n}\n\nconst wrapMount = (tracer, config) => mount => opts => {\n  const handler = mount(opts)\n\n  const traced = (req, res) =>\n    web.instrument(\n      tracer, config, req, res, 'paperplane.request',\n      () => handler(req, res)\n    )\n\n  return traced\n}\n\nconst wrapRoutes = tracer => routes => handlers => {\n  const traced = {}\n\n  for (const route in handlers) {\n    traced[route] = traceRoute(handlers[route])\n  }\n\n  return routes(traced)\n}\n\nconst nodeMajor = Number(process.versions.node.split('.')[0])\nconst mainVersionRange = nodeMajor <= 12 ? ['>=2.3.2'] : nodeMajor <= 14 ? ['>=3.1.1'] : []\n\nmodule.exports = [\n  {\n    name: 'paperplane',\n    versions: mainVersionRange,\n    file: 'lib/logger.js',\n    patch (exports, tracer) {\n      if (tracer._logInjection) {\n        this.wrap(exports, 'logger', wrapLogger(tracer))\n      }\n    },\n    unpatch (exports) {\n      this.unwrap(exports, 'logger')\n    }\n  },\n  {\n    name: 'paperplane',\n    versions: mainVersionRange,\n    file: 'lib/mount.js',\n    patch (exports, tracer, config) {\n      config = web.normalizeConfig(config)\n      this.wrap(exports, 'mount', wrapMount(tracer, config))\n    },\n    unpatch (exports) {\n      this.unwrap(exports, 'mount')\n    }\n  },\n  {\n    name: 'paperplane',\n    versions: mainVersionRange,\n    file: 'lib/routes.js',\n    patch (exports, tracer) {\n      this.wrap(exports, 'routes', wrapRoutes(tracer))\n    },\n    unpatch (exports) {\n      this.unwrap(exports, 'routes')\n    }\n  }\n]\n\nif (nodeMajor <= 12) {\n  module.exports.push({\n    name: 'paperplane',\n    versions: ['2.3.0 - 2.3.1'],\n    patch (paperplane, tracer, config) {\n      config = web.normalizeConfig(config)\n      this.wrap(paperplane, 'mount', wrapMount(tracer, config))\n      this.wrap(paperplane, 'routes', wrapRoutes(tracer))\n    },\n    unpatch (paperplane) {\n      this.unwrap(paperplane, ['mount', 'routes'])\n    }\n  })\n}\n","'use strict'\n\nconst Plugin = require('../../dd-trace/src/plugins/plugin')\nconst { storage } = require('../../datadog-core')\nconst analyticsSampler = require('../../dd-trace/src/analytics_sampler')\n\nclass PGPlugin extends Plugin {\n  static get name () {\n    return 'pg'\n  }\n\n  constructor (...args) {\n    super(...args)\n\n    this.addSub(`apm:pg:query:start`, ({ params, statement }) => {\n      const service = getServiceName(this.tracer, this.config, params)\n      const store = storage.getStore()\n      const childOf = store ? store.span : store\n      const span = this.tracer.startSpan('pg.query', {\n        childOf,\n        tags: {\n          'service.name': service,\n          'span.type': 'sql',\n          'span.kind': 'client',\n          'db.type': 'postgres',\n          'resource.name': statement\n        }\n      })\n\n      if (params) {\n        span.addTags({\n          'db.name': params.database,\n          'db.user': params.user,\n          'out.host': params.host,\n          'out.port': params.port\n        })\n      }\n\n      analyticsSampler.sample(span, this.config.measured)\n      this.enter(span, store)\n    })\n\n    this.addSub(`apm:pg:query:end`, () => {\n      this.exit()\n    })\n\n    this.addSub(`apm:pg:query:error`, err => {\n      const span = storage.getStore().span\n      span.setTag('error', err)\n    })\n\n    this.addSub(`apm:pg:query:async-end`, () => {\n      const span = storage.getStore().span\n      span.finish()\n    })\n  }\n}\n\nfunction getServiceName (tracer, config, params) {\n  if (typeof config.service === 'function') {\n    return config.service(params)\n  } else if (config.service) {\n    return config.service\n  } else {\n    return `${tracer._service}-postgres`\n  }\n}\n\nmodule.exports = PGPlugin\n","'use strict'\n\nconst LogPlugin = require('../../dd-trace/src/plugins/log_plugin')\n\nclass PinoPlugin extends LogPlugin {\n  static get name () {\n    return 'pino'\n  }\n}\n\nmodule.exports = PinoPlugin\n","'use strict'\n\nconst Plugin = require('../../dd-trace/src/plugins/plugin')\nconst { storage } = require('../../datadog-core')\nconst analyticsSampler = require('../../dd-trace/src/analytics_sampler')\nconst urlFilter = require('../../dd-trace/src/plugins/util/urlfilter')\n\nclass RedisPlugin extends Plugin {\n  static get name () {\n    return 'redis'\n  }\n\n  constructor (...args) {\n    super(...args)\n\n    this.addSub(`apm:${this.constructor.name}:command:start`, (\n      { db, command, args, connectionOptions, connectionName }\n    ) => {\n      if (!this.config.filter(command)) {\n        return this.skip()\n      }\n      const store = storage.getStore()\n      const childOf = store ? store.span : store\n      const span = this.tracer.startSpan('redis.command', {\n        childOf,\n        tags: {\n          'span.kind': 'client',\n          'resource.name': command,\n          'span.type': 'redis',\n          'db.type': 'redis',\n          'db.name': db || '0',\n          'redis.raw_command': formatCommand(command, args)\n        }\n      })\n\n      span.setTag('service.name', this.config.service || `${span.context()._tags['service.name']}-redis`)\n\n      analyticsSampler.sample(span, this.config.measured)\n\n      if (connectionOptions) {\n        span.addTags({\n          'out.host': connectionOptions.host,\n          'out.port': connectionOptions.port\n        })\n      }\n\n      if (this.config.splitByInstance && connectionName) {\n        const service = this.config.service\n          ? `${this.config.service}-${connectionName}`\n          : connectionName\n\n        span.setTag('service.name', service)\n      }\n\n      this.enter(span, store)\n    })\n\n    this.addSub(`apm:${this.constructor.name}:command:end`, () => {\n      this.exit()\n    })\n\n    this.addSub(`apm:${this.constructor.name}:command:error`, err => {\n      const span = storage.getStore().span\n      span.setTag('error', err)\n    })\n\n    this.addSub(`apm:${this.constructor.name}:command:async-end`, () => {\n      const span = storage.getStore().span\n      span.finish()\n    })\n  }\n\n  configure (config) {\n    super.configure(normalizeConfig(config))\n  }\n}\n\nfunction formatCommand (command, args) {\n  command = command.toUpperCase()\n\n  if (!args || command === 'AUTH') return command\n\n  for (let i = 0, l = args.length; i < l; i++) {\n    if (typeof args[i] === 'function') continue\n\n    command = `${command} ${formatArg(args[i])}`\n\n    if (command.length > 1000) return trim(command, 1000)\n  }\n\n  return command\n}\n\nfunction formatArg (arg) {\n  switch (typeof arg) {\n    case 'string':\n    case 'number':\n      return trim(String(arg), 100)\n    default:\n      return '?'\n  }\n}\n\nfunction trim (str, maxlen) {\n  if (str.length > maxlen) {\n    str = str.substr(0, maxlen - 3) + '...'\n  }\n\n  return str\n}\n\nfunction normalizeConfig (config) {\n  const filter = urlFilter.getFilter(config)\n\n  return Object.assign({}, config, {\n    filter\n  })\n}\n\nmodule.exports = RedisPlugin\n","'use strict'\n\nconst web = require('../../dd-trace/src/plugins/util/web')\nconst handlers = ['use', 'pre']\nconst methods = ['del', 'get', 'head', 'opts', 'post', 'put', 'patch']\n\nfunction createWrapSetupRequest (tracer, config, withRoute) {\n  config = web.normalizeConfig(config)\n\n  return function wrapSetupRequest (setupRequest) {\n    return function setupRequestWithTrace (req, res) {\n      return web.instrument(tracer, config, req, res, 'restify.request', () => {\n        web.beforeEnd(req, () => {\n          if (req.route && withRoute) {\n            web.enterRoute(req, req.route.path)\n          }\n        })\n\n        return setupRequest.apply(this, arguments)\n      })\n    }\n  }\n}\n\nfunction createWrapMethod (tracer, config) {\n  return function wrapMethod (method) {\n    return function methodWithTrace (path) {\n      const middleware = wrapMiddleware(Array.prototype.slice.call(arguments, 1))\n\n      return method.apply(this, [path].concat(middleware))\n    }\n  }\n}\n\nfunction createWrapHandler (tracer, config) {\n  return function wrapMethod (method) {\n    return function methodWithTrace () {\n      return method.apply(this, wrapMiddleware(arguments))\n    }\n  }\n}\n\nfunction wrapMiddleware (middleware) {\n  return Array.prototype.map.call(middleware, wrapFn)\n}\n\nfunction wrapFn (fn) {\n  if (Array.isArray(fn)) return wrapMiddleware(fn)\n\n  return function (req, res, next) {\n    return web.reactivate(req, () => fn.apply(this, arguments))\n  }\n}\n\nmodule.exports = [\n  {\n    name: 'restify',\n    versions: ['>=7'],\n    file: 'lib/server.js',\n    patch (Server, tracer, config) {\n      this.wrap(Server.prototype, '_setupRequest', createWrapSetupRequest(tracer, config))\n      this.wrap(Server.prototype, handlers, createWrapHandler(tracer, config))\n      this.wrap(Server.prototype, methods, createWrapMethod(tracer, config))\n    },\n    unpatch (Server) {\n      this.unwrap(Server.prototype, '_setupRequest')\n      this.unwrap(Server.prototype, handlers)\n      this.unwrap(Server.prototype, methods)\n    }\n  },\n  {\n    name: 'restify',\n    versions: ['3 - 6'],\n    file: 'lib/server.js',\n    patch (Server, tracer, config) {\n      this.wrap(Server.prototype, '_setupRequest', createWrapSetupRequest(tracer, config, true))\n      this.wrap(Server.prototype, handlers, createWrapHandler(tracer, config))\n      this.wrap(Server.prototype, methods, createWrapMethod(tracer, config))\n    },\n    unpatch (Server) {\n      this.unwrap(Server.prototype, '_setupRequest')\n      this.unwrap(Server.prototype, handlers)\n      this.unwrap(Server.prototype, methods)\n    }\n  }\n]\n","'use strict'\n\nconst Plugin = require('../../dd-trace/src/plugins/plugin')\nconst { storage } = require('../../datadog-core')\nconst analyticsSampler = require('../../dd-trace/src/analytics_sampler')\n\nclass RheaPlugin extends Plugin {\n  static get name () {\n    return 'rhea'\n  }\n\n  constructor (...args) {\n    super(...args)\n\n    this.addSub(`apm:rhea:send:start`, ({ targetAddress, host, port, msg }) => {\n      const store = storage.getStore()\n      const childOf = store ? store.span : store\n      const name = targetAddress || 'amq.topic'\n      const span = this.tracer.startSpan('amqp.send', {\n        childOf,\n        tags: {\n          'component': 'rhea',\n          'resource.name': name,\n          'service.name': this.config.service || `${this.tracer._service}-amqp-producer`,\n          'span.kind': 'producer',\n          'amqp.link.target.address': name,\n          'amqp.link.role': 'sender',\n          'out.host': host,\n          'out.port': port\n        }\n      })\n      analyticsSampler.sample(span, this.config.measured)\n      addDeliveryAnnotations(msg, this.tracer, span)\n\n      this.enter(span, store)\n    })\n\n    this.addSub(`apm:rhea:receive:start`, ({ msgObj, connection }) => {\n      const name = getResourceNameFromMessage(msgObj)\n\n      const store = storage.getStore()\n      const childOf = extractTextMap(msgObj, this.tracer)\n      const span = this.tracer.startSpan('amqp.receive', {\n        childOf,\n        tags: {\n          'span.type': 'worker',\n          'component': 'rhea',\n          'resource.name': name,\n          'service.name': this.config.service || this.tracer._service,\n          'span.kind': 'consumer',\n          'amqp.link.source.address': name,\n          'amqp.link.role': 'receiver'\n        }\n      })\n      analyticsSampler.sample(span, this.config.measured, true)\n\n      this.enter(span, store)\n    })\n\n    this.addSub(`apm:rhea:error`, error => {\n      storage.getStore().span.setTag('error', error)\n    })\n\n    this.addSub(`apm:rhea:async-end`, () => {\n      const span = storage.getStore().span\n      span.finish()\n    })\n\n    this.addSub(`apm:rhea:end`, () => {\n      this.exit()\n    })\n\n    this.addSub(`apm:rhea:dispatch`, ({ state }) => {\n      const span = storage.getStore().span\n      span.setTag('amqp.delivery.state', state)\n    })\n  }\n}\n\nfunction getResourceNameFromMessage (msgObj) {\n  let resourceName = 'amq.topic'\n  let options = {}\n  if (msgObj.receiver && msgObj.receiver.options) {\n    options = msgObj.receiver.options\n  }\n  if (options.source && options.source.address) {\n    resourceName = options.source.address\n  }\n  return resourceName\n}\n\nfunction extractTextMap (msgObj, tracer) {\n  if (msgObj.message) {\n    return tracer.extract('text_map', msgObj.message.delivery_annotations)\n  }\n}\n\nfunction addDeliveryAnnotations (msg, tracer, span) {\n  if (msg) {\n    msg.delivery_annotations = msg.delivery_annotations || {}\n\n    tracer.inject(span, 'text_map', msg.delivery_annotations)\n  }\n}\n\nmodule.exports = RheaPlugin\n","'use strict'\n\nconst METHODS = require('methods').concat('all')\nconst pathToRegExp = require('path-to-regexp')\nconst shimmer = require('../../datadog-shimmer')\nconst web = require('../../dd-trace/src/plugins/util/web')\n\n// TODO: stop checking for fast star and fast slash\n\nconst contexts = new WeakMap()\nconst layerMatchers = new WeakMap()\nconst regexpCache = Object.create(null)\n\nfunction createWrapHandle (tracer, config) {\n  return function wrapHandle (handle) {\n    return function handleWithTrace (req, res, done) {\n      web.patch(req)\n\n      if (!contexts.has(req)) {\n        const context = {\n          route: '',\n          stack: []\n        }\n\n        web.beforeEnd(req, () => {\n          web.enterRoute(req, context.route)\n        })\n\n        contexts.set(req, context)\n      }\n\n      return handle.apply(this, arguments)\n    }\n  }\n}\n\nfunction wrapRouterMethod (original) {\n  return function methodWithTrace (fn) {\n    const offset = this.stack ? [].concat(this.stack).length : 0\n    const router = original.apply(this, arguments)\n\n    if (typeof this.stack === 'function') {\n      this.stack = [{ handle: this.stack }]\n    }\n\n    wrapStack(this.stack, offset, extractMatchers(fn))\n\n    return router\n  }\n}\n\nfunction wrapLayerHandle (layer, handle) {\n  handle._name = handle._name || layer.name\n\n  let wrapCallHandle\n\n  if (handle.length === 4) {\n    wrapCallHandle = shimmer.wrap(handle, function (error, req, res, next) {\n      return callHandle(layer, handle, req, [error, req, res, wrapNext(layer, req, next)])\n    })\n  } else {\n    wrapCallHandle = shimmer.wrap(handle, function (req, res, next) {\n      return callHandle(layer, handle, req, [req, res, wrapNext(layer, req, next)])\n    })\n  }\n\n  // This is a workaround for the `loopback` library so that it can find the correct express layer\n  // that contains the real handle function\n  wrapCallHandle._datadog_orig = handle\n\n  return wrapCallHandle\n}\n\nfunction wrapStack (stack, offset, matchers) {\n  [].concat(stack).slice(offset).forEach(layer => {\n    if (layer.__handle) { // express-async-errors\n      layer.__handle = wrapLayerHandle(layer, layer.__handle)\n    } else {\n      layer.handle = wrapLayerHandle(layer, layer.handle)\n    }\n\n    layerMatchers.set(layer, matchers)\n\n    if (layer.route) {\n      METHODS.forEach(method => {\n        if (typeof layer.route.stack === 'function') {\n          layer.route.stack = [{ handle: layer.route.stack }]\n        }\n\n        layer.route[method] = wrapRouterMethod(layer.route[method])\n      })\n    }\n  })\n}\n\nfunction wrapNext (layer, req, next) {\n  if (!next || !web.active(req)) return next\n\n  const originalNext = next\n  const context = contexts.get(req)\n  const matchers = layerMatchers.get(layer)\n\n  return function (error) {\n    if (layer.path && !isFastStar(layer, matchers) && !isFastSlash(layer, matchers)) {\n      context.stack.pop()\n    }\n\n    web.finish(req, error)\n\n    originalNext.apply(null, arguments)\n  }\n}\n\nfunction callHandle (layer, handle, req, args) {\n  const matchers = layerMatchers.get(layer)\n\n  if (web.active(req) && matchers) {\n    // Try to guess which path actually matched\n    for (let i = 0; i < matchers.length; i++) {\n      if (matchers[i].test(layer)) {\n        const context = contexts.get(req)\n\n        context.stack.push(matchers[i].path)\n\n        const route = context.stack.join('')\n\n        // Longer route is more likely to be the actual route handler route.\n        if (route.length > context.route.length) {\n          context.route = route\n        }\n\n        break\n      }\n    }\n  }\n\n  return web.wrapMiddleware(req, handle, 'express.middleware', () => {\n    return handle.apply(layer, args)\n  })\n}\n\nfunction extractMatchers (fn) {\n  const arg = flatten([].concat(fn))\n\n  if (typeof arg[0] === 'function') {\n    return []\n  }\n\n  return arg.map(pattern => ({\n    path: pattern instanceof RegExp ? `(${pattern})` : pattern,\n    test: layer => {\n      const matchers = layerMatchers.get(layer)\n\n      return !isFastStar(layer, matchers) &&\n        !isFastSlash(layer, matchers) &&\n        cachedPathToRegExp(pattern).test(layer.path)\n    }\n  }))\n}\n\nfunction isFastStar (layer, matchers) {\n  if (layer.regexp.fast_star !== undefined) {\n    return layer.regexp.fast_star\n  }\n\n  return matchers.some(matcher => matcher.path === '*')\n}\n\nfunction isFastSlash (layer, matchers) {\n  if (layer.regexp.fast_slash !== undefined) {\n    return layer.regexp.fast_slash\n  }\n\n  return matchers.some(matcher => matcher.path === '/')\n}\n\nfunction flatten (arr) {\n  return arr.reduce((acc, val) => Array.isArray(val) ? acc.concat(flatten(val)) : acc.concat(val), [])\n}\n\nfunction cachedPathToRegExp (pattern) {\n  const maybeCached = regexpCache[pattern]\n  if (maybeCached) {\n    return maybeCached\n  }\n  const regexp = pathToRegExp(pattern)\n  regexpCache[pattern] = regexp\n  return regexp\n}\n\nmodule.exports = {\n  name: 'router',\n  versions: ['>=1'],\n  patch (Router, tracer, config) {\n    this.wrap(Router.prototype, 'handle', createWrapHandle(tracer, config))\n    this.wrap(Router.prototype, 'use', wrapRouterMethod)\n    this.wrap(Router.prototype, 'route', wrapRouterMethod)\n  },\n  unpatch (Router) {\n    this.unwrap(Router.prototype, 'handle')\n    this.unwrap(Router.prototype, 'use')\n    this.unwrap(Router.prototype, 'route')\n  }\n}\n","'use strict'\n\nconst Plugin = require('../../dd-trace/src/plugins/plugin')\nconst { storage } = require('../../datadog-core')\n\nclass SharedbPlugin extends Plugin {\n  static get name () {\n    return 'sharedb'\n  }\n\n  constructor (...args) {\n    super(...args)\n\n    this.addSub(`apm:sharedb:request:start`, ({ actionName, request }) => {\n      const store = storage.getStore()\n      const childOf = store ? store.span : store\n      const span = this.tracer.startSpan('sharedb.request', {\n        childOf,\n        tags: {\n          'service.name': this.config.service || this.tracer._service,\n          'span.kind': 'server',\n          'sharedb.action': actionName,\n          'resource.name': getReadableResourceName(actionName, request.c, request.q)\n        }\n      })\n\n      if (this.config.hooks && this.config.hooks.receive) {\n        this.config.hooks.receive(span, request)\n      }\n\n      this.enter(span, store)\n    })\n\n    this.addSub(`apm:sharedb:request:end`, () => {\n      this.exit()\n    })\n\n    this.addSub(`apm:sharedb:request:error`, err => {\n      const span = storage.getStore().span\n      span.setTag('error', err)\n    })\n\n    this.addSub(`apm:sharedb:request:async-end`, ({ request, res }) => {\n      const span = storage.getStore().span\n      if (this.config.hooks && this.config.hooks.reply) {\n        this.config.hooks.reply(span, request, res)\n      }\n      span.finish()\n    })\n  }\n}\n\nfunction getReadableResourceName (readableActionName, collection, query) {\n  if (collection) {\n    readableActionName += ' ' + collection\n  }\n  if (query) {\n    readableActionName += ' ' + JSON.stringify(sanitize(query))\n  }\n  return readableActionName\n}\n\nfunction sanitize (input) {\n  const output = {}\n\n  if (!isObject(input) || Buffer.isBuffer(input)) return '?'\n\n  for (const key in input) {\n    if (typeof input[key] === 'function') continue\n\n    output[key] = sanitize(input[key])\n  }\n\n  return output\n}\n\nfunction isObject (val) {\n  return typeof val === 'object' && val !== null && !(val instanceof Array)\n}\n\nmodule.exports = SharedbPlugin\n","'use strict'\n\nconst Plugin = require('../../dd-trace/src/plugins/plugin')\nconst { storage } = require('../../datadog-core')\nconst analyticsSampler = require('../../dd-trace/src/analytics_sampler')\n\nclass TediousPlugin extends Plugin {\n  static get name () {\n    return 'tedious'\n  }\n\n  constructor (...args) {\n    super(...args)\n\n    this.addSub(`apm:tedious:request:start`, ({ queryOrProcedure, connectionConfig }) => {\n      const store = storage.getStore()\n      const childOf = store ? store.span : store\n      const span = this.tracer.startSpan('tedious.request', {\n        childOf,\n        tags: {\n          'span.kind': 'client',\n          'db.type': 'mssql',\n          'span.type': 'sql',\n          'component': 'tedious',\n          'service.name': this.config.service || `${this.tracer._service}-mssql`,\n          'resource.name': queryOrProcedure,\n          'out.host': connectionConfig.server,\n          'out.port': connectionConfig.options.port,\n          'db.user': connectionConfig.userName || connectionConfig.authentication.options.userName,\n          'db.name': connectionConfig.options.database,\n          'db.instance': connectionConfig.options.instanceName\n        }\n      })\n      analyticsSampler.sample(span, this.config.measured)\n      this.enter(span, store)\n    })\n\n    this.addSub(`apm:tedious:request:end`, () => {\n      this.exit()\n    })\n\n    this.addSub(`apm:tedious:request:error`, err => {\n      const span = storage.getStore().span\n      span.setTag('error', err)\n    })\n\n    this.addSub(`apm:tedious:request:async-end`, () => {\n      const span = storage.getStore().span\n      span.finish()\n    })\n  }\n}\n\nmodule.exports = TediousPlugin\n","'use strict'\n\nconst LogPlugin = require('../../dd-trace/src/plugins/log_plugin')\n\nclass WinstonPlugin extends LogPlugin {\n  static get name () {\n    return 'winston'\n  }\n}\nmodule.exports = WinstonPlugin\n","'use strict'\n\nmodule.exports = require('./src/shimmer')\n","'use strict'\n\n// Use a weak map to avoid polluting the wrapped function/method.\nconst unwrappers = new WeakMap()\n\nfunction copyProperties (original, wrapped) {\n  Object.setPrototypeOf(wrapped, original)\n\n  const props = Object.getOwnPropertyDescriptors(original)\n  const keys = Reflect.ownKeys(props)\n\n  for (const key of keys) {\n    Object.defineProperty(wrapped, key, props[key])\n  }\n}\n\nfunction wrapFn (original, delegate) {\n  assertFunction(delegate)\n  assertNotClass(original) // TODO: support constructors of native classes\n\n  const shim = function shim () {\n    return delegate.apply(this, arguments)\n  }\n\n  unwrappers.set(shim, () => {\n    delegate = original\n  })\n\n  copyProperties(original, shim)\n\n  return shim\n}\n\nfunction wrapMethod (target, name, wrapper) {\n  assertMethod(target, name)\n  assertNotClass(target[name]) // TODO: support constructors of native classes\n  assertFunction(wrapper)\n\n  const original = target[name]\n  const wrapped = wrapper(original)\n  const descriptor = Object.getOwnPropertyDescriptor(target, name)\n\n  if (descriptor) {\n    unwrappers.set(wrapped, () => Object.defineProperty(target, name, descriptor))\n  } else { // no descriptor means original was on the prototype\n    unwrappers.set(wrapped, () => delete target[name])\n  }\n\n  Object.defineProperty(target, name, {\n    configurable: true,\n    writable: true,\n    enumerable: false,\n    ...descriptor,\n    value: wrapped\n  })\n\n  copyProperties(original, wrapped)\n\n  return target\n}\n\nfunction wrap (target, name, wrapper) {\n  return typeof name === 'function'\n    ? wrapFn(target, name)\n    : wrapMethod(target, name, wrapper)\n}\n\nfunction unwrap (target, name) {\n  if (!target) return target // no target to unwrap\n\n  const unwrapper = unwrappers.get(name ? target[name] : target)\n\n  if (!unwrapper) return target // target is already unwrapped or isn't wrapped\n\n  unwrapper()\n\n  return target\n}\n\nfunction massWrap (targets, names, wrapper) {\n  targets = toArray(targets)\n  names = toArray(names)\n\n  for (const target of targets) {\n    for (const name of names) {\n      wrap(target, name, wrapper)\n    }\n  }\n}\n\nfunction massUnwrap (targets, names) {\n  targets = toArray(targets)\n  names = toArray(names)\n\n  for (const target of targets) {\n    for (const name of names) {\n      unwrap(target, name)\n    }\n  }\n}\n\nfunction toArray (maybeArray) {\n  return Array.isArray(maybeArray) ? maybeArray : [maybeArray]\n}\n\nfunction assertMethod (target, name) {\n  if (!target) {\n    throw new Error('No target object provided.')\n  }\n\n  if (typeof target !== 'object' && typeof target !== 'function') {\n    throw new Error('Invalid target.')\n  }\n\n  if (!target[name]) {\n    throw new Error(`No original method ${name}.`)\n  }\n\n  if (typeof target[name] !== 'function') {\n    throw new Error(`Original method ${name} is not a function.`)\n  }\n}\n\nfunction assertFunction (target) {\n  if (!target) {\n    throw new Error('No function provided.')\n  }\n\n  if (typeof target !== 'function') {\n    throw new Error('Target is not a function.')\n  }\n}\n\nfunction assertNotClass (target) {\n  if (Function.prototype.toString.call(target).startsWith('class')) {\n    throw new Error('Target is a native class constructor and cannot be wrapped.')\n  }\n}\n\nmodule.exports = {\n  wrap,\n  massWrap,\n  unwrap,\n  massUnwrap\n}\n","'use strict'\n\nif (!global._ddtrace) {\n  const TracerProxy = require('./src/proxy')\n\n  Object.defineProperty(global, '_ddtrace', {\n    value: new TracerProxy(),\n    enumerable: false,\n    configurable: true,\n    writable: true\n  })\n\n  global._ddtrace.default = global._ddtrace\n  global._ddtrace.tracer = global._ddtrace\n}\n\nmodule.exports = global._ddtrace\n","module.exports = '2.5.0'\n","'use strict'\n\nconst { MEASURED } = require('../../../ext/tags')\n\nmodule.exports = {\n  sample (span, measured, measuredByDefault) {\n    if (typeof measured === 'object') {\n      this.sample(span, measured[span.context()._name], measuredByDefault)\n    } else if (measured !== undefined) {\n      span.setTag(MEASURED, !!measured)\n    } else if (measuredByDefault) {\n      span.setTag(MEASURED, true)\n    }\n  }\n}\n","'use strict'\n\nmodule.exports = {\n  HTTP_INCOMING_BODY: 'server.request.body',\n  HTTP_INCOMING_QUERY: 'server.request.query',\n  HTTP_INCOMING_HEADERS: 'server.request.headers.no_cookies',\n  // TODO: 'server.request.trailers',\n  HTTP_INCOMING_URL: 'server.request.uri.raw',\n  HTTP_INCOMING_METHOD: 'server.request.method',\n  HTTP_INCOMING_ENDPOINT: 'server.request.framework_endpoint',\n  HTTP_INCOMING_PARAMS: 'server.request.path_params',\n  HTTP_INCOMING_COOKIES: 'server.request.cookies',\n  HTTP_INCOMING_RESPONSE_CODE: 'server.response.status',\n  HTTP_INCOMING_RESPONSE_HEADERS: 'server.response.headers.no_cookies',\n  // TODO: 'server.response.trailers',\n  HTTP_INCOMING_REMOTE_IP: 'server.request.client_ip',\n  HTTP_INCOMING_REMOTE_PORT: 'server.request.client_port'\n}\n","'use strict'\n\nconst log = require('../../log')\nconst addresses = require('../addresses')\nconst Gateway = require('../gateway/engine')\nconst Reporter = require('../reporter')\n\nconst validAddressSet = new Set(Object.values(addresses))\n\nconst DEFAULT_MAX_BUDGET = 5e3 // s\n\n// TODO: put reusable code in a base class\nclass WAFCallback {\n  static loadDDWAF (rules) {\n    try {\n      // require in `try/catch` because this can throw at require time\n      const { DDWAF } = require('@datadog/native-appsec')\n\n      return new DDWAF(rules)\n    } catch (err) {\n      log.error('AppSec could not load native package. In-app WAF features will not be available.')\n\n      throw err\n    }\n  }\n\n  constructor (rules) {\n    this.ddwaf = WAFCallback.loadDDWAF(rules)\n    this.wafContextCache = new WeakMap()\n\n    // closures are faster than binds\n    const self = this\n    const method = (params, store) => {\n      return self.action(params, store)\n    }\n\n    // might be its own class with more info later\n    const callback = { method }\n\n    const subscribedAddresses = new Set()\n\n    for (const rule of rules.rules) {\n      for (const condition of rule.conditions) {\n        for (const input of condition.parameters.inputs) {\n          const address = input.address.split(':', 2)[0]\n\n          if (!validAddressSet.has(address) || subscribedAddresses.has(address)) continue\n\n          subscribedAddresses.add(address)\n\n          Gateway.manager.addSubscription({ addresses: [ address ], callback })\n        }\n      }\n    }\n  }\n\n  action (params, store) {\n    let wafContext\n\n    if (store) {\n      const key = store.get('context')\n\n      if (key) {\n        if (this.wafContextCache.has(key)) {\n          wafContext = this.wafContextCache.get(key)\n        } else {\n          wafContext = this.ddwaf.createContext()\n          this.wafContextCache.set(key, wafContext)\n        }\n      }\n    }\n\n    if (!wafContext || wafContext.disposed) {\n      wafContext = this.ddwaf.createContext()\n    }\n\n    // cast status code to string\n    if (params[addresses.HTTP_INCOMING_RESPONSE_CODE]) {\n      params[addresses.HTTP_INCOMING_RESPONSE_CODE] = params[addresses.HTTP_INCOMING_RESPONSE_CODE] + ''\n    }\n\n    try {\n      // TODO: possible optimizaion: only send params that haven't already been sent to this wafContext\n      const result = wafContext.run(params, DEFAULT_MAX_BUDGET)\n\n      return this.applyResult(result, store)\n    } catch (err) {\n      log.error('Error while running the AppSec WAF')\n      log.error(err)\n    } finally {\n      wafContext.dispose()\n    }\n  }\n\n  applyResult (result, store) {\n    if (result.data && result.data !== '[]') {\n      Reporter.reportAttack(result.data, store)\n    }\n\n    // TODO: use these values later for budget management\n    // result.perfData\n    // result.perfTotalRuntime\n  }\n\n  clear () {\n    this.ddwaf.dispose()\n\n    this.wafContextCache = new WeakMap()\n\n    Gateway.manager.clear()\n  }\n}\n\nmodule.exports = WAFCallback\n","'use strict'\n\n// lazy loading\n// TODO: cache the returned value\nmodule.exports = {\n  get DDWAF () { return require('./ddwaf') }\n}\n","'use strict'\n\n// TODO: use datadog-core storage instead\nconst { AsyncLocalStorage } = require('async_hooks')\n\nmodule.exports = new AsyncLocalStorage()\n","'use strict'\n\nconst dc = require('diagnostics_channel')\n\n// TODO: use TBD naming convention\n//       or directly use http plugin's channels\n//       when it gets converted to new plugin system\nmodule.exports = {\n  incomingHttpRequestStart: dc.channel('dd-trace:incomingHttpRequestStart'),\n  incomingHttpRequestEnd: dc.channel('dd-trace:incomingHttpRequestEnd')\n}\n","'use strict'\n\nconst Runner = require('./runner')\n\nconst MAX_CONTEXT_SIZE = 1024\n\nclass SubscriptionManager {\n  constructor () {\n    this.addressToSubscriptions = new Map()\n    this.addresses = new Set()\n    this.subscriptions = new Set()\n  }\n\n  clear () {\n    this.addressToSubscriptions = new Map()\n    this.addresses = new Set()\n    this.subscriptions = new Set()\n  }\n\n  addSubscription (subscription) {\n    if (!subscription.addresses.length || this.subscriptions.has(subscription)) return\n\n    for (let i = 0; i < subscription.addresses.length; ++i) {\n      const address = subscription.addresses[i]\n\n      this.addresses.add(address)\n\n      const list = this.addressToSubscriptions.get(address)\n\n      if (list === undefined) {\n        this.addressToSubscriptions.set(address, [ subscription ])\n      } else {\n        list.push(subscription)\n      }\n    }\n\n    this.subscriptions.add(subscription)\n  }\n\n  matchSubscriptions (newAddresses, allAddresses) {\n    const addresses = new Set()\n    const subscriptions = new Set()\n    const knownSubscriptions = new Set()\n\n    // TODO: possible optimization: collect matchedSubscriptions on the fly in Context#setValue\n    newAddresses.forEach((newAddress) => {\n      const matchedSubscriptions = this.addressToSubscriptions.get(newAddress)\n\n      if (matchedSubscriptions === undefined) return\n\n      for (let j = 0; j < matchedSubscriptions.length; ++j) {\n        const subscription = matchedSubscriptions[j]\n\n        if (knownSubscriptions.has(subscription) === true) continue\n        knownSubscriptions.add(subscription)\n\n        const isFulfilled = subscription.addresses.every(allAddresses.has, allAddresses)\n\n        if (isFulfilled === true) {\n          for (let k = 0; k < subscription.addresses.length; ++k) {\n            addresses.add(subscription.addresses[k])\n          }\n\n          subscriptions.add(subscription)\n        }\n      }\n    })\n\n    return { addresses, subscriptions }\n  }\n\n  dispatch (newAddresses, allAddresses, context) {\n    const matches = this.matchSubscriptions(newAddresses, allAddresses)\n\n    // TODO: possible optimization\n    // check if matches.subscriptions is empty here instead of in runner.js\n\n    const params = {}\n\n    matches.addresses.forEach((address) => {\n      params[address] = context.resolve(address)\n    })\n\n    return Runner.runSubscriptions(matches.subscriptions, params)\n  }\n}\n\nclass Context {\n  static setManager (manager) {\n    this.manager = manager\n  }\n\n  constructor () {\n    // TODO: this probably don't need to be a Map()\n    this.store = new Map()\n    this.allAddresses = new Set()\n    this.newAddresses = new Set()\n  }\n\n  clear () {\n    this.store = new Map()\n    this.allAddresses = new Set()\n    this.newAddresses = new Set()\n  }\n\n  setValue (address, value) {\n    if (this.allAddresses.size >= MAX_CONTEXT_SIZE) return this\n\n    // cannot optimize for objects because they're pointers\n    if (typeof value !== 'object') {\n      const oldValue = this.store.get(address)\n      if (oldValue === value) return this\n    }\n\n    this.store.set(address, value)\n    this.allAddresses.add(address)\n    this.newAddresses.add(address)\n\n    return this\n  }\n\n  dispatch () {\n    if (this.newAddresses.size === 0) return []\n\n    const result = Context.manager.dispatch(this.newAddresses, this.allAddresses, this)\n\n    this.newAddresses.clear()\n\n    return result\n  }\n\n  resolve (address) {\n    return this.store.get(address)\n  }\n}\n\nmodule.exports = {\n  SubscriptionManager,\n  Context\n}\n","'use strict'\n\nconst { SubscriptionManager, Context } = require('./engine')\nconst als = require('../als')\n\nconst manager = new SubscriptionManager()\nContext.setManager(manager)\n\nfunction startContext () {\n  const store = new Map()\n\n  store.set('context', new Context())\n\n  als.enterWith(store)\n\n  return store\n}\n\nfunction getContext () {\n  const store = als.getStore()\n\n  return store && store.get('context')\n}\n\nfunction propagate (data, context = getContext()) {\n  if (!context) return\n\n  const keys = Object.keys(data)\n\n  for (let i = 0; i < keys.length; ++i) {\n    const key = keys[i]\n\n    if (manager.addresses.has(key)) {\n      context.setValue(key, data[key])\n    }\n  }\n\n  context.dispatch()\n}\n\nmodule.exports = {\n  manager,\n  startContext,\n  getContext,\n  propagate\n}\n","'use strict'\n\nconst als = require('../als')\n\nlet lock = false // lock to prevent recursive calls to runSubscriptions\n\nfunction runSubscriptions (subscriptions, params) {\n  const results = []\n\n  if (lock || !subscriptions.size) return results\n  lock = true\n\n  const store = als.getStore()\n\n  // TODO: possible optimization\n  // can we deduplicate those before ?\n  const executedCallbacks = new Set()\n\n  for (const subscription of subscriptions) {\n    if (executedCallbacks.has(subscription.callback)) continue\n    executedCallbacks.add(subscription.callback)\n\n    let result\n\n    try {\n      result = subscription.callback.method(params, store)\n    } catch (err) {\n      // TODO: log ?\n      result = {}\n    }\n\n    results.push(result)\n  }\n\n  lock = false\n\n  return results\n}\n\nmodule.exports = {\n  runSubscriptions\n}\n","'use strict'\n\nconst fs = require('fs')\nconst log = require('../log')\nconst RuleManager = require('./rule_manager')\nconst { incomingHttpRequestStart, incomingHttpRequestEnd } = require('./gateway/channels')\nconst Gateway = require('./gateway/engine')\nconst addresses = require('./addresses')\nconst Reporter = require('./reporter')\nconst web = require('../plugins/util/web')\n\nfunction enable (config) {\n  try {\n    // TODO: enable dc_blocking: config.appsec.blocking === true\n\n    let rules = fs.readFileSync(config.appsec.rules)\n    rules = JSON.parse(rules)\n\n    RuleManager.applyRules(rules)\n  } catch (err) {\n    log.error('Unable to start AppSec')\n    log.error(err)\n\n    // abort AppSec start\n    RuleManager.clearAllRules()\n    return\n  }\n\n  Reporter.setRateLimit(config.appsec.rateLimit)\n\n  incomingHttpRequestStart.subscribe(incomingHttpStartTranslator)\n  incomingHttpRequestEnd.subscribe(incomingHttpEndTranslator)\n\n  // add fields needed for HTTP context reporting\n  Gateway.manager.addresses.add(addresses.HTTP_INCOMING_HEADERS)\n  Gateway.manager.addresses.add(addresses.HTTP_INCOMING_ENDPOINT)\n  Gateway.manager.addresses.add(addresses.HTTP_INCOMING_RESPONSE_HEADERS)\n  Gateway.manager.addresses.add(addresses.HTTP_INCOMING_REMOTE_IP)\n}\n\nfunction incomingHttpStartTranslator (data) {\n  // TODO: get span from datadog-core storage instead\n  const topSpan = web.root(data.req)\n  if (topSpan) {\n    topSpan.addTags({\n      '_dd.appsec.enabled': 1,\n      '_dd.runtime_family': 'nodejs'\n    })\n  }\n\n  const store = Gateway.startContext()\n\n  store.set('req', data.req)\n  store.set('res', data.res)\n}\n\nfunction incomingHttpEndTranslator (data) {\n  const context = Gateway.getContext()\n\n  if (!context) return\n\n  const requestHeaders = Object.assign({}, data.req.headers)\n  delete requestHeaders.cookie\n\n  // TODO: this doesn't support headers sent with res.writeHead()\n  const responseHeaders = Object.assign({}, data.res.getHeaders())\n  delete responseHeaders['set-cookie']\n\n  const payload = {\n    [addresses.HTTP_INCOMING_URL]: data.req.url,\n    [addresses.HTTP_INCOMING_HEADERS]: requestHeaders,\n    [addresses.HTTP_INCOMING_METHOD]: data.req.method,\n    [addresses.HTTP_INCOMING_REMOTE_IP]: data.req.socket.remoteAddress,\n    [addresses.HTTP_INCOMING_REMOTE_PORT]: data.req.socket.remotePort,\n    [addresses.HTTP_INCOMING_RESPONSE_CODE]: data.res.statusCode,\n    [addresses.HTTP_INCOMING_RESPONSE_HEADERS]: responseHeaders\n  }\n\n  // TODO: temporary express instrumentation, will use express plugin later\n  if (data.req.body !== undefined && data.req.body !== null) {\n    payload[addresses.HTTP_INCOMING_BODY] = data.req.body\n  }\n\n  if (data.req.query && typeof data.req.query === 'object') {\n    payload[addresses.HTTP_INCOMING_QUERY] = data.req.query\n  }\n\n  if (data.req.route && typeof data.req.route.path === 'string') {\n    payload[addresses.HTTP_INCOMING_ENDPOINT] = data.req.route.path\n  }\n\n  if (data.req.params && typeof data.req.params === 'object') {\n    payload[addresses.HTTP_INCOMING_PARAMS] = data.req.params\n  }\n\n  if (data.req.cookies && typeof data.req.cookies === 'object') {\n    payload[addresses.HTTP_INCOMING_COOKIES] = data.req.cookies\n  }\n\n  Gateway.propagate(payload, context)\n\n  Reporter.finishAttacks(data.req, context)\n}\n\nfunction disable () {\n  RuleManager.clearAllRules()\n\n  // Channel#unsubscribe() is undefined for non active channels\n  if (incomingHttpRequestStart.hasSubscribers) incomingHttpRequestStart.unsubscribe(incomingHttpStartTranslator)\n  if (incomingHttpRequestEnd.hasSubscribers) incomingHttpRequestEnd.unsubscribe(incomingHttpEndTranslator)\n}\n\nmodule.exports = {\n  enable,\n  disable,\n  incomingHttpStartTranslator,\n  incomingHttpEndTranslator\n}\n","'use strict'\n\nconst addresses = require('./addresses')\nconst Limiter = require('../rate_limiter')\nconst web = require('../plugins/util/web')\n\n// default limiter, configurable with setRateLimit()\nlet limiter = new Limiter(100)\n\nconst REQUEST_HEADERS_PASSLIST = [\n  'accept',\n  'accept-encoding',\n  'accept-language',\n  'content-encoding',\n  'content-language',\n  'content-length',\n  'content-type',\n  'forwarded',\n  'forwarded-for',\n  'host',\n  'true-client-ip',\n  'user-agent',\n  'via',\n  'x-client-ip',\n  'x-cluster-client-ip',\n  'x-forwarded',\n  'x-forwarded-for',\n  'x-real-ip'\n]\n\nconst RESPONSE_HEADERS_PASSLIST = [\n  'content-encoding',\n  'content-language',\n  'content-length',\n  'content-type'\n]\n\nfunction resolveHTTPRequest (context) {\n  if (!context) return {}\n\n  const headers = context.resolve(addresses.HTTP_INCOMING_HEADERS)\n\n  return {\n    remote_ip: context.resolve(addresses.HTTP_INCOMING_REMOTE_IP),\n    headers: filterHeaders(headers, REQUEST_HEADERS_PASSLIST, 'http.request.headers.')\n  }\n}\n\nfunction resolveHTTPResponse (context) {\n  if (!context) return {}\n\n  const headers = context.resolve(addresses.HTTP_INCOMING_RESPONSE_HEADERS)\n\n  return {\n    endpoint: context.resolve(addresses.HTTP_INCOMING_ENDPOINT),\n    headers: filterHeaders(headers, RESPONSE_HEADERS_PASSLIST, 'http.response.headers.')\n  }\n}\n\nfunction filterHeaders (headers, passlist, prefix) {\n  const result = {}\n\n  if (!headers) return result\n\n  for (let i = 0; i < passlist.length; ++i) {\n    const headerName = passlist[i]\n\n    if (headers[headerName]) {\n      result[`${prefix}${formatHeaderName(headerName)}`] = headers[headerName] + ''\n    }\n  }\n\n  return result\n}\n\n// TODO: this can be precomputed at start time\nfunction formatHeaderName (name) {\n  return name\n    .trim()\n    .slice(0, 200)\n    .replace(/[^a-zA-Z0-9_\\-:/]/g, '_')\n    .toLowerCase()\n}\n\nfunction reportAttack (attackData, store) {\n  const req = store && store.get('req')\n  const topSpan = web.root(req)\n  if (!topSpan) return false\n\n  const currentTags = topSpan.context()._tags\n\n  const newTags = {\n    'appsec.event': 'true'\n  }\n\n  if (limiter.isAllowed()) {\n    newTags['manual.keep'] = 'true' // TODO: figure out how to keep appsec traces with sampling revamp\n  }\n\n  // TODO: maybe add this to format.js later (to take decision as late as possible)\n  if (!currentTags['_dd.origin']) {\n    newTags['_dd.origin'] = 'appsec'\n  }\n\n  const currentJson = currentTags['_dd.appsec.json']\n\n  // merge JSON arrays without parsing them\n  if (currentJson) {\n    newTags['_dd.appsec.json'] = currentJson.slice(0, -2) + ',' + attackData.slice(1, -1) + currentJson.slice(-2)\n  } else {\n    newTags['_dd.appsec.json'] = '{\"triggers\":' + attackData + '}'\n  }\n\n  const context = store.get('context')\n\n  if (context) {\n    const resolvedRequest = resolveHTTPRequest(context)\n\n    Object.assign(newTags, resolvedRequest.headers)\n\n    const ua = resolvedRequest.headers['http.request.headers.user-agent']\n    if (ua) {\n      newTags['http.useragent'] = ua\n    }\n\n    newTags['network.client.ip'] = resolvedRequest.remote_ip\n  }\n\n  topSpan.addTags(newTags)\n}\n\nfunction finishAttacks (req, context) {\n  const topSpan = web.root(req)\n  if (!topSpan || !context) return false\n\n  const resolvedResponse = resolveHTTPResponse(context)\n\n  const newTags = resolvedResponse.headers\n\n  if (resolvedResponse.endpoint) {\n    newTags['http.endpoint'] = resolvedResponse.endpoint\n  }\n\n  topSpan.addTags(newTags)\n}\n\nfunction setRateLimit (rateLimit) {\n  limiter = new Limiter(rateLimit)\n}\n\nmodule.exports = {\n  resolveHTTPRequest,\n  resolveHTTPResponse,\n  filterHeaders,\n  formatHeaderName,\n  reportAttack,\n  finishAttacks,\n  setRateLimit\n}\n","'use strict'\n\nconst callbacks = require('./callbacks')\n\nconst appliedCallbacks = new Map()\n\nfunction applyRules (rules) {\n  if (appliedCallbacks.has(rules)) return\n\n  // for now there is only WAF\n  const callback = new callbacks.DDWAF(rules)\n\n  appliedCallbacks.set(rules, callback)\n}\n\nfunction clearAllRules () {\n  for (const [key, callback] of appliedCallbacks) {\n    callback.clear()\n\n    appliedCallbacks.delete(key)\n  }\n}\n\nmodule.exports = {\n  applyRules,\n  clearAllRules\n}\n","'use strict'\n\nconst URL = require('url').URL\nconst Writer = require('./writer')\nconst Scheduler = require('../../../exporters/scheduler')\n\nclass AgentlessCiVisibilityExporter {\n  constructor (config) {\n    const { flushInterval, tags, site, url } = config\n    this._url = url || new URL(`https://citestcycle-intake.${site}`)\n    this._writer = new Writer({ url: this._url, tags })\n\n    if (flushInterval > 0) {\n      this._scheduler = new Scheduler(() => this._writer.flush(), flushInterval)\n    }\n    this._scheduler && this._scheduler.start()\n  }\n\n  export (trace) {\n    this._writer.append(trace)\n\n    if (!this._scheduler) {\n      this._writer.flush()\n    }\n  }\n\n  flush () {\n    this._writer.flush()\n  }\n}\n\nmodule.exports = AgentlessCiVisibilityExporter\n","'use strict'\nconst request = require('../../../exporters/common/request')\nconst log = require('../../../log')\n\nconst { AgentlessCiVisibilityEncoder } = require('../../../encode/agentless-ci-visibility')\nconst BaseWriter = require('../../../exporters/common/writer')\n\nclass Writer extends BaseWriter {\n  constructor ({ url, tags }) {\n    super(...arguments)\n    const { 'runtime-id': runtimeId, env, service } = tags\n    this._url = url\n    this._encoder = new AgentlessCiVisibilityEncoder({ runtimeId, env, service })\n  }\n\n  _sendPayload (data, _, done) {\n    makeRequest(data, this._url, (err, res) => {\n      if (err) {\n        log.error(err)\n        done()\n        return\n      }\n      log.debug(`Response from the intake: ${res}`)\n      done()\n    })\n  }\n}\n\nfunction makeRequest (data, url, cb) {\n  const options = {\n    path: '/api/v2/citestcycle',\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/msgpack',\n      'dd-api-key': process.env.DATADOG_API_KEY || process.env.DD_API_KEY\n    },\n    timeout: 15000\n  }\n\n  options.protocol = url.protocol\n  options.hostname = url.hostname\n  options.port = url.port\n\n  log.debug(() => `Request to the intake: ${JSON.stringify(options)}`)\n\n  request(data, options, false, (err, res) => {\n    cb(err, res)\n  })\n}\n\nmodule.exports = Writer\n","'use strict'\n\nconst fs = require('fs')\nconst os = require('os')\nconst URL = require('url').URL\nconst path = require('path')\nconst pkg = require('./pkg')\nconst coalesce = require('koalas')\nconst tagger = require('./tagger')\nconst { isTrue, isFalse } = require('./util')\nconst uuid = require('crypto-randomuuid')\n\nconst fromEntries = Object.fromEntries || (entries =>\n  entries.reduce((obj, [k, v]) => Object.assign(obj, { [k]: v }), {}))\n\nclass Config {\n  constructor (options) {\n    options = options || {}\n\n    this.tags = {}\n\n    tagger.add(this.tags, process.env.DD_TAGS)\n    tagger.add(this.tags, process.env.DD_TRACE_TAGS)\n    tagger.add(this.tags, process.env.DD_TRACE_GLOBAL_TAGS)\n    tagger.add(this.tags, options.tags)\n\n    const DD_TRACING_ENABLED = coalesce(\n      process.env.DD_TRACING_ENABLED,\n      true\n    )\n    const DD_PROFILING_ENABLED = coalesce(\n      options.profiling, // TODO: remove when enabled by default\n      process.env.DD_EXPERIMENTAL_PROFILING_ENABLED,\n      process.env.DD_PROFILING_ENABLED,\n      false\n    )\n    const DD_PROFILING_EXPORTERS = coalesce(\n      process.env.DD_PROFILING_EXPORTERS,\n      'agent'\n    )\n    const DD_PROFILING_SOURCE_MAP = process.env.DD_PROFILING_SOURCE_MAP\n    const DD_LOGS_INJECTION = coalesce(\n      options.logInjection,\n      process.env.DD_LOGS_INJECTION,\n      false\n    )\n    const DD_RUNTIME_METRICS_ENABLED = coalesce(\n      options.runtimeMetrics, // TODO: remove when enabled by default\n      process.env.DD_RUNTIME_METRICS_ENABLED,\n      false\n    )\n    const DD_AGENT_HOST = coalesce(\n      options.hostname,\n      process.env.DD_AGENT_HOST,\n      process.env.DD_TRACE_AGENT_HOSTNAME,\n      '127.0.0.1'\n    )\n    const DD_TRACE_AGENT_PORT = coalesce(\n      options.port,\n      process.env.DD_TRACE_AGENT_PORT,\n      '8126'\n    )\n    const DD_TRACE_AGENT_URL = coalesce(\n      options.url,\n      process.env.DD_TRACE_AGENT_URL,\n      process.env.DD_TRACE_URL,\n      null\n    )\n    const DD_CIVISIBILITY_AGENTLESS_URL = process.env.DD_CIVISIBILITY_AGENTLESS_URL\n    const DD_SERVICE = options.service ||\n      process.env.DD_SERVICE ||\n      process.env.DD_SERVICE_NAME ||\n      this.tags.service ||\n      process.env.AWS_LAMBDA_FUNCTION_NAME ||\n      pkg.name ||\n      'node'\n    const DD_SERVICE_MAPPING = process.env.DD_SERVICE_MAPPING || ''\n    const DD_ENV = coalesce(\n      options.env,\n      process.env.DD_ENV,\n      this.tags.env\n    )\n    const DD_VERSION = coalesce(\n      options.version,\n      process.env.DD_VERSION,\n      this.tags.version,\n      pkg.version\n    )\n    const DD_TRACE_STARTUP_LOGS = coalesce(\n      options.startupLogs,\n      process.env.DD_TRACE_STARTUP_LOGS,\n      false\n    )\n    const DD_TRACE_TELEMETRY_ENABLED = coalesce(\n      process.env.DD_TRACE_TELEMETRY_ENABLED,\n      true\n    )\n    const DD_TRACE_DEBUG = coalesce(\n      process.env.DD_TRACE_DEBUG,\n      false\n    )\n    const DD_TRACE_AGENT_PROTOCOL_VERSION = coalesce(\n      options.protocolVersion,\n      process.env.DD_TRACE_AGENT_PROTOCOL_VERSION,\n      '0.4'\n    )\n    const DD_TRACE_PARTIAL_FLUSH_MIN_SPANS = coalesce(\n      parseInt(options.flushMinSpans),\n      parseInt(process.env.DD_TRACE_PARTIAL_FLUSH_MIN_SPANS),\n      1000\n    )\n    const DD_TRACE_B3_ENABLED = coalesce(\n      options.experimental && options.experimental.b3,\n      process.env.DD_TRACE_EXPERIMENTAL_B3_ENABLED,\n      false\n    )\n    const DD_TRACE_TRACEPARENT_ENABLED = coalesce(\n      options.experimental && options.experimental.traceparent,\n      process.env.DD_TRACE_EXPERIMENTAL_TRACEPARENT_ENABLED,\n      false\n    )\n    const DD_TRACE_RUNTIME_ID_ENABLED = coalesce(\n      options.experimental && options.experimental.runtimeId,\n      process.env.DD_TRACE_EXPERIMENTAL_RUNTIME_ID_ENABLED,\n      false\n    )\n    const DD_TRACE_EXPORTER = coalesce(\n      options.experimental && options.experimental.exporter,\n      process.env.DD_TRACE_EXPERIMENTAL_EXPORTER\n    )\n    const DD_TRACE_GET_RUM_DATA_ENABLED = coalesce(\n      options.experimental && options.experimental.enableGetRumData,\n      process.env.DD_TRACE_EXPERIMENTAL_GET_RUM_DATA_ENABLED,\n      false\n    )\n\n    let appsec = options.appsec || (options.experimental && options.experimental.appsec)\n\n    const DD_APPSEC_ENABLED = coalesce(\n      appsec && (appsec === true || appsec.enabled === true), // TODO: remove when enabled by default\n      process.env.DD_APPSEC_ENABLED,\n      false\n    )\n\n    appsec = appsec || {}\n\n    const DD_APPSEC_RULES = coalesce(\n      appsec.rules,\n      process.env.DD_APPSEC_RULES,\n      path.join(__dirname, 'appsec', 'recommended.json')\n    )\n    const DD_APPSEC_TRACE_RATE_LIMIT = coalesce(\n      appsec.rateLimit,\n      process.env.DD_APPSEC_TRACE_RATE_LIMIT,\n      100\n    )\n\n    const sampler = (options.experimental && options.experimental.sampler) || {}\n    const ingestion = options.ingestion || {}\n    const dogstatsd = coalesce(options.dogstatsd, {})\n\n    Object.assign(sampler, {\n      sampleRate: coalesce(\n        options.sampleRate,\n        ingestion.sampleRate,\n        sampler.sampleRate,\n        process.env.DD_TRACE_SAMPLE_RATE\n      ),\n      rateLimit: coalesce(ingestion.rateLimit, sampler.rateLimit, process.env.DD_TRACE_RATE_LIMIT)\n    })\n\n    const inAWSLambda = process.env.AWS_LAMBDA_FUNCTION_NAME !== undefined\n    const defaultFlushInterval = inAWSLambda ? 0 : 2000\n\n    this.tracing = !isFalse(DD_TRACING_ENABLED)\n    this.debug = isTrue(DD_TRACE_DEBUG)\n    this.logInjection = isTrue(DD_LOGS_INJECTION)\n    this.env = DD_ENV\n    this.url = DD_CIVISIBILITY_AGENTLESS_URL ? new URL(DD_CIVISIBILITY_AGENTLESS_URL)\n      : getAgentUrl(DD_TRACE_AGENT_URL, options)\n    this.site = coalesce(options.site, process.env.DD_SITE, 'datadoghq.com')\n    this.hostname = DD_AGENT_HOST || (this.url && this.url.hostname)\n    this.port = String(DD_TRACE_AGENT_PORT || (this.url && this.url.port))\n    this.flushInterval = coalesce(parseInt(options.flushInterval, 10), defaultFlushInterval)\n    this.flushMinSpans = DD_TRACE_PARTIAL_FLUSH_MIN_SPANS\n    this.sampleRate = coalesce(Math.min(Math.max(sampler.sampleRate, 0), 1), 1)\n    this.logger = options.logger\n    this.plugins = !!coalesce(options.plugins, true)\n    this.service = DD_SERVICE\n    this.serviceMapping = DD_SERVICE_MAPPING.length ? fromEntries(\n      DD_SERVICE_MAPPING.split(',').map(x => x.trim().split(':'))\n    ) : {}\n    this.version = DD_VERSION\n    this.dogstatsd = {\n      hostname: coalesce(dogstatsd.hostname, process.env.DD_DOGSTATSD_HOSTNAME, this.hostname),\n      port: String(coalesce(dogstatsd.port, process.env.DD_DOGSTATSD_PORT, 8125))\n    }\n    this.runtimeMetrics = isTrue(DD_RUNTIME_METRICS_ENABLED)\n    this.experimental = {\n      b3: isTrue(DD_TRACE_B3_ENABLED),\n      traceparent: isTrue(DD_TRACE_TRACEPARENT_ENABLED),\n      runtimeId: isTrue(DD_TRACE_RUNTIME_ID_ENABLED),\n      exporter: DD_TRACE_EXPORTER,\n      enableGetRumData: isTrue(DD_TRACE_GET_RUM_DATA_ENABLED),\n      sampler\n    }\n    this.reportHostname = isTrue(coalesce(options.reportHostname, process.env.DD_TRACE_REPORT_HOSTNAME, false))\n    this.scope = process.env.DD_TRACE_SCOPE\n    this.logLevel = coalesce(\n      options.logLevel,\n      process.env.DD_TRACE_LOG_LEVEL,\n      'debug'\n    )\n    this.profiling = {\n      enabled: isTrue(DD_PROFILING_ENABLED),\n      sourceMap: !isFalse(DD_PROFILING_SOURCE_MAP),\n      exporters: DD_PROFILING_EXPORTERS\n    }\n    this.lookup = options.lookup\n    this.startupLogs = isTrue(DD_TRACE_STARTUP_LOGS)\n    this.telemetryEnabled = isTrue(DD_TRACE_TELEMETRY_ENABLED)\n    this.protocolVersion = DD_TRACE_AGENT_PROTOCOL_VERSION\n    this.appsec = {\n      enabled: isTrue(DD_APPSEC_ENABLED),\n      rules: DD_APPSEC_RULES,\n      rateLimit: DD_APPSEC_TRACE_RATE_LIMIT\n    }\n\n    tagger.add(this.tags, {\n      service: this.service,\n      env: this.env,\n      version: this.version,\n      'runtime-id': uuid()\n    })\n  }\n}\n\nfunction getAgentUrl (url, options) {\n  if (url) return new URL(url)\n\n  if (os.type() === 'Windows_NT') return\n\n  if (\n    !options.hostname &&\n    !options.port &&\n    !process.env.DD_AGENT_HOST &&\n    !process.env.DD_TRACE_AGENT_HOSTNAME &&\n    !process.env.DD_TRACE_AGENT_PORT &&\n    fs.existsSync('/var/run/datadog/apm.socket')\n  ) {\n    return new URL('unix:///var/run/datadog/apm.socket')\n  }\n}\n\nmodule.exports = Config\n","'use strict'\n\nmodule.exports = {\n  SAMPLING_PRIORITY_KEY: '_sampling_priority_v1',\n  ANALYTICS_KEY: '_dd1.sr.eausr',\n  ORIGIN_KEY: '_dd.origin',\n  HOSTNAME_KEY: '_dd.hostname',\n  SAMPLING_RULE_DECISION: '_dd.rule_psr',\n  SAMPLING_LIMIT_DECISION: '_dd.limit_psr',\n  SAMPLING_AGENT_DECISION: '_dd.agent_psr',\n  DATADOG_LAMBDA_EXTENSION_PATH: '/opt/extensions/datadog-agent'\n}\n","'use strict'\n\nconst lookup = require('dns').lookup // cache to avoid instrumentation\nconst dgram = require('dgram')\nconst isIP = require('net').isIP\nconst log = require('./log')\n\nconst MAX_BUFFER_SIZE = 1024 // limit from the agent\n\nclass Client {\n  constructor (options) {\n    options = options || {}\n\n    this._host = options.host || 'localhost'\n    this._family = isIP(this._host)\n    this._port = options.port || 8125\n    this._prefix = options.prefix || ''\n    this._tags = options.tags || []\n    this._queue = []\n    this._buffer = ''\n    this._offset = 0\n    this._udp4 = this._socket('udp4')\n    this._udp6 = this._socket('udp6')\n  }\n\n  gauge (stat, value, tags) {\n    this._add(stat, value, 'g', tags)\n  }\n\n  increment (stat, value, tags) {\n    this._add(stat, value, 'c', tags)\n  }\n\n  flush () {\n    const queue = this._enqueue()\n\n    if (this._queue.length === 0) return\n\n    this._queue = []\n\n    if (this._family !== 0) {\n      this._sendAll(queue, this._host, this._family)\n    } else {\n      lookup(this._host, (err, address, family) => {\n        if (err) return log.error(err)\n        this._sendAll(queue, address, family)\n      })\n    }\n  }\n\n  _send (address, family, buffer) {\n    const socket = family === 6 ? this._udp6 : this._udp4\n\n    log.debug(`Sending to DogStatsD: ${buffer}`)\n\n    socket.send(buffer, 0, buffer.length, this._port, address)\n  }\n\n  _sendAll (queue, address, family) {\n    queue.forEach((buffer) => this._send(address, family, buffer))\n  }\n\n  _add (stat, value, type, tags) {\n    const message = `${this._prefix + stat}:${value}|${type}`\n\n    tags = tags ? this._tags.concat(tags) : this._tags\n\n    if (tags.length > 0) {\n      this._write(`${message}|#${tags.join(',')}\\n`)\n    } else {\n      this._write(`${message}\\n`)\n    }\n  }\n\n  _write (message) {\n    const offset = Buffer.byteLength(message)\n\n    if (this._offset + offset > MAX_BUFFER_SIZE) {\n      this._enqueue()\n    }\n\n    this._offset += offset\n    this._buffer += message\n  }\n\n  _enqueue () {\n    if (this._offset > 0) {\n      this._queue.push(Buffer.from(this._buffer))\n      this._buffer = ''\n      this._offset = 0\n    }\n\n    return this._queue\n  }\n\n  _socket (type) {\n    const socket = dgram.createSocket(type)\n\n    socket.on('error', () => {})\n    socket.unref()\n\n    return socket\n  }\n}\n\nmodule.exports = Client\n","'use strict'\n\nconst Chunk = require('./chunk')\nconst log = require('../log')\n\nconst SOFT_LIMIT = 8 * 1024 * 1024 // 8MB\n\nconst float64Array = new Float64Array(1)\nconst uInt8Float64Array = new Uint8Array(float64Array.buffer)\n\nfloat64Array[0] = -1\n\nconst bigEndian = uInt8Float64Array[7] === 0\n\nclass AgentEncoder {\n  constructor (writer) {\n    this._traceBytes = new Chunk()\n    this._stringBytes = new Chunk()\n    this._writer = writer\n    this._reset()\n  }\n\n  count () {\n    return this._traceCount\n  }\n\n  encode (trace) {\n    const bytes = this._traceBytes\n    const start = bytes.length\n\n    this._traceCount++\n\n    this._encode(bytes, trace)\n\n    const end = bytes.length\n\n    log.debug(() => {\n      const hex = bytes.buffer.subarray(start, end).toString('hex').match(/../g).join(' ')\n\n      return `Adding encoded trace to buffer: ${hex}`\n    })\n\n    // we can go over the soft limit since the agent has a 50MB hard limit\n    if (this._traceBytes.length > SOFT_LIMIT || this._stringBytes.length > SOFT_LIMIT) {\n      this._writer.flush()\n    }\n  }\n\n  makePayload () {\n    const traceSize = this._traceBytes.length + 5\n    const buffer = Buffer.allocUnsafe(traceSize)\n\n    this._writeTraces(buffer)\n\n    this._reset()\n\n    return buffer\n  }\n\n  _encode (bytes, trace) {\n    this._encodeArrayPrefix(bytes, trace)\n\n    for (const span of trace) {\n      bytes.reserve(1)\n\n      if (span.type) {\n        bytes.buffer[bytes.length++] = 0x8c\n\n        this._encodeString(bytes, 'type')\n        this._encodeString(bytes, span.type)\n      } else {\n        bytes.buffer[bytes.length++] = 0x8b\n      }\n\n      this._encodeString(bytes, 'trace_id')\n      this._encodeId(bytes, span.trace_id)\n      this._encodeString(bytes, 'span_id')\n      this._encodeId(bytes, span.span_id)\n      this._encodeString(bytes, 'parent_id')\n      this._encodeId(bytes, span.parent_id)\n      this._encodeString(bytes, 'name')\n      this._encodeString(bytes, span.name)\n      this._encodeString(bytes, 'resource')\n      this._encodeString(bytes, span.resource)\n      this._encodeString(bytes, 'service')\n      this._encodeString(bytes, span.service)\n      this._encodeString(bytes, 'error')\n      this._encodeInteger(bytes, span.error)\n      this._encodeString(bytes, 'start')\n      this._encodeLong(bytes, span.start)\n      this._encodeString(bytes, 'duration')\n      this._encodeLong(bytes, span.duration)\n      this._encodeString(bytes, 'meta')\n      this._encodeMap(bytes, span.meta)\n      this._encodeString(bytes, 'metrics')\n      this._encodeMap(bytes, span.metrics)\n    }\n  }\n\n  _reset () {\n    this._traceCount = 0\n    this._traceBytes.length = 0\n    this._stringCount = 0\n    this._stringBytes.length = 0\n    this._stringMap = {}\n\n    this._cacheString('')\n  }\n\n  _encodeArrayPrefix (bytes, value) {\n    const length = value.length\n    const buffer = bytes.buffer\n    const offset = bytes.length\n\n    bytes.reserve(5)\n    bytes.length += 5\n\n    buffer[offset] = 0xdd\n    buffer[offset + 1] = length >> 24\n    buffer[offset + 2] = length >> 16\n    buffer[offset + 3] = length >> 8\n    buffer[offset + 4] = length\n  }\n\n  _encodeByte (bytes, value) {\n    const buffer = bytes.buffer\n\n    bytes.reserve(1)\n\n    buffer[bytes.length++] = value\n  }\n\n  _encodeId (bytes, id) {\n    const buffer = bytes.buffer\n    const offset = bytes.length\n\n    bytes.reserve(9)\n    bytes.length += 9\n\n    id = id.toArray()\n\n    buffer[offset] = 0xcf\n    buffer[offset + 1] = id[0]\n    buffer[offset + 2] = id[1]\n    buffer[offset + 3] = id[2]\n    buffer[offset + 4] = id[3]\n    buffer[offset + 5] = id[4]\n    buffer[offset + 6] = id[5]\n    buffer[offset + 7] = id[6]\n    buffer[offset + 8] = id[7]\n  }\n\n  _encodeInteger (bytes, value) {\n    const buffer = bytes.buffer\n    const offset = bytes.length\n\n    bytes.reserve(5)\n    bytes.length += 5\n\n    buffer[offset] = 0xce\n    buffer[offset + 1] = value >> 24\n    buffer[offset + 2] = value >> 16\n    buffer[offset + 3] = value >> 8\n    buffer[offset + 4] = value\n  }\n\n  _encodeLong (bytes, value) {\n    const buffer = bytes.buffer\n    const offset = bytes.length\n    const hi = (value / Math.pow(2, 32)) >> 0\n    const lo = value >>> 0\n\n    bytes.reserve(9)\n    bytes.length += 9\n\n    buffer[offset] = 0xcf\n    buffer[offset + 1] = hi >> 24\n    buffer[offset + 2] = hi >> 16\n    buffer[offset + 3] = hi >> 8\n    buffer[offset + 4] = hi\n    buffer[offset + 5] = lo >> 24\n    buffer[offset + 6] = lo >> 16\n    buffer[offset + 7] = lo >> 8\n    buffer[offset + 8] = lo\n  }\n\n  _encodeMap (bytes, value) {\n    const keys = Object.keys(value)\n    const buffer = bytes.buffer\n    const offset = bytes.length\n\n    bytes.reserve(5)\n    bytes.length += 5\n\n    let length = 0\n\n    for (const key of keys) {\n      if (typeof value[key] !== 'string' && typeof value[key] !== 'number') return\n      length++\n\n      this._encodeString(bytes, key)\n      this._encodeValue(bytes, value[key])\n    }\n\n    buffer[offset] = 0xdf\n    buffer[offset + 1] = length >> 24\n    buffer[offset + 2] = length >> 16\n    buffer[offset + 3] = length >> 8\n    buffer[offset + 4] = length\n  }\n\n  _encodeValue (bytes, value) {\n    switch (typeof value) {\n      case 'string':\n        this._encodeString(bytes, value)\n        break\n      case 'number':\n        this._encodeFloat(bytes, value)\n        break\n      default:\n        // should not happen\n    }\n  }\n\n  _encodeString (bytes, value = '') {\n    this._cacheString(value)\n\n    const { start, end } = this._stringMap[value]\n\n    this._stringBytes.copy(bytes, start, end)\n  }\n\n  _encodeFloat (bytes, value) {\n    float64Array[0] = value\n\n    const buffer = bytes.buffer\n    const offset = bytes.length\n\n    bytes.reserve(9)\n    bytes.length += 9\n\n    buffer[offset] = 0xcb\n\n    if (bigEndian) {\n      for (let i = 0; i <= 7; i++) {\n        buffer[offset + i + 1] = uInt8Float64Array[i]\n      }\n    } else {\n      for (let i = 7; i >= 0; i--) {\n        buffer[bytes.length - i - 1] = uInt8Float64Array[i]\n      }\n    }\n  }\n\n  _cacheString (value) {\n    if (!(value in this._stringMap)) {\n      this._stringCount++\n      this._stringMap[value] = {\n        start: this._stringBytes.length,\n        end: this._stringBytes.length + this._stringBytes.write(value)\n      }\n    }\n  }\n\n  _writeArrayPrefix (buffer, offset, count) {\n    buffer[offset++] = 0xdd\n    buffer.writeUInt32BE(count, offset)\n\n    return offset + 4\n  }\n\n  _writeTraces (buffer, offset = 0) {\n    offset = this._writeArrayPrefix(buffer, offset, this._traceCount)\n    offset += this._traceBytes.buffer.copy(buffer, offset, 0, this._traceBytes.length)\n\n    return offset\n  }\n}\n\nmodule.exports = { AgentEncoder }\n","'use strict'\n\nconst { AgentEncoder: BaseEncoder } = require('./0.4')\n\nconst ARRAY_OF_TWO = 0x92\nconst ARRAY_OF_TWELVE = 0x9c\n\nclass AgentEncoder extends BaseEncoder {\n  makePayload () {\n    const prefixSize = 1\n    const stringSize = this._stringBytes.length + 5\n    const traceSize = this._traceBytes.length + 5\n    const buffer = Buffer.allocUnsafe(prefixSize + stringSize + traceSize)\n\n    let offset = 0\n\n    buffer[offset++] = ARRAY_OF_TWO\n\n    offset = this._writeStrings(buffer, offset)\n    offset = this._writeTraces(buffer, offset)\n\n    this._reset()\n\n    return buffer\n  }\n\n  _encode (bytes, trace) {\n    this._encodeArrayPrefix(bytes, trace)\n\n    for (const span of trace) {\n      this._encodeByte(bytes, ARRAY_OF_TWELVE)\n      this._encodeString(bytes, span.service)\n      this._encodeString(bytes, span.name)\n      this._encodeString(bytes, span.resource)\n      this._encodeId(bytes, span.trace_id)\n      this._encodeId(bytes, span.span_id)\n      this._encodeId(bytes, span.parent_id)\n      this._encodeLong(bytes, span.start || 0)\n      this._encodeLong(bytes, span.duration || 0)\n      this._encodeInteger(bytes, span.error)\n      this._encodeMap(bytes, span.meta || {})\n      this._encodeMap(bytes, span.metrics || {})\n      this._encodeString(bytes, span.type)\n    }\n  }\n\n  _encodeString (bytes, value = '') {\n    this._cacheString(value)\n    this._encodeInteger(bytes, this._stringMap[value])\n  }\n\n  _cacheString (value) {\n    if (!(value in this._stringMap)) {\n      this._stringMap[value] = this._stringCount++\n      this._stringBytes.write(value)\n    }\n  }\n\n  _writeStrings (buffer, offset) {\n    offset = this._writeArrayPrefix(buffer, offset, this._stringCount)\n    offset += this._stringBytes.buffer.copy(buffer, offset, 0, this._stringBytes.length)\n\n    return offset\n  }\n}\n\nmodule.exports = { AgentEncoder }\n","'use strict'\nconst { truncateSpan, normalizeSpan } = require('./tags-processors')\nconst Chunk = require('./chunk')\nconst { AgentEncoder } = require('./0.4')\n\nconst ENCODING_VERSION = 1\n\nfunction formatSpan (span) {\n  return {\n    type: span.type === 'test' ? 'test' : 'span',\n    version: ENCODING_VERSION,\n    content: normalizeSpan(truncateSpan(span))\n  }\n}\n\nclass AgentlessCiVisibilityEncoder extends AgentEncoder {\n  constructor ({ runtimeId, service, env }) {\n    super(...arguments)\n    this._events = []\n    this.runtimeId = runtimeId\n    this.service = service\n    this.env = env\n    this._traceBytes = new Chunk()\n    this._stringBytes = new Chunk()\n    this._stringCount = 0\n    this._stringMap = {}\n\n    // Used to keep track of the number of encoded events to update the\n    // length of `payload.events` when calling `makePayload`\n    this._eventCount = 0\n\n    this.reset()\n  }\n\n  _encodeEventContent (bytes, content) {\n    this._encodeMapPrefix(bytes, content)\n    if (content.type) {\n      this._encodeString(bytes, 'type')\n      this._encodeString(bytes, content.type)\n    }\n    this._encodeString(bytes, 'trace_id')\n    this._encodeId(bytes, content.trace_id)\n    this._encodeString(bytes, 'span_id')\n    this._encodeId(bytes, content.span_id)\n    this._encodeString(bytes, 'parent_id')\n    this._encodeId(bytes, content.parent_id)\n    this._encodeString(bytes, 'name')\n    this._encodeString(bytes, content.name)\n    this._encodeString(bytes, 'resource')\n    this._encodeString(bytes, content.resource)\n    this._encodeString(bytes, 'service')\n    this._encodeString(bytes, content.service)\n    this._encodeString(bytes, 'error')\n    this._encodeNumber(bytes, content.error)\n    this._encodeString(bytes, 'start')\n    this._encodeNumber(bytes, content.start)\n    this._encodeString(bytes, 'duration')\n    this._encodeNumber(bytes, content.duration)\n    this._encodeString(bytes, 'meta')\n    this._encodeMap(bytes, content.meta)\n    this._encodeString(bytes, 'metrics')\n    this._encodeMap(bytes, content.metrics)\n  }\n\n  _encodeEvent (bytes, event) {\n    this._encodeMapPrefix(bytes, event)\n    this._encodeString(bytes, 'type')\n    this._encodeString(bytes, event.type)\n\n    this._encodeString(bytes, 'version')\n    this._encodeNumber(bytes, event.version)\n\n    this._encodeString(bytes, 'content')\n    this._encodeEventContent(bytes, event.content)\n  }\n\n  _encodeNumber (bytes, value) {\n    if (Math.floor(value) !== value) { // float 64\n      return this._encodeFloat(bytes, value)\n    }\n    return this._encodeLong(bytes, value)\n  }\n\n  _encodeLong (bytes, value) {\n    const isPositive = value >= 0\n\n    const hi = isPositive ? (value / Math.pow(2, 32)) >> 0 : Math.floor(value / Math.pow(2, 32))\n    const lo = value >>> 0\n    const flag = isPositive ? 0xcf : 0xd3\n\n    const buffer = bytes.buffer\n    const offset = bytes.length\n\n    // int 64\n    bytes.reserve(9)\n    bytes.length += 9\n\n    buffer[offset] = flag\n    buffer[offset + 1] = hi >> 24\n    buffer[offset + 2] = hi >> 16\n    buffer[offset + 3] = hi >> 8\n    buffer[offset + 4] = hi\n    buffer[offset + 5] = lo >> 24\n    buffer[offset + 6] = lo >> 16\n    buffer[offset + 7] = lo >> 8\n    buffer[offset + 8] = lo\n  }\n\n  _encodeMapPrefix (bytes, map) {\n    const keys = Object.keys(map)\n    const buffer = bytes.buffer\n    const offset = bytes.length\n\n    bytes.reserve(5)\n    bytes.length += 5\n    buffer[offset] = 0xdf\n    buffer[offset + 1] = keys.length >> 24\n    buffer[offset + 2] = keys.length >> 16\n    buffer[offset + 3] = keys.length >> 8\n    buffer[offset + 4] = keys.length\n  }\n\n  _encode (bytes, trace) {\n    this._eventCount += trace.length\n    const events = trace.map(formatSpan)\n\n    for (const event of events) {\n      this._encodeEvent(bytes, event)\n    }\n  }\n\n  makePayload () {\n    const bytes = this._traceBytes\n    const eventsOffset = this._eventsOffset\n    const eventsCount = this._eventCount\n\n    bytes.buffer[eventsOffset] = 0xdd\n    bytes.buffer[eventsOffset + 1] = eventsCount >> 24\n    bytes.buffer[eventsOffset + 2] = eventsCount >> 16\n    bytes.buffer[eventsOffset + 3] = eventsCount >> 8\n    bytes.buffer[eventsOffset + 4] = eventsCount\n\n    const traceSize = bytes.length\n    const buffer = Buffer.allocUnsafe(traceSize)\n\n    bytes.buffer.copy(buffer, 0, 0, bytes.length)\n\n    this.reset()\n\n    return buffer\n  }\n\n  _encodePayloadStart (bytes) {\n    // encodes the payload up to `events`. `events` will be encoded via _encode\n    const payload = {\n      version: ENCODING_VERSION,\n      metadata: {\n        '*': {\n          'language': 'javascript'\n        }\n      },\n      events: []\n    }\n\n    if (this.env) {\n      payload.metadata['*'].env = this.env\n    }\n    if (this.runtimeId) {\n      payload.metadata['*']['runtime-id'] = this.runtimeId\n    }\n\n    this._encodeMapPrefix(bytes, payload)\n    this._encodeString(bytes, 'version')\n    this._encodeNumber(bytes, payload.version)\n    this._encodeString(bytes, 'metadata')\n    this._encodeMapPrefix(bytes, payload.metadata)\n    this._encodeString(bytes, '*')\n    this._encodeMap(bytes, payload.metadata['*'])\n    this._encodeString(bytes, 'events')\n    // Get offset of the events list to update the length of the array when calling `makePayload`\n    this._eventsOffset = bytes.length\n    bytes.reserve(5)\n    bytes.length += 5\n  }\n\n  reset () {\n    this._reset()\n    this._eventCount = 0\n    this._encodePayloadStart(this._traceBytes)\n  }\n}\n\nmodule.exports = { AgentlessCiVisibilityEncoder }\n","'use strict'\n\nconst DEFAULT_MIN_SIZE = 2 * 1024 * 1024 // 2MB\n\n/**\n * Represents a chunk of a Msgpack payload. Exposes a subset of Array and Buffer\n * interfaces so that it can be used seamlessly by any encoder code that expects\n * either.\n */\nclass Chunk {\n  constructor (minSize = DEFAULT_MIN_SIZE) {\n    this.buffer = Buffer.allocUnsafe(minSize)\n    this.length = 0\n    this._minSize = minSize\n  }\n\n  write (value) {\n    const length = Buffer.byteLength(value)\n    const offset = this.length\n\n    if (length < 0x20) { // fixstr\n      this.reserve(length + 1)\n      this.length += 1\n      this.buffer[offset] = length | 0xa0\n    } else if (length < 0x100000000) { // str 32\n      this.reserve(length + 5)\n      this.length += 5\n      this.buffer[offset] = 0xdb\n      this.buffer[offset + 1] = length >> 24\n      this.buffer[offset + 2] = length >> 16\n      this.buffer[offset + 3] = length >> 8\n      this.buffer[offset + 4] = length\n    }\n\n    this.length += this.buffer.utf8Write(value, this.length, length)\n\n    return this.length - offset\n  }\n\n  copy (target, sourceStart, sourceEnd) {\n    target.set(new Uint8Array(this.buffer.buffer, sourceStart, sourceEnd - sourceStart))\n  }\n\n  set (array) {\n    this.reserve(array.length)\n\n    this.buffer.set(array, this.length)\n    this.length += array.length\n  }\n\n  reserve (size) {\n    if (this.length + size > this.buffer.length) {\n      this._resize(this._minSize * Math.ceil((this.length + size) / this._minSize))\n    }\n  }\n\n  _resize (size) {\n    const oldBuffer = this.buffer\n\n    this.buffer = Buffer.allocUnsafe(size)\n\n    oldBuffer.copy(this.buffer, 0, 0, this.length)\n  }\n}\n\nmodule.exports = Chunk\n","// From agent truncators: https://github.com/DataDog/datadog-agent/blob/main/pkg/trace/agent/truncator.go\n\n// Values from: https://github.com/DataDog/datadog-agent/blob/main/pkg/trace/traceutil/truncate.go#L22-L27\n// MAX_RESOURCE_NAME_LENGTH the maximum length a span resource can have\nconst MAX_RESOURCE_NAME_LENGTH = 5000\n// MAX_META_KEY_LENGTH the maximum length of metadata key\nconst MAX_META_KEY_LENGTH = 200\n// MAX_META_VALUE_LENGTH the maximum length of metadata value\nconst MAX_META_VALUE_LENGTH = 25000\n// MAX_METRIC_KEY_LENGTH the maximum length of a metric name key\nconst MAX_METRIC_KEY_LENGTH = MAX_META_KEY_LENGTH\n// MAX_METRIC_VALUE_LENGTH the maximum length of a metric name value\nconst MAX_METRIC_VALUE_LENGTH = MAX_META_VALUE_LENGTH\n\n// From agent normalizer:\n// https://github.com/DataDog/datadog-agent/blob/main/pkg/trace/traceutil/normalize.go\n// DEFAULT_SPAN_NAME is the default name we assign a span if it's missing and we have no reasonable fallback\nconst DEFAULT_SPAN_NAME = 'unnamed_operation'\n// DEFAULT_SERVICE_NAME is the default name we assign a service if it's missing and we have no reasonable fallback\nconst DEFAULT_SERVICE_NAME = 'unnamed-service'\n// MAX_NAME_LENGTH the maximum length a name can have\nconst MAX_NAME_LENGTH = 100\n// MAX_SERVICE_LENGTH the maximum length a service can have\nconst MAX_SERVICE_LENGTH = 100\n// MAX_TYPE_LENGTH the maximum length a span type can have\nconst MAX_TYPE_LENGTH = 100\n\nconst fromEntries = Object.fromEntries || (entries =>\n  entries.reduce((obj, [k, v]) => Object.assign(obj, { [k]: v }), {}))\n\nfunction truncateToLength (value, maxLength) {\n  if (!value) {\n    return value\n  }\n  if (value.length > maxLength) {\n    return `${value.slice(0, maxLength)}...`\n  }\n  return value\n}\n\nfunction truncateSpan (span) {\n  return fromEntries(Object.entries(span).map(([key, value]) => {\n    switch (key) {\n      case 'resource':\n        return ['resource', truncateToLength(value, MAX_RESOURCE_NAME_LENGTH)]\n      case 'meta':\n        return ['meta', fromEntries(Object.entries(value).map(([metaKey, metaValue]) =>\n          [truncateToLength(metaKey, MAX_META_KEY_LENGTH), truncateToLength(metaValue, MAX_META_VALUE_LENGTH)]\n        ))]\n      case 'metrics':\n        return ['metrics', fromEntries(Object.entries(value).map(([metricsKey, metricsValue]) =>\n          [truncateToLength(metricsKey, MAX_METRIC_KEY_LENGTH), truncateToLength(metricsValue, MAX_METRIC_VALUE_LENGTH)]\n        ))]\n      default:\n        return [key, value]\n    }\n  }))\n}\n\nfunction normalizeSpan (span) {\n  const normalizedSpan = fromEntries(Object.entries(span).map(([key, value]) => {\n    switch (key) {\n      case 'service':\n        if (!value) {\n          return [key, DEFAULT_SERVICE_NAME]\n        }\n        if (value.length > MAX_SERVICE_LENGTH) {\n          return [key, value.slice(0, MAX_SERVICE_LENGTH)]\n        }\n        break\n      case 'name':\n        if (!value) {\n          return [key, DEFAULT_SPAN_NAME]\n        }\n        if (value.length > MAX_NAME_LENGTH) {\n          return [key, value.slice(0, MAX_NAME_LENGTH)]\n        }\n        break\n      case 'resource':\n        if (!value) {\n          return [key, span.name || DEFAULT_SPAN_NAME]\n        }\n        break\n      case 'type':\n        if (!value) {\n          return [key, value]\n        }\n        if (value.length > MAX_TYPE_LENGTH) {\n          return [key, value.slice(0, MAX_TYPE_LENGTH)]\n        }\n    }\n    return [key, value]\n  }))\n  if (!normalizedSpan.service) {\n    normalizedSpan.service = DEFAULT_SERVICE_NAME\n  }\n  if (!normalizedSpan.name) {\n    normalizedSpan.name = DEFAULT_SPAN_NAME\n  }\n  return normalizedSpan\n}\n\nmodule.exports = {\n  truncateSpan,\n  normalizeSpan,\n  MAX_META_KEY_LENGTH,\n  MAX_META_VALUE_LENGTH,\n  MAX_METRIC_KEY_LENGTH,\n  MAX_METRIC_VALUE_LENGTH,\n  MAX_NAME_LENGTH,\n  MAX_SERVICE_LENGTH,\n  MAX_TYPE_LENGTH,\n  MAX_RESOURCE_NAME_LENGTH,\n  DEFAULT_SPAN_NAME,\n  DEFAULT_SERVICE_NAME\n}\n","'use strict'\n\nconst AgentExporter = require('./exporters/agent')\nconst LogExporter = require('./exporters/log')\nconst AgentlessCiVisibilityExporter = require('./ci-visibility/exporters/agentless')\nconst exporters = require('../../../ext/exporters')\nconst fs = require('fs')\nconst constants = require('./constants')\n\nmodule.exports = name => {\n  const inAWSLambda = process.env.AWS_LAMBDA_FUNCTION_NAME !== undefined\n  const usingLambdaExtension = inAWSLambda && fs.existsSync(constants.DATADOG_LAMBDA_EXTENSION_PATH)\n\n  switch (name) {\n    case exporters.LOG:\n      return LogExporter\n    case exporters.AGENT:\n      return AgentExporter\n    case exporters.DATADOG:\n      return AgentlessCiVisibilityExporter\n    default:\n      return inAWSLambda && !usingLambdaExtension ? LogExporter : AgentExporter\n  }\n}\n","'use strict'\n\nconst URL = require('url').URL\nconst log = require('../../log')\nconst Writer = require('./writer')\nconst Scheduler = require('../scheduler')\n\nclass AgentExporter {\n  constructor ({ url, hostname, port, flushInterval, lookup, protocolVersion }, prioritySampler) {\n    this._url = url || new URL(`http://${hostname || 'localhost'}:${port}`)\n    this._writer = new Writer({ url: this._url, prioritySampler, lookup, protocolVersion })\n\n    if (flushInterval > 0) {\n      this._scheduler = new Scheduler(() => this._writer.flush(), flushInterval)\n    }\n    this._scheduler && this._scheduler.start()\n  }\n\n  setUrl (url) {\n    try {\n      url = new URL(url)\n      this._url = url\n      this._writer.setUrl(url)\n    } catch (e) {\n      log.warn(e.stack)\n    }\n  }\n\n  export (spans) {\n    this._writer.append(spans)\n\n    if (!this._scheduler) {\n      this._writer.flush()\n    }\n  }\n}\n\nmodule.exports = AgentExporter\n","'use strict'\n\nconst request = require('../common/request')\nconst { startupLog } = require('../../startup-log')\nconst metrics = require('../../metrics')\nconst log = require('../../log')\nconst tracerVersion = require('../../../lib/version')\nconst BaseWriter = require('../common/writer')\n\nconst METRIC_PREFIX = 'datadog.tracer.node.exporter.agent'\n\nclass Writer extends BaseWriter {\n  constructor ({ prioritySampler, lookup, protocolVersion }) {\n    super(...arguments)\n    const AgentEncoder = getEncoder(protocolVersion)\n\n    this._prioritySampler = prioritySampler\n    this._lookup = lookup\n    this._protocolVersion = protocolVersion\n    this._encoder = new AgentEncoder(this)\n  }\n\n  _sendPayload (data, count, done) {\n    metrics.increment(`${METRIC_PREFIX}.requests`, true)\n\n    makeRequest(this._protocolVersion, data, count, this._url, this._lookup, true, (err, res, status) => {\n      if (status) {\n        metrics.increment(`${METRIC_PREFIX}.responses`, true)\n        metrics.increment(`${METRIC_PREFIX}.responses.by.status`, `status:${status}`, true)\n      } else if (err) {\n        metrics.increment(`${METRIC_PREFIX}.errors`, true)\n        metrics.increment(`${METRIC_PREFIX}.errors.by.name`, `name:${err.name}`, true)\n\n        if (err.code) {\n          metrics.increment(`${METRIC_PREFIX}.errors.by.code`, `code:${err.code}`, true)\n        }\n      }\n\n      startupLog({ agentError: err })\n\n      if (err) {\n        log.error(err)\n        done()\n        return\n      }\n\n      log.debug(`Response from the agent: ${res}`)\n\n      try {\n        this._prioritySampler.update(JSON.parse(res).rate_by_service)\n      } catch (e) {\n        log.error(e)\n\n        metrics.increment(`${METRIC_PREFIX}.errors`, true)\n        metrics.increment(`${METRIC_PREFIX}.errors.by.name`, `name:${e.name}`, true)\n      }\n      done()\n    })\n  }\n}\n\nfunction setHeader (headers, key, value) {\n  if (value) {\n    headers[key] = value\n  }\n}\n\nfunction getEncoder (protocolVersion) {\n  if (protocolVersion === '0.5') {\n    return require('../../encode/0.5').AgentEncoder\n  } else {\n    return require('../../encode/0.4').AgentEncoder\n  }\n}\n\nfunction makeRequest (version, data, count, url, lookup, needsStartupLog, cb) {\n  const options = {\n    path: `/v${version}/traces`,\n    method: 'PUT',\n    headers: {\n      'Content-Type': 'application/msgpack',\n      'Datadog-Meta-Tracer-Version': tracerVersion,\n      'X-Datadog-Trace-Count': String(count)\n    },\n    lookup\n  }\n\n  setHeader(options.headers, 'Datadog-Meta-Lang', 'nodejs')\n  setHeader(options.headers, 'Datadog-Meta-Lang-Version', process.version)\n  setHeader(options.headers, 'Datadog-Meta-Lang-Interpreter', process.jsEngine || 'v8')\n\n  if (url.protocol === 'unix:') {\n    options.socketPath = url.pathname\n  } else {\n    options.protocol = url.protocol\n    options.hostname = url.hostname\n    options.port = url.port\n  }\n\n  log.debug(() => `Request to the agent: ${JSON.stringify(options)}`)\n\n  request(data, options, true, (err, res, status) => {\n    if (needsStartupLog) {\n      // Note that logging will only happen once, regardless of how many times this is called.\n      startupLog({\n        agentError: status !== 404 && status !== 200 ? err : undefined\n      })\n    }\n    cb(err, res, status)\n  })\n}\n\nmodule.exports = Writer\n","'use strict'\n\nconst fs = require('fs')\n\nconst uuidSource = '[0-9a-f]{8}[-_][0-9a-f]{4}[-_][0-9a-f]{4}[-_][0-9a-f]{4}[-_][0-9a-f]{12}'\nconst containerSource = '[0-9a-f]{64}'\nconst taskSource = '[0-9a-f]{32}-\\\\d+'\nconst entityReg = new RegExp(`.*(${uuidSource}|${containerSource}|${taskSource})(?:\\\\.scope)?$`, 'm')\n\nconst entityId = getEntityId()\n\nfunction getEntityId () {\n  const cgroup = readControlGroup() || ''\n  const match = cgroup.trim().match(entityReg) || []\n\n  return match[1]\n}\n\nfunction readControlGroup () {\n  try {\n    return fs.readFileSync('/proc/self/cgroup').toString()\n  } catch (err) {\n    // ignore\n  }\n}\n\nmodule.exports = {\n  // can be the container ID but not always depending on the orchestrator\n  id () {\n    return entityId\n  }\n}\n","'use strict'\n\nconst http = require('http')\nconst https = require('https')\nconst log = require('../../log')\nconst docker = require('./docker')\nconst { storage } = require('../../../../datadog-core')\n\nconst httpAgent = new http.Agent({ keepAlive: true })\nconst httpsAgent = new https.Agent({ keepAlive: true })\nconst containerId = docker.id()\n\nfunction request (data, options, keepAlive, callback) {\n  if (!options.headers) {\n    options.headers = {}\n  }\n  const isSecure = options.protocol === 'https:'\n  const client = isSecure ? https : http\n  const dataArray = [].concat(data)\n  options.headers['Content-Length'] = byteLength(dataArray)\n\n  if (containerId) {\n    options.headers['Datadog-Container-ID'] = containerId\n  }\n\n  if (keepAlive) {\n    options.agent = isSecure ? httpsAgent : httpAgent\n  }\n\n  const firstRequest = retriableRequest(options, client, callback)\n  dataArray.forEach(buffer => firstRequest.write(buffer))\n\n  // The first request will be retried\n  const firstRequestErrorHandler = () => {\n    log.debug('Retrying request to the intake')\n    const retriedReq = retriableRequest(options, client, callback)\n    dataArray.forEach(buffer => retriedReq.write(buffer))\n    // The retried request will fail normally\n    retriedReq.on('error', e => callback(new Error(`Network error trying to reach the intake: ${e.message}`)))\n    retriedReq.end()\n  }\n\n  firstRequest.on('error', firstRequestErrorHandler)\n  firstRequest.end()\n\n  return firstRequest\n}\n\nfunction retriableRequest (options, client, callback) {\n  const store = storage.getStore()\n\n  storage.enterWith({ noop: true })\n\n  const timeout = options.timeout || 15000\n\n  const request = client.request(options, res => {\n    let responseData = ''\n\n    res.setTimeout(timeout)\n\n    res.on('data', chunk => { responseData += chunk })\n    res.on('end', () => {\n      if (res.statusCode >= 200 && res.statusCode <= 299) {\n        callback(null, responseData, res.statusCode)\n      } else {\n        const error = new Error(`Error from the endpoint: ${res.statusCode} ${http.STATUS_CODES[res.statusCode]}`)\n        error.status = res.statusCode\n\n        callback(error, null, res.statusCode)\n      }\n    })\n  })\n  request.setTimeout(timeout, request.abort)\n  storage.enterWith(store)\n\n  return request\n}\n\nfunction byteLength (data) {\n  return data.length > 0 ? data.reduce((prev, next) => prev + next.length, 0) : 0\n}\n\nmodule.exports = request\n","'use strict'\nconst log = require('../../log')\n\nclass Writer {\n  constructor ({ url }) {\n    this._url = url\n  }\n\n  flush (done = () => {}) {\n    const count = this._encoder.count()\n\n    if (count > 0) {\n      const payload = this._encoder.makePayload()\n\n      this._sendPayload(payload, count, done)\n    } else {\n      done()\n    }\n  }\n\n  append (spans) {\n    log.debug(() => `Encoding trace: ${JSON.stringify(spans)}`)\n\n    this._encode(spans)\n  }\n\n  _encode (trace) {\n    this._encoder.encode(trace)\n  }\n\n  setUrl (url) {\n    this._url = url\n  }\n}\n\nmodule.exports = Writer\n","'use strict'\n\nconst log = require('../../log')\n\nconst TRACE_PREFIX = '{\"traces\":[['\nconst TRACE_SUFFIX = ']]}\\n'\nconst TRACE_FORMAT_OVERHEAD = TRACE_PREFIX.length + TRACE_SUFFIX.length\nconst MAX_SIZE = 64 * 1024 // 64kb\n\nclass LogExporter {\n  export (spans) {\n    log.debug(() => `Adding trace to queue: ${JSON.stringify(spans)}`)\n\n    let size = TRACE_FORMAT_OVERHEAD\n    let queue = []\n\n    for (const span of spans) {\n      const spanStr = JSON.stringify(span)\n      if (spanStr.length + TRACE_FORMAT_OVERHEAD > MAX_SIZE) {\n        log.debug('Span too large to send to logs, dropping')\n        continue\n      }\n      if (spanStr.length + size > MAX_SIZE) {\n        this._printSpans(queue)\n        queue = []\n        size = TRACE_FORMAT_OVERHEAD\n      }\n      size += spanStr.length + 1 // includes length of ',' character\n      queue.push(spanStr)\n    }\n    if (queue.length > 0) {\n      this._printSpans(queue)\n    }\n  }\n\n  _printSpans (queue) {\n    let logLine = TRACE_PREFIX\n    let firstTrace = true\n    for (const spanStr of queue) {\n      if (firstTrace) {\n        firstTrace = false\n        logLine += spanStr\n      } else {\n        logLine += ',' + spanStr\n      }\n    }\n    logLine += TRACE_SUFFIX\n    process.stdout.write(logLine)\n  }\n}\n\nmodule.exports = LogExporter\n","'use strict'\n\nclass Scheduler {\n  constructor (callback, interval) {\n    this._timer = null\n    this._callback = callback\n    this._interval = interval\n  }\n\n  start () {\n    this._timer = setInterval(this._callback, this._interval)\n    this._timer.unref && this._timer.unref()\n\n    process.once('beforeExit', this._callback)\n  }\n\n  stop () {\n    clearInterval(this._timer)\n\n    process.removeListener('beforeExit', this._callback)\n  }\n\n  reset () {\n    this.stop()\n    this.start()\n  }\n}\n\nmodule.exports = Scheduler\n","'use strict'\n\nconst constants = require('./constants')\nconst tags = require('../../../ext/tags')\nconst id = require('./id')\nconst { isError } = require('./util')\n\nconst SAMPLING_PRIORITY_KEY = constants.SAMPLING_PRIORITY_KEY\nconst SAMPLING_RULE_DECISION = constants.SAMPLING_RULE_DECISION\nconst SAMPLING_LIMIT_DECISION = constants.SAMPLING_LIMIT_DECISION\nconst SAMPLING_AGENT_DECISION = constants.SAMPLING_AGENT_DECISION\nconst MEASURED = tags.MEASURED\nconst ORIGIN_KEY = constants.ORIGIN_KEY\nconst HOSTNAME_KEY = constants.HOSTNAME_KEY\n\nconst map = {\n  'service.name': 'service',\n  'span.type': 'type',\n  'resource.name': 'resource'\n}\n\nfunction format (span) {\n  const formatted = formatSpan(span)\n\n  extractError(formatted, span)\n  extractRootTags(formatted, span)\n  extractChunkTags(formatted, span)\n  extractTags(formatted, span)\n\n  return formatted\n}\n\nfunction formatSpan (span) {\n  const spanContext = span.context()\n\n  return {\n    trace_id: spanContext._traceId,\n    span_id: spanContext._spanId,\n    parent_id: spanContext._parentId || id('0'),\n    name: String(spanContext._name),\n    resource: String(spanContext._name),\n    error: 0,\n    meta: {},\n    metrics: {},\n    start: Math.round(span._startTime * 1e6),\n    duration: Math.round(span._duration * 1e6)\n  }\n}\n\nfunction extractTags (trace, span) {\n  const context = span.context()\n  const origin = context._trace.origin\n  const tags = context._tags\n  const hostname = context._hostname\n  const priority = context._sampling.priority\n\n  if (tags['span.kind'] && tags['span.kind'] !== 'internal') {\n    addTag({}, trace.metrics, MEASURED, 1)\n  }\n\n  for (const tag in tags) {\n    switch (tag) {\n      case 'service.name':\n      case 'span.type':\n      case 'resource.name':\n        addTag(trace, {}, map[tag], tags[tag])\n        break\n      // HACK: remove when Datadog supports numeric status code\n      case 'http.status_code':\n        addTag(trace.meta, {}, tag, tags[tag] && String(tags[tag]))\n        break\n      case HOSTNAME_KEY:\n      case MEASURED:\n        addTag({}, trace.metrics, tag, tags[tag] === undefined || tags[tag] ? 1 : 0)\n        break\n      case 'error':\n        if (tags[tag] && (context._name !== 'fs.operation')) {\n          trace.error = 1\n        }\n        break\n      case 'error.type':\n      case 'error.msg':\n      case 'error.stack':\n        // HACK: remove when implemented in the backend\n        if (context._name !== 'fs.operation') {\n          trace.error = 1\n        }\n      default: // eslint-disable-line no-fallthrough\n        addTag(trace.meta, trace.metrics, tag, tags[tag])\n    }\n  }\n\n  if (span.tracer()._service === tags['service.name']) {\n    addTag(trace.meta, trace.metrics, 'language', 'javascript')\n  }\n\n  addTag(trace.meta, trace.metrics, SAMPLING_PRIORITY_KEY, priority)\n  addTag(trace.meta, trace.metrics, ORIGIN_KEY, origin)\n  addTag(trace.meta, trace.metrics, HOSTNAME_KEY, hostname)\n}\n\nfunction extractRootTags (trace, span) {\n  const context = span.context()\n  const isLocalRoot = span === context._trace.started[0]\n  const parentId = context._parentId\n\n  if (!isLocalRoot || (parentId && parentId.toString(10) !== '0')) return\n\n  addTag({}, trace.metrics, SAMPLING_RULE_DECISION, context._trace[SAMPLING_RULE_DECISION])\n  addTag({}, trace.metrics, SAMPLING_LIMIT_DECISION, context._trace[SAMPLING_LIMIT_DECISION])\n  addTag({}, trace.metrics, SAMPLING_AGENT_DECISION, context._trace[SAMPLING_AGENT_DECISION])\n}\n\nfunction extractChunkTags (trace, span) {\n  const context = span.context()\n  const isLocalRoot = span === context._trace.started[0]\n\n  if (!isLocalRoot) return\n\n  for (const key in context._trace.tags) {\n    addTag(trace.meta, trace.metrics, key, context._trace.tags[key])\n  }\n}\n\nfunction extractError (trace, span) {\n  const error = span.context()._tags['error']\n  if (isError(error)) {\n    addTag(trace.meta, trace.metrics, 'error.msg', error.message)\n    addTag(trace.meta, trace.metrics, 'error.type', error.name)\n    addTag(trace.meta, trace.metrics, 'error.stack', error.stack)\n  }\n}\n\nfunction addTag (meta, metrics, key, value, nested) {\n  switch (typeof value) {\n    case 'string':\n      if (!value) break\n      meta[key] = value\n      break\n    case 'number':\n      if (isNaN(value)) break\n      metrics[key] = value\n      break\n    case 'boolean':\n      metrics[key] = value ? 1 : 0\n      break\n    case 'undefined':\n      break\n    case 'object':\n      if (value === null) break\n\n      // Special case for Node.js Buffer and URL\n      if (isNodeBuffer(value) || isUrl(value)) {\n        metrics[key] = value.toString()\n      } else if (!Array.isArray(value) && !nested) {\n        for (const prop in value) {\n          if (!value.hasOwnProperty(prop)) continue\n\n          addTag(meta, metrics, `${key}.${prop}`, value[prop], true)\n        }\n      }\n\n      break\n  }\n}\n\nfunction isNodeBuffer (obj) {\n  return obj.constructor && obj.constructor.name === 'Buffer' &&\n    typeof obj.readInt8 === 'function' &&\n    typeof obj.toString === 'function'\n}\n\nfunction isUrl (obj) {\n  return obj.constructor && obj.constructor.name === 'URL' &&\n    typeof obj.href === 'string' &&\n    typeof obj.toString === 'function'\n}\n\nmodule.exports = format\n","'use strict'\n\nconst { DDSketch } = require('@datadog/sketches-js')\n\nclass Histogram {\n  constructor () {\n    this.reset()\n  }\n\n  get min () { return this._min }\n  get max () { return this._max }\n  get avg () { return this._count === 0 ? 0 : this._sum / this._count }\n  get sum () { return this._sum }\n  get count () { return this._count }\n  get median () { return this.percentile(50) }\n  get p95 () { return this.percentile(95) }\n\n  percentile (percentile) {\n    return this._histogram.getValueAtQuantile(percentile / 100) || 0\n  }\n\n  record (value) {\n    if (this._count === 0) {\n      this._min = this._max = value\n    } else {\n      this._min = Math.min(this._min, value)\n      this._max = Math.max(this._max, value)\n    }\n\n    this._count++\n    this._sum += value\n\n    this._histogram.accept(value)\n  }\n\n  reset () {\n    this._min = 0\n    this._max = 0\n    this._sum = 0\n    this._count = 0\n\n    this._histogram = new DDSketch()\n  }\n}\n\nmodule.exports = Histogram\n","'use strict'\n\nconst { randomFillSync } = require('crypto')\n\nconst UINT_MAX = 4294967296\n\nconst data = new Uint8Array(8 * 8192)\nconst zeroId = new Uint8Array(8)\n\nconst map = Array.prototype.map\nconst pad = byte => `${byte < 16 ? '0' : ''}${byte.toString(16)}`\n\nlet batch = 0\n\n// Internal representation of a trace or span ID.\nclass Identifier {\n  constructor (value, radix) {\n    this._isUint64BE = true // msgpack-lite compatibility\n    this._buffer = typeof radix === 'number'\n      ? fromString(value, radix)\n      : createBuffer(value)\n  }\n\n  toString (radix) {\n    return typeof radix === 'number'\n      ? toNumberString(this._buffer, radix)\n      : toHexString(this._buffer)\n  }\n\n  toBuffer () {\n    return this._buffer\n  }\n\n  // msgpack-lite compatibility\n  toArray () {\n    if (this._buffer.length === 8) {\n      return this._buffer\n    }\n    return this._buffer.slice(-8)\n  }\n\n  toJSON () {\n    return this.toString()\n  }\n}\n\n// Create a buffer, using an optional hexadecimal value if provided.\nfunction createBuffer (value) {\n  if (value === '0') return zeroId\n  if (!value) return pseudoRandom()\n\n  const size = Math.ceil(value.length / 2)\n  const buffer = new Array(size)\n\n  for (let i = 0; i < size; i++) {\n    buffer[i] = parseInt(value.substring(i * 2, i * 2 + 2), 16)\n  }\n\n  return buffer\n}\n\n// Convert a numerical string to a buffer using the specified radix.\nfunction fromString (str, raddix) {\n  const buffer = new Array(8)\n  const len = str.length\n\n  let pos = 0\n  let high = 0\n  let low = 0\n\n  if (str[0] === '-') pos++\n\n  const sign = pos\n\n  while (pos < len) {\n    const chr = parseInt(str[pos++], raddix)\n\n    if (!(chr >= 0)) break // NaN\n\n    low = low * raddix + chr\n    high = high * raddix + Math.floor(low / UINT_MAX)\n    low %= UINT_MAX\n  }\n\n  if (sign) {\n    high = ~high\n\n    if (low) {\n      low = UINT_MAX - low\n    } else {\n      high++\n    }\n  }\n\n  writeUInt32BE(buffer, high, 0)\n  writeUInt32BE(buffer, low, 4)\n\n  return buffer\n}\n\n// Convert a buffer to a numerical string.\nfunction toNumberString (buffer, radix) {\n  let high = readInt32(buffer, 0)\n  let low = readInt32(buffer, 4)\n  let str = ''\n\n  radix = radix || 10\n\n  while (1) {\n    const mod = (high % radix) * UINT_MAX + low\n\n    high = Math.floor(high / radix)\n    low = Math.floor(mod / radix)\n    str = (mod % radix).toString(radix) + str\n\n    if (!high && !low) break\n  }\n\n  return str\n}\n\n// Convert a buffer to a hexadecimal string.\nfunction toHexString (buffer) {\n  return map.call(buffer, pad).join('')\n}\n\n// Simple pseudo-random 64-bit ID generator.\nfunction pseudoRandom () {\n  if (batch === 0) {\n    randomFillSync(data)\n  }\n\n  batch = (batch + 1) % 8192\n\n  const offset = batch * 8\n\n  return [\n    data[offset] & 0x7F, // only positive int64,\n    data[offset + 1],\n    data[offset + 2],\n    data[offset + 3],\n    data[offset + 4],\n    data[offset + 5],\n    data[offset + 6],\n    data[offset + 7]\n  ]\n}\n\n// Read a buffer to unsigned integer bytes.\nfunction readInt32 (buffer, offset) {\n  return (buffer[offset + 0] * 16777216) +\n    (buffer[offset + 1] << 16) +\n    (buffer[offset + 2] << 8) +\n    buffer[offset + 3]\n}\n\n// Write unsigned integer bytes to a buffer.\nfunction writeUInt32BE (buffer, value, offset) {\n  buffer[3 + offset] = value & 255\n  value = value >> 8\n  buffer[2 + offset] = value & 255\n  value = value >> 8\n  buffer[1 + offset] = value & 255\n  value = value >> 8\n  buffer[0 + offset] = value & 255\n}\n\nmodule.exports = (value, radix) => new Identifier(value, radix)\n","'use strict'\n\nconst semver = require('semver')\nconst logger = require('./log')\n\nif (semver.satisfies(process.versions.node, '^12.20.0 || >=14.13.1')) {\n  module.exports = require('import-in-the-middle')\n} else {\n  logger.warn('ESM is not fully supported by this version of Node.js, ' +\n    'so dd-trace will not intercept ESM loading.')\n  module.exports = () => ({\n    unhook: () => {}\n  })\n  module.exports.addHook = () => {}\n  module.exports.removeHook = () => {}\n}\n","'use strict'\n\nconst shimmer = require('../../datadog-shimmer')\nconst log = require('./log')\nconst metrics = require('./metrics')\nconst Loader = require('./loader')\nconst { isTrue } = require('./util')\nconst plugins = require('./plugins')\nconst Plugin = require('./plugins/plugin')\nconst telemetry = require('./telemetry')\n\nconst disabledPlugins = process.env.DD_TRACE_DISABLED_PLUGINS\n\nconst collectDisabledPlugins = () => {\n  return new Set(disabledPlugins && disabledPlugins.split(',').map(plugin => plugin.trim()))\n}\n\nfunction cleanEnv (name) {\n  return process.env[`DD_TRACE_${name.toUpperCase()}`.replace(/[^a-z0-9_]/ig, '_')]\n}\n\nfunction getConfig (name, config = {}) {\n  if (!name) {\n    return config\n  }\n\n  const enabled = cleanEnv(`${name}_ENABLED`)\n  if (enabled !== undefined) {\n    config.enabled = isTrue(enabled)\n  }\n\n  return config\n}\n\nclass Instrumenter {\n  constructor (tracer) {\n    this._tracer = tracer\n    this._loader = new Loader(this)\n    this._enabled = false\n    this._names = new Set()\n    this._plugins = new Map()\n    this._instrumented = new Map()\n    this._disabledPlugins = collectDisabledPlugins()\n  }\n\n  use (name, config) {\n    if (typeof name !== 'string') return\n    const plugin = plugins[name.toLowerCase()]\n    if (plugin && plugin.prototype instanceof Plugin) return\n    if (typeof config === 'boolean') {\n      config = { enabled: config }\n    }\n\n    config = getConfig(name, config)\n\n    try {\n      this._set(plugin, { name, config })\n      telemetry.updateIntegrations()\n    } catch (e) {\n      log.debug(`Could not find a plugin named \"${name}\".`)\n    }\n\n    if (this._enabled) {\n      this._loader.reload(this._plugins)\n    }\n  }\n\n  enable (config) {\n    config = config || {}\n    const serviceMapping = config.serviceMapping\n\n    this._enabled = true\n\n    if (config.plugins !== false) {\n      Object.keys(plugins)\n        .filter(name => !this._plugins.has(plugins[name]))\n        .forEach(name => {\n          if (plugins[name].prototype instanceof Plugin) return\n          const pluginConfig = {}\n          if (serviceMapping && serviceMapping[name]) {\n            pluginConfig.service = serviceMapping[name]\n          }\n          this._set(plugins[name], { name, config: getConfig(name, pluginConfig) })\n        })\n    }\n\n    this._loader.reload(this._plugins)\n  }\n\n  disable () {\n    for (const instrumentation of this._instrumented.keys()) {\n      this.unpatch(instrumentation)\n    }\n\n    this._plugins.clear()\n    this._enabled = false\n    this._loader.reload(this._plugins)\n  }\n\n  wrap (nodules, names, wrapper) {\n    shimmer.massWrap(nodules, names, wrapper)\n  }\n\n  unwrap (nodules, names, wrapper) {\n    shimmer.massUnwrap(nodules, names, wrapper)\n  }\n\n  wrapExport (moduleExports, wrapper) {\n    return shimmer.wrap(moduleExports, wrapper)\n  }\n\n  unwrapExport (moduleExports) {\n    return shimmer.unwrap(moduleExports)\n  }\n\n  load (plugin, meta) {\n    if (!this._enabled) return\n\n    const instrumentations = [].concat(plugin)\n    const enabled = meta.config.enabled !== false\n\n    metrics.boolean(`datadog.tracer.node.plugin.enabled.by.name`, enabled, `name:${meta.name}`)\n\n    try {\n      instrumentations\n        .forEach(instrumentation => {\n          this._loader.load(instrumentation, meta.config)\n        })\n    } catch (e) {\n      log.error(e)\n      this.unload(plugin)\n      log.debug(`Error while trying to patch ${meta.name}. The plugin has been disabled.`)\n\n      metrics.increment(`datadog.tracer.node.plugin.errors`, true)\n    }\n  }\n\n  unload (plugin) {\n    [].concat(plugin)\n      .forEach(instrumentation => {\n        this.unpatch(instrumentation)\n        this._instrumented.delete(instrumentation)\n      })\n\n    const meta = this._plugins.get(plugin)\n\n    if (meta) {\n      this._plugins.delete(plugin)\n\n      metrics.boolean(`datadog.tracer.node.plugin.enabled.by.name`, false, `name:${meta.name}`)\n    }\n  }\n\n  patch (instrumentation, moduleExports, config) {\n    let instrumented = this._instrumented.get(instrumentation)\n\n    if (!instrumented) {\n      this._instrumented.set(instrumentation, instrumented = new Set())\n      telemetry.updateIntegrations()\n    }\n\n    if (!instrumented.has(this._defaultExport(moduleExports))) {\n      try {\n        moduleExports = instrumentation.patch.call(this, moduleExports, this._tracer._tracer, config) || moduleExports\n        return moduleExports\n      } finally {\n        // add even on error since `unpatch` will take care of removing it.\n        instrumented.add(this._defaultExport(moduleExports))\n      }\n    }\n  }\n\n  unpatch (instrumentation) {\n    const instrumented = this._instrumented.get(instrumentation)\n\n    if (instrumented) {\n      instrumented.forEach(moduleExports => {\n        try {\n          instrumentation.unpatch.call(this, moduleExports, this._tracer)\n        } catch (e) {\n          log.error(e)\n        }\n      })\n    }\n  }\n\n  _set (plugin, meta) {\n    if (this._disabledPlugins.has(meta.name)) {\n      log.debug(`Plugin \"${meta.name}\" was disabled via configuration option.`)\n    } else {\n      this._plugins.set(plugin, meta)\n      this.load(plugin, meta)\n    }\n  }\n\n  // ESM modules have a different export between `import` and `require` so we\n  // use the default export instead when available.\n  _defaultExport (moduleExports) {\n    return moduleExports && (moduleExports.default || moduleExports)\n  }\n}\n\nmodule.exports = Instrumenter\n","'use strict'\n\nconst semver = require('semver')\nconst Hook = require('../../datadog-instrumentations/src/helpers/hook')\nconst parse = require('module-details-from-path')\nconst path = require('path')\nconst uniq = require('lodash.uniq')\nconst log = require('./log')\nconst requirePackageJson = require('./require-package-json')\n\nconst pathSepExpr = new RegExp(`\\\\${path.sep}`, 'g')\n\nclass Loader {\n  constructor (instrumenter) {\n    this._instrumenter = instrumenter\n  }\n\n  reload (plugins) {\n    this._plugins = plugins\n    this._patched = []\n\n    const instrumentations = Array.from(this._plugins.keys())\n      .reduce((prev, current) => prev.concat(current), [])\n\n    const instrumentedModules = uniq(instrumentations\n      .map(instrumentation => instrumentation.name))\n\n    this._names = new Set(instrumentations\n      .map(instrumentation => filename(instrumentation)))\n\n    this._hook && this._hook.unhook()\n    this._hook = Hook(instrumentedModules, (moduleExports, moduleName, moduleBaseDir) => {\n      return this._hookModule(moduleExports, moduleName, moduleBaseDir)\n    })\n  }\n\n  load (instrumentation, config) {\n    this._getModules(instrumentation).forEach(nodule => {\n      this._instrumenter.patch(instrumentation, nodule, config)\n    })\n  }\n\n  _getModules (instrumentation) {\n    const modules = []\n    const ids = Object.keys(require.cache)\n\n    let pkg\n\n    for (let i = 0, l = ids.length; i < l; i++) {\n      const id = ids[i].replace(pathSepExpr, '/')\n\n      if (!id.includes(`/node_modules/${instrumentation.name}/`)) continue\n\n      if (instrumentation.file) {\n        if (!id.endsWith(`/node_modules/${filename(instrumentation)}`)) continue\n\n        const basedir = getBasedir(ids[i])\n\n        pkg = requirePackageJson(basedir, module)\n      } else {\n        const basedir = getBasedir(ids[i])\n\n        pkg = requirePackageJson(basedir, module)\n\n        const mainFile = path.posix.normalize(pkg.main || 'index.js')\n        if (!id.endsWith(`/node_modules/${instrumentation.name}/${mainFile}`)) continue\n      }\n\n      if (!matchVersion(pkg.version, instrumentation.versions)) continue\n\n      modules.push(require.cache[ids[i]].exports)\n    }\n\n    return modules\n  }\n\n  _hookModule (moduleExports, moduleName, moduleBaseDir) {\n    moduleName = moduleName.replace(pathSepExpr, '/')\n\n    if (!this._names.has(moduleName)) {\n      return moduleExports\n    }\n\n    if (moduleBaseDir) {\n      moduleBaseDir = moduleBaseDir.replace(pathSepExpr, '/')\n    }\n\n    const moduleVersion = getVersion(moduleBaseDir)\n\n    for (const [plugin, meta] of this._plugins) {\n      if (meta.config.enabled === false) {\n        continue\n      }\n      try {\n        for (const instrumentation of [].concat(plugin)) {\n          if (moduleName !== filename(instrumentation) || !matchVersion(moduleVersion, instrumentation.versions)) {\n            continue\n          }\n\n          moduleExports = this._instrumenter.patch(instrumentation, moduleExports, meta.config) || moduleExports\n        }\n      } catch (e) {\n        log.error(e)\n        this._instrumenter.unload(plugin)\n        log.debug(`Error while trying to patch ${meta.name}. The plugin has been disabled.`)\n      }\n    }\n\n    return moduleExports\n  }\n}\n\nfunction getBasedir (id) {\n  return parse(id).basedir.replace(pathSepExpr, '/')\n}\n\nfunction matchVersion (version, ranges) {\n  return !version || (ranges && ranges.some(range => semver.satisfies(semver.coerce(version), range)))\n}\n\nfunction getVersion (moduleBaseDir) {\n  if (moduleBaseDir) {\n    return requirePackageJson(moduleBaseDir, module).version\n  }\n}\n\nfunction filename (plugin) {\n  return [plugin.name, plugin.file].filter(val => val).join('/')\n}\n\nmodule.exports = Loader\n","'use strict'\n\nconst { storage } = require('../../datadog-core')\n\nconst _default = {\n  debug: msg => console.debug(msg), /* eslint-disable-line no-console */\n  info: msg => console.info(msg), /* eslint-disable-line no-console */\n  warn: msg => console.warn(msg), /* eslint-disable-line no-console */\n  error: msg => console.error(msg) /* eslint-disable-line no-console */\n}\n\n// based on: https://github.com/trentm/node-bunyan#levels\nconst _logLevels = {\n  'debug': 20,\n  'info': 30,\n  'warn': 40,\n  'error': 50\n}\n\nconst _defaultLogLevel = 'debug'\n\nconst _checkLogLevel = (logLevel) => {\n  if (logLevel && typeof logLevel === 'string') {\n    return _logLevels[logLevel.toLowerCase().trim()] || _logLevels[_defaultLogLevel]\n  }\n\n  return _logLevels[_defaultLogLevel]\n}\n\nconst memoize = func => {\n  const cache = {}\n  const memoized = function (key) {\n    if (!cache[key]) {\n      cache[key] = func.apply(this, arguments)\n    }\n\n    return cache[key]\n  }\n\n  return memoized\n}\n\nfunction processMsg (msg) {\n  return typeof msg === 'function' ? msg() : msg\n}\n\nfunction withNoop (fn) {\n  const store = storage.getStore()\n\n  storage.enterWith({ noop: true })\n  fn()\n  storage.enterWith(store)\n}\n\nconst log = {\n  _isLogLevelEnabled (level) {\n    return _logLevels[level] >= this._logLevel\n  },\n\n  use (logger) {\n    if (logger && logger.debug instanceof Function && logger.error instanceof Function) {\n      this._logger = logger\n    }\n\n    return this\n  },\n\n  toggle (enabled, logLevel, tracer) {\n    this._enabled = enabled\n    this._logLevel = _checkLogLevel(logLevel)\n    this._tracer = tracer\n\n    return this\n  },\n\n  reset () {\n    this._logger = _default\n    this._enabled = false\n    this._deprecate = memoize((code, message) => {\n      withNoop(() => this._logger.error(message))\n      return this\n    })\n    this._logLevel = _checkLogLevel()\n\n    return this\n  },\n\n  debug (message) {\n    if (this._enabled && this._isLogLevelEnabled('debug')) {\n      withNoop(() => this._logger.debug(processMsg(message)))\n    }\n\n    return this\n  },\n\n  info (message) {\n    if (!this._logger.info) return this.debug(message)\n    if (this._enabled && this._isLogLevelEnabled('info')) {\n      withNoop(() => this._logger.info(processMsg(message)))\n    }\n\n    return this\n  },\n\n  warn (message) {\n    if (!this._logger.warn) return this.debug(message)\n    if (this._enabled && this._isLogLevelEnabled('warn')) {\n      withNoop(() => this._logger.warn(processMsg(message)))\n    }\n\n    return this\n  },\n\n  error (err) {\n    if (this._enabled && this._isLogLevelEnabled('error')) {\n      if (err instanceof Function) {\n        err = err()\n      }\n\n      if (typeof err !== 'object' || !err) {\n        err = String(err)\n      } else if (!err.stack) {\n        err = String(err.message || err)\n      }\n\n      if (typeof err === 'string') {\n        err = new Error(err)\n      }\n\n      withNoop(() => this._logger.error(err))\n    }\n\n    return this\n  },\n\n  deprecate (code, message) {\n    return this._deprecate(code, message)\n  }\n}\n\nlog.reset()\n\nmodule.exports = log\n","'use strict'\n\n// TODO: capture every second and flush every 10 seconds\n\nconst v8 = require('v8')\nconst os = require('os')\nconst Client = require('./dogstatsd')\nconst log = require('./log')\nconst Histogram = require('./histogram')\n\nconst INTERVAL = 10 * 1000\n\nlet nativeMetrics = null\n\nlet interval\nlet client\nlet time\nlet cpuUsage\nlet gauges\nlet counters\nlet histograms\n\nreset()\n\nmodule.exports = {\n  start (config) {\n    const tags = []\n\n    Object.keys(config.tags)\n      .filter(key => typeof config.tags[key] === 'string')\n      .filter(key => {\n        // Skip runtime-id unless enabled as cardinality may be too high\n        if (key !== 'runtime-id') return true\n        return (config.experimental && config.experimental.runtimeId)\n      })\n      .forEach(key => {\n        // https://docs.datadoghq.com/tagging/#defining-tags\n        const value = config.tags[key].replace(/[^a-z0-9_:./-]/ig, '_')\n\n        tags.push(`${key}:${value}`)\n      })\n\n    try {\n      nativeMetrics = require('@datadog/native-metrics')\n      nativeMetrics.start()\n    } catch (e) {\n      log.error(e)\n      nativeMetrics = null\n    }\n\n    client = new Client({\n      host: config.dogstatsd.hostname,\n      port: config.dogstatsd.port,\n      tags\n    })\n\n    time = process.hrtime()\n\n    if (nativeMetrics) {\n      interval = setInterval(() => {\n        captureCommonMetrics()\n        captureNativeMetrics()\n        client.flush()\n      }, INTERVAL)\n    } else {\n      cpuUsage = process.cpuUsage()\n\n      interval = setInterval(() => {\n        captureCommonMetrics()\n        captureCpuUsage()\n        captureHeapSpace()\n        client.flush()\n      }, INTERVAL)\n    }\n\n    interval.unref()\n  },\n\n  stop () {\n    if (nativeMetrics) {\n      nativeMetrics.stop()\n    }\n\n    clearInterval(interval)\n    reset()\n  },\n\n  track (span) {\n    if (nativeMetrics) {\n      const handle = nativeMetrics.track(span)\n\n      return {\n        finish: () => nativeMetrics.finish(handle)\n      }\n    }\n\n    return { finish: () => {} }\n  },\n\n  boolean (name, value, tag) {\n    this.gauge(name, value ? 1 : 0, tag)\n  },\n\n  histogram (name, value, tag) {\n    if (!client) return\n\n    histograms[name] = histograms[name] || new Map()\n\n    if (!histograms[name].has(tag)) {\n      histograms[name].set(tag, new Histogram())\n    }\n\n    histograms[name].get(tag).record(value)\n  },\n\n  count (name, count, tag, monotonic = false) {\n    if (!client) return\n    if (typeof tag === 'boolean') {\n      monotonic = tag\n      tag = undefined\n    }\n\n    const map = monotonic ? counters : gauges\n\n    map[name] = map[name] || new Map()\n\n    const value = map[name].get(tag) || 0\n\n    map[name].set(tag, value + count)\n  },\n\n  gauge (name, value, tag) {\n    if (!client) return\n\n    gauges[name] = gauges[name] || new Map()\n    gauges[name].set(tag, value)\n  },\n\n  increment (name, tag, monotonic) {\n    this.count(name, 1, tag, monotonic)\n  },\n\n  decrement (name, tag) {\n    this.count(name, -1, tag)\n  }\n}\n\nfunction reset () {\n  interval = null\n  client = null\n  time = null\n  cpuUsage = null\n  gauges = {}\n  counters = {}\n  histograms = {}\n  nativeMetrics = null\n}\n\nfunction captureCpuUsage () {\n  if (!process.cpuUsage) return\n\n  const elapsedTime = process.hrtime(time)\n  const elapsedUsage = process.cpuUsage(cpuUsage)\n\n  time = process.hrtime()\n  cpuUsage = process.cpuUsage()\n\n  const elapsedMs = elapsedTime[0] * 1000 + elapsedTime[1] / 1000000\n  const userPercent = 100 * elapsedUsage.user / 1000 / elapsedMs\n  const systemPercent = 100 * elapsedUsage.system / 1000 / elapsedMs\n  const totalPercent = userPercent + systemPercent\n\n  client.gauge('runtime.node.cpu.system', systemPercent.toFixed(2))\n  client.gauge('runtime.node.cpu.user', userPercent.toFixed(2))\n  client.gauge('runtime.node.cpu.total', totalPercent.toFixed(2))\n}\n\nfunction captureMemoryUsage () {\n  const stats = process.memoryUsage()\n\n  client.gauge('runtime.node.mem.heap_total', stats.heapTotal)\n  client.gauge('runtime.node.mem.heap_used', stats.heapUsed)\n  client.gauge('runtime.node.mem.rss', stats.rss)\n  client.gauge('runtime.node.mem.total', os.totalmem())\n  client.gauge('runtime.node.mem.free', os.freemem())\n\n  stats.external && client.gauge('runtime.node.mem.external', stats.external)\n}\n\nfunction captureProcess () {\n  client.gauge('runtime.node.process.uptime', Math.round(process.uptime()))\n}\n\nfunction captureHeapStats () {\n  const stats = v8.getHeapStatistics()\n\n  client.gauge('runtime.node.heap.total_heap_size', stats.total_heap_size)\n  client.gauge('runtime.node.heap.total_heap_size_executable', stats.total_heap_size_executable)\n  client.gauge('runtime.node.heap.total_physical_size', stats.total_physical_size)\n  client.gauge('runtime.node.heap.total_available_size', stats.total_available_size)\n  client.gauge('runtime.node.heap.heap_size_limit', stats.heap_size_limit)\n\n  stats.malloced_memory && client.gauge('runtime.node.heap.malloced_memory', stats.malloced_memory)\n  stats.peak_malloced_memory && client.gauge('runtime.node.heap.peak_malloced_memory', stats.peak_malloced_memory)\n}\n\nfunction captureHeapSpace () {\n  if (!v8.getHeapSpaceStatistics) return\n\n  const stats = v8.getHeapSpaceStatistics()\n\n  for (let i = 0, l = stats.length; i < l; i++) {\n    const tags = [`space:${stats[i].space_name}`]\n\n    client.gauge('runtime.node.heap.size.by.space', stats[i].space_size, tags)\n    client.gauge('runtime.node.heap.used_size.by.space', stats[i].space_used_size, tags)\n    client.gauge('runtime.node.heap.available_size.by.space', stats[i].space_available_size, tags)\n    client.gauge('runtime.node.heap.physical_size.by.space', stats[i].physical_space_size, tags)\n  }\n}\n\nfunction captureGauges () {\n  Object.keys(gauges).forEach(name => {\n    gauges[name].forEach((value, tag) => {\n      client.gauge(name, value, tag && [tag])\n    })\n  })\n}\n\nfunction captureCounters () {\n  Object.keys(counters).forEach(name => {\n    counters[name].forEach((value, tag) => {\n      client.increment(name, value, tag && [tag])\n    })\n  })\n\n  counters = {}\n}\n\nfunction captureHistograms () {\n  Object.keys(histograms).forEach(name => {\n    histograms[name].forEach((stats, tag) => {\n      histogram(name, stats, tag && [tag])\n      stats.reset()\n    })\n  })\n}\n\nfunction captureCommonMetrics () {\n  captureMemoryUsage()\n  captureProcess()\n  captureHeapStats()\n  captureGauges()\n  captureCounters()\n  captureHistograms()\n}\n\nfunction captureNativeMetrics () {\n  const stats = nativeMetrics.stats()\n  const spaces = stats.heap.spaces\n  const elapsedTime = process.hrtime(time)\n\n  time = process.hrtime()\n\n  const elapsedUs = elapsedTime[0] * 1e6 + elapsedTime[1] / 1e3\n  const userPercent = 100 * stats.cpu.user / elapsedUs\n  const systemPercent = 100 * stats.cpu.system / elapsedUs\n  const totalPercent = userPercent + systemPercent\n\n  client.gauge('runtime.node.cpu.system', systemPercent.toFixed(2))\n  client.gauge('runtime.node.cpu.user', userPercent.toFixed(2))\n  client.gauge('runtime.node.cpu.total', totalPercent.toFixed(2))\n\n  histogram('runtime.node.event_loop.delay', stats.eventLoop)\n\n  Object.keys(stats.gc).forEach(type => {\n    if (type === 'all') {\n      histogram('runtime.node.gc.pause', stats.gc[type])\n    } else {\n      histogram('runtime.node.gc.pause.by.type', stats.gc[type], [`gc_type:${type}`])\n    }\n  })\n\n  for (let i = 0, l = spaces.length; i < l; i++) {\n    const tags = [`heap_space:${spaces[i].space_name}`]\n\n    client.gauge('runtime.node.heap.size.by.space', spaces[i].space_size, tags)\n    client.gauge('runtime.node.heap.used_size.by.space', spaces[i].space_used_size, tags)\n    client.gauge('runtime.node.heap.available_size.by.space', spaces[i].space_available_size, tags)\n    client.gauge('runtime.node.heap.physical_size.by.space', spaces[i].physical_space_size, tags)\n  }\n}\n\nfunction histogram (name, stats, tags) {\n  tags = [].concat(tags)\n\n  client.gauge(`${name}.min`, stats.min, tags)\n  client.gauge(`${name}.max`, stats.max, tags)\n  client.increment(`${name}.sum`, stats.sum, tags)\n  client.increment(`${name}.total`, stats.sum, tags)\n  client.gauge(`${name}.avg`, stats.avg, tags)\n  client.increment(`${name}.count`, stats.count, tags)\n  client.gauge(`${name}.median`, stats.median, tags)\n  client.gauge(`${name}.95percentile`, stats.p95, tags)\n}\n","'use strict'\n\nclass Scope {\n  active () {\n    return null\n  }\n\n  activate (span, callback) {\n    if (typeof callback !== 'function') return callback\n\n    return callback()\n  }\n\n  bind (target, span) {\n    return target\n  }\n\n  unbind (target) {\n    return target\n  }\n}\n\nmodule.exports = Scope\n","'use strict'\n\nconst Span = require('opentracing').Span\nconst NoopSpanContext = require('../noop/span_context')\nconst id = require('../id')\nconst { storage } = require('../../../datadog-core') // TODO: noop storage?\n\nclass NoopSpan extends Span {\n  constructor (tracer, parent) {\n    super()\n\n    this._store = storage.getStore()\n    this._noopTracer = tracer\n    this._noopContext = this._createContext(parent)\n  }\n\n  _context () {\n    return this._noopContext\n  }\n\n  _tracer () {\n    return this._noopTracer\n  }\n\n  _createContext (parent) {\n    const spanId = id()\n\n    if (parent) {\n      return new NoopSpanContext({\n        noop: this,\n        traceId: parent._traceId,\n        spanId,\n        parentId: parent._spanId,\n        baggageItems: Object.assign({}, parent._baggageItems)\n      })\n    } else {\n      return new NoopSpanContext({\n        noop: this,\n        traceId: spanId,\n        spanId\n      })\n    }\n  }\n}\n\nmodule.exports = NoopSpan\n","'use strict'\n\nconst DatadogSpanContext = require('../opentracing/span_context')\nconst priority = require('../../../../ext/priority')\n\nconst USER_REJECT = priority.USER_REJECT\n\nclass NoopSpanContext extends DatadogSpanContext {\n  constructor (props) {\n    super(props)\n\n    this._sampling.priority = USER_REJECT\n  }\n}\n\nmodule.exports = NoopSpanContext\n","'use strict'\n\nconst Tracer = require('opentracing').Tracer\nconst Scope = require('../noop/scope')\nconst Span = require('./span')\n\nclass NoopTracer extends Tracer {\n  constructor (config) {\n    super(config)\n\n    this._scope = new Scope()\n    this._span = new Span(this)\n  }\n\n  trace (name, options, fn) {\n    return fn(this._span, () => {})\n  }\n\n  wrap (name, options, fn) {\n    return fn\n  }\n\n  scope () {\n    return this._scope\n  }\n\n  currentSpan () {\n    return null\n  }\n\n  getRumData () {\n    return ''\n  }\n\n  setUrl () {\n  }\n\n  _startSpan (name, options) {\n    return this._span\n  }\n\n  setUser () {\n    return this\n  }\n}\n\nmodule.exports = NoopTracer\n","'use strict'\n\nclass BinaryPropagator {\n  inject (spanContext, carrier) {}\n\n  extract (carrier) {\n    return null\n  }\n}\n\nmodule.exports = BinaryPropagator\n","'use strict'\n\nconst TextMapPropagator = require('./text_map')\n\nclass HttpPropagator extends TextMapPropagator {}\n\nmodule.exports = HttpPropagator\n","'use strict'\n\nconst id = require('../../id')\nconst DatadogSpanContext = require('../span_context')\n\nclass LogPropagator {\n  constructor (config) {\n    this._config = config\n  }\n\n  inject (spanContext, carrier) {\n    if (!carrier) return\n\n    carrier.dd = {}\n\n    if (spanContext) {\n      carrier.dd.trace_id = spanContext.toTraceId()\n      carrier.dd.span_id = spanContext.toSpanId()\n    }\n\n    if (this._config.service) carrier.dd.service = this._config.service\n    if (this._config.version) carrier.dd.version = this._config.version\n    if (this._config.env) carrier.dd.env = this._config.env\n  }\n\n  extract (carrier) {\n    if (!carrier || !carrier.dd || !carrier.dd.trace_id || !carrier.dd.span_id) {\n      return null\n    }\n\n    const spanContext = new DatadogSpanContext({\n      traceId: id(carrier.dd.trace_id, 10),\n      spanId: id(carrier.dd.span_id, 10)\n    })\n\n    return spanContext\n  }\n}\n\nmodule.exports = LogPropagator\n","'use strict'\n\nconst pick = require('lodash.pick')\nconst id = require('../../id')\nconst DatadogSpanContext = require('../span_context')\nconst log = require('../../log')\n\nconst { AUTO_KEEP, AUTO_REJECT, USER_KEEP } = require('../../../../../ext/priority')\n\nconst traceKey = 'x-datadog-trace-id'\nconst spanKey = 'x-datadog-parent-id'\nconst originKey = 'x-datadog-origin'\nconst samplingKey = 'x-datadog-sampling-priority'\nconst baggagePrefix = 'ot-baggage-'\nconst b3TraceKey = 'x-b3-traceid'\nconst b3TraceExpr = /^([0-9a-f]{16}){1,2}$/i\nconst b3SpanKey = 'x-b3-spanid'\nconst b3SpanExpr = /^[0-9a-f]{16}$/i\nconst b3ParentKey = 'x-b3-parentspanid'\nconst b3SampledKey = 'x-b3-sampled'\nconst b3FlagsKey = 'x-b3-flags'\nconst b3HeaderKey = 'b3'\nconst sqsdHeaderHey = 'x-aws-sqsd-attr-_datadog'\nconst b3HeaderExpr = /^(([0-9a-f]{16}){1,2}-[0-9a-f]{16}(-[01d](-[0-9a-f]{16})?)?|[01d])$/i\nconst baggageExpr = new RegExp(`^${baggagePrefix}(.+)$`)\nconst ddKeys = [traceKey, spanKey, samplingKey, originKey]\nconst b3Keys = [b3TraceKey, b3SpanKey, b3ParentKey, b3SampledKey, b3FlagsKey, b3HeaderKey]\nconst logKeys = ddKeys.concat(b3Keys)\nconst traceparentExpr = /^(\\d{2})-([A-Fa-f0-9]{32})-([A-Fa-f0-9]{16})-(\\d{2})$/i\nconst traceparentKey = 'traceparent'\n\nclass TextMapPropagator {\n  constructor (config) {\n    this._config = config\n  }\n\n  inject (spanContext, carrier) {\n    carrier[traceKey] = spanContext.toTraceId()\n    carrier[spanKey] = spanContext.toSpanId()\n\n    this._injectOrigin(spanContext, carrier)\n    this._injectSamplingPriority(spanContext, carrier)\n    this._injectBaggageItems(spanContext, carrier)\n    this._injectB3(spanContext, carrier)\n    this._injectTraceparent(spanContext, carrier)\n\n    log.debug(() => `Inject into carrier: ${JSON.stringify(pick(carrier, logKeys))}.`)\n  }\n\n  extract (carrier) {\n    const spanContext = this._extractSpanContext(carrier)\n\n    if (!spanContext) return spanContext\n\n    log.debug(() => `Extract from carrier: ${JSON.stringify(pick(carrier, logKeys))}.`)\n\n    return spanContext\n  }\n\n  _injectOrigin (spanContext, carrier) {\n    const origin = spanContext._trace.origin\n\n    if (origin) {\n      carrier[originKey] = origin\n    }\n  }\n\n  _injectSamplingPriority (spanContext, carrier) {\n    const priority = spanContext._sampling.priority\n\n    if (Number.isInteger(priority)) {\n      carrier[samplingKey] = priority.toString()\n    }\n  }\n\n  _injectBaggageItems (spanContext, carrier) {\n    spanContext._baggageItems && Object.keys(spanContext._baggageItems).forEach(key => {\n      carrier[baggagePrefix + key] = String(spanContext._baggageItems[key])\n    })\n  }\n\n  _injectB3 (spanContext, carrier) {\n    if (!this._config.experimental.b3) return\n\n    carrier[b3TraceKey] = spanContext._traceId.toString('hex')\n    carrier[b3SpanKey] = spanContext._spanId.toString('hex')\n    carrier[b3SampledKey] = spanContext._sampling.priority >= AUTO_KEEP ? '1' : '0'\n\n    if (spanContext._sampling.priority > AUTO_KEEP) {\n      carrier[b3FlagsKey] = '1'\n    }\n\n    if (spanContext._parentId) {\n      carrier[b3ParentKey] = spanContext._parentId.toString('hex')\n    }\n  }\n\n  _injectTraceparent (spanContext, carrier) {\n    if (!this._config.experimental.traceparent) return\n\n    const sampling = spanContext._sampling.priority >= AUTO_KEEP ? '01' : '00'\n    const traceId = spanContext._traceId.toString('hex').padStart(32, '0')\n    const spanId = spanContext._spanId.toString('hex').padStart(16, '0')\n    carrier[traceparentKey] = `01-${traceId}-${spanId}-${sampling}`\n  }\n\n  _extractSpanContext (carrier) {\n    return this._extractDatadogContext(carrier) ||\n      this._extractTraceparentContext(carrier) ||\n      this._extractB3Context(carrier) ||\n      this._extractSqsdContext(carrier)\n  }\n\n  _extractDatadogContext (carrier) {\n    const spanContext = this._extractGenericContext(carrier, traceKey, spanKey, 10)\n\n    if (spanContext) {\n      this._extractOrigin(carrier, spanContext)\n      this._extractBaggageItems(carrier, spanContext)\n      this._extractSamplingPriority(carrier, spanContext)\n    }\n\n    return spanContext\n  }\n\n  _extractB3Context (carrier) {\n    if (!this._config.experimental.b3) return null\n\n    const b3 = this._extractB3Headers(carrier)\n    const debug = b3[b3FlagsKey] === '1'\n    const priority = this._getPriority(b3[b3SampledKey], debug)\n    const spanContext = this._extractGenericContext(b3, b3TraceKey, b3SpanKey)\n\n    if (priority !== undefined) {\n      if (!spanContext) {\n        // B3 can force a sampling decision without providing IDs\n        return new DatadogSpanContext({\n          traceId: id(),\n          spanId: null,\n          sampling: { priority }\n        })\n      }\n\n      spanContext._sampling.priority = priority\n    }\n\n    return spanContext\n  }\n\n  _extractSqsdContext (carrier) {\n    const headerValue = carrier[sqsdHeaderHey]\n    if (!headerValue) {\n      return null\n    }\n    let parsed\n    try {\n      parsed = JSON.parse(headerValue)\n    } catch (e) {\n      return null\n    }\n    return this._extractDatadogContext(parsed)\n  }\n\n  _extractTraceparentContext (carrier) {\n    if (!this._config.experimental.traceparent) return null\n\n    const headerValue = carrier[traceparentKey]\n    if (!headerValue) {\n      return null\n    }\n    const matches = headerValue.match(traceparentExpr)\n    if (matches.length) {\n      return new DatadogSpanContext({\n        traceId: id(matches[2], 16),\n        spanId: id(matches[3], 16),\n        sampling: { priority: matches[4] === '01' ? 1 : 0 }\n      })\n    }\n    return null\n  }\n\n  _extractGenericContext (carrier, traceKey, spanKey, radix) {\n    if (carrier[traceKey] && carrier[spanKey]) {\n      return new DatadogSpanContext({\n        traceId: id(carrier[traceKey], radix),\n        spanId: id(carrier[spanKey], radix)\n      })\n    }\n\n    return null\n  }\n\n  _extractB3Headers (carrier) {\n    if (b3HeaderExpr.test(carrier[b3HeaderKey])) {\n      return this._extractB3SingleHeader(carrier)\n    } else {\n      return this._extractB3MultipleHeaders(carrier)\n    }\n  }\n\n  _extractB3MultipleHeaders (carrier) {\n    const b3 = {}\n\n    if (b3TraceExpr.test(carrier[b3TraceKey]) && b3SpanExpr.test(carrier[b3SpanKey])) {\n      b3[b3TraceKey] = carrier[b3TraceKey]\n      b3[b3SpanKey] = carrier[b3SpanKey]\n    }\n\n    if (carrier[b3SampledKey]) {\n      b3[b3SampledKey] = carrier[b3SampledKey]\n    }\n\n    if (carrier[b3FlagsKey]) {\n      b3[b3FlagsKey] = carrier[b3FlagsKey]\n    }\n\n    return b3\n  }\n\n  _extractB3SingleHeader (carrier) {\n    const parts = carrier[b3HeaderKey].split('-')\n\n    if (parts[0] === 'd') {\n      return {\n        [b3SampledKey]: '1',\n        [b3FlagsKey]: '1'\n      }\n    } else if (parts.length === 1) {\n      return {\n        [b3SampledKey]: parts[0]\n      }\n    } else {\n      const b3 = {\n        [b3TraceKey]: parts[0],\n        [b3SpanKey]: parts[1]\n      }\n\n      if (parts[2]) {\n        b3[b3SampledKey] = parts[2] !== '0' ? '1' : '0'\n\n        if (parts[2] === 'd') {\n          b3[b3FlagsKey] = '1'\n        }\n      }\n\n      return b3\n    }\n  }\n\n  _extractOrigin (carrier, spanContext) {\n    const origin = carrier[originKey]\n\n    if (typeof carrier[originKey] === 'string') {\n      spanContext._trace.origin = origin\n    }\n  }\n\n  _extractBaggageItems (carrier, spanContext) {\n    Object.keys(carrier).forEach(key => {\n      const match = key.match(baggageExpr)\n\n      if (match) {\n        spanContext._baggageItems[match[1]] = carrier[key]\n      }\n    })\n  }\n\n  _extractSamplingPriority (carrier, spanContext) {\n    const priority = parseInt(carrier[samplingKey], 10)\n\n    if (Number.isInteger(priority)) {\n      spanContext._sampling.priority = parseInt(carrier[samplingKey], 10)\n    }\n  }\n\n  _getPriority (sampled, debug) {\n    if (debug) {\n      return USER_KEEP\n    } else if (sampled === '1') {\n      return AUTO_KEEP\n    } else if (sampled === '0') {\n      return AUTO_REJECT\n    }\n  }\n}\n\nmodule.exports = TextMapPropagator\n","'use strict'\n\n// TODO (new internal tracer): use DC events for lifecycle metrics and test them\n\nconst opentracing = require('opentracing')\nconst now = require('performance-now')\nconst semver = require('semver')\nconst Span = opentracing.Span\nconst SpanContext = require('./span_context')\nconst id = require('../id')\nconst tagger = require('../tagger')\nconst metrics = require('../metrics')\nconst log = require('../log')\nconst { storage } = require('../../../datadog-core')\n\nconst { DD_TRACE_EXPERIMENTAL_STATE_TRACKING } = process.env\n\nconst unfinishedRegistry = createRegistry('unfinished')\nconst finishedRegistry = createRegistry('finished')\n\nclass DatadogSpan extends Span {\n  constructor (tracer, processor, prioritySampler, fields, debug) {\n    super()\n\n    const operationName = fields.operationName\n    const parent = fields.parent || null\n    const tags = Object.assign({}, fields.tags)\n    const hostname = fields.hostname\n\n    this._parentTracer = tracer\n    this._debug = debug\n    this._processor = processor\n    this._prioritySampler = prioritySampler\n    this._store = storage.getStore()\n    this._name = operationName\n\n    this._spanContext = this._createContext(parent)\n    this._spanContext._name = operationName\n    this._spanContext._tags = tags\n    this._spanContext._hostname = hostname\n\n    this._startTime = fields.startTime || this._getTime()\n\n    if (this._debug && unfinishedRegistry) {\n      metrics.increment('runtime.node.spans.unfinished')\n      metrics.increment('runtime.node.spans.unfinished.by.name', `span_name:${operationName}`)\n\n      unfinishedRegistry.register(this, operationName, this)\n    }\n  }\n\n  toString () {\n    const spanContext = this.context()\n    const resourceName = spanContext._tags['resource.name']\n    const resource = resourceName.length > 100\n      ? `${resourceName.substring(0, 97)}...`\n      : resourceName\n    const json = JSON.stringify({\n      traceId: spanContext._traceId,\n      spanId: spanContext._spanId,\n      parentId: spanContext._parentId,\n      service: spanContext._tags['service.name'],\n      name: spanContext._name,\n      resource\n    })\n\n    return `Span${json}`\n  }\n\n  _createContext (parent) {\n    let spanContext\n\n    if (parent) {\n      spanContext = new SpanContext({\n        traceId: parent._traceId,\n        spanId: id(),\n        parentId: parent._spanId,\n        sampling: parent._sampling,\n        baggageItems: Object.assign({}, parent._baggageItems),\n        trace: parent._trace\n      })\n    } else {\n      const spanId = id()\n      spanContext = new SpanContext({\n        traceId: spanId,\n        spanId\n      })\n    }\n\n    spanContext._trace.started.push(this)\n    spanContext._trace.startTime = spanContext._trace.startTime || Date.now()\n    spanContext._trace.ticks = spanContext._trace.ticks || now()\n\n    return spanContext\n  }\n\n  _getTime () {\n    const { startTime, ticks } = this._spanContext._trace\n\n    return startTime + now() - ticks\n  }\n\n  _context () {\n    return this._spanContext\n  }\n\n  _tracer () {\n    return this._parentTracer\n  }\n\n  _setOperationName (name) {\n    this._spanContext._name = name\n  }\n\n  _setBaggageItem (key, value) {\n    this._spanContext._baggageItems[key] = value\n  }\n\n  _getBaggageItem (key) {\n    return this._spanContext._baggageItems[key]\n  }\n\n  _addTags (keyValuePairs) {\n    tagger.add(this._spanContext._tags, keyValuePairs)\n\n    this._prioritySampler.sample(this, false)\n  }\n\n  _finish (finishTime) {\n    if (this._duration !== undefined) {\n      return\n    }\n\n    if (DD_TRACE_EXPERIMENTAL_STATE_TRACKING === 'true') {\n      if (!this._spanContext._tags['service.name']) {\n        log.error(`Finishing invalid span: ${this}`)\n      }\n    }\n\n    if (this._debug && finishedRegistry) {\n      metrics.decrement('runtime.node.spans.unfinished')\n      metrics.decrement('runtime.node.spans.unfinished.by.name', `span_name:${this._name}`)\n      metrics.increment('runtime.node.spans.finished')\n      metrics.increment('runtime.node.spans.finished.by.name', `span_name:${this._name}`)\n\n      unfinishedRegistry.unregister(this)\n      finishedRegistry.register(this, this._name)\n    }\n\n    finishTime = parseFloat(finishTime) || this._getTime()\n\n    this._duration = finishTime - this._startTime\n    this._spanContext._trace.finished.push(this)\n    this._spanContext._isFinished = true\n    this._processor.process(this)\n  }\n}\n\nfunction createRegistry (type) {\n  if (!semver.satisfies(process.version, '>=14.6')) return\n\n  return new global.FinalizationRegistry(name => {\n    metrics.decrement(`runtime.node.spans.${type}`)\n    metrics.decrement(`runtime.node.spans.${type}.by.name`, [`span_name:${name}`])\n  })\n}\n\nmodule.exports = DatadogSpan\n","'use strict'\n\nconst SpanContext = require('opentracing').SpanContext\n\nclass DatadogSpanContext extends SpanContext {\n  constructor (props) {\n    super()\n\n    props = props || {}\n\n    this._traceId = props.traceId\n    this._spanId = props.spanId\n    this._parentId = props.parentId || null\n    this._name = props.name\n    this._isFinished = props.isFinished || false\n    this._tags = props.tags || {}\n    this._sampling = props.sampling || {}\n    this._baggageItems = props.baggageItems || {}\n    this._noop = props.noop || null\n    this._trace = props.trace || {\n      started: [],\n      finished: [],\n      tags: {}\n    }\n  }\n\n  toTraceId () {\n    return this._traceId.toString(10)\n  }\n\n  toSpanId () {\n    return this._spanId.toString(10)\n  }\n}\n\nmodule.exports = DatadogSpanContext\n","'use strict'\n\nconst opentracing = require('opentracing')\nconst os = require('os')\nconst Tracer = opentracing.Tracer\nconst Reference = opentracing.Reference\nconst Span = require('./span')\nconst SpanContext = require('./span_context')\nconst SpanProcessor = require('../span_processor')\nconst PrioritySampler = require('../priority_sampler')\nconst TextMapPropagator = require('./propagation/text_map')\nconst HttpPropagator = require('./propagation/http')\nconst BinaryPropagator = require('./propagation/binary')\nconst LogPropagator = require('./propagation/log')\nconst formats = require('../../../../ext/formats')\n\nconst log = require('../log')\nconst metrics = require('../metrics')\nconst getExporter = require('../exporter')\n\nconst REFERENCE_CHILD_OF = opentracing.REFERENCE_CHILD_OF\nconst REFERENCE_FOLLOWS_FROM = opentracing.REFERENCE_FOLLOWS_FROM\n\nclass DatadogTracer extends Tracer {\n  constructor (config) {\n    super()\n\n    const Exporter = getExporter(config.experimental.exporter)\n\n    this._service = config.service\n    this._version = config.version\n    this._env = config.env\n    this._tags = config.tags\n    this._logInjection = config.logInjection\n    this._debug = config.debug\n    this._prioritySampler = new PrioritySampler(config.env, config.experimental.sampler)\n    this._exporter = new Exporter(config, this._prioritySampler)\n    this._processor = new SpanProcessor(this._exporter, this._prioritySampler, config)\n    this._url = this._exporter._url\n    this._enableGetRumData = config.experimental.enableGetRumData\n    this._propagators = {\n      [formats.TEXT_MAP]: new TextMapPropagator(config),\n      [formats.HTTP_HEADERS]: new HttpPropagator(config),\n      [formats.BINARY]: new BinaryPropagator(config),\n      [formats.LOG]: new LogPropagator(config)\n    }\n    if (config.reportHostname) {\n      this._hostname = os.hostname()\n    }\n  }\n\n  _startSpan (name, fields) {\n    const reference = getParent(fields.references)\n    const parent = reference && reference.referencedContext()\n    return this._startSpanInternal(name, fields, parent)\n  }\n\n  _startSpanInternal (name, fields = {}, parent) {\n    const tags = {\n      'service.name': this._service\n    }\n\n    const span = new Span(this, this._processor, this._prioritySampler, {\n      operationName: fields.operationName || name,\n      parent,\n      tags,\n      startTime: fields.startTime,\n      hostname: this._hostname\n    }, this._debug)\n\n    span.addTags(this._tags)\n    span.addTags(fields.tags)\n\n    return span\n  }\n\n  _inject (spanContext, format, carrier) {\n    try {\n      this._prioritySampler.sample(spanContext)\n      this._propagators[format].inject(spanContext, carrier)\n    } catch (e) {\n      log.error(e)\n      metrics.increment('datadog.tracer.node.inject.errors', true)\n    }\n\n    return this\n  }\n\n  _extract (format, carrier) {\n    try {\n      return this._propagators[format].extract(carrier)\n    } catch (e) {\n      log.error(e)\n      metrics.increment('datadog.tracer.node.extract.errors', true)\n      return null\n    }\n  }\n}\n\nfunction getParent (references = []) {\n  let parent = null\n\n  for (let i = 0; i < references.length; i++) {\n    const ref = references[i]\n\n    if (!(ref instanceof Reference)) {\n      log.error(() => `Expected ${ref} to be an instance of opentracing.Reference`)\n      continue\n    }\n\n    const spanContext = ref.referencedContext()\n    const type = ref.type()\n\n    if (spanContext && !(spanContext instanceof SpanContext)) {\n      log.error(() => `Expected ${spanContext} to be an instance of SpanContext`)\n      continue\n    }\n\n    if (type === REFERENCE_CHILD_OF) {\n      parent = ref\n      break\n    } else if (type === REFERENCE_FOLLOWS_FROM) {\n      if (!parent) {\n        parent = ref\n      }\n    }\n  }\n\n  return parent\n}\n\nmodule.exports = DatadogTracer\n","'use strict'\n\nconst fs = require('fs')\nconst path = require('path')\n\nfunction findRoot () {\n  return require.main && require.main.filename\n    ? path.dirname(require.main.filename)\n    : process.cwd()\n}\n\nfunction findPkg () {\n  const cwd = findRoot()\n  const directory = path.resolve(cwd)\n  const res = path.parse(directory)\n\n  if (!res) return {}\n\n  const { root } = res\n\n  const filePath = findUp('package.json', root, directory)\n\n  try {\n    return JSON.parse(fs.readFileSync(filePath, 'utf8'))\n  } catch (e) {\n    return {}\n  }\n}\n\nfunction findUp (name, root, directory) {\n  while (true) {\n    const current = path.resolve(directory, name)\n\n    if (fs.existsSync(current)) return current\n\n    if (directory === root) return\n\n    directory = path.dirname(directory)\n  }\n}\n\nmodule.exports = Object.assign(findPkg(), { findRoot, findUp })\n","'use strict'\n\nconst { isTrue } = require('./util')\nconst plugins = require('./plugins')\n\n// instrument everything that needs Plugin System V2 instrumentation\nrequire('../../datadog-instrumentations')\n\n// TODO this is shared w/ instrumenter. DRY up.\nfunction getConfig (name, config = {}) {\n  const enabled = process.env[`DD_TRACE_${name.toUpperCase()}_ENABLED`.replace(/[^a-z0-9_]/ig, '_')]\n  if (enabled !== undefined) {\n    config.enabled = isTrue(enabled)\n  }\n\n  // TODO is this the best/correct place for this default?\n  if (!('enabled' in config)) {\n    config.enabled = true\n  }\n\n  return config\n}\n\n// TODO actually ... should we be looking at envrionment variables this deep down in the code?\n\n// TODO this must always be a singleton.\nmodule.exports = class PluginManager {\n  constructor (tracer) {\n    this._pluginsByName = {}\n    for (const PluginClass of Object.values(plugins)) {\n      if (typeof PluginClass !== 'function') continue\n      this._pluginsByName[PluginClass.name] = new PluginClass(tracer)\n    }\n  }\n\n  // like instrumenter.use()\n  configurePlugin (name, pluginConfig) {\n    if (!(name in this._pluginsByName)) return\n    if (typeof pluginConfig === 'boolean') {\n      pluginConfig = { enabled: pluginConfig }\n    }\n\n    this._pluginsByName[name].configure(getConfig(name, pluginConfig))\n  }\n\n  // like instrumenter.enable()\n  configure (config) {\n    const serviceMapping = config.serviceMapping\n\n    if (config.plugins !== false) {\n      for (const name in this._pluginsByName) {\n        const pluginConfig = {}\n        if (serviceMapping && serviceMapping[name]) {\n          pluginConfig.service = serviceMapping[name]\n        }\n        this.configurePlugin(name, pluginConfig)\n      }\n    } else {\n      for (const name in this._pluginsByName) {\n        this.configurePlugin(name, false)\n      }\n    }\n  }\n\n  // This is basically just for testing. like intrumenter.disable()\n  destroy () {\n    for (const name in this._pluginsByName) this._pluginsByName[name].configure({ enabled: false })\n  }\n}\n","'use strict'\n\nmodule.exports = {\n  'amqp10': require('../../../datadog-plugin-amqp10/src'),\n  'amqplib': require('../../../datadog-plugin-amqplib/src'),\n  'aws-sdk': require('../../../datadog-plugin-aws-sdk/src'),\n  'bunyan': require('../../../datadog-plugin-bunyan/src'),\n  'cassandra-driver': require('../../../datadog-plugin-cassandra-driver/src'),\n  'connect': require('../../../datadog-plugin-connect/src'),\n  'couchbase': require('../../../datadog-plugin-couchbase/src'),\n  'cucumber': require('../../../datadog-plugin-cucumber/src'),\n  'cypress': require('../../../datadog-plugin-cypress/src'),\n  'dns': require('../../../datadog-plugin-dns/src'),\n  'elasticsearch': require('../../../datadog-plugin-elasticsearch/src'),\n  'express': require('../../../datadog-plugin-express/src'),\n  'fastify': require('../../../datadog-plugin-fastify/src'),\n  'fs': require('../../../datadog-plugin-fs/src'),\n  'google-cloud-pubsub': require('../../../datadog-plugin-google-cloud-pubsub/src'),\n  'graphql': require('../../../datadog-plugin-graphql/src'),\n  'grpc': require('../../../datadog-plugin-grpc/src'),\n  'hapi': require('../../../datadog-plugin-hapi/src'),\n  'http': require('../../../datadog-plugin-http/src'),\n  'http2': require('../../../datadog-plugin-http2/src'),\n  'ioredis': require('../../../datadog-plugin-ioredis/src'),\n  'jest': require('../../../datadog-plugin-jest/src'),\n  'knex': require('../../../datadog-plugin-knex/src'),\n  'koa': require('../../../datadog-plugin-koa/src'),\n  'kafkajs': require('../../../datadog-plugin-kafkajs/src'),\n  'limitd-client': require('../../../datadog-plugin-limitd-client/src'),\n  'memcached': require('../../../datadog-plugin-memcached/src'),\n  'microgateway-core': require('../../../datadog-plugin-microgateway-core/src'),\n  'mocha': require('../../../datadog-plugin-mocha/src'),\n  'moleculer': require('../../../datadog-plugin-moleculer/src'),\n  'mongodb-core': require('../../../datadog-plugin-mongodb-core/src'),\n  'mysql': require('../../../datadog-plugin-mysql/src'),\n  'mysql2': require('../../../datadog-plugin-mysql2/src'),\n  'net': require('../../../datadog-plugin-net/src'),\n  'next': require('../../../datadog-plugin-next/src'),\n  'oracledb': require('../../../datadog-plugin-oracledb/src'),\n  'paperplane': require('../../../datadog-plugin-paperplane/src'),\n  'pg': require('../../../datadog-plugin-pg/src'),\n  'pino': require('../../../datadog-plugin-pino/src'),\n  'redis': require('../../../datadog-plugin-redis/src'),\n  'restify': require('../../../datadog-plugin-restify/src'),\n  'rhea': require('../../../datadog-plugin-rhea/src'),\n  'router': require('../../../datadog-plugin-router/src'),\n  'sharedb': require('../../../datadog-plugin-sharedb/src'),\n  'tedious': require('../../../datadog-plugin-tedious/src'),\n  'winston': require('../../../datadog-plugin-winston/src')\n}\n","'use strict'\n\nconst { LOG } = require('../../../../ext/formats')\nconst Plugin = require('./plugin')\nconst { storage } = require('../../../datadog-core')\n\nconst hasOwn = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop)\n\nfunction messageProxy (message, holder) {\n  return new Proxy(message, {\n    get (target, p, receiver) {\n      switch (p) {\n        case Symbol.toStringTag:\n          return Object.prototype.toString.call(target).slice(8, -1)\n        case 'dd':\n          return holder.dd\n        default:\n          return Reflect.get(target, p, receiver)\n      }\n    },\n    ownKeys (target) {\n      const ownKeys = Reflect.ownKeys(target)\n      return hasOwn(target, 'dd') ? ownKeys : ['dd', ...ownKeys]\n    },\n    getOwnPropertyDescriptor (target, p) {\n      return Reflect.getOwnPropertyDescriptor(p === 'dd' ? holder : target, p)\n    }\n  })\n}\n\nmodule.exports = class LogPlugin extends Plugin {\n  constructor (...args) {\n    super(...args)\n    this.addSub(`apm:${this.constructor.name}:log`, (arg) => {\n      // TODO rather than checking this every time, setting it ought to enable/disable any plugin\n      // extending from this one\n      if (!this.tracer._logInjection) return\n\n      const store = storage.getStore()\n      const span = store && store.span\n\n      if (!span) return\n\n      const holder = {}\n      this.tracer.inject(span, LOG, holder)\n      arg.message = messageProxy(arg.message, holder)\n    })\n  }\n}\n","'use strict'\n\nconst dc = require('diagnostics_channel')\nconst { storage } = require('../../../datadog-core')\n\nclass Subscription {\n  constructor (event, handler) {\n    this._channel = dc.channel(event)\n    this._handler = (message, name) => {\n      const store = storage.getStore()\n      if (!store || !store.noop) {\n        handler(message, name)\n      }\n    }\n  }\n\n  enable () {\n    this._channel.subscribe(this._handler)\n  }\n\n  disable () {\n    this._channel.unsubscribe(this._handler)\n  }\n}\n\nmodule.exports = class Plugin {\n  constructor (tracer) {\n    this._subscriptions = []\n    this._enabled = false\n    this._storeStack = []\n    this._tracer = tracer\n  }\n\n  get tracer () {\n    return this._tracer._tracer\n  }\n\n  enter (span, store) {\n    store = store || storage.getStore()\n    this._storeStack.push(store)\n    storage.enterWith({ ...store, span })\n  }\n\n  /** Prevents creation of spans here and for all async descendants. */\n  skip () {\n    const store = storage.getStore()\n    this._storeStack.push(store)\n    storage.enterWith({ noop: true })\n  }\n\n  exit () {\n    storage.enterWith(this._storeStack.pop())\n  }\n\n  addSub (channelName, handler) {\n    this._subscriptions.push(new Subscription(channelName, handler))\n  }\n\n  configure (config) {\n    if (typeof config === 'boolean') {\n      config = { enabled: config }\n    }\n    this.config = config\n    if (config.enabled && !this._enabled) {\n      this._enabled = true\n      this._subscriptions.forEach(sub => sub.enable())\n    } else if (!config.enabled && this._enabled) {\n      this._enabled = false\n      this._subscriptions.forEach(sub => sub.disable())\n    }\n  }\n}\n","const URL = require('url').URL\n\nconst {\n  GIT_BRANCH,\n  GIT_COMMIT_SHA,\n  GIT_TAG,\n  GIT_COMMIT_AUTHOR_EMAIL,\n  GIT_COMMIT_AUTHOR_NAME,\n  GIT_COMMIT_MESSAGE,\n  GIT_COMMIT_AUTHOR_DATE,\n  GIT_REPOSITORY_URL,\n  CI_PIPELINE_ID,\n  CI_PIPELINE_NAME,\n  CI_PIPELINE_NUMBER,\n  CI_PIPELINE_URL,\n  CI_PROVIDER_NAME,\n  CI_WORKSPACE_PATH,\n  CI_JOB_URL,\n  CI_JOB_NAME,\n  CI_STAGE_NAME\n} = require('./tags')\n\n// Receives a string with the form 'John Doe <john.doe@gmail.com>'\n// and returns { name: 'John Doe', email: 'john.doe@gmail.com' }\nfunction parseEmailAndName (emailAndName) {\n  if (!emailAndName) {\n    return { name: '', email: '' }\n  }\n  let name = ''\n  let email = ''\n  const matchNameAndEmail = emailAndName.match(/(?:\"?([^\"]*)\"?\\s)?(?:<?(.+@[^>]+)>?)/)\n  if (matchNameAndEmail) {\n    name = matchNameAndEmail[1]\n    email = matchNameAndEmail[2]\n  }\n\n  return { name, email }\n}\n\nfunction removeEmptyValues (tags) {\n  return Object.keys(tags).reduce((filteredTags, tag) => {\n    if (!tags[tag]) {\n      return filteredTags\n    }\n    return {\n      ...filteredTags,\n      [tag]: tags[tag]\n    }\n  }, {})\n}\n\nfunction normalizeTag (targetTags, tagKey, normalize) {\n  if (targetTags[tagKey]) {\n    targetTags[tagKey] = normalize(targetTags[tagKey])\n  }\n}\n\nfunction normalizeRef (ref) {\n  if (!ref) {\n    return ref\n  }\n  return ref.replace(/origin\\/|refs\\/heads\\/|tags\\//gm, '')\n}\n\nfunction filterSensitiveInfoFromRepository (repositoryUrl) {\n  if (repositoryUrl.startsWith('git@')) {\n    return repositoryUrl\n  }\n\n  try {\n    const { protocol, hostname, pathname } = new URL(repositoryUrl)\n\n    return `${protocol}//${hostname}${pathname}`\n  } catch (e) {\n    return repositoryUrl\n  }\n}\n\nfunction resolveTilde (filePath) {\n  if (!filePath || typeof filePath !== 'string') {\n    return ''\n  }\n  // '~/folder/path' or '~'\n  if (filePath[0] === '~' && (filePath[1] === '/' || filePath.length === 1)) {\n    return filePath.replace('~', process.env.HOME)\n  }\n  return filePath\n}\n\nmodule.exports = {\n  normalizeRef,\n  getCIMetadata () {\n    const { env } = process\n\n    let tags = {}\n\n    if (env.JENKINS_URL) {\n      const {\n        WORKSPACE,\n        BUILD_TAG,\n        JOB_NAME,\n        BUILD_NUMBER,\n        BUILD_URL,\n        GIT_BRANCH: JENKINS_GIT_BRANCH,\n        GIT_COMMIT: JENKINS_GIT_COMMIT,\n        GIT_URL: JENKINS_GIT_REPOSITORY_URL,\n        GIT_URL_1: JENKINS_GIT_REPOSITORY_URL_1\n      } = env\n\n      tags = {\n        [CI_PIPELINE_ID]: BUILD_TAG,\n        [CI_PIPELINE_NUMBER]: BUILD_NUMBER,\n        [CI_PIPELINE_URL]: BUILD_URL,\n        [CI_PROVIDER_NAME]: 'jenkins',\n        [GIT_COMMIT_SHA]: JENKINS_GIT_COMMIT,\n        [GIT_REPOSITORY_URL]: JENKINS_GIT_REPOSITORY_URL || JENKINS_GIT_REPOSITORY_URL_1,\n        [CI_WORKSPACE_PATH]: WORKSPACE\n      }\n\n      const isTag = JENKINS_GIT_BRANCH && JENKINS_GIT_BRANCH.includes('tags')\n      const refKey = isTag ? GIT_TAG : GIT_BRANCH\n      const ref = normalizeRef(JENKINS_GIT_BRANCH)\n\n      tags[refKey] = ref\n\n      let finalPipelineName = ''\n      if (JOB_NAME) {\n        // Job names can contain parameters, e.g. jobName/KEY1=VALUE1,KEY2=VALUE2/branchName\n        const jobNameAndParams = JOB_NAME.split('/')\n        if (jobNameAndParams.length > 1 && jobNameAndParams[1].includes('=')) {\n          finalPipelineName = jobNameAndParams[0]\n        } else {\n          finalPipelineName = JOB_NAME.replace(`/${ref}`, '')\n        }\n        tags[CI_PIPELINE_NAME] = finalPipelineName\n      }\n    }\n\n    if (env.GITLAB_CI) {\n      const {\n        CI_PIPELINE_ID: GITLAB_PIPELINE_ID,\n        CI_PROJECT_PATH,\n        CI_PIPELINE_IID,\n        CI_PIPELINE_URL: GITLAB_PIPELINE_URL,\n        CI_PROJECT_DIR,\n        CI_COMMIT_REF_NAME,\n        CI_COMMIT_TAG,\n        CI_COMMIT_SHA,\n        CI_REPOSITORY_URL,\n        CI_JOB_URL: GITLAB_CI_JOB_URL,\n        CI_JOB_STAGE,\n        CI_JOB_NAME: GITLAB_CI_JOB_NAME,\n        CI_COMMIT_MESSAGE,\n        CI_COMMIT_TIMESTAMP,\n        CI_COMMIT_AUTHOR\n      } = env\n\n      const { name, email } = parseEmailAndName(CI_COMMIT_AUTHOR)\n\n      tags = {\n        [CI_PIPELINE_ID]: GITLAB_PIPELINE_ID,\n        [CI_PIPELINE_NAME]: CI_PROJECT_PATH,\n        [CI_PIPELINE_NUMBER]: CI_PIPELINE_IID,\n        [CI_PROVIDER_NAME]: 'gitlab',\n        [GIT_COMMIT_SHA]: CI_COMMIT_SHA,\n        [GIT_REPOSITORY_URL]: CI_REPOSITORY_URL,\n        [CI_JOB_URL]: GITLAB_CI_JOB_URL,\n        [GIT_TAG]: CI_COMMIT_TAG,\n        [GIT_BRANCH]: CI_COMMIT_REF_NAME,\n        [CI_WORKSPACE_PATH]: CI_PROJECT_DIR,\n        [CI_PIPELINE_URL]: GITLAB_PIPELINE_URL && GITLAB_PIPELINE_URL.replace('/-/pipelines/', '/pipelines/'),\n        [CI_STAGE_NAME]: CI_JOB_STAGE,\n        [CI_JOB_NAME]: GITLAB_CI_JOB_NAME,\n        [GIT_COMMIT_MESSAGE]: CI_COMMIT_MESSAGE,\n        [GIT_COMMIT_AUTHOR_NAME]: name,\n        [GIT_COMMIT_AUTHOR_EMAIL]: email,\n        [GIT_COMMIT_AUTHOR_DATE]: CI_COMMIT_TIMESTAMP\n      }\n    }\n\n    if (env.CIRCLECI) {\n      const {\n        CIRCLE_WORKFLOW_ID,\n        CIRCLE_PROJECT_REPONAME,\n        CIRCLE_BUILD_URL,\n        CIRCLE_WORKING_DIRECTORY,\n        CIRCLE_BRANCH,\n        CIRCLE_TAG,\n        CIRCLE_SHA1,\n        CIRCLE_REPOSITORY_URL,\n        CIRCLE_JOB\n      } = env\n\n      const pipelineUrl = `https://app.circleci.com/pipelines/workflows/${CIRCLE_WORKFLOW_ID}`\n\n      tags = {\n        [CI_PIPELINE_ID]: CIRCLE_WORKFLOW_ID,\n        [CI_PIPELINE_NAME]: CIRCLE_PROJECT_REPONAME,\n        [CI_PIPELINE_URL]: pipelineUrl,\n        [CI_JOB_NAME]: CIRCLE_JOB,\n        [CI_PROVIDER_NAME]: 'circleci',\n        [GIT_COMMIT_SHA]: CIRCLE_SHA1,\n        [GIT_REPOSITORY_URL]: CIRCLE_REPOSITORY_URL,\n        [CI_JOB_URL]: CIRCLE_BUILD_URL,\n        [CI_WORKSPACE_PATH]: CIRCLE_WORKING_DIRECTORY,\n        [CIRCLE_TAG ? GIT_TAG : GIT_BRANCH]: CIRCLE_TAG || CIRCLE_BRANCH\n      }\n    }\n\n    if (env.GITHUB_ACTIONS || env.GITHUB_ACTION) {\n      const {\n        GITHUB_RUN_ID,\n        GITHUB_WORKFLOW,\n        GITHUB_RUN_NUMBER,\n        GITHUB_WORKSPACE,\n        GITHUB_HEAD_REF,\n        GITHUB_REF,\n        GITHUB_SHA,\n        GITHUB_REPOSITORY,\n        GITHUB_SERVER_URL,\n        GITHUB_RUN_ATTEMPT\n      } = env\n\n      const repositoryURL = `${GITHUB_SERVER_URL}/${GITHUB_REPOSITORY}.git`\n      let pipelineURL = `${GITHUB_SERVER_URL}/${GITHUB_REPOSITORY}/actions/runs/${GITHUB_RUN_ID}`\n\n      if (GITHUB_RUN_ATTEMPT) {\n        pipelineURL = `${pipelineURL}/attempts/${GITHUB_RUN_ATTEMPT}`\n      }\n\n      const jobUrl = `${GITHUB_SERVER_URL}/${GITHUB_REPOSITORY}/commit/${GITHUB_SHA}/checks`\n\n      const ref = GITHUB_HEAD_REF || GITHUB_REF || ''\n      const refKey = ref.includes('tags') ? GIT_TAG : GIT_BRANCH\n\n      tags = {\n        [CI_PIPELINE_ID]: GITHUB_RUN_ID,\n        [CI_PIPELINE_NAME]: GITHUB_WORKFLOW,\n        [CI_PIPELINE_NUMBER]: GITHUB_RUN_NUMBER,\n        [CI_PIPELINE_URL]: pipelineURL,\n        [CI_PROVIDER_NAME]: 'github',\n        [GIT_COMMIT_SHA]: GITHUB_SHA,\n        [GIT_REPOSITORY_URL]: repositoryURL,\n        [CI_JOB_URL]: jobUrl,\n        [CI_WORKSPACE_PATH]: GITHUB_WORKSPACE,\n        [refKey]: ref\n      }\n    }\n\n    if (env.APPVEYOR) {\n      const {\n        APPVEYOR_REPO_NAME,\n        APPVEYOR_REPO_PROVIDER,\n        APPVEYOR_BUILD_FOLDER,\n        APPVEYOR_BUILD_ID,\n        APPVEYOR_BUILD_NUMBER,\n        APPVEYOR_REPO_COMMIT,\n        APPVEYOR_PULL_REQUEST_HEAD_REPO_BRANCH,\n        APPVEYOR_REPO_BRANCH,\n        APPVEYOR_REPO_TAG_NAME,\n        APPVEYOR_REPO_COMMIT_AUTHOR,\n        APPVEYOR_REPO_COMMIT_AUTHOR_EMAIL,\n        APPVEYOR_REPO_COMMIT_MESSAGE_EXTENDED\n      } = env\n\n      const pipelineUrl = `https://ci.appveyor.com/project/${APPVEYOR_REPO_NAME}/builds/${APPVEYOR_BUILD_ID}`\n\n      tags = {\n        [CI_PROVIDER_NAME]: 'appveyor',\n        [CI_PIPELINE_URL]: pipelineUrl,\n        [CI_PIPELINE_ID]: APPVEYOR_BUILD_ID,\n        [CI_PIPELINE_NAME]: APPVEYOR_REPO_NAME,\n        [CI_PIPELINE_NUMBER]: APPVEYOR_BUILD_NUMBER,\n        [CI_JOB_URL]: pipelineUrl,\n        [CI_WORKSPACE_PATH]: APPVEYOR_BUILD_FOLDER,\n        [GIT_COMMIT_AUTHOR_NAME]: APPVEYOR_REPO_COMMIT_AUTHOR,\n        [GIT_COMMIT_AUTHOR_EMAIL]: APPVEYOR_REPO_COMMIT_AUTHOR_EMAIL,\n        [GIT_COMMIT_MESSAGE]: APPVEYOR_REPO_COMMIT_MESSAGE_EXTENDED\n      }\n\n      if (APPVEYOR_REPO_PROVIDER === 'github') {\n        const refKey = APPVEYOR_REPO_TAG_NAME ? GIT_TAG : GIT_BRANCH\n        const ref = APPVEYOR_REPO_TAG_NAME || APPVEYOR_PULL_REQUEST_HEAD_REPO_BRANCH || APPVEYOR_REPO_BRANCH\n        tags = {\n          ...tags,\n          [GIT_REPOSITORY_URL]: `https://github.com/${APPVEYOR_REPO_NAME}.git`,\n          [GIT_COMMIT_SHA]: APPVEYOR_REPO_COMMIT,\n          [refKey]: ref\n        }\n      }\n    }\n\n    if (env.TF_BUILD) {\n      const {\n        BUILD_SOURCESDIRECTORY,\n        BUILD_BUILDID,\n        BUILD_DEFINITIONNAME,\n        SYSTEM_TEAMFOUNDATIONSERVERURI,\n        SYSTEM_TEAMPROJECTID,\n        SYSTEM_JOBID,\n        SYSTEM_TASKINSTANCEID,\n        SYSTEM_PULLREQUEST_SOURCEBRANCH,\n        BUILD_SOURCEBRANCH,\n        BUILD_SOURCEBRANCHNAME,\n        SYSTEM_PULLREQUEST_SOURCECOMMITID,\n        SYSTEM_PULLREQUEST_SOURCEREPOSITORYURI,\n        BUILD_REPOSITORY_URI,\n        BUILD_SOURCEVERSION,\n        BUILD_REQUESTEDFORID,\n        BUILD_REQUESTEDFOREMAIL,\n        BUILD_SOURCEVERSIONMESSAGE,\n        SYSTEM_STAGEDISPLAYNAME,\n        SYSTEM_JOBDISPLAYNAME\n      } = env\n\n      const ref = SYSTEM_PULLREQUEST_SOURCEBRANCH || BUILD_SOURCEBRANCH || BUILD_SOURCEBRANCHNAME\n      const refKey = (ref || '').includes('tags') ? GIT_TAG : GIT_BRANCH\n\n      tags = {\n        [CI_PROVIDER_NAME]: 'azurepipelines',\n        [CI_PIPELINE_ID]: BUILD_BUILDID,\n        [CI_PIPELINE_NAME]: BUILD_DEFINITIONNAME,\n        [CI_PIPELINE_NUMBER]: BUILD_BUILDID,\n        [GIT_COMMIT_SHA]: SYSTEM_PULLREQUEST_SOURCECOMMITID || BUILD_SOURCEVERSION,\n        [CI_WORKSPACE_PATH]: BUILD_SOURCESDIRECTORY,\n        [GIT_REPOSITORY_URL]: SYSTEM_PULLREQUEST_SOURCEREPOSITORYURI || BUILD_REPOSITORY_URI,\n        [refKey]: ref,\n        [GIT_COMMIT_AUTHOR_NAME]: BUILD_REQUESTEDFORID,\n        [GIT_COMMIT_AUTHOR_EMAIL]: BUILD_REQUESTEDFOREMAIL,\n        [GIT_COMMIT_MESSAGE]: BUILD_SOURCEVERSIONMESSAGE,\n        [CI_STAGE_NAME]: SYSTEM_STAGEDISPLAYNAME,\n        [CI_JOB_NAME]: SYSTEM_JOBDISPLAYNAME\n      }\n\n      if (SYSTEM_TEAMFOUNDATIONSERVERURI && SYSTEM_TEAMPROJECTID && BUILD_BUILDID) {\n        const baseUrl =\n          `${SYSTEM_TEAMFOUNDATIONSERVERURI}${SYSTEM_TEAMPROJECTID}/_build/results?buildId=${BUILD_BUILDID}`\n        const pipelineUrl = baseUrl\n        const jobUrl = `${baseUrl}&view=logs&j=${SYSTEM_JOBID}&t=${SYSTEM_TASKINSTANCEID}`\n\n        tags = {\n          ...tags,\n          [CI_PIPELINE_URL]: pipelineUrl,\n          [CI_JOB_URL]: jobUrl\n        }\n      }\n    }\n\n    if (env.BITBUCKET_COMMIT) {\n      const {\n        BITBUCKET_REPO_FULL_NAME,\n        BITBUCKET_BUILD_NUMBER,\n        BITBUCKET_BRANCH,\n        BITBUCKET_COMMIT,\n        BITBUCKET_GIT_SSH_ORIGIN,\n        BITBUCKET_TAG,\n        BITBUCKET_PIPELINE_UUID,\n        BITBUCKET_CLONE_DIR\n      } = env\n\n      const url =\n        `https://bitbucket.org/${BITBUCKET_REPO_FULL_NAME}/addon/pipelines/home#!/results/${BITBUCKET_BUILD_NUMBER}`\n\n      tags = {\n        [CI_PROVIDER_NAME]: 'bitbucket',\n        [GIT_COMMIT_SHA]: BITBUCKET_COMMIT,\n        [CI_PIPELINE_NUMBER]: BITBUCKET_BUILD_NUMBER,\n        [CI_PIPELINE_NAME]: BITBUCKET_REPO_FULL_NAME,\n        [CI_JOB_URL]: url,\n        [CI_PIPELINE_URL]: url,\n        [GIT_BRANCH]: BITBUCKET_BRANCH,\n        [GIT_TAG]: BITBUCKET_TAG,\n        [GIT_REPOSITORY_URL]: BITBUCKET_GIT_SSH_ORIGIN,\n        [CI_WORKSPACE_PATH]: BITBUCKET_CLONE_DIR,\n        [CI_PIPELINE_ID]: BITBUCKET_PIPELINE_UUID && BITBUCKET_PIPELINE_UUID.replace(/{|}/gm, '')\n      }\n    }\n\n    if (env.BITRISE_BUILD_SLUG) {\n      const {\n        BITRISE_GIT_COMMIT,\n        GIT_CLONE_COMMIT_HASH,\n        BITRISEIO_GIT_BRANCH_DEST,\n        BITRISE_GIT_BRANCH,\n        BITRISE_BUILD_SLUG,\n        BITRISE_TRIGGERED_WORKFLOW_ID,\n        BITRISE_BUILD_NUMBER,\n        BITRISE_BUILD_URL,\n        BITRISE_SOURCE_DIR,\n        GIT_REPOSITORY_URL: BITRISE_GIT_REPOSITORY_URL,\n        BITRISE_GIT_TAG,\n        BITRISE_GIT_MESSAGE\n      } = env\n\n      const isTag = !!BITRISE_GIT_TAG\n      const refKey = isTag ? GIT_TAG : GIT_BRANCH\n      const ref = BITRISE_GIT_TAG || BITRISEIO_GIT_BRANCH_DEST || BITRISE_GIT_BRANCH\n\n      tags = {\n        [CI_PROVIDER_NAME]: 'bitrise',\n        [CI_PIPELINE_ID]: BITRISE_BUILD_SLUG,\n        [CI_PIPELINE_NAME]: BITRISE_TRIGGERED_WORKFLOW_ID,\n        [CI_PIPELINE_NUMBER]: BITRISE_BUILD_NUMBER,\n        [CI_PIPELINE_URL]: BITRISE_BUILD_URL,\n        [GIT_COMMIT_SHA]: BITRISE_GIT_COMMIT || GIT_CLONE_COMMIT_HASH,\n        [GIT_REPOSITORY_URL]: BITRISE_GIT_REPOSITORY_URL,\n        [CI_WORKSPACE_PATH]: BITRISE_SOURCE_DIR,\n        [refKey]: ref,\n        [GIT_COMMIT_MESSAGE]: BITRISE_GIT_MESSAGE\n      }\n    }\n\n    if (env.BUILDKITE) {\n      const {\n        BUILDKITE_BRANCH,\n        BUILDKITE_COMMIT,\n        BUILDKITE_REPO,\n        BUILDKITE_TAG,\n        BUILDKITE_BUILD_ID,\n        BUILDKITE_PIPELINE_SLUG,\n        BUILDKITE_BUILD_NUMBER,\n        BUILDKITE_BUILD_URL,\n        BUILDKITE_JOB_ID,\n        BUILDKITE_BUILD_CHECKOUT_PATH,\n        BUILDKITE_BUILD_AUTHOR,\n        BUILDKITE_BUILD_AUTHOR_EMAIL,\n        BUILDKITE_MESSAGE\n      } = env\n\n      const ref = BUILDKITE_TAG || BUILDKITE_BRANCH\n      const refKey = BUILDKITE_TAG ? GIT_TAG : GIT_BRANCH\n\n      tags = {\n        [CI_PROVIDER_NAME]: 'buildkite',\n        [CI_PIPELINE_ID]: BUILDKITE_BUILD_ID,\n        [CI_PIPELINE_NAME]: BUILDKITE_PIPELINE_SLUG,\n        [CI_PIPELINE_NUMBER]: BUILDKITE_BUILD_NUMBER,\n        [CI_PIPELINE_URL]: BUILDKITE_BUILD_URL,\n        [CI_JOB_URL]: `${BUILDKITE_BUILD_URL}#${BUILDKITE_JOB_ID}`,\n        [GIT_COMMIT_SHA]: BUILDKITE_COMMIT,\n        [CI_WORKSPACE_PATH]: BUILDKITE_BUILD_CHECKOUT_PATH,\n        [GIT_REPOSITORY_URL]: BUILDKITE_REPO,\n        [refKey]: ref,\n        [GIT_COMMIT_AUTHOR_NAME]: BUILDKITE_BUILD_AUTHOR,\n        [GIT_COMMIT_AUTHOR_EMAIL]: BUILDKITE_BUILD_AUTHOR_EMAIL,\n        [GIT_COMMIT_MESSAGE]: BUILDKITE_MESSAGE\n      }\n    }\n\n    if (env.TRAVIS) {\n      const {\n        TRAVIS_PULL_REQUEST_BRANCH,\n        TRAVIS_BRANCH,\n        TRAVIS_COMMIT,\n        TRAVIS_REPO_SLUG,\n        TRAVIS_TAG,\n        TRAVIS_JOB_WEB_URL,\n        TRAVIS_BUILD_ID,\n        TRAVIS_BUILD_NUMBER,\n        TRAVIS_BUILD_WEB_URL,\n        TRAVIS_BUILD_DIR,\n        TRAVIS_COMMIT_MESSAGE\n      } = env\n\n      const isTag = !!TRAVIS_TAG\n      const ref = TRAVIS_TAG || TRAVIS_PULL_REQUEST_BRANCH || TRAVIS_BRANCH\n      const refKey = isTag ? GIT_TAG : GIT_BRANCH\n\n      tags = {\n        [CI_PROVIDER_NAME]: 'travisci',\n        [CI_JOB_URL]: TRAVIS_JOB_WEB_URL,\n        [CI_PIPELINE_ID]: TRAVIS_BUILD_ID,\n        [CI_PIPELINE_NAME]: TRAVIS_REPO_SLUG,\n        [CI_PIPELINE_NUMBER]: TRAVIS_BUILD_NUMBER,\n        [CI_PIPELINE_URL]: TRAVIS_BUILD_WEB_URL,\n        [GIT_COMMIT_SHA]: TRAVIS_COMMIT,\n        [GIT_REPOSITORY_URL]: `https://github.com/${TRAVIS_REPO_SLUG}.git`,\n        [CI_WORKSPACE_PATH]: TRAVIS_BUILD_DIR,\n        [refKey]: ref,\n        [GIT_COMMIT_MESSAGE]: TRAVIS_COMMIT_MESSAGE\n      }\n    }\n\n    normalizeTag(tags, CI_WORKSPACE_PATH, resolveTilde)\n    normalizeTag(tags, GIT_REPOSITORY_URL, filterSensitiveInfoFromRepository)\n    normalizeTag(tags, GIT_BRANCH, normalizeRef)\n    normalizeTag(tags, GIT_TAG, normalizeRef)\n\n    return removeEmptyValues(tags)\n  }\n}\n","const os = require('os')\n\nconst OS_PLATFORM = 'os.platform'\nconst OS_VERSION = 'os.version'\nconst OS_ARCHITECTURE = 'os.architecture'\nconst RUNTIME_NAME = 'runtime.name'\nconst RUNTIME_VERSION = 'runtime.version'\n\nfunction getRuntimeAndOSMetadata () {\n  return {\n    [RUNTIME_VERSION]: process.version,\n    [OS_ARCHITECTURE]: process.arch,\n    [OS_PLATFORM]: process.platform,\n    [RUNTIME_NAME]: 'node',\n    [OS_VERSION]: os.release()\n  }\n}\n\nmodule.exports = {\n  getRuntimeAndOSMetadata,\n  OS_PLATFORM,\n  OS_VERSION,\n  OS_ARCHITECTURE,\n  RUNTIME_NAME,\n  RUNTIME_VERSION\n}\n","const { execSync } = require('child_process')\n\nconst sanitizedExec = (cmd, options = {}) => {\n  try {\n    return execSync(cmd, options).toString().replace(/(\\r\\n|\\n|\\r)/gm, '')\n  } catch (e) {\n    return ''\n  }\n}\n\nmodule.exports = { sanitizedExec }\n","const { sanitizedExec } = require('./exec')\n\nconst {\n  GIT_COMMIT_SHA,\n  GIT_BRANCH,\n  GIT_REPOSITORY_URL,\n  GIT_TAG,\n  GIT_COMMIT_MESSAGE,\n  GIT_COMMIT_COMMITTER_DATE,\n  GIT_COMMIT_COMMITTER_EMAIL,\n  GIT_COMMIT_COMMITTER_NAME,\n  GIT_COMMIT_AUTHOR_DATE,\n  GIT_COMMIT_AUTHOR_EMAIL,\n  GIT_COMMIT_AUTHOR_NAME,\n  CI_WORKSPACE_PATH\n} = require('./tags')\n\n// If there is ciMetadata, it takes precedence.\nfunction getGitMetadata (ciMetadata) {\n  const {\n    commitSHA,\n    branch,\n    repositoryUrl,\n    tag,\n    commitMessage,\n    authorName: ciAuthorName,\n    authorEmail: ciAuthorEmail,\n    ciWorkspacePath\n  } = ciMetadata\n\n  // With stdio: 'pipe', errors in this command will not be output to the parent process,\n  // so if `git` is not present in the env, we won't show a warning to the user.\n  const [\n    authorName,\n    authorEmail,\n    authorDate,\n    committerName,\n    committerEmail,\n    committerDate\n  ] = sanitizedExec('git show -s --format=%an,%ae,%aI,%cn,%ce,%cI', { stdio: 'pipe' }).split(',')\n\n  return {\n    [GIT_REPOSITORY_URL]:\n      repositoryUrl || sanitizedExec('git ls-remote --get-url', { stdio: 'pipe' }),\n    [GIT_COMMIT_MESSAGE]:\n      commitMessage || sanitizedExec('git show -s --format=%s', { stdio: 'pipe' }),\n    [GIT_COMMIT_AUTHOR_DATE]: authorDate,\n    [GIT_COMMIT_AUTHOR_NAME]: ciAuthorName || authorName,\n    [GIT_COMMIT_AUTHOR_EMAIL]: ciAuthorEmail || authorEmail,\n    [GIT_COMMIT_COMMITTER_DATE]: committerDate,\n    [GIT_COMMIT_COMMITTER_NAME]: committerName,\n    [GIT_COMMIT_COMMITTER_EMAIL]: committerEmail,\n    [GIT_BRANCH]: branch || sanitizedExec('git rev-parse --abbrev-ref HEAD', { stdio: 'pipe' }),\n    [GIT_COMMIT_SHA]: commitSHA || sanitizedExec('git rev-parse HEAD', { stdio: 'pipe' }),\n    [GIT_TAG]: tag,\n    [CI_WORKSPACE_PATH]: ciWorkspacePath || sanitizedExec('git rev-parse --show-toplevel', { stdio: 'pipe' })\n  }\n}\n\nmodule.exports = { getGitMetadata }\n","const GIT_COMMIT_SHA = 'git.commit.sha'\nconst GIT_BRANCH = 'git.branch'\nconst GIT_REPOSITORY_URL = 'git.repository_url'\nconst GIT_TAG = 'git.tag'\nconst GIT_COMMIT_MESSAGE = 'git.commit.message'\nconst GIT_COMMIT_COMMITTER_DATE = 'git.commit.committer.date'\nconst GIT_COMMIT_COMMITTER_EMAIL = 'git.commit.committer.email'\nconst GIT_COMMIT_COMMITTER_NAME = 'git.commit.committer.name'\nconst GIT_COMMIT_AUTHOR_DATE = 'git.commit.author.date'\nconst GIT_COMMIT_AUTHOR_EMAIL = 'git.commit.author.email'\nconst GIT_COMMIT_AUTHOR_NAME = 'git.commit.author.name'\n\nconst CI_PIPELINE_ID = 'ci.pipeline.id'\nconst CI_PIPELINE_NAME = 'ci.pipeline.name'\nconst CI_PIPELINE_NUMBER = 'ci.pipeline.number'\nconst CI_PIPELINE_URL = 'ci.pipeline.url'\nconst CI_PROVIDER_NAME = 'ci.provider.name'\nconst CI_WORKSPACE_PATH = 'ci.workspace_path'\nconst CI_JOB_URL = 'ci.job.url'\nconst CI_JOB_NAME = 'ci.job.name'\nconst CI_STAGE_NAME = 'ci.stage.name'\n\nmodule.exports = {\n  GIT_COMMIT_SHA,\n  GIT_BRANCH,\n  GIT_REPOSITORY_URL,\n  GIT_TAG,\n  GIT_COMMIT_MESSAGE,\n  GIT_COMMIT_COMMITTER_DATE,\n  GIT_COMMIT_COMMITTER_EMAIL,\n  GIT_COMMIT_COMMITTER_NAME,\n  GIT_COMMIT_AUTHOR_DATE,\n  GIT_COMMIT_AUTHOR_EMAIL,\n  GIT_COMMIT_AUTHOR_NAME,\n  CI_PIPELINE_ID,\n  CI_PIPELINE_NAME,\n  CI_PIPELINE_NUMBER,\n  CI_PIPELINE_URL,\n  CI_PROVIDER_NAME,\n  CI_WORKSPACE_PATH,\n  CI_JOB_URL,\n  CI_JOB_NAME,\n  CI_STAGE_NAME\n}\n","const path = require('path')\nconst fs = require('fs')\n\nconst ignore = require('ignore')\n\nconst { getGitMetadata } = require('./git')\nconst { getUserProviderGitMetadata } = require('./user-provided-git')\nconst { getCIMetadata } = require('./ci')\nconst { getRuntimeAndOSMetadata } = require('./env')\nconst {\n  GIT_BRANCH,\n  GIT_COMMIT_SHA,\n  GIT_REPOSITORY_URL,\n  GIT_TAG,\n  GIT_COMMIT_AUTHOR_EMAIL,\n  GIT_COMMIT_AUTHOR_NAME,\n  GIT_COMMIT_MESSAGE,\n  CI_WORKSPACE_PATH\n} = require('./tags')\nconst id = require('../../id')\n\nconst TEST_FRAMEWORK = 'test.framework'\nconst TEST_FRAMEWORK_VERSION = 'test.framework_version'\nconst TEST_TYPE = 'test.type'\nconst TEST_NAME = 'test.name'\nconst TEST_SUITE = 'test.suite'\nconst TEST_STATUS = 'test.status'\nconst TEST_PARAMETERS = 'test.parameters'\nconst TEST_SKIP_REASON = 'test.skip_reason'\nconst TEST_IS_RUM_ACTIVE = 'test.is_rum_active'\nconst TEST_CODE_OWNERS = 'test.codeowners'\n\nconst ERROR_TYPE = 'error.type'\nconst ERROR_MESSAGE = 'error.msg'\nconst ERROR_STACK = 'error.stack'\n\nconst CI_APP_ORIGIN = 'ciapp-test'\n\nconst JEST_TEST_RUNNER = 'test.jest.test_runner'\n\nmodule.exports = {\n  TEST_CODE_OWNERS,\n  TEST_FRAMEWORK,\n  TEST_FRAMEWORK_VERSION,\n  JEST_TEST_RUNNER,\n  TEST_TYPE,\n  TEST_NAME,\n  TEST_SUITE,\n  TEST_STATUS,\n  TEST_PARAMETERS,\n  TEST_SKIP_REASON,\n  TEST_IS_RUM_ACTIVE,\n  ERROR_TYPE,\n  ERROR_MESSAGE,\n  ERROR_STACK,\n  CI_APP_ORIGIN,\n  getTestEnvironmentMetadata,\n  getTestParametersString,\n  finishAllTraceSpans,\n  getTestParentSpan,\n  getTestSuitePath,\n  getCodeOwnersFileEntries,\n  getCodeOwnersForFilename\n}\n\nfunction getTestEnvironmentMetadata (testFramework, config) {\n  // TODO: eventually these will come from the tracer (generally available)\n  const ciMetadata = getCIMetadata()\n  const {\n    [GIT_COMMIT_SHA]: commitSHA,\n    [GIT_BRANCH]: branch,\n    [GIT_REPOSITORY_URL]: repositoryUrl,\n    [GIT_TAG]: tag,\n    [GIT_COMMIT_AUTHOR_NAME]: authorName,\n    [GIT_COMMIT_AUTHOR_EMAIL]: authorEmail,\n    [GIT_COMMIT_MESSAGE]: commitMessage,\n    [CI_WORKSPACE_PATH]: ciWorkspacePath\n  } = ciMetadata\n\n  const gitMetadata = getGitMetadata({\n    commitSHA,\n    branch,\n    repositoryUrl,\n    tag,\n    authorName,\n    authorEmail,\n    commitMessage,\n    ciWorkspacePath\n  })\n\n  const userProvidedGitMetadata = getUserProviderGitMetadata()\n\n  const runtimeAndOSMetadata = getRuntimeAndOSMetadata()\n\n  const metadata = {\n    [TEST_FRAMEWORK]: testFramework,\n    ...gitMetadata,\n    ...ciMetadata,\n    ...userProvidedGitMetadata,\n    ...runtimeAndOSMetadata\n  }\n  if (config && config.service) {\n    metadata['service.name'] = config.service\n  }\n  return metadata\n}\n\nfunction getTestParametersString (parametersByTestName, testName) {\n  if (!parametersByTestName[testName]) {\n    return ''\n  }\n  try {\n    // test is invoked with each parameter set sequencially\n    const testParameters = parametersByTestName[testName].shift()\n    return JSON.stringify({ arguments: testParameters, metadata: {} })\n  } catch (e) {\n    // We can't afford to interrupt the test if `testParameters` is not serializable to JSON,\n    // so we ignore the test parameters and move on\n    return ''\n  }\n}\n\nfunction finishAllTraceSpans (span) {\n  span.context()._trace.started.forEach(traceSpan => {\n    if (traceSpan !== span) {\n      traceSpan.finish()\n    }\n  })\n}\n\nfunction getTestParentSpan (tracer) {\n  return tracer.extract('text_map', {\n    'x-datadog-trace-id': id().toString(10),\n    'x-datadog-parent-id': '0000000000000000'\n  })\n}\n/**\n * We want to make sure that test suites are reported the same way for\n * every OS, so we replace `path.sep` by `/`\n */\nfunction getTestSuitePath (testSuiteAbsolutePath, sourceRoot) {\n  if (!testSuiteAbsolutePath) {\n    return sourceRoot\n  }\n  const testSuitePath = testSuiteAbsolutePath === sourceRoot\n    ? testSuiteAbsolutePath : path.relative(sourceRoot, testSuiteAbsolutePath)\n\n  return testSuitePath.replace(path.sep, '/')\n}\n\nconst POSSIBLE_CODEOWNERS_LOCATIONS = [\n  'CODEOWNERS',\n  '.github/CODEOWNERS',\n  'docs/CODEOWNERS',\n  '.gitlab/CODEOWNERS'\n]\n\nfunction getCodeOwnersFileEntries (rootDir = process.cwd()) {\n  let codeOwnersContent\n\n  POSSIBLE_CODEOWNERS_LOCATIONS.forEach(location => {\n    try {\n      codeOwnersContent = fs.readFileSync(`${rootDir}/${location}`).toString()\n    } catch (e) {\n      // retry with next path\n    }\n  })\n  if (!codeOwnersContent) {\n    return null\n  }\n\n  const entries = []\n  const lines = codeOwnersContent.split('\\n')\n\n  for (const line of lines) {\n    const [content] = line.split('#')\n    const trimmed = content.trim()\n    if (trimmed === '') continue\n    const [pattern, ...owners] = trimmed.split(/\\s+/)\n    entries.push({ pattern, owners })\n  }\n  // Reverse because rules defined last take precedence\n  return entries.reverse()\n}\n\nfunction getCodeOwnersForFilename (filename, entries) {\n  if (!entries) {\n    return null\n  }\n  for (const entry of entries) {\n    try {\n      const isResponsible = ignore().add(entry.pattern).ignores(filename)\n      if (isResponsible) {\n        return JSON.stringify(entry.owners)\n      }\n    } catch (e) {\n      return null\n    }\n  }\n  return null\n}\n","'use strict'\n\nconst log = require('../../log')\n\nconst urlFilter = {\n  getFilter (config) {\n    if (typeof config.filter === 'function') {\n      return config.filter\n    } else if (config.hasOwnProperty('filter')) {\n      log.error('Expected `filter` to be a function. Overriding filter property to default.')\n    }\n\n    const allowlist = config.allowlist || config.whitelist || /.*/\n    const blocklist = config.blocklist || config.blacklist || []\n\n    return uri => {\n      const allowed = applyFilter(allowlist, uri)\n      const blocked = applyFilter(blocklist, uri)\n      return allowed && !blocked\n    }\n\n    function applyFilter (filter, uri) {\n      if (typeof filter === 'function') {\n        return filter(uri)\n      } else if (filter instanceof RegExp) {\n        return filter.test(uri)\n      } else if (filter instanceof Array) {\n        return filter.some(filter => applyFilter(filter, uri))\n      }\n\n      return filter === uri\n    }\n  }\n}\n\nmodule.exports = urlFilter\n","const {\n  GIT_COMMIT_SHA,\n  GIT_BRANCH,\n  GIT_REPOSITORY_URL,\n  GIT_TAG,\n  GIT_COMMIT_MESSAGE,\n  GIT_COMMIT_COMMITTER_DATE,\n  GIT_COMMIT_COMMITTER_EMAIL,\n  GIT_COMMIT_COMMITTER_NAME,\n  GIT_COMMIT_AUTHOR_DATE,\n  GIT_COMMIT_AUTHOR_EMAIL,\n  GIT_COMMIT_AUTHOR_NAME\n} = require('./tags')\n\nconst { normalizeRef } = require('./ci')\n\nfunction removeEmptyValues (tags) {\n  return Object.keys(tags).reduce((filteredTags, tag) => {\n    if (!tags[tag]) {\n      return filteredTags\n    }\n    return {\n      ...filteredTags,\n      [tag]: tags[tag]\n    }\n  }, {})\n}\n\nfunction getUserProviderGitMetadata () {\n  const {\n    DD_GIT_COMMIT_SHA,\n    DD_GIT_BRANCH,\n    DD_GIT_REPOSITORY_URL,\n    DD_GIT_TAG,\n    DD_GIT_COMMIT_MESSAGE,\n    DD_GIT_COMMIT_COMMITTER_NAME,\n    DD_GIT_COMMIT_COMMITTER_EMAIL,\n    DD_GIT_COMMIT_COMMITTER_DATE,\n    DD_GIT_COMMIT_AUTHOR_NAME,\n    DD_GIT_COMMIT_AUTHOR_EMAIL,\n    DD_GIT_COMMIT_AUTHOR_DATE\n  } = process.env\n\n  let branch = normalizeRef(DD_GIT_BRANCH)\n  let tag = normalizeRef(DD_GIT_TAG)\n\n  if (DD_GIT_TAG) {\n    branch = undefined\n  }\n\n  // if DD_GIT_BRANCH is a tag, we associate its value to TAG instead of BRANCH\n  if ((DD_GIT_BRANCH || '').includes('origin/tags') || (DD_GIT_BRANCH || '').includes('refs/heads/tags')) {\n    branch = undefined\n    tag = normalizeRef(DD_GIT_BRANCH)\n  }\n\n  return removeEmptyValues({\n    [GIT_COMMIT_SHA]: DD_GIT_COMMIT_SHA,\n    [GIT_BRANCH]: branch,\n    [GIT_REPOSITORY_URL]: DD_GIT_REPOSITORY_URL,\n    [GIT_TAG]: tag,\n    [GIT_COMMIT_MESSAGE]: DD_GIT_COMMIT_MESSAGE,\n    [GIT_COMMIT_COMMITTER_NAME]: DD_GIT_COMMIT_COMMITTER_NAME,\n    [GIT_COMMIT_COMMITTER_DATE]: DD_GIT_COMMIT_COMMITTER_DATE,\n    [GIT_COMMIT_COMMITTER_EMAIL]: DD_GIT_COMMIT_COMMITTER_EMAIL,\n    [GIT_COMMIT_AUTHOR_NAME]: DD_GIT_COMMIT_AUTHOR_NAME,\n    [GIT_COMMIT_AUTHOR_EMAIL]: DD_GIT_COMMIT_AUTHOR_EMAIL,\n    [GIT_COMMIT_AUTHOR_DATE]: DD_GIT_COMMIT_AUTHOR_DATE\n  })\n}\n\nmodule.exports = { getUserProviderGitMetadata }\n","'use strict'\n\nconst uniq = require('lodash.uniq')\nconst analyticsSampler = require('../../analytics_sampler')\nconst FORMAT_HTTP_HEADERS = require('opentracing').FORMAT_HTTP_HEADERS\nconst log = require('../../log')\nconst tags = require('../../../../../ext/tags')\nconst types = require('../../../../../ext/types')\nconst kinds = require('../../../../../ext/kinds')\nconst urlFilter = require('./urlfilter')\nconst { incomingHttpRequestEnd } = require('../../appsec/gateway/channels')\n\nconst WEB = types.WEB\nconst SERVER = kinds.SERVER\nconst RESOURCE_NAME = tags.RESOURCE_NAME\nconst SERVICE_NAME = tags.SERVICE_NAME\nconst SPAN_TYPE = tags.SPAN_TYPE\nconst SPAN_KIND = tags.SPAN_KIND\nconst ERROR = tags.ERROR\nconst HTTP_METHOD = tags.HTTP_METHOD\nconst HTTP_URL = tags.HTTP_URL\nconst HTTP_STATUS_CODE = tags.HTTP_STATUS_CODE\nconst HTTP_ROUTE = tags.HTTP_ROUTE\nconst HTTP_REQUEST_HEADERS = tags.HTTP_REQUEST_HEADERS\nconst HTTP_RESPONSE_HEADERS = tags.HTTP_RESPONSE_HEADERS\nconst MANUAL_DROP = tags.MANUAL_DROP\n\nconst HTTP2_HEADER_AUTHORITY = ':authority'\nconst HTTP2_HEADER_SCHEME = ':scheme'\nconst HTTP2_HEADER_PATH = ':path'\n\nconst contexts = new WeakMap()\nconst ends = new WeakMap()\n\nconst web = {\n  // Ensure the configuration has the correct structure and defaults.\n  normalizeConfig (config) {\n    config = config.server || config\n\n    const headers = getHeadersToRecord(config)\n    const validateStatus = getStatusValidator(config)\n    const hooks = getHooks(config)\n    const filter = urlFilter.getFilter(config)\n    const middleware = getMiddlewareSetting(config)\n\n    return Object.assign({}, config, {\n      headers,\n      validateStatus,\n      hooks,\n      filter,\n      middleware\n    })\n  },\n\n  startSpan (tracer, config, req, res, name) {\n    const context = this.patch(req)\n    context.config = config\n\n    let span\n\n    if (context.span) {\n      context.span.context()._name = name\n      span = context.span\n    } else {\n      span = web.startChildSpan(tracer, name, req.headers)\n    }\n\n    context.tracer = tracer\n    context.span = span\n    context.res = res\n\n    return span\n  },\n  wrap (req) {\n    const context = contexts.get(req)\n    if (!context.instrumented) {\n      this.wrapEnd(context)\n      this.wrapEvents(context)\n      context.instrumented = true\n    }\n  },\n  // Start a span and activate a scope for a request.\n  instrument (tracer, config, req, res, name, callback) {\n    const span = this.startSpan(tracer, config, req, res, name)\n\n    if (!config.filter(req.url)) {\n      span.setTag(MANUAL_DROP, true)\n    }\n\n    if (config.service) {\n      span.setTag(SERVICE_NAME, config.service)\n    }\n\n    analyticsSampler.sample(span, config.measured, true)\n\n    this.wrap(req)\n\n    return callback && tracer.scope().activate(span, () => callback(span))\n  },\n\n  // Reactivate the request scope in case it was changed by a middleware.\n  reactivate (req, fn) {\n    return reactivate(req, fn)\n  },\n\n  // Add a route segment that will be used for the resource name.\n  enterRoute (req, path) {\n    if (typeof path === 'string') {\n      contexts.get(req).paths.push(path)\n    }\n  },\n\n  // Remove the current route segment.\n  exitRoute (req) {\n    contexts.get(req).paths.pop()\n  },\n\n  // Start a new middleware span and activate a new scope with the span.\n  wrapMiddleware (req, middleware, name, fn) {\n    if (!this.active(req)) return fn()\n\n    const context = contexts.get(req)\n    const tracer = context.tracer\n    const childOf = this.active(req)\n    const config = context.config\n\n    if (config.middleware === false) return this.bindAndWrapMiddlewareErrors(fn, req, tracer, childOf)\n\n    const span = tracer.startSpan(name, { childOf })\n\n    analyticsSampler.sample(span, config.measured)\n\n    span.addTags({\n      [RESOURCE_NAME]: middleware._name || middleware.name || '<anonymous>'\n    })\n\n    context.middleware.push(span)\n\n    return tracer.scope().activate(span, fn)\n  },\n\n  // catch errors and apply to active span\n  bindAndWrapMiddlewareErrors (fn, req, tracer, activeSpan) {\n    try {\n      return tracer.scope().bind(fn, activeSpan).apply(this, arguments)\n    } catch (e) {\n      web.addError(req, e) // TODO: remove when error formatting is moved to Span\n      throw e\n    }\n  },\n\n  // Finish the active middleware span.\n  finish (req, error) {\n    if (!this.active(req)) return\n\n    const context = contexts.get(req)\n    const span = context.middleware.pop()\n\n    if (span) {\n      if (error) {\n        span.addTags({\n          'error.type': error.name,\n          'error.msg': error.message,\n          'error.stack': error.stack\n        })\n      }\n\n      span.finish()\n    }\n  },\n\n  // Register a callback to run before res.end() is called.\n  beforeEnd (req, callback) {\n    contexts.get(req).beforeEnd.push(callback)\n  },\n\n  // Prepare the request for instrumentation.\n  patch (req) {\n    let context = contexts.get(req)\n\n    if (context) return context\n\n    context = req.stream && contexts.get(req.stream)\n\n    if (context) {\n      contexts.set(req, context)\n      return context\n    }\n\n    context = {\n      req,\n      span: null,\n      paths: [],\n      middleware: [],\n      beforeEnd: [],\n      config: {}\n    }\n\n    contexts.set(req, context)\n\n    return context\n  },\n\n  // Return the request root span.\n  root (req) {\n    const context = contexts.get(req)\n    return context ? context.span : null\n  },\n\n  // Return the active span.\n  active (req) {\n    const context = contexts.get(req)\n\n    if (!context) return null\n    if (context.middleware.length === 0) return context.span || null\n\n    return context.middleware.slice(-1)[0]\n  },\n\n  // Extract the parent span from the headers and start a new span as its child\n  startChildSpan (tracer, name, headers) {\n    const childOf = tracer.scope().active() || tracer.extract(FORMAT_HTTP_HEADERS, headers)\n\n    const span = tracer.startSpan(name, { childOf })\n\n    return span\n  },\n\n  // Validate a request's status code and then add error tags if necessary\n  addStatusError (req, statusCode) {\n    const context = contexts.get(req)\n    const span = context.span\n    const error = context.error\n\n    if (!context.config.validateStatus(statusCode)) {\n      span.setTag(ERROR, error || true)\n    }\n  },\n\n  // Add an error to the request\n  addError (req, error) {\n    if (error instanceof Error) {\n      const context = contexts.get(req)\n      context.error = context.error || error\n    }\n  },\n\n  finishMiddleware (context) {\n    if (context.finished) return\n\n    let span\n\n    while ((span = context.middleware.pop())) {\n      span.finish()\n    }\n  },\n\n  finishSpan (context) {\n    const { req, res } = context\n\n    if (context.finished && !req.stream) return\n\n    addRequestTags(context)\n    addResponseTags(context)\n\n    context.config.hooks.request(context.span, req, res)\n    addResourceTag(context)\n\n    context.span.finish()\n    context.finished = true\n  },\n  wrapWriteHead (context) {\n    const { req, res } = context\n    const writeHead = res.writeHead\n\n    return function (statusCode, statusMessage, headers) {\n      headers = typeof statusMessage === 'string' ? headers : statusMessage\n      headers = Object.assign(res.getHeaders(), headers)\n\n      if (req.method.toLowerCase() === 'options' && isOriginAllowed(req, headers)) {\n        addAllowHeaders(req, res, headers)\n      }\n\n      return writeHead.apply(this, arguments)\n    }\n  },\n  getContext (req) {\n    return contexts.get(req)\n  },\n  wrapRes (context, req, res, end) {\n    return function () {\n      for (const beforeEnd of context.beforeEnd) {\n        beforeEnd()\n      }\n\n      web.finishMiddleware(context)\n\n      if (incomingHttpRequestEnd.hasSubscribers) {\n        incomingHttpRequestEnd.publish({ req, res })\n      }\n\n      const returnValue = end.apply(res, arguments)\n\n      web.finishSpan(context)\n\n      return returnValue\n    }\n  },\n  wrapEnd (context) {\n    const scope = context.tracer.scope()\n    const req = context.req\n    const res = context.res\n    const end = res.end\n\n    res.writeHead = web.wrapWriteHead(context)\n\n    ends.set(res, this.wrapRes(context, req, res, end))\n\n    Object.defineProperty(res, 'end', {\n      configurable: true,\n      get () {\n        return ends.get(this)\n      },\n      set (value) {\n        ends.set(this, scope.bind(value, context.span))\n      }\n    })\n  },\n  wrapEvents (context) {\n    const scope = context.tracer.scope()\n    const res = context.res\n\n    scope.bind(res, context.span)\n  }\n}\n\nfunction addAllowHeaders (req, res, headers) {\n  const allowHeaders = splitHeader(headers['access-control-allow-headers'])\n  const requestHeaders = splitHeader(req.headers['access-control-request-headers'])\n  const contextHeaders = [\n    'x-datadog-origin',\n    'x-datadog-parent-id',\n    'x-datadog-sampled', // Deprecated, but still accept it in case it's sent.\n    'x-datadog-sampling-priority',\n    'x-datadog-trace-id'\n  ]\n\n  for (const header of contextHeaders) {\n    if (~requestHeaders.indexOf(header)) {\n      allowHeaders.push(header)\n    }\n  }\n\n  if (allowHeaders.length > 0) {\n    res.setHeader('access-control-allow-headers', uniq(allowHeaders).join(','))\n  }\n}\n\nfunction isOriginAllowed (req, headers) {\n  const origin = req.headers['origin']\n  const allowOrigin = headers['access-control-allow-origin']\n\n  return origin && (allowOrigin === '*' || allowOrigin === origin)\n}\n\nfunction splitHeader (str) {\n  return typeof str === 'string' ? str.split(/\\s*,\\s*/) : []\n}\n\nfunction reactivate (req, fn) {\n  const context = contexts.get(req)\n\n  return context\n    ? context.tracer.scope().activate(context.span, fn)\n    : fn()\n}\n\nfunction addRequestTags (context) {\n  const { req, span } = context\n  const url = extractURL(req)\n\n  span.addTags({\n    [HTTP_URL]: url.split('?')[0],\n    [HTTP_METHOD]: req.method,\n    [SPAN_KIND]: SERVER,\n    [SPAN_TYPE]: WEB\n  })\n\n  addHeaders(context)\n}\n\nfunction addResponseTags (context) {\n  const { req, res, paths, span } = context\n\n  if (paths.length > 0) {\n    span.setTag(HTTP_ROUTE, paths.join(''))\n  }\n\n  span.addTags({\n    [HTTP_STATUS_CODE]: res.statusCode\n  })\n\n  web.addStatusError(req, res.statusCode)\n}\n\nfunction addResourceTag (context) {\n  const { req, span } = context\n  const tags = span.context()._tags\n\n  if (tags['resource.name']) return\n\n  const resource = [req.method, tags[HTTP_ROUTE]]\n    .filter(val => val)\n    .join(' ')\n\n  span.setTag(RESOURCE_NAME, resource)\n}\n\nfunction addHeaders (context) {\n  const { req, res, config, span } = context\n\n  config.headers.forEach(key => {\n    const reqHeader = req.headers[key]\n    const resHeader = res.getHeader(key)\n\n    if (reqHeader) {\n      span.setTag(`${HTTP_REQUEST_HEADERS}.${key}`, reqHeader)\n    }\n\n    if (resHeader) {\n      span.setTag(`${HTTP_RESPONSE_HEADERS}.${key}`, resHeader)\n    }\n  })\n}\n\nfunction extractURL (req) {\n  const headers = req.headers\n\n  if (req.stream) {\n    return `${headers[HTTP2_HEADER_SCHEME]}://${headers[HTTP2_HEADER_AUTHORITY]}${headers[HTTP2_HEADER_PATH]}`\n  } else {\n    const protocol = getProtocol(req)\n    return `${protocol}://${req.headers['host']}${req.originalUrl || req.url}`\n  }\n}\n\nfunction getProtocol (req) {\n  if (req.socket && req.socket.encrypted) return 'https'\n  if (req.connection && req.connection.encrypted) return 'https'\n\n  return 'http'\n}\n\nfunction getHeadersToRecord (config) {\n  if (Array.isArray(config.headers)) {\n    try {\n      return config.headers.map(key => key.toLowerCase())\n    } catch (err) {\n      log.error(err)\n    }\n  } else if (config.hasOwnProperty('headers')) {\n    log.error('Expected `headers` to be an array of strings.')\n  }\n  return []\n}\n\nfunction getStatusValidator (config) {\n  if (typeof config.validateStatus === 'function') {\n    return config.validateStatus\n  } else if (config.hasOwnProperty('validateStatus')) {\n    log.error('Expected `validateStatus` to be a function.')\n  }\n  return code => code < 500\n}\n\nfunction getHooks (config) {\n  const noop = () => {}\n  const request = (config.hooks && config.hooks.request) || noop\n\n  return { request }\n}\n\nfunction getMiddlewareSetting (config) {\n  if (config && typeof config.middleware === 'boolean') {\n    return config.middleware\n  } else if (config && config.hasOwnProperty('middleware')) {\n    log.error('Expected `middleware` to be a boolean.')\n  }\n\n  return true\n}\n\nmodule.exports = web\n","'use strict'\n\nconst RateLimiter = require('./rate_limiter')\nconst Sampler = require('./sampler')\nconst ext = require('../../../ext')\nconst { setSamplingRules } = require('./startup-log')\n\nconst {\n  SAMPLING_RULE_DECISION,\n  SAMPLING_LIMIT_DECISION,\n  SAMPLING_AGENT_DECISION\n} = require('./constants')\n\nconst SERVICE_NAME = ext.tags.SERVICE_NAME\nconst SAMPLING_PRIORITY = ext.tags.SAMPLING_PRIORITY\nconst MANUAL_KEEP = ext.tags.MANUAL_KEEP\nconst MANUAL_DROP = ext.tags.MANUAL_DROP\nconst USER_REJECT = ext.priority.USER_REJECT\nconst AUTO_REJECT = ext.priority.AUTO_REJECT\nconst AUTO_KEEP = ext.priority.AUTO_KEEP\nconst USER_KEEP = ext.priority.USER_KEEP\nconst DEFAULT_KEY = 'service:,env:'\n\nconst defaultSampler = new Sampler(AUTO_KEEP)\n\nclass PrioritySampler {\n  constructor (env, { sampleRate, rateLimit = 100, rules = [] } = {}) {\n    this._env = env\n    this._rules = this._normalizeRules(rules, sampleRate)\n    this._limiter = new RateLimiter(rateLimit)\n\n    setSamplingRules(this._rules)\n\n    this.update({})\n  }\n\n  isSampled (span) {\n    const priority = this._getPriorityFromAuto(span)\n    return priority === USER_KEEP || priority === AUTO_KEEP\n  }\n\n  sample (span, auto = true) {\n    if (!span) return\n\n    const context = this._getContext(span)\n    const root = context._trace.started[0]\n\n    if (context._sampling.priority !== undefined) return\n    if (!root) return // noop span\n\n    const tag = this._getPriorityFromTags(context._tags)\n\n    if (this.validate(tag)) {\n      context._sampling.priority = tag\n    } else if (auto) {\n      context._sampling.priority = this._getPriorityFromAuto(root)\n    }\n  }\n\n  update (rates) {\n    const samplers = {}\n\n    for (const key in rates) {\n      const rate = rates[key]\n      const sampler = new Sampler(rate)\n\n      samplers[key] = sampler\n    }\n\n    samplers[DEFAULT_KEY] = samplers[DEFAULT_KEY] || defaultSampler\n\n    this._samplers = samplers\n  }\n\n  validate (samplingPriority) {\n    switch (samplingPriority) {\n      case USER_REJECT:\n      case USER_KEEP:\n      case AUTO_REJECT:\n      case AUTO_KEEP:\n        return true\n      default:\n        return false\n    }\n  }\n\n  _getContext (span) {\n    return typeof span.context === 'function' ? span.context() : span\n  }\n\n  _getPriorityFromAuto (span) {\n    const context = this._getContext(span)\n    const rule = this._findRule(context)\n\n    return rule\n      ? this._getPriorityByRule(context, rule)\n      : this._getPriorityByAgent(context)\n  }\n\n  _getPriorityFromTags (tags) {\n    if (tags.hasOwnProperty(MANUAL_KEEP) && tags[MANUAL_KEEP] !== false) {\n      return USER_KEEP\n    } else if (tags.hasOwnProperty(MANUAL_DROP) && tags[MANUAL_DROP] !== false) {\n      return USER_REJECT\n    } else {\n      const priority = parseInt(tags[SAMPLING_PRIORITY], 10)\n\n      if (priority === 1 || priority === 2) {\n        return USER_KEEP\n      } else if (priority === 0 || priority === -1) {\n        return USER_REJECT\n      }\n    }\n  }\n\n  _getPriorityByRule (context, rule) {\n    context._trace[SAMPLING_RULE_DECISION] = rule.sampleRate\n\n    return rule.sampler.isSampled(context) && this._isSampledByRateLimit(context) ? USER_KEEP : USER_REJECT\n  }\n\n  _isSampledByRateLimit (context) {\n    const allowed = this._limiter.isAllowed()\n\n    context._trace[SAMPLING_LIMIT_DECISION] = this._limiter.effectiveRate()\n\n    return allowed\n  }\n\n  _getPriorityByAgent (context) {\n    const key = `service:${context._tags[SERVICE_NAME]},env:${this._env}`\n    const sampler = this._samplers[key] || this._samplers[DEFAULT_KEY]\n\n    context._trace[SAMPLING_AGENT_DECISION] = sampler.rate()\n\n    return sampler.isSampled(context) ? AUTO_KEEP : AUTO_REJECT\n  }\n\n  _normalizeRules (rules, sampleRate) {\n    return rules\n      .concat({ sampleRate })\n      .map(rule => ({ ...rule, sampleRate: parseFloat(rule.sampleRate) }))\n      .filter(rule => !isNaN(rule.sampleRate))\n      .map(rule => ({ ...rule, sampler: new Sampler(rule.sampleRate) }))\n  }\n\n  _findRule (context) {\n    for (let i = 0, l = this._rules.length; i < l; i++) {\n      if (this._matchRule(context, this._rules[i])) return this._rules[i]\n    }\n  }\n\n  _matchRule (context, rule) {\n    const name = context._name\n    const service = context._tags['service.name']\n\n    if (rule.name instanceof RegExp && !rule.name.test(name)) return false\n    if (typeof rule.name === 'string' && rule.name !== name) return false\n    if (rule.service instanceof RegExp && !rule.service.test(service)) return false\n    if (typeof rule.service === 'string' && rule.service !== service) return false\n\n    return true\n  }\n}\n\nmodule.exports = PrioritySampler\n","'use strict'\n\nconst log = require('./log')\nconst { profiler } = require('./profiling')\n\nmodule.exports = {\n  start: config => {\n    const { service, version, env, url, hostname, port, tags } = config\n    const { enabled, sourceMap, exporters } = config.profiling\n    const logger = {\n      debug: (message) => log.debug(message),\n      info: (message) => log.info(message),\n      warn: (message) => log.warn(message),\n      error: (message) => log.error(message)\n    }\n\n    profiler.start({\n      enabled,\n      service,\n      version,\n      env,\n      logger,\n      sourceMap,\n      exporters,\n      url,\n      hostname,\n      port,\n      tags\n    })\n  },\n\n  stop: () => {\n    profiler.stop()\n  }\n}\n","'use strict'\n\nconst coalesce = require('koalas')\nconst os = require('os')\nconst { URL } = require('url')\nconst { AgentExporter } = require('./exporters/agent')\nconst { FileExporter } = require('./exporters/file')\nconst { ConsoleLogger } = require('./loggers/console')\nconst CpuProfiler = require('./profilers/cpu')\nconst HeapProfiler = require('./profilers/heap')\nconst { tagger } = require('./tagger')\n\nconst {\n  DD_PROFILING_ENABLED,\n  DD_PROFILING_PROFILERS,\n  DD_ENV,\n  DD_TAGS,\n  DD_SERVICE,\n  DD_VERSION,\n  DD_TRACE_AGENT_URL,\n  DD_AGENT_HOST,\n  DD_TRACE_AGENT_PORT,\n  DD_PROFILING_UPLOAD_TIMEOUT,\n  DD_PROFILING_SOURCE_MAP\n} = process.env\n\nclass Config {\n  constructor (options = {}) {\n    const enabled = coalesce(options.enabled, DD_PROFILING_ENABLED, true)\n    const env = coalesce(options.env, DD_ENV)\n    const service = options.service || DD_SERVICE || 'node'\n    const host = os.hostname()\n    const version = coalesce(options.version, DD_VERSION)\n    // Must be longer than one minute so pad with five seconds\n    const flushInterval = coalesce(options.interval, 65 * 1000)\n    const uploadTimeout = coalesce(options.uploadTimeout,\n      DD_PROFILING_UPLOAD_TIMEOUT, 60 * 1000)\n    const sourceMap = coalesce(options.sourceMap,\n      DD_PROFILING_SOURCE_MAP, true)\n\n    this.enabled = String(enabled) !== 'false'\n    this.service = service\n    this.env = env\n    this.host = host\n\n    this.version = version\n    this.tags = Object.assign(\n      tagger.parse(DD_TAGS),\n      tagger.parse(options.tags),\n      tagger.parse({ env, host, service, version })\n    )\n    this.logger = ensureLogger(options.logger)\n    this.flushInterval = flushInterval\n    this.uploadTimeout = uploadTimeout\n    this.sourceMap = sourceMap\n\n    const hostname = coalesce(options.hostname, DD_AGENT_HOST, 'localhost')\n    const port = coalesce(options.port, DD_TRACE_AGENT_PORT, 8126)\n    this.url = new URL(coalesce(options.url, DD_TRACE_AGENT_URL,\n      `http://${hostname || 'localhost'}:${port || 8126}`))\n\n    this.exporters = ensureExporters(options.exporters || [\n      new AgentExporter(this)\n    ], this)\n\n    const profilers = coalesce(options.profilers, DD_PROFILING_PROFILERS, [\n      new CpuProfiler(),\n      new HeapProfiler()\n    ])\n\n    this.profilers = ensureProfilers(profilers, this)\n  }\n}\n\nmodule.exports = { Config }\n\nfunction getExporter (name, options) {\n  switch (name) {\n    case 'agent':\n      return new AgentExporter(options)\n    case 'file':\n      return new FileExporter(options)\n  }\n}\n\nfunction ensureExporters (exporters, options) {\n  if (typeof exporters === 'string') {\n    exporters = exporters.split(',')\n  }\n\n  for (let i = 0; i < exporters.length; i++) {\n    const exporter = exporters[i]\n    if (typeof exporter === 'string') {\n      exporters[i] = getExporter(exporter, options)\n    }\n  }\n\n  return exporters\n}\n\nfunction getProfiler (name, options) {\n  switch (name) {\n    case 'cpu':\n      return new CpuProfiler(options)\n    case 'heap':\n      return new HeapProfiler(options)\n    default:\n      options.logger.error(`Unknown profiler \"${name}\"`)\n  }\n}\n\nfunction ensureProfilers (profilers, options) {\n  if (typeof profilers === 'string') {\n    profilers = profilers.split(',')\n  }\n\n  for (let i = 0; i < profilers.length; i++) {\n    const profiler = profilers[i]\n    if (typeof profiler === 'string') {\n      profilers[i] = getProfiler(profiler, options)\n    }\n  }\n\n  // Filter out any invalid profilers\n  return profilers.filter(v => v)\n}\n\nfunction ensureLogger (logger) {\n  if (typeof logger !== 'object' ||\n    typeof logger.debug !== 'function' ||\n    typeof logger.info !== 'function' ||\n    typeof logger.warn !== 'function' ||\n    typeof logger.error !== 'function') {\n    return new ConsoleLogger()\n  }\n\n  return logger\n}\n","'use strict'\n\nconst retry = require('retry')\nconst { request } = require('http')\nconst FormData = require('form-data')\n\n// TODO: avoid using dd-trace internals. Make this a separate module?\nconst docker = require('../../exporters/common/docker')\nconst version = require('../../../lib/version')\n\nconst containerId = docker.id()\n\nfunction sendRequest (options, form, callback) {\n  const req = request(options, res => {\n    if (res.statusCode >= 400) {\n      const error = new Error(`HTTP Error ${res.statusCode}`)\n      error.status = res.statusCode\n      callback(error)\n    } else {\n      callback(null, res)\n    }\n  })\n  req.on('error', callback)\n  if (form) form.pipe(req)\n  req.end()\n}\n\nfunction getBody (stream, callback) {\n  const chunks = []\n  stream.on('error', callback)\n  stream.on('data', chunk => chunks.push(chunk))\n  stream.on('end', () => {\n    callback(null, Buffer.concat(chunks))\n  })\n}\n\nfunction computeRetries (uploadTimeout) {\n  let tries = 0\n  while (tries < 2 || uploadTimeout > 1000) {\n    tries++\n    uploadTimeout /= 2\n  }\n  return [tries, Math.floor(uploadTimeout)]\n}\n\nclass AgentExporter {\n  constructor ({ url, logger, uploadTimeout } = {}) {\n    this._url = url\n    this._logger = logger\n\n    const [backoffTries, backoffTime] = computeRetries(uploadTimeout)\n\n    this._backoffTime = backoffTime\n    this._backoffTries = backoffTries\n  }\n\n  export ({ profiles, start, end, tags }) {\n    const types = Object.keys(profiles)\n\n    const fields = [\n      ['recording-start', start.toISOString()],\n      ['recording-end', end.toISOString()],\n      ['language', 'javascript'],\n      ['runtime', 'nodejs'],\n      ['runtime_version', process.version],\n      ['profiler_version', version],\n      ['format', 'pprof'],\n\n      ['tags[]', 'language:javascript'],\n      ['tags[]', 'runtime:nodejs'],\n      ['tags[]', `runtime_version:${process.version}`],\n      ['tags[]', `profiler_version:${version}`],\n      ['tags[]', 'format:pprof'],\n      ...Object.entries(tags).map(([key, value]) => ['tags[]', `${key}:${value}`])\n    ]\n\n    this._logger.debug(() => {\n      const body = fields.map(([key, value]) => `  ${key}: ${value}`).join('\\n')\n      return `Building agent export report: ${'\\n' + body}`\n    })\n\n    for (let index = 0; index < types.length; index++) {\n      const type = types[index]\n      const buffer = profiles[type]\n\n      this._logger.debug(() => {\n        const bytes = buffer.toString('hex').match(/../g).join(' ')\n        return `Adding ${type} profile to agent export: ` + bytes\n      })\n\n      fields.push([`types[${index}]`, type])\n      fields.push([`data[${index}]`, buffer, {\n        filename: `${type}.pb.gz`,\n        contentType: 'application/octet-stream',\n        knownLength: buffer.length\n      }])\n    }\n\n    return new Promise((resolve, reject) => {\n      const operation = retry.operation({\n        randomize: true,\n        minTimeout: this._backoffTime,\n        retries: this._backoffTries\n      })\n\n      operation.attempt((attempt) => {\n        const form = new FormData()\n\n        for (const [key, value, options] of fields) {\n          form.append(key, value, options)\n        }\n\n        const options = {\n          method: 'POST',\n          path: '/profiling/v1/input',\n          headers: form.getHeaders(),\n          timeout: this._backoffTime * Math.pow(2, attempt)\n        }\n\n        if (containerId) {\n          options.headers['Datadog-Container-ID'] = containerId\n        }\n\n        if (this._url.protocol === 'unix:') {\n          options.socketPath = this._url.pathname\n        } else {\n          options.protocol = this._url.protocol\n          options.hostname = this._url.hostname\n          options.port = this._url.port\n        }\n\n        this._logger.debug(() => {\n          return `Submitting profiler agent report attempt #${attempt} to: ${JSON.stringify(options)}`\n        })\n\n        sendRequest(options, form, (err, response) => {\n          if (operation.retry(err)) {\n            this._logger.error(`Error from the agent: ${err.message}`)\n            return\n          } else if (err) {\n            reject(new Error('Profiler agent export back-off period expired'))\n            return\n          }\n\n          getBody(response, (err, body) => {\n            if (err) {\n              this._logger.error(`Error reading agent response: ${err.message}`)\n            } else {\n              this._logger.debug(() => {\n                const bytes = (body.toString('hex').match(/../g) || []).join(' ')\n                return `Agent export response: ${bytes}`\n              })\n            }\n          })\n\n          resolve()\n        })\n      })\n    })\n  }\n}\n\nmodule.exports = { AgentExporter, computeRetries }\n","'use strict'\n\nconst fs = require('fs')\nconst { promisify } = require('util')\nconst writeFile = promisify(fs.writeFile)\n\nclass FileExporter {\n  export ({ profiles }) {\n    const types = Object.keys(profiles)\n    const tasks = types.map(type => {\n      return writeFile(`${type}.pb.gz`, profiles[type])\n    })\n\n    return Promise.all(tasks)\n  }\n}\n\nmodule.exports = { FileExporter }\n","'use strict'\n\nconst { Profiler } = require('./profiler')\nconst CpuProfiler = require('./profilers/cpu')\nconst HeapProfiler = require('./profilers/heap')\nconst { AgentExporter } = require('./exporters/agent')\nconst { FileExporter } = require('./exporters/file')\nconst { ConsoleLogger } = require('./loggers/console')\n\nconst profiler = new Profiler()\n\nmodule.exports = {\n  profiler,\n  AgentExporter,\n  FileExporter,\n  CpuProfiler,\n  HeapProfiler,\n  ConsoleLogger\n}\n","'use strict'\n\n/* eslint-disable no-console */\n\n// https://en.wikipedia.org/wiki/Syslog#Severity_level\nconst mapping = {\n  error: 3,\n  warn: 4,\n  info: 6,\n  debug: 7\n}\n\nclass ConsoleLogger {\n  constructor (options = {}) {\n    this._level = mapping[options.level] || mapping['error']\n  }\n\n  debug (message) {\n    this._log('debug', message)\n  }\n\n  info (message) {\n    this._log('info', message)\n  }\n\n  warn (message) {\n    this._log('warn', message)\n  }\n\n  error (message) {\n    this._log('error', message)\n  }\n\n  _log (level, message) {\n    if (mapping[level] > this._level) return\n\n    console[level](message)\n  }\n}\n\nmodule.exports = { ConsoleLogger }\n","'use strict'\n\nconst { EventEmitter } = require('events')\nconst { Config } = require('./config')\n\nfunction maybeSourceMap (sourceMap) {\n  if (!sourceMap) return\n\n  const { SourceMapper } = require('@datadog/pprof')\n  return SourceMapper.create([\n    process.cwd()\n  ])\n}\n\nclass Profiler extends EventEmitter {\n  constructor () {\n    super()\n    this._enabled = false\n    this._logger = undefined\n    this._config = undefined\n    this._timer = undefined\n    this._lastStart = undefined\n  }\n\n  start (options) {\n    this._start(options).catch(() => {})\n    return this\n  }\n\n  async _start (options) {\n    if (this._enabled) return\n\n    const config = this._config = new Config(options)\n    if (!config.enabled) return\n\n    this._logger = config.logger\n    this._enabled = true\n\n    try {\n      const mapper = await maybeSourceMap(config.sourceMap)\n\n      for (const profiler of config.profilers) {\n        // TODO: move this out of Profiler when restoring sourcemap support\n        profiler.start({ mapper })\n        this._logger.debug(`Started ${profiler.type} profiler`)\n      }\n\n      this._capture(config.flushInterval)\n    } catch (e) {\n      this._logger.error(e)\n      this.stop()\n    }\n  }\n\n  stop () {\n    if (!this._enabled) return\n\n    this._enabled = false\n\n    for (const profiler of this._config.profilers) {\n      profiler.stop()\n      this._logger.debug(`Stopped ${profiler.type} profiler`)\n    }\n\n    clearTimeout(this._timer)\n    this._timer = undefined\n\n    return this\n  }\n\n  _capture (timeout) {\n    if (!this._enabled) return\n    this._lastStart = new Date()\n\n    if (!this._timer || timeout !== this._config.flushInterval) {\n      this._timer = setTimeout(() => this._collect(), timeout)\n      this._timer.unref()\n    } else {\n      this._timer.refresh()\n    }\n  }\n\n  async _collect () {\n    const start = this._lastStart\n    const end = new Date()\n    const profiles = {}\n\n    try {\n      for (const profiler of this._config.profilers) {\n        const profile = profiler.profile()\n        if (!profile) continue\n\n        profiles[profiler.type] = await profiler.encode(profile)\n        this._logger.debug(`Collected ${profiler.type} profile: ` + JSON.stringify(profile))\n      }\n\n      this._capture(this._config.flushInterval)\n      await this._submit(profiles, start, end)\n      this._logger.debug('Submitted profiles')\n    } catch (err) {\n      this._logger.error(err)\n      this.stop()\n    }\n  }\n\n  _submit (profiles, start, end) {\n    if (!Object.keys(profiles).length) {\n      return Promise.reject(new Error('No profiles to submit'))\n    }\n    const { tags } = this._config\n    const tasks = []\n\n    for (const exporter of this._config.exporters) {\n      const task = exporter.export({ profiles, start, end, tags })\n        .catch(err => this._logger.error(err))\n\n      tasks.push(task)\n    }\n\n    return Promise.all(tasks)\n  }\n}\n\nmodule.exports = { Profiler }\n","'use strict'\n\nclass NativeCpuProfiler {\n  constructor (options = {}) {\n    this.type = 'wall'\n    this._samplingInterval = options.samplingInterval || 10 * 1000\n    this._mapper = undefined\n    this._pprof = undefined\n  }\n\n  start ({ mapper } = {}) {\n    this._mapper = mapper\n    this._pprof = require('@datadog/pprof')\n\n    // pprof otherwise crashes in worker threads\n    if (!process._startProfilerIdleNotifier) {\n      process._startProfilerIdleNotifier = () => {}\n    }\n    if (!process._stopProfilerIdleNotifier) {\n      process._stopProfilerIdleNotifier = () => {}\n    }\n\n    this._record()\n  }\n\n  profile () {\n    if (!this._stop) return\n    return this._stop(true)\n  }\n\n  encode (profile) {\n    return this._pprof.encode(profile)\n  }\n\n  stop () {\n    if (!this._stop) return\n    this._stop()\n  }\n\n  _record () {\n    this._stop = this._pprof.time.start(this._samplingInterval, null,\n      this._mapper, false)\n  }\n}\n\nmodule.exports = NativeCpuProfiler\n","'use strict'\n\nclass NativeHeapProfiler {\n  constructor (options = {}) {\n    this.type = 'space'\n    this._samplingInterval = options.samplingInterval || 512 * 1024\n    this._stackDepth = options.stackDepth || 64\n    this._pprof = undefined\n  }\n\n  start ({ mapper } = {}) {\n    this._mapper = mapper\n    this._pprof = require('@datadog/pprof')\n    this._pprof.heap.start(this._samplingInterval, this._stackDepth)\n  }\n\n  profile () {\n    return this._pprof.heap.profile(undefined, this._mapper)\n  }\n\n  encode (profile) {\n    return this._pprof.encode(profile)\n  }\n\n  stop () {\n    this._pprof.heap.stop()\n  }\n}\n\nmodule.exports = NativeHeapProfiler\n","'use strict'\n\nconst tagger = {\n  parse (tags) {\n    if (!tags) return {}\n\n    switch (typeof tags) {\n      case 'object':\n        if (Array.isArray(tags)) {\n          return tags.reduce((prev, next) => {\n            const parts = next.split(':')\n            const key = parts.shift().trim()\n            const value = parts.join(':').trim()\n\n            if (!key || !value) return prev\n\n            return Object.assign(prev, { [key]: value })\n          }, {})\n        } else {\n          return tagger.parse(Object.keys(tags)\n            .filter(key => tags[key] !== undefined && tags[key] !== null)\n            .map(key => `${key}:${tags[key]}`))\n        }\n      case 'string':\n        return tagger.parse(tags.split(','))\n      default:\n        return {}\n    }\n  }\n}\n\nmodule.exports = { tagger }\n","'use strict'\n\nconst BaseTracer = require('opentracing').Tracer\nconst NoopTracer = require('./noop/tracer')\nconst DatadogTracer = require('./tracer')\nconst Config = require('./config')\nconst Instrumenter = require('./instrumenter')\nconst PluginManager = require('./plugin_manager')\nconst metrics = require('./metrics')\nconst log = require('./log')\nconst { isFalse } = require('./util')\nconst { setStartupLogInstrumenter } = require('./startup-log')\nconst telemetry = require('./telemetry')\n\nconst noop = new NoopTracer()\n\nclass Tracer extends BaseTracer {\n  constructor () {\n    super()\n\n    this._initialized = false\n    this._tracer = noop\n    this._instrumenter = new Instrumenter(this)\n    this._pluginManager = new PluginManager(this)\n    this._deprecate = method => log.deprecate(`tracer.${method}`, [\n      `tracer.${method}() is deprecated.`,\n      'Please use tracer.startSpan() and tracer.scope() instead.',\n      'See: https://datadog.github.io/dd-trace-js/#manual-instrumentation.'\n    ].join(' '))\n  }\n\n  init (options) {\n    if (isFalse(process.env.DD_TRACE_ENABLED) || this._initialized) return this\n\n    this._initialized = true\n\n    try {\n      const config = new Config(options) // TODO: support dynamic config\n\n      log.use(config.logger)\n      log.toggle(config.debug, config.logLevel, this)\n\n      if (config.profiling.enabled) {\n        // do not stop tracer initialization if the profiler fails to be imported\n        try {\n          const profiler = require('./profiler')\n          profiler.start(config)\n        } catch (e) {\n          log.error(e)\n        }\n      }\n\n      if (config.runtimeMetrics) {\n        metrics.start(config)\n      }\n\n      if (config.tracing) {\n        // dirty require for now so zero appsec code is executed unless explicitly enabled\n        if (config.appsec.enabled) {\n          require('./appsec').enable(config)\n        }\n\n        this._tracer = new DatadogTracer(config)\n        this._instrumenter.enable(config)\n        this._pluginManager.configure(config)\n        setStartupLogInstrumenter(this._instrumenter)\n        telemetry.start(config, this._instrumenter, this._pluginManager)\n      }\n    } catch (e) {\n      log.error(e)\n    }\n\n    return this\n  }\n\n  use () {\n    this._instrumenter.use(...arguments)\n    this._pluginManager.configurePlugin(...arguments)\n    return this\n  }\n\n  trace (name, options, fn) {\n    if (!fn) {\n      fn = options\n      options = {}\n    }\n\n    if (typeof fn !== 'function') return\n\n    options = options || {}\n\n    return this._tracer.trace(name, options, fn)\n  }\n\n  wrap (name, options, fn) {\n    if (!fn) {\n      fn = options\n      options = {}\n    }\n\n    if (typeof fn !== 'function') return fn\n\n    options = options || {}\n\n    return this._tracer.wrap(name, options, fn)\n  }\n\n  setUrl () {\n    this._tracer.setUrl.apply(this._tracer, arguments)\n    return this\n  }\n\n  startSpan () {\n    return this._tracer.startSpan.apply(this._tracer, arguments)\n  }\n\n  inject () {\n    return this._tracer.inject.apply(this._tracer, arguments)\n  }\n\n  extract () {\n    return this._tracer.extract.apply(this._tracer, arguments)\n  }\n\n  scope () {\n    return this._tracer.scope.apply(this._tracer, arguments)\n  }\n\n  currentSpan () {\n    this._deprecate('currentSpan')\n    return this._tracer.currentSpan.apply(this._tracer, arguments)\n  }\n\n  bind (callback) {\n    this._deprecate('bind')\n    return callback\n  }\n\n  bindEmitter () {\n    this._deprecate('bindEmitter')\n  }\n\n  getRumData () {\n    return this._tracer.getRumData.apply(this._tracer, arguments)\n  }\n\n  setUser () {\n    return this._tracer.setUser.apply(this.tracer, arguments)\n  }\n}\n\nmodule.exports = Tracer\n","'use strict'\n\nconst limiter = require('limiter')\n\nclass RateLimiter {\n  constructor (rateLimit) {\n    this._rateLimit = parseInt(rateLimit)\n    this._limiter = new limiter.RateLimiter(this._rateLimit, 'second')\n    this._tokensRequested = 0\n    this._prevIntervalTokens = 0\n    this._prevTokensRequested = 0\n  }\n\n  isAllowed () {\n    const curIntervalStart = this._limiter.curIntervalStart\n    const curIntervalTokens = this._limiter.tokensThisInterval\n    const allowed = this._isAllowed()\n\n    if (curIntervalStart !== this._limiter.curIntervalStart) {\n      this._prevIntervalTokens = curIntervalTokens\n      this._prevTokensRequested = this._tokensRequested\n      this._tokensRequested = 1\n    } else {\n      this._tokensRequested++\n    }\n\n    return allowed\n  }\n\n  effectiveRate () {\n    if (this._rateLimit < 0) return 1\n    if (this._rateLimit === 0) return 0\n    if (this._tokensRequested === 0) return 1\n\n    const allowed = this._prevIntervalTokens + this._limiter.tokensThisInterval\n    const requested = this._prevTokensRequested + this._tokensRequested\n\n    return allowed / requested\n  }\n\n  _isAllowed () {\n    if (this._rateLimit < 0) return true\n    if (this._rateLimit === 0) return false\n\n    return this._limiter.tryRemoveTokens(1)\n  }\n\n  _currentWindowRate () {\n    if (this._rateLimit < 0) return 1\n    if (this._rateLimit === 0) return 0\n    if (this._tokensRequested === 0) return 1\n\n    return this._limiter.tokensThisInterval / this._tokensRequested\n  }\n}\n\nmodule.exports = RateLimiter\n","'use strict'\n\nconst path = require('path')\nconst fs = require('fs')\n\n/**\n * Given a package name and a module to start from, find a package's\n * package.json file, parses it, and returns the result.\n *\n * Equivalent to require(`${name}/package.json`) prior to Node 12.\n *\n * @typedef { import('module').Module } Module\n * @param {string} name\n * @param {Module} module\n * @return {Object} The parsed package.json\n */\nfunction requirePackageJson (name, module) {\n  if (path.isAbsolute(name)) {\n    const candidate = path.join(name, 'package.json')\n    return JSON.parse(fs.readFileSync(candidate, 'utf8'))\n  }\n  for (const modulePath of module.paths) {\n    const candidate = path.join(modulePath, name, 'package.json')\n    try {\n      return JSON.parse(fs.readFileSync(candidate, 'utf8'))\n    } catch (e) {\n      continue\n    }\n  }\n  throw new Error(`could not find ${name}/package.json`)\n}\n\nmodule.exports = requirePackageJson\n","'use strict'\n\nconst path = require('path')\nconst Module = require('module')\nconst parse = require('module-details-from-path')\n\nconst origRequire = Module.prototype.require\n\n// derived from require-in-the-middle@3 with tweaks\n\nmodule.exports = Hook\n\nlet moduleHooks = Object.create(null)\nlet cache = Object.create(null)\nlet patching = Object.create(null)\nlet patchedRequire = null\n\nfunction Hook (modules, options, onrequire) {\n  if (!(this instanceof Hook)) return new Hook(modules, options, onrequire)\n  if (typeof modules === 'function') {\n    onrequire = modules\n    modules = null\n    options = {}\n  } else if (typeof options === 'function') {\n    onrequire = options\n    options = {}\n  }\n\n  modules = modules || []\n  options = options || {}\n\n  this.modules = modules\n  this.options = options\n  this.onrequire = onrequire\n\n  if (Array.isArray(modules)) {\n    for (const mod of modules) {\n      const hooks = moduleHooks[mod]\n\n      if (hooks) {\n        hooks.push(onrequire)\n      } else {\n        moduleHooks[mod] = [onrequire]\n      }\n    }\n  }\n\n  if (patchedRequire) return\n\n  patchedRequire = Module.prototype.require = function (request) {\n    const filename = Module._resolveFilename(request, this)\n    const core = filename.indexOf(path.sep) === -1\n    let name, basedir, hooks\n\n    // return known patched modules immediately\n    if (cache[filename]) {\n      // require.cache was potentially altered externally\n      if (require.cache[filename] && require.cache[filename].exports !== cache[filename].original) {\n        return require.cache[filename].exports\n      }\n\n      return cache[filename].exports\n    }\n\n    // Check if this module has a patcher in-progress already.\n    // Otherwise, mark this module as patching in-progress.\n    const patched = patching[filename]\n    if (!patched) {\n      patching[filename] = true\n    }\n\n    const exports = origRequire.apply(this, arguments)\n\n    // If it's already patched, just return it as-is.\n    if (patched) return exports\n\n    // The module has already been loaded,\n    // so the patching mark can be cleaned up.\n    delete patching[filename]\n\n    if (core) {\n      hooks = moduleHooks[filename]\n      if (!hooks) return exports // abort if module name isn't on whitelist\n      name = filename\n    } else {\n      const stat = parse(filename)\n      if (!stat) return exports // abort if filename could not be parsed\n      name = stat.name\n      basedir = stat.basedir\n\n      hooks = moduleHooks[name]\n      if (!hooks) return exports // abort if module name isn't on whitelist\n\n      // figure out if this is the main module file, or a file inside the module\n      const paths = Module._resolveLookupPaths(name, this, true)\n      if (!paths) {\n        // abort if _resolveLookupPaths return null\n        return exports\n      }\n      const res = Module._findPath(name, [basedir, ...paths])\n      if (res !== filename) {\n        // this is a module-internal file\n        // use the module-relative path to the file, prefixed by original module name\n        name = name + path.sep + path.relative(basedir, filename)\n      }\n    }\n\n    // ensure that the cache entry is assigned a value before calling\n    // onrequire, in case calling onrequire requires the same module.\n    cache[filename] = { exports }\n    cache[filename].original = exports\n\n    for (const hook of hooks) {\n      cache[filename].exports = hook(cache[filename].exports, name, basedir)\n    }\n\n    return cache[filename].exports\n  }\n}\n\nHook.reset = function () {\n  Module.prototype.require = origRequire\n  patchedRequire = null\n  patching = Object.create(null)\n  cache = Object.create(null)\n  moduleHooks = Object.create(null)\n}\n\nHook.prototype.unhook = function () {\n  for (const mod of this.modules) {\n    const hooks = (moduleHooks[mod] || []).filter(hook => hook !== this.onrequire)\n\n    if (hooks.length > 0) {\n      moduleHooks[mod] = hooks\n    } else {\n      delete moduleHooks[mod]\n    }\n  }\n\n  if (Object.keys(moduleHooks).length === 0) {\n    Hook.reset()\n  }\n}\n","'use strict'\n\nclass Sampler {\n  constructor (rate) {\n    this._rate = rate\n  }\n\n  rate () {\n    return this._rate\n  }\n\n  isSampled () {\n    return this._rate === 1 || Math.random() < this._rate\n  }\n}\n\nmodule.exports = Sampler\n","'use strict'\n\nconst { storage } = require('../../datadog-core')\n\n// TODO: deprecate binding event emitters in 3.0\n\nconst originals = new WeakMap()\nconst listenerMaps = new WeakMap()\nconst emitterSpans = new WeakMap()\nconst emitterScopes = new WeakMap()\nconst emitters = new WeakSet()\n\nclass Scope {\n  active () {\n    const store = storage.getStore()\n\n    return (store && store.span) || null\n  }\n\n  activate (span, callback) {\n    if (typeof callback !== 'function') return callback\n\n    const oldStore = storage.getStore()\n    const newStore = span ? span._store : oldStore\n\n    storage.enterWith({ ...newStore, span })\n\n    try {\n      return callback()\n    } catch (e) {\n      if (span && typeof span.setTag === 'function') {\n        span.setTag('error', e)\n      }\n\n      throw e\n    } finally {\n      storage.enterWith(oldStore)\n    }\n  }\n\n  bind (target, span) {\n    target = this._bindEmitter(target, span)\n    target = this._bindPromise(target, span)\n    target = this._bindFn(target, span)\n\n    return target\n  }\n\n  unbind (target) {\n    target = this._unbindFn(target)\n    target = this._unbindPromise(target)\n    target = this._unbindEmitter(target)\n\n    return target\n  }\n\n  _bindFn (fn, span) {\n    if (typeof fn !== 'function') return fn\n\n    const scope = this\n    const spanOrActive = this._spanOrActive(span)\n\n    const bound = function () {\n      return scope.activate(spanOrActive, () => {\n        return fn.apply(this, arguments)\n      })\n    }\n\n    originals.set(bound, fn)\n\n    return bound\n  }\n\n  _unbindFn (fn) {\n    if (typeof fn !== 'function') return fn\n\n    return originals.get(fn) || fn\n  }\n\n  _bindEmitter (emitter, span) {\n    if (!this._isEmitter(emitter)) return emitter\n    if (!emitters.has(emitter)) {\n      Scope._wrapEmitter(emitter)\n    }\n    emitterSpans.set(emitter, span)\n    emitterScopes.set(emitter, this)\n    return emitter\n  }\n\n  // Occasionally we want to wrap a prototype rather than emitter instances,\n  // so we're exposing this as a static method. This gives us a faster\n  // path for binding instances of known EventEmitter subclasses.\n  static _wrapEmitter (emitter) {\n    wrapMethod(emitter, 'addListener', wrapAddListener)\n    wrapMethod(emitter, 'prependListener', wrapAddListener)\n    wrapMethod(emitter, 'on', wrapAddListener)\n    wrapMethod(emitter, 'once', wrapAddListener)\n    wrapMethod(emitter, 'removeListener', wrapRemoveListener)\n    wrapMethod(emitter, 'off', wrapRemoveListener)\n    wrapMethod(emitter, 'removeAllListeners', wrapRemoveAllListeners)\n    emitters.add(emitter)\n  }\n\n  _unbindEmitter (emitter) {\n    if (!this._isEmitter(emitter)) return emitter\n    emitterScopes.delete(emitter)\n    emitterSpans.delete(emitter)\n    return emitter\n  }\n\n  _bindPromise (promise, span) {\n    if (!this._isPromise(promise)) return promise\n\n    wrapMethod(promise, 'then', wrapThen, this, span)\n\n    return promise\n  }\n\n  _unbindPromise (promise) {\n    if (!this._isPromise(promise)) return promise\n\n    promise.then = originals.get(promise.then) || promise.then\n\n    return promise\n  }\n\n  _spanOrActive (span) {\n    return span !== undefined ? span : this.active()\n  }\n\n  _isEmitter (emitter) {\n    return emitter &&\n      typeof emitter.emit === 'function' &&\n      typeof emitter.on === 'function' &&\n      typeof emitter.addListener === 'function' &&\n      typeof emitter.removeListener === 'function'\n  }\n\n  _isPromise (promise) {\n    return promise && typeof promise.then === 'function'\n  }\n}\n\nfunction getScope (emitter) {\n  return emitterScopes.get(emitter) || emitterScopes.get(emitter.constructor.prototype)\n}\n\nfunction getSpan (emitter) {\n  return emitterSpans.get(emitter) || emitterSpans.get(emitter.constructor.prototype)\n}\n\nfunction hasScope (emitter) {\n  return emitterScopes.has(emitter) || emitterScopes.has(emitter.constructor.prototype)\n}\n\nfunction wrapThen (then, scope, span) {\n  return function thenWithTrace (onFulfilled, onRejected) {\n    const args = new Array(arguments.length)\n\n    for (let i = 0, l = args.length; i < l; i++) {\n      args[i] = scope.bind(arguments[i], span)\n    }\n\n    return then.apply(this, args)\n  }\n}\n\nfunction wrapAddListener (addListener) {\n  return function addListenerWithTrace (eventName, listener) {\n    const scope = getScope(this)\n    if (!scope || !listener || originals.has(listener) || listener.listener) {\n      return addListener.apply(this, arguments)\n    }\n    const span = getSpan(this)\n\n    const bound = scope.bind(listener, scope._spanOrActive(span))\n    const listenerMap = listenerMaps.get(this) || {}\n\n    listenerMaps.set(this, listenerMap)\n\n    if (!listenerMap[eventName]) {\n      listenerMap[eventName] = new WeakMap()\n    }\n\n    const events = listenerMap[eventName]\n\n    if (!events.has(listener)) {\n      events.set(listener, [])\n    }\n\n    events.get(listener).push(bound)\n\n    return addListener.call(this, eventName, bound)\n  }\n}\n\nfunction wrapRemoveListener (removeListener) {\n  return function removeListenerWithTrace (eventName, listener) {\n    if (!hasScope(this)) {\n      return removeListener.apply(this, arguments)\n    }\n\n    const listenerMap = listenerMaps.get(this)\n    const listeners = listenerMap && listenerMap[eventName]\n\n    if (!listener || !listeners || !listeners.has(listener)) {\n      return removeListener.apply(this, arguments)\n    }\n\n    for (const bound of listeners.get(listener)) {\n      removeListener.call(this, eventName, bound)\n    }\n\n    listeners.delete(listener)\n\n    return removeListener.apply(this, arguments)\n  }\n}\n\nfunction wrapRemoveAllListeners (removeAllListeners) {\n  return function removeAllListenersWithTrace (eventName) {\n    const listenerMap = listenerMaps.get(this)\n\n    if (hasScope(this) && listenerMap) {\n      if (eventName) {\n        delete listenerMap[eventName]\n      } else {\n        listenerMaps.delete(this)\n      }\n    }\n\n    return removeAllListeners.apply(this, arguments)\n  }\n}\n\nfunction wrapMethod (target, name, wrapper, ...args) {\n  if (!target[name] || originals.has(target[name])) return\n\n  const original = target[name]\n\n  target[name] = wrapper(target[name], ...args)\n  originals.set(target[name], original)\n}\n\nmodule.exports = Scope\n","'use strict'\n\nconst log = require('./log')\nconst format = require('./format')\n\nconst startedSpans = new WeakSet()\nconst finishedSpans = new WeakSet()\n\nclass SpanProcessor {\n  constructor (exporter, prioritySampler, config) {\n    this._exporter = exporter\n    this._prioritySampler = prioritySampler\n    this._config = config\n  }\n\n  process (span) {\n    const spanContext = span.context()\n    const active = []\n    const formatted = []\n    const trace = spanContext._trace\n    const { flushMinSpans } = this._config\n    const { started, finished } = trace\n\n    if (started.length === finished.length || finished.length >= flushMinSpans) {\n      this._prioritySampler.sample(spanContext)\n\n      for (const span of started) {\n        if (span._duration !== undefined) {\n          formatted.push(format(span))\n        } else {\n          active.push(span)\n        }\n      }\n\n      this._exporter.export(formatted)\n      this._erase(trace, active)\n    }\n  }\n\n  _erase (trace, active) {\n    if (process.env.DD_TRACE_EXPERIMENTAL_STATE_TRACKING === 'true') {\n      const started = new Set()\n      const startedIds = new Set()\n      const finished = new Set()\n      const finishedIds = new Set()\n\n      for (const span of trace.finished) {\n        const context = span.context()\n        const id = context.toSpanId()\n\n        if (finished.has(span)) {\n          log.error(`Span was already finished in the same trace: ${span}`)\n        } else {\n          finished.add(span)\n\n          if (finishedIds.has(id)) {\n            log.error(`Another span with the same ID was already finished in the same trace: ${span}`)\n          } else {\n            finishedIds.add(id)\n          }\n\n          if (context._trace !== trace) {\n            log.error(`A span was finished in the wrong trace: ${span}.`)\n          }\n\n          if (finishedSpans.has(span)) {\n            log.error(`Span was already finished in a different trace: ${span}`)\n          } else {\n            finishedSpans.add(span)\n          }\n        }\n      }\n\n      for (const span of trace.started) {\n        const context = span.context()\n        const id = context.toSpanId()\n\n        if (started.has(span)) {\n          log.error(`Span was already started in the same trace: ${span}`)\n        } else {\n          started.add(span)\n\n          if (startedIds.has(id)) {\n            log.error(`Another span with the same ID was already started in the same trace: ${span}`)\n          } else {\n            startedIds.add(id)\n          }\n\n          if (context._trace !== trace) {\n            log.error(`A span was started in the wrong trace: ${span}.`)\n          }\n\n          if (startedSpans.has(span)) {\n            log.error(`Span was already started in a different trace: ${span}`)\n          } else {\n            startedSpans.add(span)\n          }\n        }\n\n        if (!finished.has(span)) {\n          log.error(`Span started in one trace but was finished in another trace: ${span}`)\n        }\n      }\n\n      for (const span of trace.finished) {\n        if (!started.has(span)) {\n          log.error(`Span finished in one trace but was started in another trace: ${span}`)\n        }\n      }\n    }\n\n    for (const span of trace.finished) {\n      span.context()._tags = {}\n    }\n\n    trace.started = active\n    trace.finished = []\n  }\n}\n\nmodule.exports = SpanProcessor\n","'use strict'\n\nconst mainLogger = require('./log')\n\nconst os = require('os')\nconst { inspect } = require('util')\nconst tracerVersion = require('../lib/version')\nconst requirePackageJson = require('./require-package-json')\n\nconst logger = Object.create(mainLogger)\nlogger._enabled = true\n\nlet config\nlet instrumenter\nlet samplingRules = []\n\nlet alreadyRan = false\n\nfunction getIntegrationsAndAnalytics () {\n  const integrations = new Set()\n  const extras = {}\n  for (const plugin of instrumenter._instrumented.keys()) {\n    if (plugin.versions) {\n      try {\n        const version = requirePackageJson(plugin.name, module).version\n        integrations.add(`${plugin.name}@${version}`)\n      } catch (e) {\n        integrations.add(plugin.name)\n      }\n    } else {\n      integrations.add(plugin.name)\n    }\n  }\n  extras.integrations_loaded = Array.from(integrations)\n  return extras\n}\n\nfunction startupLog ({ agentError } = {}) {\n  if (!config || !instrumenter) {\n    return\n  }\n\n  if (alreadyRan) {\n    return\n  }\n\n  alreadyRan = true\n\n  if (!config.startupLogs) {\n    return\n  }\n\n  const url = config.url || `http://${config.hostname || 'localhost'}:${config.port}`\n\n  const out = {\n    [inspect.custom] () {\n      return String(this)\n    },\n    toString () {\n      return JSON.stringify(this)\n    }\n  }\n\n  out.date = new Date().toISOString()\n  out.os_name = os.type()\n  out.os_version = os.release()\n  out.architecture = os.arch()\n  out.version = tracerVersion\n  out.lang = 'nodejs'\n  out.lang_version = process.versions.node\n  out.env = config.env\n  out.enabled = config.enabled\n  out.service = config.service\n  out.agent_url = url\n  if (agentError) {\n    out.agent_error = agentError.message\n  }\n  out.debug = !!config.debug\n  out.sample_rate = config.sampleRate\n  out.sampling_rules = samplingRules\n  out.tags = config.tags\n  if (config.tags && config.tags.version) {\n    out.dd_version = config.tags.version\n  }\n\n  out.log_injection_enabled = !!config.logInjection\n  out.runtime_metrics_enabled = !!config.runtimeMetrics\n  out.profiling_enabled = !!(config.profiling || {}).enabled\n  Object.assign(out, getIntegrationsAndAnalytics())\n\n  out.appsec_enabled = !!config.appsec.enabled\n\n  // // This next bunch is for features supported by other tracers, but not this\n  // // one. They may be implemented in the future.\n\n  // out.enabled_cli\n  // out.sampling_rules_error\n  // out.integration_XXX_analytics_enabled\n  // out.integration_XXX_sample_rate\n  // out.service_mapping\n  // out.service_mapping_error\n\n  logger.info('DATADOG TRACER CONFIGURATION - ' + out)\n  if (agentError) {\n    logger.warn('DATADOG TRACER DIAGNOSTIC - Agent Error: ' + agentError.message)\n  }\n\n  config = undefined\n  instrumenter = undefined\n  samplingRules = undefined\n}\n\nfunction setStartupLogConfig (aConfig) {\n  config = aConfig\n}\n\nfunction setStartupLogInstrumenter (theInstrumenter) {\n  instrumenter = theInstrumenter\n}\n\nfunction setSamplingRules (theRules) {\n  samplingRules = theRules\n}\n\nmodule.exports = {\n  startupLog,\n  setStartupLogConfig,\n  setStartupLogInstrumenter,\n  setSamplingRules\n}\n","'use strict'\n\nconst log = require('./log')\n\nfunction add (carrier, keyValuePairs) {\n  if (!carrier || !keyValuePairs) return\n\n  if (Array.isArray(keyValuePairs)) {\n    return keyValuePairs.forEach(tags => add(carrier, tags))\n  }\n\n  try {\n    if (typeof keyValuePairs === 'string') {\n      const segments = keyValuePairs.split(',')\n      for (const segment of segments) {\n        const separatorIndex = segment.indexOf(':')\n        if (separatorIndex === -1) continue\n\n        const key = segment.slice(0, separatorIndex)\n        const value = segment.slice(separatorIndex + 1)\n\n        carrier[key.trim()] = value.trim()\n      }\n    } else {\n      Object.assign(carrier, keyValuePairs)\n    }\n  } catch (e) {\n    log.error(e)\n  }\n}\n\nmodule.exports = { add }\n","'use strict'\n\nconst tracerVersion = require('../lib/version')\nconst pkg = require('./pkg')\nconst containerId = require('./exporters/common/docker').id()\nconst requirePackageJson = require('./require-package-json')\nconst path = require('path')\nconst os = require('os')\nconst request = require('./exporters/common/request')\n\nlet config\nlet instrumenter\nlet pluginManager\n\nlet seqId = 0\nlet application\nlet host\nlet interval\nconst sentIntegrations = new Set()\n\nfunction getIntegrations () {\n  const newIntegrations = []\n  for (const plugin of instrumenter._instrumented.keys()) {\n    if (sentIntegrations.has(plugin.name)) {\n      continue\n    }\n    newIntegrations.push({\n      name: plugin.name,\n      enabled: true,\n      auto_enabled: true\n    })\n    sentIntegrations.add(plugin.name)\n  }\n  for (const pluginName in pluginManager._pluginsByName) {\n    if (sentIntegrations.has(pluginName)) {\n      continue\n    }\n    newIntegrations.push({\n      name: pluginName,\n      enabled: pluginManager._pluginsByName[pluginName]._enabled,\n      auto_enabled: true\n    })\n    sentIntegrations.add(pluginName)\n  }\n  return newIntegrations\n}\n\nfunction getDependencies () {\n  const deps = []\n  const { dependencies } = pkg\n  if (!dependencies) {\n    return deps\n  }\n  const rootDir = pkg.findRoot()\n  for (const [name, version] of Object.entries(dependencies)) {\n    const dep = { name }\n    try {\n      dep.version = requirePackageJson(\n        path.join(rootDir, 'node_modules', name.replace('/', path.sep))\n      ).version\n    } catch (e) {\n      dep.version = version\n    }\n    deps.push(dep)\n  }\n  return deps\n}\n\nfunction flatten (input, result = [], prefix = [], traversedObjects = null) {\n  traversedObjects = traversedObjects || new WeakSet()\n  if (traversedObjects.has(input)) {\n    return\n  }\n  traversedObjects.add(input)\n  for (const [key, value] of Object.entries(input)) {\n    if (typeof value === 'object' && value !== null) {\n      flatten(value, result, [...prefix, key], traversedObjects)\n    } else {\n      result.push({ name: [...prefix, key].join('.'), value })\n    }\n  }\n  return result\n}\n\nfunction appStarted () {\n  return {\n    integrations: getIntegrations(),\n    dependencies: getDependencies(),\n    configuration: flatten(config),\n    additional_payload: []\n  }\n}\n\nfunction onBeforeExit () {\n  process.removeListener('beforeExit', onBeforeExit)\n  sendData('app-closing')\n}\n\nfunction createAppObject () {\n  return {\n    service_name: config.service,\n    env: config.env,\n    service_version: config.version,\n    tracer_version: tracerVersion,\n    language_name: 'nodejs',\n    language_version: process.versions.node\n  }\n}\n\nfunction createHostObject () {\n  return {\n    hostname: os.hostname(), // TODO is this enough?\n    container_id: containerId\n  }\n}\n\nfunction sendData (reqType, payload = {}) {\n  const {\n    hostname,\n    port\n  } = config\n  const options = {\n    hostname,\n    port,\n    method: 'POST',\n    path: '/telemetry/proxy/api/v2/apmtelemetry',\n    headers: {\n      'content-type': 'application/json',\n      'dd-telemetry-api-version': 'v1',\n      'dd-telemetry-request-type': reqType\n    }\n  }\n  const data = JSON.stringify({\n    api_version: 'v1',\n    request_type: reqType,\n    tracer_time: Math.floor(Date.now() / 1000),\n    runtime_id: config.tags['runtime-id'],\n    seq_id: ++seqId,\n    payload,\n    application,\n    host\n  })\n\n  request(data, options, true, () => {\n    // ignore errors\n  })\n}\n\nfunction start (aConfig, theInstrumenter, thePluginManager) {\n  if (!aConfig.telemetryEnabled) {\n    return\n  }\n  config = aConfig\n  instrumenter = theInstrumenter\n  pluginManager = thePluginManager\n  application = createAppObject()\n  host = createHostObject()\n  sendData('app-started', appStarted())\n  interval = setInterval(() => sendData('app-heartbeat'), 60000)\n  interval.unref()\n  process.on('beforeExit', onBeforeExit)\n}\n\nfunction stop () {\n  if (!config) {\n    return\n  }\n  clearInterval(interval)\n  process.removeListener('beforeExit', onBeforeExit)\n}\n\nfunction updateIntegrations () {\n  if (!config || !config.telemetryEnabled) {\n    return\n  }\n  const integrations = getIntegrations()\n  if (integrations.length === 0) {\n    return\n  }\n  sendData('app-integrations-change', { integrations })\n}\n\nmodule.exports = {\n  start,\n  stop,\n  updateIntegrations\n}\n","'use strict'\n\nconst Tracer = require('./opentracing/tracer')\nconst tags = require('../../../ext/tags')\nconst Scope = require('./scope')\nconst { storage } = require('../../datadog-core')\nconst { isError } = require('./util')\nconst { setStartupLogConfig } = require('./startup-log')\n\nconst SPAN_TYPE = tags.SPAN_TYPE\nconst RESOURCE_NAME = tags.RESOURCE_NAME\nconst SERVICE_NAME = tags.SERVICE_NAME\nconst MEASURED = tags.MEASURED\n\nclass DatadogTracer extends Tracer {\n  constructor (config) {\n    super(config)\n\n    this._scope = new Scope()\n    setStartupLogConfig(config)\n  }\n\n  trace (name, options, fn) {\n    options = Object.assign({\n      childOf: this.scope().active()\n    }, options)\n\n    if (!options.childOf && options.orphanable === false) {\n      return fn(null, () => {})\n    }\n\n    const span = this.startSpan(name, options)\n\n    addTags(span, options)\n\n    try {\n      if (fn.length > 1) {\n        return this.scope().activate(span, () => fn(span, err => {\n          addError(span, err)\n          span.finish()\n        }))\n      }\n\n      const result = this.scope().activate(span, () => fn(span))\n\n      if (result && typeof result.then === 'function') {\n        result.then(\n          () => span.finish(),\n          err => {\n            addError(span, err)\n            span.finish()\n          }\n        )\n      } else {\n        span.finish()\n      }\n\n      return result\n    } catch (e) {\n      addError(span, e)\n      span.finish()\n      throw e\n    }\n  }\n\n  wrap (name, options, fn) {\n    const tracer = this\n\n    return function () {\n      const store = storage.getStore()\n\n      if (store && store.noop) return fn.apply(this, arguments)\n\n      let optionsObj = options\n      if (typeof optionsObj === 'function' && typeof fn === 'function') {\n        optionsObj = optionsObj.apply(this, arguments)\n      }\n\n      if (optionsObj && optionsObj.orphanable === false && !tracer.scope().active()) {\n        return fn.apply(this, arguments)\n      }\n\n      const lastArgId = arguments.length - 1\n      const cb = arguments[lastArgId]\n\n      if (typeof cb === 'function') {\n        const scopeBoundCb = tracer.scope().bind(cb)\n        return tracer.trace(name, optionsObj, (span, done) => {\n          arguments[lastArgId] = function (err) {\n            done(err)\n            return scopeBoundCb.apply(this, arguments)\n          }\n\n          return fn.apply(this, arguments)\n        })\n      } else {\n        return tracer.trace(name, optionsObj, () => fn.apply(this, arguments))\n      }\n    }\n  }\n\n  setUrl (url) {\n    this._exporter.setUrl(url)\n  }\n\n  scope () {\n    return this._scope\n  }\n\n  currentSpan () {\n    return this.scope().active()\n  }\n\n  getRumData () {\n    if (!this._enableGetRumData) {\n      return ''\n    }\n    const span = this.scope().active().context()\n    const traceId = span.toTraceId()\n    const traceTime = Date.now()\n    return `\\\n<meta name=\"dd-trace-id\" content=\"${traceId}\" />\\\n<meta name=\"dd-trace-time\" content=\"${traceTime}\" />`\n  }\n\n  setUser (user) {\n    if (!user || !user.id) return this\n\n    const span = this.scope().active()\n    if (!span) return this\n\n    const rootSpan = span._spanContext._trace.started[0]\n    if (!rootSpan) return this\n\n    for (const k of Object.keys(user)) {\n      rootSpan.setTag(`usr.${k}`, '' + user[k])\n    }\n\n    return this\n  }\n}\n\nfunction addError (span, error) {\n  if (isError(error)) {\n    span.addTags({\n      'error.type': error.name,\n      'error.msg': error.message,\n      'error.stack': error.stack\n    })\n  }\n}\n\nfunction addTags (span, options) {\n  const tags = {}\n\n  if (options.type) tags[SPAN_TYPE] = options.type\n  if (options.service) tags[SERVICE_NAME] = options.service\n  if (options.resource) tags[RESOURCE_NAME] = options.resource\n\n  tags[MEASURED] = options.measured\n\n  span.addTags(tags)\n}\n\nmodule.exports = DatadogTracer\n","'use strict'\n\nfunction isTrue (str) {\n  str = String(str).toLowerCase()\n  return str === 'true' || str === '1'\n}\n\nfunction isFalse (str) {\n  str = String(str).toLowerCase()\n  return str === 'false' || str === '0'\n}\n\nfunction isError (value) {\n  if (value instanceof Error) {\n    return true\n  }\n  if (value && value.message && value.stack) {\n    return true\n  }\n  return false\n}\n\nmodule.exports = {\n  isTrue,\n  isFalse,\n  isError\n}\n","'use strict';\n\n// From https://github.com/sindresorhus/random-int/blob/c37741b56f76b9160b0b63dae4e9c64875128146/index.js#L13-L15\nconst randomInteger = (minimum, maximum) => Math.floor((Math.random() * (maximum - minimum + 1)) + minimum);\n\nconst createAbortError = () => {\n\tconst error = new Error('Delay aborted');\n\terror.name = 'AbortError';\n\treturn error;\n};\n\nconst createDelay = ({clearTimeout: defaultClear, setTimeout: set, willResolve}) => (ms, {value, signal} = {}) => {\n\tif (signal && signal.aborted) {\n\t\treturn Promise.reject(createAbortError());\n\t}\n\n\tlet timeoutId;\n\tlet settle;\n\tlet rejectFn;\n\tconst clear = defaultClear || clearTimeout;\n\n\tconst signalListener = () => {\n\t\tclear(timeoutId);\n\t\trejectFn(createAbortError());\n\t};\n\n\tconst cleanup = () => {\n\t\tif (signal) {\n\t\t\tsignal.removeEventListener('abort', signalListener);\n\t\t}\n\t};\n\n\tconst delayPromise = new Promise((resolve, reject) => {\n\t\tsettle = () => {\n\t\t\tcleanup();\n\t\t\tif (willResolve) {\n\t\t\t\tresolve(value);\n\t\t\t} else {\n\t\t\t\treject(value);\n\t\t\t}\n\t\t};\n\n\t\trejectFn = reject;\n\t\ttimeoutId = (set || setTimeout)(settle, ms);\n\t});\n\n\tif (signal) {\n\t\tsignal.addEventListener('abort', signalListener, {once: true});\n\t}\n\n\tdelayPromise.clear = () => {\n\t\tclear(timeoutId);\n\t\ttimeoutId = null;\n\t\tsettle();\n\t};\n\n\treturn delayPromise;\n};\n\nconst createWithTimers = clearAndSet => {\n\tconst delay = createDelay({...clearAndSet, willResolve: true});\n\tdelay.reject = createDelay({...clearAndSet, willResolve: false});\n\tdelay.range = (minimum, maximum, options) => delay(randomInteger(minimum, maximum), options);\n\treturn delay;\n};\n\nconst delay = createWithTimers();\ndelay.createWithTimers = createWithTimers;\n\nmodule.exports = delay;\n// TODO: Remove this for the next major release\nmodule.exports.default = delay;\n","'use strict';\n\nvar platform = require('os').platform();\nvar spawnSync = require('child_process').spawnSync;\nvar readdirSync = require('fs').readdirSync;\n\nvar GLIBC = 'glibc';\nvar MUSL = 'musl';\n\nvar spawnOptions = {\n  encoding: 'utf8',\n  env: process.env\n};\n\nif (!spawnSync) {\n  spawnSync = function () {\n    return { status: 126, stdout: '', stderr: '' };\n  };\n}\n\nfunction contains (needle) {\n  return function (haystack) {\n    return haystack.indexOf(needle) !== -1;\n  };\n}\n\nfunction versionFromMuslLdd (out) {\n  return out.split(/[\\r\\n]+/)[1].trim().split(/\\s/)[1];\n}\n\nfunction safeReaddirSync (path) {\n  try {\n    return readdirSync(path);\n  } catch (e) {}\n  return [];\n}\n\nvar family = '';\nvar version = '';\nvar method = '';\n\nif (platform === 'linux') {\n  // Try getconf\n  var glibc = spawnSync('getconf', ['GNU_LIBC_VERSION'], spawnOptions);\n  if (glibc.status === 0) {\n    family = GLIBC;\n    version = glibc.stdout.trim().split(' ')[1];\n    method = 'getconf';\n  } else {\n    // Try ldd\n    var ldd = spawnSync('ldd', ['--version'], spawnOptions);\n    if (ldd.status === 0 && ldd.stdout.indexOf(MUSL) !== -1) {\n      family = MUSL;\n      version = versionFromMuslLdd(ldd.stdout);\n      method = 'ldd';\n    } else if (ldd.status === 1 && ldd.stderr.indexOf(MUSL) !== -1) {\n      family = MUSL;\n      version = versionFromMuslLdd(ldd.stderr);\n      method = 'ldd';\n    } else {\n      // Try filesystem (family only)\n      var lib = safeReaddirSync('/lib');\n      if (lib.some(contains('-linux-gnu'))) {\n        family = GLIBC;\n        method = 'filesystem';\n      } else if (lib.some(contains('libc.musl-'))) {\n        family = MUSL;\n        method = 'filesystem';\n      } else if (lib.some(contains('ld-musl-'))) {\n        family = MUSL;\n        method = 'filesystem';\n      } else {\n        var usrSbin = safeReaddirSync('/usr/sbin');\n        if (usrSbin.some(contains('glibc'))) {\n          family = GLIBC;\n          method = 'filesystem';\n        }\n      }\n    }\n  }\n}\n\nvar isNonGlibcLinux = (family !== '' && family !== GLIBC);\n\nmodule.exports = {\n  GLIBC: GLIBC,\n  MUSL: MUSL,\n  family: family,\n  version: version,\n  method: method,\n  isNonGlibcLinux: isNonGlibcLinux\n};\n","var EventEmitter = require('events').EventEmitter;\nvar fs = require('fs');\nvar path = require('path');\n\nmodule.exports = findit;\n\nfunction findit(basedir, opts) {\n  opts = opts || {};\n  var followSymlinks = !!opts.followSymlinks;\n  var myFs = opts.fs || fs;\n  var emitter = new EventEmitter();\n  var stopped = false;\n  var pending = 0;\n  var seen = {};\n\n  emitter.stop = stop;\n  walkPath(basedir);\n  return emitter;\n\n  function recursiveReadDir(basedir, linkPath) {\n    pendStart();\n    myFs.readdir(basedir, function(err, entries) {\n      if (stopped) return;\n      if (err) {\n        handleError(err, basedir);\n        pendEnd();\n        return;\n      }\n      entries.forEach(function(entry) {\n        var fullPath = path.join(basedir, entry);\n        var fullLinkPath = linkPath && path.join(linkPath, entry);\n        walkPath(fullPath, fullLinkPath);\n      });\n      pendEnd();\n    });\n  }\n\n  function walkPath(fullPath, linkPath) {\n    pendStart();\n    myFs.lstat(fullPath, function(err, stats) {\n      if (stopped) return;\n      if (err) {\n        handleError(err, fullPath);\n        pendEnd();\n        return;\n      }\n      emitter.emit('path', fullPath, stats, linkPath);\n      var dirStopped = false;\n      if (stats.isDirectory()) {\n        if (seen[fullPath]) {\n          err = new Error(\"file system loop detected\");\n          err.code = 'ELOOP';\n          handleError(err, fullPath);\n          pendEnd();\n          return;\n        }\n        seen[fullPath] = true;\n\n        emitter.emit('directory', fullPath, stats, stopDir, linkPath);\n        if (!dirStopped) recursiveReadDir(fullPath, linkPath);\n      } else if (stats.isFile()) {\n        if (!seen[fullPath]) {\n          seen[fullPath] = true;\n          emitter.emit('file', fullPath, stats, linkPath);\n        }\n      } else if (stats.isSymbolicLink()) {\n        emitter.emit('link', fullPath, stats, linkPath);\n        if (followSymlinks) recursiveReadLink(fullPath);\n      }\n      pendEnd();\n\n      function stopDir() {\n        dirStopped = true;\n      }\n    });\n  }\n\n  function recursiveReadLink(linkPath) {\n    pendStart();\n    myFs.readlink(linkPath, function(err, linkString) {\n      if (stopped) return;\n      if (err) {\n        handleError(err, linkPath);\n        pendEnd();\n        return;\n      }\n      var fullPath = path.resolve(path.dirname(linkPath), linkString);\n      emitter.emit('readlink', linkPath, fullPath);\n      walkPath(fullPath, linkPath);\n      pendEnd();\n    });\n  }\n\n  function stop() {\n    if (stopped) return;\n    stopped = true;\n    emitter.emit('stop');\n  }\n\n  function handleError(err, errPath) {\n    if (!err || stopped) return;\n    err.path = errPath;\n    emitter.emit('error', err);\n  }\n\n  function pendStart() {\n    pending += 1;\n  }\n\n  function pendEnd() {\n    if (stopped) return;\n    pending -= 1;\n    if (pending === 0) {\n      emitter.emit('end');\n    } else if (pending < 0) {\n      // this should never happen; if this gets thrown we need to debug findit\n      // and this stack trace will help.\n      throw new Error(\"pendEnd called too many times\");\n    }\n  }\n}\n","var CombinedStream = require('combined-stream');\nvar util = require('util');\nvar path = require('path');\nvar http = require('http');\nvar https = require('https');\nvar parseUrl = require('url').parse;\nvar fs = require('fs');\nvar mime = require('mime-types');\nvar asynckit = require('asynckit');\nvar populate = require('./populate.js');\n\n// Public API\nmodule.exports = FormData;\n\n// make it a Stream\nutil.inherits(FormData, CombinedStream);\n\n/**\n * Create readable \"multipart/form-data\" streams.\n * Can be used to submit forms\n * and file uploads to other web applications.\n *\n * @constructor\n * @param {Object} options - Properties to be added/overriden for FormData and CombinedStream\n */\nfunction FormData(options) {\n  if (!(this instanceof FormData)) {\n    return new FormData(options);\n  }\n\n  this._overheadLength = 0;\n  this._valueLength = 0;\n  this._valuesToMeasure = [];\n\n  CombinedStream.call(this);\n\n  options = options || {};\n  for (var option in options) {\n    this[option] = options[option];\n  }\n}\n\nFormData.LINE_BREAK = '\\r\\n';\nFormData.DEFAULT_CONTENT_TYPE = 'application/octet-stream';\n\nFormData.prototype.append = function(field, value, options) {\n\n  options = options || {};\n\n  // allow filename as single option\n  if (typeof options == 'string') {\n    options = {filename: options};\n  }\n\n  var append = CombinedStream.prototype.append.bind(this);\n\n  // all that streamy business can't handle numbers\n  if (typeof value == 'number') {\n    value = '' + value;\n  }\n\n  // https://github.com/felixge/node-form-data/issues/38\n  if (util.isArray(value)) {\n    // Please convert your array into string\n    // the way web server expects it\n    this._error(new Error('Arrays are not supported.'));\n    return;\n  }\n\n  var header = this._multiPartHeader(field, value, options);\n  var footer = this._multiPartFooter();\n\n  append(header);\n  append(value);\n  append(footer);\n\n  // pass along options.knownLength\n  this._trackLength(header, value, options);\n};\n\nFormData.prototype._trackLength = function(header, value, options) {\n  var valueLength = 0;\n\n  // used w/ getLengthSync(), when length is known.\n  // e.g. for streaming directly from a remote server,\n  // w/ a known file a size, and not wanting to wait for\n  // incoming file to finish to get its size.\n  if (options.knownLength != null) {\n    valueLength += +options.knownLength;\n  } else if (Buffer.isBuffer(value)) {\n    valueLength = value.length;\n  } else if (typeof value === 'string') {\n    valueLength = Buffer.byteLength(value);\n  }\n\n  this._valueLength += valueLength;\n\n  // @check why add CRLF? does this account for custom/multiple CRLFs?\n  this._overheadLength +=\n    Buffer.byteLength(header) +\n    FormData.LINE_BREAK.length;\n\n  // empty or either doesn't have path or not an http response\n  if (!value || ( !value.path && !(value.readable && value.hasOwnProperty('httpVersion')) )) {\n    return;\n  }\n\n  // no need to bother with the length\n  if (!options.knownLength) {\n    this._valuesToMeasure.push(value);\n  }\n};\n\nFormData.prototype._lengthRetriever = function(value, callback) {\n\n  if (value.hasOwnProperty('fd')) {\n\n    // take read range into a account\n    // `end` = Infinity > read file till the end\n    //\n    // TODO: Looks like there is bug in Node fs.createReadStream\n    // it doesn't respect `end` options without `start` options\n    // Fix it when node fixes it.\n    // https://github.com/joyent/node/issues/7819\n    if (value.end != undefined && value.end != Infinity && value.start != undefined) {\n\n      // when end specified\n      // no need to calculate range\n      // inclusive, starts with 0\n      callback(null, value.end + 1 - (value.start ? value.start : 0));\n\n    // not that fast snoopy\n    } else {\n      // still need to fetch file size from fs\n      fs.stat(value.path, function(err, stat) {\n\n        var fileSize;\n\n        if (err) {\n          callback(err);\n          return;\n        }\n\n        // update final size based on the range options\n        fileSize = stat.size - (value.start ? value.start : 0);\n        callback(null, fileSize);\n      });\n    }\n\n  // or http response\n  } else if (value.hasOwnProperty('httpVersion')) {\n    callback(null, +value.headers['content-length']);\n\n  // or request stream http://github.com/mikeal/request\n  } else if (value.hasOwnProperty('httpModule')) {\n    // wait till response come back\n    value.on('response', function(response) {\n      value.pause();\n      callback(null, +response.headers['content-length']);\n    });\n    value.resume();\n\n  // something else\n  } else {\n    callback('Unknown stream');\n  }\n};\n\nFormData.prototype._multiPartHeader = function(field, value, options) {\n  // custom header specified (as string)?\n  // it becomes responsible for boundary\n  // (e.g. to handle extra CRLFs on .NET servers)\n  if (typeof options.header == 'string') {\n    return options.header;\n  }\n\n  var contentDisposition = this._getContentDisposition(value, options);\n  var contentType = this._getContentType(value, options);\n\n  var contents = '';\n  var headers  = {\n    // add custom disposition as third element or keep it two elements if not\n    'Content-Disposition': ['form-data', 'name=\"' + field + '\"'].concat(contentDisposition || []),\n    // if no content type. allow it to be empty array\n    'Content-Type': [].concat(contentType || [])\n  };\n\n  // allow custom headers.\n  if (typeof options.header == 'object') {\n    populate(headers, options.header);\n  }\n\n  var header;\n  for (var prop in headers) {\n    if (!headers.hasOwnProperty(prop)) continue;\n    header = headers[prop];\n\n    // skip nullish headers.\n    if (header == null) {\n      continue;\n    }\n\n    // convert all headers to arrays.\n    if (!Array.isArray(header)) {\n      header = [header];\n    }\n\n    // add non-empty headers.\n    if (header.length) {\n      contents += prop + ': ' + header.join('; ') + FormData.LINE_BREAK;\n    }\n  }\n\n  return '--' + this.getBoundary() + FormData.LINE_BREAK + contents + FormData.LINE_BREAK;\n};\n\nFormData.prototype._getContentDisposition = function(value, options) {\n\n  var filename\n    , contentDisposition\n    ;\n\n  if (typeof options.filepath === 'string') {\n    // custom filepath for relative paths\n    filename = path.normalize(options.filepath).replace(/\\\\/g, '/');\n  } else if (options.filename || value.name || value.path) {\n    // custom filename take precedence\n    // formidable and the browser add a name property\n    // fs- and request- streams have path property\n    filename = path.basename(options.filename || value.name || value.path);\n  } else if (value.readable && value.hasOwnProperty('httpVersion')) {\n    // or try http response\n    filename = path.basename(value.client._httpMessage.path || '');\n  }\n\n  if (filename) {\n    contentDisposition = 'filename=\"' + filename + '\"';\n  }\n\n  return contentDisposition;\n};\n\nFormData.prototype._getContentType = function(value, options) {\n\n  // use custom content-type above all\n  var contentType = options.contentType;\n\n  // or try `name` from formidable, browser\n  if (!contentType && value.name) {\n    contentType = mime.lookup(value.name);\n  }\n\n  // or try `path` from fs-, request- streams\n  if (!contentType && value.path) {\n    contentType = mime.lookup(value.path);\n  }\n\n  // or if it's http-reponse\n  if (!contentType && value.readable && value.hasOwnProperty('httpVersion')) {\n    contentType = value.headers['content-type'];\n  }\n\n  // or guess it from the filepath or filename\n  if (!contentType && (options.filepath || options.filename)) {\n    contentType = mime.lookup(options.filepath || options.filename);\n  }\n\n  // fallback to the default content type if `value` is not simple value\n  if (!contentType && typeof value == 'object') {\n    contentType = FormData.DEFAULT_CONTENT_TYPE;\n  }\n\n  return contentType;\n};\n\nFormData.prototype._multiPartFooter = function() {\n  return function(next) {\n    var footer = FormData.LINE_BREAK;\n\n    var lastPart = (this._streams.length === 0);\n    if (lastPart) {\n      footer += this._lastBoundary();\n    }\n\n    next(footer);\n  }.bind(this);\n};\n\nFormData.prototype._lastBoundary = function() {\n  return '--' + this.getBoundary() + '--' + FormData.LINE_BREAK;\n};\n\nFormData.prototype.getHeaders = function(userHeaders) {\n  var header;\n  var formHeaders = {\n    'content-type': 'multipart/form-data; boundary=' + this.getBoundary()\n  };\n\n  for (header in userHeaders) {\n    if (userHeaders.hasOwnProperty(header)) {\n      formHeaders[header.toLowerCase()] = userHeaders[header];\n    }\n  }\n\n  return formHeaders;\n};\n\nFormData.prototype.setBoundary = function(boundary) {\n  this._boundary = boundary;\n};\n\nFormData.prototype.getBoundary = function() {\n  if (!this._boundary) {\n    this._generateBoundary();\n  }\n\n  return this._boundary;\n};\n\nFormData.prototype.getBuffer = function() {\n  var dataBuffer = new Buffer.alloc( 0 );\n  var boundary = this.getBoundary();\n\n  // Create the form content. Add Line breaks to the end of data.\n  for (var i = 0, len = this._streams.length; i < len; i++) {\n    if (typeof this._streams[i] !== 'function') {\n\n      // Add content to the buffer.\n      if(Buffer.isBuffer(this._streams[i])) {\n        dataBuffer = Buffer.concat( [dataBuffer, this._streams[i]]);\n      }else {\n        dataBuffer = Buffer.concat( [dataBuffer, Buffer.from(this._streams[i])]);\n      }\n\n      // Add break after content.\n      if (typeof this._streams[i] !== 'string' || this._streams[i].substring( 2, boundary.length + 2 ) !== boundary) {\n        dataBuffer = Buffer.concat( [dataBuffer, Buffer.from(FormData.LINE_BREAK)] );\n      }\n    }\n  }\n\n  // Add the footer and return the Buffer object.\n  return Buffer.concat( [dataBuffer, Buffer.from(this._lastBoundary())] );\n};\n\nFormData.prototype._generateBoundary = function() {\n  // This generates a 50 character boundary similar to those used by Firefox.\n  // They are optimized for boyer-moore parsing.\n  var boundary = '--------------------------';\n  for (var i = 0; i < 24; i++) {\n    boundary += Math.floor(Math.random() * 10).toString(16);\n  }\n\n  this._boundary = boundary;\n};\n\n// Note: getLengthSync DOESN'T calculate streams length\n// As workaround one can calculate file size manually\n// and add it as knownLength option\nFormData.prototype.getLengthSync = function() {\n  var knownLength = this._overheadLength + this._valueLength;\n\n  // Don't get confused, there are 3 \"internal\" streams for each keyval pair\n  // so it basically checks if there is any value added to the form\n  if (this._streams.length) {\n    knownLength += this._lastBoundary().length;\n  }\n\n  // https://github.com/form-data/form-data/issues/40\n  if (!this.hasKnownLength()) {\n    // Some async length retrievers are present\n    // therefore synchronous length calculation is false.\n    // Please use getLength(callback) to get proper length\n    this._error(new Error('Cannot calculate proper length in synchronous way.'));\n  }\n\n  return knownLength;\n};\n\n// Public API to check if length of added values is known\n// https://github.com/form-data/form-data/issues/196\n// https://github.com/form-data/form-data/issues/262\nFormData.prototype.hasKnownLength = function() {\n  var hasKnownLength = true;\n\n  if (this._valuesToMeasure.length) {\n    hasKnownLength = false;\n  }\n\n  return hasKnownLength;\n};\n\nFormData.prototype.getLength = function(cb) {\n  var knownLength = this._overheadLength + this._valueLength;\n\n  if (this._streams.length) {\n    knownLength += this._lastBoundary().length;\n  }\n\n  if (!this._valuesToMeasure.length) {\n    process.nextTick(cb.bind(this, null, knownLength));\n    return;\n  }\n\n  asynckit.parallel(this._valuesToMeasure, this._lengthRetriever, function(err, values) {\n    if (err) {\n      cb(err);\n      return;\n    }\n\n    values.forEach(function(length) {\n      knownLength += length;\n    });\n\n    cb(null, knownLength);\n  });\n};\n\nFormData.prototype.submit = function(params, cb) {\n  var request\n    , options\n    , defaults = {method: 'post'}\n    ;\n\n  // parse provided url if it's string\n  // or treat it as options object\n  if (typeof params == 'string') {\n\n    params = parseUrl(params);\n    options = populate({\n      port: params.port,\n      path: params.pathname,\n      host: params.hostname,\n      protocol: params.protocol\n    }, defaults);\n\n  // use custom params\n  } else {\n\n    options = populate(params, defaults);\n    // if no port provided use default one\n    if (!options.port) {\n      options.port = options.protocol == 'https:' ? 443 : 80;\n    }\n  }\n\n  // put that good code in getHeaders to some use\n  options.headers = this.getHeaders(params.headers);\n\n  // https if specified, fallback to http in any other case\n  if (options.protocol == 'https:') {\n    request = https.request(options);\n  } else {\n    request = http.request(options);\n  }\n\n  // get content length and fire away\n  this.getLength(function(err, length) {\n    if (err) {\n      this._error(err);\n      return;\n    }\n\n    // add content length\n    request.setHeader('Content-Length', length);\n\n    this.pipe(request);\n    if (cb) {\n      var onResponse;\n\n      var callback = function (error, responce) {\n        request.removeListener('error', callback);\n        request.removeListener('response', onResponse);\n\n        return cb.call(this, error, responce);\n      };\n\n      onResponse = callback.bind(this, null);\n\n      request.on('error', callback);\n      request.on('response', onResponse);\n    }\n  }.bind(this));\n\n  return request;\n};\n\nFormData.prototype._error = function(err) {\n  if (!this.error) {\n    this.error = err;\n    this.pause();\n    this.emit('error', err);\n  }\n};\n\nFormData.prototype.toString = function () {\n  return '[object FormData]';\n};\n","// Unless explicitly stated otherwise all files in this repository are licensed under the Apache 2.0 License.\n//\n// This product includes software developed at Datadog (https://www.datadoghq.com/). Copyright 2021 Datadog, Inc.\n\nconst path = require('path')\nconst parse = require('module-details-from-path')\nconst { fileURLToPath } = require('url')\n\nconst {\n  importHooks,\n  specifiers,\n  toHook\n} = require('./lib/register')\n\nfunction addHook(hook) {\n  importHooks.push(hook)\n  toHook.forEach(([name, namespace]) => hook(name, namespace))\n}\n\nfunction removeHook(hook) {\n  const index = importHooks.indexOf(hook)\n  if (index > -1) {\n    importHooks.splice(index, 1)\n  }\n}\n\nfunction callHookFn(hookFn, namespace, name, baseDir) {\n  const newDefault = hookFn(namespace, name, baseDir)\n  if (newDefault && newDefault !== namespace) {\n    namespace.default = newDefault\n  }\n}\n\nfunction Hook(modules, options, hookFn) {\n  if ((this instanceof Hook) === false) return new Hook(modules, options, hookFn)\n  if (typeof modules === 'function') {\n    hookFn = modules\n    modules = null\n    options = null\n  } else if (typeof options === 'function') {\n    hookFn = options\n    options = null\n  }\n  const internals = options ? options.internals === true : false\n\n  this._iitmHook = (name, namespace) => {\n    const filename = name\n    const isBuiltin = name.startsWith('node:')\n    let baseDir\n\n    if (isBuiltin) {\n      name = name.replace(/^node:/, '')\n    } else {\n      name = name.replace(/^file:\\/\\//, '')\n      const details = parse(name)\n      if (details) {\n        name = details.name\n        baseDir = details.basedir\n      }\n    }\n\n    if (modules) {\n      for (const moduleName of modules) {\n        if (moduleName === name) {\n          if (baseDir) {\n            if (internals) {\n              name = name + path.sep + path.relative(baseDir, fileURLToPath(filename))\n            } else {\n              if (!baseDir.endsWith(specifiers.get(filename))) continue\n            }\n          }\n          callHookFn(hookFn, namespace, name, baseDir)\n        }\n      }\n    } else {\n      callHookFn(hookFn, namespace, name, baseDir)\n    }\n  }\n\n  addHook(this._iitmHook)\n}\n\nHook.prototype.unhook = function () {\n  removeHook(this._iitmHook)\n}\n\nmodule.exports = Hook\nmodule.exports.addHook = addHook\nmodule.exports.removeHook = removeHook\n","// Unless explicitly stated otherwise all files in this repository are licensed under the Apache 2.0 License.\n//\n// This product includes software developed at Datadog (https://www.datadoghq.com/). Copyright 2021 Datadog, Inc.\n\n\nconst importHooks = [] // TODO should this be a Set?\nconst setters = new WeakMap()\nconst specifiers = new Map()\nconst toHook = []\n\nconst proxyHandler = {\n  set(target, name, value) {\n    return setters.get(target)[name](value)\n  },\n\n  defineProperty(target, property, descriptor) {\n    if ((!('value' in descriptor))) {\n      throw new Error('Getters/setters are not supported for exports property descriptors.')\n    }\n\n    return setters.get(target)[property](descriptor.value)\n  }\n}\n\nfunction register(name, namespace, set, specifier) {\n  specifiers.set(name, specifier)\n  setters.set(namespace, set)\n  const proxy = new Proxy(namespace, proxyHandler)\n  importHooks.forEach(hook => hook(name, proxy))\n  toHook.push([name, proxy])\n}\n\nexports.register = register\nexports.importHooks = importHooks\nexports.specifiers = specifiers\nexports.toHook = toHook\n","'use strict';\n\n/**\n * Coalesce function to find the first valid value.\n * A valid value is one that is not undefined, not null and not NaN (not a number).\n * If no values are valid, then the last argument is returned.\n *\n * ```js\n * console.log(koalas(undefined, null, NaN, 'a', 'b'));\n * //=> 'a'\n *\n * console.log(koalas(undefined, null, NaN, {a: 'b'}, 'b'));\n * //=> {a: 'b'}\n *\n * console.log(koalas(undefined, null, NaN, ['a', 'b', 'c'], {a: 'b'}, 'b'));\n * //=> ['a', 'b', 'c']\n *\n * console.log(koalas(undefined, NaN, null));\n * //=> null\n * ```\n * @name koalas\n * @param {Mixed} `arguments` Pass in any amount of arguments.\n * @return {Mixed} First valid value.\n * @api public\n */\n\nfunction koalas() {\n  var len = arguments.length;\n  var arg;\n  for (var i = 0; i < len; i++) {\n    arg = arguments[i];\n    if (hasValue(arg)) {\n      return arg;\n    }\n  }\n  return arg;\n}\n\n/**\n * Check to see if a value actually has a valid value:\n *  - not undefined\n *  - not null\n *  - not NaN (not a number)\n *\n * @param  {*} `val` value to check\n * @return {Boolean} returns `true` if the `val` has a valid value\n */\n\nfunction hasValue(val) {\n  // eslint-disable-next-line no-self-compare\n  return val != null && val === val;\n}\n\n/**\n * Expose koalas\n */\n\nmodule.exports = koalas;\n","\r\nexports.RateLimiter = require('./lib/rateLimiter');\r\nexports.TokenBucket = require('./lib/tokenBucket');\r\n","var getMilliseconds = function() {\r\n  if (typeof process !== 'undefined' && process.hrtime) {\r\n    var hrtime = process.hrtime();\r\n    var seconds = hrtime[0];\r\n    var nanoseconds = hrtime[1];\r\n\r\n    return seconds * 1e3 +  Math.floor(nanoseconds / 1e6);\r\n  }\r\n\r\n  return new Date().getTime();\r\n}\r\n\r\nmodule.exports = getMilliseconds;\r\n","var TokenBucket = require('./tokenBucket');\r\nvar getMilliseconds = require('./clock');\r\n\r\n/**\r\n * A generic rate limiter. Underneath the hood, this uses a token bucket plus\r\n * an additional check to limit how many tokens we can remove each interval.\r\n * @author John Hurliman <jhurliman@jhurliman.org>\r\n *\r\n * @param {Number} tokensPerInterval Maximum number of tokens that can be\r\n *  removed at any given moment and over the course of one interval.\r\n * @param {String|Number} interval The interval length in milliseconds, or as\r\n *  one of the following strings: 'second', 'minute', 'hour', day'.\r\n * @param {Boolean} fireImmediately Optional. Whether or not the callback\r\n *  will fire immediately when rate limiting is in effect (default is false).\r\n */\r\nvar RateLimiter = function(tokensPerInterval, interval, fireImmediately) {\r\n  this.tokenBucket = new TokenBucket(tokensPerInterval, tokensPerInterval,\r\n    interval, null);\r\n\r\n  // Fill the token bucket to start\r\n  this.tokenBucket.content = tokensPerInterval;\r\n\r\n  this.curIntervalStart = getMilliseconds();\r\n  this.tokensThisInterval = 0;\r\n  this.fireImmediately = fireImmediately;\r\n};\r\n\r\nRateLimiter.prototype = {\r\n  tokenBucket: null,\r\n  curIntervalStart: 0,\r\n  tokensThisInterval: 0,\r\n  fireImmediately: false,\r\n\r\n  /**\r\n   * Remove the requested number of tokens and fire the given callback. If the\r\n   * rate limiter contains enough tokens and we haven't spent too many tokens\r\n   * in this interval already, this will happen immediately. Otherwise, the\r\n   * removal and callback will happen when enough tokens become available.\r\n   * @param {Number} count The number of tokens to remove.\r\n   * @param {Function} callback(err, remainingTokens)\r\n   * @returns {Boolean} True if the callback was fired immediately, otherwise\r\n   *  false.\r\n   */\r\n  removeTokens: function(count, callback) {\r\n    // Make sure the request isn't for more than we can handle\r\n    if (count > this.tokenBucket.bucketSize) {\r\n      process.nextTick(callback.bind(null, 'Requested tokens ' + count +\r\n        ' exceeds maximum tokens per interval ' + this.tokenBucket.bucketSize,\r\n        null));\r\n      return false;\r\n    }\r\n\r\n    var self = this;\r\n    var now = getMilliseconds();\r\n\r\n    // Advance the current interval and reset the current interval token count\r\n    // if needed\r\n    if (now < this.curIntervalStart\r\n      || now - this.curIntervalStart >= this.tokenBucket.interval) {\r\n      this.curIntervalStart = now;\r\n      this.tokensThisInterval = 0;\r\n    }\r\n\r\n    // If we don't have enough tokens left in this interval, wait until the\r\n    // next interval\r\n    if (count > this.tokenBucket.tokensPerInterval - this.tokensThisInterval) {\r\n      if (this.fireImmediately) {\r\n        process.nextTick(callback.bind(null, null, -1));\r\n      } else {\r\n        var waitInterval = Math.ceil(\r\n          this.curIntervalStart + this.tokenBucket.interval - now);\r\n\r\n        setTimeout(function() {\r\n          self.tokenBucket.removeTokens(count, afterTokensRemoved);\r\n        }, waitInterval);\r\n      }\r\n      return false;\r\n    }\r\n\r\n    // Remove the requested number of tokens from the token bucket\r\n    return this.tokenBucket.removeTokens(count, afterTokensRemoved);\r\n\r\n    function afterTokensRemoved(err, tokensRemaining) {\r\n      if (err) return callback(err, null);\r\n\r\n      self.tokensThisInterval += count;\r\n      callback(null, tokensRemaining);\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Attempt to remove the requested number of tokens and return immediately.\r\n   * If the bucket (and any parent buckets) contains enough tokens and we\r\n   * haven't spent too many tokens in this interval already, this will return\r\n   * true. Otherwise, false is returned.\r\n   * @param {Number} count The number of tokens to remove.\r\n   * @param {Boolean} True if the tokens were successfully removed, otherwise\r\n   *  false.\r\n   */\r\n  tryRemoveTokens: function(count) {\r\n    // Make sure the request isn't for more than we can handle\r\n    if (count > this.tokenBucket.bucketSize)\r\n      return false;\r\n\r\n    var now = getMilliseconds();\r\n\r\n    // Advance the current interval and reset the current interval token count\r\n    // if needed\r\n    if (now < this.curIntervalStart\r\n      || now - this.curIntervalStart >= this.tokenBucket.interval) {\r\n      this.curIntervalStart = now;\r\n      this.tokensThisInterval = 0;\r\n    }\r\n\r\n    // If we don't have enough tokens left in this interval, return false\r\n    if (count > this.tokenBucket.tokensPerInterval - this.tokensThisInterval)\r\n      return false;\r\n\r\n    // Try to remove the requested number of tokens from the token bucket\r\n    var removed = this.tokenBucket.tryRemoveTokens(count);\r\n    if (removed) {\r\n      this.tokensThisInterval += count;\r\n    }\r\n    return removed;\r\n  },\r\n\r\n  /**\r\n   * Returns the number of tokens remaining in the TokenBucket.\r\n   * @returns {Number} The number of tokens remaining.\r\n   */\r\n  getTokensRemaining: function () {\r\n    this.tokenBucket.drip();\r\n    return this.tokenBucket.content;\r\n  }\r\n};\r\n\r\nmodule.exports = RateLimiter;\r\n","\r\n/**\r\n * A hierarchical token bucket for rate limiting. See\r\n * http://en.wikipedia.org/wiki/Token_bucket for more information.\r\n * @author John Hurliman <jhurliman@cull.tv>\r\n *\r\n * @param {Number} bucketSize Maximum number of tokens to hold in the bucket.\r\n *  Also known as the burst rate.\r\n * @param {Number} tokensPerInterval Number of tokens to drip into the bucket\r\n *  over the course of one interval.\r\n * @param {String|Number} interval The interval length in milliseconds, or as\r\n *  one of the following strings: 'second', 'minute', 'hour', day'.\r\n * @param {TokenBucket} parentBucket Optional. A token bucket that will act as\r\n *  the parent of this bucket.\r\n */\r\nvar TokenBucket = function(bucketSize, tokensPerInterval, interval, parentBucket) {\r\n  this.bucketSize = bucketSize;\r\n  this.tokensPerInterval = tokensPerInterval;\r\n\r\n  if (typeof interval === 'string') {\r\n    switch (interval) {\r\n      case 'sec': case 'second':\r\n        this.interval = 1000; break;\r\n      case 'min': case 'minute':\r\n        this.interval = 1000 * 60; break;\r\n      case 'hr': case 'hour':\r\n        this.interval = 1000 * 60 * 60; break;\r\n      case 'day':\r\n        this.interval = 1000 * 60 * 60 * 24; break;\r\n      default:\r\n        throw new Error('Invaid interval ' + interval);\r\n    }\r\n  } else {\r\n    this.interval = interval;\r\n  }\r\n\r\n  this.parentBucket = parentBucket;\r\n  this.content = 0;\r\n  this.lastDrip = +new Date();\r\n};\r\n\r\nTokenBucket.prototype = {\r\n  bucketSize: 1,\r\n  tokensPerInterval: 1,\r\n  interval: 1000,\r\n  parentBucket: null,\r\n  content: 0,\r\n  lastDrip: 0,\r\n\r\n  /**\r\n   * Remove the requested number of tokens and fire the given callback. If the\r\n   * bucket (and any parent buckets) contains enough tokens this will happen\r\n   * immediately. Otherwise, the removal and callback will happen when enough\r\n   * tokens become available.\r\n   * @param {Number} count The number of tokens to remove.\r\n   * @param {Function} callback(err, remainingTokens)\r\n   * @returns {Boolean} True if the callback was fired immediately, otherwise\r\n   *  false.\r\n   */\r\n  removeTokens: function(count, callback) {\r\n    var self = this;\r\n\r\n    // Is this an infinite size bucket?\r\n    if (!this.bucketSize) {\r\n      process.nextTick(callback.bind(null, null, count, Number.POSITIVE_INFINITY));\r\n      return true;\r\n    }\r\n\r\n    // Make sure the bucket can hold the requested number of tokens\r\n    if (count > this.bucketSize) {\r\n      process.nextTick(callback.bind(null, 'Requested tokens ' + count + ' exceeds bucket size ' +\r\n        this.bucketSize, null));\r\n      return false;\r\n    }\r\n\r\n    // Drip new tokens into this bucket\r\n    this.drip();\r\n\r\n    // If we don't have enough tokens in this bucket, come back later\r\n    if (count > this.content)\r\n      return comeBackLater();\r\n\r\n    if (this.parentBucket) {\r\n      // Remove the requested from the parent bucket first\r\n      return this.parentBucket.removeTokens(count, function(err, remainingTokens) {\r\n        if (err) return callback(err, null);\r\n\r\n        // Check that we still have enough tokens in this bucket\r\n        if (count > self.content)\r\n          return comeBackLater();\r\n\r\n        // Tokens were removed from the parent bucket, now remove them from\r\n        // this bucket and fire the callback. Note that we look at the current\r\n        // bucket and parent bucket's remaining tokens and return the smaller\r\n        // of the two values\r\n        self.content -= count;\r\n        callback(null, Math.min(remainingTokens, self.content));\r\n      });\r\n    } else {\r\n      // Remove the requested tokens from this bucket and fire the callback\r\n      this.content -= count;\r\n      process.nextTick(callback.bind(null, null, this.content));\r\n      return true;\r\n    }\r\n\r\n    function comeBackLater() {\r\n      // How long do we need to wait to make up the difference in tokens?\r\n      var waitInterval = Math.ceil(\r\n        (count - self.content) * (self.interval / self.tokensPerInterval));\r\n      setTimeout(function() { self.removeTokens(count, callback); }, waitInterval);\r\n      return false;\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Attempt to remove the requested number of tokens and return immediately.\r\n   * If the bucket (and any parent buckets) contains enough tokens this will\r\n   * return true, otherwise false is returned.\r\n   * @param {Number} count The number of tokens to remove.\r\n   * @param {Boolean} True if the tokens were successfully removed, otherwise\r\n   *  false.\r\n   */\r\n  tryRemoveTokens: function(count) {\r\n    // Is this an infinite size bucket?\r\n    if (!this.bucketSize)\r\n      return true;\r\n\r\n    // Make sure the bucket can hold the requested number of tokens\r\n    if (count > this.bucketSize)\r\n      return false;\r\n\r\n    // Drip new tokens into this bucket\r\n    this.drip();\r\n\r\n    // If we don't have enough tokens in this bucket, return false\r\n    if (count > this.content)\r\n      return false;\r\n\r\n    // Try to remove the requested tokens from the parent bucket\r\n    if (this.parentBucket && !this.parentBucket.tryRemoveTokens(count))\r\n      return false;\r\n\r\n    // Remove the requested tokens from this bucket and return\r\n    this.content -= count;\r\n    return true;\r\n  },\r\n\r\n  /**\r\n   * Add any new tokens to the bucket since the last drip.\r\n   * @returns {Boolean} True if new tokens were added, otherwise false.\r\n   */\r\n  drip: function() {\r\n    if (!this.tokensPerInterval) {\r\n      this.content = this.bucketSize;\r\n      return;\r\n    }\r\n\r\n    var now = +new Date();\r\n    var deltaMS = Math.max(now - this.lastDrip, 0);\r\n    this.lastDrip = now;\r\n\r\n    var dripAmount = deltaMS * (this.tokensPerInterval / this.interval);\r\n    this.content = Math.min(this.content + dripAmount, this.bucketSize);\r\n  }\r\n};\r\n\r\nmodule.exports = TokenBucket;\r\n","/**\n * lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/** `Object#toString` result references. */\nvar symbolTag = '[object Symbol]';\n\n/** Used to match words composed of alphanumeric characters. */\nvar reAsciiWord = /[^\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\x7f]+/g;\n\n/** Used to match Latin Unicode letters (excluding mathematical operators). */\nvar reLatin = /[\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\xff\\u0100-\\u017f]/g;\n\n/** Used to compose unicode character classes. */\nvar rsAstralRange = '\\\\ud800-\\\\udfff',\n    rsComboMarksRange = '\\\\u0300-\\\\u036f\\\\ufe20-\\\\ufe23',\n    rsComboSymbolsRange = '\\\\u20d0-\\\\u20f0',\n    rsDingbatRange = '\\\\u2700-\\\\u27bf',\n    rsLowerRange = 'a-z\\\\xdf-\\\\xf6\\\\xf8-\\\\xff',\n    rsMathOpRange = '\\\\xac\\\\xb1\\\\xd7\\\\xf7',\n    rsNonCharRange = '\\\\x00-\\\\x2f\\\\x3a-\\\\x40\\\\x5b-\\\\x60\\\\x7b-\\\\xbf',\n    rsPunctuationRange = '\\\\u2000-\\\\u206f',\n    rsSpaceRange = ' \\\\t\\\\x0b\\\\f\\\\xa0\\\\ufeff\\\\n\\\\r\\\\u2028\\\\u2029\\\\u1680\\\\u180e\\\\u2000\\\\u2001\\\\u2002\\\\u2003\\\\u2004\\\\u2005\\\\u2006\\\\u2007\\\\u2008\\\\u2009\\\\u200a\\\\u202f\\\\u205f\\\\u3000',\n    rsUpperRange = 'A-Z\\\\xc0-\\\\xd6\\\\xd8-\\\\xde',\n    rsVarRange = '\\\\ufe0e\\\\ufe0f',\n    rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;\n\n/** Used to compose unicode capture groups. */\nvar rsApos = \"['\\u2019]\",\n    rsBreak = '[' + rsBreakRange + ']',\n    rsCombo = '[' + rsComboMarksRange + rsComboSymbolsRange + ']',\n    rsDigits = '\\\\d+',\n    rsDingbat = '[' + rsDingbatRange + ']',\n    rsLower = '[' + rsLowerRange + ']',\n    rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']',\n    rsFitz = '\\\\ud83c[\\\\udffb-\\\\udfff]',\n    rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',\n    rsNonAstral = '[^' + rsAstralRange + ']',\n    rsRegional = '(?:\\\\ud83c[\\\\udde6-\\\\uddff]){2}',\n    rsSurrPair = '[\\\\ud800-\\\\udbff][\\\\udc00-\\\\udfff]',\n    rsUpper = '[' + rsUpperRange + ']',\n    rsZWJ = '\\\\u200d';\n\n/** Used to compose unicode regexes. */\nvar rsLowerMisc = '(?:' + rsLower + '|' + rsMisc + ')',\n    rsUpperMisc = '(?:' + rsUpper + '|' + rsMisc + ')',\n    rsOptLowerContr = '(?:' + rsApos + '(?:d|ll|m|re|s|t|ve))?',\n    rsOptUpperContr = '(?:' + rsApos + '(?:D|LL|M|RE|S|T|VE))?',\n    reOptMod = rsModifier + '?',\n    rsOptVar = '[' + rsVarRange + ']?',\n    rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',\n    rsSeq = rsOptVar + reOptMod + rsOptJoin,\n    rsEmoji = '(?:' + [rsDingbat, rsRegional, rsSurrPair].join('|') + ')' + rsSeq;\n\n/** Used to match apostrophes. */\nvar reApos = RegExp(rsApos, 'g');\n\n/**\n * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and\n * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).\n */\nvar reComboMark = RegExp(rsCombo, 'g');\n\n/** Used to match complex or compound words. */\nvar reUnicodeWord = RegExp([\n  rsUpper + '?' + rsLower + '+' + rsOptLowerContr + '(?=' + [rsBreak, rsUpper, '$'].join('|') + ')',\n  rsUpperMisc + '+' + rsOptUpperContr + '(?=' + [rsBreak, rsUpper + rsLowerMisc, '$'].join('|') + ')',\n  rsUpper + '?' + rsLowerMisc + '+' + rsOptLowerContr,\n  rsUpper + '+' + rsOptUpperContr,\n  rsDigits,\n  rsEmoji\n].join('|'), 'g');\n\n/** Used to detect strings that need a more robust regexp to match words. */\nvar reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2,}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;\n\n/** Used to map Latin Unicode letters to basic Latin letters. */\nvar deburredLetters = {\n  // Latin-1 Supplement block.\n  '\\xc0': 'A',  '\\xc1': 'A', '\\xc2': 'A', '\\xc3': 'A', '\\xc4': 'A', '\\xc5': 'A',\n  '\\xe0': 'a',  '\\xe1': 'a', '\\xe2': 'a', '\\xe3': 'a', '\\xe4': 'a', '\\xe5': 'a',\n  '\\xc7': 'C',  '\\xe7': 'c',\n  '\\xd0': 'D',  '\\xf0': 'd',\n  '\\xc8': 'E',  '\\xc9': 'E', '\\xca': 'E', '\\xcb': 'E',\n  '\\xe8': 'e',  '\\xe9': 'e', '\\xea': 'e', '\\xeb': 'e',\n  '\\xcc': 'I',  '\\xcd': 'I', '\\xce': 'I', '\\xcf': 'I',\n  '\\xec': 'i',  '\\xed': 'i', '\\xee': 'i', '\\xef': 'i',\n  '\\xd1': 'N',  '\\xf1': 'n',\n  '\\xd2': 'O',  '\\xd3': 'O', '\\xd4': 'O', '\\xd5': 'O', '\\xd6': 'O', '\\xd8': 'O',\n  '\\xf2': 'o',  '\\xf3': 'o', '\\xf4': 'o', '\\xf5': 'o', '\\xf6': 'o', '\\xf8': 'o',\n  '\\xd9': 'U',  '\\xda': 'U', '\\xdb': 'U', '\\xdc': 'U',\n  '\\xf9': 'u',  '\\xfa': 'u', '\\xfb': 'u', '\\xfc': 'u',\n  '\\xdd': 'Y',  '\\xfd': 'y', '\\xff': 'y',\n  '\\xc6': 'Ae', '\\xe6': 'ae',\n  '\\xde': 'Th', '\\xfe': 'th',\n  '\\xdf': 'ss',\n  // Latin Extended-A block.\n  '\\u0100': 'A',  '\\u0102': 'A', '\\u0104': 'A',\n  '\\u0101': 'a',  '\\u0103': 'a', '\\u0105': 'a',\n  '\\u0106': 'C',  '\\u0108': 'C', '\\u010a': 'C', '\\u010c': 'C',\n  '\\u0107': 'c',  '\\u0109': 'c', '\\u010b': 'c', '\\u010d': 'c',\n  '\\u010e': 'D',  '\\u0110': 'D', '\\u010f': 'd', '\\u0111': 'd',\n  '\\u0112': 'E',  '\\u0114': 'E', '\\u0116': 'E', '\\u0118': 'E', '\\u011a': 'E',\n  '\\u0113': 'e',  '\\u0115': 'e', '\\u0117': 'e', '\\u0119': 'e', '\\u011b': 'e',\n  '\\u011c': 'G',  '\\u011e': 'G', '\\u0120': 'G', '\\u0122': 'G',\n  '\\u011d': 'g',  '\\u011f': 'g', '\\u0121': 'g', '\\u0123': 'g',\n  '\\u0124': 'H',  '\\u0126': 'H', '\\u0125': 'h', '\\u0127': 'h',\n  '\\u0128': 'I',  '\\u012a': 'I', '\\u012c': 'I', '\\u012e': 'I', '\\u0130': 'I',\n  '\\u0129': 'i',  '\\u012b': 'i', '\\u012d': 'i', '\\u012f': 'i', '\\u0131': 'i',\n  '\\u0134': 'J',  '\\u0135': 'j',\n  '\\u0136': 'K',  '\\u0137': 'k', '\\u0138': 'k',\n  '\\u0139': 'L',  '\\u013b': 'L', '\\u013d': 'L', '\\u013f': 'L', '\\u0141': 'L',\n  '\\u013a': 'l',  '\\u013c': 'l', '\\u013e': 'l', '\\u0140': 'l', '\\u0142': 'l',\n  '\\u0143': 'N',  '\\u0145': 'N', '\\u0147': 'N', '\\u014a': 'N',\n  '\\u0144': 'n',  '\\u0146': 'n', '\\u0148': 'n', '\\u014b': 'n',\n  '\\u014c': 'O',  '\\u014e': 'O', '\\u0150': 'O',\n  '\\u014d': 'o',  '\\u014f': 'o', '\\u0151': 'o',\n  '\\u0154': 'R',  '\\u0156': 'R', '\\u0158': 'R',\n  '\\u0155': 'r',  '\\u0157': 'r', '\\u0159': 'r',\n  '\\u015a': 'S',  '\\u015c': 'S', '\\u015e': 'S', '\\u0160': 'S',\n  '\\u015b': 's',  '\\u015d': 's', '\\u015f': 's', '\\u0161': 's',\n  '\\u0162': 'T',  '\\u0164': 'T', '\\u0166': 'T',\n  '\\u0163': 't',  '\\u0165': 't', '\\u0167': 't',\n  '\\u0168': 'U',  '\\u016a': 'U', '\\u016c': 'U', '\\u016e': 'U', '\\u0170': 'U', '\\u0172': 'U',\n  '\\u0169': 'u',  '\\u016b': 'u', '\\u016d': 'u', '\\u016f': 'u', '\\u0171': 'u', '\\u0173': 'u',\n  '\\u0174': 'W',  '\\u0175': 'w',\n  '\\u0176': 'Y',  '\\u0177': 'y', '\\u0178': 'Y',\n  '\\u0179': 'Z',  '\\u017b': 'Z', '\\u017d': 'Z',\n  '\\u017a': 'z',  '\\u017c': 'z', '\\u017e': 'z',\n  '\\u0132': 'IJ', '\\u0133': 'ij',\n  '\\u0152': 'Oe', '\\u0153': 'oe',\n  '\\u0149': \"'n\", '\\u017f': 'ss'\n};\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/**\n * A specialized version of `_.reduce` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @param {*} [accumulator] The initial value.\n * @param {boolean} [initAccum] Specify using the first element of `array` as\n *  the initial value.\n * @returns {*} Returns the accumulated value.\n */\nfunction arrayReduce(array, iteratee, accumulator, initAccum) {\n  var index = -1,\n      length = array ? array.length : 0;\n\n  if (initAccum && length) {\n    accumulator = array[++index];\n  }\n  while (++index < length) {\n    accumulator = iteratee(accumulator, array[index], index, array);\n  }\n  return accumulator;\n}\n\n/**\n * Splits an ASCII `string` into an array of its words.\n *\n * @private\n * @param {string} The string to inspect.\n * @returns {Array} Returns the words of `string`.\n */\nfunction asciiWords(string) {\n  return string.match(reAsciiWord) || [];\n}\n\n/**\n * The base implementation of `_.propertyOf` without support for deep paths.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Function} Returns the new accessor function.\n */\nfunction basePropertyOf(object) {\n  return function(key) {\n    return object == null ? undefined : object[key];\n  };\n}\n\n/**\n * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A\n * letters to basic Latin letters.\n *\n * @private\n * @param {string} letter The matched letter to deburr.\n * @returns {string} Returns the deburred letter.\n */\nvar deburrLetter = basePropertyOf(deburredLetters);\n\n/**\n * Checks if `string` contains a word composed of Unicode symbols.\n *\n * @private\n * @param {string} string The string to inspect.\n * @returns {boolean} Returns `true` if a word is found, else `false`.\n */\nfunction hasUnicodeWord(string) {\n  return reHasUnicodeWord.test(string);\n}\n\n/**\n * Splits a Unicode `string` into an array of its words.\n *\n * @private\n * @param {string} The string to inspect.\n * @returns {Array} Returns the words of `string`.\n */\nfunction unicodeWords(string) {\n  return string.match(reUnicodeWord) || [];\n}\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objectToString = objectProto.toString;\n\n/** Built-in value references. */\nvar Symbol = root.Symbol;\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolToString = symbolProto ? symbolProto.toString : undefined;\n\n/**\n * The base implementation of `_.toString` which doesn't convert nullish\n * values to empty strings.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n */\nfunction baseToString(value) {\n  // Exit early for strings to avoid a performance hit in some environments.\n  if (typeof value == 'string') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return symbolToString ? symbolToString.call(value) : '';\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\n/**\n * Creates a function like `_.camelCase`.\n *\n * @private\n * @param {Function} callback The function to combine each word.\n * @returns {Function} Returns the new compounder function.\n */\nfunction createCompounder(callback) {\n  return function(string) {\n    return arrayReduce(words(deburr(string).replace(reApos, '')), callback, '');\n  };\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && objectToString.call(value) == symbolTag);\n}\n\n/**\n * Converts `value` to a string. An empty string is returned for `null`\n * and `undefined` values. The sign of `-0` is preserved.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n * @example\n *\n * _.toString(null);\n * // => ''\n *\n * _.toString(-0);\n * // => '-0'\n *\n * _.toString([1, 2, 3]);\n * // => '1,2,3'\n */\nfunction toString(value) {\n  return value == null ? '' : baseToString(value);\n}\n\n/**\n * Deburrs `string` by converting\n * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)\n * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)\n * letters to basic Latin letters and removing\n * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category String\n * @param {string} [string=''] The string to deburr.\n * @returns {string} Returns the deburred string.\n * @example\n *\n * _.deburr('dj vu');\n * // => 'deja vu'\n */\nfunction deburr(string) {\n  string = toString(string);\n  return string && string.replace(reLatin, deburrLetter).replace(reComboMark, '');\n}\n\n/**\n * Converts `string` to\n * [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category String\n * @param {string} [string=''] The string to convert.\n * @returns {string} Returns the kebab cased string.\n * @example\n *\n * _.kebabCase('Foo Bar');\n * // => 'foo-bar'\n *\n * _.kebabCase('fooBar');\n * // => 'foo-bar'\n *\n * _.kebabCase('__FOO_BAR__');\n * // => 'foo-bar'\n */\nvar kebabCase = createCompounder(function(result, word, index) {\n  return result + (index ? '-' : '') + word.toLowerCase();\n});\n\n/**\n * Splits `string` into an array of its words.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category String\n * @param {string} [string=''] The string to inspect.\n * @param {RegExp|string} [pattern] The pattern to match words.\n * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n * @returns {Array} Returns the words of `string`.\n * @example\n *\n * _.words('fred, barney, & pebbles');\n * // => ['fred', 'barney', 'pebbles']\n *\n * _.words('fred, barney, & pebbles', /[^, ]+/g);\n * // => ['fred', 'barney', '&', 'pebbles']\n */\nfunction words(string, pattern, guard) {\n  string = toString(string);\n  pattern = guard ? undefined : pattern;\n\n  if (pattern === undefined) {\n    return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);\n  }\n  return string.match(pattern) || [];\n}\n\nmodule.exports = kebabCase;\n","/**\n * lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0,\n    MAX_SAFE_INTEGER = 9007199254740991;\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    symbolTag = '[object Symbol]';\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/**\n * A faster alternative to `Function#apply`, this function invokes `func`\n * with the `this` binding of `thisArg` and the arguments of `args`.\n *\n * @private\n * @param {Function} func The function to invoke.\n * @param {*} thisArg The `this` binding of `func`.\n * @param {Array} args The arguments to invoke `func` with.\n * @returns {*} Returns the result of `func`.\n */\nfunction apply(func, thisArg, args) {\n  switch (args.length) {\n    case 0: return func.call(thisArg);\n    case 1: return func.call(thisArg, args[0]);\n    case 2: return func.call(thisArg, args[0], args[1]);\n    case 3: return func.call(thisArg, args[0], args[1], args[2]);\n  }\n  return func.apply(thisArg, args);\n}\n\n/**\n * A specialized version of `_.map` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n */\nfunction arrayMap(array, iteratee) {\n  var index = -1,\n      length = array ? array.length : 0,\n      result = Array(length);\n\n  while (++index < length) {\n    result[index] = iteratee(array[index], index, array);\n  }\n  return result;\n}\n\n/**\n * Appends the elements of `values` to `array`.\n *\n * @private\n * @param {Array} array The array to modify.\n * @param {Array} values The values to append.\n * @returns {Array} Returns `array`.\n */\nfunction arrayPush(array, values) {\n  var index = -1,\n      length = values.length,\n      offset = array.length;\n\n  while (++index < length) {\n    array[offset + index] = values[index];\n  }\n  return array;\n}\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objectToString = objectProto.toString;\n\n/** Built-in value references. */\nvar Symbol = root.Symbol,\n    propertyIsEnumerable = objectProto.propertyIsEnumerable,\n    spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max;\n\n/**\n * The base implementation of `_.flatten` with support for restricting flattening.\n *\n * @private\n * @param {Array} array The array to flatten.\n * @param {number} depth The maximum recursion depth.\n * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.\n * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.\n * @param {Array} [result=[]] The initial result value.\n * @returns {Array} Returns the new flattened array.\n */\nfunction baseFlatten(array, depth, predicate, isStrict, result) {\n  var index = -1,\n      length = array.length;\n\n  predicate || (predicate = isFlattenable);\n  result || (result = []);\n\n  while (++index < length) {\n    var value = array[index];\n    if (depth > 0 && predicate(value)) {\n      if (depth > 1) {\n        // Recursively flatten arrays (susceptible to call stack limits).\n        baseFlatten(value, depth - 1, predicate, isStrict, result);\n      } else {\n        arrayPush(result, value);\n      }\n    } else if (!isStrict) {\n      result[result.length] = value;\n    }\n  }\n  return result;\n}\n\n/**\n * The base implementation of `_.pick` without support for individual\n * property identifiers.\n *\n * @private\n * @param {Object} object The source object.\n * @param {string[]} props The property identifiers to pick.\n * @returns {Object} Returns the new object.\n */\nfunction basePick(object, props) {\n  object = Object(object);\n  return basePickBy(object, props, function(value, key) {\n    return key in object;\n  });\n}\n\n/**\n * The base implementation of  `_.pickBy` without support for iteratee shorthands.\n *\n * @private\n * @param {Object} object The source object.\n * @param {string[]} props The property identifiers to pick from.\n * @param {Function} predicate The function invoked per property.\n * @returns {Object} Returns the new object.\n */\nfunction basePickBy(object, props, predicate) {\n  var index = -1,\n      length = props.length,\n      result = {};\n\n  while (++index < length) {\n    var key = props[index],\n        value = object[key];\n\n    if (predicate(value, key)) {\n      result[key] = value;\n    }\n  }\n  return result;\n}\n\n/**\n * The base implementation of `_.rest` which doesn't validate or coerce arguments.\n *\n * @private\n * @param {Function} func The function to apply a rest parameter to.\n * @param {number} [start=func.length-1] The start position of the rest parameter.\n * @returns {Function} Returns the new function.\n */\nfunction baseRest(func, start) {\n  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);\n  return function() {\n    var args = arguments,\n        index = -1,\n        length = nativeMax(args.length - start, 0),\n        array = Array(length);\n\n    while (++index < length) {\n      array[index] = args[start + index];\n    }\n    index = -1;\n    var otherArgs = Array(start + 1);\n    while (++index < start) {\n      otherArgs[index] = args[index];\n    }\n    otherArgs[start] = array;\n    return apply(func, this, otherArgs);\n  };\n}\n\n/**\n * Checks if `value` is a flattenable `arguments` object or array.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.\n */\nfunction isFlattenable(value) {\n  return isArray(value) || isArguments(value) ||\n    !!(spreadableSymbol && value && value[spreadableSymbol]);\n}\n\n/**\n * Converts `value` to a string key if it's not a string or symbol.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {string|symbol} Returns the key.\n */\nfunction toKey(value) {\n  if (typeof value == 'string' || isSymbol(value)) {\n    return value;\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\n/**\n * Checks if `value` is likely an `arguments` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n *  else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */\nfunction isArguments(value) {\n  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.\n  return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') &&\n    (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);\n}\n\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\n/**\n * Checks if `value` is array-like. A value is considered array-like if it's\n * not a function and has a `value.length` that's an integer greater than or\n * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n * @example\n *\n * _.isArrayLike([1, 2, 3]);\n * // => true\n *\n * _.isArrayLike(document.body.children);\n * // => true\n *\n * _.isArrayLike('abc');\n * // => true\n *\n * _.isArrayLike(_.noop);\n * // => false\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(value.length) && !isFunction(value);\n}\n\n/**\n * This method is like `_.isArrayLike` except that it also checks if `value`\n * is an object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array-like object,\n *  else `false`.\n * @example\n *\n * _.isArrayLikeObject([1, 2, 3]);\n * // => true\n *\n * _.isArrayLikeObject(document.body.children);\n * // => true\n *\n * _.isArrayLikeObject('abc');\n * // => false\n *\n * _.isArrayLikeObject(_.noop);\n * // => false\n */\nfunction isArrayLikeObject(value) {\n  return isObjectLike(value) && isArrayLike(value);\n}\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 8-9 which returns 'object' for typed array and other constructors.\n  var tag = isObject(value) ? objectToString.call(value) : '';\n  return tag == funcTag || tag == genTag;\n}\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This method is loosely based on\n * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3);\n * // => true\n *\n * _.isLength(Number.MIN_VALUE);\n * // => false\n *\n * _.isLength(Infinity);\n * // => false\n *\n * _.isLength('3');\n * // => false\n */\nfunction isLength(value) {\n  return typeof value == 'number' &&\n    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return !!value && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && objectToString.call(value) == symbolTag);\n}\n\n/**\n * Creates an object composed of the picked `object` properties.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The source object.\n * @param {...(string|string[])} [props] The property identifiers to pick.\n * @returns {Object} Returns the new object.\n * @example\n *\n * var object = { 'a': 1, 'b': '2', 'c': 3 };\n *\n * _.pick(object, ['a', 'c']);\n * // => { 'a': 1, 'c': 3 }\n */\nvar pick = baseRest(function(object, props) {\n  return object == null ? {} : basePick(object, arrayMap(baseFlatten(props, 1), toKey));\n});\n\nmodule.exports = pick;\n","/**\n * lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as the size to enable large array optimizations. */\nvar LARGE_ARRAY_SIZE = 200;\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/** `Object#toString` result references. */\nvar funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]';\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/**\n * A specialized version of `_.includes` for arrays without support for\n * specifying an index to search from.\n *\n * @private\n * @param {Array} [array] The array to inspect.\n * @param {*} target The value to search for.\n * @returns {boolean} Returns `true` if `target` is found, else `false`.\n */\nfunction arrayIncludes(array, value) {\n  var length = array ? array.length : 0;\n  return !!length && baseIndexOf(array, value, 0) > -1;\n}\n\n/**\n * This function is like `arrayIncludes` except that it accepts a comparator.\n *\n * @private\n * @param {Array} [array] The array to inspect.\n * @param {*} target The value to search for.\n * @param {Function} comparator The comparator invoked per element.\n * @returns {boolean} Returns `true` if `target` is found, else `false`.\n */\nfunction arrayIncludesWith(array, value, comparator) {\n  var index = -1,\n      length = array ? array.length : 0;\n\n  while (++index < length) {\n    if (comparator(value, array[index])) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * The base implementation of `_.findIndex` and `_.findLastIndex` without\n * support for iteratee shorthands.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {Function} predicate The function invoked per iteration.\n * @param {number} fromIndex The index to search from.\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction baseFindIndex(array, predicate, fromIndex, fromRight) {\n  var length = array.length,\n      index = fromIndex + (fromRight ? 1 : -1);\n\n  while ((fromRight ? index-- : ++index < length)) {\n    if (predicate(array[index], index, array)) {\n      return index;\n    }\n  }\n  return -1;\n}\n\n/**\n * The base implementation of `_.indexOf` without `fromIndex` bounds checks.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} value The value to search for.\n * @param {number} fromIndex The index to search from.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction baseIndexOf(array, value, fromIndex) {\n  if (value !== value) {\n    return baseFindIndex(array, baseIsNaN, fromIndex);\n  }\n  var index = fromIndex - 1,\n      length = array.length;\n\n  while (++index < length) {\n    if (array[index] === value) {\n      return index;\n    }\n  }\n  return -1;\n}\n\n/**\n * The base implementation of `_.isNaN` without support for number objects.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.\n */\nfunction baseIsNaN(value) {\n  return value !== value;\n}\n\n/**\n * Checks if a cache value for `key` exists.\n *\n * @private\n * @param {Object} cache The cache to query.\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction cacheHas(cache, key) {\n  return cache.has(key);\n}\n\n/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\n/**\n * Checks if `value` is a host object in IE < 9.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a host object, else `false`.\n */\nfunction isHostObject(value) {\n  // Many host objects are `Object` objects that can coerce to strings\n  // despite having improperly defined `toString` methods.\n  var result = false;\n  if (value != null && typeof value.toString != 'function') {\n    try {\n      result = !!(value + '');\n    } catch (e) {}\n  }\n  return result;\n}\n\n/**\n * Converts `set` to an array of its values.\n *\n * @private\n * @param {Object} set The set to convert.\n * @returns {Array} Returns the values.\n */\nfunction setToArray(set) {\n  var index = -1,\n      result = Array(set.size);\n\n  set.forEach(function(value) {\n    result[++index] = value;\n  });\n  return result;\n}\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype,\n    funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objectToString = objectProto.toString;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/** Built-in value references. */\nvar splice = arrayProto.splice;\n\n/* Built-in method references that are verified to be native. */\nvar Map = getNative(root, 'Map'),\n    Set = getNative(root, 'Set'),\n    nativeCreate = getNative(Object, 'create');\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n}\n\n/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  return this.has(key) && delete this.__data__[key];\n}\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\n}\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);\n}\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n  return this;\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = hashClear;\nHash.prototype['delete'] = hashDelete;\nHash.prototype.get = hashGet;\nHash.prototype.has = hashHas;\nHash.prototype.set = hashSet;\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n}\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  return true;\n}\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return assocIndexOf(this.__data__, key) > -1;\n}\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = listCacheClear;\nListCache.prototype['delete'] = listCacheDelete;\nListCache.prototype.get = listCacheGet;\nListCache.prototype.has = listCacheHas;\nListCache.prototype.set = listCacheSet;\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.__data__ = {\n    'hash': new Hash,\n    'map': new (Map || ListCache),\n    'string': new Hash\n  };\n}\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  return getMapData(this, key)['delete'](key);\n}\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return getMapData(this, key).get(key);\n}\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return getMapData(this, key).has(key);\n}\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  getMapData(this, key).set(key, value);\n  return this;\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = mapCacheClear;\nMapCache.prototype['delete'] = mapCacheDelete;\nMapCache.prototype.get = mapCacheGet;\nMapCache.prototype.has = mapCacheHas;\nMapCache.prototype.set = mapCacheSet;\n\n/**\n *\n * Creates an array cache object to store unique values.\n *\n * @private\n * @constructor\n * @param {Array} [values] The values to cache.\n */\nfunction SetCache(values) {\n  var index = -1,\n      length = values ? values.length : 0;\n\n  this.__data__ = new MapCache;\n  while (++index < length) {\n    this.add(values[index]);\n  }\n}\n\n/**\n * Adds `value` to the array cache.\n *\n * @private\n * @name add\n * @memberOf SetCache\n * @alias push\n * @param {*} value The value to cache.\n * @returns {Object} Returns the cache instance.\n */\nfunction setCacheAdd(value) {\n  this.__data__.set(value, HASH_UNDEFINED);\n  return this;\n}\n\n/**\n * Checks if `value` is in the array cache.\n *\n * @private\n * @name has\n * @memberOf SetCache\n * @param {*} value The value to search for.\n * @returns {number} Returns `true` if `value` is found, else `false`.\n */\nfunction setCacheHas(value) {\n  return this.__data__.has(value);\n}\n\n// Add methods to `SetCache`.\nSetCache.prototype.add = SetCache.prototype.push = setCacheAdd;\nSetCache.prototype.has = setCacheHas;\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\n/**\n * The base implementation of `_.uniqBy` without support for iteratee shorthands.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {Function} [iteratee] The iteratee invoked per element.\n * @param {Function} [comparator] The comparator invoked per element.\n * @returns {Array} Returns the new duplicate free array.\n */\nfunction baseUniq(array, iteratee, comparator) {\n  var index = -1,\n      includes = arrayIncludes,\n      length = array.length,\n      isCommon = true,\n      result = [],\n      seen = result;\n\n  if (comparator) {\n    isCommon = false;\n    includes = arrayIncludesWith;\n  }\n  else if (length >= LARGE_ARRAY_SIZE) {\n    var set = iteratee ? null : createSet(array);\n    if (set) {\n      return setToArray(set);\n    }\n    isCommon = false;\n    includes = cacheHas;\n    seen = new SetCache;\n  }\n  else {\n    seen = iteratee ? [] : result;\n  }\n  outer:\n  while (++index < length) {\n    var value = array[index],\n        computed = iteratee ? iteratee(value) : value;\n\n    value = (comparator || value !== 0) ? value : 0;\n    if (isCommon && computed === computed) {\n      var seenIndex = seen.length;\n      while (seenIndex--) {\n        if (seen[seenIndex] === computed) {\n          continue outer;\n        }\n      }\n      if (iteratee) {\n        seen.push(computed);\n      }\n      result.push(value);\n    }\n    else if (!includes(seen, computed, comparator)) {\n      if (seen !== result) {\n        seen.push(computed);\n      }\n      result.push(value);\n    }\n  }\n  return result;\n}\n\n/**\n * Creates a set object of `values`.\n *\n * @private\n * @param {Array} values The values to add to the set.\n * @returns {Object} Returns the new set.\n */\nvar createSet = !(Set && (1 / setToArray(new Set([,-0]))[1]) == INFINITY) ? noop : function(values) {\n  return new Set(values);\n};\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return isKeyable(key)\n    ? data[typeof key == 'string' ? 'string' : 'hash']\n    : data.map;\n}\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\n/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value;\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n    ? (value !== '__proto__')\n    : (value === null);\n}\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to process.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\n/**\n * Creates a duplicate-free version of an array, using\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * for equality comparisons, in which only the first occurrence of each\n * element is kept.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Array\n * @param {Array} array The array to inspect.\n * @returns {Array} Returns the new duplicate free array.\n * @example\n *\n * _.uniq([2, 1, 2]);\n * // => [2, 1]\n */\nfunction uniq(array) {\n  return (array && array.length)\n    ? baseUniq(array)\n    : [];\n}\n\n/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 8-9 which returns 'object' for typed array and other constructors.\n  var tag = isObject(value) ? objectToString.call(value) : '';\n  return tag == funcTag || tag == genTag;\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return !!value && (type == 'object' || type == 'function');\n}\n\n/**\n * This method returns `undefined`.\n *\n * @static\n * @memberOf _\n * @since 2.3.0\n * @category Util\n * @example\n *\n * _.times(2, _.noop);\n * // => [undefined, undefined]\n */\nfunction noop() {\n  // No operation performed.\n}\n\nmodule.exports = uniq;\n","'use strict'\n\nvar path = require('path')\n\nmodule.exports = function (file) {\n  var segments = file.split(path.sep)\n  var index = segments.lastIndexOf('node_modules')\n  if (index === -1) return\n  if (!segments[index + 1]) return\n  var scoped = segments[index + 1][0] === '@'\n  var name = scoped ? segments[index + 1] + '/' + segments[index + 2] : segments[index + 1]\n  var offset = scoped ? 3 : 2\n  return {\n    name: name,\n    basedir: segments.slice(0, index + offset).join(path.sep),\n    path: segments.slice(index + offset).join(path.sep)\n  }\n}\n","var fs = require('fs')\nvar path = require('path')\nvar os = require('os')\n\n// Workaround to fix webpack's build warnings: 'the request of a dependency is an expression'\nvar runtimeRequire = typeof __webpack_require__ === 'function' ? __non_webpack_require__ : require // eslint-disable-line\n\nvar prebuildsOnly = !!process.env.PREBUILDS_ONLY\nvar abi = process.versions.modules // TODO: support old node where this is undef\nvar runtime = isElectron() ? 'electron' : 'node'\nvar arch = os.arch()\nvar platform = os.platform()\nvar libc = process.env.LIBC || (isAlpine(platform) ? 'musl' : 'glibc')\nvar armv = process.env.ARM_VERSION || (arch === 'arm64' ? '8' : process.config.variables.arm_version) || ''\n\nmodule.exports = load\n\nfunction load (dir) {\n  return runtimeRequire(load.path(dir))\n}\n\nload.path = function (dir) {\n  dir = path.resolve(dir || '.')\n\n  try {\n    var name = runtimeRequire(path.join(dir, 'package.json')).name.toUpperCase().replace(/-/g, '_')\n    if (process.env[name + '_PREBUILD']) dir = process.env[name + '_PREBUILD']\n  } catch (err) {}\n\n  if (!prebuildsOnly) {\n    var release = getFirst(path.join(dir, 'build/Release'), matchBuild)\n    if (release) return release\n\n    var debug = getFirst(path.join(dir, 'build/Debug'), matchBuild)\n    if (debug) return debug\n  }\n\n  var names = [platform + '-' + arch]\n  if (libc) names.push(platform + libc + '-' + arch)\n\n  if ((arch === 'arm' || arch === 'arm64') && armv) {\n    names.forEach(function (name) {\n      names.push(name + '-v' + armv)\n    })\n  }\n\n  // Find most specific flavor first\n  for (var i = names.length; i--;) {\n    var prebuild = getFirst(path.join(dir, 'prebuilds/' + names[i]), matchPrebuild)\n    if (prebuild) return prebuild\n\n    var napiRuntime = getFirst(path.join(dir, 'prebuilds/' + names[i]), matchNapiRuntime)\n    if (napiRuntime) return napiRuntime\n\n    var napi = getFirst(path.join(dir, 'prebuilds/' + names[i]), matchNapi)\n    if (napi) return napi\n  }\n\n  throw new Error('No native build was found for runtime=' + runtime + ' abi=' + abi + ' platform=' + platform + libc + ' arch=' + arch)\n}\n\nfunction getFirst (dir, filter) {\n  try {\n    var files = fs.readdirSync(dir).filter(filter)\n    return files[0] && path.join(dir, files[0])\n  } catch (err) {\n    return null\n  }\n}\n\nfunction matchNapiRuntime (name) {\n  return name === runtime + '-napi.node'\n}\n\nfunction matchNapi (name) {\n  return name === 'node-napi.node'\n}\n\nfunction matchPrebuild (name) {\n  var parts = name.split('-')\n  return parts[0] === runtime && parts[1] === abi + '.node'\n}\n\nfunction matchBuild (name) {\n  return /\\.node$/.test(name)\n}\n\nfunction isElectron () {\n  if (process.versions && process.versions.electron) return true\n  if (process.env.ELECTRON_RUN_AS_NODE) return true\n  return typeof window !== 'undefined' && window.process && window.process.type === 'renderer'\n}\n\nfunction isAlpine (platform) {\n  return platform === 'linux' && fs.existsSync('/etc/alpine-release')\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Convenience class to use as a binary carrier.\n *\n * Any valid Object with a field named `buffer` may be used as a binary carrier;\n * this class is only one such type of object that can be used.\n */\nvar BinaryCarrier = /** @class */ (function () {\n    function BinaryCarrier(buffer) {\n        this.buffer = buffer;\n    }\n    return BinaryCarrier;\n}());\nexports.default = BinaryCarrier;\n//# sourceMappingURL=binary_carrier.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * The FORMAT_BINARY format represents SpanContexts in an opaque binary\n * carrier.\n *\n * Tracer.inject() will set the buffer field to an Array-like (Array,\n * ArrayBuffer, or TypedBuffer) object containing the injected binary data.\n * Any valid Object can be used as long as the buffer field of the object\n * can be set.\n *\n * Tracer.extract() will look for `carrier.buffer`, and that field is\n * expected to be an Array-like object (Array, ArrayBuffer, or\n * TypedBuffer).\n */\nexports.FORMAT_BINARY = 'binary';\n/**\n * The FORMAT_TEXT_MAP format represents SpanContexts using a\n * string->string map (backed by a Javascript Object) as a carrier.\n *\n * NOTE: Unlike FORMAT_HTTP_HEADERS, FORMAT_TEXT_MAP places no restrictions\n * on the characters used in either the keys or the values of the map\n * entries.\n *\n * The FORMAT_TEXT_MAP carrier map may contain unrelated data (e.g.,\n * arbitrary gRPC metadata); as such, the Tracer implementation should use\n * a prefix or other convention to distinguish Tracer-specific key:value\n * pairs.\n */\nexports.FORMAT_TEXT_MAP = 'text_map';\n/**\n * The FORMAT_HTTP_HEADERS format represents SpanContexts using a\n * character-restricted string->string map (backed by a Javascript Object)\n * as a carrier.\n *\n * Keys and values in the FORMAT_HTTP_HEADERS carrier must be suitable for\n * use as HTTP headers (without modification or further escaping). That is,\n * the keys have a greatly restricted character set, casing for the keys\n * may not be preserved by various intermediaries, and the values should be\n * URL-escaped.\n *\n * The FORMAT_HTTP_HEADERS carrier map may contain unrelated data (e.g.,\n * arbitrary HTTP headers); as such, the Tracer implementation should use a\n * prefix or other convention to distinguish Tracer-specific key:value\n * pairs.\n */\nexports.FORMAT_HTTP_HEADERS = 'http_headers';\n/**\n * A Span may be the \"child of\" a parent Span. In a child of reference,\n * the parent Span depends on the child Span in some capacity.\n *\n * See more about reference types at https://github.com/opentracing/specification\n */\nexports.REFERENCE_CHILD_OF = 'child_of';\n/**\n * Some parent Spans do not depend in any way on the result of their child\n * Spans. In these cases, we say merely that the child Span follows from\n * the parent Span in a causal sense.\n *\n * See more about reference types at https://github.com/opentracing/specification\n */\nexports.REFERENCE_FOLLOWS_FROM = 'follows_from';\n//# sourceMappingURL=constants.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/** SPAN_KIND hints at relationship between spans, e.g. client/server */\nexports.SPAN_KIND = 'span.kind';\n/** Marks a span representing the client-side of an RPC or other remote call */\nexports.SPAN_KIND_RPC_CLIENT = 'client';\n/** Marks a span representing the server-side of an RPC or other remote call */\nexports.SPAN_KIND_RPC_SERVER = 'server';\n/** Marks a span representing the producing-side within a messaging system or other remote call */\nexports.SPAN_KIND_MESSAGING_PRODUCER = 'producer';\n/** Marks a span representing the consuming-side within a messaging system or other remote call */\nexports.SPAN_KIND_MESSAGING_CONSUMER = 'consumer';\n/**\n * ERROR (boolean) true if and only if the application considers the operation\n * represented by the Span to have failed\n */\nexports.ERROR = 'error';\n/**\n * COMPONENT (string) ia s low-cardinality identifier of the module, library,\n * or package that is generating a span.\n */\nexports.COMPONENT = 'component';\n/**\n * SAMPLING_PRIORITY (number) determines the priority of sampling this Span.\n * If greater than 0, a hint to the Tracer to do its best to capture the trace.\n * If 0, a hint to the trace to not-capture the trace. If absent, the Tracer\n * should use its default sampling mechanism.\n */\nexports.SAMPLING_PRIORITY = 'sampling.priority';\n// ---------------------------------------------------------------------------\n// PEER_* tags can be emitted by either client-side of server-side to describe\n// the other side/service in a peer-to-peer communications, like an RPC call.\n// ---------------------------------------------------------------------------\n/**\n * PEER_SERVICE (string) Remote service name (for some unspecified\n * definition of \"service\"). E.g., \"elasticsearch\", \"a_custom_microservice\", \"memcache\"\n */\nexports.PEER_SERVICE = 'peer.service';\n/** PEER_HOSTNAME (string) Remote hostname. E.g., \"opentracing.io\", \"internal.dns.name\" */\nexports.PEER_HOSTNAME = 'peer.hostname';\n/**\n * PEER_ADDRESS (string) Remote \"address\", suitable for use in a\n * networking client library. This may be a \"ip:port\", a bare\n * \"hostname\", a FQDN, or even a JDBC substring like \"mysql://prod-db:3306\"\n */\nexports.PEER_ADDRESS = 'peer.address';\n/**\n * PEER_HOST_IPV4 (number) Remote IPv4 address as a .-separated tuple.\n * E.g., \"127.0.0.1\"\n */\nexports.PEER_HOST_IPV4 = 'peer.ipv4';\n// PEER_HOST_IPV6 (string) Remote IPv6 address as a string of\n// colon-separated 4-char hex tuples. E.g., \"2001:0db8:85a3:0000:0000:8a2e:0370:7334\"\nexports.PEER_HOST_IPV6 = 'peer.ipv6';\n// PEER_PORT (number) Remote port. E.g., 80\nexports.PEER_PORT = 'peer.port';\n// ---------------------------------------------------------------------------\n// HTTP tags\n// ---------------------------------------------------------------------------\n/**\n * HTTP_URL (string) URL of the request being handled in this segment of the\n * trace, in standard URI format. E.g., \"https://domain.net/path/to?resource=here\"\n */\nexports.HTTP_URL = 'http.url';\n/**\n * HTTP_METHOD (string) HTTP method of the request for the associated Span. E.g.,\n * \"GET\", \"POST\"\n */\nexports.HTTP_METHOD = 'http.method';\n/**\n * HTTP_STATUS_CODE (number) HTTP response status code for the associated Span.\n * E.g., 200, 503, 404\n */\nexports.HTTP_STATUS_CODE = 'http.status_code';\n// -------------------------------------------------------------------------\n// Messaging tags\n// -------------------------------------------------------------------------\n/**\n * MESSAGE_BUS_DESTINATION (string) An address at which messages can be exchanged.\n * E.g. A Kafka record has an associated \"topic name\" that can be extracted\n * by the instrumented producer or consumer and stored using this tag.\n */\nexports.MESSAGE_BUS_DESTINATION = 'message_bus.destination';\n// --------------------------------------------------------------------------\n// Database tags\n// --------------------------------------------------------------------------\n/**\n * DB_INSTANCE (string) Database instance name. E.g., In java, if the\n * jdbc.url=\"jdbc:mysql://127.0.0.1:3306/customers\", the instance name is \"customers\".\n */\nexports.DB_INSTANCE = 'db.instance';\n/**\n * DB_STATEMENT (string) A database statement for the given database type.\n * E.g., for db.type=\"SQL\", \"SELECT * FROM wuser_table\";\n * for db.type=\"redis\", \"SET mykey 'WuValue'\".\n */\nexports.DB_STATEMENT = 'db.statement';\n/**\n * DB_TYPE (string) Database type. For any SQL database, \"sql\". For others,\n * the lower-case database category, e.g. \"cassandra\", \"hbase\", or \"redis\".\n */\nexports.DB_TYPE = 'db.type';\n/**\n * DB_USER (string) Username for accessing database. E.g., \"readonly_user\"\n * or \"reporting_user\"\n */\nexports.DB_USER = 'db.user';\n//# sourceMappingURL=tags.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Constants = require(\"./constants\");\nvar reference_1 = require(\"./reference\");\nvar span_1 = require(\"./span\");\n/**\n * Return a new REFERENCE_CHILD_OF reference.\n *\n * @param {SpanContext} spanContext - the parent SpanContext instance to\n *        reference.\n * @return a REFERENCE_CHILD_OF reference pointing to `spanContext`\n */\nfunction childOf(spanContext) {\n    // Allow the user to pass a Span instead of a SpanContext\n    if (spanContext instanceof span_1.default) {\n        spanContext = spanContext.context();\n    }\n    return new reference_1.default(Constants.REFERENCE_CHILD_OF, spanContext);\n}\nexports.childOf = childOf;\n/**\n * Return a new REFERENCE_FOLLOWS_FROM reference.\n *\n * @param {SpanContext} spanContext - the parent SpanContext instance to\n *        reference.\n * @return a REFERENCE_FOLLOWS_FROM reference pointing to `spanContext`\n */\nfunction followsFrom(spanContext) {\n    // Allow the user to pass a Span instead of a SpanContext\n    if (spanContext instanceof span_1.default) {\n        spanContext = spanContext.context();\n    }\n    return new reference_1.default(Constants.REFERENCE_FOLLOWS_FROM, spanContext);\n}\nexports.followsFrom = followsFrom;\n//# sourceMappingURL=functions.js.map","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tracer_1 = require(\"./tracer\");\nvar noopTracer = new tracer_1.default();\nvar _globalTracer = null;\n// Allows direct importing/requiring of the global tracer:\n//\n// let globalTracer = require('opentracing/global');\n//      OR\n// import globalTracer from 'opentracing/global';\n//\n// Acts a bridge to the global tracer that can be safely called before the\n// global tracer is initialized. The purpose of the delegation is to avoid the\n// sometimes nearly intractible initialization order problems that can arise in\n// applications with a complex set of dependencies, while also avoiding the\n// case where\nvar GlobalTracerDelegate = /** @class */ (function (_super) {\n    __extends(GlobalTracerDelegate, _super);\n    function GlobalTracerDelegate() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    GlobalTracerDelegate.prototype.startSpan = function () {\n        var tracer = _globalTracer || noopTracer;\n        return tracer.startSpan.apply(tracer, arguments);\n    };\n    GlobalTracerDelegate.prototype.inject = function () {\n        var tracer = _globalTracer || noopTracer;\n        return tracer.inject.apply(tracer, arguments);\n    };\n    GlobalTracerDelegate.prototype.extract = function () {\n        var tracer = _globalTracer || noopTracer;\n        return tracer.extract.apply(tracer, arguments);\n    };\n    return GlobalTracerDelegate;\n}(tracer_1.default));\nvar globalTracerDelegate = new GlobalTracerDelegate();\n/**\n * Set the global Tracer.\n *\n * The behavior is undefined if this function is called more than once.\n *\n * @param {Tracer} tracer - the Tracer implementation\n */\nfunction initGlobalTracer(tracer) {\n    _globalTracer = tracer;\n}\nexports.initGlobalTracer = initGlobalTracer;\n/**\n * Returns the global tracer.\n */\nfunction globalTracer() {\n    // Return the delegate.  Since the global tracer is largely a convenience\n    // (the user can always create their own tracers), the delegate is used to\n    // give the added convenience of not needing to worry about initialization\n    // order.\n    return globalTracerDelegate;\n}\nexports.globalTracer = globalTracer;\n//# sourceMappingURL=global_tracer.js.map","\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar binary_carrier_1 = require(\"./binary_carrier\");\nexports.BinaryCarrier = binary_carrier_1.default;\nvar Tags = require(\"./ext/tags\");\nexports.Tags = Tags;\nvar Noop = require(\"./noop\");\nvar reference_1 = require(\"./reference\");\nexports.Reference = reference_1.default;\nvar span_1 = require(\"./span\");\nexports.Span = span_1.default;\nvar span_context_1 = require(\"./span_context\");\nexports.SpanContext = span_context_1.default;\nvar tracer_1 = require(\"./tracer\");\nexports.Tracer = tracer_1.Tracer;\nvar mock_tracer_1 = require(\"./mock_tracer\");\nexports.MockTracer = mock_tracer_1.MockTracer;\n__export(require(\"./global_tracer\"));\n__export(require(\"./constants\"));\n__export(require(\"./functions\"));\n// Initialize the noops last to avoid a dependecy cycle between the classes.\nNoop.initialize();\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar mock_context_1 = require(\"./mock_context\");\nexports.MockContext = mock_context_1.default;\nvar mock_span_1 = require(\"./mock_span\");\nexports.MockSpan = mock_span_1.default;\nvar mock_tracer_1 = require(\"./mock_tracer\");\nexports.MockTracer = mock_tracer_1.default;\n//# sourceMappingURL=index.js.map","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar span_context_1 = require(\"../span_context\");\n/**\n * OpenTracing Context implementation designed for use in\n * unit tests.\n */\nvar MockContext = /** @class */ (function (_super) {\n    __extends(MockContext, _super);\n    function MockContext(span) {\n        var _this = _super.call(this) || this;\n        // Store a reference to the span itself since this is a mock tracer\n        // intended to make debugging and unit testing easier.\n        _this._span = span;\n        return _this;\n    }\n    MockContext.prototype.span = function () {\n        return this._span;\n    };\n    return MockContext;\n}(span_context_1.SpanContext));\nexports.MockContext = MockContext;\nexports.default = MockContext;\n//# sourceMappingURL=mock_context.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Index a collection of reported MockSpans in a way that's easy to run unit\n * test assertions against.\n */\nvar MockReport = /** @class */ (function () {\n    function MockReport(spans) {\n        var _this = this;\n        this.spans = spans;\n        this.spansByUUID = {};\n        this.spansByTag = {};\n        this.debugSpans = [];\n        this.unfinishedSpans = [];\n        spans.forEach(function (span) {\n            if (span._finishMs === 0) {\n                _this.unfinishedSpans.push(span);\n            }\n            _this.spansByUUID[span.uuid()] = span;\n            _this.debugSpans.push(span.debug());\n            var tags = span.tags();\n            Object.keys(tags).forEach(function (key) {\n                var val = tags[key];\n                _this.spansByTag[key] = _this.spansByTag[key] || {};\n                _this.spansByTag[key][val] = _this.spansByTag[key][val] || [];\n                _this.spansByTag[key][val].push(span);\n            });\n        });\n    }\n    MockReport.prototype.firstSpanWithTagValue = function (key, val) {\n        var m = this.spansByTag[key];\n        if (!m) {\n            return null;\n        }\n        var n = m[val];\n        if (!n) {\n            return null;\n        }\n        return n[0];\n    };\n    return MockReport;\n}());\nexports.MockReport = MockReport;\nexports.default = MockReport;\n//# sourceMappingURL=mock_report.js.map","\"use strict\";\n/* eslint-disable import/no-extraneous-dependencies */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar opentracing = require(\"../index\");\nvar mock_context_1 = require(\"./mock_context\");\n/**\n * OpenTracing Span implementation designed for use in unit tests.\n */\nvar MockSpan = /** @class */ (function (_super) {\n    __extends(MockSpan, _super);\n    //------------------------------------------------------------------------//\n    // MockSpan-specific\n    //------------------------------------------------------------------------//\n    function MockSpan(tracer) {\n        var _this = _super.call(this) || this;\n        _this._mockTracer = tracer;\n        _this._uuid = _this._generateUUID();\n        _this._startMs = Date.now();\n        _this._finishMs = 0;\n        _this._operationName = '';\n        _this._tags = {};\n        _this._logs = [];\n        return _this;\n    }\n    //------------------------------------------------------------------------//\n    // OpenTracing implementation\n    //------------------------------------------------------------------------//\n    MockSpan.prototype._context = function () {\n        return new mock_context_1.default(this);\n    };\n    MockSpan.prototype._setOperationName = function (name) {\n        this._operationName = name;\n    };\n    MockSpan.prototype._addTags = function (set) {\n        var keys = Object.keys(set);\n        for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {\n            var key = keys_1[_i];\n            this._tags[key] = set[key];\n        }\n    };\n    MockSpan.prototype._log = function (fields, timestamp) {\n        this._logs.push({\n            fields: fields,\n            timestamp: timestamp\n        });\n    };\n    MockSpan.prototype._finish = function (finishTime) {\n        this._finishMs = finishTime || Date.now();\n    };\n    MockSpan.prototype.uuid = function () {\n        return this._uuid;\n    };\n    MockSpan.prototype.operationName = function () {\n        return this._operationName;\n    };\n    MockSpan.prototype.durationMs = function () {\n        return this._finishMs - this._startMs;\n    };\n    MockSpan.prototype.tags = function () {\n        return this._tags;\n    };\n    MockSpan.prototype.tracer = function () {\n        return this._mockTracer;\n    };\n    MockSpan.prototype._generateUUID = function () {\n        var p0 = (\"00000000\" + Math.abs((Math.random() * 0xFFFFFFFF) | 0).toString(16)).substr(-8);\n        var p1 = (\"00000000\" + Math.abs((Math.random() * 0xFFFFFFFF) | 0).toString(16)).substr(-8);\n        return \"\" + p0 + p1;\n    };\n    MockSpan.prototype.addReference = function (ref) {\n    };\n    /**\n     * Returns a simplified object better for console.log()'ing.\n     */\n    MockSpan.prototype.debug = function () {\n        var obj = {\n            uuid: this._uuid,\n            operation: this._operationName,\n            millis: [this._finishMs - this._startMs, this._startMs, this._finishMs]\n        };\n        if (Object.keys(this._tags).length) {\n            obj.tags = this._tags;\n        }\n        return obj;\n    };\n    return MockSpan;\n}(opentracing.Span));\nexports.MockSpan = MockSpan;\nexports.default = MockSpan;\n//# sourceMappingURL=mock_span.js.map","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// TODO: Move mock-tracer to its own NPM package once it is complete and tested.\nvar opentracing = require(\"../index\");\nvar mock_report_1 = require(\"./mock_report\");\nvar mock_span_1 = require(\"./mock_span\");\n/**\n * OpenTracing Tracer implementation designed for use in unit tests.\n */\nvar MockTracer = /** @class */ (function (_super) {\n    __extends(MockTracer, _super);\n    //------------------------------------------------------------------------//\n    // MockTracer-specific\n    //------------------------------------------------------------------------//\n    function MockTracer() {\n        var _this = _super.call(this) || this;\n        _this._spans = [];\n        return _this;\n    }\n    //------------------------------------------------------------------------//\n    // OpenTracing implementation\n    //------------------------------------------------------------------------//\n    MockTracer.prototype._startSpan = function (name, fields) {\n        // _allocSpan is given it's own method so that derived classes can\n        // allocate any type of object they want, but not have to duplicate\n        // the other common logic in startSpan().\n        var span = this._allocSpan();\n        span.setOperationName(name);\n        this._spans.push(span);\n        if (fields.references) {\n            for (var _i = 0, _a = fields.references; _i < _a.length; _i++) {\n                var ref = _a[_i];\n                span.addReference(ref);\n            }\n        }\n        // Capture the stack at the time the span started\n        span._startStack = new Error().stack;\n        return span;\n    };\n    MockTracer.prototype._inject = function (span, format, carrier) {\n        throw new Error('NOT YET IMPLEMENTED');\n    };\n    MockTracer.prototype._extract = function (format, carrier) {\n        throw new Error('NOT YET IMPLEMENTED');\n    };\n    MockTracer.prototype._allocSpan = function () {\n        return new mock_span_1.default(this);\n    };\n    /**\n     * Discard any buffered data.\n     */\n    MockTracer.prototype.clear = function () {\n        this._spans = [];\n    };\n    /**\n     * Return the buffered data in a format convenient for making unit test\n     * assertions.\n     */\n    MockTracer.prototype.report = function () {\n        return new mock_report_1.default(this._spans);\n    };\n    return MockTracer;\n}(opentracing.Tracer));\nexports.MockTracer = MockTracer;\nexports.default = MockTracer;\n//# sourceMappingURL=mock_tracer.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar span_1 = require(\"./span\");\nvar span_context_1 = require(\"./span_context\");\nvar tracer_1 = require(\"./tracer\");\nexports.tracer = null;\nexports.spanContext = null;\nexports.span = null;\n// Deferred initialization to avoid a dependency cycle where Tracer depends on\n// Span which depends on the noop tracer.\nfunction initialize() {\n    exports.tracer = new tracer_1.default();\n    exports.span = new span_1.default();\n    exports.spanContext = new span_context_1.default();\n}\nexports.initialize = initialize;\n//# sourceMappingURL=noop.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar span_1 = require(\"./span\");\n/**\n * Reference pairs a reference type constant (e.g., REFERENCE_CHILD_OF or\n * REFERENCE_FOLLOWS_FROM) with the SpanContext it points to.\n *\n * See the exported childOf() and followsFrom() functions at the package level.\n */\nvar Reference = /** @class */ (function () {\n    /**\n     * Initialize a new Reference instance.\n     *\n     * @param {string} type - the Reference type constant (e.g.,\n     *        REFERENCE_CHILD_OF or REFERENCE_FOLLOWS_FROM).\n     * @param {SpanContext} referencedContext - the SpanContext being referred\n     *        to. As a convenience, a Span instance may be passed in instead\n     *        (in which case its .context() is used here).\n     */\n    function Reference(type, referencedContext) {\n        this._type = type;\n        this._referencedContext = (referencedContext instanceof span_1.default ?\n            referencedContext.context() :\n            referencedContext);\n    }\n    /**\n     * @return {string} The Reference type (e.g., REFERENCE_CHILD_OF or\n     *         REFERENCE_FOLLOWS_FROM).\n     */\n    Reference.prototype.type = function () {\n        return this._type;\n    };\n    /**\n     * @return {SpanContext} The SpanContext being referred to (e.g., the\n     *         parent in a REFERENCE_CHILD_OF Reference).\n     */\n    Reference.prototype.referencedContext = function () {\n        return this._referencedContext;\n    };\n    return Reference;\n}());\nexports.default = Reference;\n//# sourceMappingURL=reference.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar noop = require(\"./noop\");\n/**\n * Span represents a logical unit of work as part of a broader Trace. Examples\n * of span might include remote procedure calls or a in-process function calls\n * to sub-components. A Trace has a single, top-level \"root\" Span that in turn\n * may have zero or more child Spans, which in turn may have children.\n */\nvar Span = /** @class */ (function () {\n    function Span() {\n    }\n    // ---------------------------------------------------------------------- //\n    // OpenTracing API methods\n    // ---------------------------------------------------------------------- //\n    /**\n     * Returns the SpanContext object associated with this Span.\n     *\n     * @return {SpanContext}\n     */\n    Span.prototype.context = function () {\n        return this._context();\n    };\n    /**\n     * Returns the Tracer object used to create this Span.\n     *\n     * @return {Tracer}\n     */\n    Span.prototype.tracer = function () {\n        return this._tracer();\n    };\n    /**\n     * Sets the string name for the logical operation this span represents.\n     *\n     * @param {string} name\n     */\n    Span.prototype.setOperationName = function (name) {\n        this._setOperationName(name);\n        return this;\n    };\n    /**\n     * Sets a key:value pair on this Span that also propagates to future\n     * children of the associated Span.\n     *\n     * setBaggageItem() enables powerful functionality given a full-stack\n     * opentracing integration (e.g., arbitrary application data from a web\n     * client can make it, transparently, all the way into the depths of a\n     * storage system), and with it some powerful costs: use this feature with\n     * care.\n     *\n     * IMPORTANT NOTE #1: setBaggageItem() will only propagate baggage items to\n     * *future* causal descendants of the associated Span.\n     *\n     * IMPORTANT NOTE #2: Use this thoughtfully and with care. Every key and\n     * value is copied into every local *and remote* child of the associated\n     * Span, and that can add up to a lot of network and cpu overhead.\n     *\n     * @param {string} key\n     * @param {string} value\n     */\n    Span.prototype.setBaggageItem = function (key, value) {\n        this._setBaggageItem(key, value);\n        return this;\n    };\n    /**\n     * Returns the value for a baggage item given its key.\n     *\n     * @param  {string} key\n     *         The key for the given trace attribute.\n     * @return {string}\n     *         String value for the given key, or undefined if the key does not\n     *         correspond to a set trace attribute.\n     */\n    Span.prototype.getBaggageItem = function (key) {\n        return this._getBaggageItem(key);\n    };\n    /**\n     * Adds a single tag to the span.  See `addTags()` for details.\n     *\n     * @param {string} key\n     * @param {any} value\n     */\n    Span.prototype.setTag = function (key, value) {\n        var _a;\n        // NOTE: the call is normalized to a call to _addTags()\n        this._addTags((_a = {}, _a[key] = value, _a));\n        return this;\n    };\n    /**\n     * Adds the given key value pairs to the set of span tags.\n     *\n     * Multiple calls to addTags() results in the tags being the superset of\n     * all calls.\n     *\n     * The behavior of setting the same key multiple times on the same span\n     * is undefined.\n     *\n     * The supported type of the values is implementation-dependent.\n     * Implementations are expected to safely handle all types of values but\n     * may choose to ignore unrecognized / unhandle-able values (e.g. objects\n     * with cyclic references, function objects).\n     *\n     * @return {[type]} [description]\n     */\n    Span.prototype.addTags = function (keyValueMap) {\n        this._addTags(keyValueMap);\n        return this;\n    };\n    /**\n     * Add a log record to this Span, optionally at a user-provided timestamp.\n     *\n     * For example:\n     *\n     *     span.log({\n     *         size: rpc.size(),  // numeric value\n     *         URI: rpc.URI(),  // string value\n     *         payload: rpc.payload(),  // Object value\n     *         \"keys can be arbitrary strings\": rpc.foo(),\n     *     });\n     *\n     *     span.log({\n     *         \"error.description\": someError.description(),\n     *     }, someError.timestampMillis());\n     *\n     * @param {object} keyValuePairs\n     *        An object mapping string keys to arbitrary value types. All\n     *        Tracer implementations should support bool, string, and numeric\n     *        value types, and some may also support Object values.\n     * @param {number} timestamp\n     *        An optional parameter specifying the timestamp in milliseconds\n     *        since the Unix epoch. Fractional values are allowed so that\n     *        timestamps with sub-millisecond accuracy can be represented. If\n     *        not specified, the implementation is expected to use its notion\n     *        of the current time of the call.\n     */\n    Span.prototype.log = function (keyValuePairs, timestamp) {\n        this._log(keyValuePairs, timestamp);\n        return this;\n    };\n    /**\n     * DEPRECATED\n     */\n    Span.prototype.logEvent = function (eventName, payload) {\n        return this._log({ event: eventName, payload: payload });\n    };\n    /**\n     * Sets the end timestamp and finalizes Span state.\n     *\n     * With the exception of calls to Span.context() (which are always allowed),\n     * finish() must be the last call made to any span instance, and to do\n     * otherwise leads to undefined behavior.\n     *\n     * @param  {number} finishTime\n     *         Optional finish time in milliseconds as a Unix timestamp. Decimal\n     *         values are supported for timestamps with sub-millisecond accuracy.\n     *         If not specified, the current time (as defined by the\n     *         implementation) will be used.\n     */\n    Span.prototype.finish = function (finishTime) {\n        this._finish(finishTime);\n        // Do not return `this`. The Span generally should not be used after it\n        // is finished so chaining is not desired in this context.\n    };\n    // ---------------------------------------------------------------------- //\n    // Derived classes can choose to implement the below\n    // ---------------------------------------------------------------------- //\n    // By default returns a no-op SpanContext.\n    Span.prototype._context = function () {\n        return noop.spanContext;\n    };\n    // By default returns a no-op tracer.\n    //\n    // The base class could store the tracer that created it, but it does not\n    // in order to ensure the no-op span implementation has zero members,\n    // which allows V8 to aggressively optimize calls to such objects.\n    Span.prototype._tracer = function () {\n        return noop.tracer;\n    };\n    // By default does nothing\n    Span.prototype._setOperationName = function (name) {\n    };\n    // By default does nothing\n    Span.prototype._setBaggageItem = function (key, value) {\n    };\n    // By default does nothing\n    Span.prototype._getBaggageItem = function (key) {\n        return undefined;\n    };\n    // By default does nothing\n    //\n    // NOTE: both setTag() and addTags() map to this function. keyValuePairs\n    // will always be an associative array.\n    Span.prototype._addTags = function (keyValuePairs) {\n    };\n    // By default does nothing\n    Span.prototype._log = function (keyValuePairs, timestamp) {\n    };\n    // By default does nothing\n    //\n    // finishTime is expected to be either a number or undefined.\n    Span.prototype._finish = function (finishTime) {\n    };\n    return Span;\n}());\nexports.Span = Span;\nexports.default = Span;\n//# sourceMappingURL=span.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * SpanContext represents Span state that must propagate to descendant Spans\n * and across process boundaries.\n *\n * SpanContext is logically divided into two pieces: the user-level \"Baggage\"\n * (see setBaggageItem and getBaggageItem) that propagates across Span\n * boundaries and any Tracer-implementation-specific fields that are needed to\n * identify or otherwise contextualize the associated Span instance (e.g., a\n * <trace_id, span_id, sampled> tuple).\n */\nvar SpanContext = /** @class */ (function () {\n    function SpanContext() {\n    }\n    // The SpanContext is entirely implementation dependent\n    /**\n     * Returns a string representation of the implementation internal trace ID.\n     *\n     * @returns {string}\n     */\n    SpanContext.prototype.toTraceId = function () {\n        return '';\n    };\n    /**\n     * Returns a string representation of the implementation internal span ID.\n     *\n     * @returns {string}\n     */\n    SpanContext.prototype.toSpanId = function () {\n        return '';\n    };\n    return SpanContext;\n}());\nexports.SpanContext = SpanContext;\nexports.default = SpanContext;\n//# sourceMappingURL=span_context.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Functions = require(\"./functions\");\nvar Noop = require(\"./noop\");\nvar span_1 = require(\"./span\");\n/**\n * Tracer is the entry-point between the instrumentation API and the tracing\n * implementation.\n *\n * The default object acts as a no-op implementation.\n *\n * Note to implementators: derived classes can choose to directly implement the\n * methods in the \"OpenTracing API methods\" section, or optionally the subset of\n * underscore-prefixed methods to pick up the argument checking and handling\n * automatically from the base class.\n */\nvar Tracer = /** @class */ (function () {\n    function Tracer() {\n    }\n    // ---------------------------------------------------------------------- //\n    // OpenTracing API methods\n    // ---------------------------------------------------------------------- //\n    /**\n     * Starts and returns a new Span representing a logical unit of work.\n     *\n     * For example:\n     *\n     *     // Start a new (parentless) root Span:\n     *     var parent = Tracer.startSpan('DoWork');\n     *\n     *     // Start a new (child) Span:\n     *     var child = Tracer.startSpan('load-from-db', {\n     *         childOf: parent.context(),\n     *     });\n     *\n     *     // Start a new async (FollowsFrom) Span:\n     *     var child = Tracer.startSpan('async-cache-write', {\n     *         references: [\n     *             opentracing.followsFrom(parent.context())\n     *         ],\n     *     });\n     *\n     * @param {string} name - the name of the operation (REQUIRED).\n     * @param {SpanOptions} [options] - options for the newly created span.\n     * @return {Span} - a new Span object.\n     */\n    Tracer.prototype.startSpan = function (name, options) {\n        if (options === void 0) { options = {}; }\n        // Convert options.childOf to fields.references as needed.\n        if (options.childOf) {\n            // Convert from a Span or a SpanContext into a Reference.\n            var childOf = Functions.childOf(options.childOf);\n            if (options.references) {\n                options.references.push(childOf);\n            }\n            else {\n                options.references = [childOf];\n            }\n            delete (options.childOf);\n        }\n        return this._startSpan(name, options);\n    };\n    /**\n     * Injects the given SpanContext instance for cross-process propagation\n     * within `carrier`. The expected type of `carrier` depends on the value of\n     * `format.\n     *\n     * OpenTracing defines a common set of `format` values (see\n     * FORMAT_TEXT_MAP, FORMAT_HTTP_HEADERS, and FORMAT_BINARY), and each has\n     * an expected carrier type.\n     *\n     * Consider this pseudocode example:\n     *\n     *     var clientSpan = ...;\n     *     ...\n     *     // Inject clientSpan into a text carrier.\n     *     var headersCarrier = {};\n     *     Tracer.inject(clientSpan.context(), Tracer.FORMAT_HTTP_HEADERS, headersCarrier);\n     *     // Incorporate the textCarrier into the outbound HTTP request header\n     *     // map.\n     *     Object.assign(outboundHTTPReq.headers, headersCarrier);\n     *     // ... send the httpReq\n     *\n     * @param  {SpanContext} spanContext - the SpanContext to inject into the\n     *         carrier object. As a convenience, a Span instance may be passed\n     *         in instead (in which case its .context() is used for the\n     *         inject()).\n     * @param  {string} format - the format of the carrier.\n     * @param  {any} carrier - see the documentation for the chosen `format`\n     *         for a description of the carrier object.\n     */\n    Tracer.prototype.inject = function (spanContext, format, carrier) {\n        // Allow the user to pass a Span instead of a SpanContext\n        if (spanContext instanceof span_1.default) {\n            spanContext = spanContext.context();\n        }\n        return this._inject(spanContext, format, carrier);\n    };\n    /**\n     * Returns a SpanContext instance extracted from `carrier` in the given\n     * `format`.\n     *\n     * OpenTracing defines a common set of `format` values (see\n     * FORMAT_TEXT_MAP, FORMAT_HTTP_HEADERS, and FORMAT_BINARY), and each has\n     * an expected carrier type.\n     *\n     * Consider this pseudocode example:\n     *\n     *     // Use the inbound HTTP request's headers as a text map carrier.\n     *     var headersCarrier = inboundHTTPReq.headers;\n     *     var wireCtx = Tracer.extract(Tracer.FORMAT_HTTP_HEADERS, headersCarrier);\n     *     var serverSpan = Tracer.startSpan('...', { childOf : wireCtx });\n     *\n     * @param  {string} format - the format of the carrier.\n     * @param  {any} carrier - the type of the carrier object is determined by\n     *         the format.\n     * @return {SpanContext}\n     *         The extracted SpanContext, or null if no such SpanContext could\n     *         be found in `carrier`\n     */\n    Tracer.prototype.extract = function (format, carrier) {\n        return this._extract(format, carrier);\n    };\n    // ---------------------------------------------------------------------- //\n    // Derived classes can choose to implement the below\n    // ---------------------------------------------------------------------- //\n    // NOTE: the input to this method is *always* an associative array. The\n    // public-facing startSpan() method normalizes the arguments so that\n    // all N implementations do not need to worry about variations in the call\n    // signature.\n    //\n    // The default behavior returns a no-op span.\n    Tracer.prototype._startSpan = function (name, fields) {\n        return Noop.span;\n    };\n    // The default behavior is a no-op.\n    Tracer.prototype._inject = function (spanContext, format, carrier) {\n    };\n    // The default behavior is to return a no-op SpanContext.\n    Tracer.prototype._extract = function (format, carrier) {\n        return Noop.spanContext;\n    };\n    return Tracer;\n}());\nexports.Tracer = Tracer;\nexports.default = Tracer;\n//# sourceMappingURL=tracer.js.map","'use strict';\nconst Queue = require('yocto-queue');\n\nconst pLimit = concurrency => {\n\tif (!((Number.isInteger(concurrency) || concurrency === Infinity) && concurrency > 0)) {\n\t\tthrow new TypeError('Expected `concurrency` to be a number from 1 and up');\n\t}\n\n\tconst queue = new Queue();\n\tlet activeCount = 0;\n\n\tconst next = () => {\n\t\tactiveCount--;\n\n\t\tif (queue.size > 0) {\n\t\t\tqueue.dequeue()();\n\t\t}\n\t};\n\n\tconst run = async (fn, resolve, ...args) => {\n\t\tactiveCount++;\n\n\t\tconst result = (async () => fn(...args))();\n\n\t\tresolve(result);\n\n\t\ttry {\n\t\t\tawait result;\n\t\t} catch {}\n\n\t\tnext();\n\t};\n\n\tconst enqueue = (fn, resolve, ...args) => {\n\t\tqueue.enqueue(run.bind(null, fn, resolve, ...args));\n\n\t\t(async () => {\n\t\t\t// This function needs to wait until the next microtask before comparing\n\t\t\t// `activeCount` to `concurrency`, because `activeCount` is updated asynchronously\n\t\t\t// when the run function is dequeued and called. The comparison in the if-statement\n\t\t\t// needs to happen asynchronously as well to get an up-to-date value for `activeCount`.\n\t\t\tawait Promise.resolve();\n\n\t\t\tif (activeCount < concurrency && queue.size > 0) {\n\t\t\t\tqueue.dequeue()();\n\t\t\t}\n\t\t})();\n\t};\n\n\tconst generator = (fn, ...args) => new Promise(resolve => {\n\t\tenqueue(fn, resolve, ...args);\n\t});\n\n\tObject.defineProperties(generator, {\n\t\tactiveCount: {\n\t\t\tget: () => activeCount\n\t\t},\n\t\tpendingCount: {\n\t\t\tget: () => queue.size\n\t\t},\n\t\tclearQueue: {\n\t\t\tvalue: () => {\n\t\t\t\tqueue.clear();\n\t\t\t}\n\t\t}\n\t});\n\n\treturn generator;\n};\n\nmodule.exports = pLimit;\n","// Generated by CoffeeScript 1.12.2\n(function() {\n  var getNanoSeconds, hrtime, loadTime, moduleLoadTime, nodeLoadTime, upTime;\n\n  if ((typeof performance !== \"undefined\" && performance !== null) && performance.now) {\n    module.exports = function() {\n      return performance.now();\n    };\n  } else if ((typeof process !== \"undefined\" && process !== null) && process.hrtime) {\n    module.exports = function() {\n      return (getNanoSeconds() - nodeLoadTime) / 1e6;\n    };\n    hrtime = process.hrtime;\n    getNanoSeconds = function() {\n      var hr;\n      hr = hrtime();\n      return hr[0] * 1e9 + hr[1];\n    };\n    moduleLoadTime = getNanoSeconds();\n    upTime = process.uptime() * 1e9;\n    nodeLoadTime = moduleLoadTime - upTime;\n  } else if (Date.now) {\n    module.exports = function() {\n      return Date.now() - loadTime;\n    };\n    loadTime = Date.now();\n  } else {\n    module.exports = function() {\n      return new Date().getTime() - loadTime;\n    };\n    loadTime = new Date().getTime();\n  }\n\n}).call(this);\n\n//# sourceMappingURL=performance-now.js.map\n","// minimal library entry point.\n\n\"use strict\";\nmodule.exports = require(\"./src/index-minimal\");\n","\"use strict\";\nvar protobuf = exports;\n\n/**\n * Build type, one of `\"full\"`, `\"light\"` or `\"minimal\"`.\n * @name build\n * @type {string}\n * @const\n */\nprotobuf.build = \"minimal\";\n\n// Serialization\nprotobuf.Writer       = require(\"./writer\");\nprotobuf.BufferWriter = require(\"./writer_buffer\");\nprotobuf.Reader       = require(\"./reader\");\nprotobuf.BufferReader = require(\"./reader_buffer\");\n\n// Utility\nprotobuf.util         = require(\"./util/minimal\");\nprotobuf.rpc          = require(\"./rpc\");\nprotobuf.roots        = require(\"./roots\");\nprotobuf.configure    = configure;\n\n/* istanbul ignore next */\n/**\n * Reconfigures the library according to the environment.\n * @returns {undefined}\n */\nfunction configure() {\n    protobuf.util._configure();\n    protobuf.Writer._configure(protobuf.BufferWriter);\n    protobuf.Reader._configure(protobuf.BufferReader);\n}\n\n// Set up buffer utility according to the environment\nconfigure();\n","\"use strict\";\nmodule.exports = Reader;\n\nvar util      = require(\"./util/minimal\");\n\nvar BufferReader; // cyclic\n\nvar LongBits  = util.LongBits,\n    utf8      = util.utf8;\n\n/* istanbul ignore next */\nfunction indexOutOfRange(reader, writeLength) {\n    return RangeError(\"index out of range: \" + reader.pos + \" + \" + (writeLength || 1) + \" > \" + reader.len);\n}\n\n/**\n * Constructs a new reader instance using the specified buffer.\n * @classdesc Wire format reader using `Uint8Array` if available, otherwise `Array`.\n * @constructor\n * @param {Uint8Array} buffer Buffer to read from\n */\nfunction Reader(buffer) {\n\n    /**\n     * Read buffer.\n     * @type {Uint8Array}\n     */\n    this.buf = buffer;\n\n    /**\n     * Read buffer position.\n     * @type {number}\n     */\n    this.pos = 0;\n\n    /**\n     * Read buffer length.\n     * @type {number}\n     */\n    this.len = buffer.length;\n}\n\nvar create_array = typeof Uint8Array !== \"undefined\"\n    ? function create_typed_array(buffer) {\n        if (buffer instanceof Uint8Array || Array.isArray(buffer))\n            return new Reader(buffer);\n        throw Error(\"illegal buffer\");\n    }\n    /* istanbul ignore next */\n    : function create_array(buffer) {\n        if (Array.isArray(buffer))\n            return new Reader(buffer);\n        throw Error(\"illegal buffer\");\n    };\n\nvar create = function create() {\n    return util.Buffer\n        ? function create_buffer_setup(buffer) {\n            return (Reader.create = function create_buffer(buffer) {\n                return util.Buffer.isBuffer(buffer)\n                    ? new BufferReader(buffer)\n                    /* istanbul ignore next */\n                    : create_array(buffer);\n            })(buffer);\n        }\n        /* istanbul ignore next */\n        : create_array;\n};\n\n/**\n * Creates a new reader using the specified buffer.\n * @function\n * @param {Uint8Array|Buffer} buffer Buffer to read from\n * @returns {Reader|BufferReader} A {@link BufferReader} if `buffer` is a Buffer, otherwise a {@link Reader}\n * @throws {Error} If `buffer` is not a valid buffer\n */\nReader.create = create();\n\nReader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */ util.Array.prototype.slice;\n\n/**\n * Reads a varint as an unsigned 32 bit value.\n * @function\n * @returns {number} Value read\n */\nReader.prototype.uint32 = (function read_uint32_setup() {\n    var value = 4294967295; // optimizer type-hint, tends to deopt otherwise (?!)\n    return function read_uint32() {\n        value = (         this.buf[this.pos] & 127       ) >>> 0; if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] & 127) <<  7) >>> 0; if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0; if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0; if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] &  15) << 28) >>> 0; if (this.buf[this.pos++] < 128) return value;\n\n        /* istanbul ignore if */\n        if ((this.pos += 5) > this.len) {\n            this.pos = this.len;\n            throw indexOutOfRange(this, 10);\n        }\n        return value;\n    };\n})();\n\n/**\n * Reads a varint as a signed 32 bit value.\n * @returns {number} Value read\n */\nReader.prototype.int32 = function read_int32() {\n    return this.uint32() | 0;\n};\n\n/**\n * Reads a zig-zag encoded varint as a signed 32 bit value.\n * @returns {number} Value read\n */\nReader.prototype.sint32 = function read_sint32() {\n    var value = this.uint32();\n    return value >>> 1 ^ -(value & 1) | 0;\n};\n\n/* eslint-disable no-invalid-this */\n\nfunction readLongVarint() {\n    // tends to deopt with local vars for octet etc.\n    var bits = new LongBits(0, 0);\n    var i = 0;\n    if (this.len - this.pos > 4) { // fast route (lo)\n        for (; i < 4; ++i) {\n            // 1st..4th\n            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;\n            if (this.buf[this.pos++] < 128)\n                return bits;\n        }\n        // 5th\n        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;\n        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >>  4) >>> 0;\n        if (this.buf[this.pos++] < 128)\n            return bits;\n        i = 0;\n    } else {\n        for (; i < 3; ++i) {\n            /* istanbul ignore if */\n            if (this.pos >= this.len)\n                throw indexOutOfRange(this);\n            // 1st..3th\n            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;\n            if (this.buf[this.pos++] < 128)\n                return bits;\n        }\n        // 4th\n        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;\n        return bits;\n    }\n    if (this.len - this.pos > 4) { // fast route (hi)\n        for (; i < 5; ++i) {\n            // 6th..10th\n            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;\n            if (this.buf[this.pos++] < 128)\n                return bits;\n        }\n    } else {\n        for (; i < 5; ++i) {\n            /* istanbul ignore if */\n            if (this.pos >= this.len)\n                throw indexOutOfRange(this);\n            // 6th..10th\n            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;\n            if (this.buf[this.pos++] < 128)\n                return bits;\n        }\n    }\n    /* istanbul ignore next */\n    throw Error(\"invalid varint encoding\");\n}\n\n/* eslint-enable no-invalid-this */\n\n/**\n * Reads a varint as a signed 64 bit value.\n * @name Reader#int64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads a varint as an unsigned 64 bit value.\n * @name Reader#uint64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads a zig-zag encoded varint as a signed 64 bit value.\n * @name Reader#sint64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads a varint as a boolean.\n * @returns {boolean} Value read\n */\nReader.prototype.bool = function read_bool() {\n    return this.uint32() !== 0;\n};\n\nfunction readFixed32_end(buf, end) { // note that this uses `end`, not `pos`\n    return (buf[end - 4]\n          | buf[end - 3] << 8\n          | buf[end - 2] << 16\n          | buf[end - 1] << 24) >>> 0;\n}\n\n/**\n * Reads fixed 32 bits as an unsigned 32 bit integer.\n * @returns {number} Value read\n */\nReader.prototype.fixed32 = function read_fixed32() {\n\n    /* istanbul ignore if */\n    if (this.pos + 4 > this.len)\n        throw indexOutOfRange(this, 4);\n\n    return readFixed32_end(this.buf, this.pos += 4);\n};\n\n/**\n * Reads fixed 32 bits as a signed 32 bit integer.\n * @returns {number} Value read\n */\nReader.prototype.sfixed32 = function read_sfixed32() {\n\n    /* istanbul ignore if */\n    if (this.pos + 4 > this.len)\n        throw indexOutOfRange(this, 4);\n\n    return readFixed32_end(this.buf, this.pos += 4) | 0;\n};\n\n/* eslint-disable no-invalid-this */\n\nfunction readFixed64(/* this: Reader */) {\n\n    /* istanbul ignore if */\n    if (this.pos + 8 > this.len)\n        throw indexOutOfRange(this, 8);\n\n    return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));\n}\n\n/* eslint-enable no-invalid-this */\n\n/**\n * Reads fixed 64 bits.\n * @name Reader#fixed64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads zig-zag encoded fixed 64 bits.\n * @name Reader#sfixed64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads a float (32 bit) as a number.\n * @function\n * @returns {number} Value read\n */\nReader.prototype.float = function read_float() {\n\n    /* istanbul ignore if */\n    if (this.pos + 4 > this.len)\n        throw indexOutOfRange(this, 4);\n\n    var value = util.float.readFloatLE(this.buf, this.pos);\n    this.pos += 4;\n    return value;\n};\n\n/**\n * Reads a double (64 bit float) as a number.\n * @function\n * @returns {number} Value read\n */\nReader.prototype.double = function read_double() {\n\n    /* istanbul ignore if */\n    if (this.pos + 8 > this.len)\n        throw indexOutOfRange(this, 4);\n\n    var value = util.float.readDoubleLE(this.buf, this.pos);\n    this.pos += 8;\n    return value;\n};\n\n/**\n * Reads a sequence of bytes preceeded by its length as a varint.\n * @returns {Uint8Array} Value read\n */\nReader.prototype.bytes = function read_bytes() {\n    var length = this.uint32(),\n        start  = this.pos,\n        end    = this.pos + length;\n\n    /* istanbul ignore if */\n    if (end > this.len)\n        throw indexOutOfRange(this, length);\n\n    this.pos += length;\n    if (Array.isArray(this.buf)) // plain array\n        return this.buf.slice(start, end);\n    return start === end // fix for IE 10/Win8 and others' subarray returning array of size 1\n        ? new this.buf.constructor(0)\n        : this._slice.call(this.buf, start, end);\n};\n\n/**\n * Reads a string preceeded by its byte length as a varint.\n * @returns {string} Value read\n */\nReader.prototype.string = function read_string() {\n    var bytes = this.bytes();\n    return utf8.read(bytes, 0, bytes.length);\n};\n\n/**\n * Skips the specified number of bytes if specified, otherwise skips a varint.\n * @param {number} [length] Length if known, otherwise a varint is assumed\n * @returns {Reader} `this`\n */\nReader.prototype.skip = function skip(length) {\n    if (typeof length === \"number\") {\n        /* istanbul ignore if */\n        if (this.pos + length > this.len)\n            throw indexOutOfRange(this, length);\n        this.pos += length;\n    } else {\n        do {\n            /* istanbul ignore if */\n            if (this.pos >= this.len)\n                throw indexOutOfRange(this);\n        } while (this.buf[this.pos++] & 128);\n    }\n    return this;\n};\n\n/**\n * Skips the next element of the specified wire type.\n * @param {number} wireType Wire type received\n * @returns {Reader} `this`\n */\nReader.prototype.skipType = function(wireType) {\n    switch (wireType) {\n        case 0:\n            this.skip();\n            break;\n        case 1:\n            this.skip(8);\n            break;\n        case 2:\n            this.skip(this.uint32());\n            break;\n        case 3:\n            while ((wireType = this.uint32() & 7) !== 4) {\n                this.skipType(wireType);\n            }\n            break;\n        case 5:\n            this.skip(4);\n            break;\n\n        /* istanbul ignore next */\n        default:\n            throw Error(\"invalid wire type \" + wireType + \" at offset \" + this.pos);\n    }\n    return this;\n};\n\nReader._configure = function(BufferReader_) {\n    BufferReader = BufferReader_;\n    Reader.create = create();\n    BufferReader._configure();\n\n    var fn = util.Long ? \"toLong\" : /* istanbul ignore next */ \"toNumber\";\n    util.merge(Reader.prototype, {\n\n        int64: function read_int64() {\n            return readLongVarint.call(this)[fn](false);\n        },\n\n        uint64: function read_uint64() {\n            return readLongVarint.call(this)[fn](true);\n        },\n\n        sint64: function read_sint64() {\n            return readLongVarint.call(this).zzDecode()[fn](false);\n        },\n\n        fixed64: function read_fixed64() {\n            return readFixed64.call(this)[fn](true);\n        },\n\n        sfixed64: function read_sfixed64() {\n            return readFixed64.call(this)[fn](false);\n        }\n\n    });\n};\n","\"use strict\";\nmodule.exports = BufferReader;\n\n// extends Reader\nvar Reader = require(\"./reader\");\n(BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;\n\nvar util = require(\"./util/minimal\");\n\n/**\n * Constructs a new buffer reader instance.\n * @classdesc Wire format reader using node buffers.\n * @extends Reader\n * @constructor\n * @param {Buffer} buffer Buffer to read from\n */\nfunction BufferReader(buffer) {\n    Reader.call(this, buffer);\n\n    /**\n     * Read buffer.\n     * @name BufferReader#buf\n     * @type {Buffer}\n     */\n}\n\nBufferReader._configure = function () {\n    /* istanbul ignore else */\n    if (util.Buffer)\n        BufferReader.prototype._slice = util.Buffer.prototype.slice;\n};\n\n\n/**\n * @override\n */\nBufferReader.prototype.string = function read_string_buffer() {\n    var len = this.uint32(); // modifies pos\n    return this.buf.utf8Slice\n        ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len))\n        : this.buf.toString(\"utf-8\", this.pos, this.pos = Math.min(this.pos + len, this.len));\n};\n\n/**\n * Reads a sequence of bytes preceeded by its length as a varint.\n * @name BufferReader#bytes\n * @function\n * @returns {Buffer} Value read\n */\n\nBufferReader._configure();\n","\"use strict\";\nmodule.exports = {};\n\n/**\n * Named roots.\n * This is where pbjs stores generated structures (the option `-r, --root` specifies a name).\n * Can also be used manually to make roots available accross modules.\n * @name roots\n * @type {Object.<string,Root>}\n * @example\n * // pbjs -r myroot -o compiled.js ...\n *\n * // in another module:\n * require(\"./compiled.js\");\n *\n * // in any subsequent module:\n * var root = protobuf.roots[\"myroot\"];\n */\n","\"use strict\";\n\n/**\n * Streaming RPC helpers.\n * @namespace\n */\nvar rpc = exports;\n\n/**\n * RPC implementation passed to {@link Service#create} performing a service request on network level, i.e. by utilizing http requests or websockets.\n * @typedef RPCImpl\n * @type {function}\n * @param {Method|rpc.ServiceMethod<Message<{}>,Message<{}>>} method Reflected or static method being called\n * @param {Uint8Array} requestData Request data\n * @param {RPCImplCallback} callback Callback function\n * @returns {undefined}\n * @example\n * function rpcImpl(method, requestData, callback) {\n *     if (protobuf.util.lcFirst(method.name) !== \"myMethod\") // compatible with static code\n *         throw Error(\"no such method\");\n *     asynchronouslyObtainAResponse(requestData, function(err, responseData) {\n *         callback(err, responseData);\n *     });\n * }\n */\n\n/**\n * Node-style callback as used by {@link RPCImpl}.\n * @typedef RPCImplCallback\n * @type {function}\n * @param {Error|null} error Error, if any, otherwise `null`\n * @param {Uint8Array|null} [response] Response data or `null` to signal end of stream, if there hasn't been an error\n * @returns {undefined}\n */\n\nrpc.Service = require(\"./rpc/service\");\n","\"use strict\";\nmodule.exports = Service;\n\nvar util = require(\"../util/minimal\");\n\n// Extends EventEmitter\n(Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;\n\n/**\n * A service method callback as used by {@link rpc.ServiceMethod|ServiceMethod}.\n *\n * Differs from {@link RPCImplCallback} in that it is an actual callback of a service method which may not return `response = null`.\n * @typedef rpc.ServiceMethodCallback\n * @template TRes extends Message<TRes>\n * @type {function}\n * @param {Error|null} error Error, if any\n * @param {TRes} [response] Response message\n * @returns {undefined}\n */\n\n/**\n * A service method part of a {@link rpc.Service} as created by {@link Service.create}.\n * @typedef rpc.ServiceMethod\n * @template TReq extends Message<TReq>\n * @template TRes extends Message<TRes>\n * @type {function}\n * @param {TReq|Properties<TReq>} request Request message or plain object\n * @param {rpc.ServiceMethodCallback<TRes>} [callback] Node-style callback called with the error, if any, and the response message\n * @returns {Promise<Message<TRes>>} Promise if `callback` has been omitted, otherwise `undefined`\n */\n\n/**\n * Constructs a new RPC service instance.\n * @classdesc An RPC service as returned by {@link Service#create}.\n * @exports rpc.Service\n * @extends util.EventEmitter\n * @constructor\n * @param {RPCImpl} rpcImpl RPC implementation\n * @param {boolean} [requestDelimited=false] Whether requests are length-delimited\n * @param {boolean} [responseDelimited=false] Whether responses are length-delimited\n */\nfunction Service(rpcImpl, requestDelimited, responseDelimited) {\n\n    if (typeof rpcImpl !== \"function\")\n        throw TypeError(\"rpcImpl must be a function\");\n\n    util.EventEmitter.call(this);\n\n    /**\n     * RPC implementation. Becomes `null` once the service is ended.\n     * @type {RPCImpl|null}\n     */\n    this.rpcImpl = rpcImpl;\n\n    /**\n     * Whether requests are length-delimited.\n     * @type {boolean}\n     */\n    this.requestDelimited = Boolean(requestDelimited);\n\n    /**\n     * Whether responses are length-delimited.\n     * @type {boolean}\n     */\n    this.responseDelimited = Boolean(responseDelimited);\n}\n\n/**\n * Calls a service method through {@link rpc.Service#rpcImpl|rpcImpl}.\n * @param {Method|rpc.ServiceMethod<TReq,TRes>} method Reflected or static method\n * @param {Constructor<TReq>} requestCtor Request constructor\n * @param {Constructor<TRes>} responseCtor Response constructor\n * @param {TReq|Properties<TReq>} request Request message or plain object\n * @param {rpc.ServiceMethodCallback<TRes>} callback Service callback\n * @returns {undefined}\n * @template TReq extends Message<TReq>\n * @template TRes extends Message<TRes>\n */\nService.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {\n\n    if (!request)\n        throw TypeError(\"request must be specified\");\n\n    var self = this;\n    if (!callback)\n        return util.asPromise(rpcCall, self, method, requestCtor, responseCtor, request);\n\n    if (!self.rpcImpl) {\n        setTimeout(function() { callback(Error(\"already ended\")); }, 0);\n        return undefined;\n    }\n\n    try {\n        return self.rpcImpl(\n            method,\n            requestCtor[self.requestDelimited ? \"encodeDelimited\" : \"encode\"](request).finish(),\n            function rpcCallback(err, response) {\n\n                if (err) {\n                    self.emit(\"error\", err, method);\n                    return callback(err);\n                }\n\n                if (response === null) {\n                    self.end(/* endedByRPC */ true);\n                    return undefined;\n                }\n\n                if (!(response instanceof responseCtor)) {\n                    try {\n                        response = responseCtor[self.responseDelimited ? \"decodeDelimited\" : \"decode\"](response);\n                    } catch (err) {\n                        self.emit(\"error\", err, method);\n                        return callback(err);\n                    }\n                }\n\n                self.emit(\"data\", response, method);\n                return callback(null, response);\n            }\n        );\n    } catch (err) {\n        self.emit(\"error\", err, method);\n        setTimeout(function() { callback(err); }, 0);\n        return undefined;\n    }\n};\n\n/**\n * Ends this service and emits the `end` event.\n * @param {boolean} [endedByRPC=false] Whether the service has been ended by the RPC implementation.\n * @returns {rpc.Service} `this`\n */\nService.prototype.end = function end(endedByRPC) {\n    if (this.rpcImpl) {\n        if (!endedByRPC) // signal end to rpcImpl\n            this.rpcImpl(null, null, null);\n        this.rpcImpl = null;\n        this.emit(\"end\").off();\n    }\n    return this;\n};\n","\"use strict\";\nmodule.exports = LongBits;\n\nvar util = require(\"../util/minimal\");\n\n/**\n * Constructs new long bits.\n * @classdesc Helper class for working with the low and high bits of a 64 bit value.\n * @memberof util\n * @constructor\n * @param {number} lo Low 32 bits, unsigned\n * @param {number} hi High 32 bits, unsigned\n */\nfunction LongBits(lo, hi) {\n\n    // note that the casts below are theoretically unnecessary as of today, but older statically\n    // generated converter code might still call the ctor with signed 32bits. kept for compat.\n\n    /**\n     * Low bits.\n     * @type {number}\n     */\n    this.lo = lo >>> 0;\n\n    /**\n     * High bits.\n     * @type {number}\n     */\n    this.hi = hi >>> 0;\n}\n\n/**\n * Zero bits.\n * @memberof util.LongBits\n * @type {util.LongBits}\n */\nvar zero = LongBits.zero = new LongBits(0, 0);\n\nzero.toNumber = function() { return 0; };\nzero.zzEncode = zero.zzDecode = function() { return this; };\nzero.length = function() { return 1; };\n\n/**\n * Zero hash.\n * @memberof util.LongBits\n * @type {string}\n */\nvar zeroHash = LongBits.zeroHash = \"\\0\\0\\0\\0\\0\\0\\0\\0\";\n\n/**\n * Constructs new long bits from the specified number.\n * @param {number} value Value\n * @returns {util.LongBits} Instance\n */\nLongBits.fromNumber = function fromNumber(value) {\n    if (value === 0)\n        return zero;\n    var sign = value < 0;\n    if (sign)\n        value = -value;\n    var lo = value >>> 0,\n        hi = (value - lo) / 4294967296 >>> 0;\n    if (sign) {\n        hi = ~hi >>> 0;\n        lo = ~lo >>> 0;\n        if (++lo > 4294967295) {\n            lo = 0;\n            if (++hi > 4294967295)\n                hi = 0;\n        }\n    }\n    return new LongBits(lo, hi);\n};\n\n/**\n * Constructs new long bits from a number, long or string.\n * @param {Long|number|string} value Value\n * @returns {util.LongBits} Instance\n */\nLongBits.from = function from(value) {\n    if (typeof value === \"number\")\n        return LongBits.fromNumber(value);\n    if (util.isString(value)) {\n        /* istanbul ignore else */\n        if (util.Long)\n            value = util.Long.fromString(value);\n        else\n            return LongBits.fromNumber(parseInt(value, 10));\n    }\n    return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;\n};\n\n/**\n * Converts this long bits to a possibly unsafe JavaScript number.\n * @param {boolean} [unsigned=false] Whether unsigned or not\n * @returns {number} Possibly unsafe number\n */\nLongBits.prototype.toNumber = function toNumber(unsigned) {\n    if (!unsigned && this.hi >>> 31) {\n        var lo = ~this.lo + 1 >>> 0,\n            hi = ~this.hi     >>> 0;\n        if (!lo)\n            hi = hi + 1 >>> 0;\n        return -(lo + hi * 4294967296);\n    }\n    return this.lo + this.hi * 4294967296;\n};\n\n/**\n * Converts this long bits to a long.\n * @param {boolean} [unsigned=false] Whether unsigned or not\n * @returns {Long} Long\n */\nLongBits.prototype.toLong = function toLong(unsigned) {\n    return util.Long\n        ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned))\n        /* istanbul ignore next */\n        : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };\n};\n\nvar charCodeAt = String.prototype.charCodeAt;\n\n/**\n * Constructs new long bits from the specified 8 characters long hash.\n * @param {string} hash Hash\n * @returns {util.LongBits} Bits\n */\nLongBits.fromHash = function fromHash(hash) {\n    if (hash === zeroHash)\n        return zero;\n    return new LongBits(\n        ( charCodeAt.call(hash, 0)\n        | charCodeAt.call(hash, 1) << 8\n        | charCodeAt.call(hash, 2) << 16\n        | charCodeAt.call(hash, 3) << 24) >>> 0\n    ,\n        ( charCodeAt.call(hash, 4)\n        | charCodeAt.call(hash, 5) << 8\n        | charCodeAt.call(hash, 6) << 16\n        | charCodeAt.call(hash, 7) << 24) >>> 0\n    );\n};\n\n/**\n * Converts this long bits to a 8 characters long hash.\n * @returns {string} Hash\n */\nLongBits.prototype.toHash = function toHash() {\n    return String.fromCharCode(\n        this.lo        & 255,\n        this.lo >>> 8  & 255,\n        this.lo >>> 16 & 255,\n        this.lo >>> 24      ,\n        this.hi        & 255,\n        this.hi >>> 8  & 255,\n        this.hi >>> 16 & 255,\n        this.hi >>> 24\n    );\n};\n\n/**\n * Zig-zag encodes this long bits.\n * @returns {util.LongBits} `this`\n */\nLongBits.prototype.zzEncode = function zzEncode() {\n    var mask =   this.hi >> 31;\n    this.hi  = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;\n    this.lo  = ( this.lo << 1                   ^ mask) >>> 0;\n    return this;\n};\n\n/**\n * Zig-zag decodes this long bits.\n * @returns {util.LongBits} `this`\n */\nLongBits.prototype.zzDecode = function zzDecode() {\n    var mask = -(this.lo & 1);\n    this.lo  = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;\n    this.hi  = ( this.hi >>> 1                  ^ mask) >>> 0;\n    return this;\n};\n\n/**\n * Calculates the length of this longbits when encoded as a varint.\n * @returns {number} Length\n */\nLongBits.prototype.length = function length() {\n    var part0 =  this.lo,\n        part1 = (this.lo >>> 28 | this.hi << 4) >>> 0,\n        part2 =  this.hi >>> 24;\n    return part2 === 0\n         ? part1 === 0\n           ? part0 < 16384\n             ? part0 < 128 ? 1 : 2\n             : part0 < 2097152 ? 3 : 4\n           : part1 < 16384\n             ? part1 < 128 ? 5 : 6\n             : part1 < 2097152 ? 7 : 8\n         : part2 < 128 ? 9 : 10;\n};\n","\"use strict\";\nvar util = exports;\n\n// used to return a Promise where callback is omitted\nutil.asPromise = require(\"@protobufjs/aspromise\");\n\n// converts to / from base64 encoded strings\nutil.base64 = require(\"@protobufjs/base64\");\n\n// base class of rpc.Service\nutil.EventEmitter = require(\"@protobufjs/eventemitter\");\n\n// float handling accross browsers\nutil.float = require(\"@protobufjs/float\");\n\n// requires modules optionally and hides the call from bundlers\nutil.inquire = require(\"@protobufjs/inquire\");\n\n// converts to / from utf8 encoded strings\nutil.utf8 = require(\"@protobufjs/utf8\");\n\n// provides a node-like buffer pool in the browser\nutil.pool = require(\"@protobufjs/pool\");\n\n// utility to work with the low and high bits of a 64 bit value\nutil.LongBits = require(\"./longbits\");\n\n/**\n * Whether running within node or not.\n * @memberof util\n * @type {boolean}\n */\nutil.isNode = Boolean(typeof global !== \"undefined\"\n                   && global\n                   && global.process\n                   && global.process.versions\n                   && global.process.versions.node);\n\n/**\n * Global object reference.\n * @memberof util\n * @type {Object}\n */\nutil.global = util.isNode && global\n           || typeof window !== \"undefined\" && window\n           || typeof self   !== \"undefined\" && self\n           || this; // eslint-disable-line no-invalid-this\n\n/**\n * An immuable empty array.\n * @memberof util\n * @type {Array.<*>}\n * @const\n */\nutil.emptyArray = Object.freeze ? Object.freeze([]) : /* istanbul ignore next */ []; // used on prototypes\n\n/**\n * An immutable empty object.\n * @type {Object}\n * @const\n */\nutil.emptyObject = Object.freeze ? Object.freeze({}) : /* istanbul ignore next */ {}; // used on prototypes\n\n/**\n * Tests if the specified value is an integer.\n * @function\n * @param {*} value Value to test\n * @returns {boolean} `true` if the value is an integer\n */\nutil.isInteger = Number.isInteger || /* istanbul ignore next */ function isInteger(value) {\n    return typeof value === \"number\" && isFinite(value) && Math.floor(value) === value;\n};\n\n/**\n * Tests if the specified value is a string.\n * @param {*} value Value to test\n * @returns {boolean} `true` if the value is a string\n */\nutil.isString = function isString(value) {\n    return typeof value === \"string\" || value instanceof String;\n};\n\n/**\n * Tests if the specified value is a non-null object.\n * @param {*} value Value to test\n * @returns {boolean} `true` if the value is a non-null object\n */\nutil.isObject = function isObject(value) {\n    return value && typeof value === \"object\";\n};\n\n/**\n * Checks if a property on a message is considered to be present.\n * This is an alias of {@link util.isSet}.\n * @function\n * @param {Object} obj Plain object or message instance\n * @param {string} prop Property name\n * @returns {boolean} `true` if considered to be present, otherwise `false`\n */\nutil.isset =\n\n/**\n * Checks if a property on a message is considered to be present.\n * @param {Object} obj Plain object or message instance\n * @param {string} prop Property name\n * @returns {boolean} `true` if considered to be present, otherwise `false`\n */\nutil.isSet = function isSet(obj, prop) {\n    var value = obj[prop];\n    if (value != null && obj.hasOwnProperty(prop)) // eslint-disable-line eqeqeq, no-prototype-builtins\n        return typeof value !== \"object\" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;\n    return false;\n};\n\n/**\n * Any compatible Buffer instance.\n * This is a minimal stand-alone definition of a Buffer instance. The actual type is that exported by node's typings.\n * @interface Buffer\n * @extends Uint8Array\n */\n\n/**\n * Node's Buffer class if available.\n * @type {Constructor<Buffer>}\n */\nutil.Buffer = (function() {\n    try {\n        var Buffer = util.inquire(\"buffer\").Buffer;\n        // refuse to use non-node buffers if not explicitly assigned (perf reasons):\n        return Buffer.prototype.utf8Write ? Buffer : /* istanbul ignore next */ null;\n    } catch (e) {\n        /* istanbul ignore next */\n        return null;\n    }\n})();\n\n// Internal alias of or polyfull for Buffer.from.\nutil._Buffer_from = null;\n\n// Internal alias of or polyfill for Buffer.allocUnsafe.\nutil._Buffer_allocUnsafe = null;\n\n/**\n * Creates a new buffer of whatever type supported by the environment.\n * @param {number|number[]} [sizeOrArray=0] Buffer size or number array\n * @returns {Uint8Array|Buffer} Buffer\n */\nutil.newBuffer = function newBuffer(sizeOrArray) {\n    /* istanbul ignore next */\n    return typeof sizeOrArray === \"number\"\n        ? util.Buffer\n            ? util._Buffer_allocUnsafe(sizeOrArray)\n            : new util.Array(sizeOrArray)\n        : util.Buffer\n            ? util._Buffer_from(sizeOrArray)\n            : typeof Uint8Array === \"undefined\"\n                ? sizeOrArray\n                : new Uint8Array(sizeOrArray);\n};\n\n/**\n * Array implementation used in the browser. `Uint8Array` if supported, otherwise `Array`.\n * @type {Constructor<Uint8Array>}\n */\nutil.Array = typeof Uint8Array !== \"undefined\" ? Uint8Array /* istanbul ignore next */ : Array;\n\n/**\n * Any compatible Long instance.\n * This is a minimal stand-alone definition of a Long instance. The actual type is that exported by long.js.\n * @interface Long\n * @property {number} low Low bits\n * @property {number} high High bits\n * @property {boolean} unsigned Whether unsigned or not\n */\n\n/**\n * Long.js's Long class if available.\n * @type {Constructor<Long>}\n */\nutil.Long = /* istanbul ignore next */ util.global.dcodeIO && /* istanbul ignore next */ util.global.dcodeIO.Long\n         || /* istanbul ignore next */ util.global.Long\n         || util.inquire(\"long\");\n\n/**\n * Regular expression used to verify 2 bit (`bool`) map keys.\n * @type {RegExp}\n * @const\n */\nutil.key2Re = /^true|false|0|1$/;\n\n/**\n * Regular expression used to verify 32 bit (`int32` etc.) map keys.\n * @type {RegExp}\n * @const\n */\nutil.key32Re = /^-?(?:0|[1-9][0-9]*)$/;\n\n/**\n * Regular expression used to verify 64 bit (`int64` etc.) map keys.\n * @type {RegExp}\n * @const\n */\nutil.key64Re = /^(?:[\\\\x00-\\\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;\n\n/**\n * Converts a number or long to an 8 characters long hash string.\n * @param {Long|number} value Value to convert\n * @returns {string} Hash\n */\nutil.longToHash = function longToHash(value) {\n    return value\n        ? util.LongBits.from(value).toHash()\n        : util.LongBits.zeroHash;\n};\n\n/**\n * Converts an 8 characters long hash string to a long or number.\n * @param {string} hash Hash\n * @param {boolean} [unsigned=false] Whether unsigned or not\n * @returns {Long|number} Original value\n */\nutil.longFromHash = function longFromHash(hash, unsigned) {\n    var bits = util.LongBits.fromHash(hash);\n    if (util.Long)\n        return util.Long.fromBits(bits.lo, bits.hi, unsigned);\n    return bits.toNumber(Boolean(unsigned));\n};\n\n/**\n * Merges the properties of the source object into the destination object.\n * @memberof util\n * @param {Object.<string,*>} dst Destination object\n * @param {Object.<string,*>} src Source object\n * @param {boolean} [ifNotSet=false] Merges only if the key is not already set\n * @returns {Object.<string,*>} Destination object\n */\nfunction merge(dst, src, ifNotSet) { // used by converters\n    for (var keys = Object.keys(src), i = 0; i < keys.length; ++i)\n        if (dst[keys[i]] === undefined || !ifNotSet)\n            dst[keys[i]] = src[keys[i]];\n    return dst;\n}\n\nutil.merge = merge;\n\n/**\n * Converts the first character of a string to lower case.\n * @param {string} str String to convert\n * @returns {string} Converted string\n */\nutil.lcFirst = function lcFirst(str) {\n    return str.charAt(0).toLowerCase() + str.substring(1);\n};\n\n/**\n * Creates a custom error constructor.\n * @memberof util\n * @param {string} name Error name\n * @returns {Constructor<Error>} Custom error constructor\n */\nfunction newError(name) {\n\n    function CustomError(message, properties) {\n\n        if (!(this instanceof CustomError))\n            return new CustomError(message, properties);\n\n        // Error.call(this, message);\n        // ^ just returns a new error instance because the ctor can be called as a function\n\n        Object.defineProperty(this, \"message\", { get: function() { return message; } });\n\n        /* istanbul ignore next */\n        if (Error.captureStackTrace) // node\n            Error.captureStackTrace(this, CustomError);\n        else\n            Object.defineProperty(this, \"stack\", { value: new Error().stack || \"\" });\n\n        if (properties)\n            merge(this, properties);\n    }\n\n    (CustomError.prototype = Object.create(Error.prototype)).constructor = CustomError;\n\n    Object.defineProperty(CustomError.prototype, \"name\", { get: function() { return name; } });\n\n    CustomError.prototype.toString = function toString() {\n        return this.name + \": \" + this.message;\n    };\n\n    return CustomError;\n}\n\nutil.newError = newError;\n\n/**\n * Constructs a new protocol error.\n * @classdesc Error subclass indicating a protocol specifc error.\n * @memberof util\n * @extends Error\n * @template T extends Message<T>\n * @constructor\n * @param {string} message Error message\n * @param {Object.<string,*>} [properties] Additional properties\n * @example\n * try {\n *     MyMessage.decode(someBuffer); // throws if required fields are missing\n * } catch (e) {\n *     if (e instanceof ProtocolError && e.instance)\n *         console.log(\"decoded so far: \" + JSON.stringify(e.instance));\n * }\n */\nutil.ProtocolError = newError(\"ProtocolError\");\n\n/**\n * So far decoded message instance.\n * @name util.ProtocolError#instance\n * @type {Message<T>}\n */\n\n/**\n * A OneOf getter as returned by {@link util.oneOfGetter}.\n * @typedef OneOfGetter\n * @type {function}\n * @returns {string|undefined} Set field name, if any\n */\n\n/**\n * Builds a getter for a oneof's present field name.\n * @param {string[]} fieldNames Field names\n * @returns {OneOfGetter} Unbound getter\n */\nutil.oneOfGetter = function getOneOf(fieldNames) {\n    var fieldMap = {};\n    for (var i = 0; i < fieldNames.length; ++i)\n        fieldMap[fieldNames[i]] = 1;\n\n    /**\n     * @returns {string|undefined} Set field name, if any\n     * @this Object\n     * @ignore\n     */\n    return function() { // eslint-disable-line consistent-return\n        for (var keys = Object.keys(this), i = keys.length - 1; i > -1; --i)\n            if (fieldMap[keys[i]] === 1 && this[keys[i]] !== undefined && this[keys[i]] !== null)\n                return keys[i];\n    };\n};\n\n/**\n * A OneOf setter as returned by {@link util.oneOfSetter}.\n * @typedef OneOfSetter\n * @type {function}\n * @param {string|undefined} value Field name\n * @returns {undefined}\n */\n\n/**\n * Builds a setter for a oneof's present field name.\n * @param {string[]} fieldNames Field names\n * @returns {OneOfSetter} Unbound setter\n */\nutil.oneOfSetter = function setOneOf(fieldNames) {\n\n    /**\n     * @param {string} name Field name\n     * @returns {undefined}\n     * @this Object\n     * @ignore\n     */\n    return function(name) {\n        for (var i = 0; i < fieldNames.length; ++i)\n            if (fieldNames[i] !== name)\n                delete this[fieldNames[i]];\n    };\n};\n\n/**\n * Default conversion options used for {@link Message#toJSON} implementations.\n *\n * These options are close to proto3's JSON mapping with the exception that internal types like Any are handled just like messages. More precisely:\n *\n * - Longs become strings\n * - Enums become string keys\n * - Bytes become base64 encoded strings\n * - (Sub-)Messages become plain objects\n * - Maps become plain objects with all string keys\n * - Repeated fields become arrays\n * - NaN and Infinity for float and double fields become strings\n *\n * @type {IConversionOptions}\n * @see https://developers.google.com/protocol-buffers/docs/proto3?hl=en#json\n */\nutil.toJSONOptions = {\n    longs: String,\n    enums: String,\n    bytes: String,\n    json: true\n};\n\n// Sets up buffer utility according to the environment (called in index-minimal)\nutil._configure = function() {\n    var Buffer = util.Buffer;\n    /* istanbul ignore if */\n    if (!Buffer) {\n        util._Buffer_from = util._Buffer_allocUnsafe = null;\n        return;\n    }\n    // because node 4.x buffers are incompatible & immutable\n    // see: https://github.com/dcodeIO/protobuf.js/pull/665\n    util._Buffer_from = Buffer.from !== Uint8Array.from && Buffer.from ||\n        /* istanbul ignore next */\n        function Buffer_from(value, encoding) {\n            return new Buffer(value, encoding);\n        };\n    util._Buffer_allocUnsafe = Buffer.allocUnsafe ||\n        /* istanbul ignore next */\n        function Buffer_allocUnsafe(size) {\n            return new Buffer(size);\n        };\n};\n","\"use strict\";\nmodule.exports = Writer;\n\nvar util      = require(\"./util/minimal\");\n\nvar BufferWriter; // cyclic\n\nvar LongBits  = util.LongBits,\n    base64    = util.base64,\n    utf8      = util.utf8;\n\n/**\n * Constructs a new writer operation instance.\n * @classdesc Scheduled writer operation.\n * @constructor\n * @param {function(*, Uint8Array, number)} fn Function to call\n * @param {number} len Value byte length\n * @param {*} val Value to write\n * @ignore\n */\nfunction Op(fn, len, val) {\n\n    /**\n     * Function to call.\n     * @type {function(Uint8Array, number, *)}\n     */\n    this.fn = fn;\n\n    /**\n     * Value byte length.\n     * @type {number}\n     */\n    this.len = len;\n\n    /**\n     * Next operation.\n     * @type {Writer.Op|undefined}\n     */\n    this.next = undefined;\n\n    /**\n     * Value to write.\n     * @type {*}\n     */\n    this.val = val; // type varies\n}\n\n/* istanbul ignore next */\nfunction noop() {} // eslint-disable-line no-empty-function\n\n/**\n * Constructs a new writer state instance.\n * @classdesc Copied writer state.\n * @memberof Writer\n * @constructor\n * @param {Writer} writer Writer to copy state from\n * @ignore\n */\nfunction State(writer) {\n\n    /**\n     * Current head.\n     * @type {Writer.Op}\n     */\n    this.head = writer.head;\n\n    /**\n     * Current tail.\n     * @type {Writer.Op}\n     */\n    this.tail = writer.tail;\n\n    /**\n     * Current buffer length.\n     * @type {number}\n     */\n    this.len = writer.len;\n\n    /**\n     * Next state.\n     * @type {State|null}\n     */\n    this.next = writer.states;\n}\n\n/**\n * Constructs a new writer instance.\n * @classdesc Wire format writer using `Uint8Array` if available, otherwise `Array`.\n * @constructor\n */\nfunction Writer() {\n\n    /**\n     * Current length.\n     * @type {number}\n     */\n    this.len = 0;\n\n    /**\n     * Operations head.\n     * @type {Object}\n     */\n    this.head = new Op(noop, 0, 0);\n\n    /**\n     * Operations tail\n     * @type {Object}\n     */\n    this.tail = this.head;\n\n    /**\n     * Linked forked states.\n     * @type {Object|null}\n     */\n    this.states = null;\n\n    // When a value is written, the writer calculates its byte length and puts it into a linked\n    // list of operations to perform when finish() is called. This both allows us to allocate\n    // buffers of the exact required size and reduces the amount of work we have to do compared\n    // to first calculating over objects and then encoding over objects. In our case, the encoding\n    // part is just a linked list walk calling operations with already prepared values.\n}\n\nvar create = function create() {\n    return util.Buffer\n        ? function create_buffer_setup() {\n            return (Writer.create = function create_buffer() {\n                return new BufferWriter();\n            })();\n        }\n        /* istanbul ignore next */\n        : function create_array() {\n            return new Writer();\n        };\n};\n\n/**\n * Creates a new writer.\n * @function\n * @returns {BufferWriter|Writer} A {@link BufferWriter} when Buffers are supported, otherwise a {@link Writer}\n */\nWriter.create = create();\n\n/**\n * Allocates a buffer of the specified size.\n * @param {number} size Buffer size\n * @returns {Uint8Array} Buffer\n */\nWriter.alloc = function alloc(size) {\n    return new util.Array(size);\n};\n\n// Use Uint8Array buffer pool in the browser, just like node does with buffers\n/* istanbul ignore else */\nif (util.Array !== Array)\n    Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);\n\n/**\n * Pushes a new operation to the queue.\n * @param {function(Uint8Array, number, *)} fn Function to call\n * @param {number} len Value byte length\n * @param {number} val Value to write\n * @returns {Writer} `this`\n * @private\n */\nWriter.prototype._push = function push(fn, len, val) {\n    this.tail = this.tail.next = new Op(fn, len, val);\n    this.len += len;\n    return this;\n};\n\nfunction writeByte(val, buf, pos) {\n    buf[pos] = val & 255;\n}\n\nfunction writeVarint32(val, buf, pos) {\n    while (val > 127) {\n        buf[pos++] = val & 127 | 128;\n        val >>>= 7;\n    }\n    buf[pos] = val;\n}\n\n/**\n * Constructs a new varint writer operation instance.\n * @classdesc Scheduled varint writer operation.\n * @extends Op\n * @constructor\n * @param {number} len Value byte length\n * @param {number} val Value to write\n * @ignore\n */\nfunction VarintOp(len, val) {\n    this.len = len;\n    this.next = undefined;\n    this.val = val;\n}\n\nVarintOp.prototype = Object.create(Op.prototype);\nVarintOp.prototype.fn = writeVarint32;\n\n/**\n * Writes an unsigned 32 bit value as a varint.\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.uint32 = function write_uint32(value) {\n    // here, the call to this.push has been inlined and a varint specific Op subclass is used.\n    // uint32 is by far the most frequently used operation and benefits significantly from this.\n    this.len += (this.tail = this.tail.next = new VarintOp(\n        (value = value >>> 0)\n                < 128       ? 1\n        : value < 16384     ? 2\n        : value < 2097152   ? 3\n        : value < 268435456 ? 4\n        :                     5,\n    value)).len;\n    return this;\n};\n\n/**\n * Writes a signed 32 bit value as a varint.\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.int32 = function write_int32(value) {\n    return value < 0\n        ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) // 10 bytes per spec\n        : this.uint32(value);\n};\n\n/**\n * Writes a 32 bit value as a varint, zig-zag encoded.\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.sint32 = function write_sint32(value) {\n    return this.uint32((value << 1 ^ value >> 31) >>> 0);\n};\n\nfunction writeVarint64(val, buf, pos) {\n    while (val.hi) {\n        buf[pos++] = val.lo & 127 | 128;\n        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;\n        val.hi >>>= 7;\n    }\n    while (val.lo > 127) {\n        buf[pos++] = val.lo & 127 | 128;\n        val.lo = val.lo >>> 7;\n    }\n    buf[pos++] = val.lo;\n}\n\n/**\n * Writes an unsigned 64 bit value as a varint.\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.uint64 = function write_uint64(value) {\n    var bits = LongBits.from(value);\n    return this._push(writeVarint64, bits.length(), bits);\n};\n\n/**\n * Writes a signed 64 bit value as a varint.\n * @function\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.int64 = Writer.prototype.uint64;\n\n/**\n * Writes a signed 64 bit value as a varint, zig-zag encoded.\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.sint64 = function write_sint64(value) {\n    var bits = LongBits.from(value).zzEncode();\n    return this._push(writeVarint64, bits.length(), bits);\n};\n\n/**\n * Writes a boolish value as a varint.\n * @param {boolean} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.bool = function write_bool(value) {\n    return this._push(writeByte, 1, value ? 1 : 0);\n};\n\nfunction writeFixed32(val, buf, pos) {\n    buf[pos    ] =  val         & 255;\n    buf[pos + 1] =  val >>> 8   & 255;\n    buf[pos + 2] =  val >>> 16  & 255;\n    buf[pos + 3] =  val >>> 24;\n}\n\n/**\n * Writes an unsigned 32 bit value as fixed 32 bits.\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.fixed32 = function write_fixed32(value) {\n    return this._push(writeFixed32, 4, value >>> 0);\n};\n\n/**\n * Writes a signed 32 bit value as fixed 32 bits.\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.sfixed32 = Writer.prototype.fixed32;\n\n/**\n * Writes an unsigned 64 bit value as fixed 64 bits.\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.fixed64 = function write_fixed64(value) {\n    var bits = LongBits.from(value);\n    return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);\n};\n\n/**\n * Writes a signed 64 bit value as fixed 64 bits.\n * @function\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.sfixed64 = Writer.prototype.fixed64;\n\n/**\n * Writes a float (32 bit).\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.float = function write_float(value) {\n    return this._push(util.float.writeFloatLE, 4, value);\n};\n\n/**\n * Writes a double (64 bit float).\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.double = function write_double(value) {\n    return this._push(util.float.writeDoubleLE, 8, value);\n};\n\nvar writeBytes = util.Array.prototype.set\n    ? function writeBytes_set(val, buf, pos) {\n        buf.set(val, pos); // also works for plain array values\n    }\n    /* istanbul ignore next */\n    : function writeBytes_for(val, buf, pos) {\n        for (var i = 0; i < val.length; ++i)\n            buf[pos + i] = val[i];\n    };\n\n/**\n * Writes a sequence of bytes.\n * @param {Uint8Array|string} value Buffer or base64 encoded string to write\n * @returns {Writer} `this`\n */\nWriter.prototype.bytes = function write_bytes(value) {\n    var len = value.length >>> 0;\n    if (!len)\n        return this._push(writeByte, 1, 0);\n    if (util.isString(value)) {\n        var buf = Writer.alloc(len = base64.length(value));\n        base64.decode(value, buf, 0);\n        value = buf;\n    }\n    return this.uint32(len)._push(writeBytes, len, value);\n};\n\n/**\n * Writes a string.\n * @param {string} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.string = function write_string(value) {\n    var len = utf8.length(value);\n    return len\n        ? this.uint32(len)._push(utf8.write, len, value)\n        : this._push(writeByte, 1, 0);\n};\n\n/**\n * Forks this writer's state by pushing it to a stack.\n * Calling {@link Writer#reset|reset} or {@link Writer#ldelim|ldelim} resets the writer to the previous state.\n * @returns {Writer} `this`\n */\nWriter.prototype.fork = function fork() {\n    this.states = new State(this);\n    this.head = this.tail = new Op(noop, 0, 0);\n    this.len = 0;\n    return this;\n};\n\n/**\n * Resets this instance to the last state.\n * @returns {Writer} `this`\n */\nWriter.prototype.reset = function reset() {\n    if (this.states) {\n        this.head   = this.states.head;\n        this.tail   = this.states.tail;\n        this.len    = this.states.len;\n        this.states = this.states.next;\n    } else {\n        this.head = this.tail = new Op(noop, 0, 0);\n        this.len  = 0;\n    }\n    return this;\n};\n\n/**\n * Resets to the last state and appends the fork state's current write length as a varint followed by its operations.\n * @returns {Writer} `this`\n */\nWriter.prototype.ldelim = function ldelim() {\n    var head = this.head,\n        tail = this.tail,\n        len  = this.len;\n    this.reset().uint32(len);\n    if (len) {\n        this.tail.next = head.next; // skip noop\n        this.tail = tail;\n        this.len += len;\n    }\n    return this;\n};\n\n/**\n * Finishes the write operation.\n * @returns {Uint8Array} Finished buffer\n */\nWriter.prototype.finish = function finish() {\n    var head = this.head.next, // skip noop\n        buf  = this.constructor.alloc(this.len),\n        pos  = 0;\n    while (head) {\n        head.fn(head.val, buf, pos);\n        pos += head.len;\n        head = head.next;\n    }\n    // this.head = this.tail = null;\n    return buf;\n};\n\nWriter._configure = function(BufferWriter_) {\n    BufferWriter = BufferWriter_;\n    Writer.create = create();\n    BufferWriter._configure();\n};\n","\"use strict\";\nmodule.exports = BufferWriter;\n\n// extends Writer\nvar Writer = require(\"./writer\");\n(BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;\n\nvar util = require(\"./util/minimal\");\n\n/**\n * Constructs a new buffer writer instance.\n * @classdesc Wire format writer using node buffers.\n * @extends Writer\n * @constructor\n */\nfunction BufferWriter() {\n    Writer.call(this);\n}\n\nBufferWriter._configure = function () {\n    /**\n     * Allocates a buffer of the specified size.\n     * @function\n     * @param {number} size Buffer size\n     * @returns {Buffer} Buffer\n     */\n    BufferWriter.alloc = util._Buffer_allocUnsafe;\n\n    BufferWriter.writeBytesBuffer = util.Buffer && util.Buffer.prototype instanceof Uint8Array && util.Buffer.prototype.set.name === \"set\"\n        ? function writeBytesBuffer_set(val, buf, pos) {\n          buf.set(val, pos); // faster than copy (requires node >= 4 where Buffers extend Uint8Array and set is properly inherited)\n          // also works for plain array values\n        }\n        /* istanbul ignore next */\n        : function writeBytesBuffer_copy(val, buf, pos) {\n          if (val.copy) // Buffer values\n            val.copy(buf, pos, 0, val.length);\n          else for (var i = 0; i < val.length;) // plain array values\n            buf[pos++] = val[i++];\n        };\n};\n\n\n/**\n * @override\n */\nBufferWriter.prototype.bytes = function write_bytes_buffer(value) {\n    if (util.isString(value))\n        value = util._Buffer_from(value, \"base64\");\n    var len = value.length >>> 0;\n    this.uint32(len);\n    if (len)\n        this._push(BufferWriter.writeBytesBuffer, len, value);\n    return this;\n};\n\nfunction writeStringBuffer(val, buf, pos) {\n    if (val.length < 40) // plain js is faster for short strings (probably due to redundant assertions)\n        util.utf8.write(val, buf, pos);\n    else if (buf.utf8Write)\n        buf.utf8Write(val, pos);\n    else\n        buf.write(val, pos);\n}\n\n/**\n * @override\n */\nBufferWriter.prototype.string = function write_string_buffer(value) {\n    var len = util.Buffer.byteLength(value);\n    this.uint32(len);\n    if (len)\n        this._push(writeStringBuffer, len, value);\n    return this;\n};\n\n\n/**\n * Finishes the write operation.\n * @name BufferWriter#finish\n * @function\n * @returns {Buffer} Finished buffer\n */\n\nBufferWriter._configure();\n","//filter will reemit the data if cb(err,pass) pass is truthy\n\n// reduce is more tricky\n// maybe we want to group the reductions or emit progress updates occasionally\n// the most basic reduce just emits one 'data' event after it has recieved 'end'\n\n\nvar through = require('through')\nvar Decoder = require('string_decoder').StringDecoder\n\nmodule.exports = split\n\n//TODO pass in a function to map across the lines.\n\nfunction split (matcher, mapper, options) {\n  var decoder = new Decoder()\n  var soFar = ''\n  var maxLength = options && options.maxLength;\n  var trailing = options && options.trailing === false ? false : true\n  if('function' === typeof matcher)\n    mapper = matcher, matcher = null\n  if (!matcher)\n    matcher = /\\r?\\n/\n\n  function emit(stream, piece) {\n    if(mapper) {\n      try {\n        piece = mapper(piece)\n      }\n      catch (err) {\n        return stream.emit('error', err)\n      }\n      if('undefined' !== typeof piece)\n        stream.queue(piece)\n    }\n    else\n      stream.queue(piece)\n  }\n\n  function next (stream, buffer) {\n    var pieces = ((soFar != null ? soFar : '') + buffer).split(matcher)\n    soFar = pieces.pop()\n\n    if (maxLength && soFar.length > maxLength)\n      return stream.emit('error', new Error('maximum buffer reached'))\n\n    for (var i = 0; i < pieces.length; i++) {\n      var piece = pieces[i]\n      emit(stream, piece)\n    }\n  }\n\n  return through(function (b) {\n    next(this, decoder.write(b))\n  },\n  function () {\n    if(decoder.end)\n      next(this, decoder.end())\n    if(trailing && soFar != null)\n      emit(this, soFar)\n    this.queue(null)\n  })\n}\n","var Stream = require('stream')\n\n// through\n//\n// a stream that does nothing but re-emit the input.\n// useful for aggregating a series of changing but not ending streams into one stream)\n\nexports = module.exports = through\nthrough.through = through\n\n//create a readable writable stream.\n\nfunction through (write, end, opts) {\n  write = write || function (data) { this.queue(data) }\n  end = end || function () { this.queue(null) }\n\n  var ended = false, destroyed = false, buffer = [], _ended = false\n  var stream = new Stream()\n  stream.readable = stream.writable = true\n  stream.paused = false\n\n//  stream.autoPause   = !(opts && opts.autoPause   === false)\n  stream.autoDestroy = !(opts && opts.autoDestroy === false)\n\n  stream.write = function (data) {\n    write.call(this, data)\n    return !stream.paused\n  }\n\n  function drain() {\n    while(buffer.length && !stream.paused) {\n      var data = buffer.shift()\n      if(null === data)\n        return stream.emit('end')\n      else\n        stream.emit('data', data)\n    }\n  }\n\n  stream.queue = stream.push = function (data) {\n//    console.error(ended)\n    if(_ended) return stream\n    if(data === null) _ended = true\n    buffer.push(data)\n    drain()\n    return stream\n  }\n\n  //this will be registered as the first 'end' listener\n  //must call destroy next tick, to make sure we're after any\n  //stream piped from here.\n  //this is only a problem if end is not emitted synchronously.\n  //a nicer way to do this is to make sure this is the last listener for 'end'\n\n  stream.on('end', function () {\n    stream.readable = false\n    if(!stream.writable && stream.autoDestroy)\n      process.nextTick(function () {\n        stream.destroy()\n      })\n  })\n\n  function _end () {\n    stream.writable = false\n    end.call(stream)\n    if(!stream.readable && stream.autoDestroy)\n      stream.destroy()\n  }\n\n  stream.end = function (data) {\n    if(ended) return\n    ended = true\n    if(arguments.length) stream.write(data)\n    _end() // will emit or queue\n    return stream\n  }\n\n  stream.destroy = function () {\n    if(destroyed) return\n    destroyed = true\n    ended = true\n    buffer.length = 0\n    stream.writable = stream.readable = false\n    stream.emit('close')\n    return stream\n  }\n\n  stream.pause = function () {\n    if(stream.paused) return\n    stream.paused = true\n    return stream\n  }\n\n  stream.resume = function () {\n    if(stream.paused) {\n      stream.paused = false\n      stream.emit('resume')\n    }\n    drain()\n    //may have become paused again,\n    //as drain emits 'data'.\n    if(!stream.paused)\n      stream.emit('drain')\n    return stream\n  }\n  return stream\n}\n\n","class Node {\n\t/// value;\n\t/// next;\n\n\tconstructor(value) {\n\t\tthis.value = value;\n\n\t\t// TODO: Remove this when targeting Node.js 12.\n\t\tthis.next = undefined;\n\t}\n}\n\nclass Queue {\n\t// TODO: Use private class fields when targeting Node.js 12.\n\t// #_head;\n\t// #_tail;\n\t// #_size;\n\n\tconstructor() {\n\t\tthis.clear();\n\t}\n\n\tenqueue(value) {\n\t\tconst node = new Node(value);\n\n\t\tif (this._head) {\n\t\t\tthis._tail.next = node;\n\t\t\tthis._tail = node;\n\t\t} else {\n\t\t\tthis._head = node;\n\t\t\tthis._tail = node;\n\t\t}\n\n\t\tthis._size++;\n\t}\n\n\tdequeue() {\n\t\tconst current = this._head;\n\t\tif (!current) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._head = this._head.next;\n\t\tthis._size--;\n\t\treturn current.value;\n\t}\n\n\tclear() {\n\t\tthis._head = undefined;\n\t\tthis._tail = undefined;\n\t\tthis._size = 0;\n\t}\n\n\tget size() {\n\t\treturn this._size;\n\t}\n\n\t* [Symbol.iterator]() {\n\t\tlet current = this._head;\n\n\t\twhile (current) {\n\t\t\tyield current.value;\n\t\t\tcurrent = current.next;\n\t\t}\n\t}\n}\n\nmodule.exports = Queue;\n","module.exports = require(\"child_process\");","module.exports = require(\"dgram\");","module.exports = require(\"diagnostics_channel\");","module.exports = require(\"dns\");","module.exports = require(\"v8\");"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AAIA;AAOA;AAEA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAFA;AAKA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AADA;AAGA;AACA;AAEA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAGA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAlFA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACrBA;AAEA;AACA;AACA;AAEA;AACA;AACA;AA4DA;AAWA;AAQA;AAAA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AAgBA;AAAA;AACA;AAAA;AAEA;AAAA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA9BA;AAmFA;AAEA;AAEA;AACA;AACA;AAzFA;AAyGA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAzHA;AA0IA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AAtJA;AAwJA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAIA;AACA;AAEA;AACA;AACA;AAHA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AAIA;AACA;AACA;AApLA;AAsLA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAEA;AACA;AACA;AAFA;AAIA;AAAA;AACA;AAAA;AAEA;AACA;AACA;AAFA;AAIA;AACA;AACA;AA1MA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAjCA;AAAA;AAAA;AAmDA;AAEA;AACA;AAtDA;AAAA;AAAA;AAyDA;AACA;AACA;AAFA;AAKA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA5EA;AAAA;AAAA;AA+EA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;AAQA;AAvFA;AAAA;AAAA;AA0FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAPA;AASA;AAnGA;AAAA;AAAA;AA8GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAzHA;AAAA;AAAA;AA8IA;AACA;AACA;AAFA;AAIA;AAlJA;AAAA;AAAA;AAqJA;AACA;AACA;AACA;AACA;AACA;AA1JA;AACA;AADA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACpEA;AAEA;AACA;AACA;AACA;AACA;AAOA;AAAA;AACA;AADA;AACA;AAKA;AAKA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAFA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AAFA;AACA;AAOA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AAKA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAlCA;AAkCA;AACA;AA9CA;AAAA;AAAA;AAgDA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAzDA;AAAA;AAAA;AA2DA;AAAA;AAAA;AACA;AAAA;AACA;AA7DA;AAAA;AAAA;AA8DA;AAAA;AAAA;AACA;AAAA;AACA;AAhEA;AAAA;AAAA;AAiEA;AAAA;AAAA;AACA;AAAA;AACA;AAnEA;AAAA;AAAA;AAoEA;AAAA;AAAA;AACA;AAAA;AACA;AAtEA;AAAA;AAAA;AAuEA;AAAA;AAAA;AACA;AAAA;AACA;AAzEA;AAAA;AAAA;AA4EA;AACA;AA7EA;AAAA;AAAA;AAgFA;AACA;AACA;AACA;AAnFA;AACA;AADA;AAAA;;;;;;;;;;;;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACRA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AChHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACnGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC9GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC1GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC/EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACruCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC5ZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACnZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACjiBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC1GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACzFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AChDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC3CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACzPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACzNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AClFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AChOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC56FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC1MA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AChFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC9FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACrEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AClDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC7CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC3xBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACpJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACpJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC1NA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACVA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACh5MA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACh5MA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACvGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AChMA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC3BA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACLA;AACA;AACA;;;;;;;;;;;;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC1lBA;;;;;;;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AClGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC9IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC18CA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AChDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC3EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACrEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACzDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC9LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC9IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AClIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC7FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACnFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC/CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC3CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC5FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC5BA;AACA;AACA;AACA;;;;;;;;;;;;;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACzKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC5DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACnDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC1IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AClLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AClEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC3EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACpHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC1EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACxGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACrHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC/NA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC7EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACjEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACxDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC/GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC5GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACtGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACrHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC7CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC/CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACjEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AChDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC/CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACrFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACnFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC1HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACzEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACtHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACvFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AChFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACrMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACpCA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACjiBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC/JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC1gBA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC3GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACrUA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC7LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC5DA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC1EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC3MA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACjNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACpEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACzOA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC1NA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACVA;AACA;AACA;AACA;;;;;;;;;;;;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC/QA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACxLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC/DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC1HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC/KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACnFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC5JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACrKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC3DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC5DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACzHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACzDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACxFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AChNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AClIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC9GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACpEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACvHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACrFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACzGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC3MA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AChFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACrDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACTA;AACA;AACA;;;;;;;;;;;;;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AChJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AChBA;;;;;;;;;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACjHA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC3IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC7CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACrHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC9JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AClDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC9PA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACzGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACvRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AClEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AChMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACjEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACnHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AChHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AClFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACnCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACnDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AClLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC7CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACvKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC1MA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AClIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC9IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AChTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC7CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC9CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC9RA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACvKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACnCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACnIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACpEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACjDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AChDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACvEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC1eA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC3DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC3CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACxMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACnCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACvEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC5eA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACrKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACzIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AClKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACxCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC3HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC7CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACvJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACxDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC9IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACpPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACxHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACjIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC1LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACpKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACvEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC3FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACxHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACjfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACxFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACnCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACzDA;AACA;AACA;;;;;;;;;;;;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACxIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACtKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AClbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACtfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC/3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC/FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC9DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC3GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACnCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACvEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC5CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACtGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC9EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC1CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC9MA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AClJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACtEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACnCA;AACA;AACA;AACA;;;;;;;;;;;;;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACnCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC1ZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AClDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACnCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC7IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACvMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACpaA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AChdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACpFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC9DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC3GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACnEA;;;;;;;;;;;;ACAA;;;;;;;;;;;;ACAA;;;;;;;;;;;;ACAA;;;;;;;;;;;;ACAA;;;;A","sourceRoot":""}