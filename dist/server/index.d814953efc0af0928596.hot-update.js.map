{"version":3,"file":"index.d814953efc0af0928596.hot-update.js","sources":["webpack:////Users/opagani/projects/zillowgroup/rentals-js/modules/particles-js-node-logger/src/pinoLogger.ts","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/atob/node-atob.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/base64-js/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/container-info/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/ext/exporters.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/ext/scopes.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/node_modules/find-up/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/node_modules/locate-path/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/node_modules/p-limit/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/node_modules/p-locate/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/node_modules/p-try/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/node_modules/path-exists/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/node_modules/path-type/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/node_modules/pify/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/node_modules/read-pkg-up/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/node_modules/read-pkg/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/node_modules/require-in-the-middle/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/node_modules/source-map/lib/array-set.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/node_modules/source-map/lib/base64-vlq.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/node_modules/source-map/lib/base64.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/node_modules/source-map/lib/binary-search.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/node_modules/source-map/lib/mapping-list.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/node_modules/source-map/lib/read-wasm.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/node_modules/source-map/lib/source-map-consumer.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/node_modules/source-map/lib/source-map-generator.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/node_modules/source-map/lib/source-node.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/node_modules/source-map/lib/util.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/node_modules/source-map/lib/wasm.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/node_modules/source-map/source-map.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-amqp10/src/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-amqplib/src/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/helpers.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/services sync ^\\.\\/.*$","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/services/kinesis.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/services/sns.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/services/sqs.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-bluebird/src/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-bunyan/src/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-cassandra-driver/src/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-couchbase/src/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-dns/src/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-elasticsearch/src/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-fastify/src/fastify.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-fastify/src/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-fs/src/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-generic-pool/src/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-google-cloud-pubsub/src/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-graphql/src/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-grpc/src/client.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-grpc/src/server.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-grpc/src/util.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-hapi/src/server.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-http/src/client.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-http/src/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-http/src/server.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-http2/src/client.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-http2/src/server.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-ioredis/src/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-knex/src/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-koa/src/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-memcached/src/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-microgateway-core/src/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-mongodb-core/src/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-mongodb-core/src/legacy.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-mongodb-core/src/unified.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-mongodb-core/src/util.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-mongoose/src/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-mysql/src/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-mysql2/src/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-net/src/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-paperplane/src/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-pg/src/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-pino/src/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-promise-js/src/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-promise/src/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-q/src/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-redis/src/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-restify/src/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-rhea/src/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-router/src/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-tedious/src/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-when/src/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-winston/src/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/lib/version.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/analytics_sampler.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/config.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/constants.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/encode/0.4.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/encode/0.5.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/encode/notepack.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/exporters/agent/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/exporters/agent/scheduler.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/exporters/agent/writer.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/format.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/histogram.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/id.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/instrumenter.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/log.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/noop/span.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/noop/span_context.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/noop/tracer.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/opentracing/propagation/text_map.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/opentracing/span.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/opentracing/span_context.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/opentracing/tracer.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/platform/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/platform/node sync","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/platform/node sync ^.*\\/.*$","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/platform/node sync ^.*\\/package\\.json$","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/platform/node/agents.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/platform/node/crypto.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/platform/node/dogstatsd.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/platform/node/env.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/platform/node/exporter.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/platform/node/hostname.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/platform/node/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/platform/node/loader.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/platform/node/metrics.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/platform/node/now.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/platform/node/pkg.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/platform/node/profiler.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/platform/node/request.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/platform/node/startup-log.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/platform/node/validate.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/plugins/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/plugins/util/promise.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/plugins/util/redis.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/plugins/util/tx.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/plugins/util/urlfilter.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/plugins/util/web.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/priority_sampler.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/profiling sync","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/profiling/config.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/profiling/encoders/pprof.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/profiling/exporters/agent.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/profiling/exporters/file.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/profiling/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/profiling/mapper.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/profiling/profile.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/profiling/profiler.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/profiling/profilers/inspector/cpu.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/profiling/profilers/inspector/heap.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/profiling/profilers/native/cpu.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/profiling/profilers/native/heap.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/profiling/tagger.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/profiling/util.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/proxy.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/scope/async_hooks.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/scope/async_local_storage.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/scope/async_resource.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/scope/base.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/scope/noop/scope.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/scope/noop/scope_manager.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/scope/scope_manager.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/span_processor.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/tagger.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/tracer.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/util.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/protobuf/profile.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/decode-uri-component/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/graceful-fs/clone.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/graceful-fs/graceful-fs.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/graceful-fs/legacy-streams.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/graceful-fs/polyfills.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/hdr-histogram-js/AbstractHistogram.encoding.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/hdr-histogram-js/AbstractHistogram.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/hdr-histogram-js/AbstractHistogramBase.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/hdr-histogram-js/AbstractHistogramIterator.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/hdr-histogram-js/ByteBuffer.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/hdr-histogram-js/EncodableHistogram.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/hdr-histogram-js/Float64Histogram.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/hdr-histogram-js/HistogramIterationValue.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/hdr-histogram-js/HistogramLogReader.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/hdr-histogram-js/HistogramLogWriter.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/hdr-histogram-js/Int16Histogram.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/hdr-histogram-js/Int32Histogram.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/hdr-histogram-js/Int8Histogram.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/hdr-histogram-js/PackedHistogram.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/hdr-histogram-js/PercentileIterator.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/hdr-histogram-js/RecordedValuesIterator.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/hdr-histogram-js/Recorder.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/hdr-histogram-js/SparseArrayHistogram.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/hdr-histogram-js/ZigZagEncoding.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/hdr-histogram-js/encoding.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/hdr-histogram-js/formatters.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/hdr-histogram-js/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/hdr-histogram-js/packedarray/PackedArray.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/hdr-histogram-js/packedarray/PackedArrayContext.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/hdr-histogram-js/packedarray/ResizeError.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/hdr-histogram-js/ulp.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/json-parse-better-errors/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/load-json-file/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/load-json-file/node_modules/parse-json/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/load-json-file/node_modules/pify/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/load-json-file/node_modules/strip-bom/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/pako/lib/deflate.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/pako/lib/inflate.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/pako/lib/utils/common.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/pako/lib/utils/strings.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/pako/lib/zlib/adler32.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/pako/lib/zlib/constants.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/pako/lib/zlib/crc32.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/pako/lib/zlib/deflate.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/pako/lib/zlib/gzheader.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/pako/lib/zlib/inffast.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/pako/lib/zlib/inflate.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/pako/lib/zlib/inftrees.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/pako/lib/zlib/messages.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/pako/lib/zlib/trees.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/pako/lib/zlib/zstream.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/querystringify/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/requires-port/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/source-map-resolve/index.js","webpack:////Users/opagani/projects/zillowgroup/rentals-js/node_modules/url-parse/index.js","webpack:///external \"child_process\"","webpack:///external \"constants\"","webpack:///external \"inspector\""],"sourcesContent":["import type { GetLoggerInterface, Logger } from '@zg-rentals/particles-js-base-logger';\nimport { BaseLogger } from '@zg-rentals/particles-js-base-logger';\n\nimport child_process from 'child_process';\nimport fs from 'fs';\nimport path from 'path';\nimport pino from 'pino';\nimport stream from 'stream';\n\nexport interface PinoLoggerInterface extends GetLoggerInterface {\n  logPath?: string;\n  prettyPath?: string;\n  pinoArgs?: pino.LoggerOptions;\n}\nexport class PinoLogger extends BaseLogger<pino.Logger> implements Logger {\n  logger: pino.Logger;\n  prettyLogger?: child_process.ChildProcess;\n  _enableLogSync = true;\n  runtime: 'node';\n\n  constructor({\n    pinoArgs = {},\n    logPath = '',\n    prettyPath = 'node_modules/pino-pretty/bin.js',\n    __reset = () => {},\n  }: PinoLoggerInterface = {}) {\n    super({ __reset, runtime: 'node' });\n\n    this.runtime = 'node';\n\n    const cwd = process.cwd();\n    const logThrough = new stream.PassThrough();\n\n    this.logger = pino(\n      {\n        level: 'info',\n        ...pinoArgs,\n      },\n      logThrough,\n    );\n\n    if (logPath) {\n      logThrough.pipe(fs.createWriteStream(logPath, { flags: 'a' }));\n    }\n\n    if (prettyPath) {\n      const prettyLogger = child_process.spawn(process.execPath, [path.join(process.cwd(), prettyPath), '-c'], {\n        cwd,\n        env: process.env,\n      });\n\n      logThrough.pipe(prettyLogger.stdin);\n\n      prettyLogger.stdout.pipe(process.stdout);\n\n      this.prettyLogger = prettyLogger;\n    } else {\n      logThrough.pipe(process.stdout);\n    }\n  }\n\n  child(name: string, bindings?: pino.Bindings): pino.Logger {\n    if (name.length > 255) {\n      throw new Error(`child logger name length is ${name.length}, must be less than 255`);\n    }\n\n    const logger = this.logger.child({ ...bindings, name });\n\n    this._children.set(name, logger);\n\n    return logger;\n  }\n\n  error(...args: Array<unknown>) {\n    this.logger.error(args);\n  }\n  warn(...args: Array<unknown>) {\n    this.logger.warn(args);\n  }\n  info(...args: Array<unknown>) {\n    this.logger.info(args);\n  }\n  debug(...args: Array<unknown>) {\n    this.logger.debug(args);\n  }\n  trace(...args: Array<unknown>) {\n    this.logger.trace(args);\n  }\n\n  _getChildLogger(name: string) {\n    return this._children.get(name);\n  }\n\n  setChildLogLevel(name: string, level?: string) {\n    const logger = this._getChildLogger(name);\n\n    if (logger) logger.level = level || process.env.LOG_LEVEL || 'warn';\n  }\n}\n","\"use strict\";\n\nfunction atob(str) {\n  return Buffer.from(str, 'base64').toString('binary');\n}\n\nmodule.exports = atob.atob = atob;\n","'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n","'use strict'\n\nconst fs = require('fs')\n\nconst uuidSource = '[0-9a-f]{8}[-_][0-9a-f]{4}[-_][0-9a-f]{4}[-_][0-9a-f]{4}[-_][0-9a-f]{12}'\nconst containerSource = '[0-9a-f]{64}'\nconst taskSource = '[0-9a-f]{32}'\n\nconst lineReg = /^(\\d+):([^:]*):(.+)$/\nconst podReg = new RegExp(`pod(${uuidSource})(?:.slice)?$`)\nconst containerReg = new RegExp(`(${uuidSource}|${containerSource})(?:.scope)?$`)\nconst taskReg = new RegExp(`^/ecs/(${taskSource})/.*$`)\n\nconst ecsMetadataFile = process.env.ECS_CONTAINER_METADATA_FILE\nconst ecsMetadata = ecsMetadataSync()\n\nfunction parseLine (line) {\n  const [ id, groups, path ] = (line.match(lineReg) || []).slice(1)\n  const data = { id, groups, path }\n  const parts = path.split('/')\n\n  const controllers = groups.split(',')\n  if (controllers) data.controllers = controllers\n\n  const containerId = (parts.pop().match(containerReg) || [])[1]\n  if (containerId) data.containerId = containerId\n\n  const podId = (parts.pop().match(podReg) || [])[1]\n  if (podId) data.podId = podId\n\n  const taskId = (path.match(taskReg) || [])[1]\n  if (taskId) data.taskId = taskId\n\n  return data\n}\n\nfunction parse (contents) {\n  const data = {\n    entries: []\n  }\n\n  for (let line of contents.split('\\n')) {\n    line = line.trim()\n    if (line) {\n      const lineData = parseLine(line)\n      data.entries.push(lineData)\n      if (lineData.containerId) {\n        data.containerId = lineData.containerId\n      }\n      if (lineData.podId) {\n        data.podId = lineData.podId\n      }\n      if (lineData.taskId) {\n        data.taskId = lineData.taskId\n        if (ecsMetadata) {\n          data.containerId = ecsMetadata.ContainerID\n        }\n      }\n    }\n  }\n\n  return data\n}\n\nfunction containerInfo (pid = 'self') {\n  return new Promise((resolve) => {\n    fs.readFile(`/proc/${pid}/cgroup`, (err, data) => {\n      resolve(err ? undefined : parse(data.toString()))\n    })\n  })\n}\n\nfunction containerInfoSync (pid = 'self') {\n  try {\n    const data = fs.readFileSync(`/proc/${pid}/cgroup`)\n    return parse(data.toString())\n  } catch (err) {}\n}\n\nfunction ecsMetadataSync () {\n  try {\n    return ecsMetadataFile && JSON.parse(fs.readFileSync(ecsMetadataFile))\n  } catch (err) {}\n}\n\nmodule.exports = containerInfo\ncontainerInfo.sync = containerInfoSync\ncontainerInfo.parse = parse\n","'use strict'\nmodule.exports = {\n  LOG: 'log',\n  BROWSER: 'browser',\n  AGENT: 'agent'\n}\n","'use strict'\n\nmodule.exports = {\n  ASYNC_RESOURCE: 'async_resource',\n  ASYNC_LOCAL_STORAGE: 'async_local_storage',\n  ASYNC_HOOKS: 'async_hooks',\n  NOOP: 'noop'\n}\n","'use strict';\nconst path = require('path');\nconst locatePath = require('locate-path');\n\nmodule.exports = (filename, opts) => {\n\topts = opts || {};\n\n\tconst startDir = path.resolve(opts.cwd || '');\n\tconst root = path.parse(startDir).root;\n\n\tconst filenames = [].concat(filename);\n\n\treturn new Promise(resolve => {\n\t\t(function find(dir) {\n\t\t\tlocatePath(filenames, {cwd: dir}).then(file => {\n\t\t\t\tif (file) {\n\t\t\t\t\tresolve(path.join(dir, file));\n\t\t\t\t} else if (dir === root) {\n\t\t\t\t\tresolve(null);\n\t\t\t\t} else {\n\t\t\t\t\tfind(path.dirname(dir));\n\t\t\t\t}\n\t\t\t});\n\t\t})(startDir);\n\t});\n};\n\nmodule.exports.sync = (filename, opts) => {\n\topts = opts || {};\n\n\tlet dir = path.resolve(opts.cwd || '');\n\tconst root = path.parse(dir).root;\n\n\tconst filenames = [].concat(filename);\n\n\t// eslint-disable-next-line no-constant-condition\n\twhile (true) {\n\t\tconst file = locatePath.sync(filenames, {cwd: dir});\n\n\t\tif (file) {\n\t\t\treturn path.join(dir, file);\n\t\t} else if (dir === root) {\n\t\t\treturn null;\n\t\t}\n\n\t\tdir = path.dirname(dir);\n\t}\n};\n","'use strict';\nconst path = require('path');\nconst pathExists = require('path-exists');\nconst pLocate = require('p-locate');\n\nmodule.exports = (iterable, opts) => {\n\topts = Object.assign({\n\t\tcwd: process.cwd()\n\t}, opts);\n\n\treturn pLocate(iterable, el => pathExists(path.resolve(opts.cwd, el)), opts);\n};\n\nmodule.exports.sync = (iterable, opts) => {\n\topts = Object.assign({\n\t\tcwd: process.cwd()\n\t}, opts);\n\n\tfor (const el of iterable) {\n\t\tif (pathExists.sync(path.resolve(opts.cwd, el))) {\n\t\t\treturn el;\n\t\t}\n\t}\n};\n","'use strict';\nconst pTry = require('p-try');\n\nmodule.exports = concurrency => {\n\tif (concurrency < 1) {\n\t\tthrow new TypeError('Expected `concurrency` to be a number from 1 and up');\n\t}\n\n\tconst queue = [];\n\tlet activeCount = 0;\n\n\tconst next = () => {\n\t\tactiveCount--;\n\n\t\tif (queue.length > 0) {\n\t\t\tqueue.shift()();\n\t\t}\n\t};\n\n\treturn fn => new Promise((resolve, reject) => {\n\t\tconst run = () => {\n\t\t\tactiveCount++;\n\n\t\t\tpTry(fn).then(\n\t\t\t\tval => {\n\t\t\t\t\tresolve(val);\n\t\t\t\t\tnext();\n\t\t\t\t},\n\t\t\t\terr => {\n\t\t\t\t\treject(err);\n\t\t\t\t\tnext();\n\t\t\t\t}\n\t\t\t);\n\t\t};\n\n\t\tif (activeCount < concurrency) {\n\t\t\trun();\n\t\t} else {\n\t\t\tqueue.push(run);\n\t\t}\n\t});\n};\n","'use strict';\nconst pLimit = require('p-limit');\n\nclass EndError extends Error {\n\tconstructor(value) {\n\t\tsuper();\n\t\tthis.value = value;\n\t}\n}\n\n// the input can also be a promise, so we `Promise.all()` them both\nconst finder = el => Promise.all(el).then(val => val[1] === true && Promise.reject(new EndError(val[0])));\n\nmodule.exports = (iterable, tester, opts) => {\n\topts = Object.assign({\n\t\tconcurrency: Infinity,\n\t\tpreserveOrder: true\n\t}, opts);\n\n\tconst limit = pLimit(opts.concurrency);\n\n\t// start all the promises concurrently with optional limit\n\tconst items = Array.from(iterable).map(el => [el, limit(() => Promise.resolve(el).then(tester))]);\n\n\t// check the promises either serially or concurrently\n\tconst checkLimit = pLimit(opts.preserveOrder ? 1 : Infinity);\n\n\treturn Promise.all(items.map(el => checkLimit(() => finder(el))))\n\t\t.then(() => {})\n\t\t.catch(err => err instanceof EndError ? err.value : Promise.reject(err));\n};\n","'use strict';\nmodule.exports = cb => new Promise(resolve => {\n\tresolve(cb());\n});\n","'use strict';\nconst fs = require('fs');\n\nmodule.exports = fp => new Promise(resolve => {\n\tfs.access(fp, err => {\n\t\tresolve(!err);\n\t});\n});\n\nmodule.exports.sync = fp => {\n\ttry {\n\t\tfs.accessSync(fp);\n\t\treturn true;\n\t} catch (err) {\n\t\treturn false;\n\t}\n};\n","'use strict';\nconst fs = require('fs');\nconst pify = require('pify');\n\nfunction type(fn, fn2, fp) {\n\tif (typeof fp !== 'string') {\n\t\treturn Promise.reject(new TypeError(`Expected a string, got ${typeof fp}`));\n\t}\n\n\treturn pify(fs[fn])(fp)\n\t\t.then(stats => stats[fn2]())\n\t\t.catch(err => {\n\t\t\tif (err.code === 'ENOENT') {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tthrow err;\n\t\t});\n}\n\nfunction typeSync(fn, fn2, fp) {\n\tif (typeof fp !== 'string') {\n\t\tthrow new TypeError(`Expected a string, got ${typeof fp}`);\n\t}\n\n\ttry {\n\t\treturn fs[fn](fp)[fn2]();\n\t} catch (err) {\n\t\tif (err.code === 'ENOENT') {\n\t\t\treturn false;\n\t\t}\n\n\t\tthrow err;\n\t}\n}\n\nexports.file = type.bind(null, 'stat', 'isFile');\nexports.dir = type.bind(null, 'stat', 'isDirectory');\nexports.symlink = type.bind(null, 'lstat', 'isSymbolicLink');\nexports.fileSync = typeSync.bind(null, 'statSync', 'isFile');\nexports.dirSync = typeSync.bind(null, 'statSync', 'isDirectory');\nexports.symlinkSync = typeSync.bind(null, 'lstatSync', 'isSymbolicLink');\n","'use strict';\n\nconst processFn = (fn, opts) => function () {\n\tconst P = opts.promiseModule;\n\tconst args = new Array(arguments.length);\n\n\tfor (let i = 0; i < arguments.length; i++) {\n\t\targs[i] = arguments[i];\n\t}\n\n\treturn new P((resolve, reject) => {\n\t\tif (opts.errorFirst) {\n\t\t\targs.push(function (err, result) {\n\t\t\t\tif (opts.multiArgs) {\n\t\t\t\t\tconst results = new Array(arguments.length - 1);\n\n\t\t\t\t\tfor (let i = 1; i < arguments.length; i++) {\n\t\t\t\t\t\tresults[i - 1] = arguments[i];\n\t\t\t\t\t}\n\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\tresults.unshift(err);\n\t\t\t\t\t\treject(results);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresolve(results);\n\t\t\t\t\t}\n\t\t\t\t} else if (err) {\n\t\t\t\t\treject(err);\n\t\t\t\t} else {\n\t\t\t\t\tresolve(result);\n\t\t\t\t}\n\t\t\t});\n\t\t} else {\n\t\t\targs.push(function (result) {\n\t\t\t\tif (opts.multiArgs) {\n\t\t\t\t\tconst results = new Array(arguments.length - 1);\n\n\t\t\t\t\tfor (let i = 0; i < arguments.length; i++) {\n\t\t\t\t\t\tresults[i] = arguments[i];\n\t\t\t\t\t}\n\n\t\t\t\t\tresolve(results);\n\t\t\t\t} else {\n\t\t\t\t\tresolve(result);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tfn.apply(this, args);\n\t});\n};\n\nmodule.exports = (obj, opts) => {\n\topts = Object.assign({\n\t\texclude: [/.+(Sync|Stream)$/],\n\t\terrorFirst: true,\n\t\tpromiseModule: Promise\n\t}, opts);\n\n\tconst filter = key => {\n\t\tconst match = pattern => typeof pattern === 'string' ? key === pattern : pattern.test(key);\n\t\treturn opts.include ? opts.include.some(match) : !opts.exclude.some(match);\n\t};\n\n\tlet ret;\n\tif (typeof obj === 'function') {\n\t\tret = function () {\n\t\t\tif (opts.excludeMain) {\n\t\t\t\treturn obj.apply(this, arguments);\n\t\t\t}\n\n\t\t\treturn processFn(obj, opts).apply(this, arguments);\n\t\t};\n\t} else {\n\t\tret = Object.create(Object.getPrototypeOf(obj));\n\t}\n\n\tfor (const key in obj) { // eslint-disable-line guard-for-in\n\t\tconst x = obj[key];\n\t\tret[key] = typeof x === 'function' && filter(key) ? processFn(x, opts) : x;\n\t}\n\n\treturn ret;\n};\n","'use strict';\nconst findUp = require('find-up');\nconst readPkg = require('read-pkg');\n\nmodule.exports = opts => {\n\treturn findUp('package.json', opts).then(fp => {\n\t\tif (!fp) {\n\t\t\treturn {};\n\t\t}\n\n\t\treturn readPkg(fp, opts).then(pkg => ({pkg, path: fp}));\n\t});\n};\n\nmodule.exports.sync = opts => {\n\tconst fp = findUp.sync('package.json', opts);\n\n\tif (!fp) {\n\t\treturn {};\n\t}\n\n\treturn {\n\t\tpkg: readPkg.sync(fp, opts),\n\t\tpath: fp\n\t};\n};\n","'use strict';\nconst path = require('path');\nconst loadJsonFile = require('load-json-file');\nconst pathType = require('path-type');\n\nmodule.exports = (fp, opts) => {\n\tif (typeof fp !== 'string') {\n\t\topts = fp;\n\t\tfp = '.';\n\t}\n\n\topts = opts || {};\n\n\treturn pathType.dir(fp)\n\t\t.then(isDir => {\n\t\t\tif (isDir) {\n\t\t\t\tfp = path.join(fp, 'package.json');\n\t\t\t}\n\n\t\t\treturn loadJsonFile(fp);\n\t\t})\n\t\t.then(x => {\n\t\t\tif (opts.normalize !== false) {\n\t\t\t\trequire('normalize-package-data')(x);\n\t\t\t}\n\n\t\t\treturn x;\n\t\t});\n};\n\nmodule.exports.sync = (fp, opts) => {\n\tif (typeof fp !== 'string') {\n\t\topts = fp;\n\t\tfp = '.';\n\t}\n\n\topts = opts || {};\n\tfp = pathType.dirSync(fp) ? path.join(fp, 'package.json') : fp;\n\n\tconst x = loadJsonFile.sync(fp);\n\n\tif (opts.normalize !== false) {\n\t\trequire('normalize-package-data')(x);\n\t}\n\n\treturn x;\n};\n","'use strict'\n\nvar path = require('path')\nvar Module = require('module')\nvar resolve = require('resolve')\nvar parse = require('module-details-from-path')\n\nvar orig = Module.prototype.require\n\nmodule.exports = function hook (modules, options, onrequire) {\n  if (typeof modules === 'function') return hook(null, {}, modules)\n  if (typeof options === 'function') return hook(modules, {}, options)\n\n  if (typeof Module._resolveFilename !== 'function') {\n    console.error('Error: Expected Module._resolveFilename to be a function (was: %s) - aborting!', typeof Module._resolveFilename)\n    console.error('Please report this error as an issue related to Node.js %s at %s', process.version, require('./package.json').bugs.url)\n    return\n  }\n\n  options = options || {}\n\n  hook.cache = {}\n\n  var patching = {}\n\n  Module.prototype.require = function (request) {\n    var filename = Module._resolveFilename(request, this)\n    var core = filename.indexOf(path.sep) === -1\n    var name, basedir\n\n    // return known patched modules immediately\n    if (hook.cache.hasOwnProperty(filename)) {\n      return hook.cache[filename]\n    }\n\n    // Check if this module has a patcher in-progress already.\n    // Otherwise, mark this module as patching in-progress.\n    var patched = patching[filename]\n    if (!patched) {\n      patching[filename] = true\n    }\n\n    var exports = orig.apply(this, arguments)\n\n    // If it's already patched, just return it as-is.\n    if (patched) return exports\n\n    // The module has already been loaded,\n    // so the patching mark can be cleaned up.\n    delete patching[filename]\n\n    if (core) {\n      if (modules && modules.indexOf(filename) === -1) return exports // abort if module name isn't on whitelist\n      name = filename\n    } else {\n      var stat = parse(filename)\n      if (!stat) return exports // abort if filename could not be parsed\n      name = stat.name\n      basedir = stat.basedir\n\n      if (modules && modules.indexOf(name) === -1) return exports // abort if module name isn't on whitelist\n\n      // figure out if this is the main module file, or a file inside the module\n      try {\n        var res = resolve.sync(name, { basedir: basedir })\n      } catch (e) {\n        return exports // abort if module could not be resolved (e.g. no main in package.json and no index.js file)\n      }\n      if (res !== filename) {\n        // this is a module-internal file\n        if (options.internals) {\n          // use the module-relative path to the file, prefixed by original module name\n          name = name + path.sep + path.relative(basedir, filename)\n        } else return exports // abort if not main module file\n      }\n    }\n\n    // only call onrequire the first time a module is loaded\n    if (!hook.cache.hasOwnProperty(filename)) {\n      // ensure that the cache entry is assigned a value before calling\n      // onrequire, in case calling onrequire requires the same module.\n      hook.cache[filename] = exports\n      hook.cache[filename] = onrequire(exports, name, basedir)\n    }\n\n    return hook.cache[filename]\n  }\n}\n","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\n/**\n * A data structure which is a combination of an array and a set. Adding a new\n * member is O(1), testing for membership is O(1), and finding the index of an\n * element is O(1). Removing elements from the set is not supported. Only\n * strings are supported for membership.\n */\nclass ArraySet {\n  constructor() {\n    this._array = [];\n    this._set = new Map();\n  }\n\n  /**\n   * Static method for creating ArraySet instances from an existing array.\n   */\n  static fromArray(aArray, aAllowDuplicates) {\n    const set = new ArraySet();\n    for (let i = 0, len = aArray.length; i < len; i++) {\n      set.add(aArray[i], aAllowDuplicates);\n    }\n    return set;\n  }\n\n  /**\n   * Return how many unique items are in this ArraySet. If duplicates have been\n   * added, than those do not count towards the size.\n   *\n   * @returns Number\n   */\n  size() {\n    return this._set.size;\n  }\n\n  /**\n   * Add the given string to this set.\n   *\n   * @param String aStr\n   */\n  add(aStr, aAllowDuplicates) {\n    const isDuplicate = this.has(aStr);\n    const idx = this._array.length;\n    if (!isDuplicate || aAllowDuplicates) {\n      this._array.push(aStr);\n    }\n    if (!isDuplicate) {\n      this._set.set(aStr, idx);\n    }\n  }\n\n  /**\n   * Is the given string a member of this set?\n   *\n   * @param String aStr\n   */\n  has(aStr) {\n      return this._set.has(aStr);\n  }\n\n  /**\n   * What is the index of the given string in the array?\n   *\n   * @param String aStr\n   */\n  indexOf(aStr) {\n    const idx = this._set.get(aStr);\n    if (idx >= 0) {\n        return idx;\n    }\n    throw new Error('\"' + aStr + '\" is not in the set.');\n  }\n\n  /**\n   * What is the element at the given index?\n   *\n   * @param Number aIdx\n   */\n  at(aIdx) {\n    if (aIdx >= 0 && aIdx < this._array.length) {\n      return this._array[aIdx];\n    }\n    throw new Error(\"No element indexed by \" + aIdx);\n  }\n\n  /**\n   * Returns the array representation of this set (which has the proper indices\n   * indicated by indexOf). Note that this is a copy of the internal array used\n   * for storing the members so that no one can mess with internal state.\n   */\n  toArray() {\n    return this._array.slice();\n  }\n}\nexports.ArraySet = ArraySet;\n","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n *\n * Based on the Base 64 VLQ implementation in Closure Compiler:\n * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java\n *\n * Copyright 2011 The Closure Compiler Authors. All rights reserved.\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *  * Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above\n *    copyright notice, this list of conditions and the following\n *    disclaimer in the documentation and/or other materials provided\n *    with the distribution.\n *  * Neither the name of Google Inc. nor the names of its\n *    contributors may be used to endorse or promote products derived\n *    from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\nconst base64 = require(\"./base64\");\n\n// A single base 64 digit can contain 6 bits of data. For the base 64 variable\n// length quantities we use in the source map spec, the first bit is the sign,\n// the next four bits are the actual value, and the 6th bit is the\n// continuation bit. The continuation bit tells us whether there are more\n// digits in this value following this digit.\n//\n//   Continuation\n//   |    Sign\n//   |    |\n//   V    V\n//   101011\n\nconst VLQ_BASE_SHIFT = 5;\n\n// binary: 100000\nconst VLQ_BASE = 1 << VLQ_BASE_SHIFT;\n\n// binary: 011111\nconst VLQ_BASE_MASK = VLQ_BASE - 1;\n\n// binary: 100000\nconst VLQ_CONTINUATION_BIT = VLQ_BASE;\n\n/**\n * Converts from a two-complement value to a value where the sign bit is\n * placed in the least significant bit.  For example, as decimals:\n *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)\n *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)\n */\nfunction toVLQSigned(aValue) {\n  return aValue < 0\n    ? ((-aValue) << 1) + 1\n    : (aValue << 1) + 0;\n}\n\n/**\n * Converts to a two-complement value from a value where the sign bit is\n * placed in the least significant bit.  For example, as decimals:\n *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1\n *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2\n */\n// eslint-disable-next-line no-unused-vars\nfunction fromVLQSigned(aValue) {\n  const isNegative = (aValue & 1) === 1;\n  const shifted = aValue >> 1;\n  return isNegative\n    ? -shifted\n    : shifted;\n}\n\n/**\n * Returns the base 64 VLQ encoded value.\n */\nexports.encode = function base64VLQ_encode(aValue) {\n  let encoded = \"\";\n  let digit;\n\n  let vlq = toVLQSigned(aValue);\n\n  do {\n    digit = vlq & VLQ_BASE_MASK;\n    vlq >>>= VLQ_BASE_SHIFT;\n    if (vlq > 0) {\n      // There are still more digits in this value, so we must make sure the\n      // continuation bit is marked.\n      digit |= VLQ_CONTINUATION_BIT;\n    }\n    encoded += base64.encode(digit);\n  } while (vlq > 0);\n\n  return encoded;\n};\n","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nconst intToCharMap = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\".split(\"\");\n\n/**\n * Encode an integer in the range of 0 to 63 to a single base 64 digit.\n */\nexports.encode = function(number) {\n  if (0 <= number && number < intToCharMap.length) {\n    return intToCharMap[number];\n  }\n  throw new TypeError(\"Must be between 0 and 63: \" + number);\n};\n","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nexports.GREATEST_LOWER_BOUND = 1;\nexports.LEAST_UPPER_BOUND = 2;\n\n/**\n * Recursive implementation of binary search.\n *\n * @param aLow Indices here and lower do not contain the needle.\n * @param aHigh Indices here and higher do not contain the needle.\n * @param aNeedle The element being searched for.\n * @param aHaystack The non-empty array being searched.\n * @param aCompare Function which takes two elements and returns -1, 0, or 1.\n * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or\n *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the\n *     closest element that is smaller than or greater than the one we are\n *     searching for, respectively, if the exact element cannot be found.\n */\nfunction recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {\n  // This function terminates when one of the following is true:\n  //\n  //   1. We find the exact element we are looking for.\n  //\n  //   2. We did not find the exact element, but we can return the index of\n  //      the next-closest element.\n  //\n  //   3. We did not find the exact element, and there is no next-closest\n  //      element than the one we are searching for, so we return -1.\n  const mid = Math.floor((aHigh - aLow) / 2) + aLow;\n  const cmp = aCompare(aNeedle, aHaystack[mid], true);\n  if (cmp === 0) {\n    // Found the element we are looking for.\n    return mid;\n  } else if (cmp > 0) {\n    // Our needle is greater than aHaystack[mid].\n    if (aHigh - mid > 1) {\n      // The element is in the upper half.\n      return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);\n    }\n\n    // The exact needle element was not found in this haystack. Determine if\n    // we are in termination case (3) or (2) and return the appropriate thing.\n    if (aBias == exports.LEAST_UPPER_BOUND) {\n      return aHigh < aHaystack.length ? aHigh : -1;\n    }\n    return mid;\n  }\n\n  // Our needle is less than aHaystack[mid].\n  if (mid - aLow > 1) {\n    // The element is in the lower half.\n    return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);\n  }\n\n  // we are in termination case (3) or (2) and return the appropriate thing.\n  if (aBias == exports.LEAST_UPPER_BOUND) {\n    return mid;\n  }\n  return aLow < 0 ? -1 : aLow;\n}\n\n/**\n * This is an implementation of binary search which will always try and return\n * the index of the closest element if there is no exact hit. This is because\n * mappings between original and generated line/col pairs are single points,\n * and there is an implicit region between each of them, so a miss just means\n * that you aren't on the very start of a region.\n *\n * @param aNeedle The element you are looking for.\n * @param aHaystack The array that is being searched.\n * @param aCompare A function which takes the needle and an element in the\n *     array and returns -1, 0, or 1 depending on whether the needle is less\n *     than, equal to, or greater than the element, respectively.\n * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or\n *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the\n *     closest element that is smaller than or greater than the one we are\n *     searching for, respectively, if the exact element cannot be found.\n *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.\n */\nexports.search = function search(aNeedle, aHaystack, aCompare, aBias) {\n  if (aHaystack.length === 0) {\n    return -1;\n  }\n\n  let index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack,\n                              aCompare, aBias || exports.GREATEST_LOWER_BOUND);\n  if (index < 0) {\n    return -1;\n  }\n\n  // We have found either the exact element, or the next-closest element than\n  // the one we are searching for. However, there may be more than one such\n  // element. Make sure we always return the smallest of these.\n  while (index - 1 >= 0) {\n    if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {\n      break;\n    }\n    --index;\n  }\n\n  return index;\n};\n","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2014 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nconst util = require(\"./util\");\n\n/**\n * Determine whether mappingB is after mappingA with respect to generated\n * position.\n */\nfunction generatedPositionAfter(mappingA, mappingB) {\n  // Optimized for most common case\n  const lineA = mappingA.generatedLine;\n  const lineB = mappingB.generatedLine;\n  const columnA = mappingA.generatedColumn;\n  const columnB = mappingB.generatedColumn;\n  return lineB > lineA || lineB == lineA && columnB >= columnA ||\n         util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;\n}\n\n/**\n * A data structure to provide a sorted view of accumulated mappings in a\n * performance conscious manner. It trades a negligible overhead in general\n * case for a large speedup in case of mappings being added in order.\n */\nclass MappingList {\n  constructor() {\n    this._array = [];\n    this._sorted = true;\n    // Serves as infimum\n    this._last = {generatedLine: -1, generatedColumn: 0};\n  }\n\n  /**\n   * Iterate through internal items. This method takes the same arguments that\n   * `Array.prototype.forEach` takes.\n   *\n   * NOTE: The order of the mappings is NOT guaranteed.\n   */\n  unsortedForEach(aCallback, aThisArg) {\n    this._array.forEach(aCallback, aThisArg);\n  }\n\n  /**\n   * Add the given source mapping.\n   *\n   * @param Object aMapping\n   */\n  add(aMapping) {\n    if (generatedPositionAfter(this._last, aMapping)) {\n      this._last = aMapping;\n      this._array.push(aMapping);\n    } else {\n      this._sorted = false;\n      this._array.push(aMapping);\n    }\n  }\n\n  /**\n   * Returns the flat, sorted array of mappings. The mappings are sorted by\n   * generated position.\n   *\n   * WARNING: This method returns internal data without copying, for\n   * performance. The return value must NOT be mutated, and should be treated as\n   * an immutable borrow. If you want to take ownership, you must make your own\n   * copy.\n   */\n  toArray() {\n    if (!this._sorted) {\n      this._array.sort(util.compareByGeneratedPositionsInflated);\n      this._sorted = true;\n    }\n    return this._array;\n  }\n}\n\nexports.MappingList = MappingList;\n","if (typeof fetch === \"function\") {\n  // Web version of reading a wasm file into an array buffer.\n\n  let mappingsWasmUrl = null;\n\n  module.exports = function readWasm() {\n    if (typeof mappingsWasmUrl !== \"string\") {\n      throw new Error(\"You must provide the URL of lib/mappings.wasm by calling \" +\n                      \"SourceMapConsumer.initialize({ 'lib/mappings.wasm': ... }) \" +\n                      \"before using SourceMapConsumer\");\n    }\n\n    return fetch(mappingsWasmUrl)\n      .then(response => response.arrayBuffer());\n  };\n\n  module.exports.initialize = url => mappingsWasmUrl = url;\n} else {\n  // Node version of reading a wasm file into an array buffer.\n  const fs = require(\"fs\");\n  const path = require(\"path\");\n\n  module.exports = function readWasm() {\n    return new Promise((resolve, reject) => {\n      const wasmPath = path.join(__dirname, \"mappings.wasm\");\n      fs.readFile(wasmPath, null, (error, data) => {\n        if (error) {\n          reject(error);\n          return;\n        }\n\n        resolve(data.buffer);\n      });\n    });\n  };\n\n  module.exports.initialize = _ => {\n    console.debug(\"SourceMapConsumer.initialize is a no-op when running in node.js\");\n  };\n}\n","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nconst util = require(\"./util\");\nconst binarySearch = require(\"./binary-search\");\nconst ArraySet = require(\"./array-set\").ArraySet;\nconst base64VLQ = require(\"./base64-vlq\"); // eslint-disable-line no-unused-vars\nconst readWasm = require(\"../lib/read-wasm\");\nconst wasm = require(\"./wasm\");\n\nconst INTERNAL = Symbol(\"smcInternal\");\n\nclass SourceMapConsumer {\n  constructor(aSourceMap, aSourceMapURL) {\n    // If the constructor was called by super(), just return Promise<this>.\n    // Yes, this is a hack to retain the pre-existing API of the base-class\n    // constructor also being an async factory function.\n    if (aSourceMap == INTERNAL) {\n      return Promise.resolve(this);\n    }\n\n    return _factory(aSourceMap, aSourceMapURL);\n  }\n\n  static initialize(opts) {\n    readWasm.initialize(opts[\"lib/mappings.wasm\"]);\n  }\n\n  static fromSourceMap(aSourceMap, aSourceMapURL) {\n    return _factoryBSM(aSourceMap, aSourceMapURL);\n  }\n\n  /**\n   * Construct a new `SourceMapConsumer` from `rawSourceMap` and `sourceMapUrl`\n   * (see the `SourceMapConsumer` constructor for details. Then, invoke the `async\n   * function f(SourceMapConsumer) -> T` with the newly constructed consumer, wait\n   * for `f` to complete, call `destroy` on the consumer, and return `f`'s return\n   * value.\n   *\n   * You must not use the consumer after `f` completes!\n   *\n   * By using `with`, you do not have to remember to manually call `destroy` on\n   * the consumer, since it will be called automatically once `f` completes.\n   *\n   * ```js\n   * const xSquared = await SourceMapConsumer.with(\n   *   myRawSourceMap,\n   *   null,\n   *   async function (consumer) {\n   *     // Use `consumer` inside here and don't worry about remembering\n   *     // to call `destroy`.\n   *\n   *     const x = await whatever(consumer);\n   *     return x * x;\n   *   }\n   * );\n   *\n   * // You may not use that `consumer` anymore out here; it has\n   * // been destroyed. But you can use `xSquared`.\n   * console.log(xSquared);\n   * ```\n   */\n  static with(rawSourceMap, sourceMapUrl, f) {\n    // Note: The `acorn` version that `webpack` currently depends on doesn't\n    // support `async` functions, and the nodes that we support don't all have\n    // `.finally`. Therefore, this is written a bit more convolutedly than it\n    // should really be.\n\n    let consumer = null;\n    const promise = new SourceMapConsumer(rawSourceMap, sourceMapUrl);\n    return promise\n      .then(c => {\n        consumer = c;\n        return f(c);\n      })\n      .then(x => {\n        if (consumer) {\n          consumer.destroy();\n        }\n        return x;\n      }, e => {\n        if (consumer) {\n          consumer.destroy();\n        }\n        throw e;\n      });\n  }\n\n  /**\n   * Parse the mappings in a string in to a data structure which we can easily\n   * query (the ordered arrays in the `this.__generatedMappings` and\n   * `this.__originalMappings` properties).\n   */\n  _parseMappings(aStr, aSourceRoot) {\n    throw new Error(\"Subclasses must implement _parseMappings\");\n  }\n\n  /**\n   * Iterate over each mapping between an original source/line/column and a\n   * generated line/column in this source map.\n   *\n   * @param Function aCallback\n   *        The function that is called with each mapping.\n   * @param Object aContext\n   *        Optional. If specified, this object will be the value of `this` every\n   *        time that `aCallback` is called.\n   * @param aOrder\n   *        Either `SourceMapConsumer.GENERATED_ORDER` or\n   *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to\n   *        iterate over the mappings sorted by the generated file's line/column\n   *        order or the original's source/line/column order, respectively. Defaults to\n   *        `SourceMapConsumer.GENERATED_ORDER`.\n   */\n  eachMapping(aCallback, aContext, aOrder) {\n    throw new Error(\"Subclasses must implement eachMapping\");\n  }\n\n  /**\n   * Returns all generated line and column information for the original source,\n   * line, and column provided. If no column is provided, returns all mappings\n   * corresponding to a either the line we are searching for or the next\n   * closest line that has any mappings. Otherwise, returns all mappings\n   * corresponding to the given line and either the column we are searching for\n   * or the next closest column that has any offsets.\n   *\n   * The only argument is an object with the following properties:\n   *\n   *   - source: The filename of the original source.\n   *   - line: The line number in the original source.  The line number is 1-based.\n   *   - column: Optional. the column number in the original source.\n   *    The column number is 0-based.\n   *\n   * and an array of objects is returned, each with the following properties:\n   *\n   *   - line: The line number in the generated source, or null.  The\n   *    line number is 1-based.\n   *   - column: The column number in the generated source, or null.\n   *    The column number is 0-based.\n   */\n  allGeneratedPositionsFor(aArgs) {\n    throw new Error(\"Subclasses must implement allGeneratedPositionsFor\");\n  }\n\n  destroy() {\n    throw new Error(\"Subclasses must implement destroy\");\n  }\n}\n\n/**\n * The version of the source mapping spec that we are consuming.\n */\nSourceMapConsumer.prototype._version = 3;\nSourceMapConsumer.GENERATED_ORDER = 1;\nSourceMapConsumer.ORIGINAL_ORDER = 2;\n\nSourceMapConsumer.GREATEST_LOWER_BOUND = 1;\nSourceMapConsumer.LEAST_UPPER_BOUND = 2;\n\nexports.SourceMapConsumer = SourceMapConsumer;\n\n/**\n * A BasicSourceMapConsumer instance represents a parsed source map which we can\n * query for information about the original file positions by giving it a file\n * position in the generated source.\n *\n * The first parameter is the raw source map (either as a JSON string, or\n * already parsed to an object). According to the spec, source maps have the\n * following attributes:\n *\n *   - version: Which version of the source map spec this map is following.\n *   - sources: An array of URLs to the original source files.\n *   - names: An array of identifiers which can be referenced by individual mappings.\n *   - sourceRoot: Optional. The URL root from which all sources are relative.\n *   - sourcesContent: Optional. An array of contents of the original source files.\n *   - mappings: A string of base64 VLQs which contain the actual mappings.\n *   - file: Optional. The generated file this source map is associated with.\n *\n * Here is an example source map, taken from the source map spec[0]:\n *\n *     {\n *       version : 3,\n *       file: \"out.js\",\n *       sourceRoot : \"\",\n *       sources: [\"foo.js\", \"bar.js\"],\n *       names: [\"src\", \"maps\", \"are\", \"fun\"],\n *       mappings: \"AA,AB;;ABCDE;\"\n *     }\n *\n * The second parameter, if given, is a string whose value is the URL\n * at which the source map was found.  This URL is used to compute the\n * sources array.\n *\n * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#\n */\nclass BasicSourceMapConsumer extends SourceMapConsumer {\n  constructor(aSourceMap, aSourceMapURL) {\n    return super(INTERNAL).then(that => {\n      let sourceMap = aSourceMap;\n      if (typeof aSourceMap === \"string\") {\n        sourceMap = util.parseSourceMapInput(aSourceMap);\n      }\n\n      const version = util.getArg(sourceMap, \"version\");\n      let sources = util.getArg(sourceMap, \"sources\");\n      // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which\n      // requires the array) to play nice here.\n      const names = util.getArg(sourceMap, \"names\", []);\n      let sourceRoot = util.getArg(sourceMap, \"sourceRoot\", null);\n      const sourcesContent = util.getArg(sourceMap, \"sourcesContent\", null);\n      const mappings = util.getArg(sourceMap, \"mappings\");\n      const file = util.getArg(sourceMap, \"file\", null);\n\n      // Once again, Sass deviates from the spec and supplies the version as a\n      // string rather than a number, so we use loose equality checking here.\n      if (version != that._version) {\n        throw new Error(\"Unsupported version: \" + version);\n      }\n\n      if (sourceRoot) {\n        sourceRoot = util.normalize(sourceRoot);\n      }\n\n      sources = sources\n        .map(String)\n        // Some source maps produce relative source paths like \"./foo.js\" instead of\n        // \"foo.js\".  Normalize these first so that future comparisons will succeed.\n        // See bugzil.la/1090768.\n        .map(util.normalize)\n        // Always ensure that absolute sources are internally stored relative to\n        // the source root, if the source root is absolute. Not doing this would\n        // be particularly problematic when the source root is a prefix of the\n        // source (valid, but why??). See github issue #199 and bugzil.la/1188982.\n        .map(function(source) {\n          return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source)\n            ? util.relative(sourceRoot, source)\n            : source;\n        });\n\n      // Pass `true` below to allow duplicate names and sources. While source maps\n      // are intended to be compressed and deduplicated, the TypeScript compiler\n      // sometimes generates source maps with duplicates in them. See Github issue\n      // #72 and bugzil.la/889492.\n      that._names = ArraySet.fromArray(names.map(String), true);\n      that._sources = ArraySet.fromArray(sources, true);\n\n      that._absoluteSources = that._sources.toArray().map(function(s) {\n        return util.computeSourceURL(sourceRoot, s, aSourceMapURL);\n      });\n\n      that.sourceRoot = sourceRoot;\n      that.sourcesContent = sourcesContent;\n      that._mappings = mappings;\n      that._sourceMapURL = aSourceMapURL;\n      that.file = file;\n\n      that._computedColumnSpans = false;\n      that._mappingsPtr = 0;\n      that._wasm = null;\n\n      return wasm().then(w => {\n        that._wasm = w;\n        return that;\n      });\n    });\n  }\n\n  /**\n   * Utility function to find the index of a source.  Returns -1 if not\n   * found.\n   */\n  _findSourceIndex(aSource) {\n    let relativeSource = aSource;\n    if (this.sourceRoot != null) {\n      relativeSource = util.relative(this.sourceRoot, relativeSource);\n    }\n\n    if (this._sources.has(relativeSource)) {\n      return this._sources.indexOf(relativeSource);\n    }\n\n    // Maybe aSource is an absolute URL as returned by |sources|.  In\n    // this case we can't simply undo the transform.\n    for (let i = 0; i < this._absoluteSources.length; ++i) {\n      if (this._absoluteSources[i] == aSource) {\n        return i;\n      }\n    }\n\n    return -1;\n  }\n\n  /**\n   * Create a BasicSourceMapConsumer from a SourceMapGenerator.\n   *\n   * @param SourceMapGenerator aSourceMap\n   *        The source map that will be consumed.\n   * @param String aSourceMapURL\n   *        The URL at which the source map can be found (optional)\n   * @returns BasicSourceMapConsumer\n   */\n  static fromSourceMap(aSourceMap, aSourceMapURL) {\n    return new BasicSourceMapConsumer(aSourceMap.toString());\n  }\n\n  get sources() {\n    return this._absoluteSources.slice();\n  }\n\n  _getMappingsPtr() {\n    if (this._mappingsPtr === 0) {\n      this._parseMappings(this._mappings, this.sourceRoot);\n    }\n\n    return this._mappingsPtr;\n  }\n\n  /**\n   * Parse the mappings in a string in to a data structure which we can easily\n   * query (the ordered arrays in the `this.__generatedMappings` and\n   * `this.__originalMappings` properties).\n   */\n  _parseMappings(aStr, aSourceRoot) {\n    const size = aStr.length;\n\n    const mappingsBufPtr = this._wasm.exports.allocate_mappings(size);\n    const mappingsBuf = new Uint8Array(this._wasm.exports.memory.buffer, mappingsBufPtr, size);\n    for (let i = 0; i < size; i++) {\n      mappingsBuf[i] = aStr.charCodeAt(i);\n    }\n\n    const mappingsPtr = this._wasm.exports.parse_mappings(mappingsBufPtr);\n\n    if (!mappingsPtr) {\n      const error = this._wasm.exports.get_last_error();\n      let msg = `Error parsing mappings (code ${error}): `;\n\n      // XXX: keep these error codes in sync with `fitzgen/source-map-mappings`.\n      switch (error) {\n        case 1:\n          msg += \"the mappings contained a negative line, column, source index, or name index\";\n          break;\n        case 2:\n          msg += \"the mappings contained a number larger than 2**32\";\n          break;\n        case 3:\n          msg += \"reached EOF while in the middle of parsing a VLQ\";\n          break;\n        case 4:\n          msg += \"invalid base 64 character while parsing a VLQ\";\n          break;\n        default:\n          msg += \"unknown error code\";\n          break;\n      }\n\n      throw new Error(msg);\n    }\n\n    this._mappingsPtr = mappingsPtr;\n  }\n\n  eachMapping(aCallback, aContext, aOrder) {\n    const context = aContext || null;\n    const order = aOrder || SourceMapConsumer.GENERATED_ORDER;\n    const sourceRoot = this.sourceRoot;\n\n    this._wasm.withMappingCallback(\n      mapping => {\n        if (mapping.source !== null) {\n          mapping.source = this._sources.at(mapping.source);\n          mapping.source = util.computeSourceURL(sourceRoot, mapping.source, this._sourceMapURL);\n\n          if (mapping.name !== null) {\n            mapping.name = this._names.at(mapping.name);\n          }\n        }\n\n        aCallback.call(context, mapping);\n      },\n      () => {\n        switch (order) {\n        case SourceMapConsumer.GENERATED_ORDER:\n          this._wasm.exports.by_generated_location(this._getMappingsPtr());\n          break;\n        case SourceMapConsumer.ORIGINAL_ORDER:\n          this._wasm.exports.by_original_location(this._getMappingsPtr());\n          break;\n        default:\n          throw new Error(\"Unknown order of iteration.\");\n        }\n      }\n    );\n  }\n\n  allGeneratedPositionsFor(aArgs) {\n    let source = util.getArg(aArgs, \"source\");\n    const originalLine = util.getArg(aArgs, \"line\");\n    const originalColumn = aArgs.column || 0;\n\n    source = this._findSourceIndex(source);\n    if (source < 0) {\n      return [];\n    }\n\n    if (originalLine < 1) {\n      throw new Error(\"Line numbers must be >= 1\");\n    }\n\n    if (originalColumn < 0) {\n      throw new Error(\"Column numbers must be >= 0\");\n    }\n\n    const mappings = [];\n\n    this._wasm.withMappingCallback(\n      m => {\n        let lastColumn = m.lastGeneratedColumn;\n        if (this._computedColumnSpans && lastColumn === null) {\n          lastColumn = Infinity;\n        }\n        mappings.push({\n          line: m.generatedLine,\n          column: m.generatedColumn,\n          lastColumn,\n        });\n      }, () => {\n        this._wasm.exports.all_generated_locations_for(\n          this._getMappingsPtr(),\n          source,\n          originalLine - 1,\n          \"column\" in aArgs,\n          originalColumn\n        );\n      }\n    );\n\n    return mappings;\n  }\n\n  destroy() {\n    if (this._mappingsPtr !== 0) {\n      this._wasm.exports.free_mappings(this._mappingsPtr);\n      this._mappingsPtr = 0;\n    }\n  }\n\n  /**\n   * Compute the last column for each generated mapping. The last column is\n   * inclusive.\n   */\n  computeColumnSpans() {\n    if (this._computedColumnSpans) {\n      return;\n    }\n\n    this._wasm.exports.compute_column_spans(this._getMappingsPtr());\n    this._computedColumnSpans = true;\n  }\n\n  /**\n   * Returns the original source, line, and column information for the generated\n   * source's line and column positions provided. The only argument is an object\n   * with the following properties:\n   *\n   *   - line: The line number in the generated source.  The line number\n   *     is 1-based.\n   *   - column: The column number in the generated source.  The column\n   *     number is 0-based.\n   *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or\n   *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the\n   *     closest element that is smaller than or greater than the one we are\n   *     searching for, respectively, if the exact element cannot be found.\n   *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.\n   *\n   * and an object is returned with the following properties:\n   *\n   *   - source: The original source file, or null.\n   *   - line: The line number in the original source, or null.  The\n   *     line number is 1-based.\n   *   - column: The column number in the original source, or null.  The\n   *     column number is 0-based.\n   *   - name: The original identifier, or null.\n   */\n  originalPositionFor(aArgs) {\n    const needle = {\n      generatedLine: util.getArg(aArgs, \"line\"),\n      generatedColumn: util.getArg(aArgs, \"column\")\n    };\n\n    if (needle.generatedLine < 1) {\n      throw new Error(\"Line numbers must be >= 1\");\n    }\n\n    if (needle.generatedColumn < 0) {\n      throw new Error(\"Column numbers must be >= 0\");\n    }\n\n    let bias = util.getArg(aArgs, \"bias\", SourceMapConsumer.GREATEST_LOWER_BOUND);\n    if (bias == null) {\n      bias = SourceMapConsumer.GREATEST_LOWER_BOUND;\n    }\n\n    let mapping;\n    this._wasm.withMappingCallback(m => mapping = m, () => {\n      this._wasm.exports.original_location_for(\n        this._getMappingsPtr(),\n        needle.generatedLine - 1,\n        needle.generatedColumn,\n        bias\n      );\n    });\n\n    if (mapping) {\n      if (mapping.generatedLine === needle.generatedLine) {\n        let source = util.getArg(mapping, \"source\", null);\n        if (source !== null) {\n          source = this._sources.at(source);\n          source = util.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);\n        }\n\n        let name = util.getArg(mapping, \"name\", null);\n        if (name !== null) {\n          name = this._names.at(name);\n        }\n\n        return {\n          source,\n          line: util.getArg(mapping, \"originalLine\", null),\n          column: util.getArg(mapping, \"originalColumn\", null),\n          name\n        };\n      }\n    }\n\n    return {\n      source: null,\n      line: null,\n      column: null,\n      name: null\n    };\n  }\n\n  /**\n   * Return true if we have the source content for every source in the source\n   * map, false otherwise.\n   */\n  hasContentsOfAllSources() {\n    if (!this.sourcesContent) {\n      return false;\n    }\n    return this.sourcesContent.length >= this._sources.size() &&\n      !this.sourcesContent.some(function(sc) { return sc == null; });\n  }\n\n  /**\n   * Returns the original source content. The only argument is the url of the\n   * original source file. Returns null if no original source content is\n   * available.\n   */\n  sourceContentFor(aSource, nullOnMissing) {\n    if (!this.sourcesContent) {\n      return null;\n    }\n\n    const index = this._findSourceIndex(aSource);\n    if (index >= 0) {\n      return this.sourcesContent[index];\n    }\n\n    let relativeSource = aSource;\n    if (this.sourceRoot != null) {\n      relativeSource = util.relative(this.sourceRoot, relativeSource);\n    }\n\n    let url;\n    if (this.sourceRoot != null\n        && (url = util.urlParse(this.sourceRoot))) {\n      // XXX: file:// URIs and absolute paths lead to unexpected behavior for\n      // many users. We can help them out when they expect file:// URIs to\n      // behave like it would if they were running a local HTTP server. See\n      // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.\n      const fileUriAbsPath = relativeSource.replace(/^file:\\/\\//, \"\");\n      if (url.scheme == \"file\"\n          && this._sources.has(fileUriAbsPath)) {\n        return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];\n      }\n\n      if ((!url.path || url.path == \"/\")\n          && this._sources.has(\"/\" + relativeSource)) {\n        return this.sourcesContent[this._sources.indexOf(\"/\" + relativeSource)];\n      }\n    }\n\n    // This function is used recursively from\n    // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we\n    // don't want to throw if we can't find the source - we just want to\n    // return null, so we provide a flag to exit gracefully.\n    if (nullOnMissing) {\n      return null;\n    }\n\n    throw new Error('\"' + relativeSource + '\" is not in the SourceMap.');\n  }\n\n  /**\n   * Returns the generated line and column information for the original source,\n   * line, and column positions provided. The only argument is an object with\n   * the following properties:\n   *\n   *   - source: The filename of the original source.\n   *   - line: The line number in the original source.  The line number\n   *     is 1-based.\n   *   - column: The column number in the original source.  The column\n   *     number is 0-based.\n   *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or\n   *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the\n   *     closest element that is smaller than or greater than the one we are\n   *     searching for, respectively, if the exact element cannot be found.\n   *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.\n   *\n   * and an object is returned with the following properties:\n   *\n   *   - line: The line number in the generated source, or null.  The\n   *     line number is 1-based.\n   *   - column: The column number in the generated source, or null.\n   *     The column number is 0-based.\n   */\n  generatedPositionFor(aArgs) {\n    let source = util.getArg(aArgs, \"source\");\n    source = this._findSourceIndex(source);\n    if (source < 0) {\n      return {\n        line: null,\n        column: null,\n        lastColumn: null\n      };\n    }\n\n    const needle = {\n      source,\n      originalLine: util.getArg(aArgs, \"line\"),\n      originalColumn: util.getArg(aArgs, \"column\")\n    };\n\n    if (needle.originalLine < 1) {\n      throw new Error(\"Line numbers must be >= 1\");\n    }\n\n    if (needle.originalColumn < 0) {\n      throw new Error(\"Column numbers must be >= 0\");\n    }\n\n    let bias = util.getArg(aArgs, \"bias\", SourceMapConsumer.GREATEST_LOWER_BOUND);\n    if (bias == null) {\n      bias = SourceMapConsumer.GREATEST_LOWER_BOUND;\n    }\n\n    let mapping;\n    this._wasm.withMappingCallback(m => mapping = m, () => {\n      this._wasm.exports.generated_location_for(\n        this._getMappingsPtr(),\n        needle.source,\n        needle.originalLine - 1,\n        needle.originalColumn,\n        bias\n      );\n    });\n\n    if (mapping) {\n      if (mapping.source === needle.source) {\n        let lastColumn = mapping.lastGeneratedColumn;\n        if (this._computedColumnSpans && lastColumn === null) {\n          lastColumn = Infinity;\n        }\n        return {\n          line: util.getArg(mapping, \"generatedLine\", null),\n          column: util.getArg(mapping, \"generatedColumn\", null),\n          lastColumn,\n        };\n      }\n    }\n\n    return {\n      line: null,\n      column: null,\n      lastColumn: null\n    };\n  }\n}\n\nBasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;\nexports.BasicSourceMapConsumer = BasicSourceMapConsumer;\n\n/**\n * An IndexedSourceMapConsumer instance represents a parsed source map which\n * we can query for information. It differs from BasicSourceMapConsumer in\n * that it takes \"indexed\" source maps (i.e. ones with a \"sections\" field) as\n * input.\n *\n * The first parameter is a raw source map (either as a JSON string, or already\n * parsed to an object). According to the spec for indexed source maps, they\n * have the following attributes:\n *\n *   - version: Which version of the source map spec this map is following.\n *   - file: Optional. The generated file this source map is associated with.\n *   - sections: A list of section definitions.\n *\n * Each value under the \"sections\" field has two fields:\n *   - offset: The offset into the original specified at which this section\n *       begins to apply, defined as an object with a \"line\" and \"column\"\n *       field.\n *   - map: A source map definition. This source map could also be indexed,\n *       but doesn't have to be.\n *\n * Instead of the \"map\" field, it's also possible to have a \"url\" field\n * specifying a URL to retrieve a source map from, but that's currently\n * unsupported.\n *\n * Here's an example source map, taken from the source map spec[0], but\n * modified to omit a section which uses the \"url\" field.\n *\n *  {\n *    version : 3,\n *    file: \"app.js\",\n *    sections: [{\n *      offset: {line:100, column:10},\n *      map: {\n *        version : 3,\n *        file: \"section.js\",\n *        sources: [\"foo.js\", \"bar.js\"],\n *        names: [\"src\", \"maps\", \"are\", \"fun\"],\n *        mappings: \"AAAA,E;;ABCDE;\"\n *      }\n *    }],\n *  }\n *\n * The second parameter, if given, is a string whose value is the URL\n * at which the source map was found.  This URL is used to compute the\n * sources array.\n *\n * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt\n */\nclass IndexedSourceMapConsumer extends SourceMapConsumer {\n  constructor(aSourceMap, aSourceMapURL) {\n    return super(INTERNAL).then(that => {\n      let sourceMap = aSourceMap;\n      if (typeof aSourceMap === \"string\") {\n        sourceMap = util.parseSourceMapInput(aSourceMap);\n      }\n\n      const version = util.getArg(sourceMap, \"version\");\n      const sections = util.getArg(sourceMap, \"sections\");\n\n      if (version != that._version) {\n        throw new Error(\"Unsupported version: \" + version);\n      }\n\n      that._sources = new ArraySet();\n      that._names = new ArraySet();\n      that.__generatedMappings = null;\n      that.__originalMappings = null;\n      that.__generatedMappingsUnsorted = null;\n      that.__originalMappingsUnsorted = null;\n\n      let lastOffset = {\n        line: -1,\n        column: 0\n      };\n      return Promise.all(sections.map(s => {\n        if (s.url) {\n          // The url field will require support for asynchronicity.\n          // See https://github.com/mozilla/source-map/issues/16\n          throw new Error(\"Support for url field in sections not implemented.\");\n        }\n        const offset = util.getArg(s, \"offset\");\n        const offsetLine = util.getArg(offset, \"line\");\n        const offsetColumn = util.getArg(offset, \"column\");\n\n        if (offsetLine < lastOffset.line ||\n            (offsetLine === lastOffset.line && offsetColumn < lastOffset.column)) {\n          throw new Error(\"Section offsets must be ordered and non-overlapping.\");\n        }\n        lastOffset = offset;\n\n        const cons = new SourceMapConsumer(util.getArg(s, \"map\"), aSourceMapURL);\n        return cons.then(consumer => {\n          return {\n            generatedOffset: {\n              // The offset fields are 0-based, but we use 1-based indices when\n              // encoding/decoding from VLQ.\n              generatedLine: offsetLine + 1,\n              generatedColumn: offsetColumn + 1\n            },\n            consumer\n          };\n        });\n      })).then(s => {\n        that._sections = s;\n        return that;\n      });\n    });\n  }\n\n  // `__generatedMappings` and `__originalMappings` are arrays that hold the\n  // parsed mapping coordinates from the source map's \"mappings\" attribute. They\n  // are lazily instantiated, accessed via the `_generatedMappings` and\n  // `_originalMappings` getters respectively, and we only parse the mappings\n  // and create these arrays once queried for a source location. We jump through\n  // these hoops because there can be many thousands of mappings, and parsing\n  // them is expensive, so we only want to do it if we must.\n  //\n  // Each object in the arrays is of the form:\n  //\n  //     {\n  //       generatedLine: The line number in the generated code,\n  //       generatedColumn: The column number in the generated code,\n  //       source: The path to the original source file that generated this\n  //               chunk of code,\n  //       originalLine: The line number in the original source that\n  //                     corresponds to this chunk of generated code,\n  //       originalColumn: The column number in the original source that\n  //                       corresponds to this chunk of generated code,\n  //       name: The name of the original symbol which generated this chunk of\n  //             code.\n  //     }\n  //\n  // All properties except for `generatedLine` and `generatedColumn` can be\n  // `null`.\n  //\n  // `_generatedMappings` is ordered by the generated positions.\n  //\n  // `_originalMappings` is ordered by the original positions.\n  get _generatedMappings() {\n    if (!this.__generatedMappings) {\n      this._sortGeneratedMappings();\n    }\n\n    return this.__generatedMappings;\n  }\n\n  get _originalMappings() {\n    if (!this.__originalMappings) {\n      this._sortOriginalMappings();\n    }\n\n    return this.__originalMappings;\n  }\n\n  get _generatedMappingsUnsorted() {\n    if (!this.__generatedMappingsUnsorted) {\n      this._parseMappings(this._mappings, this.sourceRoot);\n    }\n\n    return this.__generatedMappingsUnsorted;\n  }\n\n  get _originalMappingsUnsorted() {\n    if (!this.__originalMappingsUnsorted) {\n      this._parseMappings(this._mappings, this.sourceRoot);\n    }\n\n    return this.__originalMappingsUnsorted;\n  }\n\n  _sortGeneratedMappings() {\n    const mappings = this._generatedMappingsUnsorted;\n    mappings.sort(util.compareByGeneratedPositionsDeflated);\n    this.__generatedMappings = mappings;\n  }\n\n  _sortOriginalMappings() {\n    const mappings = this._originalMappingsUnsorted;\n    mappings.sort(util.compareByOriginalPositions);\n    this.__originalMappings = mappings;\n  }\n\n  /**\n   * The list of original sources.\n   */\n  get sources() {\n    const sources = [];\n    for (let i = 0; i < this._sections.length; i++) {\n      for (let j = 0; j < this._sections[i].consumer.sources.length; j++) {\n        sources.push(this._sections[i].consumer.sources[j]);\n      }\n    }\n    return sources;\n  }\n\n  /**\n   * Returns the original source, line, and column information for the generated\n   * source's line and column positions provided. The only argument is an object\n   * with the following properties:\n   *\n   *   - line: The line number in the generated source.  The line number\n   *     is 1-based.\n   *   - column: The column number in the generated source.  The column\n   *     number is 0-based.\n   *\n   * and an object is returned with the following properties:\n   *\n   *   - source: The original source file, or null.\n   *   - line: The line number in the original source, or null.  The\n   *     line number is 1-based.\n   *   - column: The column number in the original source, or null.  The\n   *     column number is 0-based.\n   *   - name: The original identifier, or null.\n   */\n  originalPositionFor(aArgs) {\n    const needle = {\n      generatedLine: util.getArg(aArgs, \"line\"),\n      generatedColumn: util.getArg(aArgs, \"column\")\n    };\n\n    // Find the section containing the generated position we're trying to map\n    // to an original position.\n    const sectionIndex = binarySearch.search(needle, this._sections,\n      function(aNeedle, section) {\n        const cmp = aNeedle.generatedLine - section.generatedOffset.generatedLine;\n        if (cmp) {\n          return cmp;\n        }\n\n        return (aNeedle.generatedColumn -\n                section.generatedOffset.generatedColumn);\n      });\n    const section = this._sections[sectionIndex];\n\n    if (!section) {\n      return {\n        source: null,\n        line: null,\n        column: null,\n        name: null\n      };\n    }\n\n    return section.consumer.originalPositionFor({\n      line: needle.generatedLine -\n        (section.generatedOffset.generatedLine - 1),\n      column: needle.generatedColumn -\n        (section.generatedOffset.generatedLine === needle.generatedLine\n         ? section.generatedOffset.generatedColumn - 1\n         : 0),\n      bias: aArgs.bias\n    });\n  }\n\n  /**\n   * Return true if we have the source content for every source in the source\n   * map, false otherwise.\n   */\n  hasContentsOfAllSources() {\n    return this._sections.every(function(s) {\n      return s.consumer.hasContentsOfAllSources();\n    });\n  }\n\n  /**\n   * Returns the original source content. The only argument is the url of the\n   * original source file. Returns null if no original source content is\n   * available.\n   */\n  sourceContentFor(aSource, nullOnMissing) {\n    for (let i = 0; i < this._sections.length; i++) {\n      const section = this._sections[i];\n\n      const content = section.consumer.sourceContentFor(aSource, true);\n      if (content) {\n        return content;\n      }\n    }\n    if (nullOnMissing) {\n      return null;\n    }\n    throw new Error('\"' + aSource + '\" is not in the SourceMap.');\n  }\n\n  /**\n   * Returns the generated line and column information for the original source,\n   * line, and column positions provided. The only argument is an object with\n   * the following properties:\n   *\n   *   - source: The filename of the original source.\n   *   - line: The line number in the original source.  The line number\n   *     is 1-based.\n   *   - column: The column number in the original source.  The column\n   *     number is 0-based.\n   *\n   * and an object is returned with the following properties:\n   *\n   *   - line: The line number in the generated source, or null.  The\n   *     line number is 1-based.\n   *   - column: The column number in the generated source, or null.\n   *     The column number is 0-based.\n   */\n  generatedPositionFor(aArgs) {\n    for (let i = 0; i < this._sections.length; i++) {\n      const section = this._sections[i];\n\n      // Only consider this section if the requested source is in the list of\n      // sources of the consumer.\n      if (section.consumer._findSourceIndex(util.getArg(aArgs, \"source\")) === -1) {\n        continue;\n      }\n      const generatedPosition = section.consumer.generatedPositionFor(aArgs);\n      if (generatedPosition) {\n        const ret = {\n          line: generatedPosition.line +\n            (section.generatedOffset.generatedLine - 1),\n          column: generatedPosition.column +\n            (section.generatedOffset.generatedLine === generatedPosition.line\n             ? section.generatedOffset.generatedColumn - 1\n             : 0)\n        };\n        return ret;\n      }\n    }\n\n    return {\n      line: null,\n      column: null\n    };\n  }\n\n  /**\n   * Parse the mappings in a string in to a data structure which we can easily\n   * query (the ordered arrays in the `this.__generatedMappings` and\n   * `this.__originalMappings` properties).\n   */\n  _parseMappings(aStr, aSourceRoot) {\n    const generatedMappings = this.__generatedMappingsUnsorted = [];\n    const originalMappings = this.__originalMappingsUnsorted = [];\n    for (let i = 0; i < this._sections.length; i++) {\n      const section = this._sections[i];\n\n      const sectionMappings = [];\n      section.consumer.eachMapping(m => sectionMappings.push(m));\n\n      for (let j = 0; j < sectionMappings.length; j++) {\n        const mapping = sectionMappings[j];\n\n        // TODO: test if null is correct here.  The original code used\n        // `source`, which would actually have gotten used as null because\n        // var's get hoisted.\n        // See: https://github.com/mozilla/source-map/issues/333\n        let source = util.computeSourceURL(section.consumer.sourceRoot, null, this._sourceMapURL);\n        this._sources.add(source);\n        source = this._sources.indexOf(source);\n\n        let name = null;\n        if (mapping.name) {\n          this._names.add(mapping.name);\n          name = this._names.indexOf(mapping.name);\n        }\n\n        // The mappings coming from the consumer for the section have\n        // generated positions relative to the start of the section, so we\n        // need to offset them to be relative to the start of the concatenated\n        // generated file.\n        const adjustedMapping = {\n          source,\n          generatedLine: mapping.generatedLine +\n            (section.generatedOffset.generatedLine - 1),\n          generatedColumn: mapping.generatedColumn +\n            (section.generatedOffset.generatedLine === mapping.generatedLine\n            ? section.generatedOffset.generatedColumn - 1\n            : 0),\n          originalLine: mapping.originalLine,\n          originalColumn: mapping.originalColumn,\n          name\n        };\n\n        generatedMappings.push(adjustedMapping);\n        if (typeof adjustedMapping.originalLine === \"number\") {\n          originalMappings.push(adjustedMapping);\n        }\n      }\n    }\n  }\n\n  eachMapping(aCallback, aContext, aOrder) {\n    const context = aContext || null;\n    const order = aOrder || SourceMapConsumer.GENERATED_ORDER;\n\n    let mappings;\n    switch (order) {\n    case SourceMapConsumer.GENERATED_ORDER:\n      mappings = this._generatedMappings;\n      break;\n    case SourceMapConsumer.ORIGINAL_ORDER:\n      mappings = this._originalMappings;\n      break;\n    default:\n      throw new Error(\"Unknown order of iteration.\");\n    }\n\n    const sourceRoot = this.sourceRoot;\n    mappings.map(function(mapping) {\n      let source = null;\n      if (mapping.source !== null) {\n        source = this._sources.at(mapping.source);\n        source = util.computeSourceURL(sourceRoot, source, this._sourceMapURL);\n      }\n      return {\n        source,\n        generatedLine: mapping.generatedLine,\n        generatedColumn: mapping.generatedColumn,\n        originalLine: mapping.originalLine,\n        originalColumn: mapping.originalColumn,\n        name: mapping.name === null ? null : this._names.at(mapping.name)\n      };\n    }, this).forEach(aCallback, context);\n  }\n\n  /**\n   * Find the mapping that best matches the hypothetical \"needle\" mapping that\n   * we are searching for in the given \"haystack\" of mappings.\n   */\n  _findMapping(aNeedle, aMappings, aLineName,\n              aColumnName, aComparator, aBias) {\n    // To return the position we are searching for, we must first find the\n    // mapping for the given position and then return the opposite position it\n    // points to. Because the mappings are sorted, we can use binary search to\n    // find the best mapping.\n\n    if (aNeedle[aLineName] <= 0) {\n      throw new TypeError(\"Line must be greater than or equal to 1, got \"\n                          + aNeedle[aLineName]);\n    }\n    if (aNeedle[aColumnName] < 0) {\n      throw new TypeError(\"Column must be greater than or equal to 0, got \"\n                          + aNeedle[aColumnName]);\n    }\n\n    return binarySearch.search(aNeedle, aMappings, aComparator, aBias);\n  }\n\n  allGeneratedPositionsFor(aArgs) {\n    const line = util.getArg(aArgs, \"line\");\n\n    // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping\n    // returns the index of the closest mapping less than the needle. By\n    // setting needle.originalColumn to 0, we thus find the last mapping for\n    // the given line, provided such a mapping exists.\n    const needle = {\n      source: util.getArg(aArgs, \"source\"),\n      originalLine: line,\n      originalColumn: util.getArg(aArgs, \"column\", 0)\n    };\n\n    needle.source = this._findSourceIndex(needle.source);\n    if (needle.source < 0) {\n      return [];\n    }\n\n    if (needle.originalLine < 1) {\n      throw new Error(\"Line numbers must be >= 1\");\n    }\n\n    if (needle.originalColumn < 0) {\n      throw new Error(\"Column numbers must be >= 0\");\n    }\n\n    const mappings = [];\n\n    let index = this._findMapping(needle,\n                                  this._originalMappings,\n                                  \"originalLine\",\n                                  \"originalColumn\",\n                                  util.compareByOriginalPositions,\n                                  binarySearch.LEAST_UPPER_BOUND);\n    if (index >= 0) {\n      let mapping = this._originalMappings[index];\n\n      if (aArgs.column === undefined) {\n        const originalLine = mapping.originalLine;\n\n        // Iterate until either we run out of mappings, or we run into\n        // a mapping for a different line than the one we found. Since\n        // mappings are sorted, this is guaranteed to find all mappings for\n        // the line we found.\n        while (mapping && mapping.originalLine === originalLine) {\n          let lastColumn = mapping.lastGeneratedColumn;\n          if (this._computedColumnSpans && lastColumn === null) {\n            lastColumn = Infinity;\n          }\n          mappings.push({\n            line: util.getArg(mapping, \"generatedLine\", null),\n            column: util.getArg(mapping, \"generatedColumn\", null),\n            lastColumn,\n          });\n\n          mapping = this._originalMappings[++index];\n        }\n      } else {\n        const originalColumn = mapping.originalColumn;\n\n        // Iterate until either we run out of mappings, or we run into\n        // a mapping for a different line than the one we were searching for.\n        // Since mappings are sorted, this is guaranteed to find all mappings for\n        // the line we are searching for.\n        while (mapping &&\n               mapping.originalLine === line &&\n               mapping.originalColumn == originalColumn) {\n          let lastColumn = mapping.lastGeneratedColumn;\n          if (this._computedColumnSpans && lastColumn === null) {\n            lastColumn = Infinity;\n          }\n          mappings.push({\n            line: util.getArg(mapping, \"generatedLine\", null),\n            column: util.getArg(mapping, \"generatedColumn\", null),\n            lastColumn,\n          });\n\n          mapping = this._originalMappings[++index];\n        }\n      }\n    }\n\n    return mappings;\n  }\n\n  destroy() {\n    for (let i = 0; i < this._sections.length; i++) {\n      this._sections[i].consumer.destroy();\n    }\n  }\n}\nexports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;\n\n/*\n * Cheat to get around inter-twingled classes.  `factory()` can be at the end\n * where it has access to non-hoisted classes, but it gets hoisted itself.\n */\nfunction _factory(aSourceMap, aSourceMapURL) {\n  let sourceMap = aSourceMap;\n  if (typeof aSourceMap === \"string\") {\n    sourceMap = util.parseSourceMapInput(aSourceMap);\n  }\n\n  const consumer = sourceMap.sections != null\n      ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL)\n      : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);\n  return Promise.resolve(consumer);\n}\n\nfunction _factoryBSM(aSourceMap, aSourceMapURL) {\n  return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);\n}\n","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nconst base64VLQ = require(\"./base64-vlq\");\nconst util = require(\"./util\");\nconst ArraySet = require(\"./array-set\").ArraySet;\nconst MappingList = require(\"./mapping-list\").MappingList;\n\n/**\n * An instance of the SourceMapGenerator represents a source map which is\n * being built incrementally. You may pass an object with the following\n * properties:\n *\n *   - file: The filename of the generated source.\n *   - sourceRoot: A root for all relative URLs in this source map.\n */\nclass SourceMapGenerator {\n  constructor(aArgs) {\n    if (!aArgs) {\n      aArgs = {};\n    }\n    this._file = util.getArg(aArgs, \"file\", null);\n    this._sourceRoot = util.getArg(aArgs, \"sourceRoot\", null);\n    this._skipValidation = util.getArg(aArgs, \"skipValidation\", false);\n    this._sources = new ArraySet();\n    this._names = new ArraySet();\n    this._mappings = new MappingList();\n    this._sourcesContents = null;\n  }\n\n  /**\n   * Creates a new SourceMapGenerator based on a SourceMapConsumer\n   *\n   * @param aSourceMapConsumer The SourceMap.\n   */\n  static fromSourceMap(aSourceMapConsumer) {\n    const sourceRoot = aSourceMapConsumer.sourceRoot;\n    const generator = new SourceMapGenerator({\n      file: aSourceMapConsumer.file,\n      sourceRoot\n    });\n    aSourceMapConsumer.eachMapping(function(mapping) {\n      const newMapping = {\n        generated: {\n          line: mapping.generatedLine,\n          column: mapping.generatedColumn\n        }\n      };\n\n      if (mapping.source != null) {\n        newMapping.source = mapping.source;\n        if (sourceRoot != null) {\n          newMapping.source = util.relative(sourceRoot, newMapping.source);\n        }\n\n        newMapping.original = {\n          line: mapping.originalLine,\n          column: mapping.originalColumn\n        };\n\n        if (mapping.name != null) {\n          newMapping.name = mapping.name;\n        }\n      }\n\n      generator.addMapping(newMapping);\n    });\n    aSourceMapConsumer.sources.forEach(function(sourceFile) {\n      let sourceRelative = sourceFile;\n      if (sourceRoot !== null) {\n        sourceRelative = util.relative(sourceRoot, sourceFile);\n      }\n\n      if (!generator._sources.has(sourceRelative)) {\n        generator._sources.add(sourceRelative);\n      }\n\n      const content = aSourceMapConsumer.sourceContentFor(sourceFile);\n      if (content != null) {\n        generator.setSourceContent(sourceFile, content);\n      }\n    });\n    return generator;\n  }\n\n  /**\n   * Add a single mapping from original source line and column to the generated\n   * source's line and column for this source map being created. The mapping\n   * object should have the following properties:\n   *\n   *   - generated: An object with the generated line and column positions.\n   *   - original: An object with the original line and column positions.\n   *   - source: The original source file (relative to the sourceRoot).\n   *   - name: An optional original token name for this mapping.\n   */\n  addMapping(aArgs) {\n    const generated = util.getArg(aArgs, \"generated\");\n    const original = util.getArg(aArgs, \"original\", null);\n    let source = util.getArg(aArgs, \"source\", null);\n    let name = util.getArg(aArgs, \"name\", null);\n\n    if (!this._skipValidation) {\n      this._validateMapping(generated, original, source, name);\n    }\n\n    if (source != null) {\n      source = String(source);\n      if (!this._sources.has(source)) {\n        this._sources.add(source);\n      }\n    }\n\n    if (name != null) {\n      name = String(name);\n      if (!this._names.has(name)) {\n        this._names.add(name);\n      }\n    }\n\n    this._mappings.add({\n      generatedLine: generated.line,\n      generatedColumn: generated.column,\n      originalLine: original != null && original.line,\n      originalColumn: original != null && original.column,\n      source,\n      name\n    });\n  }\n\n  /**\n   * Set the source content for a source file.\n   */\n  setSourceContent(aSourceFile, aSourceContent) {\n    let source = aSourceFile;\n    if (this._sourceRoot != null) {\n      source = util.relative(this._sourceRoot, source);\n    }\n\n    if (aSourceContent != null) {\n      // Add the source content to the _sourcesContents map.\n      // Create a new _sourcesContents map if the property is null.\n      if (!this._sourcesContents) {\n        this._sourcesContents = Object.create(null);\n      }\n      this._sourcesContents[util.toSetString(source)] = aSourceContent;\n    } else if (this._sourcesContents) {\n      // Remove the source file from the _sourcesContents map.\n      // If the _sourcesContents map is empty, set the property to null.\n      delete this._sourcesContents[util.toSetString(source)];\n      if (Object.keys(this._sourcesContents).length === 0) {\n        this._sourcesContents = null;\n      }\n    }\n  }\n\n  /**\n   * Applies the mappings of a sub-source-map for a specific source file to the\n   * source map being generated. Each mapping to the supplied source file is\n   * rewritten using the supplied source map. Note: The resolution for the\n   * resulting mappings is the minimium of this map and the supplied map.\n   *\n   * @param aSourceMapConsumer The source map to be applied.\n   * @param aSourceFile Optional. The filename of the source file.\n   *        If omitted, SourceMapConsumer's file property will be used.\n   * @param aSourceMapPath Optional. The dirname of the path to the source map\n   *        to be applied. If relative, it is relative to the SourceMapConsumer.\n   *        This parameter is needed when the two source maps aren't in the same\n   *        directory, and the source map to be applied contains relative source\n   *        paths. If so, those relative source paths need to be rewritten\n   *        relative to the SourceMapGenerator.\n   */\n  applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {\n    let sourceFile = aSourceFile;\n    // If aSourceFile is omitted, we will use the file property of the SourceMap\n    if (aSourceFile == null) {\n      if (aSourceMapConsumer.file == null) {\n        throw new Error(\n          \"SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, \" +\n          'or the source map\\'s \"file\" property. Both were omitted.'\n        );\n      }\n      sourceFile = aSourceMapConsumer.file;\n    }\n    const sourceRoot = this._sourceRoot;\n    // Make \"sourceFile\" relative if an absolute Url is passed.\n    if (sourceRoot != null) {\n      sourceFile = util.relative(sourceRoot, sourceFile);\n    }\n    // Applying the SourceMap can add and remove items from the sources and\n    // the names array.\n    const newSources = this._mappings.toArray().length > 0\n      ? new ArraySet()\n      : this._sources;\n    const newNames = new ArraySet();\n\n    // Find mappings for the \"sourceFile\"\n    this._mappings.unsortedForEach(function(mapping) {\n      if (mapping.source === sourceFile && mapping.originalLine != null) {\n        // Check if it can be mapped by the source map, then update the mapping.\n        const original = aSourceMapConsumer.originalPositionFor({\n          line: mapping.originalLine,\n          column: mapping.originalColumn\n        });\n        if (original.source != null) {\n          // Copy mapping\n          mapping.source = original.source;\n          if (aSourceMapPath != null) {\n            mapping.source = util.join(aSourceMapPath, mapping.source);\n          }\n          if (sourceRoot != null) {\n            mapping.source = util.relative(sourceRoot, mapping.source);\n          }\n          mapping.originalLine = original.line;\n          mapping.originalColumn = original.column;\n          if (original.name != null) {\n            mapping.name = original.name;\n          }\n        }\n      }\n\n      const source = mapping.source;\n      if (source != null && !newSources.has(source)) {\n        newSources.add(source);\n      }\n\n      const name = mapping.name;\n      if (name != null && !newNames.has(name)) {\n        newNames.add(name);\n      }\n\n    }, this);\n    this._sources = newSources;\n    this._names = newNames;\n\n    // Copy sourcesContents of applied map.\n    aSourceMapConsumer.sources.forEach(function(srcFile) {\n      const content = aSourceMapConsumer.sourceContentFor(srcFile);\n      if (content != null) {\n        if (aSourceMapPath != null) {\n          srcFile = util.join(aSourceMapPath, srcFile);\n        }\n        if (sourceRoot != null) {\n          srcFile = util.relative(sourceRoot, srcFile);\n        }\n        this.setSourceContent(srcFile, content);\n      }\n    }, this);\n  }\n\n  /**\n   * A mapping can have one of the three levels of data:\n   *\n   *   1. Just the generated position.\n   *   2. The Generated position, original position, and original source.\n   *   3. Generated and original position, original source, as well as a name\n   *      token.\n   *\n   * To maintain consistency, we validate that any new mapping being added falls\n   * in to one of these categories.\n   */\n  _validateMapping(aGenerated, aOriginal, aSource, aName) {\n    // When aOriginal is truthy but has empty values for .line and .column,\n    // it is most likely a programmer error. In this case we throw a very\n    // specific error message to try to guide them the right way.\n    // For example: https://github.com/Polymer/polymer-bundler/pull/519\n    if (aOriginal && typeof aOriginal.line !== \"number\" && typeof aOriginal.column !== \"number\") {\n        throw new Error(\n            \"original.line and original.column are not numbers -- you probably meant to omit \" +\n            \"the original mapping entirely and only map the generated position. If so, pass \" +\n            \"null for the original mapping instead of an object with empty or null values.\"\n        );\n    }\n\n    if (aGenerated && \"line\" in aGenerated && \"column\" in aGenerated\n        && aGenerated.line > 0 && aGenerated.column >= 0\n        && !aOriginal && !aSource && !aName) {\n      // Case 1.\n\n    } else if (aGenerated && \"line\" in aGenerated && \"column\" in aGenerated\n             && aOriginal && \"line\" in aOriginal && \"column\" in aOriginal\n             && aGenerated.line > 0 && aGenerated.column >= 0\n             && aOriginal.line > 0 && aOriginal.column >= 0\n             && aSource) {\n      // Cases 2 and 3.\n\n    } else {\n      throw new Error(\"Invalid mapping: \" + JSON.stringify({\n        generated: aGenerated,\n        source: aSource,\n        original: aOriginal,\n        name: aName\n      }));\n    }\n  }\n\n  /**\n   * Serialize the accumulated mappings in to the stream of base 64 VLQs\n   * specified by the source map format.\n   */\n  _serializeMappings() {\n    let previousGeneratedColumn = 0;\n    let previousGeneratedLine = 1;\n    let previousOriginalColumn = 0;\n    let previousOriginalLine = 0;\n    let previousName = 0;\n    let previousSource = 0;\n    let result = \"\";\n    let next;\n    let mapping;\n    let nameIdx;\n    let sourceIdx;\n\n    const mappings = this._mappings.toArray();\n    for (let i = 0, len = mappings.length; i < len; i++) {\n      mapping = mappings[i];\n      next = \"\";\n\n      if (mapping.generatedLine !== previousGeneratedLine) {\n        previousGeneratedColumn = 0;\n        while (mapping.generatedLine !== previousGeneratedLine) {\n          next += \";\";\n          previousGeneratedLine++;\n        }\n      } else if (i > 0) {\n        if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {\n          continue;\n        }\n        next += \",\";\n      }\n\n      next += base64VLQ.encode(mapping.generatedColumn\n                                 - previousGeneratedColumn);\n      previousGeneratedColumn = mapping.generatedColumn;\n\n      if (mapping.source != null) {\n        sourceIdx = this._sources.indexOf(mapping.source);\n        next += base64VLQ.encode(sourceIdx - previousSource);\n        previousSource = sourceIdx;\n\n        // lines are stored 0-based in SourceMap spec version 3\n        next += base64VLQ.encode(mapping.originalLine - 1\n                                   - previousOriginalLine);\n        previousOriginalLine = mapping.originalLine - 1;\n\n        next += base64VLQ.encode(mapping.originalColumn\n                                   - previousOriginalColumn);\n        previousOriginalColumn = mapping.originalColumn;\n\n        if (mapping.name != null) {\n          nameIdx = this._names.indexOf(mapping.name);\n          next += base64VLQ.encode(nameIdx - previousName);\n          previousName = nameIdx;\n        }\n      }\n\n      result += next;\n    }\n\n    return result;\n  }\n\n  _generateSourcesContent(aSources, aSourceRoot) {\n    return aSources.map(function(source) {\n      if (!this._sourcesContents) {\n        return null;\n      }\n      if (aSourceRoot != null) {\n        source = util.relative(aSourceRoot, source);\n      }\n      const key = util.toSetString(source);\n      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)\n        ? this._sourcesContents[key]\n        : null;\n    }, this);\n  }\n\n  /**\n   * Externalize the source map.\n   */\n  toJSON() {\n    const map = {\n      version: this._version,\n      sources: this._sources.toArray(),\n      names: this._names.toArray(),\n      mappings: this._serializeMappings()\n    };\n    if (this._file != null) {\n      map.file = this._file;\n    }\n    if (this._sourceRoot != null) {\n      map.sourceRoot = this._sourceRoot;\n    }\n    if (this._sourcesContents) {\n      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);\n    }\n\n    return map;\n  }\n\n  /**\n   * Render the source map being generated to a string.\n   */\n  toString() {\n    return JSON.stringify(this.toJSON());\n  }\n}\n\nSourceMapGenerator.prototype._version = 3;\nexports.SourceMapGenerator = SourceMapGenerator;\n","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nconst SourceMapGenerator = require(\"./source-map-generator\").SourceMapGenerator;\nconst util = require(\"./util\");\n\n// Matches a Windows-style `\\r\\n` newline or a `\\n` newline used by all other\n// operating systems these days (capturing the result).\nconst REGEX_NEWLINE = /(\\r?\\n)/;\n\n// Newline character code for charCodeAt() comparisons\nconst NEWLINE_CODE = 10;\n\n// Private symbol for identifying `SourceNode`s when multiple versions of\n// the source-map library are loaded. This MUST NOT CHANGE across\n// versions!\nconst isSourceNode = \"$$$isSourceNode$$$\";\n\n/**\n * SourceNodes provide a way to abstract over interpolating/concatenating\n * snippets of generated JavaScript source code while maintaining the line and\n * column information associated with the original source code.\n *\n * @param aLine The original line number.\n * @param aColumn The original column number.\n * @param aSource The original source's filename.\n * @param aChunks Optional. An array of strings which are snippets of\n *        generated JS, or other SourceNodes.\n * @param aName The original identifier.\n */\nclass SourceNode {\n  constructor(aLine, aColumn, aSource, aChunks, aName) {\n    this.children = [];\n    this.sourceContents = {};\n    this.line = aLine == null ? null : aLine;\n    this.column = aColumn == null ? null : aColumn;\n    this.source = aSource == null ? null : aSource;\n    this.name = aName == null ? null : aName;\n    this[isSourceNode] = true;\n    if (aChunks != null) this.add(aChunks);\n  }\n\n  /**\n   * Creates a SourceNode from generated code and a SourceMapConsumer.\n   *\n   * @param aGeneratedCode The generated code\n   * @param aSourceMapConsumer The SourceMap for the generated code\n   * @param aRelativePath Optional. The path that relative sources in the\n   *        SourceMapConsumer should be relative to.\n   */\n  static fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {\n    // The SourceNode we want to fill with the generated code\n    // and the SourceMap\n    const node = new SourceNode();\n\n    // All even indices of this array are one line of the generated code,\n    // while all odd indices are the newlines between two adjacent lines\n    // (since `REGEX_NEWLINE` captures its match).\n    // Processed fragments are accessed by calling `shiftNextLine`.\n    const remainingLines = aGeneratedCode.split(REGEX_NEWLINE);\n    let remainingLinesIndex = 0;\n    const shiftNextLine = function() {\n      const lineContents = getNextLine();\n      // The last line of a file might not have a newline.\n      const newLine = getNextLine() || \"\";\n      return lineContents + newLine;\n\n      function getNextLine() {\n        return remainingLinesIndex < remainingLines.length ?\n            remainingLines[remainingLinesIndex++] : undefined;\n      }\n    };\n\n    // We need to remember the position of \"remainingLines\"\n    let lastGeneratedLine = 1, lastGeneratedColumn = 0;\n\n    // The generate SourceNodes we need a code range.\n    // To extract it current and last mapping is used.\n    // Here we store the last mapping.\n    let lastMapping = null;\n    let nextLine;\n\n    aSourceMapConsumer.eachMapping(function(mapping) {\n      if (lastMapping !== null) {\n        // We add the code from \"lastMapping\" to \"mapping\":\n        // First check if there is a new line in between.\n        if (lastGeneratedLine < mapping.generatedLine) {\n          // Associate first line with \"lastMapping\"\n          addMappingWithCode(lastMapping, shiftNextLine());\n          lastGeneratedLine++;\n          lastGeneratedColumn = 0;\n          // The remaining code is added without mapping\n        } else {\n          // There is no new line in between.\n          // Associate the code between \"lastGeneratedColumn\" and\n          // \"mapping.generatedColumn\" with \"lastMapping\"\n          nextLine = remainingLines[remainingLinesIndex] || \"\";\n          const code = nextLine.substr(0, mapping.generatedColumn -\n                                        lastGeneratedColumn);\n          remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn -\n                                              lastGeneratedColumn);\n          lastGeneratedColumn = mapping.generatedColumn;\n          addMappingWithCode(lastMapping, code);\n          // No more remaining code, continue\n          lastMapping = mapping;\n          return;\n        }\n      }\n      // We add the generated code until the first mapping\n      // to the SourceNode without any mapping.\n      // Each line is added as separate string.\n      while (lastGeneratedLine < mapping.generatedLine) {\n        node.add(shiftNextLine());\n        lastGeneratedLine++;\n      }\n      if (lastGeneratedColumn < mapping.generatedColumn) {\n        nextLine = remainingLines[remainingLinesIndex] || \"\";\n        node.add(nextLine.substr(0, mapping.generatedColumn));\n        remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);\n        lastGeneratedColumn = mapping.generatedColumn;\n      }\n      lastMapping = mapping;\n    }, this);\n    // We have processed all mappings.\n    if (remainingLinesIndex < remainingLines.length) {\n      if (lastMapping) {\n        // Associate the remaining code in the current line with \"lastMapping\"\n        addMappingWithCode(lastMapping, shiftNextLine());\n      }\n      // and add the remaining lines without any mapping\n      node.add(remainingLines.splice(remainingLinesIndex).join(\"\"));\n    }\n\n    // Copy sourcesContent into SourceNode\n    aSourceMapConsumer.sources.forEach(function(sourceFile) {\n      const content = aSourceMapConsumer.sourceContentFor(sourceFile);\n      if (content != null) {\n        if (aRelativePath != null) {\n          sourceFile = util.join(aRelativePath, sourceFile);\n        }\n        node.setSourceContent(sourceFile, content);\n      }\n    });\n\n    return node;\n\n    function addMappingWithCode(mapping, code) {\n      if (mapping === null || mapping.source === undefined) {\n        node.add(code);\n      } else {\n        const source = aRelativePath\n          ? util.join(aRelativePath, mapping.source)\n          : mapping.source;\n        node.add(new SourceNode(mapping.originalLine,\n                                mapping.originalColumn,\n                                source,\n                                code,\n                                mapping.name));\n      }\n    }\n  }\n\n  /**\n   * Add a chunk of generated JS to this source node.\n   *\n   * @param aChunk A string snippet of generated JS code, another instance of\n   *        SourceNode, or an array where each member is one of those things.\n   */\n  add(aChunk) {\n    if (Array.isArray(aChunk)) {\n      aChunk.forEach(function(chunk) {\n        this.add(chunk);\n      }, this);\n    } else if (aChunk[isSourceNode] || typeof aChunk === \"string\") {\n      if (aChunk) {\n        this.children.push(aChunk);\n      }\n    } else {\n      throw new TypeError(\n        \"Expected a SourceNode, string, or an array of SourceNodes and strings. Got \" + aChunk\n      );\n    }\n    return this;\n  }\n\n  /**\n   * Add a chunk of generated JS to the beginning of this source node.\n   *\n   * @param aChunk A string snippet of generated JS code, another instance of\n   *        SourceNode, or an array where each member is one of those things.\n   */\n  prepend(aChunk) {\n    if (Array.isArray(aChunk)) {\n      for (let i = aChunk.length - 1; i >= 0; i--) {\n        this.prepend(aChunk[i]);\n      }\n    } else if (aChunk[isSourceNode] || typeof aChunk === \"string\") {\n      this.children.unshift(aChunk);\n    } else {\n      throw new TypeError(\n        \"Expected a SourceNode, string, or an array of SourceNodes and strings. Got \" + aChunk\n      );\n    }\n    return this;\n  }\n\n  /**\n   * Walk over the tree of JS snippets in this node and its children. The\n   * walking function is called once for each snippet of JS and is passed that\n   * snippet and the its original associated source's line/column location.\n   *\n   * @param aFn The traversal function.\n   */\n  walk(aFn) {\n    let chunk;\n    for (let i = 0, len = this.children.length; i < len; i++) {\n      chunk = this.children[i];\n      if (chunk[isSourceNode]) {\n        chunk.walk(aFn);\n      } else if (chunk !== \"\") {\n        aFn(chunk, { source: this.source,\n                      line: this.line,\n                      column: this.column,\n                      name: this.name });\n      }\n    }\n  }\n\n  /**\n   * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between\n   * each of `this.children`.\n   *\n   * @param aSep The separator.\n   */\n  join(aSep) {\n    let newChildren;\n    let i;\n    const len = this.children.length;\n    if (len > 0) {\n      newChildren = [];\n      for (i = 0; i < len - 1; i++) {\n        newChildren.push(this.children[i]);\n        newChildren.push(aSep);\n      }\n      newChildren.push(this.children[i]);\n      this.children = newChildren;\n    }\n    return this;\n  }\n\n  /**\n   * Call String.prototype.replace on the very right-most source snippet. Useful\n   * for trimming whitespace from the end of a source node, etc.\n   *\n   * @param aPattern The pattern to replace.\n   * @param aReplacement The thing to replace the pattern with.\n   */\n  replaceRight(aPattern, aReplacement) {\n    const lastChild = this.children[this.children.length - 1];\n    if (lastChild[isSourceNode]) {\n      lastChild.replaceRight(aPattern, aReplacement);\n    } else if (typeof lastChild === \"string\") {\n      this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);\n    } else {\n      this.children.push(\"\".replace(aPattern, aReplacement));\n    }\n    return this;\n  }\n\n  /**\n   * Set the source content for a source file. This will be added to the SourceMapGenerator\n   * in the sourcesContent field.\n   *\n   * @param aSourceFile The filename of the source file\n   * @param aSourceContent The content of the source file\n   */\n  setSourceContent(aSourceFile, aSourceContent) {\n    this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;\n  }\n\n  /**\n   * Walk over the tree of SourceNodes. The walking function is called for each\n   * source file content and is passed the filename and source content.\n   *\n   * @param aFn The traversal function.\n   */\n  walkSourceContents(aFn) {\n    for (let i = 0, len = this.children.length; i < len; i++) {\n      if (this.children[i][isSourceNode]) {\n        this.children[i].walkSourceContents(aFn);\n      }\n    }\n\n    const sources = Object.keys(this.sourceContents);\n    for (let i = 0, len = sources.length; i < len; i++) {\n      aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);\n    }\n  }\n\n  /**\n   * Return the string representation of this source node. Walks over the tree\n   * and concatenates all the various snippets together to one string.\n   */\n  toString() {\n    let str = \"\";\n    this.walk(function(chunk) {\n      str += chunk;\n    });\n    return str;\n  }\n\n  /**\n   * Returns the string representation of this source node along with a source\n   * map.\n   */\n  toStringWithSourceMap(aArgs) {\n    const generated = {\n      code: \"\",\n      line: 1,\n      column: 0\n    };\n    const map = new SourceMapGenerator(aArgs);\n    let sourceMappingActive = false;\n    let lastOriginalSource = null;\n    let lastOriginalLine = null;\n    let lastOriginalColumn = null;\n    let lastOriginalName = null;\n    this.walk(function(chunk, original) {\n      generated.code += chunk;\n      if (original.source !== null\n          && original.line !== null\n          && original.column !== null) {\n        if (lastOriginalSource !== original.source\n          || lastOriginalLine !== original.line\n          || lastOriginalColumn !== original.column\n          || lastOriginalName !== original.name) {\n          map.addMapping({\n            source: original.source,\n            original: {\n              line: original.line,\n              column: original.column\n            },\n            generated: {\n              line: generated.line,\n              column: generated.column\n            },\n            name: original.name\n          });\n        }\n        lastOriginalSource = original.source;\n        lastOriginalLine = original.line;\n        lastOriginalColumn = original.column;\n        lastOriginalName = original.name;\n        sourceMappingActive = true;\n      } else if (sourceMappingActive) {\n        map.addMapping({\n          generated: {\n            line: generated.line,\n            column: generated.column\n          }\n        });\n        lastOriginalSource = null;\n        sourceMappingActive = false;\n      }\n      for (let idx = 0, length = chunk.length; idx < length; idx++) {\n        if (chunk.charCodeAt(idx) === NEWLINE_CODE) {\n          generated.line++;\n          generated.column = 0;\n          // Mappings end at eol\n          if (idx + 1 === length) {\n            lastOriginalSource = null;\n            sourceMappingActive = false;\n          } else if (sourceMappingActive) {\n            map.addMapping({\n              source: original.source,\n              original: {\n                line: original.line,\n                column: original.column\n              },\n              generated: {\n                line: generated.line,\n                column: generated.column\n              },\n              name: original.name\n            });\n          }\n        } else {\n          generated.column++;\n        }\n      }\n    });\n    this.walkSourceContents(function(sourceFile, sourceContent) {\n      map.setSourceContent(sourceFile, sourceContent);\n    });\n\n    return { code: generated.code, map };\n  }\n}\n\nexports.SourceNode = SourceNode;\n","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\n/**\n * This is a helper function for getting values from parameter/options\n * objects.\n *\n * @param args The object we are extracting values from\n * @param name The name of the property we are getting.\n * @param defaultValue An optional value to return if the property is missing\n * from the object. If this is not specified and the property is missing, an\n * error will be thrown.\n */\nfunction getArg(aArgs, aName, aDefaultValue) {\n  if (aName in aArgs) {\n    return aArgs[aName];\n  } else if (arguments.length === 3) {\n    return aDefaultValue;\n  }\n    throw new Error('\"' + aName + '\" is a required argument.');\n\n}\nexports.getArg = getArg;\n\nconst urlRegexp = /^(?:([\\w+\\-.]+):)?\\/\\/(?:(\\w+:\\w+)@)?([\\w.-]*)(?::(\\d+))?(.*)$/;\nconst dataUrlRegexp = /^data:.+\\,.+$/;\n\nfunction urlParse(aUrl) {\n  const match = aUrl.match(urlRegexp);\n  if (!match) {\n    return null;\n  }\n  return {\n    scheme: match[1],\n    auth: match[2],\n    host: match[3],\n    port: match[4],\n    path: match[5]\n  };\n}\nexports.urlParse = urlParse;\n\nfunction urlGenerate(aParsedUrl) {\n  let url = \"\";\n  if (aParsedUrl.scheme) {\n    url += aParsedUrl.scheme + \":\";\n  }\n  url += \"//\";\n  if (aParsedUrl.auth) {\n    url += aParsedUrl.auth + \"@\";\n  }\n  if (aParsedUrl.host) {\n    url += aParsedUrl.host;\n  }\n  if (aParsedUrl.port) {\n    url += \":\" + aParsedUrl.port;\n  }\n  if (aParsedUrl.path) {\n    url += aParsedUrl.path;\n  }\n  return url;\n}\nexports.urlGenerate = urlGenerate;\n\nconst MAX_CACHED_INPUTS = 32;\n\n/**\n * Takes some function `f(input) -> result` and returns a memoized version of\n * `f`.\n *\n * We keep at most `MAX_CACHED_INPUTS` memoized results of `f` alive. The\n * memoization is a dumb-simple, linear least-recently-used cache.\n */\nfunction lruMemoize(f) {\n  const cache = [];\n\n  return function(input) {\n    for (let i = 0; i < cache.length; i++) {\n      if (cache[i].input === input) {\n        const temp = cache[0];\n        cache[0] = cache[i];\n        cache[i] = temp;\n        return cache[0].result;\n      }\n    }\n\n    const result = f(input);\n\n    cache.unshift({\n      input,\n      result,\n    });\n\n    if (cache.length > MAX_CACHED_INPUTS) {\n      cache.pop();\n    }\n\n    return result;\n  };\n}\n\n/**\n * Normalizes a path, or the path portion of a URL:\n *\n * - Replaces consecutive slashes with one slash.\n * - Removes unnecessary '.' parts.\n * - Removes unnecessary '<dir>/..' parts.\n *\n * Based on code in the Node.js 'path' core module.\n *\n * @param aPath The path or url to normalize.\n */\nconst normalize = lruMemoize(function normalize(aPath) {\n  let path = aPath;\n  const url = urlParse(aPath);\n  if (url) {\n    if (!url.path) {\n      return aPath;\n    }\n    path = url.path;\n  }\n  const isAbsolute = exports.isAbsolute(path);\n\n  // Split the path into parts between `/` characters. This is much faster than\n  // using `.split(/\\/+/g)`.\n  const parts = [];\n  let start = 0;\n  let i = 0;\n  while (true) {\n    start = i;\n    i = path.indexOf(\"/\", start);\n    if (i === -1) {\n      parts.push(path.slice(start));\n      break;\n    } else {\n      parts.push(path.slice(start, i));\n      while (i < path.length && path[i] === \"/\") {\n        i++;\n      }\n    }\n  }\n\n  let up = 0;\n  for (i = parts.length - 1; i >= 0; i--) {\n    const part = parts[i];\n    if (part === \".\") {\n      parts.splice(i, 1);\n    } else if (part === \"..\") {\n      up++;\n    } else if (up > 0) {\n      if (part === \"\") {\n        // The first part is blank if the path is absolute. Trying to go\n        // above the root is a no-op. Therefore we can remove all '..' parts\n        // directly after the root.\n        parts.splice(i + 1, up);\n        up = 0;\n      } else {\n        parts.splice(i, 2);\n        up--;\n      }\n    }\n  }\n  path = parts.join(\"/\");\n\n  if (path === \"\") {\n    path = isAbsolute ? \"/\" : \".\";\n  }\n\n  if (url) {\n    url.path = path;\n    return urlGenerate(url);\n  }\n  return path;\n});\nexports.normalize = normalize;\n\n/**\n * Joins two paths/URLs.\n *\n * @param aRoot The root path or URL.\n * @param aPath The path or URL to be joined with the root.\n *\n * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a\n *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended\n *   first.\n * - Otherwise aPath is a path. If aRoot is a URL, then its path portion\n *   is updated with the result and aRoot is returned. Otherwise the result\n *   is returned.\n *   - If aPath is absolute, the result is aPath.\n *   - Otherwise the two paths are joined with a slash.\n * - Joining for example 'http://' and 'www.example.com' is also supported.\n */\nfunction join(aRoot, aPath) {\n  if (aRoot === \"\") {\n    aRoot = \".\";\n  }\n  if (aPath === \"\") {\n    aPath = \".\";\n  }\n  const aPathUrl = urlParse(aPath);\n  const aRootUrl = urlParse(aRoot);\n  if (aRootUrl) {\n    aRoot = aRootUrl.path || \"/\";\n  }\n\n  // `join(foo, '//www.example.org')`\n  if (aPathUrl && !aPathUrl.scheme) {\n    if (aRootUrl) {\n      aPathUrl.scheme = aRootUrl.scheme;\n    }\n    return urlGenerate(aPathUrl);\n  }\n\n  if (aPathUrl || aPath.match(dataUrlRegexp)) {\n    return aPath;\n  }\n\n  // `join('http://', 'www.example.com')`\n  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {\n    aRootUrl.host = aPath;\n    return urlGenerate(aRootUrl);\n  }\n\n  const joined = aPath.charAt(0) === \"/\"\n    ? aPath\n    : normalize(aRoot.replace(/\\/+$/, \"\") + \"/\" + aPath);\n\n  if (aRootUrl) {\n    aRootUrl.path = joined;\n    return urlGenerate(aRootUrl);\n  }\n  return joined;\n}\nexports.join = join;\n\nexports.isAbsolute = function(aPath) {\n  return aPath.charAt(0) === \"/\" || urlRegexp.test(aPath);\n};\n\n/**\n * Make a path relative to a URL or another path.\n *\n * @param aRoot The root path or URL.\n * @param aPath The path or URL to be made relative to aRoot.\n */\nfunction relative(aRoot, aPath) {\n  if (aRoot === \"\") {\n    aRoot = \".\";\n  }\n\n  aRoot = aRoot.replace(/\\/$/, \"\");\n\n  // It is possible for the path to be above the root. In this case, simply\n  // checking whether the root is a prefix of the path won't work. Instead, we\n  // need to remove components from the root one by one, until either we find\n  // a prefix that fits, or we run out of components to remove.\n  let level = 0;\n  while (aPath.indexOf(aRoot + \"/\") !== 0) {\n    const index = aRoot.lastIndexOf(\"/\");\n    if (index < 0) {\n      return aPath;\n    }\n\n    // If the only part of the root that is left is the scheme (i.e. http://,\n    // file:///, etc.), one or more slashes (/), or simply nothing at all, we\n    // have exhausted all components, so the path is not relative to the root.\n    aRoot = aRoot.slice(0, index);\n    if (aRoot.match(/^([^\\/]+:\\/)?\\/*$/)) {\n      return aPath;\n    }\n\n    ++level;\n  }\n\n  // Make sure we add a \"../\" for each component we removed from the root.\n  return Array(level + 1).join(\"../\") + aPath.substr(aRoot.length + 1);\n}\nexports.relative = relative;\n\nconst supportsNullProto = (function() {\n  const obj = Object.create(null);\n  return !(\"__proto__\" in obj);\n}());\n\nfunction identity(s) {\n  return s;\n}\n\n/**\n * Because behavior goes wacky when you set `__proto__` on objects, we\n * have to prefix all the strings in our set with an arbitrary character.\n *\n * See https://github.com/mozilla/source-map/pull/31 and\n * https://github.com/mozilla/source-map/issues/30\n *\n * @param String aStr\n */\nfunction toSetString(aStr) {\n  if (isProtoString(aStr)) {\n    return \"$\" + aStr;\n  }\n\n  return aStr;\n}\nexports.toSetString = supportsNullProto ? identity : toSetString;\n\nfunction fromSetString(aStr) {\n  if (isProtoString(aStr)) {\n    return aStr.slice(1);\n  }\n\n  return aStr;\n}\nexports.fromSetString = supportsNullProto ? identity : fromSetString;\n\nfunction isProtoString(s) {\n  if (!s) {\n    return false;\n  }\n\n  const length = s.length;\n\n  if (length < 9 /* \"__proto__\".length */) {\n    return false;\n  }\n\n  /* eslint-disable no-multi-spaces */\n  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||\n      s.charCodeAt(length - 2) !== 95  /* '_' */ ||\n      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||\n      s.charCodeAt(length - 4) !== 116 /* 't' */ ||\n      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||\n      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||\n      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||\n      s.charCodeAt(length - 8) !== 95  /* '_' */ ||\n      s.charCodeAt(length - 9) !== 95  /* '_' */) {\n    return false;\n  }\n  /* eslint-enable no-multi-spaces */\n\n  for (let i = length - 10; i >= 0; i--) {\n    if (s.charCodeAt(i) !== 36 /* '$' */) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Comparator between two mappings where the original positions are compared.\n *\n * Optionally pass in `true` as `onlyCompareGenerated` to consider two\n * mappings with the same original source/line/column, but different generated\n * line and column the same. Useful when searching for a mapping with a\n * stubbed out mapping.\n */\nfunction compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {\n  let cmp = strcmp(mappingA.source, mappingB.source);\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalLine - mappingB.originalLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalColumn - mappingB.originalColumn;\n  if (cmp !== 0 || onlyCompareOriginal) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedLine - mappingB.generatedLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  return strcmp(mappingA.name, mappingB.name);\n}\nexports.compareByOriginalPositions = compareByOriginalPositions;\n\n/**\n * Comparator between two mappings with deflated source and name indices where\n * the generated positions are compared.\n *\n * Optionally pass in `true` as `onlyCompareGenerated` to consider two\n * mappings with the same generated line and column, but different\n * source/name/original line and column the same. Useful when searching for a\n * mapping with a stubbed out mapping.\n */\nfunction compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {\n  let cmp = mappingA.generatedLine - mappingB.generatedLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n  if (cmp !== 0 || onlyCompareGenerated) {\n    return cmp;\n  }\n\n  cmp = strcmp(mappingA.source, mappingB.source);\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalLine - mappingB.originalLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalColumn - mappingB.originalColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  return strcmp(mappingA.name, mappingB.name);\n}\nexports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;\n\nfunction strcmp(aStr1, aStr2) {\n  if (aStr1 === aStr2) {\n    return 0;\n  }\n\n  if (aStr1 === null) {\n    return 1; // aStr2 !== null\n  }\n\n  if (aStr2 === null) {\n    return -1; // aStr1 !== null\n  }\n\n  if (aStr1 > aStr2) {\n    return 1;\n  }\n\n  return -1;\n}\n\n/**\n * Comparator between two mappings with inflated source and name strings where\n * the generated positions are compared.\n */\nfunction compareByGeneratedPositionsInflated(mappingA, mappingB) {\n  let cmp = mappingA.generatedLine - mappingB.generatedLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = strcmp(mappingA.source, mappingB.source);\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalLine - mappingB.originalLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalColumn - mappingB.originalColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  return strcmp(mappingA.name, mappingB.name);\n}\nexports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;\n\n/**\n * Strip any JSON XSSI avoidance prefix from the string (as documented\n * in the source maps specification), and then parse the string as\n * JSON.\n */\nfunction parseSourceMapInput(str) {\n  return JSON.parse(str.replace(/^\\)]}'[^\\n]*\\n/, \"\"));\n}\nexports.parseSourceMapInput = parseSourceMapInput;\n\n/**\n * Compute the URL of a source given the the source root, the source's\n * URL, and the source map's URL.\n */\nfunction computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {\n  sourceURL = sourceURL || \"\";\n\n  if (sourceRoot) {\n    // This follows what Chrome does.\n    if (sourceRoot[sourceRoot.length - 1] !== \"/\" && sourceURL[0] !== \"/\") {\n      sourceRoot += \"/\";\n    }\n    // The spec says:\n    //   Line 4: An optional source root, useful for relocating source\n    //   files on a server or removing repeated values in the\n    //   sources entry.  This value is prepended to the individual\n    //   entries in the source field.\n    sourceURL = sourceRoot + sourceURL;\n  }\n\n  // Historically, SourceMapConsumer did not take the sourceMapURL as\n  // a parameter.  This mode is still somewhat supported, which is why\n  // this code block is conditional.  However, it's preferable to pass\n  // the source map URL to SourceMapConsumer, so that this function\n  // can implement the source URL resolution algorithm as outlined in\n  // the spec.  This block is basically the equivalent of:\n  //    new URL(sourceURL, sourceMapURL).toString()\n  // ... except it avoids using URL, which wasn't available in the\n  // older releases of node still supported by this library.\n  //\n  // The spec says:\n  //   If the sources are not absolute URLs after prepending of the\n  //   sourceRoot, the sources are resolved relative to the\n  //   SourceMap (like resolving script src in a html document).\n  if (sourceMapURL) {\n    const parsed = urlParse(sourceMapURL);\n    if (!parsed) {\n      throw new Error(\"sourceMapURL could not be parsed\");\n    }\n    if (parsed.path) {\n      // Strip the last path component, but keep the \"/\".\n      const index = parsed.path.lastIndexOf(\"/\");\n      if (index >= 0) {\n        parsed.path = parsed.path.substring(0, index + 1);\n      }\n    }\n    sourceURL = join(urlGenerate(parsed), sourceURL);\n  }\n\n  return normalize(sourceURL);\n}\nexports.computeSourceURL = computeSourceURL;\n","const readWasm = require(\"../lib/read-wasm\");\n\n/**\n * Provide the JIT with a nice shape / hidden class.\n */\nfunction Mapping() {\n  this.generatedLine = 0;\n  this.generatedColumn = 0;\n  this.lastGeneratedColumn = null;\n  this.source = null;\n  this.originalLine = null;\n  this.originalColumn = null;\n  this.name = null;\n}\n\nlet cachedWasm = null;\n\nmodule.exports = function wasm() {\n  if (cachedWasm) {\n    return cachedWasm;\n  }\n\n  const callbackStack = [];\n\n  cachedWasm = readWasm().then(buffer => {\n      return WebAssembly.instantiate(buffer, {\n        env: {\n          mapping_callback(\n            generatedLine,\n            generatedColumn,\n\n            hasLastGeneratedColumn,\n            lastGeneratedColumn,\n\n            hasOriginal,\n            source,\n            originalLine,\n            originalColumn,\n\n            hasName,\n            name\n          ) {\n            const mapping = new Mapping();\n            // JS uses 1-based line numbers, wasm uses 0-based.\n            mapping.generatedLine = generatedLine + 1;\n            mapping.generatedColumn = generatedColumn;\n\n            if (hasLastGeneratedColumn) {\n              // JS uses inclusive last generated column, wasm uses exclusive.\n              mapping.lastGeneratedColumn = lastGeneratedColumn - 1;\n            }\n\n            if (hasOriginal) {\n              mapping.source = source;\n              // JS uses 1-based line numbers, wasm uses 0-based.\n              mapping.originalLine = originalLine + 1;\n              mapping.originalColumn = originalColumn;\n\n              if (hasName) {\n                mapping.name = name;\n              }\n            }\n\n            callbackStack[callbackStack.length - 1](mapping);\n          },\n\n          start_all_generated_locations_for() { console.time(\"all_generated_locations_for\"); },\n          end_all_generated_locations_for() { console.timeEnd(\"all_generated_locations_for\"); },\n\n          start_compute_column_spans() { console.time(\"compute_column_spans\"); },\n          end_compute_column_spans() { console.timeEnd(\"compute_column_spans\"); },\n\n          start_generated_location_for() { console.time(\"generated_location_for\"); },\n          end_generated_location_for() { console.timeEnd(\"generated_location_for\"); },\n\n          start_original_location_for() { console.time(\"original_location_for\"); },\n          end_original_location_for() { console.timeEnd(\"original_location_for\"); },\n\n          start_parse_mappings() { console.time(\"parse_mappings\"); },\n          end_parse_mappings() { console.timeEnd(\"parse_mappings\"); },\n\n          start_sort_by_generated_location() { console.time(\"sort_by_generated_location\"); },\n          end_sort_by_generated_location() { console.timeEnd(\"sort_by_generated_location\"); },\n\n          start_sort_by_original_location() { console.time(\"sort_by_original_location\"); },\n          end_sort_by_original_location() { console.timeEnd(\"sort_by_original_location\"); },\n        }\n      });\n  }).then(Wasm => {\n    return {\n      exports: Wasm.instance.exports,\n      withMappingCallback: (mappingCallback, f) => {\n        callbackStack.push(mappingCallback);\n        try {\n          f();\n        } finally {\n          callbackStack.pop();\n        }\n      }\n    };\n  }).then(null, e => {\n    cachedWasm = null;\n    throw e;\n  });\n\n  return cachedWasm;\n};\n","/*\n * Copyright 2009-2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE.txt or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\nexports.SourceMapGenerator = require(\"./lib/source-map-generator\").SourceMapGenerator;\nexports.SourceMapConsumer = require(\"./lib/source-map-consumer\").SourceMapConsumer;\nexports.SourceNode = require(\"./lib/source-node\").SourceNode;\n","'use strict'\n\nconst analyticsSampler = require('../../dd-trace/src/analytics_sampler')\n\nfunction createWrapSend (tracer, config) {\n  return function wrapSend (send) {\n    return function sendWithTrace (msg, options) {\n      const span = startSendSpan(tracer, config, this)\n\n      try {\n        const promise = tracer.scope().activate(span, () => {\n          return send.apply(this, arguments)\n        })\n\n        return wrapPromise(promise, span)\n      } catch (e) {\n        finish(span, e)\n        throw e\n      }\n    }\n  }\n}\n\nfunction createWrapMessageReceived (tracer, config) {\n  return function wrapMessageReceived (messageReceived) {\n    return function messageReceivedWithTrace (transferFrame) {\n      if (!transferFrame || transferFrame.aborted || transferFrame.more) {\n        return messageReceived.apply(this, arguments)\n      }\n\n      const span = startReceiveSpan(tracer, config, this)\n\n      return tracer.scope().activate(span, () => {\n        messageReceived.apply(this, arguments)\n        span.finish()\n      })\n    }\n  }\n}\n\nfunction startSendSpan (tracer, config, link) {\n  const address = getAddress(link)\n  const target = getShortName(link)\n\n  const span = tracer.startSpan(`amqp.send`, {\n    tags: {\n      'resource.name': ['send', target].filter(v => v).join(' '),\n      'span.kind': 'producer',\n      'amqp.link.target.address': target,\n      'amqp.link.role': 'sender',\n      'out.host': address.host,\n      'out.port': address.port\n    }\n  })\n\n  addTags(tracer, config, span, link)\n\n  analyticsSampler.sample(span, config.analytics)\n\n  return span\n}\n\nfunction startReceiveSpan (tracer, config, link) {\n  const source = getShortName(link)\n  const span = tracer.startSpan(`amqp.receive`, {\n    tags: {\n      'resource.name': ['receive', source].filter(v => v).join(' '),\n      'span.kind': 'consumer',\n      'amqp.link.source.address': source,\n      'amqp.link.role': 'receiver'\n    }\n  })\n\n  addTags(tracer, config, span, link)\n\n  analyticsSampler.sample(span, config.analytics, true)\n\n  return span\n}\n\nfunction addTags (tracer, config, span, link = {}) {\n  const address = getAddress(link)\n\n  span.addTags({\n    'service.name': config.service || `${tracer._service}-amqp`,\n    'span.type': 'worker',\n    'amqp.link.name': link.name,\n    'amqp.link.handle': link.handle,\n    'amqp.connection.host': address.host,\n    'amqp.connection.port': address.port,\n    'amqp.connection.user': address.user\n  })\n\n  return span\n}\n\nfunction finish (span, error) {\n  if (error) {\n    span.addTags({\n      'error.type': error.name,\n      'error.msg': error.message,\n      'error.stack': error.stack\n    })\n  }\n\n  span.finish()\n}\n\nfunction wrapPromise (promise, span) {\n  if (!promise) {\n    finish(span)\n    return promise\n  }\n\n  promise.then(() => finish(span), e => finish(span, e))\n\n  return promise\n}\n\nfunction getShortName (link) {\n  if (!link || !link.name) return null\n\n  return link.name.split('_').slice(0, -1).join('_')\n}\n\nfunction getAddress (link) {\n  if (!link || !link.session || !link.session.connection) return {}\n\n  return link.session.connection.address || {}\n}\n\nmodule.exports = [\n  {\n    name: 'amqp10',\n    file: 'lib/sender_link.js',\n    versions: ['>=3'],\n    patch (SenderLink, tracer, config) {\n      this.wrap(SenderLink.prototype, 'send', createWrapSend(tracer, config))\n    },\n    unpatch (SenderLink) {\n      this.unwrap(SenderLink.prototype, 'send')\n    }\n  },\n  {\n    name: 'amqp10',\n    file: 'lib/receiver_link.js',\n    versions: ['>=3'],\n    patch (ReceiverLink, tracer, config) {\n      this.wrap(ReceiverLink.prototype, '_messageReceived', createWrapMessageReceived(tracer, config))\n    },\n    unpatch (ReceiverLink) {\n      this.unwrap(ReceiverLink.prototype, '_messageReceived')\n    }\n  }\n]\n","'use strict'\n\nconst kebabCase = require('lodash.kebabcase')\nconst analyticsSampler = require('../../dd-trace/src/analytics_sampler')\nconst { TEXT_MAP } = require('../../../ext/formats')\n\nlet methods = {}\n\nfunction createWrapSendImmediately (tracer, config) {\n  return function wrapSendImmediately (sendImmediately) {\n    return function sendImmediatelyWithTrace (method, fields) {\n      return sendWithTrace(sendImmediately, this, arguments, tracer, config, methods[method], fields)\n    }\n  }\n}\n\nfunction createWrapSendMessage (tracer, config) {\n  return function wrapSendMessage (sendMessage) {\n    return function sendMessageWithTrace (fields) {\n      return sendWithTrace(sendMessage, this, arguments, tracer, config, 'basic.publish', fields)\n    }\n  }\n}\n\nfunction createWrapDispatchMessage (tracer, config) {\n  return function wrapDispatchMessage (dispatchMessage) {\n    return function dispatchMessageWithTrace (fields, message) {\n      const childOf = extract(tracer, message)\n      const span = tracer.startSpan('amqp.command', { childOf })\n\n      addTags(this, tracer, config, span, 'basic.deliver', fields)\n\n      analyticsSampler.sample(span, config.analytics, true)\n\n      tracer.scope().activate(span, () => {\n        try {\n          dispatchMessage.apply(this, arguments)\n        } catch (e) {\n          throw addError(span, e)\n        } finally {\n          span.finish()\n        }\n      })\n    }\n  }\n}\n\nfunction sendWithTrace (send, channel, args, tracer, config, method, fields) {\n  const childOf = tracer.scope().active()\n  const span = tracer.startSpan('amqp.command', { childOf })\n\n  fields.headers = fields.headers || {}\n\n  addTags(channel, tracer, config, span, method, fields)\n  tracer.inject(span, TEXT_MAP, fields.headers)\n\n  analyticsSampler.sample(span, config.analytics)\n\n  return tracer.scope().activate(span, () => {\n    try {\n      return send.apply(channel, args)\n    } catch (e) {\n      throw addError(span, e)\n    } finally {\n      span.finish()\n    }\n  })\n}\n\nfunction isCamelCase (str) {\n  return /([A-Z][a-z0-9]+)+/.test(str)\n}\n\nfunction getResourceName (method, fields = {}) {\n  return [\n    method,\n    fields.exchange,\n    fields.routingKey,\n    fields.queue,\n    fields.source,\n    fields.destination\n  ].filter(val => val).join(' ')\n}\n\nfunction addError (span, error) {\n  span.addTags({\n    'error.type': error.name,\n    'error.msg': error.message,\n    'error.stack': error.stack\n  })\n\n  return error\n}\n\nfunction addTags (channel, tracer, config, span, method, fields) {\n  const fieldNames = [\n    'queue',\n    'exchange',\n    'routingKey',\n    'consumerTag',\n    'source',\n    'destination'\n  ]\n\n  span.addTags({\n    'service.name': config.service || `${tracer._service}-amqp`,\n    'resource.name': getResourceName(method, fields),\n    'span.type': 'worker'\n  })\n\n  if (channel && channel.connection && channel.connection.stream) {\n    span.addTags({\n      'out.host': channel.connection.stream._host,\n      'out.port': channel.connection.stream.remotePort\n    })\n  }\n\n  switch (method) {\n    case 'basic.publish':\n      span.setTag('span.kind', 'producer')\n      break\n    case 'basic.consume':\n    case 'basic.get':\n    case 'basic.deliver':\n      span.setTag('span.kind', 'consumer')\n      break\n  }\n\n  fieldNames.forEach(field => {\n    fields[field] !== undefined && span.setTag(`amqp.${field}`, fields[field])\n  })\n}\n\nfunction extract (tracer, message) {\n  return message\n    ? tracer.extract(TEXT_MAP, message.properties.headers)\n    : null\n}\n\nmodule.exports = [\n  {\n    name: 'amqplib',\n    file: 'lib/defs.js',\n    versions: ['>=0.5'],\n    patch (defs, tracer, config) {\n      methods = Object.keys(defs)\n        .filter(key => Number.isInteger(defs[key]))\n        .filter(key => isCamelCase(key))\n        .reduce((acc, key) => Object.assign(acc, { [defs[key]]: kebabCase(key).replace('-', '.') }), {})\n    },\n    unpatch (defs) {\n      methods = {}\n    }\n  },\n  {\n    name: 'amqplib',\n    file: 'lib/channel.js',\n    versions: ['>=0.5'],\n    patch (channel, tracer, config) {\n      this.wrap(channel.Channel.prototype, 'sendImmediately', createWrapSendImmediately(tracer, config))\n      this.wrap(channel.Channel.prototype, 'sendMessage', createWrapSendMessage(tracer, config))\n      this.wrap(channel.BaseChannel.prototype, 'dispatchMessage', createWrapDispatchMessage(tracer, config))\n    },\n    unpatch (channel) {\n      this.unwrap(channel.Channel.prototype, 'sendImmediately')\n      this.unwrap(channel.Channel.prototype, 'sendMessage')\n      this.unwrap(channel.BaseChannel.prototype, 'dispatchMessage')\n    }\n  }\n]\n","'use strict'\n\nconst Tags = require('opentracing').Tags\n\nconst services = {\n  cloudwatchlogs: getService('cloudwatchlogs'),\n  dynamodb: getService('dynamodb'),\n  kinesis: getService('kinesis'),\n  s3: getService('s3'),\n  redshift: getService('redshift'),\n  sns: getService('sns'),\n  sqs: getService('sqs')\n}\n\nfunction getService (serviceName) {\n  const Service = require(`./services/${serviceName}`)\n  return new Service()\n}\n\nconst helpers = {\n  finish (span, err) {\n    if (err) {\n      span.setTag('error', err)\n\n      if (err.requestId) {\n        span.addTags({ 'aws.response.request_id': err.requestId })\n      }\n    }\n\n    span.finish()\n  },\n\n  addResponseTags (span, response, serviceName, config) {\n    if (!span) return\n\n    if (response.request) {\n      this.addServicesTags(span, response, serviceName)\n    }\n\n    config.hooks.request(span, response)\n  },\n\n  addServicesTags (span, response, serviceName) {\n    if (!span) return\n\n    const params = response.request.params\n    const operation = response.request.operation\n    const extraTags = services[serviceName] ? services[serviceName].generateTags(params, operation, response) : {}\n    const tags = Object.assign({\n      'aws.response.request_id': response.requestId,\n      'resource.name': operation\n    }, extraTags)\n\n    span.addTags(tags)\n  },\n\n  responseExtract (serviceName, request, response, tracer) {\n    if (services[serviceName] && services[serviceName].responseExtract) {\n      const params = request.params\n      const operation = request.operation\n      return services[serviceName].responseExtract(params, operation, response, tracer)\n    }\n  },\n\n  requestInject (span, request, serviceName, tracer) {\n    if (!span) return\n\n    const inject = services[serviceName] && services[serviceName].requestInject\n    if (inject) inject(span, request, tracer)\n  },\n\n  wrapCb (cb, serviceName, tags, request, tracer, childOf) {\n    const awsHelpers = this\n    return function wrappedCb (err, resp) {\n      const maybeChildOf = awsHelpers.responseExtract(serviceName, request, resp, tracer)\n      if (maybeChildOf) {\n        const options = {\n          childOf: maybeChildOf,\n          tags: Object.assign({}, tags, { [Tags.SPAN_KIND]: 'server' })\n        }\n        return tracer.wrap('aws.response', options, cb).call(this, err, resp)\n      } else {\n        return tracer.scope().bind(cb, childOf).call(this, err, resp)\n      }\n    }\n  }\n}\n\nmodule.exports = helpers\n","'use strict'\n\nconst Tags = require('opentracing').Tags\nconst analyticsSampler = require('../../dd-trace/src/analytics_sampler')\nconst awsHelpers = require('./helpers')\n\nfunction createWrapRequest (tracer, config) {\n  config = normalizeConfig(config)\n\n  return function wrapRequest (send) {\n    return function requestWithTrace (cb) {\n      if (!this.service) return send.apply(this, arguments)\n\n      const serviceIdentifier = this.service.serviceIdentifier\n      const serviceName = getServiceName(serviceIdentifier, tracer, config)\n      const childOf = tracer.scope().active()\n      const tags = {\n        [Tags.SPAN_KIND]: 'client',\n        'service.name': serviceName,\n        'aws.operation': this.operation,\n        'aws.region': this.service.config && this.service.config.region,\n        'aws.service': this.service.api && this.service.api.className,\n        'component': 'aws-sdk'\n      }\n\n      const span = tracer.startSpan('aws.request', {\n        childOf,\n        tags\n      })\n\n      this.on('complete', response => {\n        if (!span) return\n\n        awsHelpers.addResponseTags(span, response, serviceIdentifier, config, tracer)\n        awsHelpers.finish(span, response.error)\n      })\n\n      analyticsSampler.sample(span, config.analytics)\n\n      awsHelpers.requestInject(span, this, serviceIdentifier, tracer)\n\n      const request = this\n\n      return tracer.scope().activate(span, () => {\n        let boundCb\n        if (typeof cb === 'function') {\n          boundCb = awsHelpers.wrapCb(cb, serviceIdentifier, tags, request, tracer, childOf)\n        } else {\n          boundCb = cb\n        }\n        return send.call(this, boundCb)\n      })\n    }\n  }\n}\n\nfunction createWrapSetPromisesDependency (tracer, config, instrumenter, AWS) {\n  return function wrapSetPromisesDependency (setPromisesDependency) {\n    return function setPromisesDependencyWithTrace (dep) {\n      const result = setPromisesDependency.apply(this, arguments)\n\n      instrumenter.wrap(AWS.Request.prototype, 'promise', createWrapRequest(tracer, config))\n\n      return result\n    }\n  }\n}\n\nfunction normalizeConfig (config) {\n  const hooks = getHooks(config)\n\n  return Object.assign({}, config, {\n    splitByAwsService: config.splitByAwsService !== false,\n    hooks\n  })\n}\n\nfunction getHooks (config) {\n  const noop = () => {}\n  const request = (config.hooks && config.hooks.request) || noop\n\n  return { request }\n}\n\n// TODO: test splitByAwsService when the test suite is fixed\nfunction getServiceName (serviceIdentifier, tracer, config) {\n  const service = config.service || tracer._service\n\n  return config.splitByAwsService\n    ? `${service}-aws-${serviceIdentifier}`\n    : service\n}\n\n// <2.1.35 has breaking changes for instrumentation\n// https://github.com/aws/aws-sdk-js/pull/629\nmodule.exports = [\n  {\n    name: 'aws-sdk',\n    versions: ['>=2.3.0'],\n    patch (AWS, tracer, config) {\n      this.wrap(AWS.Request.prototype, 'promise', createWrapRequest(tracer, config))\n      this.wrap(AWS.config, 'setPromisesDependency', createWrapSetPromisesDependency(tracer, config, this, AWS))\n    },\n    unpatch (AWS) {\n      this.unwrap(AWS.Request.prototype, 'promise')\n      this.unwrap(AWS.config, 'setPromisesDependency')\n    }\n  },\n  {\n    name: 'aws-sdk',\n    versions: ['>=2.1.35'],\n    patch (AWS, tracer, config) {\n      this.wrap(AWS.Request.prototype, 'send', createWrapRequest(tracer, config))\n    },\n    unpatch (AWS) {\n      this.wrap(AWS.Request.prototype, 'send')\n    }\n  }\n]\n","var map = {\n\t\"./cloudwatchlogs\": \"../../node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/services/cloudwatchlogs.js\",\n\t\"./cloudwatchlogs.js\": \"../../node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/services/cloudwatchlogs.js\",\n\t\"./dynamodb\": \"../../node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/services/dynamodb.js\",\n\t\"./dynamodb.js\": \"../../node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/services/dynamodb.js\",\n\t\"./kinesis\": \"../../node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/services/kinesis.js\",\n\t\"./kinesis.js\": \"../../node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/services/kinesis.js\",\n\t\"./redshift\": \"../../node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/services/redshift.js\",\n\t\"./redshift.js\": \"../../node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/services/redshift.js\",\n\t\"./s3\": \"../../node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/services/s3.js\",\n\t\"./s3.js\": \"../../node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/services/s3.js\",\n\t\"./sns\": \"../../node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/services/sns.js\",\n\t\"./sns.js\": \"../../node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/services/sns.js\",\n\t\"./sqs\": \"../../node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/services/sqs.js\",\n\t\"./sqs.js\": \"../../node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/services/sqs.js\"\n};\n\n\nfunction webpackContext(req) {\n\tvar id = webpackContextResolve(req);\n\treturn __webpack_require__(id);\n}\nfunction webpackContextResolve(req) {\n\tif(!__webpack_require__.o(map, req)) {\n\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t}\n\treturn map[req];\n}\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = \"../../node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/services sync recursive ^\\\\.\\\\/.*$\";","'use strict'\n\nclass Kinesis {\n  generateTags (params, operation, response) {\n    const tags = {}\n\n    if (!params || !params.StreamName) return tags\n\n    return Object.assign(tags, {\n      'resource.name': `${operation} ${params.StreamName}`,\n      'aws.kinesis.stream_name': params.StreamName\n    })\n  }\n}\n\nmodule.exports = Kinesis\n","'use strict'\n\nclass Sns {\n  generateTags (params, operation, response) {\n    const tags = {}\n\n    if (!params) return tags\n\n    if (!params.TopicArn && !(response.data && response.data.TopicArn)) return tags\n\n    return Object.assign(tags, {\n      'resource.name': `${operation} ${params.TopicArn || response.data.TopicArn}`,\n      'aws.sns.topic_arn': params.TopicArn || response.data.TopicArn\n    })\n\n    // TODO: should arn be sanitized or quantized in some way here,\n    // for example if it contains a phone number?\n  }\n}\n\nmodule.exports = Sns\n","'use strict'\n\nconst log = require('../../../dd-trace/src/log')\n\nclass Sqs {\n  generateTags (params, operation, response) {\n    const tags = {}\n\n    if (!params || (!params.QueueName && !params.QueueUrl)) return tags\n\n    return Object.assign(tags, {\n      'resource.name': `${operation} ${params.QueueName || params.QueueUrl}`,\n      'aws.sqs.queue_name': params.QueueName || params.QueueUrl\n    })\n  }\n\n  responseExtract (params, operation, response, tracer) {\n    if (operation === 'receiveMessage') {\n      if (\n        (!params.MaxNumberOfMessages || params.MaxNumberOfMessages === 1) &&\n        response &&\n        response.Messages &&\n        response.Messages[0] &&\n        response.Messages[0].MessageAttributes &&\n        response.Messages[0].MessageAttributes._datadog &&\n        response.Messages[0].MessageAttributes._datadog.StringValue\n      ) {\n        const textMap = response.Messages[0].MessageAttributes._datadog.StringValue\n        try {\n          return tracer.extract('text_map', JSON.parse(textMap))\n        } catch (err) {\n          log.error(err)\n          return undefined\n        }\n      }\n    }\n  }\n\n  requestInject (span, request, tracer) {\n    const operation = request.operation\n    if (operation === 'sendMessage') {\n      if (!request.params) {\n        request.params = {}\n      }\n      if (!request.params.MessageAttributes) {\n        request.params.MessageAttributes = {}\n      } else if (Object.keys(request.params.MessageAttributes).length >= 10) { // SQS quota\n        // TODO: add test when the test suite is fixed\n        return\n      }\n      const ddInfo = {}\n      tracer.inject(span, 'text_map', ddInfo)\n      request.params.MessageAttributes._datadog = {\n        DataType: 'String',\n        StringValue: JSON.stringify(ddInfo)\n      }\n    }\n  }\n}\n\nmodule.exports = Sqs\n","'use strict'\n\nconst tx = require('../../dd-trace/src/plugins/util/promise')\n\nconst DD_LIB_COPIES = '_datadog_library_copies'\n\nfunction createGetNewLibraryCopyWrap (tracer, config, originalLib, shim) {\n  return function wrapGetNewLibraryCopy (getNewLibraryCopy) {\n    return function getNewLibraryCopyWithTrace () {\n      const libraryCopy = getNewLibraryCopy.apply(this, arguments)\n      shim.wrap(libraryCopy.prototype, '_then', tx.createWrapThen(tracer, config))\n      shim.wrap(libraryCopy, 'getNewLibraryCopy', createGetNewLibraryCopyWrap(tracer, config, originalLib, shim))\n      addToLibraryCopies(originalLib, libraryCopy)\n      return libraryCopy\n    }\n  }\n}\n\nfunction addToLibraryCopies (originalLib, libraryCopy) {\n  let libraryCopies = originalLib[DD_LIB_COPIES]\n\n  if (!libraryCopies) {\n    libraryCopies = new Set()\n\n    Object.defineProperty(originalLib, DD_LIB_COPIES, {\n      writable: true,\n      configurable: true,\n      value: libraryCopies\n    })\n  }\n  libraryCopies.add(libraryCopy)\n}\n\nfunction unwrapLibraryCopies (originalLib, shim) {\n  const libraryCopies = originalLib[DD_LIB_COPIES]\n\n  if (libraryCopies) {\n    libraryCopies.forEach(libraryCopy => {\n      shim.unwrap(libraryCopy.prototype, '_then')\n      shim.unwrap(libraryCopy, 'getNewLibraryCopy')\n    })\n    libraryCopies.clear()\n    delete originalLib[DD_LIB_COPIES]\n  }\n}\n\nmodule.exports = [\n  {\n    name: 'bluebird',\n    versions: ['^2.11.0', '^3.4.1'],\n    patch (Promise, tracer, config) {\n      this.wrap(Promise, 'getNewLibraryCopy', createGetNewLibraryCopyWrap(tracer, config, Promise, this))\n    },\n    unpatch (Promise) {\n      this.unwrap(Promise, 'getNewLibraryCopy')\n      unwrapLibraryCopies(Promise, this)\n    }\n  },\n  {\n    name: 'bluebird',\n    versions: ['>=2.0.2'], // 2.0.0 and 2.0.1 were removed from npm\n    patch (Promise, tracer, config) {\n      this.wrap(Promise.prototype, '_then', tx.createWrapThen(tracer, config))\n    },\n    unpatch (Promise) {\n      this.unwrap(Promise.prototype, '_then')\n    }\n  }\n]\n","'use strict'\n\nconst { LOG } = require('../../../ext/formats')\n\nfunction createWrapEmit (tracer, config) {\n  return function wrapEmit (emit) {\n    return function emitWithTrace (rec, noemit) {\n      const span = tracer.scope().active()\n\n      tracer.inject(span, LOG, rec)\n\n      return emit.apply(this, arguments)\n    }\n  }\n}\n\nmodule.exports = {\n  name: 'bunyan',\n  versions: ['>=1'],\n  patch (Logger, tracer, config) {\n    if (!tracer._logInjection) return\n    this.wrap(Logger.prototype, '_emit', createWrapEmit(tracer, config))\n  },\n  unpatch (Logger) {\n    this.unwrap(Logger.prototype, '_emit')\n  }\n}\n","'use strict'\n\nconst tx = require('../../dd-trace/src/plugins/util/tx')\n\nfunction createWrapInnerExecute (tracer, config) {\n  const isValid = (args) => {\n    return args.length === 4 || typeof args[3] === 'function'\n  }\n\n  return function wrapInnerExecute (_innerExecute) {\n    return function _innerExecuteWithTrace (query, params, execOptions, callback) {\n      if (!isValid(arguments)) {\n        return _innerExecute.apply(this, arguments)\n      }\n\n      const scope = tracer.scope()\n      const childOf = scope.active()\n      const span = start(tracer, config, this, query)\n\n      callback = scope.bind(callback, childOf)\n\n      return scope.bind(_innerExecute, span).call(this, query, params, execOptions, function (err) {\n        finish(span, err)\n        return callback.apply(this, arguments)\n      })\n    }\n  }\n}\nfunction createWrapExecute (tracer, config) {\n  return function wrapExecute (_execute) {\n    return function _executeWithTrace (query, params, execOptions, callback) {\n      const span = start(tracer, config, this, query)\n      const promise = tracer.scope().bind(_execute, span).apply(this, arguments)\n\n      return tx.wrap(span, promise)\n    }\n  }\n}\n\nfunction createWrapExecutionStart (tracer, config) {\n  return function wrapExecutionStart (start) {\n    return function startWithTrace (getHostCallback) {\n      const span = tracer.scope().active()\n      const execution = this\n\n      if (!isRequestValid(this, arguments, 1, span)) {\n        return start.apply(this, arguments)\n      }\n\n      return start.call(this, function () {\n        addHost(span, execution._connection)\n        return getHostCallback.apply(this, arguments)\n      })\n    }\n  }\n}\n\nfunction createWrapSendOnConnection (tracer, config) {\n  return function wrapSendOnConnection (_sendOnConnection) {\n    return function _sendOnConnectionWithTrace () {\n      const span = tracer.scope().active()\n\n      addHost(span, this._connection)\n\n      return _sendOnConnection.apply(this, arguments)\n    }\n  }\n}\n\nfunction createWrapSend (tracer, config) {\n  return function wrapSend (send) {\n    return function sendWithTrace (request, options, callback) {\n      const span = tracer.scope().active()\n      const handler = this\n\n      if (!isRequestValid(this, arguments, 3, span)) {\n        return send.apply(this, arguments)\n      }\n\n      return send.call(this, request, options, function () {\n        addHost(span, handler.connection)\n        return callback.apply(this, arguments)\n      })\n    }\n  }\n}\n\nfunction createWrapBatch (tracer, config) {\n  return function wrapBatch (batch) {\n    return function batchWithTrace (queries, options, callback) {\n      const query = combine(queries)\n      const span = start(tracer, config, this, query)\n      const scope = tracer.scope()\n      const fn = scope.bind(batch, span)\n\n      callback = arguments[arguments.length - 1]\n\n      if (typeof callback === 'function') {\n        arguments[arguments.length - 1] = tx.wrap(span, callback)\n      }\n\n      try {\n        return tx.wrap(span, fn.apply(this, arguments))\n      } catch (e) {\n        finish(span, e)\n        throw e\n      }\n    }\n  }\n}\n\nfunction createWrapStream (tracer, config) {\n  return function wrapStream (stream) {\n    return function streamWithTrace (query, params, options, callback) {\n      return tracer.scope().bind(stream.apply(this, arguments))\n    }\n  }\n}\n\nfunction start (tracer, config, client = {}, query) {\n  const scope = tracer.scope()\n  const childOf = scope.active()\n  const span = tracer.startSpan('cassandra.query', {\n    childOf,\n    tags: {\n      'service.name': config.service || `${tracer._service}-cassandra`,\n      'resource.name': trim(query, 5000),\n      'span.type': 'cassandra',\n      'span.kind': 'client',\n      'db.type': 'cassandra',\n      'cassandra.query': query,\n      'cassandra.keyspace': client.keyspace\n    }\n  })\n\n  return span\n}\n\nfunction finish (span, error) {\n  addError(span, error)\n\n  span.finish()\n\n  return error\n}\n\nfunction addTag (span, key, value) {\n  if (value) {\n    span.setTag(key, value)\n  }\n}\n\nfunction addHost (span, connection) {\n  if (span && connection) {\n    addTag(span, 'out.host', connection.address)\n    addTag(span, 'out.port', connection.port)\n  }\n}\n\nfunction addError (span, error) {\n  if (error && error instanceof Error) {\n    span.addTags({\n      'error.type': error.name,\n      'error.msg': error.message,\n      'error.stack': error.stack\n    })\n  }\n\n  return error\n}\n\nfunction isRequestValid (exec, args, length, span) {\n  if (!exec) return false\n  if (args.length !== length || typeof args[length - 1] !== 'function') return false\n  if (!span || span.context()._name !== 'cassandra.query') return false\n\n  return true\n}\n\nfunction combine (queries) {\n  if (!Array.isArray(queries)) return []\n\n  return queries\n    .map(query => (query.query || query).replace(/;?$/, ';'))\n    .join(' ')\n}\n\nfunction trim (str, size) {\n  if (!str || str.length <= size) return str\n\n  return `${str.substr(0, size - 3)}...`\n}\n\nmodule.exports = [\n  {\n    name: 'cassandra-driver',\n    versions: ['>=3.0.0'],\n    patch (cassandra, tracer, config) {\n      this.wrap(cassandra.Client.prototype, 'batch', createWrapBatch(tracer, config))\n      this.wrap(cassandra.Client.prototype, 'stream', createWrapStream(tracer, config))\n    },\n    unpatch (cassandra) {\n      this.unwrap(cassandra.Client.prototype, 'batch')\n      this.unwrap(cassandra.Client.prototype, 'stream')\n    }\n  },\n  {\n    name: 'cassandra-driver',\n    versions: ['>=4.4'],\n    patch (cassandra, tracer, config) {\n      this.wrap(cassandra.Client.prototype, '_execute', createWrapExecute(tracer, config))\n    },\n    unpatch (cassandra) {\n      this.unwrap(cassandra.Client.prototype, '_execute')\n    }\n  },\n  {\n    name: 'cassandra-driver',\n    versions: ['3 - 4.3'],\n    patch (cassandra, tracer, config) {\n      this.wrap(cassandra.Client.prototype, '_innerExecute', createWrapInnerExecute(tracer, config))\n    },\n    unpatch (cassandra) {\n      this.unwrap(cassandra.Client.prototype, '_innerExecute')\n    }\n  },\n  {\n    name: 'cassandra-driver',\n    versions: ['>=3.3'],\n    file: 'lib/request-execution.js',\n    patch (RequestExecution, tracer, config) {\n      this.wrap(RequestExecution.prototype, '_sendOnConnection', createWrapSendOnConnection(tracer, config))\n    },\n    unpatch (RequestExecution) {\n      this.unwrap(RequestExecution.prototype, '_sendOnConnection')\n    }\n  },\n  {\n    name: 'cassandra-driver',\n    versions: ['3.3 - 4.3'],\n    file: 'lib/request-execution.js',\n    patch (RequestExecution, tracer, config) {\n      this.wrap(RequestExecution.prototype, 'start', createWrapExecutionStart(tracer, config))\n    },\n    unpatch (RequestExecution) {\n      this.unwrap(RequestExecution.prototype, 'start')\n    }\n  },\n  {\n    name: 'cassandra-driver',\n    versions: ['3 - 3.2'],\n    file: 'lib/request-handler.js',\n    patch (RequestHandler, tracer, config) {\n      this.wrap(RequestHandler.prototype, 'send', createWrapSend(tracer, config))\n    },\n    unpatch (RequestHandler) {\n      this.unwrap(RequestHandler.prototype, 'send')\n    }\n  }\n]\n","'use strict'\n\nconst Tags = require('../../../ext/tags')\nconst Kinds = require('../../../ext/kinds')\nconst analyticsSampler = require('../../dd-trace/src/analytics_sampler')\n\nfunction startQuerySpan (tracer, config, query) {\n  const childOf = tracer.scope().active()\n  const span = tracer.startSpan('couchbase.query', {\n    childOf,\n    tags: {\n      'db.type': 'couchbase',\n      'span.type': 'sql',\n      'component': 'couchbase',\n      'service.name': config.service || `${tracer._service}-couchbase`,\n      'resource.name': query,\n      [Tags.SPAN_KIND]: Kinds.CLIENT\n    }\n  })\n\n  analyticsSampler.sample(span, config.analytics)\n\n  return span\n}\n\nfunction onRequestFinish (emitter, span) {\n  emitter.once('rows', () => {\n    span.finish()\n  })\n  emitter.once('error', (err) => {\n    span.setTag(Tags.ERROR, err)\n    span.finish()\n  })\n}\n\nfunction createWrapMaybeInvoke (tracer) {\n  return function wrapMaybeInvoke (_maybeInvoke) {\n    return function maybeInvokeWithTrace (fn, args) {\n      if (!Array.isArray(args)) return _maybeInvoke.apply(this, arguments)\n\n      const scope = tracer.scope()\n      const callbackIndex = args.length - 1\n      const callback = args[callbackIndex]\n\n      if (callback instanceof Function) {\n        args[callbackIndex] = scope.bind(callback)\n      }\n\n      return scope.bind(_maybeInvoke).apply(this, arguments)\n    }\n  }\n}\n\nfunction createWrapQuery (tracer) {\n  return function wrapQuery (query) {\n    return function queryWithTrace (q, params, callback) {\n      const scope = tracer.scope()\n\n      callback = arguments[arguments.length - 1]\n\n      if (typeof callback === 'function') {\n        arguments[arguments.length - 1] = scope.bind(callback)\n      }\n\n      return scope.bind(query.apply(this, arguments))\n    }\n  }\n}\n\nfunction createWrapN1qlReq (tracer, config) {\n  return function wrapN1qlReq (_n1qlReq) {\n    return function n1qlReqWithTrace (host, q, adhoc, emitter) {\n      if (!emitter || !emitter.once) return _n1qlReq.apply(this, arguments)\n\n      const scope = tracer.scope()\n      const n1qlQuery = q && q.statement\n      const span = startQuerySpan(tracer, config, n1qlQuery)\n\n      addBucketTag(span, this)\n      onRequestFinish(emitter, span)\n\n      return scope.bind(_n1qlReq, span).apply(this, arguments)\n    }\n  }\n}\n\nfunction addBucketTag (span, bucket) {\n  span.setTag('couchbase.bucket.name', bucket.name || bucket._name)\n}\n\nfunction wrapRequests (Class, tracer, config) {\n  this.wrap(Class.prototype, '_n1qlReq', createWrapN1qlReq(tracer, config))\n}\n\nfunction unwrapRequests (Class) {\n  this.unwrap(Class.prototype, '_n1qlReq')\n}\n\nfunction wrapCouchbase (Class, tracer, config) {\n  this.wrap(Class.prototype, '_maybeInvoke', createWrapMaybeInvoke(tracer, config))\n  this.wrap(Class.prototype, 'query', createWrapQuery(tracer))\n}\n\nfunction unwrapCouchbase (Class) {\n  this.unwrap(Class.prototype, '_maybeInvoke')\n  this.unwrap(Class.prototype, 'query')\n}\n\nmodule.exports = [\n  {\n    name: 'couchbase',\n    versions: ['^2.4.2'],\n    file: 'lib/bucket.js',\n    patch (Bucket, tracer, config) {\n      tracer.scope().bind(Bucket.prototype)\n\n      wrapCouchbase.call(this, Bucket, tracer, config)\n      wrapRequests.call(this, Bucket, tracer, config)\n    },\n    unpatch (Bucket, tracer) {\n      tracer.scope().unbind(Bucket.prototype)\n\n      unwrapCouchbase.call(this, Bucket)\n      unwrapRequests.call(this, Bucket)\n    }\n  },\n  {\n    name: 'couchbase',\n    versions: ['^2.4.2'],\n    file: 'lib/cluster.js',\n    patch: wrapCouchbase,\n    unpatch: unwrapCouchbase\n  }\n]\n","'use strict'\n\nconst analyticsSampler = require('../../dd-trace/src/analytics_sampler')\nconst tx = require('../../dd-trace/src/plugins/util/tx')\n\nconst rrtypes = {\n  resolveAny: 'ANY',\n  resolve4: 'A',\n  resolve6: 'AAAA',\n  resolveCname: 'CNAME',\n  resolveMx: 'MX',\n  resolveNs: 'NS',\n  resolveTxt: 'TXT',\n  resolveSrv: 'SRV',\n  resolvePtr: 'PTR',\n  resolveNaptr: 'NAPTR',\n  resolveSoa: 'SOA'\n}\n\nfunction createWrapLookup (tracer, config) {\n  return function wrapLookup (lookup) {\n    return function lookupWithTrace (hostname, options, callback) {\n      if (!isArgsValid(arguments, 2)) return lookup.apply(this, arguments)\n\n      const span = startSpan(tracer, config, 'dns.lookup', {\n        'resource.name': hostname,\n        'dns.hostname': hostname\n      })\n\n      wrapArgs(span, arguments, (e, address) => {\n        span.setTag('dns.address', address)\n      })\n\n      return tracer.scope().activate(span, () => lookup.apply(this, arguments))\n    }\n  }\n}\n\nfunction createWrapLookupService (tracer, config) {\n  return function wrapLookupService (lookupService) {\n    return function lookupServiceWithTrace (address, port, callback) {\n      if (!isArgsValid(arguments, 3)) return lookupService.apply(this, arguments)\n\n      const span = startSpan(tracer, config, 'dns.lookup_service', {\n        'resource.name': `${address}:${port}`,\n        'dns.address': address,\n        'dns.port': port\n      })\n\n      wrapArgs(span, arguments)\n\n      return tracer.scope().activate(span, () => lookupService.apply(this, arguments))\n    }\n  }\n}\n\nfunction createWrapResolve (tracer, config) {\n  return function wrapResolve (resolve) {\n    return function resolveWithTrace (hostname, rrtype, callback) {\n      if (!isArgsValid(arguments, 2)) return resolve.apply(this, arguments)\n\n      if (typeof rrtype !== 'string') {\n        rrtype = 'A'\n      }\n\n      const span = wrapResolver(tracer, config, rrtype, arguments)\n\n      return tracer.scope().activate(span, () => resolve.apply(this, arguments))\n    }\n  }\n}\n\nfunction createWrapResolver (tracer, config, rrtype) {\n  return function wrapResolve (resolve) {\n    return function resolveWithTrace (hostname, callback) {\n      if (!isArgsValid(arguments, 2)) return resolve.apply(this, arguments)\n\n      const span = wrapResolver(tracer, config, rrtype, arguments)\n\n      return tracer.scope().activate(span, () => resolve.apply(this, arguments))\n    }\n  }\n}\n\nfunction createWrapReverse (tracer, config) {\n  return function wrapReverse (reverse) {\n    return function reverseWithTrace (ip, callback) {\n      if (!isArgsValid(arguments, 2)) return reverse.apply(this, arguments)\n\n      const span = startSpan(tracer, config, 'dns.reverse', {\n        'resource.name': ip,\n        'dns.ip': ip\n      })\n\n      wrapArgs(span, arguments)\n\n      return tracer.scope().activate(span, () => reverse.apply(this, arguments))\n    }\n  }\n}\n\nfunction startSpan (tracer, config, operation, tags) {\n  const childOf = tracer.scope().active()\n  const span = tracer.startSpan(operation, {\n    childOf,\n    tags: Object.assign({\n      'span.kind': 'client',\n      'service.name': config.service || `${tracer._service}-dns`\n    }, tags)\n  })\n\n  analyticsSampler.sample(span, config.analytics)\n\n  return span\n}\n\nfunction isArgsValid (args, minLength) {\n  if (args.length < minLength) return false\n  if (typeof args[args.length - 1] !== 'function') return false\n\n  return true\n}\n\nfunction wrapArgs (span, args, callback) {\n  const original = args[args.length - 1]\n  const fn = tx.wrap(span, original)\n\n  args[args.length - 1] = function () {\n    callback && callback.apply(null, arguments)\n    return fn.apply(this, arguments)\n  }\n}\n\nfunction wrapResolver (tracer, config, rrtype, args) {\n  const hostname = args[0]\n  const span = startSpan(tracer, config, 'dns.resolve', {\n    'resource.name': `${rrtype} ${hostname}`,\n    'dns.hostname': hostname,\n    'dns.rrtype': rrtype\n  })\n\n  wrapArgs(span, args)\n\n  return span\n}\n\nfunction patchResolveShorthands (tracer, config, shim, prototype) {\n  Object.keys(rrtypes)\n    .filter(method => !!prototype[method])\n    .forEach(method => {\n      shim.wrap(prototype, method, createWrapResolver(tracer, config, rrtypes[method]))\n    })\n}\n\nfunction unpatchResolveShorthands (shim, prototype) {\n  Object.keys(rrtypes)\n    .filter(method => !!prototype[method])\n    .forEach(method => {\n      shim.unwrap(prototype, method)\n    })\n}\n\nmodule.exports = [\n  {\n    name: 'dns',\n    patch (dns, tracer, config) {\n      this.wrap(dns, 'lookup', createWrapLookup(tracer, config))\n      this.wrap(dns, 'lookupService', createWrapLookupService(tracer, config))\n      this.wrap(dns, 'resolve', createWrapResolve(tracer, config))\n      this.wrap(dns, 'reverse', createWrapReverse(tracer, config))\n\n      patchResolveShorthands(tracer, config, this, dns)\n\n      if (dns.Resolver) {\n        this.wrap(dns.Resolver.prototype, 'resolve', createWrapResolve(tracer, config))\n        this.wrap(dns.Resolver.prototype, 'reverse', createWrapReverse(tracer, config))\n\n        patchResolveShorthands(tracer, config, this, dns.Resolver.prototype)\n      }\n    },\n    unpatch (dns) {\n      this.unwrap(dns, [\n        'lookup',\n        'lookupService',\n        'resolve',\n        'reverse'\n      ])\n\n      unpatchResolveShorthands(this, dns)\n\n      if (dns.Resolver) {\n        this.unwrap(dns.prototype.Resolver, [\n          'resolve',\n          'reverse'\n        ])\n\n        unpatchResolveShorthands(this, dns.Resolver.prototype)\n      }\n    }\n  }\n]\n","'use strict'\n\nconst Tags = require('opentracing').Tags\nconst analyticsSampler = require('../../dd-trace/src/analytics_sampler')\n\nfunction createWrapRequest (tracer, config) {\n  config = normalizeConfig(config)\n  return function wrapRequest (request) {\n    return function requestWithTrace (params, options, cb) {\n      if (!params) return request.apply(this, arguments)\n\n      const childOf = tracer.scope().active()\n      const span = tracer.startSpan('elasticsearch.query', {\n        childOf,\n        tags: {\n          [Tags.SPAN_KIND]: Tags.SPAN_KIND_RPC_CLIENT,\n          [Tags.DB_TYPE]: 'elasticsearch',\n          'service.name': config.service || `${tracer._service}-elasticsearch`,\n          'resource.name': `${params.method} ${quantizePath(params.path)}`,\n          'span.type': 'elasticsearch',\n          'elasticsearch.url': params.path,\n          'elasticsearch.method': params.method,\n          'elasticsearch.params': JSON.stringify(params.querystring || params.query)\n        }\n      })\n\n      if (params.body) {\n        span.setTag('elasticsearch.body', JSON.stringify(params.body))\n      }\n\n      analyticsSampler.sample(span, config.analytics)\n\n      cb = request.length === 2 || typeof options === 'function'\n        ? tracer.scope().bind(options, childOf)\n        : tracer.scope().bind(cb, childOf)\n\n      return tracer.scope().activate(span, () => {\n        if (typeof cb === 'function') {\n          if (request.length === 2) {\n            return request.call(this, params, wrapCallback(tracer, span, params, config, cb))\n          } else {\n            return request.call(this, params, options, wrapCallback(tracer, span, params, config, cb))\n          }\n        } else {\n          const promise = request.apply(this, arguments)\n\n          if (promise && typeof promise.then === 'function') {\n            promise.then(() => finish(span, params, config), e => finish(span, params, config, e))\n          } else {\n            finish(span, params, config)\n          }\n\n          return promise\n        }\n      })\n    }\n  }\n}\n\nfunction wrapCallback (tracer, span, params, config, done) {\n  return function (err) {\n    finish(span, params, config, err)\n    done.apply(null, arguments)\n  }\n}\n\nfunction finish (span, params, config, err) {\n  if (err) {\n    span.addTags({\n      'error.type': err.name,\n      'error.msg': err.message,\n      'error.stack': err.stack\n    })\n  }\n\n  config.hooks.query(span, params)\n\n  span.finish()\n}\n\nfunction quantizePath (path) {\n  return path && path.replace(/[0-9]+/g, '?')\n}\n\nfunction normalizeConfig (config) {\n  const hooks = getHooks(config)\n\n  return Object.assign({}, config, {\n    hooks\n  })\n}\n\nfunction getHooks (config) {\n  const noop = () => {}\n  const query = (config.hooks && config.hooks.query) || noop\n\n  return { query }\n}\n\nmodule.exports = [\n  {\n    name: 'elasticsearch',\n    file: 'src/lib/transport.js',\n    versions: ['>=10'],\n    patch (Transport, tracer, config) {\n      this.wrap(Transport.prototype, 'request', createWrapRequest(tracer, config))\n    },\n    unpatch (Transport) {\n      this.unwrap(Transport.prototype, 'request')\n    }\n  },\n  {\n    name: '@elastic/elasticsearch',\n    file: 'lib/Transport.js',\n    versions: ['>=5.6.16'], // initial version of this module\n    patch (Transport, tracer, config) {\n      this.wrap(Transport.prototype, 'request', createWrapRequest(tracer, config))\n    },\n    unpatch (Transport) {\n      this.unwrap(Transport.prototype, 'request')\n    }\n  }\n]\n","'use strict'\n\nconst methods = require('methods').concat('all')\nconst web = require('../../dd-trace/src/plugins/util/web')\n\nfunction createWrapFastify (tracer, config) {\n  config = web.normalizeConfig(config)\n\n  return function wrapFastify (fastify) {\n    if (typeof fastify !== 'function') return fastify\n\n    return function fastifyWithTrace () {\n      const app = fastify.apply(this, arguments)\n\n      if (!app) return app\n\n      if (typeof app.addHook === 'function') {\n        app.addHook('onRequest', createOnRequest(tracer, config))\n        app.addHook('preHandler', preHandler)\n      }\n\n      methods.forEach(method => {\n        app[method] = wrapMethod(app[method])\n      })\n\n      app.route = wrapRoute(app.route)\n\n      return app\n    }\n  }\n}\n\nfunction createOnRequest (tracer, config) {\n  return function onRequest (request, reply, next) {\n    if (typeof next !== 'function') return\n\n    const req = getReq(request)\n    const res = getRes(reply)\n    const name = 'fastify.request'\n\n    return web.instrument(tracer, config, req, res, name, () => next())\n  }\n}\n\nfunction preHandler (request, reply, next) {\n  if (typeof next !== 'function') return\n  if (!reply || typeof reply.send !== 'function') return next()\n\n  reply.send = wrapSend(reply.send)\n\n  next()\n}\n\nfunction wrapSend (send) {\n  return function sendWithTrace (payload) {\n    const req = getReq(this && this.request)\n\n    web.addError(req, payload)\n\n    return send.apply(this, arguments)\n  }\n}\n\nfunction wrapRoute (route) {\n  if (typeof route !== 'function') return route\n\n  return function routeWithTrace (opts) {\n    opts.handler = wrapHandler(opts.handler)\n\n    return route.apply(this, arguments)\n  }\n}\n\nfunction wrapMethod (method) {\n  if (typeof method !== 'function') return method\n\n  return function methodWithTrace (url, opts, handler) {\n    const lastIndex = arguments.length - 1\n\n    arguments[lastIndex] = wrapHandler(arguments[lastIndex])\n\n    return method.apply(this, arguments)\n  }\n}\n\nfunction wrapHandler (handler) {\n  return function handlerWithTrace (request, reply) {\n    const req = getReq(request)\n\n    return web.reactivate(req, () => handler.apply(this, arguments))\n  }\n}\n\nfunction getReq (request) {\n  return request && (request.raw || request.req || request)\n}\n\nfunction getRes (reply) {\n  return reply && (reply.raw || reply.res || reply)\n}\n\nmodule.exports = [\n  {\n    name: 'fastify',\n    versions: ['>=1'],\n    patch (fastify, tracer, config) {\n      // `fastify` is a function so we return a wrapper that will replace its export.\n      return this.wrapExport(fastify, createWrapFastify(tracer, config)(fastify))\n    },\n    unpatch (fastify) {\n      this.unwrapExport(fastify)\n    }\n  }\n]\n","'use strict'\n\nmodule.exports = [].concat(\n  require('./fastify'),\n  require('./find-my-way')\n)\n","'use strict'\n\nlet kDirReadPromisified\nlet kDirClosePromisified\nlet kHandle\n\nconst ddFhSym = Symbol('ddFileHandle')\n\nconst tagMakers = {\n  open: createOpenTags,\n  close: createCloseTags,\n  readFile: createReadFileTags,\n  writeFile: createWriteFileTags,\n  appendFile: createAppendFileTags,\n  access: createPathTags,\n  copyFile: createCopyFileTags,\n  stat: createPathTags,\n  lstat: createPathTags,\n  fstat: createFDTags,\n  readdir: createPathTags,\n  opendir: createPathTags,\n  read: createFDTags,\n  write: createFDTags,\n  writev: createFDTags,\n  chmod: createChmodTags,\n  lchmod: createChmodTags,\n  fchmod: createFchmodTags,\n  chown: createChownTags,\n  lchown: createChownTags,\n  fchown: createFchownTags,\n  realpath: createPathTags,\n  readlink: createPathTags,\n  unlink: createPathTags,\n  symlink: createCopyFileTags,\n  link: createCopyFileTags,\n  rmdir: createPathTags,\n  rename: createCopyFileTags,\n  fsync: createFDTags,\n  fdatasync: createFDTags,\n  mkdir: createPathTags,\n  truncate: createPathTags,\n  ftruncate: createFDTags,\n  utimes: createPathTags,\n  futimes: createFDTags,\n  mkdtemp: createPathTags\n}\n\nconst promisifiable = ['read', 'readv', 'write', 'writev']\n\nconst orphanable = false\n\nfunction createWrapCreateReadStream (config, tracer) {\n  return function wrapCreateReadStream (createReadStream) {\n    return function createReadStreamWithTrace (path, options) {\n      if (!hasParent(tracer)) {\n        return createReadStream.apply(this, arguments)\n      }\n      const tags = makeFSFlagTags('ReadStream', path, options, 'r', config, tracer)\n      return tracer.trace('fs.operation', { tags, orphanable }, (span, done) => {\n        const stream = createReadStream.apply(this, arguments)\n        stream.once('end', done)\n        stream.once('error', done)\n        return stream\n      })\n    }\n  }\n}\n\nfunction createWrapCreateWriteStream (config, tracer) {\n  return function wrapCreateWriteStream (createWriteStream) {\n    return function createWriteStreamWithTrace (path, options) {\n      const tags = makeFSFlagTags('WriteStream', path, options, 'w', config, tracer)\n      return tracer.trace('fs.operation', { tags, orphanable }, (span, done) => {\n        const stream = createWriteStream.apply(this, arguments)\n        stream.once('finish', done)\n        stream.once('error', done)\n        return stream\n      })\n    }\n  }\n}\n\nfunction createWrapExists (config, tracer) {\n  return function wrapExists (exists) {\n    const existsWithTrace = function existsWithTrace (path, cb) {\n      if (typeof cb !== 'function') {\n        return exists.apply(this, arguments)\n      }\n      const tags = makeFSTags('exists', path, null, config, tracer)\n      return tracer.trace('fs.operation', { tags, orphanable }, (span, done) => {\n        arguments[1] = function (result) {\n          done()\n          cb.apply(this, arguments)\n        }\n        return exists.apply(this, arguments)\n      })\n    }\n\n    copySymbols(exists, existsWithTrace)\n\n    return existsWithTrace\n  }\n}\n\nfunction createWrapDirRead (config, tracer, sync) {\n  const name = sync ? 'dir.readSync' : 'dir.read'\n  return function wrapDirRead (read) {\n    function options () {\n      const tags = makeFSTags(name, this.path, null, config, tracer)\n      return { tags, orphanable }\n    }\n    return tracer.wrap('fs.operation', options, read, true)\n  }\n}\n\nfunction createWrapDirClose (config, tracer, sync) {\n  const name = sync ? 'dir.closeSync' : 'dir.close'\n  return function wrapDirClose (close) {\n    function options () {\n      const tags = makeFSTags(name, this.path, null, config, tracer)\n      return { tags, orphanable }\n    }\n    return tracer.wrap('fs.operation', options, close, true)\n  }\n}\n\nfunction createWrapDirAsyncIterator (config, tracer, instrumenter) {\n  return function wrapDirAsyncIterator (asyncIterator) {\n    return function asyncIteratorWithTrace () {\n      if (!kDirReadPromisified) {\n        const keys = Reflect.ownKeys(this)\n        for (const key of keys) {\n          if (kDirReadPromisified && kDirClosePromisified) break\n          if (typeof key !== 'symbol') continue\n          if (!kDirReadPromisified && getSymbolName(key).includes('kDirReadPromisified')) {\n            kDirReadPromisified = key\n          }\n          if (!kDirClosePromisified && getSymbolName(key).includes('kDirClosePromisified')) {\n            kDirClosePromisified = key\n          }\n        }\n      }\n      instrumenter.wrap(this, kDirReadPromisified, createWrapDirRead(config, tracer))\n      instrumenter.wrap(this, kDirClosePromisified, createWrapKDirClose(config, tracer, instrumenter))\n      return asyncIterator.call(this)\n    }\n  }\n}\n\nfunction createWrapKDirClose (config, tracer, instrumenter) {\n  return function wrapKDirClose (kDirClose) {\n    return function kDirCloseWithTrace () {\n      const tags = makeFSTags('dir.close', this.path, null, config, tracer)\n      return tracer.trace('fs.operation', { tags, orphanable }, (span) => {\n        const p = kDirClose.call(this)\n        const unwrapBoth = () => {\n          instrumenter.unwrap(this, kDirReadPromisified)\n          instrumenter.unwrap(this, kDirClosePromisified)\n        }\n        p.then(unwrapBoth, unwrapBoth)\n        return p\n      })\n    }\n  }\n}\n\nfunction createOpenTags (resourceName, config, tracer) {\n  return function openTags (path, flag, mode) {\n    if (!flag || typeof flag === 'function') {\n      flag = null\n    }\n    return makeFSFlagTags(resourceName, path, { flag }, 'r', config, tracer)\n  }\n}\n\nfunction createCloseTags (resourceName, config, tracer) {\n  return function closeTags (fd) {\n    if (typeof fd === 'undefined' && this && this[ddFhSym]) {\n      fd = this[ddFhSym].fd\n    }\n    if (typeof fd !== 'number' || !Number.isInteger(fd)) {\n      return\n    }\n    return makeFSTags(resourceName, fd, null, config, tracer)\n  }\n}\n\nfunction createReadFileTags (resourceName, config, tracer) {\n  return function readFileTags (path, options) {\n    return makeFSFlagTags(resourceName, path, options, 'r', config, tracer)\n  }\n}\n\nfunction createWriteFileTags (resourceName, config, tracer) {\n  return function writeFileTags (path, data, options) {\n    return makeFSFlagTags(resourceName, path, options, 'w', config, tracer)\n  }\n}\n\nfunction createAppendFileTags (resourceName, config, tracer) {\n  return function appendFileTags (path, data, options) {\n    return makeFSFlagTags(resourceName, path, options, 'a', config, tracer)\n  }\n}\n\nfunction createCopyFileTags (resourceName, config, tracer) {\n  return function copyFileTags (src, dest, flag) {\n    return makeFSTags(resourceName, { src, dest }, null, config, tracer)\n  }\n}\n\nfunction createChmodTags (resourceName, config, tracer) {\n  return function chmodTags (fd, mode) {\n    const tags = makeFSTags(resourceName, fd, null, config, tracer)\n    tags['file.mode'] = mode.toString(8)\n    return tags\n  }\n}\n\nfunction createFchmodTags (resourceName, config, tracer) {\n  return function fchmodTags (fd, mode) {\n    if (typeof this === 'object' && this !== null && this.fd) {\n      mode = fd\n      fd = this.fd\n    }\n\n    const tags = makeFSTags(resourceName, fd, null, config, tracer)\n    if (mode) {\n      tags['file.mode'] = mode.toString(8)\n    }\n    return tags\n  }\n}\n\nfunction createPathTags (resourceName, config, tracer) {\n  return function pathTags (path) {\n    return makeFSTags(resourceName, path, null, config, tracer)\n  }\n}\n\nfunction createFDTags (resourceName, config, tracer) {\n  return function fdTags (fd) {\n    if (typeof this === 'object' && this !== null && this.fd) {\n      fd = this.fd\n    }\n    return makeFSTags(resourceName, fd, null, config, tracer)\n  }\n}\n\nfunction createChownTags (resourceName, config, tracer) {\n  return function chownTags (fd, uid, gid) {\n    const tags = makeFSTags(resourceName, fd, null, config, tracer)\n    if (typeof uid === 'number') {\n      tags['file.uid'] = uid.toString()\n    }\n    if (typeof gid === 'number') {\n      tags['file.gid'] = gid.toString()\n    }\n    return tags\n  }\n}\n\nfunction createFchownTags (resourceName, config, tracer) {\n  return function fchownTags (fd, uid, gid) {\n    if (typeof this === 'object' && this !== null && this.fd) {\n      gid = uid\n      uid = fd\n      fd = this.fd\n    }\n    const tags = makeFSTags(resourceName, fd, null, config, tracer)\n    if (typeof uid === 'number') {\n      tags['file.uid'] = uid.toString()\n    }\n    if (typeof gid === 'number') {\n      tags['file.gid'] = gid.toString()\n    }\n    return tags\n  }\n}\n\nfunction getSymbolName (sym) {\n  return sym.description || sym.toString()\n}\n\nfunction hasParent (tracer) {\n  return !!tracer.scope().active()\n}\n\nfunction createWrapCb (tracer, config, name, tagMaker) {\n  const makeTags = tagMaker(name, config, tracer)\n  return function wrapFunction (fn) {\n    return tracer.wrap('fs.operation', function () {\n      if (typeof arguments[arguments.length - 1] !== 'function') {\n        return\n      }\n      const tags = makeTags.apply(this, arguments)\n      return tags ? { tags, orphanable } : { orphanable }\n    }, fn, true)\n  }\n}\n\nfunction createWrap (tracer, config, name, tagMaker) {\n  const makeTags = tagMaker(name, config, tracer)\n\n  return function wrapSyncFunction (fn) {\n    return tracer.wrap('fs.operation', function () {\n      const tags = makeTags.apply(this, arguments)\n      return tags ? { tags, orphanable } : { orphanable }\n    }, fn, true)\n  }\n}\n\nfunction makeFSFlagTags (resourceName, path, options, defaultFlag, config, tracer) {\n  const tags = makeFSTags(resourceName, path, options, config, tracer)\n\n  if (tags) {\n    let flag = defaultFlag\n    if (typeof options === 'object' && options !== null) {\n      if (options.flag) {\n        flag = options.flag\n      } else if (options.flags) {\n        flag = options.flags\n      }\n    }\n    tags['file.flag'] = flag\n    return tags\n  }\n}\n\nfunction makeFSTags (resourceName, path, options, config, tracer) {\n  path = options && typeof options === 'object' && 'fd' in options ? options.fd : path\n  const tags = {\n    'component': 'fs',\n    'span.kind': 'internal',\n    'resource.name': resourceName,\n    'service.name': config.service || `${tracer._service}-fs`\n  }\n\n  switch (typeof path) {\n    case 'object': {\n      if (path === null) return\n      const src = 'src' in path ? path.src : null\n      const dest = 'dest' in path ? path.dest : null\n      if (src || dest) {\n        tags['file.src'] = src\n        tags['file.dest'] = dest\n      } else {\n        tags['file.path'] = path\n      }\n      break\n    }\n    case 'string': {\n      tags['file.path'] = path\n      break\n    }\n    case 'number': {\n      tags['file.descriptor'] = path.toString()\n      break\n    }\n  }\n\n  return tags\n}\n\nfunction copySymbols (from, to) {\n  const props = Object.getOwnPropertyDescriptors(from)\n  const keys = Reflect.ownKeys(props)\n\n  for (const key of keys) {\n    if (typeof key !== 'symbol' || to.hasOwnProperty(key)) continue\n\n    Object.defineProperty(to, key, props[key])\n  }\n}\n\nfunction getFileHandlePrototype (fs) {\n  return fs.promises.open(__filename, 'r')\n    .then(fh => {\n      if (!kHandle) {\n        kHandle = Reflect.ownKeys(fh).find(key => typeof key === 'symbol' && key.toString().includes('kHandle'))\n      }\n      fh.close()\n\n      return Object.getPrototypeOf(fh)\n    })\n}\n\nfunction patchClassicFunctions (fs, tracer, config) {\n  for (const name in fs) {\n    if (!fs[name]) continue\n    const tagMakerName = name.endsWith('Sync') ? name.substr(0, name.length - 4) : name\n    const original = fs[name]\n    if (tagMakerName in tagMakers) {\n      const tagMaker = tagMakers[tagMakerName]\n      if (name.endsWith('Sync')) {\n        this.wrap(fs, name, createWrap(tracer, config, name, tagMaker))\n      } else {\n        this.wrap(fs, name, createWrapCb(tracer, config, name, tagMaker))\n      }\n      if (name in promisifiable) {\n        copySymbols(original, fs[name])\n      }\n    }\n  }\n}\n\nfunction patchFileHandle (fs, tracer, config) {\n  getFileHandlePrototype(fs).then((fileHandlePrototype) => {\n    for (const name of Reflect.ownKeys(fileHandlePrototype)) {\n      if (typeof name !== 'string' || name === 'constructor' || name === 'fd' || name === 'getAsyncId') {\n        continue\n      }\n      let tagMaker\n      const fName = 'f' + name\n      if (fName in tagMakers) {\n        tagMaker = tagMakers[fName]\n      } else {\n        tagMaker = createFDTags\n      }\n\n      const instrumenter = this\n\n      const desc = Reflect.getOwnPropertyDescriptor(fileHandlePrototype, kHandle)\n      if (!desc || !desc.get) {\n        Reflect.defineProperty(fileHandlePrototype, kHandle, {\n          get () {\n            return this[ddFhSym]\n          },\n          set (h) {\n            this[ddFhSym] = h\n            instrumenter.wrap(this, 'close', createWrap(tracer, config, 'filehandle.close', tagMakers.close))\n          },\n          configurable: true\n        })\n      }\n\n      this.wrap(fileHandlePrototype, name, createWrap(tracer, config, 'filehandle.' + name, tagMaker))\n    }\n  })\n}\n\nfunction patchPromiseFunctions (fs, tracer, config) {\n  for (const name in fs.promises) {\n    if (name in tagMakers) {\n      const tagMaker = tagMakers[name]\n      this.wrap(fs.promises, name, createWrap(tracer, config, 'promises.' + name, tagMaker))\n    }\n  }\n}\n\nfunction patchDirFunctions (fs, tracer, config) {\n  this.wrap(fs.Dir.prototype, 'close', createWrapDirClose(config, tracer))\n  this.wrap(fs.Dir.prototype, 'closeSync', createWrapDirClose(config, tracer, true))\n  this.wrap(fs.Dir.prototype, 'read', createWrapDirRead(config, tracer))\n  this.wrap(fs.Dir.prototype, 'readSync', createWrapDirRead(config, tracer, true))\n  this.wrap(fs.Dir.prototype, Symbol.asyncIterator, createWrapDirAsyncIterator(config, tracer, this))\n}\n\nfunction unpatchClassicFunctions (fs) {\n  for (const name in fs) {\n    if (!fs[name]) continue\n    const tagMakerName = name.endsWith('Sync') ? name.substr(0, name.length - 4) : name\n    if (tagMakerName in tagMakers) {\n      this.unwrap(fs, name)\n    }\n  }\n}\n\nfunction unpatchFileHandle (fs) {\n  getFileHandlePrototype(fs).then(fileHandlePrototype => {\n    for (const name of Reflect.ownKeys(fileHandlePrototype)) {\n      if (typeof name !== 'string' || name === 'constructor' || name === 'fd' || name === 'getAsyncId') {\n        continue\n      }\n      this.unwrap(fileHandlePrototype, name)\n    }\n    delete fileHandlePrototype[kHandle]\n  })\n}\n\nfunction unpatchPromiseFunctions (fs) {\n  for (const name in fs.promises) {\n    if (name in tagMakers) {\n      this.unwrap(fs.promises, name)\n    }\n  }\n}\n\nfunction unpatchDirFunctions (fs) {\n  this.unwrap(fs.Dir.prototype, 'close')\n  this.unwrap(fs.Dir.prototype, 'closeSync')\n  this.unwrap(fs.Dir.prototype, 'read')\n  this.unwrap(fs.Dir.prototype, 'readSync')\n  this.unwrap(fs.Dir.prototype, Symbol.asyncIterator)\n}\n\nmodule.exports = {\n  name: 'fs',\n  patch (fs, tracer, config) {\n    patchClassicFunctions.call(this, fs, tracer, config)\n    if (fs.promises) {\n      patchFileHandle.call(this, fs, tracer, config)\n      patchPromiseFunctions.call(this, fs, tracer, config)\n    }\n    if (fs.Dir) {\n      patchDirFunctions.call(this, fs, tracer, config)\n    }\n    this.wrap(fs, 'createReadStream', createWrapCreateReadStream(config, tracer))\n    this.wrap(fs, 'createWriteStream', createWrapCreateWriteStream(config, tracer))\n    this.wrap(fs, 'existsSync', createWrap(tracer, config, 'existsSync', createPathTags))\n    this.wrap(fs, 'exists', createWrapExists(config, tracer))\n  },\n  unpatch (fs) {\n    unpatchClassicFunctions.call(this, fs)\n    if (fs.promises) {\n      unpatchFileHandle.call(this, fs)\n      unpatchPromiseFunctions.call(this, fs)\n    }\n    if (fs.Dir) {\n      unpatchDirFunctions.call(this, fs)\n    }\n    this.unwrap(fs, 'createReadStream')\n    this.unwrap(fs, 'createWriteStream')\n    this.unwrap(fs, 'existsSync')\n    this.unwrap(fs, 'exists')\n  }\n}\n\n/** TODO fs functions:\n\nunwatchFile\nwatch\nwatchFile\n*/\n","'use strict'\n\nfunction createWrapAcquire (tracer, config) {\n  return function wrapAcquire (acquire) {\n    return function acquireWithTrace (callback, priority) {\n      if (typeof callback === 'function') {\n        arguments[0] = tracer.scope().bind(callback)\n      }\n\n      return acquire.apply(this, arguments)\n    }\n  }\n}\n\nfunction createWrapPool (tracer, config, instrumenter) {\n  return function wrapPool (Pool) {\n    if (typeof Pool !== 'function') return Pool\n\n    return function PoolWithTrace (factory) {\n      const pool = Pool.apply(this, arguments)\n\n      if (pool && typeof pool.acquire === 'function') {\n        instrumenter.wrap(pool, 'acquire', createWrapAcquire(tracer, config))\n      }\n\n      return pool\n    }\n  }\n}\n\nmodule.exports = [\n  {\n    name: 'generic-pool',\n    versions: ['^2.4'],\n    patch (genericPool, tracer, config) {\n      this.wrap(genericPool.Pool.prototype, 'acquire', createWrapAcquire(tracer, config))\n    },\n    unpatch (genericPool) {\n      this.unwrap(genericPool.Pool.prototype, 'acquire')\n    }\n  },\n  {\n    name: 'generic-pool',\n    versions: ['2 - 2.3'],\n    patch (genericPool, tracer, config) {\n      this.wrap(genericPool, 'Pool', createWrapPool(tracer, config, this))\n    },\n    unpatch (genericPool) {\n      this.unwrap(genericPool, 'Pool')\n    }\n  }\n]\n","'use strict'\n\nfunction createWrapRequest (tracer, config) {\n  return function wrapRequest (request) {\n    return function requestWithTrace (cfg = { reqOpts: {} }, cb) {\n      const topic = getTopic(cfg)\n      const tags = {\n        component: '@google-cloud/pubsub',\n        'resource.name': [cfg.method, topic].filter(x => x).join(' '),\n        'service.name': config.service || `${tracer._service}-pubsub`,\n        'pubsub.method': cfg.method,\n        'gcloud.project_id': this.projectId,\n        'pubsub.topic': topic\n      }\n      if (cfg.method === 'publish') {\n        tags['span.kind'] = 'producer'\n      }\n      cb = tracer.scope().bind(cb)\n      return tracer.trace('pubsub.request', { tags }, (span, done) => {\n        if (cfg.reqOpts && cfg.method === 'publish') {\n          for (const msg of cfg.reqOpts.messages) {\n            if (!msg.attributes) {\n              msg.attributes = {}\n            }\n            tracer.inject(span, 'text_map', msg.attributes)\n          }\n        }\n\n        arguments[1] = function (err) {\n          done(err)\n          return cb.apply(this, arguments)\n        }\n\n        return request.apply(this, arguments)\n      })\n    }\n  }\n}\n\nfunction createWrapSubscriptionEmit (tracer, config) {\n  return function wrapSubscriptionEmit (emit) {\n    return function emitWithTrace (eventName, message) {\n      if (eventName !== 'message' || !message || !message._datadog_span) {\n        return emit.apply(this, arguments)\n      }\n\n      const span = message._datadog_span\n\n      return tracer.scope().activate(span, () => {\n        try {\n          return emit.apply(this, arguments)\n        } catch (e) {\n          span.setTag('error', e)\n          throw e\n        }\n      })\n    }\n  }\n}\n\nfunction createWrapLeaseDispense (tracer, config) {\n  return function wrapDispense (dispense) {\n    return function dispenseWithTrace (message) {\n      const subscription = message._subscriber._subscription\n      const topic = subscription.metadata && subscription.metadata.topic\n      const tags = {\n        component: '@google-cloud/pubsub',\n        'resource.name': topic,\n        'service.name': config.service || tracer._service,\n        'gcloud.project_id': subscription.pubsub.projectId,\n        'pubsub.topic': topic,\n        'span.kind': 'consumer'\n      }\n\n      const childOf = tracer.extract('text_map', message.attributes)\n      const span = tracer.startSpan('pubsub.receive', { tags, childOf })\n\n      message._datadog_span = span\n\n      return dispense.apply(this, arguments)\n    }\n  }\n}\n\nfunction createWrapLeaseRemove (tracer, config) {\n  return function wrapRemove (remove) {\n    return function removeWithTrace (message) {\n      finish(message)\n\n      return remove.apply(this, arguments)\n    }\n  }\n}\n\nfunction createWrapLeaseClear (tracer, config) {\n  return function wrapClear (clear) {\n    return function clearWithTrace () {\n      for (const message of this._messages) {\n        finish(message)\n      }\n\n      return clear.apply(this, arguments)\n    }\n  }\n}\n\nfunction getTopic (cfg) {\n  if (cfg.reqOpts) {\n    return cfg.reqOpts[cfg.method === 'createTopic' ? 'name' : 'topic']\n  }\n}\n\nfunction finish (message) {\n  const span = message._datadog_span\n\n  if (!span) return\n\n  span.setTag('pubsub.ack', message._handled ? 1 : 0)\n  span.finish()\n}\n\nmodule.exports = [\n  {\n    name: '@google-cloud/pubsub',\n    versions: ['>=1.2'],\n    patch ({ PubSub, Subscription }, tracer, config) {\n      this.wrap(PubSub.prototype, 'request', createWrapRequest(tracer, config))\n      this.wrap(Subscription.prototype, 'emit', createWrapSubscriptionEmit(tracer, config))\n    },\n    unpatch ({ PubSub, Subscription }) {\n      this.unwrap(PubSub.prototype, 'request')\n      this.unwrap(Subscription.prototype, 'emit')\n    }\n  },\n  {\n    name: '@google-cloud/pubsub',\n    versions: ['>=1.2'],\n    file: 'build/src/lease-manager.js',\n    patch ({ LeaseManager }, tracer, config) {\n      this.wrap(LeaseManager.prototype, '_dispense', createWrapLeaseDispense(tracer, config))\n      this.wrap(LeaseManager.prototype, 'remove', createWrapLeaseRemove(tracer, config))\n      this.wrap(LeaseManager.prototype, 'clear', createWrapLeaseClear(tracer, config))\n    },\n    unpatch ({ LeaseManager }) {\n      this.unwrap(LeaseManager.prototype, '_dispense')\n      this.unwrap(LeaseManager.prototype, 'remove')\n      this.unwrap(LeaseManager.prototype, 'clear')\n    }\n  }\n]\n","'use strict'\n\nconst pick = require('lodash.pick')\nconst log = require('../../dd-trace/src/log')\nconst analyticsSampler = require('../../dd-trace/src/analytics_sampler')\n\nlet tools\n\nfunction createWrapExecute (tracer, config, defaultFieldResolver) {\n  return function wrapExecute (execute) {\n    return function executeWithTrace () {\n      const args = normalizeArgs(arguments)\n      const schema = args.schema\n      const document = args.document\n      const source = document && document._datadog_source\n      const fieldResolver = args.fieldResolver || defaultFieldResolver\n      const contextValue = args.contextValue = args.contextValue || {}\n      const operation = getOperation(document, args.operationName)\n\n      if (contextValue._datadog_graphql) {\n        return execute.apply(this, arguments)\n      }\n\n      args.fieldResolver = wrapResolve(fieldResolver, tracer, config)\n\n      if (schema) {\n        wrapFields(schema._queryType, tracer, config)\n        wrapFields(schema._mutationType, tracer, config)\n      }\n\n      const span = startExecutionSpan(tracer, config, operation, args)\n\n      contextValue._datadog_graphql = { source, span, fields: {} }\n\n      return call(execute, span, this, [args], (err, res) => {\n        finishResolvers(contextValue, config)\n\n        setError(span, err || (res && res.errors && res.errors[0]))\n        config.hooks.execute(span, args, res)\n        finish(span)\n      })\n    }\n  }\n}\n\nfunction createWrapParse (tracer, config) {\n  return function wrapParse (parse) {\n    return function parseWithTrace (source) {\n      const span = startSpan(tracer, config, 'parse')\n\n      analyticsSampler.sample(span, config.analytics)\n\n      try {\n        const document = parse.apply(this, arguments)\n        const operation = getOperation(document)\n\n        if (!operation) return document // skip schema parsing\n\n        if (source) {\n          document._datadog_source = source.body || source\n        }\n\n        addDocumentTags(span, document)\n\n        return document\n      } catch (e) {\n        setError(span, e)\n        throw e\n      } finally {\n        finish(span)\n      }\n    }\n  }\n}\n\nfunction createWrapValidate (tracer, config) {\n  return function wrapValidate (validate) {\n    return function validateWithTrace (schema, document, rules, typeInfo) {\n      const span = startSpan(tracer, config, 'validate')\n\n      analyticsSampler.sample(span, config.analytics)\n\n      // skip for schema stitching nested validation\n      if (document && document.loc) {\n        addDocumentTags(span, document)\n      }\n\n      try {\n        const errors = validate.apply(this, arguments)\n\n        setError(span, errors && errors[0])\n\n        return errors\n      } catch (e) {\n        setError(span, e)\n        throw e\n      } finally {\n        finish(span)\n      }\n    }\n  }\n}\n\nfunction wrapFields (type, tracer, config) {\n  if (!type || !type._fields || type._datadog_patched) {\n    return\n  }\n\n  type._datadog_patched = true\n\n  Object.keys(type._fields).forEach(key => {\n    const field = type._fields[key]\n\n    wrapFieldResolve(field, tracer, config)\n    wrapFieldType(field, tracer, config)\n  })\n}\n\nfunction wrapFieldResolve (field, tracer, config) {\n  if (!field || !field.resolve) return\n\n  field.resolve = wrapResolve(field.resolve, tracer, config)\n}\n\nfunction wrapFieldType (field, tracer, config) {\n  if (!field || !field.type) return\n\n  let unwrappedType = field.type\n\n  while (unwrappedType.ofType) {\n    unwrappedType = unwrappedType.ofType\n  }\n\n  wrapFields(unwrappedType, tracer, config)\n}\n\nfunction wrapResolve (resolve, tracer, config) {\n  if (resolve._datadog_patched || typeof resolve !== 'function') return resolve\n\n  const responsePathAsArray = config.collapse\n    ? withCollapse(pathToArray)\n    : pathToArray\n\n  function resolveWithTrace (source, args, contextValue, info) {\n    if (!contextValue._datadog_graphql) return resolve.apply(this, arguments)\n\n    const path = responsePathAsArray(info && info.path)\n    const depth = path.filter(item => typeof item === 'string').length\n\n    if (config.depth >= 0 && config.depth < depth) {\n      const parent = getParentField(tracer, contextValue, path)\n\n      return call(resolve, parent.span, this, arguments)\n    }\n\n    const field = assertField(tracer, config, contextValue, info, path)\n\n    return call(resolve, field.span, this, arguments, err => updateField(field, err))\n  }\n\n  resolveWithTrace._datadog_patched = true\n\n  return resolveWithTrace\n}\n\nfunction call (fn, span, thisArg, args, callback) {\n  const scope = span.tracer().scope()\n\n  callback = callback || (() => {})\n\n  try {\n    const result = scope.activate(span, () => fn.apply(thisArg, args))\n\n    if (result && typeof result.then === 'function') {\n      result.then(\n        res => callback(null, res),\n        err => callback(err)\n      )\n    } else {\n      callback(null, result)\n    }\n\n    return result\n  } catch (e) {\n    callback(e)\n    throw e\n  }\n}\n\nfunction getParentField (tracer, contextValue, path) {\n  for (let i = path.length - 1; i > 0; i--) {\n    const field = getField(contextValue, path.slice(0, i))\n\n    if (field) {\n      return field\n    }\n  }\n\n  return {\n    span: contextValue._datadog_graphql.span\n  }\n}\n\nfunction getField (contextValue, path) {\n  return contextValue._datadog_graphql.fields[path.join('.')]\n}\n\nfunction normalizeArgs (args) {\n  if (args.length === 1) {\n    return args[0]\n  }\n\n  return {\n    schema: args[0],\n    document: args[1],\n    rootValue: args[2],\n    contextValue: args[3],\n    variableValues: args[4],\n    operationName: args[5],\n    fieldResolver: args[6]\n  }\n}\n\nfunction startExecutionSpan (tracer, config, operation, args) {\n  const span = startSpan(tracer, config, 'execute')\n\n  addExecutionTags(span, config, operation, args.document, args.operationName)\n  addDocumentTags(span, args.document)\n  addVariableTags(tracer, config, span, args.variableValues)\n\n  analyticsSampler.sample(span, config.analytics)\n\n  return span\n}\n\nfunction addExecutionTags (span, config, operation, document, operationName) {\n  const type = operation && operation.operation\n  const name = operation && operation.name && operation.name.value\n  const tags = {\n    'resource.name': getSignature(document, name, type, config.signature)\n  }\n\n  if (type) {\n    tags['graphql.operation.type'] = type\n  }\n\n  if (name) {\n    tags['graphql.operation.name'] = name\n  }\n\n  span.addTags(tags)\n}\n\nfunction addDocumentTags (span, document) {\n  const tags = {}\n\n  if (document && document._datadog_source) {\n    tags['graphql.source'] = document._datadog_source\n  }\n\n  span.addTags(tags)\n}\n\nfunction addVariableTags (tracer, config, span, variableValues) {\n  const tags = {}\n\n  if (variableValues && config.variables) {\n    const variables = config.variables(variableValues)\n    for (const param in variables) {\n      tags[`graphql.variables.${param}`] = variables[param]\n    }\n  }\n\n  span.addTags(tags)\n}\n\nfunction startSpan (tracer, config, name, options) {\n  options = options || {}\n\n  return tracer.startSpan(`graphql.${name}`, {\n    childOf: options.childOf || tracer.scope().active(),\n    startTime: options.startTime,\n    tags: {\n      'service.name': getService(tracer, config),\n      'span.type': 'graphql'\n    }\n  })\n}\n\nfunction startResolveSpan (tracer, config, childOf, path, info, contextValue) {\n  const span = startSpan(tracer, config, 'resolve', { childOf })\n  const document = contextValue._datadog_graphql.source\n  const fieldNode = info.fieldNodes.find(fieldNode => fieldNode.kind === 'Field')\n\n  span.addTags({\n    'resource.name': `${info.fieldName}:${info.returnType}`,\n    'graphql.field.name': info.fieldName,\n    'graphql.field.path': path.join('.'),\n    'graphql.field.type': info.returnType.name\n  })\n\n  if (fieldNode) {\n    if (document && fieldNode.loc) {\n      span.setTag('graphql.source', document.substring(fieldNode.loc.start, fieldNode.loc.end))\n    }\n\n    if (config.variables && fieldNode.arguments) {\n      const variables = config.variables(info.variableValues)\n\n      fieldNode.arguments\n        .filter(arg => arg.value && arg.value.kind === 'Variable')\n        .filter(arg => arg.value.name && variables[arg.value.name.value])\n        .map(arg => arg.value.name.value)\n        .forEach(name => {\n          span.setTag(`graphql.variables.${name}`, variables[name])\n        })\n    }\n  }\n\n  return span\n}\n\nfunction setError (span, error) {\n  if (error) {\n    span.setTag('error', error)\n  }\n}\n\nfunction finish (span, finishTime) {\n  span.finish(finishTime)\n}\n\nfunction finishResolvers (contextValue) {\n  const fields = contextValue._datadog_graphql.fields\n\n  Object.keys(fields).reverse().forEach(key => {\n    const field = fields[key]\n\n    setError(field.span, field.error)\n    finish(field.span, field.finishTime)\n  })\n}\n\nfunction updateField (field, error) {\n  // TODO: update this to also work with no-op spans without a hack\n  field.finishTime = field.span._getTime ? field.span._getTime() : 0\n  field.error = field.error || error\n}\n\nfunction withCollapse (responsePathAsArray) {\n  return function () {\n    return responsePathAsArray.apply(this, arguments)\n      .map(segment => typeof segment === 'number' ? '*' : segment)\n  }\n}\n\nfunction assertField (tracer, config, contextValue, info, path) {\n  const pathString = path.join('.')\n  const fields = contextValue._datadog_graphql.fields\n\n  let field = fields[pathString]\n\n  if (!field) {\n    const parent = getParentField(tracer, contextValue, path)\n\n    field = fields[pathString] = {\n      parent,\n      span: startResolveSpan(tracer, config, parent.span, path, info, contextValue),\n      error: null\n    }\n  }\n\n  return field\n}\n\nfunction getService (tracer, config) {\n  return config.service || `${tracer._service}-graphql`\n}\n\nfunction getOperation (document, operationName) {\n  if (!document || !Array.isArray(document.definitions)) {\n    return\n  }\n\n  const definitions = document.definitions.filter(def => def)\n  const types = ['query', 'mutation', 'subscription']\n\n  if (operationName) {\n    return definitions\n      .filter(def => types.indexOf(def.operation) !== -1)\n      .find(def => operationName === (def.name && def.name.value))\n  } else {\n    return definitions.find(def => types.indexOf(def.operation) !== -1)\n  }\n}\n\nfunction validateConfig (config) {\n  return Object.assign({}, config, {\n    depth: getDepth(config),\n    variables: getVariablesFilter(config),\n    collapse: config.collapse === undefined || !!config.collapse,\n    hooks: getHooks(config)\n  })\n}\n\nfunction getDepth (config) {\n  if (typeof config.depth === 'number') {\n    return config.depth\n  } else if (config.hasOwnProperty('depth')) {\n    log.error('Expected `depth` to be a integer.')\n  }\n  return -1\n}\n\nfunction getVariablesFilter (config) {\n  if (typeof config.variables === 'function') {\n    return config.variables\n  } else if (config.variables instanceof Array) {\n    return variables => pick(variables, config.variables)\n  } else if (config.hasOwnProperty('variables')) {\n    log.error('Expected `variables` to be an array or function.')\n  }\n  return null\n}\n\nfunction getSignature (document, operationName, operationType, calculate) {\n  if (calculate !== false && tools !== false) {\n    try {\n      try {\n        tools = tools || require('./tools')\n      } catch (e) {\n        tools = false\n        throw e\n      }\n\n      return tools.defaultEngineReportingSignature(document, operationName)\n    } catch (e) {\n      // safety net\n    }\n  }\n\n  return [operationType, operationName].filter(val => val).join(' ')\n}\n\nfunction pathToArray (path) {\n  const flattened = []\n  let curr = path\n  while (curr) {\n    flattened.push(curr.key)\n    curr = curr.prev\n  }\n  return flattened.reverse()\n}\n\nfunction getHooks (config) {\n  const noop = () => {}\n  const execute = (config.hooks && config.hooks.execute) || noop\n\n  return { execute }\n}\n\nmodule.exports = [\n  {\n    name: 'graphql',\n    file: 'execution/execute.js',\n    versions: ['>=0.10'],\n    patch (execute, tracer, config) {\n      this.wrap(execute, 'execute', createWrapExecute(\n        tracer,\n        validateConfig(config),\n        execute.defaultFieldResolver\n      ))\n    },\n    unpatch (execute) {\n      this.unwrap(execute, 'execute')\n    }\n  },\n  {\n    name: 'graphql',\n    file: 'language/parser.js',\n    versions: ['>=0.10'],\n    patch (parser, tracer, config) {\n      this.wrap(parser, 'parse', createWrapParse(tracer, validateConfig(config)))\n    },\n    unpatch (parser) {\n      this.unwrap(parser, 'parse')\n    }\n  },\n  {\n    name: 'graphql',\n    file: 'validation/validate.js',\n    versions: ['>=0.10'],\n    patch (validate, tracer, config) {\n      this.wrap(validate, 'validate', createWrapValidate(tracer, validateConfig(config)))\n    },\n    unpatch (validate) {\n      this.unwrap(validate, 'validate')\n    }\n  }\n]\n","'use strict'\n\nconst Tags = require('../../../ext/tags')\nconst { TEXT_MAP } = require('../../../ext/formats')\nconst { ERROR } = require('../../../ext/tags')\nconst kinds = require('./kinds')\nconst { addMethodTags, addMetadataTags, getFilter } = require('./util')\n\nfunction createWrapLoadPackageDefinition (tracer, config) {\n  config = config.client || config\n\n  return function wrapLoadPackageDefinition (loadPackageDefinition) {\n    return function loadPackageDefinitionWithTrace (packageDef) {\n      const result = loadPackageDefinition.apply(this, arguments)\n\n      if (!result) return result\n\n      wrapPackageDefinition(tracer, config, result)\n\n      return result\n    }\n  }\n}\n\nfunction createWrapMakeClientConstructor (tracer, config) {\n  config = config.client || config\n\n  return function wrapMakeClientConstructor (makeClientConstructor) {\n    return function makeClientConstructorWithTrace (methods) {\n      const ServiceClient = makeClientConstructor.apply(this, arguments)\n\n      wrapClientConstructor(tracer, config, ServiceClient, methods)\n\n      return ServiceClient\n    }\n  }\n}\n\nfunction wrapPackageDefinition (tracer, config, def) {\n  for (const name in def) {\n    if (def[name].format) continue\n    if (def[name].service) {\n      wrapClientConstructor(tracer, config, def[name], def[name].service)\n    } else {\n      wrapPackageDefinition(tracer, config, def[name])\n    }\n  }\n}\n\nfunction wrapClientConstructor (tracer, config, ServiceClient, methods) {\n  const proto = ServiceClient.prototype\n\n  if (typeof methods !== 'object' || 'format' in methods) return\n\n  Object.keys(methods)\n    .forEach(name => {\n      if (!methods[name]) return\n\n      const originalName = methods[name].originalName\n      const path = methods[name].path\n      const methodKind = getMethodKind(methods[name])\n\n      if (methods[name]) {\n        proto[name] = wrapMethod(tracer, config, proto[name], path, methodKind)\n      }\n\n      if (originalName) {\n        proto[originalName] = wrapMethod(tracer, config, proto[originalName], path, methodKind)\n      }\n    })\n}\n\nfunction wrapMethod (tracer, config, method, path, methodKind) {\n  if (typeof method !== 'function' || method._datadog_patched) {\n    return method\n  }\n\n  const filter = getFilter(config, 'metadata')\n\n  const methodWithTrace = function methodWithTrace () {\n    const args = ensureMetadata(this, arguments)\n    const length = args.length\n    const metadata = args[1]\n    const callback = args[length - 1]\n    const scope = tracer.scope()\n    const span = startSpan(tracer, config, path, methodKind)\n\n    if (metadata) {\n      addMetadataTags(span, metadata, filter, 'request')\n      inject(tracer, span, metadata)\n    }\n\n    if (methodKind === kinds.unary || methodKind === kinds.client_stream) {\n      if (typeof callback === 'function') {\n        args[length - 1] = wrapCallback(span, callback)\n      } else {\n        args[length] = wrapCallback(span)\n      }\n    }\n\n    const call = scope.bind(method, span).apply(this, args)\n\n    wrapStream(span, call, filter)\n\n    return scope.bind(call)\n  }\n\n  Object.assign(methodWithTrace, method)\n\n  methodWithTrace._datadog_patched = true\n\n  return methodWithTrace\n}\n\nfunction wrapCallback (span, callback) {\n  const scope = span.tracer().scope()\n  const parent = scope.active()\n\n  return function (err) {\n    err && span.setTag(ERROR, err)\n\n    if (callback) {\n      return scope.bind(callback, parent).apply(this, arguments)\n    }\n  }\n}\n\nfunction wrapStream (span, call, filter) {\n  if (!call || typeof call.emit !== 'function') return\n\n  const emit = call.emit\n\n  call.emit = function (eventName, ...args) {\n    switch (eventName) {\n      case 'error':\n        span.setTag(ERROR, args[0] || 1)\n\n        break\n      case 'status':\n        if (args[0]) {\n          span.setTag('grpc.status.code', args[0].code)\n\n          addMetadataTags(span, args[0].metadata, filter, 'response')\n        }\n\n        span.finish()\n\n        break\n    }\n\n    return emit.apply(this, arguments)\n  }\n}\n\nfunction startSpan (tracer, config, path, methodKind) {\n  const scope = tracer.scope()\n  const childOf = scope.active()\n  const span = tracer.startSpan('grpc.request', {\n    childOf,\n    tags: {\n      [Tags.SPAN_KIND]: 'client',\n      'resource.name': path,\n      'service.name': config.service || `${tracer._service}-grpc-client`,\n      'component': 'grpc'\n    }\n  })\n\n  addMethodTags(span, path, methodKind)\n\n  return span\n}\n\nfunction ensureMetadata (client, args) {\n  if (!client || !client._datadog) return args\n\n  const normalized = [args[0]]\n\n  if (!args[1] || !args[1].constructor || args[1].constructor.name !== 'Metadata') {\n    normalized.push(new client._datadog.grpc.Metadata())\n  }\n\n  for (let i = 1; i < args.length; i++) {\n    normalized.push(args[i])\n  }\n\n  return normalized\n}\n\nfunction inject (tracer, span, metadata) {\n  if (typeof metadata.set !== 'function') return\n\n  const carrier = {}\n\n  tracer.inject(span, TEXT_MAP, carrier)\n\n  for (const key in carrier) {\n    metadata.set(key, carrier[key])\n  }\n}\n\nfunction getMethodKind (definition) {\n  if (definition.requestStream) {\n    if (definition.responseStream) {\n      return kinds.bidi\n    }\n\n    return kinds.client_stream\n  }\n\n  if (definition.responseStream) {\n    return kinds.server_stream\n  }\n\n  return kinds.unary\n}\n\nmodule.exports = [\n  {\n    name: 'grpc',\n    versions: ['>=1.13'],\n    patch (grpc, tracer, config) {\n      if (config.client === false) return\n\n      grpc.Client.prototype._datadog = { grpc }\n    },\n    unpatch (grpc) {\n      delete grpc.Client._datadog\n    }\n  },\n  {\n    name: 'grpc',\n    versions: ['>=1.13'],\n    file: 'src/client.js',\n    patch (client, tracer, config) {\n      if (config.client === false) return\n\n      this.wrap(client, 'makeClientConstructor', createWrapMakeClientConstructor(tracer, config))\n    },\n    unpatch (client) {\n      this.unwrap(client, 'makeClientConstructor')\n    }\n  },\n  {\n    name: '@grpc/grpc-js',\n    versions: ['>=1.0.3'],\n    patch (grpc, tracer, config) {\n      if (config.client === false) return\n\n      grpc.Client.prototype._datadog = { grpc }\n    },\n    unpatch (grpc) {\n      delete grpc.Client._datadog\n    }\n  },\n  {\n    name: '@grpc/grpc-js',\n    versions: ['>=1.0.3'],\n    file: 'build/src/make-client.js',\n    patch (client, tracer, config) {\n      if (config.client === false) return\n\n      this.wrap(client, 'makeClientConstructor', createWrapMakeClientConstructor(tracer, config))\n      this.wrap(client, 'loadPackageDefinition', createWrapLoadPackageDefinition(tracer, config))\n    },\n    unpatch (client) {\n      this.unwrap(client, 'makeClientConstructor')\n      this.unwrap(client, 'loadPackageDefinition')\n    }\n  }\n]\n","'use strict'\n\nconst Tags = require('../../../ext/tags')\nconst { TEXT_MAP } = require('../../../ext/formats')\nconst { ERROR } = require('../../../ext/tags')\nconst kinds = require('./kinds')\nconst { addMethodTags, addMetadataTags, getFilter } = require('./util')\n\n// https://github.com/grpc/grpc/blob/master/doc/statuscodes.md\nconst OK = 0\nconst CANCELLED = 1\n\nfunction createWrapHandler (tracer, config, handler) {\n  const filter = getFilter(config, 'metadata')\n\n  return function wrapHandler (func) {\n    const isValid = (server, args) => {\n      if (!server || !server.type) return false\n      if (!args[0]) return false\n      if (server.type !== 'unary' && !isEmitter(args[0])) return false\n      if (server.type === 'unary' && typeof args[1] !== 'function') return false\n\n      return true\n    }\n\n    return function funcWithTrace (call, callback) {\n      if (!isValid(this, arguments)) return func.apply(this, arguments)\n\n      const metadata = call.metadata\n      const type = this.type\n      const isStream = type !== 'unary'\n      const scope = tracer.scope()\n      const childOf = extract(tracer, metadata)\n      const span = tracer.startSpan('grpc.request', {\n        childOf,\n        tags: {\n          [Tags.SPAN_KIND]: 'server',\n          'resource.name': handler,\n          'service.name': config.service || `${tracer._service}`,\n          'component': 'grpc'\n        }\n      })\n\n      addMethodTags(span, handler, kinds[type])\n      addMetadataTags(span, metadata, filter, 'request')\n\n      scope.bind(call)\n\n      // Finish the span if the call was cancelled.\n      call.once('cancelled', () => {\n        span.setTag('grpc.status.code', CANCELLED)\n        span.finish()\n      })\n\n      if (isStream) {\n        wrapStream(span, call)\n      } else {\n        arguments[1] = wrapCallback(span, callback, filter, childOf)\n      }\n\n      return scope.bind(func, span).apply(this, arguments)\n    }\n  }\n}\n\nfunction createWrapRegister (tracer, config) {\n  config = config.server || config\n\n  return function wrapRegister (register) {\n    return function registerWithTrace (name, handler, serialize, deserialize, type) {\n      if (typeof handler === 'function') {\n        arguments[1] = createWrapHandler(tracer, config, name)(handler)\n      }\n\n      return register.apply(this, arguments)\n    }\n  }\n}\n\nfunction wrapStream (span, call, tracer) {\n  const emit = call.emit\n\n  if (call.call && call.call.sendStatus) {\n    call.call.sendStatus = wrapSendStatus(call.call.sendStatus, span)\n  }\n\n  call.emit = function (eventName, ...args) {\n    switch (eventName) {\n      case 'error':\n        span.addTags({\n          [ERROR]: args[0] || 1,\n          'grpc.status.code': args[0] && args[0].code\n        })\n\n        span.finish()\n\n        break\n\n      // Finish the span of the response only if it was successful.\n      // Otherwise it'll be finished in the `error` listener.\n      case 'finish':\n        if (call.status) {\n          span.setTag('grpc.status.code', call.status.code)\n        }\n\n        if (!call.status || call.status.code === 0) {\n          span.finish()\n        }\n\n        break\n    }\n\n    return emit.apply(this, arguments)\n  }\n}\n\nfunction wrapCallback (span, callback, filter, childOf) {\n  const scope = span.tracer().scope()\n\n  return function (err, value, trailer, flags) {\n    if (err instanceof Error) {\n      if (err.code) {\n        span.setTag('grpc.status.code', err.code)\n      }\n\n      span.setTag(ERROR, err)\n    } else {\n      span.setTag('grpc.status.code', OK)\n    }\n\n    if (trailer && filter) {\n      addMetadataTags(span, trailer, filter, 'response')\n    }\n\n    span.finish()\n\n    if (callback) {\n      return scope.bind(callback, childOf).apply(this, arguments)\n    }\n  }\n}\n\nfunction wrapSendStatus (sendStatus, span) {\n  return function sendStatusWithTrace (status) {\n    span.setTag('grpc.status.code', status.code)\n\n    return sendStatus.apply(this, arguments)\n  }\n}\n\nfunction extract (tracer, metadata) {\n  if (!metadata || typeof metadata.getMap !== 'function') return null\n\n  return tracer.extract(TEXT_MAP, metadata.getMap())\n}\n\nfunction isEmitter (obj) {\n  return typeof obj.emit === 'function' && typeof obj.once === 'function'\n}\n\nmodule.exports = [\n  {\n    name: 'grpc',\n    versions: ['>=1.13'],\n    file: 'src/server.js',\n    patch (server, tracer, config) {\n      if (config.server === false) return\n      this.wrap(server.Server.prototype, 'register', createWrapRegister(tracer, config))\n    },\n    unpatch (server) {\n      this.unwrap(server.Server.prototype, 'register')\n    }\n  },\n  {\n    name: '@grpc/grpc-js',\n    versions: ['>=1'],\n    file: 'build/src/server.js',\n    patch (server, tracer, config) {\n      if (config.server === false) return\n\n      this.wrap(server.Server.prototype, 'register', createWrapRegister(tracer, config))\n    },\n    unpatch (server) {\n      this.unwrap(server.Server.prototype, 'register')\n    }\n  }\n]\n","'use strict'\n\nconst pick = require('lodash.pick')\nconst log = require('../../dd-trace/src/log')\n\nmodule.exports = {\n  addMethodTags (span, path, kind) {\n    if (typeof path !== 'string') return\n\n    span.addTags({\n      'grpc.method.path': path,\n      'grpc.method.kind': kind\n    })\n\n    const methodParts = path.split('/')\n\n    if (methodParts.length < 2) return\n\n    const serviceParts = methodParts[1].split('.')\n    const name = methodParts[2]\n    const service = serviceParts.pop()\n    const pkg = serviceParts.join('.')\n\n    span.addTags({\n      'grpc.method.name': name,\n      'grpc.method.service': service,\n      'grpc.method.package': pkg\n    })\n  },\n\n  addMetadataTags (span, metadata, filter, type) {\n    if (!metadata || typeof metadata.getMap !== 'function') return\n\n    const values = filter(metadata.getMap())\n\n    for (const key in values) {\n      span.setTag(`grpc.${type}.metadata.${key}`, values[key])\n    }\n  },\n\n  // TODO: extract this to shared utils and add unit tests\n  getFilter (config, filter) {\n    if (typeof config[filter] === 'function') {\n      return config[filter]\n    }\n\n    if (config[filter] instanceof Array) {\n      return element => pick(element, config[filter])\n    }\n\n    if (config.hasOwnProperty(filter)) {\n      log.error(`Expected '${filter}' to be an array or function.`)\n    }\n\n    return () => ({})\n  }\n}\n","'use strict'\n\nconst web = require('../../dd-trace/src/plugins/util/web')\n\nfunction createWrapDispatch (tracer, config) {\n  config = web.normalizeConfig(config)\n\n  return function wrapDispatch (dispatch) {\n    return function dispatchWithTrace (options) {\n      const handler = dispatch.apply(this, arguments)\n\n      if (typeof handler !== 'function') return handler\n\n      return function (req, res) {\n        return web.instrument(tracer, config, req, res, 'hapi.request', () => {\n          return handler.apply(this, arguments)\n        })\n      }\n    }\n  }\n}\n\nfunction createWrapServer (tracer) {\n  return function wrapServer (server) {\n    return function serverWithTrace (options) {\n      const app = server.apply(this, arguments)\n\n      if (!app) return app\n\n      if (typeof app.ext === 'function') {\n        app.ext = createWrapExt(tracer)(app.ext)\n      }\n\n      if (typeof app.start === 'function') {\n        app.start = createWrapStart(tracer)(app.start)\n      }\n\n      return app\n    }\n  }\n}\n\nfunction createWrapStart () {\n  return function wrapStart (start) {\n    return function startWithTrace () {\n      if (this && typeof this.ext === 'function') {\n        this.ext('onPreResponse', onPreResponse)\n      }\n\n      return start.apply(this, arguments)\n    }\n  }\n}\n\nfunction createWrapExt () {\n  return function wrapExt (ext) {\n    return function extWithTrace (events, method, options) {\n      if (typeof events === 'object') {\n        events = wrapEvents(events)\n      } else {\n        method = wrapExtension(method)\n      }\n\n      return ext.call(this, events, method, options)\n    }\n  }\n}\n\nfunction wrapExtension (method) {\n  return [].concat(method).map(wrapHandler)\n}\n\nfunction wrapEvents (events) {\n  return [].concat(events).map(event => {\n    if (!event || !event.method) return event\n\n    return Object.assign({}, event, {\n      method: wrapExtension(event.method)\n    })\n  })\n}\n\nfunction wrapHandler (handler) {\n  if (typeof handler !== 'function') return handler\n\n  return function (request, h) {\n    if (!request || !request.raw) return handler.apply(this, arguments)\n\n    return web.reactivate(request.raw.req, () => handler.apply(this, arguments))\n  }\n}\n\nfunction onPreResponse (request, h) {\n  if (!request || !request.raw) return reply(request, h)\n\n  const req = request.raw.req\n\n  web.addError(req, request.response)\n\n  if (request.route) {\n    web.enterRoute(req, request.route.path)\n  }\n\n  return reply(request, h)\n}\n\nfunction reply (request, h) {\n  if (h.continue) {\n    return typeof h.continue === 'function'\n      ? h.continue()\n      : h.continue\n  } else if (typeof h === 'function') {\n    return h()\n  }\n}\n\nmodule.exports = [\n  {\n    name: '@hapi/hapi',\n    versions: ['>=17.9'],\n    patch (hapi, tracer, config) {\n      this.wrap(hapi, ['server', 'Server'], createWrapServer(tracer, config))\n    },\n    unpatch (hapi) {\n      this.unwrap(hapi, ['server', 'Server'])\n    }\n  },\n  {\n    name: 'hapi',\n    versions: ['>=17'],\n    patch (hapi, tracer, config) {\n      this.wrap(hapi, ['server', 'Server'], createWrapServer(tracer, config))\n    },\n    unpatch (hapi) {\n      this.unwrap(hapi, ['server', 'Server'])\n    }\n  },\n  {\n    name: 'hapi',\n    versions: ['2 - 7.1', '8 - 16'],\n    patch (hapi, tracer, config) {\n      this.wrap(hapi.Server.prototype, 'start', createWrapStart(tracer, config))\n      this.wrap(hapi.Server.prototype, 'ext', createWrapExt(tracer, config))\n    },\n    unpatch (hapi) {\n      this.unwrap(hapi.Server.prototype, 'start')\n      this.unwrap(hapi.Server.prototype, 'ext')\n    }\n  },\n  {\n    name: 'hapi',\n    versions: ['^7.2'],\n    patch (hapi, tracer, config) {\n      this.wrap(hapi, 'createServer', createWrapServer(tracer, config))\n    },\n    unpatch (hapi) {\n      this.unwrap(hapi, 'createServer')\n    }\n  },\n  {\n    name: '@hapi/hapi',\n    versions: ['>=17.9'],\n    file: 'lib/core.js',\n    patch (Core, tracer, config) {\n      this.wrap(Core.prototype, '_dispatch', createWrapDispatch(tracer, config))\n    },\n    unpatch (Core) {\n      this.unwrap(Core.prototype, '_dispatch')\n    }\n  },\n  {\n    name: 'hapi',\n    versions: ['7.2 - 16'],\n    file: 'lib/connection.js',\n    patch (Connection, tracer, config) {\n      this.wrap(Connection.prototype, '_dispatch', createWrapDispatch(tracer, config))\n    },\n    unpatch (Connection) {\n      this.unwrap(Connection.prototype, '_dispatch')\n    }\n  },\n  {\n    name: 'hapi',\n    versions: ['>=17'],\n    file: 'lib/core.js',\n    patch (Core, tracer, config) {\n      this.wrap(Core.prototype, '_dispatch', createWrapDispatch(tracer, config))\n    },\n    unpatch (Core) {\n      this.unwrap(Core.prototype, '_dispatch')\n    }\n  },\n  {\n    name: 'hapi',\n    versions: ['2 - 7.1'],\n    file: 'lib/server.js',\n    patch (Server, tracer, config) {\n      this.wrap(Server.prototype, '_dispatch', createWrapDispatch(tracer, config))\n    },\n    unpatch (Server) {\n      this.unwrap(Server.prototype, '_dispatch')\n    }\n  }\n]\n","'use strict'\n\nconst url = require('url')\nconst semver = require('semver')\nconst opentracing = require('opentracing')\nconst log = require('../../dd-trace/src/log')\nconst constants = require('../../dd-trace/src/constants')\nconst tags = require('../../../ext/tags')\nconst kinds = require('../../../ext/kinds')\nconst formats = require('../../../ext/formats')\nconst urlFilter = require('../../dd-trace/src/plugins/util/urlfilter')\nconst analyticsSampler = require('../../dd-trace/src/analytics_sampler')\n\nconst Reference = opentracing.Reference\n\nconst HTTP_HEADERS = formats.HTTP_HEADERS\nconst HTTP_STATUS_CODE = tags.HTTP_STATUS_CODE\nconst HTTP_REQUEST_HEADERS = tags.HTTP_REQUEST_HEADERS\nconst HTTP_RESPONSE_HEADERS = tags.HTTP_RESPONSE_HEADERS\nconst SPAN_KIND = tags.SPAN_KIND\nconst CLIENT = kinds.CLIENT\nconst REFERENCE_CHILD_OF = opentracing.REFERENCE_CHILD_OF\nconst REFERENCE_NOOP = constants.REFERENCE_NOOP\n\nfunction patch (http, methodName, tracer, config) {\n  config = normalizeConfig(tracer, config)\n  this.wrap(http, methodName, fn => makeRequestTrace(fn))\n\n  function makeRequestTrace (request) {\n    return function requestTrace () {\n      let args\n\n      try {\n        args = normalizeArgs.apply(null, arguments)\n      } catch (e) {\n        log.error(e)\n        return request.apply(this, arguments)\n      }\n\n      const options = args.options\n      const agent = options.agent || options._defaultAgent || http.globalAgent\n      const protocol = options.protocol || agent.protocol || 'http:'\n      const hostname = options.hostname || options.host || 'localhost'\n      const host = options.port ? `${hostname}:${options.port}` : hostname\n      const path = options.path ? options.path.split(/[?#]/)[0] : '/'\n      const uri = `${protocol}//${host}${path}`\n\n      let callback = args.callback\n\n      const method = (options.method || 'GET').toUpperCase()\n\n      const scope = tracer.scope()\n      const childOf = scope.active()\n      const type = config.filter(uri) ? REFERENCE_CHILD_OF : REFERENCE_NOOP\n      const span = tracer.startSpan('http.request', {\n        references: [\n          new Reference(type, childOf)\n        ],\n        tags: {\n          [SPAN_KIND]: CLIENT,\n          'service.name': getServiceName(tracer, config, options),\n          'resource.name': method,\n          'span.type': 'http',\n          'http.method': method,\n          'http.url': uri\n        }\n      })\n\n      if (!hasAmazonSignature(options)) {\n        tracer.inject(span, HTTP_HEADERS, options.headers)\n      }\n\n      analyticsSampler.sample(span, config.analytics)\n\n      callback = scope.bind(callback, childOf)\n\n      const req = scope.bind(request, span).call(this, options, callback)\n      const emit = req.emit\n\n      req.emit = function (eventName, arg) {\n        switch (eventName) {\n          case 'response': {\n            const res = arg\n\n            scope.bind(res)\n\n            span.setTag(HTTP_STATUS_CODE, res.statusCode)\n\n            addResponseHeaders(res, span, config)\n\n            if (!config.validateStatus(res.statusCode)) {\n              span.setTag('error', 1)\n            }\n\n            res.on('end', () => finish(req, res, span, config))\n\n            break\n          }\n          case 'error':\n            addError(span, arg)\n          case 'abort': // eslint-disable-line no-fallthrough\n          case 'close': // eslint-disable-line no-fallthrough\n            finish(req, null, span, config)\n        }\n\n        return emit.apply(this, arguments)\n      }\n\n      scope.bind(req)\n\n      return req\n    }\n  }\n\n  function finish (req, res, span, config) {\n    addRequestHeaders(req, span, config)\n\n    config.hooks.request(span, req, res)\n\n    span.finish()\n  }\n\n  function addError (span, error) {\n    span.addTags({\n      'error.type': error.name,\n      'error.msg': error.message,\n      'error.stack': error.stack\n    })\n\n    return error\n  }\n\n  function addRequestHeaders (req, span, config) {\n    config.headers.forEach(key => {\n      const value = req.getHeader(key)\n\n      if (value) {\n        span.setTag(`${HTTP_REQUEST_HEADERS}.${key}`, value)\n      }\n    })\n  }\n\n  function addResponseHeaders (res, span, config) {\n    config.headers.forEach(key => {\n      const value = res.headers[key]\n\n      if (value) {\n        span.setTag(`${HTTP_RESPONSE_HEADERS}.${key}`, value)\n      }\n    })\n  }\n\n  function normalizeArgs (inputURL, inputOptions, cb) {\n    inputURL = normalizeOptions(inputURL)\n\n    const [callback, inputOptionsNormalized] = normalizeCallback(inputOptions, cb, inputURL)\n    const options = combineOptions(inputURL, inputOptionsNormalized)\n    normalizeHeaders(options)\n    const uri = url.format(options)\n\n    return { uri, options, callback }\n  }\n\n  function normalizeCallback (inputOptions, callback, inputURL) {\n    if (typeof inputOptions === 'function') {\n      return [inputOptions, inputURL || {}]\n    } else {\n      return [callback, inputOptions]\n    }\n  }\n\n  function combineOptions (inputURL, inputOptions) {\n    if (typeof inputOptions === 'object') {\n      return Object.assign(inputURL || {}, inputOptions)\n    } else {\n      return inputURL\n    }\n  }\n\n  function normalizeHeaders (options) {\n    options.headers = options.headers || {}\n  }\n\n  // https://github.com/nodejs/node/blob/7e911d8b03a838e5ac6bb06c5b313533e89673ef/lib/internal/url.js#L1271\n  function urlToOptions (url) {\n    const agent = url.agent || http.globalAgent\n    const options = {\n      protocol: url.protocol || agent.protocol,\n      hostname: typeof url.hostname === 'string' && url.hostname.startsWith('[')\n        ? url.hostname.slice(1, -1)\n        : url.hostname ||\n        url.host ||\n        'localhost',\n      hash: url.hash,\n      search: url.search,\n      pathname: url.pathname,\n      path: `${url.pathname || ''}${url.search || ''}`,\n      href: url.href\n    }\n    if (url.port !== '') {\n      options.port = Number(url.port)\n    }\n    if (url.username || url.password) {\n      options.auth = `${url.username}:${url.password}`\n    }\n    return options\n  }\n\n  function normalizeOptions (inputURL) {\n    if (typeof inputURL === 'string') {\n      try {\n        return urlToOptions(new url.URL(inputURL))\n      } catch (e) {\n        return url.parse(inputURL)\n      }\n    } else if (inputURL instanceof url.URL) {\n      return urlToOptions(inputURL)\n    } else {\n      return inputURL\n    }\n  }\n}\n\nfunction getHost (options) {\n  if (typeof options === 'string') {\n    return url.parse(options).host\n  }\n\n  const hostname = options.hostname || options.host || 'localhost'\n  const port = options.port\n\n  return [hostname, port].filter(val => val).join(':')\n}\n\nfunction getServiceName (tracer, config, options) {\n  if (config.splitByDomain) {\n    return getHost(options)\n  } else if (config.service) {\n    return config.service\n  }\n\n  return `${tracer._service}-http-client`\n}\n\nfunction hasAmazonSignature (options) {\n  if (!options) {\n    return false\n  }\n\n  if (options.headers) {\n    const headers = Object.keys(options.headers)\n      .reduce((prev, next) => Object.assign(prev, {\n        [next.toLowerCase()]: options.headers[next]\n      }), {})\n\n    if (headers['x-amz-signature']) {\n      return true\n    }\n\n    if ([].concat(headers['authorization']).some(startsWith('AWS4-HMAC-SHA256'))) {\n      return true\n    }\n  }\n\n  return options.path && options.path.toLowerCase().indexOf('x-amz-signature=') !== -1\n}\n\nfunction startsWith (searchString) {\n  return value => String(value).startsWith(searchString)\n}\n\nfunction unpatch (http) {\n  this.unwrap(http, 'request')\n  this.unwrap(http, 'get')\n}\n\nfunction getStatusValidator (config) {\n  if (typeof config.validateStatus === 'function') {\n    return config.validateStatus\n  } else if (config.hasOwnProperty('validateStatus')) {\n    log.error('Expected `validateStatus` to be a function.')\n  }\n  return code => code < 400 || code >= 500\n}\n\nfunction getFilter (tracer, config) {\n  const blacklist = tracer._url ? [getAgentFilter(tracer._url)] : []\n\n  config = Object.assign({}, config, {\n    blacklist: blacklist.concat(config.blacklist || [])\n  })\n\n  return urlFilter.getFilter(config)\n}\n\nfunction getAgentFilter (url) {\n  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#Escaping\n  const agentFilter = url.href.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')\n\n  return RegExp(`^${agentFilter}/.*$`, 'i')\n}\n\nfunction normalizeConfig (tracer, config) {\n  config = config.client || config\n\n  const validateStatus = getStatusValidator(config)\n  const filter = getFilter(tracer, config)\n  const headers = getHeaders(config)\n  const hooks = getHooks(config)\n\n  return Object.assign({}, config, {\n    validateStatus,\n    filter,\n    headers,\n    hooks\n  })\n}\n\nfunction getHeaders (config) {\n  if (!Array.isArray(config.headers)) return []\n\n  return config.headers\n    .filter(key => typeof key === 'string')\n    .map(key => key.toLowerCase())\n}\n\nfunction getHooks (config) {\n  const noop = () => {}\n  const request = (config.hooks && config.hooks.request) || noop\n\n  return { request }\n}\n\nmodule.exports = [\n  {\n    name: 'http',\n    patch: function (http, tracer, config) {\n      if (config.client === false) return\n\n      patch.call(this, http, 'request', tracer, config)\n      if (semver.satisfies(process.version, '>=8')) {\n        /**\n         * In newer Node versions references internal to modules, such as `http(s).get` calling `http(s).request`, do\n         * not use externally patched versions, which is why we need to also patch `get` here separately.\n         */\n        patch.call(this, http, 'get', tracer, config)\n      }\n    },\n    unpatch\n  },\n  {\n    name: 'https',\n    patch: function (http, tracer, config) {\n      if (config.client === false) return\n\n      if (semver.satisfies(process.version, '>=9')) {\n        patch.call(this, http, 'request', tracer, config)\n        patch.call(this, http, 'get', tracer, config)\n      } else {\n        /**\n         * Below Node v9 the `https` module invokes `http.request`, which would end up counting requests twice.\n         * So rather then patch the `https` module, we ensure the `http` module is patched and we count only there.\n         */\n        require('http')\n      }\n    },\n    unpatch\n  }\n]\n","'use strict'\n\nconst client = require('./client')\nconst server = require('./server')\n\nmodule.exports = [].concat(client, server)\n","'use strict'\n\nconst web = require('../../dd-trace/src/plugins/util/web')\nconst Scope = require('../../dd-trace/src/scope/base')\n\nfunction createWrapEmit (tracer, config) {\n  config = web.normalizeConfig(config)\n\n  return function wrapEmit (emit) {\n    return function emitWithTrace (eventName, req, res) {\n      if (eventName === 'request') {\n        return web.instrument(tracer, config, req, res, 'http.request', () => {\n          return emit.apply(this, arguments)\n        })\n      }\n\n      return emit.apply(this, arguments)\n    }\n  }\n}\n\nfunction plugin (name) {\n  return {\n    name,\n    patch (http, tracer, config) {\n      if (config.server === false) return\n\n      this.wrap(http.Server.prototype, 'emit', createWrapEmit(tracer, config))\n      if (http.ServerResponse) { // not present on https\n        Scope._wrapEmitter(http.ServerResponse.prototype)\n      }\n    },\n    unpatch (http) {\n      this.unwrap(http.Server.prototype, 'emit')\n    }\n  }\n}\n\nmodule.exports = [\n  plugin('http'),\n  plugin('https')\n]\n","'use strict'\n\nconst URL = require('url').URL\nconst opentracing = require('opentracing')\nconst log = require('../../dd-trace/src/log')\nconst constants = require('../../dd-trace/src/constants')\nconst tags = require('../../../ext/tags')\nconst kinds = require('../../../ext/kinds')\nconst formats = require('../../../ext/formats')\nconst urlFilter = require('../../dd-trace/src/plugins/util/urlfilter')\nconst analyticsSampler = require('../../dd-trace/src/analytics_sampler')\nconst shimmer = require('shimmer')\n\nconst Reference = opentracing.Reference\n\nconst HTTP_HEADERS = formats.HTTP_HEADERS\nconst HTTP_STATUS_CODE = tags.HTTP_STATUS_CODE\nconst HTTP_REQUEST_HEADERS = tags.HTTP_REQUEST_HEADERS\nconst HTTP_RESPONSE_HEADERS = tags.HTTP_RESPONSE_HEADERS\nconst SPAN_KIND = tags.SPAN_KIND\nconst CLIENT = kinds.CLIENT\nconst REFERENCE_CHILD_OF = opentracing.REFERENCE_CHILD_OF\nconst REFERENCE_NOOP = constants.REFERENCE_NOOP\n\nconst HTTP2_HEADER_METHOD = ':method'\nconst HTTP2_HEADER_PATH = ':path'\nconst HTTP2_HEADER_STATUS = ':status'\nconst HTTP2_METHOD_GET = 'GET'\n\nfunction extractSessionDetails (authority, options) {\n  if (typeof authority === 'string') {\n    authority = new URL(authority)\n  }\n\n  const protocol = authority.protocol || options.protocol || 'https:'\n  let port = '' + (authority.port !== ''\n    ? authority.port : (authority.protocol === 'http:' ? 80 : 443))\n  let host = authority.hostname || authority.host || 'localhost'\n\n  if (protocol === 'https:' && options) {\n    port = options.port || port\n    host = options.host || host\n  }\n\n  return { protocol, port, host }\n}\n\nfunction getFormattedHostString (host, port) {\n  return [host, port].filter(val => val).join(':')\n}\n\nfunction getServiceName (tracer, config, sessionDetails) {\n  if (config.splitByDomain) {\n    return getFormattedHostString(sessionDetails.host, sessionDetails.port)\n  } else if (config.service) {\n    return config.service\n  }\n\n  return `${tracer._service}-http-client`\n}\n\nfunction hasAmazonSignature (headers, path) {\n  if (headers) {\n    headers = Object.keys(headers)\n      .reduce((prev, next) => Object.assign(prev, {\n        [next.toLowerCase()]: headers[next]\n      }), {})\n\n    if (headers['x-amz-signature']) {\n      return true\n    }\n\n    if ([].concat(headers['authorization']).some(startsWith('AWS4-HMAC-SHA256'))) {\n      return true\n    }\n  }\n\n  return path && path.toLowerCase().indexOf('x-amz-signature=') !== -1\n}\n\nfunction startsWith (searchString) {\n  return value => String(value).startsWith(searchString)\n}\n\nfunction getStatusValidator (config) {\n  if (typeof config.validateStatus === 'function') {\n    return config.validateStatus\n  } else if (config.hasOwnProperty('validateStatus')) {\n    log.error('Expected `validateStatus` to be a function.')\n  }\n  return code => code < 400 || code >= 500\n}\n\nfunction getFilter (tracer, config) {\n  const blacklist = tracer._url ? [`${tracer._url.href}/v0.4/traces`] : []\n\n  config = Object.assign({}, config, {\n    blacklist: blacklist.concat(config.blacklist || [])\n  })\n\n  return urlFilter.getFilter(config)\n}\n\nfunction normalizeConfig (tracer, config) {\n  config = config.client || config\n\n  const validateStatus = getStatusValidator(config)\n  const filter = getFilter(tracer, config)\n  const headers = getHeaders(config)\n\n  return Object.assign({}, config, {\n    validateStatus,\n    filter,\n    headers\n  })\n}\n\nfunction addResponseTags (headers, span, config) {\n  const status = headers && headers[HTTP2_HEADER_STATUS]\n\n  span.setTag(HTTP_STATUS_CODE, status)\n\n  if (!config.validateStatus(status)) {\n    span.setTag('error', 1)\n  }\n\n  addHeaderTags(span, headers, HTTP_RESPONSE_HEADERS, config)\n}\n\nfunction addRequestTags (headers, span, config) {\n  addHeaderTags(span, headers, HTTP_REQUEST_HEADERS, config)\n}\n\nfunction addErrorTags (span, error) {\n  span.setTag('error', error)\n}\n\nfunction addHeaderTags (span, headers, prefix, config) {\n  if (!headers) return\n\n  config.headers.forEach(key => {\n    const value = headers[key]\n\n    if (value) {\n      span.setTag(`${prefix}.${key}`, value)\n    }\n  })\n}\n\nfunction getHeaders (config) {\n  if (!Array.isArray(config.headers)) return []\n\n  return config.headers\n    .filter(key => typeof key === 'string')\n    .map(key => key.toLowerCase())\n}\n\nfunction startSpan (tracer, config, headers, sessionDetails) {\n  headers = headers || {}\n\n  const scope = tracer.scope()\n  const childOf = scope.active()\n\n  const path = headers[HTTP2_HEADER_PATH] || '/'\n  const method = headers[HTTP2_HEADER_METHOD] || HTTP2_METHOD_GET\n  const url = `${sessionDetails.protocol}//${sessionDetails.host}:${sessionDetails.port}${path}`\n\n  const type = config.filter(url) ? REFERENCE_CHILD_OF : REFERENCE_NOOP\n\n  const span = tracer.startSpan('http.request', {\n    references: [\n      new Reference(type, childOf)\n    ],\n    tags: {\n      [SPAN_KIND]: CLIENT,\n      'service.name': getServiceName(tracer, config, sessionDetails),\n      'resource.name': method,\n      'span.type': 'http',\n      'http.method': method,\n      'http.url': url.split('?')[0]\n    }\n  })\n\n  if (!hasAmazonSignature(headers, path)) {\n    tracer.inject(span, HTTP_HEADERS, headers)\n  }\n\n  analyticsSampler.sample(span, config.analytics)\n  return span\n}\n\nfunction createWrapEmit (tracer, config, span) {\n  return function wrapEmit (emit) {\n    return function emitWithTrace (event, arg1) {\n      switch (event) {\n        case 'response':\n          addResponseTags(arg1, span, config)\n          break\n        case 'error':\n          addErrorTags(span, arg1)\n        case 'close': // eslint-disable-line no-fallthrough\n          span.finish()\n          break\n      }\n      return emit.apply(this, arguments)\n    }\n  }\n}\n\nfunction createWrapRequest (tracer, config, sessionDetails) {\n  return function wrapRequest (request) {\n    if (!sessionDetails) return request\n\n    return function requestWithTrace (headers, options) {\n      const scope = tracer.scope()\n      const span = startSpan(tracer, config, headers, sessionDetails)\n\n      addRequestTags(headers, span, config)\n\n      const req = scope.bind(request, span).apply(this, arguments)\n\n      shimmer.wrap(req, 'emit', createWrapEmit(tracer, config, span))\n      scope.bind(req)\n\n      return req\n    }\n  }\n}\n\nfunction createWrapConnect (tracer, config) {\n  config = normalizeConfig(tracer, config)\n\n  return function wrapConnect (connect) {\n    return function connectWithTrace (authority, options) {\n      const session = connect.apply(this, arguments)\n\n      const sessionDetails = extractSessionDetails(authority, options)\n\n      shimmer.wrap(session, 'request', createWrapRequest(tracer, config, sessionDetails))\n      return session\n    }\n  }\n}\n\nmodule.exports = [\n  {\n    name: 'http2',\n    patch: function (http2, tracer, config) {\n      if (config.client === false) return\n\n      this.wrap(http2, 'connect', createWrapConnect(tracer, config))\n    },\n    unpatch: function (http2) {\n      this.unwrap(http2, 'connect')\n    }\n  }\n]\n","'use strict'\n\nconst web = require('../../dd-trace/src/plugins/util/web')\nconst shimmer = require('shimmer')\n\nconst analyticsSampler = require('../../dd-trace/src/analytics_sampler')\nconst tags = require('../../../ext/tags')\nconst types = require('../../../ext/types')\nconst kinds = require('../../../ext/kinds')\n\nconst WEB = types.WEB\nconst SERVER = kinds.SERVER\nconst RESOURCE_NAME = tags.RESOURCE_NAME\nconst SERVICE_NAME = tags.SERVICE_NAME\nconst SPAN_TYPE = tags.SPAN_TYPE\nconst SPAN_KIND = tags.SPAN_KIND\nconst HTTP_METHOD = tags.HTTP_METHOD\nconst HTTP_URL = tags.HTTP_URL\nconst HTTP_STATUS_CODE = tags.HTTP_STATUS_CODE\nconst HTTP_ROUTE = tags.HTTP_ROUTE\nconst HTTP_REQUEST_HEADERS = tags.HTTP_REQUEST_HEADERS\nconst HTTP_RESPONSE_HEADERS = tags.HTTP_RESPONSE_HEADERS\n\nconst HTTP_STATUS_OK = 200\nconst HTTP2_HEADER_AUTHORITY = ':authority'\nconst HTTP2_HEADER_SCHEME = ':scheme'\nconst HTTP2_HEADER_METHOD = ':method'\nconst HTTP2_HEADER_PATH = ':path'\nconst HTTP2_HEADER_STATUS = ':status'\n\nfunction createWrapEmit (tracer, config) {\n  return function wrapEmit (emit) {\n    return function emitWithTrace (event, arg1, arg2) {\n      if (event === 'stream') {\n        const stream = arg1\n        const headers = arg2\n        return instrumentStream(tracer, config, stream, headers, 'http.request', () => {\n          return emit.apply(this, arguments)\n        })\n      } else if (event === 'request') {\n        const req = arg1\n        const res = arg2\n        return web.instrument(tracer, config, req, res, 'http.request', () => {\n          return emit.apply(this, arguments)\n        })\n      } else {\n        return emit.apply(this, arguments)\n      }\n    }\n  }\n}\n\nfunction createWrapCreateServer (tracer, config) {\n  config = web.normalizeConfig(config)\n\n  return function wrapCreateServer (createServer) {\n    return function createServerWithTrace (args) {\n      const server = createServer.apply(this, arguments)\n\n      shimmer.wrap(server, 'emit', createWrapEmit(tracer, config))\n\n      return server\n    }\n  }\n}\n\nfunction instrumentStream (tracer, config, stream, headers, name, callback) {\n  if (!stream) return callback()\n\n  headers = headers || {}\n\n  web.patch(stream)\n\n  const span = startStreamSpan(tracer, config, stream, headers, name)\n\n  // TODO: replace this with a REFERENCE_NOOP after we split http/express/etc\n  if (!config.filter(headers[HTTP2_HEADER_PATH])) {\n    span.context()._traceFlags.sampled = false\n  }\n\n  if (config.service) {\n    span.setTag(SERVICE_NAME, config.service)\n  }\n\n  analyticsSampler.sample(span, config.analytics, true)\n\n  wrapStreamEnd(stream)\n\n  addRequestTags(stream, headers)\n  addRequestHeaders(stream, headers)\n  addResourceTags(stream, headers)\n\n  return callback && tracer.scope().activate(span, () => callback(span))\n}\n\nfunction startStreamSpan (tracer, config, stream, headers, name) {\n  stream._datadog.config = config\n\n  if (stream._datadog.span) {\n    return stream._datadog.span\n  }\n\n  const span = web.startChildSpan(tracer, name, headers)\n\n  stream._datadog.tracer = tracer\n  stream._datadog.span = span\n\n  return span\n}\n\nfunction wrapStreamEnd (stream) {\n  function wrapEnd (end) {\n    return function endWithTrace () {\n      const returnValue = end.apply(this, arguments)\n\n      finishStream(stream)\n      return returnValue\n    }\n  }\n\n  shimmer.wrap(stream, 'end', wrapEnd)\n}\n\nfunction finishStream (stream) {\n  if (stream._datadog.finished) return\n\n  addResponseTags(stream)\n  addResponseHeaders(stream)\n\n  stream._datadog.span.finish()\n  stream._datadog.finished = true\n}\n\nfunction addRequestTags (stream, headers) {\n  const span = stream._datadog.span\n  const url = `${headers[HTTP2_HEADER_SCHEME]}://${headers[HTTP2_HEADER_AUTHORITY]}${headers[HTTP2_HEADER_PATH]}`\n\n  span.addTags({\n    [HTTP_METHOD]: headers[HTTP2_HEADER_METHOD],\n    [HTTP_URL]: url.split('?')[0],\n    [SPAN_KIND]: SERVER,\n    [SPAN_TYPE]: WEB\n  })\n}\n\nfunction addRequestHeaders (stream, headers) {\n  if (!headers) return\n\n  const span = stream._datadog.span\n\n  stream._datadog.config.headers.forEach(key => {\n    const reqHeader = headers[key]\n\n    if (reqHeader) {\n      span.setTag(`${HTTP_REQUEST_HEADERS}.${key}`, reqHeader)\n    }\n  })\n}\n\nfunction addResponseTags (stream) {\n  const span = stream._datadog.span\n  const headers = stream.sentHeaders\n  const statusCode = headers[HTTP2_HEADER_STATUS]\n\n  span.addTags({\n    [HTTP_STATUS_CODE]: statusCode | 0 || HTTP_STATUS_OK\n  })\n\n  web.addStatusError(stream, statusCode)\n}\n\nfunction addResponseHeaders (stream) {\n  if (!stream.sentHeaders) return\n\n  const span = stream._datadog.span\n\n  stream._datadog.config.headers.forEach(key => {\n    const resHeader = stream.sentHeaders && stream.sentHeaders[key]\n\n    if (resHeader) {\n      span.setTag(`${HTTP_RESPONSE_HEADERS}.${key}`, resHeader)\n    }\n  })\n}\n\nfunction addResourceTags (stream, headers) {\n  const span = stream._datadog.span\n  const tags = span.context()._tags\n  const method = headers[HTTP2_HEADER_METHOD]\n\n  if (tags[RESOURCE_NAME]) return\n\n  const resource = [method]\n    .concat(tags[HTTP_ROUTE])\n    .filter(val => val)\n    .join(' ')\n\n  span.setTag(RESOURCE_NAME, resource)\n}\n\nmodule.exports = [\n  {\n    name: 'http2',\n    patch (http2, tracer, config) {\n      if (config.server === false) return\n\n      this.wrap(http2, 'createServer', createWrapCreateServer(tracer, config))\n      this.wrap(http2, 'createSecureServer', createWrapCreateServer(tracer, config))\n    },\n    unpatch (http2) {\n      this.unwrap(http2, 'createServer')\n      this.unwrap(http2, 'createSecureServer')\n    }\n  }\n]\n\nmodule.exports = [] // temporarily disable HTTP2 server plugin\n","'use strict'\n\nconst tx = require('../../dd-trace/src/plugins/util/redis')\n\nfunction createWrapSendCommand (tracer, config) {\n  return function wrapSendCommand (sendCommand) {\n    return function sendCommandWithTrace (command, stream) {\n      if (!command || !command.promise || !config.filter(command.name)) return sendCommand.apply(this, arguments)\n\n      const options = this.options || {}\n      const db = options.db\n      const span = tx.instrument(tracer, config, db, command.name, command.args)\n\n      tx.setHost(span, options.host, options.port)\n      tx.wrap(span, command.promise)\n\n      return tracer.scope().bind(sendCommand, span).apply(this, arguments)\n    }\n  }\n}\n\nmodule.exports = {\n  name: 'ioredis',\n  versions: ['>=2'],\n  patch (Redis, tracer, config) {\n    config = tx.normalizeConfig(config)\n    this.wrap(Redis.prototype, 'sendCommand', createWrapSendCommand(tracer, config))\n  },\n  unpatch (Redis) {\n    this.unwrap(Redis.prototype, 'sendCommand')\n  }\n}\n","'use strict'\n\nconst tx = require('../../dd-trace/src/plugins/util/promise')\n\nfunction createPatch (file) {\n  return {\n    name: 'knex',\n    versions: ['>=0.8.0'],\n    file,\n    patch (Builder, tracer, config) {\n      this.wrap(Builder.prototype, 'then', tx.createWrapThen(tracer, config))\n    },\n    unpatch (Builder) {\n      this.unwrap(Builder.prototype, 'then')\n    }\n  }\n}\n\nmodule.exports = [\n  createPatch('lib/query/builder.js'),\n  createPatch('lib/raw.js'),\n  createPatch('lib/schema/builder.js')\n]\n","'use strict'\n\nconst web = require('../../dd-trace/src/plugins/util/web')\n\nfunction createWrapCallback (tracer, config) {\n  config = web.normalizeConfig(config)\n\n  return function wrapCallback (callback) {\n    return function callbackWithTrace () {\n      const handleRequest = callback.apply(this, arguments)\n\n      if (typeof handleRequest !== 'function') return handleRequest\n\n      return function handleRequestWithTrace (req, res) {\n        web.instrument(tracer, config, req, res, 'koa.request')\n\n        return handleRequest.apply(this, arguments)\n      }\n    }\n  }\n}\n\nfunction createWrapCreateContext () {\n  return function wrapCreateContext (createContext) {\n    return function createContextWithTrace (req, res) {\n      const ctx = createContext.apply(this, arguments)\n\n      if (!ctx) return ctx\n\n      web.patch(req)\n      web.beforeEnd(req, () => {\n        web.enterRoute(req, ctx.routePath)\n      })\n\n      return ctx\n    }\n  }\n}\n\nfunction createWrapUse () {\n  return function wrapUse (use) {\n    return function useWithTrace () {\n      const result = use.apply(this, arguments)\n\n      if (!Array.isArray(this.middleware)) return result\n\n      const fn = this.middleware.pop()\n\n      this.middleware.push(wrapMiddleware(fn))\n\n      return result\n    }\n  }\n}\n\nfunction createWrapRegister (tracer, config) {\n  return function wrapRegister (register) {\n    return function registerWithTrace (path, methods, middleware, opts) {\n      const route = register.apply(this, arguments)\n\n      if (!Array.isArray(path) && route && Array.isArray(route.stack)) {\n        wrapStack(route)\n      }\n\n      return route\n    }\n  }\n}\n\nfunction createWrapRouterUse (tracer, config) {\n  return function wrapUse (use) {\n    return function useWithTrace () {\n      const router = use.apply(this, arguments)\n\n      router.stack.forEach(wrapStack)\n\n      return router\n    }\n  }\n}\n\nfunction wrapStack (layer) {\n  layer.stack = layer.stack.map(middleware => {\n    if (typeof middleware !== 'function') return middleware\n\n    middleware = middleware._dd_original || middleware\n\n    const wrappedMiddleware = wrapMiddleware(middleware)\n\n    const handler = function (ctx, next) {\n      if (!ctx || !web.active(ctx.req)) return middleware.apply(this, arguments)\n\n      web.exitRoute(ctx.req)\n      web.enterRoute(ctx.req, layer.path)\n\n      return wrappedMiddleware.apply(this, arguments)\n    }\n\n    handler._dd_original = middleware\n\n    return handler\n  })\n}\n\nfunction wrapMiddleware (fn) {\n  if (typeof fn !== 'function') return fn\n\n  return function (ctx, next) {\n    if (!ctx) return fn.apply(this, arguments)\n\n    return web.wrapMiddleware(ctx.req, fn, 'koa.middleware', () => {\n      try {\n        const result = fn.apply(this, arguments)\n\n        if (result && typeof result.then === 'function') {\n          result.then(\n            () => web.finish(ctx.req),\n            err => web.finish(ctx.req, err)\n          )\n        } else {\n          web.finish(ctx.req)\n        }\n\n        return result\n      } catch (e) {\n        web.finish(ctx.req, e)\n        throw e\n      }\n    })\n  }\n}\n\nmodule.exports = [\n  {\n    name: 'koa',\n    versions: ['>=2'],\n    patch (Koa, tracer, config) {\n      this.wrap(Koa.prototype, 'callback', createWrapCallback(tracer, config))\n      this.wrap(Koa.prototype, 'createContext', createWrapCreateContext(tracer, config))\n      this.wrap(Koa.prototype, 'use', createWrapUse(tracer, config))\n    },\n    unpatch (Koa) {\n      this.unwrap(Koa.prototype, 'callback')\n      this.unwrap(Koa.prototype, 'createContext')\n      this.unwrap(Koa.prototype, 'use')\n    }\n  },\n  {\n    name: '@koa/router',\n    versions: ['>=8'],\n    patch (Router, tracer, config) {\n      this.wrap(Router.prototype, 'register', createWrapRegister(tracer, config))\n      this.wrap(Router.prototype, 'use', createWrapRouterUse(tracer, config))\n    },\n    unpatch (Router) {\n      this.unwrap(Router.prototype, 'register')\n      this.unwrap(Router.prototype, 'use')\n    }\n  },\n  {\n    name: 'koa-router',\n    versions: ['>=7'],\n    patch (Router, tracer, config) {\n      this.wrap(Router.prototype, 'register', createWrapRegister(tracer, config))\n      this.wrap(Router.prototype, 'use', createWrapRouterUse(tracer, config))\n    },\n    unpatch (Router) {\n      this.unwrap(Router.prototype, 'register')\n      this.unwrap(Router.prototype, 'use')\n    }\n  }\n]\n","'use strict'\n\nconst analyticsSampler = require('../../dd-trace/src/analytics_sampler')\n\nfunction createWrapCommand (tracer, config) {\n  return function wrapCommand (command) {\n    return function commandWithTrace (queryCompiler, server) {\n      const scope = tracer.scope()\n      const childOf = scope.active()\n      const span = tracer.startSpan('memcached.command', {\n        childOf,\n        tags: {\n          'span.kind': 'client',\n          'span.type': 'memcached',\n          'service.name': config.service || `${tracer._service}-memcached`\n        }\n      })\n\n      analyticsSampler.sample(span, config.analytics)\n\n      queryCompiler = wrapQueryCompiler(queryCompiler, this, server, scope, span)\n\n      return scope.bind(command, span).call(this, queryCompiler, server)\n    }\n  }\n}\n\nfunction wrapQueryCompiler (original, client, server, scope, span) {\n  const parent = scope.active()\n\n  return function () {\n    const query = original.apply(this, arguments)\n    const callback = query.callback\n\n    span.addTags({\n      'resource.name': query.type,\n      'memcached.command': query.command\n    })\n\n    addHost(span, client, server, query)\n\n    query.callback = scope.bind(function (err) {\n      addError(span, err)\n\n      span.finish()\n\n      return callback.apply(this, arguments)\n    }, parent)\n\n    return query\n  }\n}\n\nfunction addHost (span, client, server, query) {\n  const address = getAddress(client, server, query)\n\n  if (address) {\n    span.addTags({\n      'out.host': address[0],\n      'out.port': address[1]\n    })\n  }\n}\n\nfunction addError (span, error) {\n  if (error) {\n    span.addTags({\n      'error.type': error.name,\n      'error.msg': error.message,\n      'error.stack': error.stack\n    })\n  }\n\n  return error\n}\n\nfunction getAddress (client, server, query) {\n  if (!server) {\n    if (client.servers.length === 1) {\n      server = client.servers[0]\n    } else {\n      let redundancy = client.redundancy && client.redundancy < client.servers.length\n      const queryRedundancy = query.redundancyEnabled\n\n      if (redundancy && queryRedundancy) {\n        redundancy = client.HashRing.range(query.key, (client.redundancy + 1), true)\n        server = redundancy.shift()\n      } else {\n        server = client.HashRing.get(query.key)\n      }\n    }\n  }\n\n  return server && server.split(':')\n}\n\nmodule.exports = {\n  name: 'memcached',\n  versions: ['>=2.2'],\n  patch (Memcached, tracer, config) {\n    this.wrap(Memcached.prototype, 'command', createWrapCommand(tracer, config))\n  },\n  unpatch (Memcached) {\n    this.unwrap(Memcached.prototype, 'command')\n  }\n}\n","'use strict'\n\nconst web = require('../../dd-trace/src/plugins/util/web')\n\n// https://docs.apigee.com/api-platform/microgateway/3.1.x/develop-custom-plugins#eventhandlerfunctions\nconst listeners = [\n  'onrequest',\n  'ondata_request',\n  'onend_request',\n  'onclose_request',\n  'onerror_request',\n  'onresponse',\n  'ondata_response',\n  'onend_response',\n  'onclose_response',\n  'onerror_response'\n]\n\nfunction createWrapGateway (tracer, config) {\n  config = web.normalizeConfig(config)\n\n  return function wrapGateway (Gateway) {\n    return function GatewayWithTrace (config) {\n      const gateway = Gateway.apply(this, arguments)\n\n      gateway.addPlugin = wrapAddPlugin(gateway.addPlugin)\n\n      return gateway\n    }\n  }\n}\n\nfunction createWrapConfigProxyFactory (tracer, config) {\n  config = web.normalizeConfig(config)\n\n  return function wrapConfigProxyFactory (configProxyFactory) {\n    return function configProxyFactoryWithTrace () {\n      const configProxy = configProxyFactory.apply(this, arguments)\n\n      return function configProxyWithTrace (req, res, next) {\n        return web.instrument(tracer, config, req, res, 'microgateway.request', () => {\n          web.beforeEnd(req, () => {\n            res.proxy && web.enterRoute(req, res.proxy.base_path)\n          })\n\n          return configProxy.call(this, req, res, wrapNext(req, next))\n        })\n      }\n    }\n  }\n}\n\nfunction createWrapPluginsFactory (tracer, config) {\n  config = web.normalizeConfig(config)\n\n  return function wrapPluginsFactory (pluginsFactory) {\n    return function pluginsFactoryWithTrace (plugins) {\n      const pluginsMiddleware = pluginsFactory.apply(this, arguments)\n\n      return function pluginsMiddlewareWithTrace (req, res, next) {\n        return pluginsMiddleware.call(this, req, res, wrapNext(req, next))\n      }\n    }\n  }\n}\n\nfunction wrapAddPlugin (addPlugin) {\n  return function (name, plugin) {\n    if (typeof plugin === 'function') {\n      plugin = wrapPluginInit(plugin)\n    } else if (plugin && typeof plugin.init === 'function') {\n      plugin.init = wrapPluginInit(plugin.init)\n    }\n\n    return addPlugin.call(this, name, plugin)\n  }\n}\n\nfunction wrapPluginInit (init) {\n  return function initWithTrace (config, logging, stats) {\n    const handler = init.apply(this, arguments)\n\n    if (!handler._dd_patched) {\n      wrapListeners(handler)\n    }\n\n    return handler\n  }\n}\n\nfunction wrapNext (req, next) {\n  return function nextWithTrace (err) {\n    web.addError(req, err)\n\n    return next.apply(this, arguments)\n  }\n}\n\nfunction wrapListeners (handler) {\n  for (const name of listeners) {\n    const listener = handler[name]\n\n    if (!listener) continue\n\n    switch (listener.length) {\n      case 3:\n        handler[name] = function handlerWithTrace (req, res, next) {\n          return web.reactivate(req, () => listener.apply(this, arguments))\n        }\n        break\n      case 4:\n        handler[name] = function handlerWithTrace (req, res, data, next) {\n          return web.reactivate(req, () => listener.apply(this, arguments))\n        }\n        break\n    }\n  }\n}\n\nmodule.exports = [\n  {\n    name: 'microgateway-core',\n    versions: ['>=2.1'],\n    patch (Gateway, tracer, config) {\n      return this.wrapExport(Gateway, createWrapGateway(tracer, config)(Gateway))\n    },\n    unpatch (Gateway) {\n      this.unwrapExport(Gateway)\n    }\n  },\n  {\n    name: 'microgateway-core',\n    versions: ['>=2.1'],\n    file: 'lib/config-proxy-middleware.js',\n    patch (configProxyFactory, tracer, config) {\n      const wrapper = createWrapConfigProxyFactory(tracer, config)(configProxyFactory)\n      return this.wrapExport(configProxyFactory, wrapper)\n    },\n    unpatch (configProxyFactory) {\n      this.unwrapExport(configProxyFactory)\n    }\n  },\n  {\n    name: 'microgateway-core',\n    versions: ['>=2.1'],\n    file: 'lib/plugins-middleware.js',\n    patch (pluginsFactory, tracer, config) {\n      const wrapper = createWrapPluginsFactory(tracer, config)(pluginsFactory)\n      return this.wrapExport(pluginsFactory, wrapper)\n    },\n    unpatch (pluginsFactory) {\n      this.unwrapExport(pluginsFactory)\n    }\n  }\n]\n","'use strict'\n\nconst unified = require('./unified')\nconst legacy = require('./legacy')\n\nmodule.exports = [].concat(unified, legacy)\n","'use strict'\n\nconst { instrument } = require('./util')\n\nfunction createWrapCommand (tracer, config, name) {\n  return function wrapCommand (command) {\n    return function commandWithTrace (ns, ops) {\n      return instrument(command, this, arguments, this, ns, ops, tracer, config, { name })\n    }\n  }\n}\n\nfunction createWrapQuery (tracer, config) {\n  return function wrapQuery (query) {\n    return function queryWithTrace () {\n      const pool = this.server.s.pool\n      const ns = this.ns\n      const ops = this.cmd\n\n      return instrument(query, this, arguments, pool, ns, ops, tracer, config)\n    }\n  }\n}\n\nfunction createWrapCursor (tracer, config, name) {\n  return function wrapCursor (cursor) {\n    return function cursorWithTrace () {\n      const pool = this.server.s.pool\n      const ns = this.ns\n\n      return instrument(cursor, this, arguments, pool, ns, {}, tracer, config, { name })\n    }\n  }\n}\n\nmodule.exports = [\n  {\n    name: 'mongodb-core',\n    versions: ['2 - 3.1.9'],\n    patch ({ Cursor, Server }, tracer, config) {\n      this.wrap(Server.prototype, 'command', createWrapCommand(tracer, config))\n      this.wrap(Server.prototype, 'insert', createWrapCommand(tracer, config, 'insert'))\n      this.wrap(Server.prototype, 'update', createWrapCommand(tracer, config, 'update'))\n      this.wrap(Server.prototype, 'remove', createWrapCommand(tracer, config, 'remove'))\n      this.wrap(Cursor.prototype, '_getmore', createWrapCursor(tracer, config, 'getMore'))\n      this.wrap(Cursor.prototype, '_find', createWrapQuery(tracer, config))\n      this.wrap(Cursor.prototype, 'kill', createWrapCursor(tracer, config, 'killCursors'))\n    },\n    unpatch ({ Cursor, Server }) {\n      this.unwrap(Server.prototype, 'command')\n      this.unwrap(Server.prototype, 'insert')\n      this.unwrap(Server.prototype, 'update')\n      this.unwrap(Server.prototype, 'remove')\n      this.unwrap(Cursor.prototype, '_getmore')\n      this.unwrap(Cursor.prototype, '_find')\n      this.unwrap(Cursor.prototype, 'kill')\n    }\n  }\n]\n","'use strict'\n\nconst { instrument } = require('./util')\n\nfunction createWrapCommand (tracer, config, name) {\n  return function wrapCommand (command) {\n    return function commandWithTrace (server, ns, ops) {\n      return instrument(command, this, arguments, server, ns, ops, tracer, config, { name })\n    }\n  }\n}\n\nfunction patch (wp, tracer, config) {\n  this.wrap(wp, 'command', createWrapCommand(tracer, config))\n  this.wrap(wp, 'insert', createWrapCommand(tracer, config, 'insert'))\n  this.wrap(wp, 'update', createWrapCommand(tracer, config, 'update'))\n  this.wrap(wp, 'remove', createWrapCommand(tracer, config, 'remove'))\n  this.wrap(wp, 'query', createWrapCommand(tracer, config))\n  this.wrap(wp, 'getMore', createWrapCommand(tracer, config, 'getMore'))\n  this.wrap(wp, 'killCursors', createWrapCommand(tracer, config, 'killCursors'))\n}\n\nfunction unpatch (wp) {\n  this.unwrap(wp, 'command')\n  this.unwrap(wp, 'insert')\n  this.unwrap(wp, 'update')\n  this.unwrap(wp, 'remove')\n  this.unwrap(wp, 'query')\n  this.unwrap(wp, 'getMore')\n  this.unwrap(wp, 'killCursors')\n}\n\nfunction patchClass (WireProtocol, tracer, config) {\n  this.wrap(WireProtocol.prototype, 'command', createWrapCommand(tracer, config))\n}\n\nfunction unpatchClass (WireProtocol) {\n  this.unwrap(WireProtocol.prototype, 'command')\n}\n\nmodule.exports = [\n  {\n    name: 'mongodb',\n    versions: ['>=3.3'],\n    file: 'lib/core/wireprotocol/index.js',\n    patch,\n    unpatch\n  },\n  {\n    name: 'mongodb-core',\n    versions: ['>=3.2'],\n    file: 'lib/wireprotocol/index.js',\n    patch,\n    unpatch\n  },\n  {\n    name: 'mongodb-core',\n    versions: ['~3.1.10'],\n    file: 'lib/wireprotocol/3_2_support.js',\n    patch: patchClass,\n    unpatch: unpatchClass\n  },\n  {\n    name: 'mongodb-core',\n    versions: ['~3.1.10'],\n    file: 'lib/wireprotocol/2_6_support.js',\n    patch: patchClass,\n    unpatch: unpatchClass\n  }\n]\n","'use strict'\n\nconst analyticsSampler = require('../../dd-trace/src/analytics_sampler')\n\nfunction instrument (command, ctx, args, server, ns, ops, tracer, config, options = {}) {\n  const name = options.name || (ops && Object.keys(ops)[0])\n  const index = args.length - 1\n  const callback = args[index]\n\n  if (typeof callback !== 'function') return command.apply(ctx, args)\n\n  const span = startSpan(tracer, config, ns, ops, server, name)\n\n  if (name !== 'getMore' && name !== 'killCursors') {\n    analyticsSampler.sample(span, config.analytics)\n  }\n\n  args[index] = wrapCallback(tracer, span, callback)\n\n  return tracer.scope().bind(command, span).apply(ctx, args)\n}\n\nfunction startSpan (tracer, config, ns, ops, server, name) {\n  const scope = tracer.scope()\n  const childOf = scope.active()\n  const span = tracer.startSpan('mongodb.query', { childOf })\n\n  addTags(span, tracer, config, ns, ops, server, name)\n\n  return span\n}\n\nfunction wrapCallback (tracer, span, done) {\n  return tracer.scope().bind((err, res) => {\n    if (err) {\n      span.addTags({\n        'error.type': err.name,\n        'error.msg': err.message,\n        'error.stack': err.stack\n      })\n    }\n\n    span.finish()\n\n    if (done) {\n      done(err, res)\n    }\n  })\n}\n\nfunction addTags (span, tracer, config, ns, cmd, topology, operationName) {\n  const query = getQuery(cmd)\n  const resource = getResource(ns, query, operationName)\n\n  span.addTags({\n    'service.name': config.service || `${tracer._service}-mongodb`,\n    'resource.name': resource,\n    'span.type': 'mongodb',\n    'db.name': ns\n  })\n\n  if (query) {\n    span.setTag('mongodb.query', query)\n  }\n\n  addHost(span, topology)\n}\n\nfunction addHost (span, topology) {\n  const options = topology && topology.s && topology.s.options\n\n  if (options && options.host && options.port) {\n    span.addTags({\n      'out.host': topology.s.options.host,\n      'out.port': topology.s.options.port\n    })\n  }\n}\n\nfunction getQuery (cmd) {\n  if (!cmd || typeof cmd !== 'object' || Array.isArray(cmd)) return\n  if (cmd.query) return JSON.stringify(sanitize(cmd.query))\n  if (cmd.filter) return JSON.stringify(sanitize(cmd.filter))\n}\n\nfunction getResource (ns, query, operationName) {\n  const parts = [operationName, ns]\n\n  if (query) {\n    parts.push(query)\n  }\n\n  return parts.join(' ')\n}\n\nfunction sanitize (input) {\n  const output = {}\n\n  if (!isObject(input) || Buffer.isBuffer(input) || isBSON(input)) return '?'\n\n  for (const key in input) {\n    if (typeof input[key] === 'function') continue\n\n    output[key] = sanitize(input[key])\n  }\n\n  return output\n}\n\nfunction isObject (val) {\n  return typeof val === 'object' && val !== null && !(val instanceof Array)\n}\n\nfunction isBSON (val) {\n  return val && val._bsontype\n}\n\nmodule.exports = { instrument }\n","'use strict'\n\nconst tx = require('../../dd-trace/src/plugins/util/promise')\n\nfunction createWrapCollectionAddQueue (tracer, config) {\n  return function wrapAddQueue (addQueue) {\n    return function addQueueWithTrace (name) {\n      const scope = tracer.scope()\n\n      if (typeof name === 'function') {\n        arguments[0] = scope.bind(name)\n      } else if (typeof this[name] === 'function') {\n        arguments[0] = scope.bind((...args) => this[name](...args))\n      }\n\n      return addQueue.apply(this, arguments)\n    }\n  }\n}\n\nmodule.exports = [\n  {\n    name: 'mongoose',\n    versions: ['>=4.6.4'],\n    patch (mongoose, tracer, config) {\n      if (mongoose.Promise !== global.Promise) {\n        this.wrap(mongoose.Promise.prototype, 'then', tx.createWrapThen(tracer, config))\n      }\n\n      this.wrap(mongoose.Collection.prototype, 'addQueue', createWrapCollectionAddQueue(tracer, config))\n    },\n    unpatch (mongoose) {\n      if (mongoose.Promise !== global.Promise) {\n        this.unwrap(mongoose.Promise.prototype, 'then')\n      }\n\n      this.unwrap(mongoose.Collection.prototype, 'addQueue')\n    }\n  }\n]\n","'use strict'\n\nconst Tags = require('opentracing').Tags\nconst analyticsSampler = require('../../dd-trace/src/analytics_sampler')\n\nfunction createWrapQuery (tracer, config) {\n  return function wrapQuery (query) {\n    return function queryWithTrace (sql, values, cb) {\n      const scope = tracer.scope()\n      const childOf = scope.active()\n      const span = tracer.startSpan('mysql.query', {\n        childOf,\n        tags: {\n          [Tags.SPAN_KIND]: Tags.SPAN_KIND_RPC_CLIENT,\n          'service.name': config.service || `${tracer._service}-mysql`,\n          'span.type': 'sql',\n          'db.type': 'mysql',\n          'db.user': this.config.user,\n          'out.host': this.config.host,\n          'out.port': this.config.port\n        }\n      })\n\n      if (this.config.database) {\n        span.setTag('db.name', this.config.database)\n      }\n\n      analyticsSampler.sample(span, config.analytics)\n\n      const sequence = scope.bind(query, span).call(this, sql, values, cb)\n\n      scope.bind(sequence)\n\n      span.setTag('resource.name', sequence.sql)\n\n      if (sequence._callback) {\n        sequence._callback = wrapCallback(tracer, span, childOf, sequence._callback)\n      } else {\n        sequence.on('end', () => {\n          span.finish()\n        })\n      }\n\n      return sequence\n    }\n  }\n}\n\nfunction createWrapGetConnection (tracer, config) {\n  return function wrapGetConnection (getConnection) {\n    return function getConnectionWithTrace (cb) {\n      const scope = tracer.scope()\n      return scope.bind(getConnection).call(this, scope.bind(cb))\n    }\n  }\n}\n\nfunction wrapCallback (tracer, span, parent, done) {\n  return tracer.scope().bind((...args) => {\n    const err = args[0]\n    if (err) {\n      span.addTags({\n        'error.type': err.name,\n        'error.msg': err.message,\n        'error.stack': err.stack\n      })\n    }\n\n    span.finish()\n\n    done(...args)\n  }, parent)\n}\n\nfunction patchConnection (Connection, tracer, config) {\n  this.wrap(Connection.prototype, 'query', createWrapQuery(tracer, config))\n}\n\nfunction unpatchConnection (Connection) {\n  this.unwrap(Connection.prototype, 'query')\n}\n\nfunction patchPool (Pool, tracer, config) {\n  this.wrap(Pool.prototype, 'getConnection', createWrapGetConnection(tracer, config))\n}\n\nfunction unpatchPool (Pool) {\n  this.unwrap(Pool.prototype, 'getConnection')\n}\n\nmodule.exports = [\n  {\n    name: 'mysql',\n    file: 'lib/Connection.js',\n    versions: ['>=2'],\n    patch: patchConnection,\n    unpatch: unpatchConnection\n  },\n  {\n    name: 'mysql',\n    file: 'lib/Pool.js',\n    versions: ['>=2'],\n    patch: patchPool,\n    unpatch: unpatchPool\n  }\n]\n","'use strict'\n\nconst Tags = require('opentracing').Tags\nconst analyticsSampler = require('../../dd-trace/src/analytics_sampler')\n\nfunction createWrapAddCommand (tracer, config) {\n  return function wrapAddCommand (addCommand) {\n    return function addCommandWithTrace (cmd) {\n      const name = cmd && cmd.constructor && cmd.constructor.name\n      const isCommand = typeof cmd.execute === 'function'\n      const isSupported = name === 'Execute' || name === 'Query'\n\n      if (isCommand && isSupported) {\n        cmd.execute = wrapExecute(tracer, config, cmd.execute)\n      }\n\n      return addCommand.apply(this, arguments)\n    }\n  }\n}\n\nfunction wrapExecute (tracer, config, execute) {\n  const scope = tracer.scope()\n  const childOf = scope.active()\n\n  return function executeWithTrace (packet, connection) {\n    const connectionConfig = (connection && connection.config) || {}\n    const sql = this.statement ? this.statement.query : this.sql\n    const span = tracer.startSpan('mysql.query', {\n      childOf,\n      tags: {\n        [Tags.SPAN_KIND]: Tags.SPAN_KIND_RPC_CLIENT,\n        'service.name': config.service || `${tracer._service}-mysql`,\n        'resource.name': sql,\n        'span.type': 'sql',\n        'db.type': 'mysql',\n        'db.user': connectionConfig.user,\n        'db.name': connectionConfig.database,\n        'out.host': connectionConfig.host,\n        'out.port': connectionConfig.port\n      }\n    })\n\n    analyticsSampler.sample(span, config.analytics)\n\n    if (typeof this.onResult === 'function') {\n      this.onResult = wrapCallback(tracer, span, childOf, this.onResult)\n    } else {\n      this.on('error', error => span.addTags({ error }))\n      this.on('end', () => span.finish())\n    }\n\n    this.execute = execute\n\n    return scope.bind(execute, span).apply(this, arguments)\n  }\n}\n\nfunction wrapCallback (tracer, span, parent, done) {\n  return tracer.scope().bind((error, res) => {\n    span.addTags({ error })\n    span.finish()\n\n    done(error, res)\n  }, parent)\n}\n\nmodule.exports = [\n  {\n    name: 'mysql2',\n    file: 'lib/connection.js',\n    versions: ['>=1'],\n    patch (Connection, tracer, config) {\n      this.wrap(Connection.prototype, 'addCommand', createWrapAddCommand(tracer, config))\n    },\n    unpatch (Connection) {\n      this.unwrap(Connection.prototype, 'addCommand')\n    }\n  },\n  {\n    name: 'mysql2',\n    file: 'lib/commands/command.js',\n    versions: ['>=1'],\n    patch (Command, tracer, config) {\n      tracer.scope().bind(Command.prototype)\n    },\n    unpatch (Command, tracer) {\n      tracer.scope().unbind(Command.prototype)\n    }\n  }\n]\n","'use strict'\n\nconst tx = require('../../dd-trace/src/plugins/util/tx')\nconst analyticsSampler = require('../../dd-trace/src/analytics_sampler')\n\nfunction createWrapConnect (tracer, config) {\n  return function wrapConnect (connect) {\n    return function connectWithTrace () {\n      const scope = tracer.scope()\n      const options = getOptions(arguments)\n      const lastIndex = arguments.length - 1\n      const callback = arguments[lastIndex]\n\n      if (!options) return connect.apply(this, arguments)\n\n      if (typeof callback === 'function') {\n        arguments[lastIndex] = scope.bind(callback)\n      }\n\n      const span = options.path\n        ? wrapIpc(tracer, config, this, options)\n        : wrapTcp(tracer, config, this, options)\n\n      analyticsSampler.sample(span, config.analytics)\n\n      return scope.bind(connect, span).apply(this, arguments)\n    }\n  }\n}\n\nfunction wrapTcp (tracer, config, socket, options) {\n  const host = options.host || 'localhost'\n  const port = options.port || 0\n  const family = options.family || 4\n\n  const span = startSpan(tracer, config, 'tcp', {\n    'resource.name': [host, port].filter(val => val).join(':'),\n    'tcp.remote.host': host,\n    'tcp.remote.port': port,\n    'tcp.family': `IPv${family}`,\n    'out.host': host,\n    'out.port': port\n  })\n\n  setupListeners(socket, span, 'tcp')\n\n  return span\n}\n\nfunction wrapIpc (tracer, config, socket, options) {\n  const span = startSpan(tracer, config, 'ipc', {\n    'resource.name': options.path,\n    'ipc.path': options.path\n  })\n\n  setupListeners(socket, span, 'ipc')\n\n  return span\n}\n\nfunction startSpan (tracer, config, protocol, tags) {\n  const childOf = tracer.scope().active()\n  const span = tracer.startSpan(`${protocol}.connect`, {\n    childOf,\n    tags: Object.assign({\n      'span.kind': 'client',\n      'service.name': config.service || `${tracer._service}-${protocol}`\n    }, tags)\n  })\n\n  return span\n}\n\nfunction getOptions (args) {\n  if (!args[0]) return\n\n  switch (typeof args[0]) {\n    case 'object':\n      if (Array.isArray(args[0])) return getOptions(args[0])\n      return args[0]\n    case 'string':\n      if (isNaN(parseFloat(args[0]))) {\n        return {\n          path: args[0]\n        }\n      }\n    case 'number': // eslint-disable-line no-fallthrough\n      return {\n        port: args[0],\n        host: typeof args[1] === 'string' ? args[1] : 'localhost'\n      }\n  }\n}\n\nfunction setupListeners (socket, span, protocol) {\n  const events = ['connect', 'error', 'close', 'timeout']\n\n  const wrapListener = tx.wrap(span)\n\n  const localListener = () => {\n    span.addTags({\n      'tcp.local.address': socket.localAddress,\n      'tcp.local.port': socket.localPort\n    })\n  }\n\n  const cleanupListener = () => {\n    socket.removeListener('connect', localListener)\n\n    events.forEach(event => {\n      socket.removeListener(event, wrapListener)\n      socket.removeListener(event, cleanupListener)\n    })\n  }\n\n  if (protocol === 'tcp') {\n    socket.once('connect', localListener)\n  }\n\n  events.forEach(event => {\n    socket.once(event, wrapListener)\n    socket.once(event, cleanupListener)\n  })\n}\n\nmodule.exports = {\n  name: 'net',\n  patch (net, tracer, config) {\n    require('dns') // net will otherwise get an unpatched version for DNS lookups\n\n    tracer.scope().bind(net.Socket.prototype)\n\n    this.wrap(net.Socket.prototype, 'connect', createWrapConnect(tracer, config))\n  },\n  unpatch (net, tracer) {\n    tracer.scope().unbind(net.Socket.prototype)\n\n    this.unwrap(net.Socket.prototype, 'connect')\n  }\n}\n","'use strict'\n\nconst web = require('../../dd-trace/src/plugins/util/web')\n\nconst traceRoute = handler => req => {\n  const { original, route } = req\n\n  if (web.active(original)) {\n    web.enterRoute(original, route)\n  }\n\n  return handler(req)\n}\n\nconst wrapLogger = tracer => logger => record => {\n  const span = tracer.scope().active()\n\n  if (!span) return logger(record)\n\n  const correlation = {\n    dd: {\n      trace_id: span.context().toTraceId(),\n      span_id: span.context().toSpanId()\n    }\n  }\n\n  record = record instanceof Error\n    ? Object.assign(record, correlation)\n    : Object.assign({}, record, correlation)\n\n  return logger(record)\n}\n\nconst wrapMount = (tracer, config) => mount => opts => {\n  const handler = mount(opts)\n\n  const traced = (req, res) =>\n    web.instrument(\n      tracer, config, req, res, 'paperplane.request',\n      () => handler(req, res)\n    )\n\n  return traced\n}\n\nconst wrapRoutes = tracer => routes => handlers => {\n  const traced = {}\n\n  for (const route in handlers) {\n    traced[route] = traceRoute(handlers[route])\n  }\n\n  return routes(traced)\n}\n\nmodule.exports = [\n  {\n    name: 'paperplane',\n    versions: ['>=2.3.2'],\n    file: 'lib/logger.js',\n    patch (exports, tracer) {\n      if (tracer._logInjection) {\n        this.wrap(exports, 'logger', wrapLogger(tracer))\n      }\n    },\n    unpatch (exports) {\n      this.unwrap(exports, 'logger')\n    }\n  },\n  {\n    name: 'paperplane',\n    versions: ['>=2.3.2'],\n    file: 'lib/mount.js',\n    patch (exports, tracer, config) {\n      config = web.normalizeConfig(config)\n      this.wrap(exports, 'mount', wrapMount(tracer, config))\n    },\n    unpatch (exports) {\n      this.unwrap(exports, 'mount')\n    }\n  },\n  {\n    name: 'paperplane',\n    versions: ['>=2.3.2'],\n    file: 'lib/routes.js',\n    patch (exports, tracer) {\n      this.wrap(exports, 'routes', wrapRoutes(tracer))\n    },\n    unpatch (exports) {\n      this.unwrap(exports, 'routes')\n    }\n  },\n  {\n    name: 'paperplane',\n    versions: ['2.3.0 - 2.3.1'],\n    patch (paperplane, tracer, config) {\n      config = web.normalizeConfig(config)\n      this.wrap(paperplane, 'mount', wrapMount(tracer, config))\n      this.wrap(paperplane, 'routes', wrapRoutes(tracer))\n    },\n    unpatch (paperplane) {\n      this.unwrap(paperplane, ['mount', 'routes'])\n    }\n  }\n]\n","'use strict'\n\nconst Tags = require('opentracing').Tags\nconst analyticsSampler = require('../../dd-trace/src/analytics_sampler')\n\nconst OPERATION_NAME = 'pg.query'\n\nfunction createWrapQuery (tracer, config) {\n  return function wrapQuery (query) {\n    return function queryWithTrace () {\n      const scope = tracer.scope()\n      const childOf = scope.active()\n      const params = this.connectionParameters\n      const service = getServiceName(tracer, config, params)\n      const span = tracer.startSpan(OPERATION_NAME, {\n        childOf,\n        tags: {\n          [Tags.SPAN_KIND]: Tags.SPAN_KIND_RPC_CLIENT,\n          'service.name': service,\n          'span.type': 'sql',\n          'db.type': 'postgres'\n        }\n      })\n\n      analyticsSampler.sample(span, config.analytics)\n\n      const retval = scope.bind(query, span).apply(this, arguments)\n      const queryQueue = this.queryQueue || this._queryQueue\n      const activeQuery = this.activeQuery || this._activeQuery\n      const pgQuery = queryQueue[queryQueue.length - 1] || activeQuery\n\n      if (!pgQuery) {\n        return retval\n      }\n\n      const originalCallback = pgQuery.callback\n      const statement = pgQuery.text\n\n      span.setTag('resource.name', statement)\n\n      if (params) {\n        span.addTags({\n          'db.name': params.database,\n          'db.user': params.user,\n          'out.host': params.host,\n          'out.port': params.port\n        })\n      }\n\n      const finish = (error) => {\n        span.setTag('error', error)\n        span.finish()\n      }\n\n      if (originalCallback) {\n        pgQuery.callback = scope.bind((err, res) => {\n          finish(err)\n          originalCallback(err, res)\n        }, childOf)\n      } else if (pgQuery.once) {\n        pgQuery\n          .once('error', finish)\n          .once('end', () => finish())\n      } else {\n        pgQuery.then(() => finish(), finish)\n      }\n\n      return retval\n    }\n  }\n}\n\nfunction getServiceName (tracer, config, params) {\n  if (typeof config.service === 'function') {\n    return config.service(params)\n  } else if (config.service) {\n    return config.service\n  } else {\n    return `${tracer._service}-postgres`\n  }\n}\n\nmodule.exports = [\n  {\n    name: 'pg',\n    versions: ['>=4'],\n    patch (pg, tracer, config) {\n      this.wrap(pg.Client.prototype, 'query', createWrapQuery(tracer, config))\n    },\n    unpatch (pg) {\n      this.unwrap(pg.Client.prototype, 'query')\n    }\n  },\n  {\n    name: 'pg',\n    versions: ['>=4'],\n    file: 'lib/native/index.js',\n    patch (Client, tracer, config) {\n      this.wrap(Client.prototype, 'query', createWrapQuery(tracer, config))\n    },\n    unpatch (Client) {\n      this.unwrap(Client.prototype, 'query')\n    }\n  }\n]\n","'use strict'\n\nconst { LOG } = require('../../../ext/formats')\n\nfunction createWrapPino (tracer, config) {\n  return function wrapPino (pino) {\n    return function pinoWithTrace () {\n      const instance = pino.apply(this, arguments)\n      const asJsonSym = (pino.symbols && pino.symbols.asJsonSym) || 'asJson'\n\n      Object.defineProperty(instance, asJsonSym, {\n        configurable: true,\n        enumerable: true,\n        writable: true,\n        value: createWrapAsJson(tracer, config)(instance[asJsonSym])\n      })\n\n      return instance\n    }\n  }\n}\n\nfunction createWrapAsJson (tracer, config) {\n  return function wrapAsJson (asJson) {\n    return function asJsonWithTrace (obj, msg, num, time) {\n      const span = tracer.scope().active()\n\n      obj = arguments[0] = obj || {}\n\n      tracer.inject(span, LOG, obj)\n\n      const json = asJson.apply(this, arguments)\n\n      obj && delete obj.dd\n\n      return json\n    }\n  }\n}\n\nmodule.exports = [\n  {\n    name: 'pino',\n    versions: ['2 - 3', '4', '>=5'],\n    patch (pino, tracer, config) {\n      if (!tracer._logInjection) return\n      return this.wrapExport(pino, createWrapPino(tracer, config)(pino))\n    },\n    unpatch (pino) {\n      return this.unwrapExport(pino)\n    }\n  }\n]\n","'use strict'\n\nconst tx = require('../../dd-trace/src/plugins/util/promise')\n\nmodule.exports = [\n  {\n    name: 'promise-js',\n    versions: ['>=0.0.3'],\n    patch (Promise, tracer, config) {\n      if (Promise !== global.Promise) {\n        this.wrap(Promise.prototype, 'then', tx.createWrapThen(tracer, config))\n      }\n    },\n    unpatch (Promise) {\n      if (Promise !== global.Promise) {\n        this.unwrap(Promise.prototype, 'then')\n      }\n    }\n  }\n]\n","'use strict'\n\nconst tx = require('../../dd-trace/src/plugins/util/promise')\n\nmodule.exports = [\n  {\n    name: 'promise',\n    file: 'lib/core.js',\n    versions: ['>=7'],\n    patch (Promise, tracer, config) {\n      this.wrap(Promise.prototype, 'then', tx.createWrapThen(tracer, config))\n    },\n    unpatch (Promise) {\n      this.unwrap(Promise.prototype, 'then')\n    }\n  }\n]\n","'use strict'\n\nconst tx = require('../../dd-trace/src/plugins/util/promise')\n\nmodule.exports = [\n  {\n    name: 'q',\n    versions: ['>=1'],\n    patch (Q, tracer, config) {\n      this.wrap(Q.makePromise.prototype, 'then', tx.createWrapThen(tracer, config))\n    },\n    unpatch (Q) {\n      this.unwrap(Q.makePromise.prototype, 'then')\n    }\n  }\n]\n","'use strict'\n\nconst tx = require('../../dd-trace/src/plugins/util/redis')\n\nfunction createWrapInternalSendCommand (tracer, config) {\n  return function wrapInternalSendCommand (internalSendCommand) {\n    return function internalSendCommandWithTrace (options) {\n      if (!config.filter(options.command)) return internalSendCommand.apply(this, arguments)\n\n      const scope = tracer.scope()\n      const span = startSpan(tracer, config, this, options.command, options.args)\n\n      options.callback = scope.bind(tx.wrap(span, options.callback))\n\n      return scope.bind(internalSendCommand, span).call(this, options)\n    }\n  }\n}\n\nfunction createWrapSendCommand (tracer, config) {\n  return function wrapSendCommand (sendCommand) {\n    return function sendCommandWithTrace (command, args, callback) {\n      if (!config.filter(command)) return sendCommand.apply(this, arguments)\n\n      const scope = tracer.scope()\n      const span = startSpan(tracer, config, this, command, args)\n\n      if (typeof callback === 'function') {\n        callback = scope.bind(tx.wrap(span, callback))\n      } else if (Array.isArray(args) && typeof args[args.length - 1] === 'function') {\n        args[args.length - 1] = scope.bind(tx.wrap(span, args[args.length - 1]))\n      } else {\n        callback = tx.wrap(span)\n      }\n\n      return scope.bind(sendCommand, span).call(this, command, args, callback)\n    }\n  }\n}\n\nfunction startSpan (tracer, config, client, command, args) {\n  const db = client.selected_db\n  const connectionOptions = client.connection_options || client.connection_option || client.connectionOption || {}\n  const span = tx.instrument(tracer, config, db, command, args)\n\n  tx.setHost(span, connectionOptions.host, connectionOptions.port)\n\n  return span\n}\n\nmodule.exports = [\n  {\n    name: 'redis',\n    versions: ['>=2.6'],\n    patch (redis, tracer, config) {\n      config = tx.normalizeConfig(config)\n      this.wrap(redis.RedisClient.prototype, 'internal_send_command', createWrapInternalSendCommand(tracer, config))\n    },\n    unpatch (redis) {\n      this.unwrap(redis.RedisClient.prototype, 'internal_send_command')\n    }\n  },\n  {\n    name: 'redis',\n    versions: ['>=0.12 <2.6'],\n    patch (redis, tracer, config) {\n      config = tx.normalizeConfig(config)\n      this.wrap(redis.RedisClient.prototype, 'send_command', createWrapSendCommand(tracer, config))\n    },\n    unpatch (redis) {\n      this.unwrap(redis.RedisClient.prototype, 'send_command')\n    }\n  }\n]\n","'use strict'\n\nconst web = require('../../dd-trace/src/plugins/util/web')\nconst handlers = ['use', 'pre']\nconst methods = ['del', 'get', 'head', 'opts', 'post', 'put', 'patch']\n\nfunction createWrapSetupRequest (tracer, config) {\n  config = web.normalizeConfig(config)\n\n  return function wrapSetupRequest (setupRequest) {\n    return function setupRequestWithTrace (req, res) {\n      return web.instrument(tracer, config, req, res, 'restify.request', () => {\n        web.beforeEnd(req, () => {\n          if (req.route) {\n            web.enterRoute(req, req.route.path)\n          }\n        })\n\n        return setupRequest.apply(this, arguments)\n      })\n    }\n  }\n}\n\nfunction createWrapMethod (tracer, config) {\n  return function wrapMethod (method) {\n    return function methodWithTrace (path) {\n      const middleware = wrapMiddleware(Array.prototype.slice.call(arguments, 1))\n\n      return method.apply(this, [path].concat(middleware))\n    }\n  }\n}\n\nfunction createWrapHandler (tracer, config) {\n  return function wrapMethod (method) {\n    return function methodWithTrace () {\n      return method.apply(this, wrapMiddleware(arguments))\n    }\n  }\n}\n\nfunction wrapMiddleware (middleware) {\n  return Array.prototype.map.call(middleware, wrapFn)\n}\n\nfunction wrapFn (fn) {\n  if (Array.isArray(fn)) return wrapMiddleware(fn)\n\n  return function (req, res, next) {\n    return web.reactivate(req, () => fn.apply(this, arguments))\n  }\n}\n\nmodule.exports = [\n  {\n    name: 'restify',\n    versions: ['>=3'],\n    file: 'lib/server.js',\n    patch (Server, tracer, config) {\n      this.wrap(Server.prototype, '_setupRequest', createWrapSetupRequest(tracer, config))\n      this.wrap(Server.prototype, handlers, createWrapHandler(tracer, config))\n      this.wrap(Server.prototype, methods, createWrapMethod(tracer, config))\n    },\n    unpatch (Server) {\n      this.unwrap(Server.prototype, '_setupRequest')\n      this.unwrap(Server.prototype, handlers)\n      this.unwrap(Server.prototype, methods)\n    }\n  }\n]\n","'use strict'\n\nconst dd = Symbol('datadog')\nconst circularBufferConstructor = Symbol('circularBufferConstructor')\nconst inFlightDeliveries = Symbol('inFlightDeliveries')\n\nfunction createWrapSend (tracer, config, instrumenter) {\n  return function wrapSend (send) {\n    return function sendWithTrace (msg, tag, format) {\n      if (!canTrace(this)) {\n        // we can't handle disconnects or ending spans, so we can't safely instrument\n        return send.apply(this, arguments)\n      }\n      const name = getResourceNameFromSender(this)\n      const { host, port } = getHostAndPort(this.connection)\n      return tracer.trace('amqp.send', {\n        tags: {\n          'component': 'rhea',\n          'resource.name': name,\n          'service.name': config.service || `${tracer._service}-amqp-producer`,\n          'span.kind': 'producer',\n          'amqp.link.target.address': name,\n          'amqp.link.role': 'sender',\n          'out.host': host,\n          'out.port': port\n        }\n      }, (span, done) => {\n        addDeliveryAnnotations(msg, tracer, span)\n        const delivery = send.apply(this, arguments)\n        delivery[dd] = { done, span }\n        addToInFlightDeliveries(this.connection, delivery)\n        return delivery\n      })\n    }\n  }\n}\n\nfunction createWrapConnectionDispatch (tracer, config) {\n  return function wrapDispatch (dispatch) {\n    return function dispatchWithTrace (eventName, obj) {\n      if (eventName === 'disconnected') {\n        const error = obj.error || this.saved_error\n        if (this[inFlightDeliveries]) {\n          this[inFlightDeliveries].forEach(delivery => {\n            const { span } = delivery[dd]\n            span.addTags({ error })\n            finish(delivery, null)\n          })\n        }\n      }\n      return dispatch.apply(this, arguments)\n    }\n  }\n}\n\nfunction createWrapReceiverDispatch (tracer, config, instrumenter) {\n  return function wrapDispatch (dispatch) {\n    return function dispatchWithTrace (eventName, msgObj) {\n      if (!canTrace(this)) {\n        // we can't handle disconnects or ending spans, so we can't safely instrument\n        return dispatch.apply(this, arguments)\n      }\n      if (eventName === 'message' && msgObj) {\n        const name = getResourceNameFromMessage(msgObj)\n        const childOf = getAnnotations(msgObj, tracer)\n        return tracer.trace('amqp.receive', {\n          tags: {\n            'component': 'rhea',\n            'resource.name': name,\n            'service.name': config.service || tracer._service,\n            'span.kind': 'consumer',\n            'amqp.link.source.address': name,\n            'amqp.link.role': 'receiver'\n          },\n          childOf\n        }, (span, done) => {\n          if (msgObj.delivery) {\n            msgObj.delivery[dd] = { done, span }\n            msgObj.delivery.update = wrapDeliveryUpdate(msgObj.delivery.update)\n            addToInFlightDeliveries(this.connection, msgObj.delivery)\n          }\n          return dispatch.apply(this, arguments)\n        })\n      }\n\n      return dispatch.apply(this, arguments)\n    }\n  }\n}\n\nfunction createWrapCircularBufferPopIf () {\n  return function wrapCircularBufferPopIf (popIf) {\n    return function wrappedPopIf (fn) {\n      const wrappedFn = entry => {\n        const shouldPop = fn(entry)\n        if (shouldPop && entry[dd]) {\n          const remoteState = entry.remote_state\n          const state = remoteState && remoteState.constructor\n            ? entry.remote_state.constructor.composite_type : undefined\n          finish(entry, state)\n        }\n        return shouldPop\n      }\n      return popIf.call(this, wrappedFn)\n    }\n  }\n}\n\nfunction wrapDeliveryUpdate (update) {\n  return function wrappedUpdate (settled, stateData) {\n    if (this[dd]) {\n      const state = getStateFromData(stateData)\n      this[dd].span.setTag('amqp.delivery.state', state)\n    }\n    return update.apply(this, arguments)\n  }\n}\n\nfunction patchCircularBuffer (proto, instrumenter) {\n  Object.defineProperty(proto, 'outgoing', {\n    configurable: true,\n    get () {},\n    set (outgoing) {\n      delete proto.outgoing // removes the setter on the prototype\n      this.outgoing = outgoing // assigns on the instance, like normal\n      if (outgoing) {\n        let CircularBuffer\n        if (outgoing.deliveries) {\n          CircularBuffer = outgoing.deliveries.constructor\n        }\n        if (CircularBuffer && !CircularBuffer.prototype.pop_if._datadog_patched) {\n          instrumenter.wrap(CircularBuffer.prototype, 'pop_if', createWrapCircularBufferPopIf())\n          const Session = proto.constructor\n          if (Session) {\n            Session[circularBufferConstructor] = CircularBuffer\n          }\n        }\n      }\n    }\n  })\n}\n\nfunction addToInFlightDeliveries (connection, delivery) {\n  let deliveries = connection[inFlightDeliveries]\n  if (!deliveries) {\n    deliveries = new Set()\n    connection[inFlightDeliveries] = deliveries\n  }\n  deliveries.add(delivery)\n  delivery[dd].connection = connection\n}\n\nfunction getHostAndPort (connection) {\n  let host\n  let port\n  if (connection && connection.options) {\n    host = connection.options.host\n    port = connection.options.port\n  }\n  return { host, port }\n}\n\nfunction addDeliveryAnnotations (msg, tracer, span) {\n  if (msg) {\n    msg.delivery_annotations = msg.delivery_annotations || {}\n    tracer.inject(span, 'text_map', msg.delivery_annotations)\n  }\n}\n\nfunction getStateFromData (stateData) {\n  if (stateData && stateData.descriptor && stateData.descriptor) {\n    switch (stateData.descriptor.value) {\n      case 0x24: return 'accepted'\n      case 0x25: return 'rejected'\n      case 0x26: return 'released'\n      case 0x27: return 'modified'\n    }\n  }\n}\n\nfunction finish (delivery, state) {\n  if (delivery[dd]) {\n    if (state) {\n      delivery[dd].span.setTag('amqp.delivery.state', state)\n    }\n    delivery[dd].done()\n    if (delivery[dd].connection && delivery[dd].connection[inFlightDeliveries]) {\n      delivery[dd].connection[inFlightDeliveries].delete(delivery)\n    }\n    delete delivery[dd]\n  }\n}\n\nfunction getResourceNameFromMessage (msgObj) {\n  let resourceName = 'amq.topic'\n  let options = {}\n  if (msgObj.receiver && msgObj.receiver.options) {\n    options = msgObj.receiver.options\n  }\n  if (options.source && options.source.address) {\n    resourceName = options.source.address\n  }\n  return resourceName\n}\n\nfunction getResourceNameFromSender (sender) {\n  let resourceName = 'amq.topic'\n  if (sender.options && sender.options.target && sender.options.target.address) {\n    resourceName = sender.options.target.address\n  }\n  return resourceName\n}\n\nfunction getAnnotations (msgObj, tracer) {\n  if (msgObj.message) {\n    return tracer.extract('text_map', msgObj.message.delivery_annotations)\n  }\n}\n\nfunction canTrace (link) {\n  return link.connection && link.session && link.session.outgoing\n}\n\nmodule.exports = [\n  {\n    name: 'rhea',\n    versions: ['>=1'],\n    file: 'lib/link.js',\n    patch ({ Sender, Receiver }, tracer, config) {\n      this.wrap(Sender.prototype, 'send', createWrapSend(tracer, config, this))\n      this.wrap(Receiver.prototype, 'dispatch', createWrapReceiverDispatch(tracer, config, this))\n    },\n    unpatch ({ Sender, Receiver }, tracer) {\n      this.unwrap(Sender.prototype, 'send')\n      this.unwrap(Receiver.prototype, 'dispatch')\n    }\n  },\n  {\n    name: 'rhea',\n    versions: ['>=1'],\n    file: 'lib/connection.js',\n    patch (Connection, tracer, config) {\n      this.wrap(Connection.prototype, 'dispatch', createWrapConnectionDispatch(tracer, config))\n    },\n    unpatch (Connection, tracer) {\n      this.unwrap(Connection.prototype, 'dispatch')\n    }\n  },\n  {\n    name: 'rhea',\n    versions: ['>=1'],\n    file: 'lib/session.js',\n    patch (Session, tracer, config) {\n      patchCircularBuffer(Session.prototype, this)\n    },\n    unpatch (Session, tracer) {\n      if (Session[circularBufferConstructor]) {\n        this.unwrap(Session[circularBufferConstructor].prototype, 'pop_if')\n      }\n    }\n  }\n]\n","'use strict'\n\nconst METHODS = require('methods').concat('all')\nconst pathToRegExp = require('path-to-regexp')\nconst web = require('../../dd-trace/src/plugins/util/web')\n\nconst regexpCache = Object.create(null)\n\nfunction createWrapHandle (tracer, config) {\n  return function wrapHandle (handle) {\n    return function handleWithTracer (req, res, done) {\n      web.patch(req)\n\n      return handle.apply(this, arguments)\n    }\n  }\n}\n\nfunction wrapRouterMethod (original) {\n  return function methodWithTrace (fn) {\n    const offset = this.stack ? [].concat(this.stack).length : 0\n    const router = original.apply(this, arguments)\n\n    if (typeof this.stack === 'function') {\n      this.stack = [{ handle: this.stack }]\n    }\n\n    wrapStack(this.stack, offset, extractMatchers(fn))\n\n    return router\n  }\n}\n\nfunction wrapLayerHandle (layer, handle) {\n  handle._name = handle._name || layer.name\n\n  let wrapCallHandle\n\n  if (handle.length === 4) {\n    wrapCallHandle = function (error, req, res, next) {\n      return callHandle(layer, handle, req, [error, req, res, wrapNext(layer, req, next)])\n    }\n  } else {\n    wrapCallHandle = function (req, res, next) {\n      return callHandle(layer, handle, req, [req, res, wrapNext(layer, req, next)])\n    }\n  }\n\n  // This is a workaround for the `loopback` library so that it can find the correct express layer\n  // that contains the real handle function\n  wrapCallHandle._datadog_orig = handle\n\n  return wrapCallHandle\n}\n\nfunction wrapStack (stack, offset, matchers) {\n  [].concat(stack).slice(offset).forEach(layer => {\n    if (layer.__handle) { // express-async-errors\n      layer.__handle = wrapLayerHandle(layer, layer.__handle)\n    } else {\n      layer.handle = wrapLayerHandle(layer, layer.handle)\n    }\n\n    layer._datadog_matchers = matchers\n\n    if (layer.route) {\n      METHODS.forEach(method => {\n        if (typeof layer.route.stack === 'function') {\n          layer.route.stack = [{ handle: layer.route.stack }]\n        }\n\n        layer.route[method] = wrapRouterMethod(layer.route[method])\n      })\n    }\n  })\n}\n\nfunction wrapNext (layer, req, next) {\n  if (!next || !web.active(req)) return next\n\n  const originalNext = next\n\n  return function (error) {\n    if (!error && layer.path && !isFastStar(layer) && !isFastSlash(layer)) {\n      web.exitRoute(req)\n    }\n\n    web.finish(req, error)\n\n    originalNext.apply(null, arguments)\n  }\n}\n\nfunction callHandle (layer, handle, req, args) {\n  const matchers = layer._datadog_matchers\n\n  if (web.active(req) && matchers) {\n    // Try to guess which path actually matched\n    for (let i = 0; i < matchers.length; i++) {\n      if (matchers[i].test(layer)) {\n        web.enterRoute(req, matchers[i].path)\n\n        break\n      }\n    }\n  }\n\n  return web.wrapMiddleware(req, handle, 'express.middleware', () => {\n    return handle.apply(layer, args)\n  })\n}\n\nfunction extractMatchers (fn) {\n  const arg = flatten([].concat(fn))\n\n  if (typeof arg[0] === 'function') {\n    return []\n  }\n\n  return arg.map(pattern => ({\n    path: pattern instanceof RegExp ? `(${pattern})` : pattern,\n    test: layer => !isFastStar(layer) && !isFastSlash(layer) && cachedPathToRegExp(pattern).test(layer.path)\n  }))\n}\n\nfunction isFastStar (layer) {\n  if (layer.regexp.fast_star !== undefined) {\n    return layer.regexp.fast_star\n  }\n\n  return layer._datadog_matchers.some(matcher => matcher.path === '*')\n}\n\nfunction isFastSlash (layer) {\n  if (layer.regexp.fast_slash !== undefined) {\n    return layer.regexp.fast_slash\n  }\n\n  return layer._datadog_matchers.some(matcher => matcher.path === '/')\n}\n\nfunction flatten (arr) {\n  return arr.reduce((acc, val) => Array.isArray(val) ? acc.concat(flatten(val)) : acc.concat(val), [])\n}\n\nfunction cachedPathToRegExp (pattern) {\n  const maybeCached = regexpCache[pattern]\n  if (maybeCached) {\n    return maybeCached\n  }\n  const regexp = pathToRegExp(pattern)\n  regexpCache[pattern] = regexp\n  return regexp\n}\n\nmodule.exports = {\n  name: 'router',\n  versions: ['>=1'],\n  patch (Router, tracer, config) {\n    this.wrap(Router.prototype, 'handle', createWrapHandle(tracer, config))\n    this.wrap(Router.prototype, 'use', wrapRouterMethod)\n    this.wrap(Router.prototype, 'route', wrapRouterMethod)\n  },\n  unpatch (Router) {\n    this.unwrap(Router.prototype, 'handle')\n    this.unwrap(Router.prototype, 'use')\n    this.unwrap(Router.prototype, 'route')\n  }\n}\n","'use strict'\n\nconst Tags = require('../../../ext/tags')\nconst Kinds = require('../../../ext/kinds')\nconst analyticsSampler = require('../../dd-trace/src/analytics_sampler')\nconst tx = require('../../dd-trace/src/plugins/util/tx')\n\nconst procnameRegex = /^sp_[a-z]+$/\n\nfunction createWrapMakeRequest (tracer, config) {\n  return function wrapMakeRequest (makeRequest) {\n    return function makeRequestWithTrace (request) {\n      const connectionConfig = this.config\n      const scope = tracer.scope()\n      const childOf = scope.active()\n      const queryOrProcedure = getQueryOrProcedure(request)\n\n      if (!queryOrProcedure) {\n        return makeRequest.apply(this, arguments)\n      }\n\n      const span = tracer.startSpan('tedious.request', {\n        childOf,\n        tags: {\n          [Tags.SPAN_KIND]: Kinds.CLIENT,\n          'db.type': 'mssql',\n          'span.type': 'sql',\n          'component': 'tedious',\n          'service.name': config.service || `${tracer._service}-mssql`,\n          'resource.name': queryOrProcedure\n        }\n      })\n\n      addConnectionTags(span, connectionConfig)\n      addDatabaseTags(span, connectionConfig)\n      addProcIdTags(span, request)\n\n      analyticsSampler.sample(span, config.analytics)\n      request.callback = tx.wrap(span, request.callback)\n\n      return scope.bind(makeRequest, span).apply(this, arguments)\n    }\n  }\n}\n\nfunction createWrapGetRowStream (tracer) {\n  return function wrapGetRowStream (getRowStream) {\n    return function getRowStreamWithTrace () {\n      const scope = tracer.scope()\n\n      const rowToPacketTransform = getRowStream.apply(this, arguments)\n      return scope.bind(rowToPacketTransform)\n    }\n  }\n}\n\nfunction getQueryOrProcedure (request) {\n  if (!request.parameters) return\n\n  const statement = request.parametersByName.statement || request.parametersByName.stmt\n\n  if (!statement) {\n    return request.sqlTextOrProcedure\n  }\n\n  return statement.value\n}\n\nfunction addConnectionTags (span, connectionConfig) {\n  span.setTag('out.host', connectionConfig.server)\n  span.setTag('out.port', connectionConfig.options.port)\n}\n\nfunction addDatabaseTags (span, connectionConfig) {\n  span.setTag('db.user', connectionConfig.userName || connectionConfig.authentication.options.userName)\n  span.setTag('db.name', connectionConfig.options.database)\n  span.setTag('db.instance', connectionConfig.options.instanceName)\n}\n\nfunction addProcIdTags (span, request) {\n  if (!procnameRegex.test(request.sqlTextOrProcedure)) return\n  span.setTag('tds.proc.name', request.sqlTextOrProcedure)\n}\n\nmodule.exports = [\n  {\n    name: 'tedious',\n    versions: [ '>=1.0.0' ],\n    patch (tedious, tracer, config) {\n      this.wrap(tedious.Connection.prototype, 'makeRequest', createWrapMakeRequest(tracer, config))\n\n      if (tedious.BulkLoad && tedious.BulkLoad.prototype.getRowStream) {\n        this.wrap(tedious.BulkLoad.prototype, 'getRowStream', createWrapGetRowStream(tracer))\n      }\n\n      tracer.scope().bind(tedious.Request.prototype)\n      tracer.scope().bind(tedious.Connection.prototype)\n    },\n    unpatch (tedious, tracer) {\n      this.unwrap(tedious.Connection.prototype, 'makeRequest')\n\n      if (tedious.BulkLoad) {\n        this.unwrap(tedious.BulkLoad.prototype, 'getRowStream')\n      }\n\n      tracer.scope().unbind(tedious.Request.prototype)\n      tracer.scope().unbind(tedious.Connection.prototype)\n    }\n  }\n]\n","'use strict'\n\nconst tx = require('../../dd-trace/src/plugins/util/promise')\n\nmodule.exports = [\n  {\n    name: 'when',\n    file: 'lib/Promise.js',\n    versions: ['>=3'],\n    patch (Promise, tracer, config) {\n      this.wrap(Promise.prototype, 'then', tx.createWrapThen(tracer, config))\n    },\n    unpatch (Promise) {\n      this.unwrap(Promise.prototype, 'then')\n    }\n  }\n]\n","'use strict'\n\nconst { LOG } = require('../../../ext/formats')\n\nfunction createWrapWrite (tracer, config) {\n  return function wrapWrite (write) {\n    return function writeWithTrace (chunk, encoding, callback) {\n      const span = tracer.scope().active()\n\n      tracer.inject(span, LOG, chunk)\n\n      const result = write.apply(this, arguments)\n\n      delete chunk.dd\n\n      return result\n    }\n  }\n}\n\nfunction createWrapMethod (tracer, config) {\n  return function wrapMethod (method) {\n    return function methodWithTrace () {\n      const result = method.apply(this, arguments)\n\n      for (const name in this.transports) {\n        const transport = this.transports[name]\n\n        if (transport._dd_patched || typeof transport.log !== 'function') continue\n\n        transport.log = createWrapLog(tracer, config)(transport.log)\n        transport._dd_patched = true\n      }\n\n      return result\n    }\n  }\n}\n\nfunction createWrapLog (tracer, config) {\n  return function wrapLog (log) {\n    return function logWithTrace (level, msg, meta, callback) {\n      const span = tracer.scope().active()\n\n      meta = arguments[2] = meta || {}\n\n      tracer.inject(span, LOG, meta)\n\n      const result = log.apply(this, arguments)\n\n      delete meta.dd\n\n      return result\n    }\n  }\n}\n\nmodule.exports = [\n  {\n    name: 'winston',\n    file: 'lib/winston/logger.js',\n    versions: ['>=3'],\n    patch (Logger, tracer, config) {\n      if (!tracer._logInjection) return\n      this.wrap(Logger.prototype, 'write', createWrapWrite(tracer, config))\n    },\n    unpatch (Logger) {\n      this.unwrap(Logger.prototype, 'write')\n    }\n  },\n  {\n    name: 'winston',\n    file: 'lib/winston/logger.js',\n    versions: ['2'],\n    patch (logger, tracer, config) {\n      if (!tracer._logInjection) return\n      this.wrap(logger.Logger.prototype, 'configure', createWrapMethod(tracer, config))\n      this.wrap(logger.Logger.prototype, 'add', createWrapMethod(tracer, config))\n    },\n    unpatch (logger) {\n      this.unwrap(logger.Logger.prototype, 'configure')\n      this.unwrap(logger.Logger.prototype, 'add')\n    }\n  },\n  {\n    name: 'winston',\n    file: 'lib/winston/logger.js',\n    versions: ['1'],\n    patch (logger, tracer, config) {\n      if (!tracer._logInjection) return\n      this.wrap(logger.Logger.prototype, 'add', createWrapMethod(tracer, config))\n    },\n    unpatch (logger) {\n      this.unwrap(logger.Logger.prototype, 'add')\n    }\n  }\n]\n","'use strict'\n\nconst platform = require('./src/platform')\nconst node = require('./src/platform/node')\n\nplatform.use(node)\n\nconst TracerProxy = require('./src/proxy')\n\nmodule.exports = new TracerProxy()\nmodule.exports.default = module.exports\nmodule.exports.tracer = module.exports\n","module.exports = '0.29.1'\n","'use strict'\n\nconst ANALYTICS = require('../../../ext/tags').ANALYTICS\n\nlet enabled = false\n\nmodule.exports = {\n  enable () {\n    enabled = true\n  },\n\n  disable () {\n    enabled = false\n  },\n\n  sample (span, rate, inherit) {\n    if (typeof rate === 'object') {\n      this.sample(span, rate[span.context()._name], inherit)\n    } else if (rate !== undefined) {\n      span.setTag(ANALYTICS, rate)\n    } else if (inherit && enabled) {\n      span.setTag(ANALYTICS, 1)\n    }\n  }\n}\n","'use strict'\n\nconst URL = require('url-parse')\nconst platform = require('./platform')\nconst coalesce = require('koalas')\nconst scopes = require('../../../ext/scopes')\nconst tagger = require('./tagger')\nconst id = require('./id')\nconst { isTrue, isFalse } = require('./util')\n\nconst runtimeId = `${id().toString()}${id().toString()}`\n\nclass Config {\n  constructor (options) {\n    options = options || {}\n\n    this.tags = {}\n\n    tagger.add(this.tags, platform.env('DD_TAGS'))\n    tagger.add(this.tags, platform.env('DD_TRACE_TAGS'))\n    tagger.add(this.tags, platform.env('DD_TRACE_GLOBAL_TAGS'))\n    tagger.add(this.tags, options.tags)\n\n    const DD_TRACE_ANALYTICS_ENABLED = coalesce(\n      options.analytics,\n      platform.env('DD_TRACE_ANALYTICS_ENABLED'),\n      platform.env('DD_TRACE_ANALYTICS'),\n      false\n    )\n    // Temporary disabled\n    const DD_PROFILING_ENABLED = coalesce(\n      // options.profiling,\n      // platform.env('DD_PROFILING_ENABLED'),\n      platform.env('DD_EXPERIMENTAL_PROFILING_ENABLED'),\n      false\n    )\n    const DD_PROFILING_EXPORTERS = coalesce(\n      platform.env('DD_PROFILING_EXPORTERS'),\n      'agent'\n    )\n    const DD_PROFILING_SOURCE_MAP = platform.env('DD_PROFILING_SOURCE_MAP')\n    const DD_LOGS_INJECTION = coalesce(\n      options.logInjection,\n      platform.env('DD_LOGS_INJECTION'),\n      false\n    )\n    const DD_RUNTIME_METRICS_ENABLED = coalesce(\n      options.runtimeMetrics,\n      platform.env('DD_RUNTIME_METRICS_ENABLED'),\n      false\n    )\n    const DD_AGENT_HOST = coalesce(\n      options.hostname,\n      platform.env('DD_AGENT_HOST'),\n      platform.env('DD_TRACE_AGENT_HOSTNAME'),\n      '127.0.0.1'\n    )\n    const DD_TRACE_AGENT_PORT = coalesce(\n      options.port,\n      platform.env('DD_TRACE_AGENT_PORT'),\n      '8126'\n    )\n    const DD_TRACE_AGENT_URL = coalesce(\n      options.url,\n      platform.env('DD_TRACE_AGENT_URL'),\n      platform.env('DD_TRACE_URL'),\n      null\n    )\n    const DD_SERVICE = options.service ||\n      platform.env('DD_SERVICE') ||\n      platform.env('DD_SERVICE_NAME') ||\n      this.tags.service ||\n      platform.service() ||\n      'node'\n    const DD_ENV = coalesce(\n      options.env,\n      platform.env('DD_ENV'),\n      this.tags.env\n    )\n    const DD_VERSION = coalesce(\n      options.version,\n      platform.env('DD_VERSION'),\n      this.tags.version,\n      platform.appVersion()\n    )\n    const DD_TRACE_STARTUP_LOGS = coalesce(\n      options.startupLogs,\n      platform.env('DD_TRACE_STARTUP_LOGS'),\n      true\n    )\n    const DD_TRACE_ENABLED = coalesce(\n      options.enabled,\n      platform.env('DD_TRACE_ENABLED'),\n      true\n    )\n    const DD_TRACE_DEBUG = coalesce(\n      options.debug,\n      platform.env('DD_TRACE_DEBUG'),\n      false\n    )\n    const DD_TRACE_AGENT_PROTOCOL_VERSION = coalesce(\n      options.protocolVersion,\n      platform.env('DD_TRACE_AGENT_PROTOCOL_VERSION'),\n      '0.4'\n    )\n\n    const sampler = (options.experimental && options.experimental.sampler) || {}\n    const ingestion = options.ingestion || {}\n    const dogstatsd = coalesce(options.dogstatsd, {})\n\n    Object.assign(sampler, {\n      sampleRate: coalesce(ingestion.sampleRate, sampler.sampleRate, platform.env('DD_TRACE_SAMPLE_RATE')),\n      rateLimit: coalesce(ingestion.rateLimit, sampler.rateLimit, platform.env('DD_TRACE_RATE_LIMIT'))\n    })\n\n    this.enabled = isTrue(DD_TRACE_ENABLED)\n    this.debug = isTrue(DD_TRACE_DEBUG)\n    this.logInjection = isTrue(DD_LOGS_INJECTION)\n    this.env = DD_ENV\n    this.url = DD_TRACE_AGENT_URL && new URL(DD_TRACE_AGENT_URL)\n    this.site = coalesce(options.site, platform.env('DD_SITE'), 'datadoghq.com')\n    this.hostname = DD_AGENT_HOST || (this.url && this.url.hostname)\n    this.port = String(DD_TRACE_AGENT_PORT || (this.url && this.url.port))\n    this.flushInterval = coalesce(parseInt(options.flushInterval, 10), 2000)\n    this.sampleRate = coalesce(Math.min(Math.max(options.sampleRate, 0), 1), 1)\n    this.logger = options.logger\n    this.plugins = !!coalesce(options.plugins, true)\n    this.service = DD_SERVICE\n    this.version = DD_VERSION\n    this.analytics = isTrue(DD_TRACE_ANALYTICS_ENABLED)\n    this.dogstatsd = {\n      hostname: coalesce(dogstatsd.hostname, platform.env(`DD_DOGSTATSD_HOSTNAME`), this.hostname),\n      port: String(coalesce(dogstatsd.port, platform.env('DD_DOGSTATSD_PORT'), 8125))\n    }\n    this.runtimeMetrics = isTrue(DD_RUNTIME_METRICS_ENABLED)\n    this.trackAsyncScope = options.trackAsyncScope !== false\n    this.experimental = {\n      b3: !(!options.experimental || !options.experimental.b3),\n      runtimeId: !(!options.experimental || !options.experimental.runtimeId),\n      exporter: options.experimental && options.experimental.exporter,\n      peers: (options.experimental && options.experimental.distributedTracingOriginWhitelist) || [],\n      enableGetRumData: (options.experimental && !!options.experimental.enableGetRumData),\n      sampler,\n      internalErrors: options.experimental && options.experimental.internalErrors\n    }\n    this.reportHostname = isTrue(coalesce(options.reportHostname, platform.env('DD_TRACE_REPORT_HOSTNAME'), false))\n    this.scope = isFalse(platform.env('DD_CONTEXT_PROPAGATION'))\n      ? scopes.NOOP\n      : coalesce(options.scope, platform.env('DD_TRACE_SCOPE'))\n    this.clientToken = coalesce(options.clientToken, platform.env('DD_CLIENT_TOKEN'))\n    this.logLevel = coalesce(\n      options.logLevel,\n      platform.env('DD_TRACE_LOG_LEVEL'),\n      'debug'\n    )\n    this.profiling = {\n      enabled: isTrue(DD_PROFILING_ENABLED),\n      sourceMap: !isFalse(DD_PROFILING_SOURCE_MAP),\n      exporters: DD_PROFILING_EXPORTERS\n    }\n    this.lookup = options.lookup\n    this.startupLogs = isTrue(DD_TRACE_STARTUP_LOGS)\n    this.protocolVersion = DD_TRACE_AGENT_PROTOCOL_VERSION\n\n    tagger.add(this.tags, { service: this.service, env: this.env, version: this.version })\n\n    if (this.experimental.runtimeId) {\n      tagger.add(this.tags, {\n        'runtime-id': runtimeId\n      })\n    }\n  }\n}\n\nmodule.exports = Config\n","'use strict'\n\nmodule.exports = {\n  SAMPLE_RATE_METRIC_KEY: '_sample_rate',\n  SAMPLING_PRIORITY_KEY: '_sampling_priority_v1',\n  ANALYTICS_KEY: '_dd1.sr.eausr',\n  ORIGIN_KEY: '_dd.origin',\n  HOSTNAME_KEY: '_dd.hostname',\n  REFERENCE_NOOP: 'noop',\n  SAMPLING_RULE_DECISION: '_dd.rule_psr',\n  SAMPLING_LIMIT_DECISION: '_dd.limit_psr',\n  SAMPLING_AGENT_DECISION: '_dd.agent_psr'\n}\n","'use strict'\n\nconst { encode } = require('./notepack')\nconst log = require('../log')\n\nconst HARD_LIMIT = 8 * 1024 * 1024 // 8MB\n\nclass AgentEncoder {\n  constructor (writer) {\n    this._writer = writer\n    this._reset()\n  }\n\n  count () {\n    return this._traces.length\n  }\n\n  encode (trace) {\n    const buffer = encode(trace)\n\n    log.debug(() => `Adding encoded trace to buffer: ${buffer.toString('hex').match(/../g).join(' ')}`)\n\n    if (buffer.length + this._size > HARD_LIMIT) {\n      this._writer.flush()\n    }\n\n    this._size += buffer.length\n    this._traces.push(buffer)\n  }\n\n  makePayload () {\n    const prefix = Buffer.alloc(5)\n\n    prefix[0] = 0xdd\n    prefix.writeUInt32BE(this._traces.length, 1)\n\n    const buffer = [prefix, ...this._traces]\n\n    this._reset()\n\n    return buffer\n  }\n\n  _reset () {\n    this._traces = []\n    this._size = 0\n  }\n}\n\nmodule.exports = { AgentEncoder }\n","'use strict'\n\nconst notepack = require('./notepack')\nconst log = require('../log')\n\nconst ARRAY_OF_TWO = 0x92\nconst ARRAY_OF_TWELVE = 0x9c\nconst SOFT_LIMIT = 8 * 1024 * 1024 // 8MB\n\nconst float64Array = new Float64Array(1)\nconst uInt8Float64Array = new Uint8Array(float64Array.buffer)\n\nfloat64Array[0] = -1\n\nconst bigEndian = uInt8Float64Array[7] === 0\n\nclass AgentEncoder {\n  constructor (writer) {\n    this._writer = writer\n    this._reset()\n  }\n\n  count () {\n    return this._traces.length\n  }\n\n  encode (trace) {\n    const bytes = []\n\n    this._encode(bytes, trace)\n    this._traces.push(bytes)\n    this._traceSize += bytes.length\n\n    log.debug(() => `Adding encoded trace to buffer: ${bytes.map(b => b.toString(16)).join(' ')}`)\n\n    // we can go over the soft limit since the agent has a 50MB hard limit\n    if (this._traceSize + this._stringSize > SOFT_LIMIT) {\n      this._writer.flush()\n    }\n  }\n\n  makePayload () {\n    const prefixSize = 1\n    const stringSize = this._stringSize + 5\n    const traceSize = this._traceSize + 5\n    const buffer = Buffer.allocUnsafe(prefixSize + stringSize + traceSize)\n\n    let offset = 0\n\n    buffer[offset++] = ARRAY_OF_TWO\n\n    offset = this._writeStrings(buffer, offset)\n    offset = this._writeTraces(buffer, offset)\n\n    this._reset()\n\n    return buffer\n  }\n\n  _encode (bytes, trace) {\n    this._encodeArrayPrefix(bytes, trace)\n\n    for (const span of trace) {\n      this._encodeByte(bytes, ARRAY_OF_TWELVE)\n      this._encodeString(bytes, span.service)\n      this._encodeString(bytes, span.name)\n      this._encodeString(bytes, span.resource)\n      this._encodeId(bytes, span.trace_id)\n      this._encodeId(bytes, span.span_id)\n      this._encodeId(bytes, span.parent_id)\n      this._encodeInteger(bytes, span.start || 0)\n      this._encodeInteger(bytes, span.duration || 0)\n      this._encodeInteger(bytes, span.error)\n      this._encodeMap(bytes, span.meta || {})\n      this._encodeMap(bytes, span.metrics || {})\n      this._encodeString(bytes, span.type)\n    }\n  }\n\n  _reset () {\n    this._traces = []\n    this._traceSize = 0\n    this._stringDefers = [{ value: '', length: 0, prefix: [0xa0] }]\n    this._stringMap = { '': 0 }\n    this._stringSize = 1\n  }\n\n  _encodeArrayPrefix (bytes, value) {\n    const length = value.length\n\n    if (length < 0x10) { // fixarray\n      bytes.push(length | 0x90)\n    } else if (length < 0x10000) { // array 16\n      bytes.push(0xdc, length >> 8, length)\n    } else if (length < 0x100000000) { // array 32\n      bytes.push(0xdd, length >> 24, length >> 16, length >> 8, length)\n    } else {\n      throw new Error('Array too large')\n    }\n  }\n\n  _encodeByte (bytes, value) {\n    bytes.push(value)\n  }\n\n  _encodeId (bytes, id) {\n    id = id.toArray()\n    bytes.push(0xcf, id[0], id[1], id[2], id[3], id[4], id[5], id[6], id[7])\n  }\n\n  _encodeInteger (bytes, value) {\n    notepack._encode(bytes, [], value)\n  }\n\n  _encodeMap (bytes, value) {\n    const keys = []\n    const allKeys = Object.keys(value)\n\n    let key = ''\n\n    for (let i = 0, l = allKeys.length; i < l; i++) {\n      key = allKeys[i]\n      if (typeof value[key] !== 'function') {\n        keys.push(key)\n      }\n    }\n\n    const length = keys.length\n\n    if (length < 0x10) { // fixmap\n      bytes.push(length | 0x80)\n    } else if (length < 0x10000) { // map 16\n      bytes.push(0xde, length >> 8, length)\n    } else if (length < 0x100000000) { // map 32\n      bytes.push(0xdf, length >> 24, length >> 16, length >> 8, length)\n    } else {\n      throw new Error('Object too large')\n    }\n\n    for (let i = 0; i < length; i++) {\n      key = keys[i]\n      this._encodeString(bytes, key)\n      this._encodeValue(bytes, value[key])\n    }\n  }\n\n  _encodeValue (bytes, value) {\n    switch (typeof value) {\n      case 'string':\n        this._encodeString(bytes, value)\n        break\n      case 'number':\n        this._encodeFloat(bytes, value)\n        break\n      default:\n        // should not happen\n    }\n  }\n\n  _encodeString (bytes, value = '') {\n    if (!(value in this._stringMap)) {\n      const prefix = []\n      const defers = []\n      const size = notepack._encode(prefix, defers, value)\n      const length = defers[0].length\n\n      this._stringSize += size\n      this._stringMap[value] = this._stringDefers.length\n      this._stringDefers.push({ value, length, prefix })\n    }\n\n    this._encodeInteger(bytes, this._stringMap[value])\n  }\n\n  _encodeFloat (bytes, value) {\n    float64Array[0] = value\n\n    bytes.push(0xcb)\n\n    if (bigEndian) {\n      for (let i = 0; i <= 7; i++) {\n        bytes.push(uInt8Float64Array[i])\n      }\n    } else {\n      for (let i = 7; i >= 0; i--) {\n        bytes.push(uInt8Float64Array[i])\n      }\n    }\n  }\n\n  _writeArrayPrefix (buffer, offset, count) {\n    buffer[offset++] = 0xdd\n    buffer.writeUInt32BE(count, offset)\n\n    return offset + 4\n  }\n\n  _writeString (buffer, offset, defer) {\n    for (let i = 0, l = defer.prefix.length; i < l; i++) {\n      buffer[offset++] = defer.prefix[i]\n    }\n\n    if (defer.length > notepack.MICRO_OPT_LEN) {\n      buffer.write(defer.value, offset, defer.length, 'utf8')\n    } else {\n      notepack.utf8Write(buffer, offset, defer.value)\n    }\n\n    return offset + defer.length\n  }\n\n  _writeStrings (buffer, offset) {\n    offset = this._writeArrayPrefix(buffer, offset, this._stringDefers.length)\n\n    for (const defer of this._stringDefers) {\n      offset = this._writeString(buffer, offset, defer)\n    }\n\n    return offset\n  }\n\n  _writeTraces (buffer, offset) {\n    offset = this._writeArrayPrefix(buffer, offset, this._traces.length)\n\n    for (const trace of this._traces) {\n      for (const byte of trace) {\n        buffer[offset++] = byte\n      }\n    }\n\n    return offset\n  }\n}\n\nmodule.exports = { AgentEncoder }\n","/* eslint-disable */\n// modified from https://github.com/darrachequesne/notepack/blob/master/lib/encode.js\n\n'use strict';\n\nconst MICRO_OPT_LEN = 32;\n\n// Faster for short strings than buffer.write\nfunction utf8Write(arr, offset, str) {\n  let c = 0;\n  for (let i = 0, l = str.length; i < l; i++) {\n    c = str.charCodeAt(i);\n    if (c < 0x80) {\n      arr[offset++] = c;\n    } else if (c < 0x800) {\n      arr[offset++] = 0xc0 | (c >> 6);\n      arr[offset++] = 0x80 | (c & 0x3f);\n    } else if (c < 0xd800 || c >= 0xe000) {\n      arr[offset++] = 0xe0 | (c >> 12);\n      arr[offset++] = 0x80 | (c >> 6) & 0x3f;\n      arr[offset++] = 0x80 | (c & 0x3f);\n    } else {\n      i++;\n      c = 0x10000 + (((c & 0x3ff) << 10) | (str.charCodeAt(i) & 0x3ff));\n      arr[offset++] = 0xf0 | (c >> 18);\n      arr[offset++] = 0x80 | (c >> 12) & 0x3f;\n      arr[offset++] = 0x80 | (c >> 6) & 0x3f;\n      arr[offset++] = 0x80 | (c & 0x3f);\n    }\n  }\n}\n\n// Faster for short strings than Buffer.byteLength\nfunction utf8Length(str) {\n  let c = 0, length = 0;\n  for (let i = 0, l = str.length; i < l; i++) {\n    c = str.charCodeAt(i);\n    if (c < 0x80) {\n      length += 1;\n    } else if (c < 0x800) {\n      length += 2;\n    } else if (c < 0xd800 || c >= 0xe000) {\n      length += 3;\n    } else {\n      i++;\n      length += 4;\n    }\n  }\n  return length;\n}\n\nconst cache = new Map();\nconst cacheMaxSize = process.env.NOTEPACK_ENCODE_CACHE_MAX_SIZE || 1024;\n\n/*jshint latedef: nofunc */\nfunction encodeKey(bytes, defers, key) {\n  if (cache.has(key)) {\n    const buffer = cache.get(key);\n    defers.push({ bin: buffer, length: buffer.length, offset: bytes.length });\n    return buffer.length;\n  }\n  if (cache.size > cacheMaxSize) {\n    return _encode(bytes, defers, key);\n  }\n  const keyBytes = [];\n  const size = _encode(keyBytes, [], key);\n  const keyBuffer = Buffer.allocUnsafe(size);\n  for (let i = 0, l = keyBytes.length; i < l; i++) {\n    keyBuffer[i] = keyBytes[i];\n  }\n  utf8Write(keyBuffer, keyBytes.length, key);\n  defers.push({ bin: keyBuffer, length: size, offset: bytes.length });\n  cache.set(key, keyBuffer);\n  return size;\n}\n\nfunction _encode(bytes, defers, value) {\n  let hi = 0, lo = 0, length = 0, size = 0;\n\n  switch (typeof value) {\n    case 'string':\n      if (value.length > MICRO_OPT_LEN) {\n        length = Buffer.byteLength(value);\n      } else {\n        length = utf8Length(value);\n      }\n\n      if (length < 0x20) { // fixstr\n        bytes.push(length | 0xa0);\n        size = 1;\n      } else if (length < 0x100) { // str 8\n        bytes.push(0xd9, length);\n        size = 2;\n      } else if (length < 0x10000) { // str 16\n        bytes.push(0xda, length >> 8, length);\n        size = 3;\n      } else if (length < 0x100000000) { // str 32\n        bytes.push(0xdb, length >> 24, length >> 16, length >> 8, length);\n        size = 5;\n      } else {\n        throw new Error('String too long');\n      }\n      defers.push({ str: value, length: length, offset: bytes.length });\n      return size + length;\n    case 'number':\n      // TODO: encode to float 32?\n\n      if (Math.floor(value) !== value || !isFinite(value)) { // float 64\n        bytes.push(0xcb);\n        defers.push({ float: value, length: 8, offset: bytes.length });\n        return 9;\n      }\n\n      if (value >= 0) {\n        if (value < 0x80) { // positive fixnum\n          bytes.push(value);\n          return 1;\n        }\n\n        if (value < 0x100) { // uint 8\n          bytes.push(0xcc, value);\n          return 2;\n        }\n\n        if (value < 0x10000) { // uint 16\n          bytes.push(0xcd, value >> 8, value);\n          return 3;\n        }\n\n        if (value < 0x100000000) { // uint 32\n          bytes.push(0xce, value >> 24, value >> 16, value >> 8, value);\n          return 5;\n        }\n        // uint 64\n        hi = (value / Math.pow(2, 32)) >> 0;\n        lo = value >>> 0;\n        bytes.push(0xcf, hi >> 24, hi >> 16, hi >> 8, hi, lo >> 24, lo >> 16, lo >> 8, lo);\n        return 9;\n      } else {\n\n        if (value >= -0x20) { // negative fixnum\n          bytes.push(value);\n          return 1;\n        }\n\n        if (value >= -0x80) { // int 8\n          bytes.push(0xd0, value);\n          return 2;\n        }\n\n        if (value >= -0x8000) { // int 16\n          bytes.push(0xd1, value >> 8, value);\n          return 3;\n        }\n\n        if (value >= -0x80000000) { // int 32\n          bytes.push(0xd2, value >> 24, value >> 16, value >> 8, value);\n          return 5;\n        }\n        // int 64\n        hi = Math.floor(value / Math.pow(2, 32));\n        lo = value >>> 0;\n        bytes.push(0xd3, hi >> 24, hi >> 16, hi >> 8, hi, lo >> 24, lo >> 16, lo >> 8, lo);\n        return 9;\n      }\n      break;\n    case 'object':\n      // nil\n      if (value === null) {\n        bytes.push(0xc0);\n        return 1;\n      }\n\n      // uint 64\n      if (value._isUint64BE) {\n        value = value.toArray();\n        bytes.push(0xcf, value[0], value[1], value[2], value[3], value[4], value[5], value[6], value[7]);\n        return 9;\n      }\n\n      if (Array.isArray(value)) {\n        length = value.length;\n\n        if (length < 0x10) { // fixarray\n          bytes.push(length | 0x90);\n          size = 1;\n        } else if (length < 0x10000) { // array 16\n          bytes.push(0xdc, length >> 8, length);\n          size = 3;\n        } else if (length < 0x100000000) { // array 32\n          bytes.push(0xdd, length >> 24, length >> 16, length >> 8, length);\n          size = 5;\n        } else {\n          throw new Error('Array too large');\n        }\n        for (let i = 0; i < length; i++) {\n          size += _encode(bytes, defers, value[i]);\n        }\n        return size;\n      }\n\n      if (value instanceof Date) { // fixext 8 / Date\n        const time = value.getTime();\n        hi = Math.floor(time / Math.pow(2, 32));\n        lo = time >>> 0;\n        bytes.push(0xd7, 0, hi >> 24, hi >> 16, hi >> 8, hi, lo >> 24, lo >> 16, lo >> 8, lo);\n        return 10;\n      }\n\n      if (value instanceof Buffer) {\n        length = value.length;\n\n        if (length < 0x100) { // bin 8\n          bytes.push(0xc4, length);\n          size = 2;\n        } else if (length < 0x10000) { // bin 16\n          bytes.push(0xc5, length >> 8, length);\n          size = 3;\n        } else if (length < 0x100000000) { // bin 32\n          bytes.push(0xc6, length >> 24, length >> 16, length >> 8, length);\n          size = 5;\n        } else {\n          throw new Error('Buffer too large');\n        }\n        defers.push({ bin: value, length: length, offset: bytes.length });\n        return size + length;\n      }\n\n      if (value instanceof ArrayBuffer || ArrayBuffer.isView(value)) {\n        const arraybuffer = value.buffer || value;\n        length = arraybuffer.byteLength;\n\n        // ext 8\n        if (length < 0x100) {\n          bytes.push(0xc7, length, 0);\n          size = 3;\n        } else if (length < 0x10000) { // ext 16\n          bytes.push(0xc8, length >> 8, length, 0);\n          size = 4;\n        } else if (length < 0x100000000) { // ext 32\n          bytes.push(0xc9, length >> 24, length >> 16, length >> 8, length, 0);\n          size = 6;\n        } else {\n          throw new Error('ArrayBuffer too large');\n        }\n        defers.push({ arraybuffer: arraybuffer, length: length, offset: bytes.length });\n        return size + length;\n      }\n\n      if (typeof value.toJSON === 'function') {\n        return _encode(bytes, defers, value.toJSON());\n      }\n\n      const keys = [], allKeys = Object.keys(value);\n      let key = '';\n\n      for (let i = 0, l = allKeys.length; i < l; i++) {\n        key = allKeys[i];\n        if (typeof value[key] !== 'function') {\n          keys.push(key);\n        }\n      }\n      length = keys.length;\n\n      if (length < 0x10) { // fixmap\n        bytes.push(length | 0x80);\n        size = 1;\n      } else if (length < 0x10000) { // map 16\n        bytes.push(0xde, length >> 8, length);\n        size = 3;\n      } else if (length < 0x100000000) { // map 32\n        bytes.push(0xdf, length >> 24, length >> 16, length >> 8, length);\n        size = 5;\n      } else {\n        throw new Error('Object too large');\n      }\n\n      for (let i = 0; i < length; i++) {\n        key = keys[i];\n        size += encodeKey(bytes, defers, key);\n        size += _encode(bytes, defers, value[key]);\n      }\n      return size;\n    case 'boolean': // false/true\n      bytes.push(value ? 0xc3 : 0xc2);\n      return 1;\n    case 'undefined': // fixext 1 / undefined\n      bytes.push(0xd4, 0, 0);\n      return 3;\n    default:\n      throw new Error('Could not encode');\n  }\n}\n\nfunction encode(value) {\n  const bytes = [], defers = [], size = _encode(bytes, defers, value);\n  const buf = Buffer.allocUnsafe(size);\n\n  let deferIndex = 0, deferWritten = 0, nextOffset = -1;\n  if (defers.length > 0) {\n    nextOffset = defers[0].offset;\n  }\n\n  let defer, deferLength = 0, offset = 0;\n  for (let i = 0, l = bytes.length; i < l; i++) {\n    buf[deferWritten + i] = bytes[i];\n    while (i + 1 === nextOffset) {\n      defer = defers[deferIndex];\n      deferLength = defer.length;\n      offset = deferWritten + nextOffset;\n      if (defer.bin) {\n        if (deferLength > MICRO_OPT_LEN) {\n          defer.bin.copy(buf, offset, 0, deferLength);\n        } else {\n          const bin = defer.bin;\n          for (let j = 0; j < deferLength; j++) {\n            buf[offset + j] = bin[j];\n          }\n        }\n      } else if (defer.str) {\n        if (deferLength > MICRO_OPT_LEN) {\n          buf.write(defer.str, offset, deferLength, 'utf8');\n        } else {\n          utf8Write(buf, offset, defer.str);\n        }\n      } else if (defer.float !== undefined) {\n        buf.writeDoubleBE(defer.float, offset);\n      } else if (defer.arraybuffer) {\n        const arr = new Uint8Array(defer.arraybuffer);\n        for (let k = 0; k < deferLength; k++) {\n          buf[offset + k] = arr[k];\n        }\n      }\n      deferIndex++;\n      deferWritten += deferLength;\n      if (defers[deferIndex]) {\n        nextOffset = defers[deferIndex].offset;\n      } else {\n        break;\n      }\n    }\n  }\n  return buf;\n}\n\nmodule.exports = { encode, _encode, utf8Length, utf8Write, MICRO_OPT_LEN };\n","'use strict'\n\nconst URL = require('url-parse')\nconst log = require('../../log')\nconst Writer = require('./writer')\nconst Scheduler = require('./scheduler')\n\nclass AgentExporter {\n  constructor ({ url, hostname, port, flushInterval, lookup, protocolVersion }, prioritySampler) {\n    this._url = url || new URL(`http://${hostname || 'localhost'}:${port}`)\n    this._writer = new Writer({ url: this._url, prioritySampler, lookup, protocolVersion })\n\n    if (flushInterval > 0) {\n      this._scheduler = new Scheduler(() => this._writer.flush(), flushInterval)\n    }\n    this._scheduler && this._scheduler.start()\n  }\n\n  setUrl (url) {\n    try {\n      url = new URL(url)\n      this._url = url\n      this._writer.setUrl(url)\n    } catch (e) {\n      log.warn(e.stack)\n    }\n  }\n\n  export (spans) {\n    this._writer.append(spans)\n\n    if (!this._scheduler) {\n      this._writer.flush()\n    }\n  }\n}\n\nmodule.exports = AgentExporter\n","'use strict'\n\nconst platform = require('../../platform')\n\nclass Scheduler {\n  constructor (callback, interval) {\n    this._timer = null\n    this._callback = callback\n    this._interval = interval\n  }\n\n  start () {\n    this._timer = setInterval(this._callback, this._interval)\n    this._timer.unref && this._timer.unref()\n\n    platform.on('exit', this._callback)\n  }\n\n  stop () {\n    clearInterval(this._timer)\n\n    platform.off('exit', this._callback)\n  }\n\n  reset () {\n    this.stop()\n    this.start()\n  }\n}\n\nmodule.exports = Scheduler\n","'use strict'\n\nconst platform = require('../../platform')\nconst log = require('../../log')\nconst tracerVersion = require('../../../lib/version')\n\nconst METRIC_PREFIX = 'datadog.tracer.node.exporter.agent'\n\nclass Writer {\n  constructor ({ url, prioritySampler, lookup, protocolVersion }) {\n    const AgentEncoder = getEncoder(protocolVersion)\n\n    this._url = url\n    this._prioritySampler = prioritySampler\n    this._lookup = lookup\n    this._protocolVersion = protocolVersion\n    this._encoderForVersion = new AgentEncoder(this)\n  }\n\n  append (spans) {\n    log.debug(() => `Encoding trace: ${JSON.stringify(spans)}`)\n\n    this._encode(spans)\n  }\n\n  _sendPayload (data, count, done) {\n    platform.metrics().increment(`${METRIC_PREFIX}.requests`, true)\n\n    makeRequest(this._protocolVersion, data, count, this._url, this._lookup, true, (err, res, status) => {\n      if (status) {\n        platform.metrics().increment(`${METRIC_PREFIX}.responses`, true)\n        platform.metrics().increment(`${METRIC_PREFIX}.responses.by.status`, `status:${status}`, true)\n      } else if (err) {\n        platform.metrics().increment(`${METRIC_PREFIX}.errors`, true)\n        platform.metrics().increment(`${METRIC_PREFIX}.errors.by.name`, `name:${err.name}`, true)\n\n        if (err.code) {\n          platform.metrics().increment(`${METRIC_PREFIX}.errors.by.code`, `code:${err.code}`, true)\n        }\n      }\n\n      platform.startupLog.startupLog({ agentError: err })\n\n      if (err) {\n        log.error(err)\n        done()\n        return\n      }\n\n      log.debug(`Response from the agent: ${res}`)\n\n      try {\n        this._prioritySampler.update(JSON.parse(res).rate_by_service)\n      } catch (e) {\n        log.error(e)\n\n        platform.metrics().increment(`${METRIC_PREFIX}.errors`, true)\n        platform.metrics().increment(`${METRIC_PREFIX}.errors.by.name`, `name:${e.name}`, true)\n      }\n      done()\n    })\n  }\n\n  setUrl (url) {\n    this._url = url\n  }\n\n  _encode (trace) {\n    this._encoderForVersion.encode(trace)\n  }\n\n  flush (done = () => {}) {\n    const count = this._encoderForVersion.count()\n\n    if (count > 0) {\n      const payload = this._encoderForVersion.makePayload()\n\n      this._sendPayload(payload, count, done)\n    } else {\n      done()\n    }\n  }\n}\n\nfunction setHeader (headers, key, value) {\n  if (value) {\n    headers[key] = value\n  }\n}\n\nfunction getEncoder (protocolVersion) {\n  if (protocolVersion === '0.5') {\n    return require('../../encode/0.5').AgentEncoder\n  } else {\n    return require('../../encode/0.4').AgentEncoder\n  }\n}\n\nfunction makeRequest (version, data, count, url, lookup, needsStartupLog, cb) {\n  const options = {\n    path: `/v${version}/traces`,\n    method: 'PUT',\n    headers: {\n      'Content-Type': 'application/msgpack',\n      'Datadog-Meta-Tracer-Version': tracerVersion,\n      'X-Datadog-Trace-Count': String(count)\n    },\n    lookup\n  }\n\n  setHeader(options.headers, 'Datadog-Meta-Lang', platform.name())\n  setHeader(options.headers, 'Datadog-Meta-Lang-Version', platform.version())\n  setHeader(options.headers, 'Datadog-Meta-Lang-Interpreter', platform.engine())\n\n  if (url.protocol === 'unix:') {\n    options.socketPath = url.pathname\n  } else {\n    options.protocol = url.protocol\n    options.hostname = url.hostname\n    options.port = url.port\n  }\n\n  log.debug(() => `Request to the agent: ${JSON.stringify(options)}`)\n\n  platform.request(Object.assign({ data }, options), (err, res, status) => {\n    if (needsStartupLog) {\n      // Note that logging will only happen once, regardless of how many times this is called.\n      platform.startupLog.startupLog({\n        agentError: status !== 404 && status !== 200 ? err : undefined\n      })\n    }\n    cb(err, res, status)\n  })\n}\n\nmodule.exports = Writer\n","'use strict'\n\nconst constants = require('./constants')\nconst tags = require('../../../ext/tags')\nconst log = require('./log')\nconst id = require('./id')\n\nconst SAMPLING_PRIORITY_KEY = constants.SAMPLING_PRIORITY_KEY\nconst ANALYTICS_KEY = constants.ANALYTICS_KEY\nconst ANALYTICS = tags.ANALYTICS\nconst MEASURED = tags.MEASURED\nconst ORIGIN_KEY = constants.ORIGIN_KEY\nconst HOSTNAME_KEY = constants.HOSTNAME_KEY\n\nconst map = {\n  'service.name': 'service',\n  'span.type': 'type',\n  'resource.name': 'resource'\n}\n\nfunction format (span) {\n  const formatted = formatSpan(span)\n\n  extractError(formatted, span)\n  extractTags(formatted, span)\n  extractAnalytics(formatted, span)\n\n  return formatted\n}\n\nfunction formatSpan (span) {\n  const spanContext = span.context()\n\n  return {\n    trace_id: spanContext._traceId,\n    span_id: spanContext._spanId,\n    parent_id: spanContext._parentId || id('0'),\n    name: serialize(spanContext._name),\n    resource: serialize(spanContext._name),\n    error: 0,\n    meta: {},\n    metrics: {},\n    start: Math.round(span._startTime * 1e6),\n    duration: Math.round(span._duration * 1e6)\n  }\n}\n\nfunction extractTags (trace, span) {\n  const context = span.context()\n  const origin = context._trace.origin\n  const tags = context._tags\n  const hostname = context._hostname\n  const priority = context._sampling.priority\n  const internalErrors = span.tracer()._internalErrors\n\n  for (const tag in tags) {\n    switch (tag) {\n      case 'service.name':\n      case 'span.type':\n      case 'resource.name':\n        addTag(trace, {}, map[tag], tags[tag])\n        break\n      // HACK: remove when Datadog supports numeric status code\n      case 'http.status_code':\n        addTag(trace.meta, {}, tag, tags[tag] && String(tags[tag]))\n        break\n      case HOSTNAME_KEY:\n      case ANALYTICS:\n        break\n      case MEASURED:\n        addTag({}, trace.metrics, tag, tags[tag] === undefined || tags[tag] ? 1 : 0)\n        break\n      case 'error':\n        if (tags[tag] && (tags['span.kind'] !== 'internal' || internalErrors)) {\n          trace.error = 1\n        }\n        break\n      case 'error.type':\n      case 'error.msg':\n      case 'error.stack':\n        // HACK: remove when implemented in the backend\n        if (tags['span.kind'] !== 'internal' || internalErrors) {\n          trace.error = 1\n        }\n      default: // eslint-disable-line no-fallthrough\n        addTag(trace.meta, trace.metrics, tag, tags[tag])\n    }\n  }\n\n  if (span.tracer()._service === tags['service.name']) {\n    addTag(trace.meta, trace.metrics, 'language', 'javascript')\n  }\n\n  addTag(trace.meta, trace.metrics, SAMPLING_PRIORITY_KEY, priority)\n  addTag(trace.meta, trace.metrics, ORIGIN_KEY, origin)\n  addTag(trace.meta, trace.metrics, HOSTNAME_KEY, hostname)\n}\n\nfunction extractError (trace, span) {\n  const error = span.context()._tags['error']\n\n  if (error instanceof Error) {\n    trace.meta['error.msg'] = error.message\n    trace.meta['error.type'] = error.name\n    trace.meta['error.stack'] = error.stack\n  }\n}\n\nfunction extractAnalytics (trace, span) {\n  let analytics = span.context()._tags[ANALYTICS]\n\n  if (analytics === true) {\n    analytics = 1\n  } else {\n    analytics = parseFloat(analytics)\n  }\n\n  if (!isNaN(analytics)) {\n    trace.metrics[ANALYTICS_KEY] = Math.max(Math.min(analytics, 1), 0)\n  }\n}\n\nfunction addTag (meta, metrics, key, value, seen) {\n  switch (typeof value) {\n    case 'string':\n      meta[key] = value\n      break\n    case 'number':\n      if (isNaN(value)) break\n      metrics[key] = value\n      break\n    case 'undefined':\n      break\n    case 'object':\n      if (value === null) break\n\n      // Special case for Node.js Buffer and URL\n      if (isNodeBuffer(value) || isUrl(value)) {\n        metrics[key] = value.toString()\n        break\n      }\n\n      if (!Array.isArray(value)) {\n        addObjectTag(meta, metrics, key, value, seen)\n        break\n      }\n\n    default: // eslint-disable-line no-fallthrough\n      addTag(meta, metrics, key, serialize(value))\n  }\n}\n\nfunction addObjectTag (meta, metrics, key, value, seen) {\n  seen = seen || []\n\n  if (~seen.indexOf(value)) {\n    meta[key] = '[Circular]'\n    return\n  }\n\n  seen.push(value)\n\n  for (const prop in value) {\n    addTag(meta, metrics, `${key}.${prop}`, value[prop], seen)\n  }\n\n  seen.pop()\n}\n\nfunction serialize (obj) {\n  try {\n    return obj && typeof obj.toString !== 'function' ? JSON.stringify(obj) : String(obj)\n  } catch (e) {\n    log.error(e)\n  }\n}\n\nfunction isNodeBuffer (obj) {\n  return obj.constructor && obj.constructor.name === 'Buffer' &&\n    typeof obj.readInt8 === 'function' &&\n    typeof obj.toString === 'function'\n}\n\nfunction isUrl (obj) {\n  return obj.constructor && obj.constructor.name === 'URL' &&\n    typeof obj.href === 'string' &&\n    typeof obj.toString === 'function'\n}\n\nmodule.exports = format\n","'use strict'\n\nconst hdr = require('hdr-histogram-js')\n\nconst highestTrackableValue = 3.6e12 // 1 hour\n\nclass Histogram {\n  constructor () {\n    this._histogram = hdr.build({\n      highestTrackableValue\n    })\n\n    this.reset()\n  }\n\n  get min () { return this._min }\n  get max () { return this._max }\n  get avg () { return this._count === 0 ? 0 : this._sum / this._count }\n  get sum () { return this._sum }\n  get count () { return this._count }\n  get median () { return this.percentile(50) }\n  get p95 () { return this.percentile(95) }\n\n  percentile (percentile) {\n    return this._histogram.getValueAtPercentile(percentile)\n  }\n\n  record (value) {\n    if (this._count === 0) {\n      this._min = this._max = value\n    } else {\n      this._min = Math.min(this._min, value)\n      this._max = Math.max(this._max, value)\n    }\n\n    this._count++\n    this._sum += value\n\n    this._histogram.recordValue(value)\n  }\n\n  reset () {\n    this._min = 0\n    this._max = 0\n    this._sum = 0\n    this._count = 0\n\n    this._histogram.reset()\n  }\n}\n\nmodule.exports = Histogram\n","'use strict'\n\nconst platform = require('./platform')\n\nconst UINT_MAX = 4294967296\n\nconst zeroId = new Uint8Array(8)\n\n// Cryptographically secure local seeds to mitigate Math.random() seed reuse.\nconst seed = new Uint32Array(2)\n\nif (platform.crypto) {\n  platform.crypto.getRandomValues(seed)\n}\n\nconst map = Array.prototype.map\nconst pad = byte => `${byte < 16 ? '0' : ''}${byte.toString(16)}`\n\n// Internal representation of a trace or span ID.\nclass Identifier {\n  constructor (value, radix) {\n    this._isUint64BE = true // msgpack-lite compatibility\n    this._buffer = typeof radix === 'number'\n      ? fromString(value, radix)\n      : createBuffer(value)\n  }\n\n  toString (radix) {\n    return typeof radix === 'number'\n      ? toNumberString(this._buffer, radix)\n      : toHexString(this._buffer)\n  }\n\n  toBuffer () {\n    return this._buffer\n  }\n\n  // msgpack-lite compatibility\n  toArray () {\n    if (this._buffer.length === 8) {\n      return this._buffer\n    }\n    return this._buffer.subarray(-8)\n  }\n\n  toJSON () {\n    return this.toString()\n  }\n}\n\n// Create a buffer, using an optional hexadecimal value if provided.\nfunction createBuffer (value) {\n  if (value === '0') return zeroId\n  if (!value) return pseudoRandom()\n\n  const size = Math.ceil(value.length / 2)\n  const buffer = new Uint8Array(size)\n\n  for (let i = 0; i < size; i++) {\n    buffer[i] = parseInt(value.substring(i * 2, i * 2 + 2), 16)\n  }\n\n  return buffer\n}\n\n// Convert a numerical string to a buffer using the specified radix.\nfunction fromString (str, raddix) {\n  const buffer = new Uint8Array(8)\n  const len = str.length\n\n  let pos = 0\n  let high = 0\n  let low = 0\n\n  if (str[0] === '-') pos++\n\n  const sign = pos\n\n  while (pos < len) {\n    const chr = parseInt(str[pos++], raddix)\n\n    if (!(chr >= 0)) break // NaN\n\n    low = low * raddix + chr\n    high = high * raddix + Math.floor(low / UINT_MAX)\n    low %= UINT_MAX\n  }\n\n  if (sign) {\n    high = ~high\n\n    if (low) {\n      low = UINT_MAX - low\n    } else {\n      high++\n    }\n  }\n\n  writeUInt32BE(buffer, high, 0)\n  writeUInt32BE(buffer, low, 4)\n\n  return buffer\n}\n\n// Convert a buffer to a numerical string.\nfunction toNumberString (buffer, radix) {\n  let high = readInt32(buffer, 0)\n  let low = readInt32(buffer, 4)\n  let str = ''\n\n  radix = radix || 10\n\n  while (1) {\n    const mod = (high % radix) * UINT_MAX + low\n\n    high = Math.floor(high / radix)\n    low = Math.floor(mod / radix)\n    str = (mod % radix).toString(radix) + str\n\n    if (!high && !low) break\n  }\n\n  return str\n}\n\n// Convert a buffer to a hexadecimal string.\nfunction toHexString (buffer) {\n  return map.call(buffer, pad).join('')\n}\n\n// Simple pseudo-random 64-bit ID generator.\nfunction pseudoRandom () {\n  const buffer = new Uint8Array(8)\n\n  const hi = randomUInt32(seed[0]) & 0x7FFFFFFF // only positive int64\n  const lo = randomUInt32(seed[1])\n\n  writeUInt32BE(buffer, hi, 0)\n  writeUInt32BE(buffer, lo, 4)\n\n  return buffer\n}\n\n// Generate a random unsigned 32-bit integer.\nfunction randomUInt32 (seed) {\n  return seed ^ Math.floor(Math.random() * (0xFFFFFFFF + 1))\n}\n\n// Read a buffer to unsigned integer bytes.\nfunction readInt32 (buffer, offset) {\n  return (buffer[offset + 0] * 16777216) +\n    (buffer[offset + 1] << 16) +\n    (buffer[offset + 2] << 8) +\n    buffer[offset + 3]\n}\n\n// Write unsigned integer bytes to a buffer.\nfunction writeUInt32BE (buffer, value, offset) {\n  buffer[3 + offset] = value & 255\n  value = value >> 8\n  buffer[2 + offset] = value & 255\n  value = value >> 8\n  buffer[1 + offset] = value & 255\n  value = value >> 8\n  buffer[0 + offset] = value & 255\n}\n\nmodule.exports = (value, radix) => new Identifier(value, radix)\n","'use strict'\n\nconst shimmer = require('shimmer')\nconst log = require('./log')\nconst platform = require('./platform')\nconst { isTrue, isFalse } = require('./util')\n\nshimmer({ logger: () => {} })\n\nconst plugins = platform.plugins\n\nconst disabldPlugins = platform.env('DD_TRACE_DISABLED_PLUGINS')\n\nconst collectDisabledPlugins = () => {\n  return new Set(disabldPlugins && disabldPlugins.split(',').map(plugin => plugin.trim()))\n}\n\nfunction cleanEnv (name) {\n  return platform.env(`DD_TRACE_${name.toUpperCase()}`.replace(/[^a-z0-9_]/ig, '_'))\n}\n\nfunction getConfig (name, config = {}) {\n  if (!name) {\n    return config\n  }\n\n  const enabled = cleanEnv(`${name}_ENABLED`)\n  if (enabled !== undefined) {\n    config.enabled = isTrue(enabled)\n  }\n\n  const analyticsEnabled = cleanEnv(`${name}_ANALYTICS_ENABLED`)\n  const analyticsSampleRate = Math.min(Math.max(cleanEnv(`${name}_ANALYTICS_SAMPLE_RATE`), 0), 1)\n\n  if (isFalse(analyticsEnabled)) {\n    config.analytics = false\n  } else if (!Number.isNaN(analyticsSampleRate)) {\n    config.analytics = analyticsSampleRate\n  } else if (isTrue(analyticsEnabled)) {\n    config.analytics = true\n  }\n\n  return config\n}\n\nclass Instrumenter {\n  constructor (tracer) {\n    this._tracer = tracer\n    this._loader = new platform.Loader(this)\n    this._enabled = false\n    this._names = new Set()\n    this._plugins = new Map()\n    this._instrumented = new Map()\n    this._disabledPlugins = collectDisabledPlugins()\n  }\n\n  use (name, config) {\n    if (typeof config === 'boolean') {\n      config = { enabled: config }\n    }\n\n    config = getConfig(name, config)\n\n    try {\n      this._set(plugins[name.toLowerCase()], { name, config })\n    } catch (e) {\n      log.debug(`Could not find a plugin named \"${name}\".`)\n    }\n\n    if (this._enabled) {\n      this._loader.reload(this._plugins)\n    }\n  }\n\n  enable (config) {\n    config = config || {}\n\n    this._enabled = true\n\n    if (config.plugins !== false) {\n      Object.keys(plugins)\n        .filter(name => !this._plugins.has(plugins[name]))\n        .forEach(name => {\n          this._set(plugins[name], { name, config: getConfig(name) })\n        })\n    }\n\n    this._loader.reload(this._plugins)\n  }\n\n  disable () {\n    for (const instrumentation of this._instrumented.keys()) {\n      this.unpatch(instrumentation)\n    }\n\n    this._plugins.clear()\n    this._enabled = false\n    this._loader.reload(this._plugins)\n  }\n\n  wrap (nodules, names, wrapper) {\n    nodules = [].concat(nodules)\n    names = [].concat(names)\n\n    nodules.forEach(nodule => {\n      names.forEach(name => {\n        if (typeof nodule[name] !== 'function') {\n          throw new Error(`Expected object ${nodule} to contain method ${name}.`)\n        }\n\n        Object.defineProperty(nodule[name], '_datadog_patched', {\n          value: true,\n          configurable: true\n        })\n      })\n    })\n\n    shimmer.massWrap.call(this, nodules, names, function (original, name) {\n      const wrapped = wrapper(original, name)\n      const props = Object.getOwnPropertyDescriptors(original)\n      const keys = Reflect.ownKeys(props)\n\n      // https://github.com/othiym23/shimmer/issues/19\n      for (const key of keys) {\n        if (typeof key !== 'symbol' || wrapped.hasOwnProperty(key)) continue\n\n        Object.defineProperty(wrapped, key, props[key])\n      }\n\n      return wrapped\n    })\n  }\n\n  unwrap (nodules, names, wrapper) {\n    nodules = [].concat(nodules)\n    names = [].concat(names)\n\n    shimmer.massUnwrap.call(this, nodules, names, wrapper)\n\n    nodules.forEach(nodule => {\n      names.forEach(name => {\n        nodule[name] && delete nodule[name]._datadog_patched\n      })\n    })\n  }\n\n  wrapExport (moduleExports, wrapper) {\n    if (typeof moduleExports !== 'function') return moduleExports\n\n    const props = Object.keys(moduleExports)\n    const shim = function () {\n      return moduleExports._datadog_wrapper.apply(this, arguments)\n    }\n\n    for (const prop of props) {\n      shim[prop] = moduleExports[prop]\n    }\n\n    moduleExports._datadog_wrapper = wrapper\n\n    return shim\n  }\n\n  unwrapExport (moduleExports) {\n    if (moduleExports && moduleExports._datadog_wrapper) {\n      moduleExports._datadog_wrapper = moduleExports\n    }\n\n    return moduleExports\n  }\n\n  load (plugin, meta) {\n    if (!this._enabled) return\n\n    const instrumentations = [].concat(plugin)\n    const enabled = meta.config.enabled !== false\n\n    platform.metrics().boolean(`datadog.tracer.node.plugin.enabled.by.name`, enabled, `name:${meta.name}`)\n\n    try {\n      instrumentations\n        .forEach(instrumentation => {\n          this._loader.load(instrumentation, meta.config)\n        })\n    } catch (e) {\n      log.error(e)\n      this.unload(plugin)\n      log.debug(`Error while trying to patch ${meta.name}. The plugin has been disabled.`)\n\n      platform.metrics().increment(`datadog.tracer.node.plugin.errors`, true)\n    }\n  }\n\n  unload (plugin) {\n    [].concat(plugin)\n      .forEach(instrumentation => {\n        this.unpatch(instrumentation)\n        this._instrumented.delete(instrumentation)\n      })\n\n    const meta = this._plugins.get(plugin)\n\n    if (meta) {\n      this._plugins.delete(plugin)\n\n      platform.metrics().boolean(`datadog.tracer.node.plugin.enabled.by.name`, false, `name:${meta.name}`)\n    }\n  }\n\n  patch (instrumentation, moduleExports, config) {\n    let instrumented = this._instrumented.get(instrumentation)\n\n    if (!instrumented) {\n      this._instrumented.set(instrumentation, instrumented = new Set())\n    }\n\n    if (!instrumented.has(moduleExports)) {\n      instrumented.add(moduleExports)\n      return instrumentation.patch.call(this, moduleExports, this._tracer._tracer, config)\n    }\n  }\n\n  unpatch (instrumentation) {\n    const instrumented = this._instrumented.get(instrumentation)\n\n    if (instrumented) {\n      instrumented.forEach(moduleExports => {\n        try {\n          instrumentation.unpatch.call(this, moduleExports, this._tracer)\n        } catch (e) {\n          log.error(e)\n        }\n      })\n    }\n  }\n\n  _set (plugin, meta) {\n    if (this._disabledPlugins.has(meta.name)) {\n      log.debug(`Plugin \"${meta.name}\" was disabled via configuration option.`)\n    } else {\n      this._plugins.set(plugin, meta)\n      this.load(plugin, meta)\n    }\n  }\n}\n\nmodule.exports = Instrumenter\n","'use strict'\n\nconst NoopSpan = require('./noop/span')\n\nconst _default = {\n  debug: msg => console.debug(msg), /* eslint-disable-line no-console */\n  info: msg => console.info(msg), /* eslint-disable-line no-console */\n  warn: msg => console.warn(msg), /* eslint-disable-line no-console */\n  error: msg => console.error(msg) /* eslint-disable-line no-console */\n}\n\n// based on: https://github.com/trentm/node-bunyan#levels\nconst _logLevels = {\n  'debug': 20,\n  'info': 30,\n  'warn': 40,\n  'error': 50\n}\n\nconst _defaultLogLevel = 'debug'\n\nconst _checkLogLevel = (logLevel) => {\n  if (logLevel && typeof logLevel === 'string') {\n    return _logLevels[logLevel.toLowerCase().trim()] || _logLevels[_defaultLogLevel]\n  }\n\n  return _logLevels[_defaultLogLevel]\n}\n\nconst memoize = func => {\n  const cache = {}\n  const memoized = function (key) {\n    if (!cache[key]) {\n      cache[key] = func.apply(this, arguments)\n    }\n\n    return cache[key]\n  }\n\n  return memoized\n}\n\nfunction processMsg (msg) {\n  return typeof msg === 'function' ? msg() : msg\n}\n\nfunction withNoop (fn) {\n  if (!log._tracer) {\n    fn()\n  } else {\n    log._tracer.scope().activate(log._noopSpan(), fn)\n  }\n}\n\nconst log = {\n  _isLogLevelEnabled (level) {\n    return _logLevels[level] >= this._logLevel\n  },\n\n  use (logger) {\n    if (logger && logger.debug instanceof Function && logger.error instanceof Function) {\n      this._logger = logger\n    }\n\n    return this\n  },\n\n  toggle (enabled, logLevel, tracer) {\n    this._enabled = enabled\n    this._logLevel = _checkLogLevel(logLevel)\n    this._tracer = tracer\n\n    return this\n  },\n\n  _noopSpan () {\n    if (!this.__noopSpan) {\n      this.__noopSpan = new NoopSpan(this._tracer)\n    }\n    return this.__noopSpan\n  },\n\n  reset () {\n    this._logger = _default\n    this._enabled = false\n    delete this._tracer\n    delete this.__noopSpan\n    this._deprecate = memoize((code, message) => {\n      withNoop(() => this._logger.error(message))\n      return this\n    })\n    this._logLevel = _checkLogLevel()\n\n    return this\n  },\n\n  debug (message) {\n    if (this._enabled && this._isLogLevelEnabled('debug')) {\n      withNoop(() => this._logger.debug(processMsg(message)))\n    }\n\n    return this\n  },\n\n  info (message) {\n    if (!this._logger.info) return this.debug(message)\n    if (this._enabled && this._isLogLevelEnabled('info')) {\n      withNoop(() => this._logger.info(processMsg(message)))\n    }\n\n    return this\n  },\n\n  warn (message) {\n    if (!this._logger.warn) return this.debug(message)\n    if (this._enabled && this._isLogLevelEnabled('warn')) {\n      withNoop(() => this._logger.warn(processMsg(message)))\n    }\n\n    return this\n  },\n\n  error (err) {\n    if (this._enabled && this._isLogLevelEnabled('error')) {\n      if (err instanceof Function) {\n        err = err()\n      }\n\n      if (typeof err !== 'object' || !err) {\n        err = String(err)\n      } else if (!err.stack) {\n        err = String(err.message || err)\n      }\n\n      if (typeof err === 'string') {\n        err = new Error(err)\n      }\n\n      withNoop(() => this._logger.error(err))\n    }\n\n    return this\n  },\n\n  deprecate (code, message) {\n    return this._deprecate(code, message)\n  }\n}\n\nlog.reset()\n\nmodule.exports = log\n","'use strict'\n\nconst Span = require('opentracing').Span\nconst NoopSpanContext = require('../noop/span_context')\nconst id = require('../id')\n\nclass NoopSpan extends Span {\n  constructor (tracer, parent) {\n    super()\n\n    this._noopTracer = tracer\n    this._noopContext = this._createContext(parent)\n  }\n\n  _context () {\n    return this._noopContext\n  }\n\n  _tracer () {\n    return this._noopTracer\n  }\n\n  _createContext (parent) {\n    const spanId = id()\n\n    if (parent) {\n      return new NoopSpanContext({\n        noop: this,\n        traceId: parent._traceId,\n        spanId,\n        parentId: parent._spanId,\n        baggageItems: Object.assign({}, parent._baggageItems)\n      })\n    } else {\n      return new NoopSpanContext({\n        noop: this,\n        traceId: spanId,\n        spanId\n      })\n    }\n  }\n}\n\nmodule.exports = NoopSpan\n","'use strict'\n\nconst DatadogSpanContext = require('../opentracing/span_context')\nconst priority = require('../../../../ext/priority')\n\nconst USER_REJECT = priority.USER_REJECT\n\nclass NoopSpanContext extends DatadogSpanContext {\n  constructor (props) {\n    super(props)\n\n    this._traceFlags.sampled = false\n    this._sampling.priority = USER_REJECT\n  }\n}\n\nmodule.exports = NoopSpanContext\n","'use strict'\n\nconst Tracer = require('opentracing').Tracer\nconst Scope = require('../scope/base')\nconst Span = require('./span')\nconst platform = require('../platform')\n\nclass NoopTracer extends Tracer {\n  constructor (config) {\n    super(config)\n\n    let ScopeManager\n\n    if (platform.env('DD_CONTEXT_PROPAGATION') === 'false') {\n      ScopeManager = require('../scope/noop/scope_manager')\n    } else {\n      ScopeManager = require('../scope/scope_manager')\n    }\n\n    this._scopeManager = new ScopeManager()\n    this._scope = new Scope(config)\n    this._span = new Span(this)\n  }\n\n  trace (name, options, fn) {\n    return fn(this._span, () => {})\n  }\n\n  wrap (name, options, fn) {\n    return fn\n  }\n\n  scopeManager () {\n    return this._scopeManager\n  }\n\n  scope () {\n    return this._scope\n  }\n\n  currentSpan () {\n    return null\n  }\n\n  getRumData () {\n    return ''\n  }\n\n  setUrl () {\n  }\n\n  _startSpan (name, options) {\n    return this._span\n  }\n}\n\nmodule.exports = NoopTracer\n","'use strict'\n\nconst pick = require('lodash.pick')\nconst id = require('../../id')\nconst DatadogSpanContext = require('../span_context')\nconst NoopSpanContext = require('../../noop/span_context')\nconst log = require('../../log')\n\nconst traceKey = 'x-datadog-trace-id'\nconst spanKey = 'x-datadog-parent-id'\nconst originKey = 'x-datadog-origin'\nconst samplingKey = 'x-datadog-sampling-priority'\nconst sampleKey = 'x-datadog-sampled'\nconst baggagePrefix = 'ot-baggage-'\nconst b3TraceKey = 'x-b3-traceid'\nconst b3TraceExpr = /^([0-9a-f]{16}){1,2}$/i\nconst b3SpanKey = 'x-b3-spanid'\nconst b3SpanExpr = /^[0-9a-f]{16}$/i\nconst b3ParentKey = 'x-b3-parentspanid'\nconst b3SampledKey = 'x-b3-sampled'\nconst b3FlagsKey = 'x-b3-flags'\nconst b3HeaderKey = 'b3'\nconst b3HeaderExpr = /^(([0-9a-f]{16}){1,2}-[0-9a-f]{16}(-[01d](-[0-9a-f]{16})?)?|[01d])$/i\nconst baggageExpr = new RegExp(`^${baggagePrefix}(.+)$`)\nconst ddKeys = [traceKey, spanKey, samplingKey, originKey]\nconst b3Keys = [b3TraceKey, b3SpanKey, b3ParentKey, b3SampledKey, b3FlagsKey, b3HeaderKey]\nconst logKeys = ddKeys.concat(b3Keys)\n\nclass TextMapPropagator {\n  constructor (config) {\n    this._config = config\n  }\n\n  inject (spanContext, carrier) {\n    carrier[traceKey] = spanContext.toTraceId()\n    carrier[spanKey] = spanContext.toSpanId()\n    carrier[sampleKey] = spanContext._traceFlags.sampled ? '1' : '0'\n\n    this._injectOrigin(spanContext, carrier)\n    this._injectSamplingPriority(spanContext, carrier)\n    this._injectBaggageItems(spanContext, carrier)\n    this._injectB3(spanContext, carrier)\n\n    log.debug(() => `Inject into carrier: ${JSON.stringify(pick(carrier, logKeys))}.`)\n  }\n\n  extract (carrier) {\n    const spanContext = this._extractSpanContext(carrier)\n\n    if (!spanContext) return spanContext\n\n    this._extractOrigin(carrier, spanContext)\n    this._extractBaggageItems(carrier, spanContext)\n    this._extractSamplingPriority(carrier, spanContext)\n\n    log.debug(() => `Extract from carrier: ${JSON.stringify(pick(carrier, logKeys))}.`)\n\n    return spanContext\n  }\n\n  _injectOrigin (spanContext, carrier) {\n    const origin = spanContext._trace.origin\n\n    if (origin) {\n      carrier[originKey] = origin\n    }\n  }\n\n  _injectSamplingPriority (spanContext, carrier) {\n    const priority = spanContext._sampling.priority\n\n    if (Number.isInteger(priority)) {\n      carrier[samplingKey] = priority.toString()\n    }\n  }\n\n  _injectBaggageItems (spanContext, carrier) {\n    spanContext._baggageItems && Object.keys(spanContext._baggageItems).forEach(key => {\n      carrier[baggagePrefix + key] = String(spanContext._baggageItems[key])\n    })\n  }\n\n  _injectB3 (spanContext, carrier) {\n    if (!this._config.experimental.b3) return\n\n    carrier[b3TraceKey] = spanContext._traceId.toString('hex')\n    carrier[b3SpanKey] = spanContext._spanId.toString('hex')\n    carrier[b3SampledKey] = spanContext._traceFlags.sampled ? '1' : '0'\n\n    if (spanContext._traceFlags.debug) {\n      carrier[b3FlagsKey] = '1'\n    }\n\n    if (spanContext._parentId) {\n      carrier[b3ParentKey] = spanContext._parentId.toString('hex')\n    }\n  }\n\n  _extractSpanContext (carrier) {\n    const context = this._extractContext(carrier)\n\n    if (!context) return null\n\n    if (context.traceFlags.sampled !== false) {\n      return new DatadogSpanContext(context)\n    } else {\n      return new NoopSpanContext(context)\n    }\n  }\n\n  _extractContext (carrier) {\n    return this._extractDatadogContext(carrier) || this._extractB3Context(carrier)\n  }\n\n  _extractDatadogContext (carrier) {\n    const sampled = this._isSampled(carrier[sampleKey])\n\n    return this._extractGenericContext(carrier, traceKey, spanKey, { sampled }, 10)\n  }\n\n  _extractB3Context (carrier) {\n    if (!this._config.experimental.b3) return null\n\n    const b3 = this._extractB3Headers(carrier)\n    const debug = b3[b3FlagsKey] === '1'\n    const sampled = this._isSampled(b3[b3SampledKey], debug)\n\n    return this._extractGenericContext(b3, b3TraceKey, b3SpanKey, { sampled, debug })\n  }\n\n  _extractGenericContext (carrier, traceKey, spanKey, traceFlags, radix) {\n    if (carrier[traceKey] && carrier[spanKey]) {\n      return {\n        traceId: id(carrier[traceKey], radix),\n        spanId: id(carrier[spanKey], radix),\n        traceFlags\n      }\n    } else if (typeof traceFlags.sampled === 'boolean') {\n      return {\n        traceId: id(),\n        spanId: null,\n        traceFlags\n      }\n    }\n\n    return null\n  }\n\n  _extractB3Headers (carrier) {\n    if (b3HeaderExpr.test(carrier[b3HeaderKey])) {\n      return this._extractB3SingleHeader(carrier)\n    } else {\n      return this._extractB3MultipleHeaders(carrier)\n    }\n  }\n\n  _extractB3MultipleHeaders (carrier) {\n    const b3 = {}\n\n    if (b3TraceExpr.test(carrier[b3TraceKey]) && b3SpanExpr.test(carrier[b3SpanKey])) {\n      b3[b3TraceKey] = carrier[b3TraceKey]\n      b3[b3SpanKey] = carrier[b3SpanKey]\n    }\n\n    if (carrier[b3SampledKey]) {\n      b3[b3SampledKey] = carrier[b3SampledKey]\n    }\n\n    if (carrier[b3FlagsKey]) {\n      b3[b3FlagsKey] = carrier[b3FlagsKey]\n    }\n\n    return b3\n  }\n\n  _extractB3SingleHeader (carrier) {\n    const parts = carrier[b3HeaderKey].split('-')\n\n    if (parts[0] === 'd') {\n      return {\n        [b3SampledKey]: '1',\n        [b3FlagsKey]: '1'\n      }\n    } else if (parts.length === 1) {\n      return {\n        [b3SampledKey]: parts[0]\n      }\n    } else {\n      const b3 = {\n        [b3TraceKey]: parts[0],\n        [b3SpanKey]: parts[1],\n        [b3SampledKey]: parts[2] !== '0' ? '1' : '0'\n      }\n\n      if (parts[2] === 'd') {\n        b3[b3FlagsKey] = '1'\n      }\n\n      return b3\n    }\n  }\n\n  _extractOrigin (carrier, spanContext) {\n    const origin = carrier[originKey]\n\n    if (typeof carrier[originKey] === 'string') {\n      spanContext._trace.origin = origin\n    }\n  }\n\n  _extractBaggageItems (carrier, spanContext) {\n    Object.keys(carrier).forEach(key => {\n      const match = key.match(baggageExpr)\n\n      if (match) {\n        spanContext._baggageItems[match[1]] = carrier[key]\n      }\n    })\n  }\n\n  _extractSamplingPriority (carrier, spanContext) {\n    const priority = parseInt(carrier[samplingKey], 10)\n\n    if (Number.isInteger(priority)) {\n      spanContext._sampling.priority = parseInt(carrier[samplingKey], 10)\n    }\n  }\n\n  _isSampled (sampled, debug) {\n    if (debug || sampled === '1') {\n      return true\n    } else if (sampled === '0') {\n      return false\n    }\n\n    return null\n  }\n}\n\nmodule.exports = TextMapPropagator\n","'use strict'\n\nconst opentracing = require('opentracing')\nconst Span = opentracing.Span\nconst SpanContext = require('./span_context')\nconst platform = require('../platform')\nconst constants = require('../constants')\nconst id = require('../id')\nconst tagger = require('../tagger')\n\nconst SAMPLE_RATE_METRIC_KEY = constants.SAMPLE_RATE_METRIC_KEY\n\nclass DatadogSpan extends Span {\n  constructor (tracer, processor, sampler, prioritySampler, fields, debug) {\n    super()\n\n    const operationName = fields.operationName\n    const parent = fields.parent || null\n    const tags = Object.assign({\n      [SAMPLE_RATE_METRIC_KEY]: sampler.rate()\n    }, fields.tags)\n    const hostname = fields.hostname\n\n    this._parentTracer = tracer\n    this._debug = debug\n    this._sampler = sampler\n    this._processor = processor\n    this._prioritySampler = prioritySampler\n\n    this._spanContext = this._createContext(parent)\n    this._spanContext._name = operationName\n    this._spanContext._tags = tags\n    this._spanContext._hostname = hostname\n\n    this._startTime = fields.startTime || this._getTime()\n\n    if (debug) {\n      this._handle = platform.metrics().track(this)\n    }\n  }\n\n  toString () {\n    const spanContext = this.context()\n    const resourceName = spanContext._tags['resource.name']\n    const resource = resourceName.length > 100\n      ? `${resourceName.substring(0, 97)}...`\n      : resourceName\n    const json = JSON.stringify({\n      traceId: spanContext._traceId,\n      spanId: spanContext._spanId,\n      parentId: spanContext._parentId,\n      service: spanContext._tags['service.name'],\n      name: spanContext._name,\n      resource\n    })\n\n    return `Span${json}`\n  }\n\n  _createContext (parent) {\n    let spanContext\n\n    if (parent) {\n      spanContext = new SpanContext({\n        traceId: parent._traceId,\n        spanId: id(),\n        parentId: parent._spanId,\n        sampling: parent._sampling,\n        baggageItems: Object.assign({}, parent._baggageItems),\n        trace: parent._trace\n      })\n    } else {\n      const spanId = id()\n      spanContext = new SpanContext({\n        traceId: spanId,\n        spanId\n      })\n    }\n\n    spanContext._trace.started.push(this)\n    spanContext._trace.startTime = spanContext._trace.startTime || Date.now()\n    spanContext._trace.ticks = spanContext._trace.ticks || platform.now()\n\n    return spanContext\n  }\n\n  _getTime () {\n    const { startTime, ticks } = this._spanContext._trace\n\n    return startTime + platform.now() - ticks\n  }\n\n  _context () {\n    return this._spanContext\n  }\n\n  _tracer () {\n    return this._parentTracer\n  }\n\n  _setOperationName (name) {\n    this._spanContext._name = name\n  }\n\n  _setBaggageItem (key, value) {\n    this._spanContext._baggageItems[key] = value\n  }\n\n  _getBaggageItem (key) {\n    return this._spanContext._baggageItems[key]\n  }\n\n  _addTags (keyValuePairs) {\n    tagger.add(this._spanContext._tags, keyValuePairs)\n  }\n\n  _finish (finishTime) {\n    if (this._duration !== undefined) {\n      return\n    }\n\n    finishTime = parseFloat(finishTime) || this._getTime()\n\n    this._duration = finishTime - this._startTime\n    this._spanContext._trace.finished.push(this)\n    this._spanContext._isFinished = true\n\n    if (this._debug) {\n      this._handle.finish()\n    }\n\n    this._processor.process(this)\n  }\n}\n\nmodule.exports = DatadogSpan\n","'use strict'\n\nconst SpanContext = require('opentracing').SpanContext\n\nclass DatadogSpanContext extends SpanContext {\n  constructor (props) {\n    super()\n\n    props = props || {}\n\n    this._traceId = props.traceId\n    this._spanId = props.spanId\n    this._parentId = props.parentId || null\n    this._name = props.name\n    this._isFinished = props.isFinished || false\n    this._tags = props.tags || {}\n    this._sampling = props.sampling || {}\n    this._baggageItems = props.baggageItems || {}\n    this._traceFlags = props.traceFlags || {}\n    this._traceFlags.sampled = this._traceFlags.sampled !== false\n    this._traceFlags.debug = this._traceFlags.debug === true\n    this._noop = props.noop || null\n    this._trace = props.trace || {\n      started: [],\n      finished: []\n    }\n  }\n\n  toTraceId () {\n    return this._traceId.toString(10)\n  }\n\n  toSpanId () {\n    return this._spanId.toString(10)\n  }\n}\n\nmodule.exports = DatadogSpanContext\n","'use strict'\n\nconst opentracing = require('opentracing')\nconst Tracer = opentracing.Tracer\nconst Reference = opentracing.Reference\nconst Span = require('./span')\nconst SpanContext = require('./span_context')\nconst SpanProcessor = require('../span_processor')\nconst Sampler = require('../sampler')\nconst PrioritySampler = require('../priority_sampler')\nconst TextMapPropagator = require('./propagation/text_map')\nconst HttpPropagator = require('./propagation/http')\nconst BinaryPropagator = require('./propagation/binary')\nconst LogPropagator = require('./propagation/log')\nconst NoopSpan = require('../noop/span')\nconst formats = require('../../../../ext/formats')\n\nconst log = require('../log')\nconst constants = require('../constants')\nconst platform = require('../platform')\n\nconst REFERENCE_NOOP = constants.REFERENCE_NOOP\nconst REFERENCE_CHILD_OF = opentracing.REFERENCE_CHILD_OF\nconst REFERENCE_FOLLOWS_FROM = opentracing.REFERENCE_FOLLOWS_FROM\n\nclass DatadogTracer extends Tracer {\n  constructor (config) {\n    super()\n\n    const Exporter = platform.exporter(config.experimental.exporter)\n\n    this._service = config.service\n    this._version = config.version\n    this._env = config.env\n    this._tags = config.tags\n    this._logInjection = config.logInjection\n    this._analytics = config.analytics\n    this._debug = config.debug\n    this._internalErrors = config.experimental.internalErrors\n    this._prioritySampler = new PrioritySampler(config.env, config.experimental.sampler)\n    this._exporter = new Exporter(config, this._prioritySampler)\n    this._processor = new SpanProcessor(this._exporter, this._prioritySampler)\n    this._url = this._exporter._url\n    this._sampler = new Sampler(config.sampleRate)\n    this._peers = config.experimental.peers\n    this._enableGetRumData = config.experimental.enableGetRumData\n    this._propagators = {\n      [formats.TEXT_MAP]: new TextMapPropagator(config),\n      [formats.HTTP_HEADERS]: new HttpPropagator(config),\n      [formats.BINARY]: new BinaryPropagator(config),\n      [formats.LOG]: new LogPropagator(config)\n    }\n    if (config.reportHostname) {\n      this._hostname = platform.hostname()\n    }\n  }\n\n  startSpan (name, fields) {\n    if (fields) {\n      if (fields.references) {\n        return super.startSpan(name, fields)\n      } else if (fields.childOf) {\n        let parent = fields.childOf\n        if (parent instanceof Span) {\n          parent = parent.context()\n        }\n        if (parent instanceof SpanContext) {\n          return this._startSpanInternal(name, fields, parent, REFERENCE_CHILD_OF)\n        }\n      }\n    }\n    return this._startSpanInternal(name, fields, null, null)\n  }\n\n  _startSpan (name, fields) {\n    const reference = getParent(fields.references)\n    const type = reference && reference.type()\n    const parent = reference && reference.referencedContext()\n    return this._startSpanInternal(name, fields, parent, type)\n  }\n\n  _startSpanInternal (name, fields = {}, parent, type) {\n    if (parent && parent._noop) return parent._noop\n    if (!isSampled(this._sampler, parent, type)) return new NoopSpan(this, parent)\n\n    const tags = {\n      'service.name': this._service\n    }\n\n    const span = new Span(this, this._processor, this._sampler, this._prioritySampler, {\n      operationName: fields.operationName || name,\n      parent,\n      tags,\n      startTime: fields.startTime,\n      hostname: this._hostname\n    }, this._debug)\n\n    span.addTags(this._tags)\n    span.addTags(fields.tags)\n    span.addTags(platform.tags())\n\n    return span\n  }\n\n  _inject (spanContext, format, carrier) {\n    try {\n      this._prioritySampler.sample(spanContext)\n      this._propagators[format].inject(spanContext, carrier)\n    } catch (e) {\n      log.error(e)\n      platform.metrics().increment('datadog.tracer.node.inject.errors', true)\n    }\n\n    return this\n  }\n\n  _extract (format, carrier) {\n    try {\n      return this._propagators[format].extract(carrier)\n    } catch (e) {\n      log.error(e)\n      platform.metrics().increment('datadog.tracer.node.extract.errors', true)\n      return null\n    }\n  }\n}\n\nfunction getParent (references = []) {\n  let parent = null\n\n  for (let i = 0; i < references.length; i++) {\n    const ref = references[i]\n\n    if (!(ref instanceof Reference)) {\n      log.error(() => `Expected ${ref} to be an instance of opentracing.Reference`)\n      continue\n    }\n\n    const spanContext = ref.referencedContext()\n    const type = ref.type()\n\n    if (type !== REFERENCE_NOOP && spanContext && !(spanContext instanceof SpanContext)) {\n      log.error(() => `Expected ${spanContext} to be an instance of SpanContext`)\n      continue\n    }\n\n    if (type === REFERENCE_CHILD_OF || type === REFERENCE_NOOP) {\n      parent = ref\n      break\n    } else if (type === REFERENCE_FOLLOWS_FROM) {\n      if (!parent) {\n        parent = ref\n      }\n    }\n  }\n\n  return parent\n}\n\nfunction isSampled (sampler, parent, type) {\n  if (type === REFERENCE_NOOP) return false\n  if (parent && !parent._traceFlags.sampled) return false\n  if (!parent && !sampler.isSampled()) return false\n\n  return true\n}\n\nmodule.exports = DatadogTracer\n","'use strict'\n\nmodule.exports = {\n  use (impl) {\n    Object.assign(this, impl)\n  },\n\n  configure (config) {\n    this._config = config\n  }\n}\n","function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = function() { return []; };\nwebpackEmptyContext.resolve = webpackEmptyContext;\nmodule.exports = webpackEmptyContext;\nwebpackEmptyContext.id = \"../../node_modules/dd-trace/packages/dd-trace/src/platform/node sync recursive\";","var map = {\n\t\"./\": \"../../node_modules/dd-trace/packages/dd-trace/src/platform/node/index.js\",\n\t\"./agents\": \"../../node_modules/dd-trace/packages/dd-trace/src/platform/node/agents.js\",\n\t\"./agents.js\": \"../../node_modules/dd-trace/packages/dd-trace/src/platform/node/agents.js\",\n\t\"./crypto\": \"../../node_modules/dd-trace/packages/dd-trace/src/platform/node/crypto.js\",\n\t\"./crypto.js\": \"../../node_modules/dd-trace/packages/dd-trace/src/platform/node/crypto.js\",\n\t\"./dogstatsd\": \"../../node_modules/dd-trace/packages/dd-trace/src/platform/node/dogstatsd.js\",\n\t\"./dogstatsd.js\": \"../../node_modules/dd-trace/packages/dd-trace/src/platform/node/dogstatsd.js\",\n\t\"./env\": \"../../node_modules/dd-trace/packages/dd-trace/src/platform/node/env.js\",\n\t\"./env.js\": \"../../node_modules/dd-trace/packages/dd-trace/src/platform/node/env.js\",\n\t\"./exporter\": \"../../node_modules/dd-trace/packages/dd-trace/src/platform/node/exporter.js\",\n\t\"./exporter.js\": \"../../node_modules/dd-trace/packages/dd-trace/src/platform/node/exporter.js\",\n\t\"./hostname\": \"../../node_modules/dd-trace/packages/dd-trace/src/platform/node/hostname.js\",\n\t\"./hostname.js\": \"../../node_modules/dd-trace/packages/dd-trace/src/platform/node/hostname.js\",\n\t\"./index\": \"../../node_modules/dd-trace/packages/dd-trace/src/platform/node/index.js\",\n\t\"./index.js\": \"../../node_modules/dd-trace/packages/dd-trace/src/platform/node/index.js\",\n\t\"./loader\": \"../../node_modules/dd-trace/packages/dd-trace/src/platform/node/loader.js\",\n\t\"./loader.js\": \"../../node_modules/dd-trace/packages/dd-trace/src/platform/node/loader.js\",\n\t\"./metrics\": \"../../node_modules/dd-trace/packages/dd-trace/src/platform/node/metrics.js\",\n\t\"./metrics.js\": \"../../node_modules/dd-trace/packages/dd-trace/src/platform/node/metrics.js\",\n\t\"./now\": \"../../node_modules/dd-trace/packages/dd-trace/src/platform/node/now.js\",\n\t\"./now.js\": \"../../node_modules/dd-trace/packages/dd-trace/src/platform/node/now.js\",\n\t\"./pkg\": \"../../node_modules/dd-trace/packages/dd-trace/src/platform/node/pkg.js\",\n\t\"./pkg.js\": \"../../node_modules/dd-trace/packages/dd-trace/src/platform/node/pkg.js\",\n\t\"./profiler\": \"../../node_modules/dd-trace/packages/dd-trace/src/platform/node/profiler.js\",\n\t\"./profiler.js\": \"../../node_modules/dd-trace/packages/dd-trace/src/platform/node/profiler.js\",\n\t\"./request\": \"../../node_modules/dd-trace/packages/dd-trace/src/platform/node/request.js\",\n\t\"./request.js\": \"../../node_modules/dd-trace/packages/dd-trace/src/platform/node/request.js\",\n\t\"./startup-log\": \"../../node_modules/dd-trace/packages/dd-trace/src/platform/node/startup-log.js\",\n\t\"./startup-log.js\": \"../../node_modules/dd-trace/packages/dd-trace/src/platform/node/startup-log.js\",\n\t\"./validate\": \"../../node_modules/dd-trace/packages/dd-trace/src/platform/node/validate.js\",\n\t\"./validate.js\": \"../../node_modules/dd-trace/packages/dd-trace/src/platform/node/validate.js\"\n};\n\n\nfunction webpackContext(req) {\n\tvar id = webpackContextResolve(req);\n\treturn __webpack_require__(id);\n}\nfunction webpackContextResolve(req) {\n\tif(!__webpack_require__.o(map, req)) {\n\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t}\n\treturn map[req];\n}\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = \"../../node_modules/dd-trace/packages/dd-trace/src/platform/node sync recursive ^.*\\\\/.*$\";","function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = function() { return []; };\nwebpackEmptyContext.resolve = webpackEmptyContext;\nmodule.exports = webpackEmptyContext;\nwebpackEmptyContext.id = \"../../node_modules/dd-trace/packages/dd-trace/src/platform/node sync recursive ^.*\\\\/package\\\\.json$\";","'use strict'\n\nconst http = require('http')\nconst https = require('https')\n\nlet agents\n\nmodule.exports = config => agents || (agents = {\n  httpAgent: new http.Agent({ keepAlive: true, lookup: config.lookup }),\n  httpsAgent: new https.Agent({ keepAlive: true, lookup: config.lookup })\n})\n","'use strict'\n\nconst { randomBytes } = require('crypto')\n\nmodule.exports = {\n  getRandomValues (typedArray) {\n    const size = typedArray.length * typedArray.BYTES_PER_ELEMENT\n    const buffer = randomBytes(size).buffer\n\n    typedArray.set(new typedArray.constructor(buffer))\n  }\n}\n","'use strict'\n\nconst dgram = require('dgram')\nconst lookup = require('dns').lookup // cache to avoid instrumentation\nconst log = require('../../log')\n\nconst MAX_BUFFER_SIZE = 1024 // limit from the agent\n\nclass Client {\n  constructor (options) {\n    options = options || {}\n\n    this._host = options.host || 'localhost'\n    this._port = options.port || 8125\n    this._prefix = options.prefix || ''\n    this._tags = options.tags || []\n    this._queue = []\n    this._buffer = ''\n    this._offset = 0\n    this._udp4 = this._socket('udp4')\n    this._udp6 = this._socket('udp6')\n  }\n\n  gauge (stat, value, tags) {\n    this._add(stat, value, 'g', tags)\n  }\n\n  increment (stat, value, tags) {\n    this._add(stat, value, 'c', tags)\n  }\n\n  flush () {\n    const queue = this._enqueue()\n\n    if (this._queue.length === 0) return\n\n    this._queue = []\n\n    lookup(this._host, (err, address, family) => {\n      if (err) return log.error(err)\n\n      queue.forEach(buffer => this._send(address, family, buffer))\n    })\n  }\n\n  _send (address, family, buffer) {\n    const socket = family === 6 ? this._udp6 : this._udp4\n\n    log.debug(`Sending to DogStatsD: ${buffer}`)\n\n    socket.send(buffer, 0, buffer.length, this._port, address)\n  }\n\n  _add (stat, value, type, tags) {\n    const message = `${this._prefix + stat}:${value}|${type}`\n\n    tags = tags ? this._tags.concat(tags) : this._tags\n\n    if (tags.length > 0) {\n      this._write(`${message}|#${tags.join(',')}\\n`)\n    } else {\n      this._write(`${message}\\n`)\n    }\n  }\n\n  _write (message) {\n    const offset = Buffer.byteLength(message)\n\n    if (this._offset + offset > MAX_BUFFER_SIZE) {\n      this._enqueue()\n    }\n\n    this._offset += offset\n    this._buffer += message\n  }\n\n  _enqueue () {\n    if (this._offset > 0) {\n      this._queue.push(Buffer.from(this._buffer))\n      this._buffer = ''\n      this._offset = 0\n    }\n\n    return this._queue\n  }\n\n  _socket (type) {\n    const socket = dgram.createSocket(type)\n\n    socket.on('error', () => {})\n    socket.unref()\n\n    return socket\n  }\n}\n\nmodule.exports = Client\n","'use strict'\n\nmodule.exports = name => process.env[name]\n","'use strict'\n\nconst AgentExporter = require('../../exporters/agent')\nconst LogExporter = require('../../exporters/log')\nconst env = require('./env')\nconst exporters = require('../../../../../ext/exporters')\n\nmodule.exports = name => {\n  const inAWSLambda = env('AWS_LAMBDA_FUNCTION_NAME') !== undefined\n\n  switch (name) {\n    case exporters.LOG:\n      return LogExporter\n    case exporters.AGENT:\n      return AgentExporter\n    default:\n      return inAWSLambda ? LogExporter : AgentExporter\n  }\n}\n","'use strict'\n\nconst os = require('os')\n\nmodule.exports = () => os.hostname()\n","'use strict'\n\nconst EventEmitter = require('events')\nconst crypto = require('./crypto')\nconst now = require('./now')\nconst env = require('./env')\nconst validate = require('./validate')\nconst request = require('./request')\nconst metrics = require('./metrics')\nconst plugins = require('../../plugins')\nconst hostname = require('./hostname')\nconst Loader = require('./loader')\nconst scopes = require('../../../../../ext/scopes')\nconst exporter = require('./exporter')\nconst profiler = require('./profiler')\nconst pkg = require('./pkg')\nconst startupLog = require('./startup-log')\nconst semver = require('semver')\n\nconst emitter = new EventEmitter()\n\nconst hasSupportedAsyncLocalStorage = semver.satisfies(process.versions.node, '>=14.5 || ^12.19.0')\n\nconst platform = {\n  _config: {},\n  name: () => 'nodejs',\n  version: () => process.version,\n  engine: () => process.jsEngine || 'v8',\n  crypto,\n  now,\n  env,\n  tags: () => ({}),\n  validate,\n  service: () => process.env['AWS_LAMBDA_FUNCTION_NAME'] || pkg.name,\n  appVersion: () => pkg.version,\n  request,\n  metrics,\n  plugins,\n  startupLog,\n  hostname,\n  on: emitter.on.bind(emitter),\n  off: emitter.removeListener.bind(emitter),\n  Loader,\n  getScope (scope) {\n    if (scope === scopes.ASYNC_RESOURCE) {\n      return require('../../scope/async_resource')\n    } else if (scope === scopes.ASYNC_LOCAL_STORAGE || (!scope && hasSupportedAsyncLocalStorage)) {\n      return require('../../scope/async_local_storage')\n    } else {\n      return require('../../scope/async_hooks')\n    }\n  },\n  exporter,\n  profiler () {\n    return profiler(this._config)\n  }\n}\n\nprocess.once('beforeExit', () => emitter.emit('exit'))\n\nmodule.exports = platform\n","'use strict'\n\nconst semver = require('semver')\nconst hook = require('require-in-the-middle')\nconst parse = require('module-details-from-path')\nconst path = require('path')\nconst uniq = require('lodash.uniq')\nconst log = require('../../log')\n\nconst pathSepExpr = new RegExp(`\\\\${path.sep}`, 'g')\n\nclass Loader {\n  constructor (instrumenter) {\n    this._instrumenter = instrumenter\n  }\n\n  reload (plugins) {\n    this._plugins = plugins\n\n    const instrumentations = Array.from(this._plugins.keys())\n      .reduce((prev, current) => prev.concat(current), [])\n\n    const instrumentedModules = uniq(instrumentations\n      .map(instrumentation => instrumentation.name))\n\n    this._names = new Set(instrumentations\n      .map(instrumentation => filename(instrumentation)))\n\n    hook(instrumentedModules, { internals: true }, this._hookModule.bind(this))\n  }\n\n  load (instrumentation, config) {\n    this._getModules(instrumentation).forEach(nodule => {\n      this._instrumenter.patch(instrumentation, nodule, config)\n    })\n  }\n\n  _getModules (instrumentation) {\n    const modules = []\n    const ids = Object.keys(require.cache)\n\n    let pkg\n\n    for (let i = 0, l = ids.length; i < l; i++) {\n      const id = ids[i].replace(pathSepExpr, '/')\n\n      if (!id.includes(`/node_modules/${instrumentation.name}/`)) continue\n\n      if (instrumentation.file) {\n        if (!id.endsWith(`/node_modules/${filename(instrumentation)}`)) continue\n\n        const basedir = getBasedir(ids[i])\n\n        pkg = require(`${basedir}/package.json`)\n      } else {\n        const basedir = getBasedir(ids[i])\n\n        pkg = require(`${basedir}/package.json`)\n\n        const mainFile = path.posix.normalize(pkg.main || 'index.js')\n        if (!id.endsWith(`/node_modules/${instrumentation.name}/${mainFile}`)) continue\n      }\n\n      if (!matchVersion(pkg.version, instrumentation.versions)) continue\n\n      modules.push(require.cache[ids[i]].exports)\n    }\n\n    return modules\n  }\n\n  _hookModule (moduleExports, moduleName, moduleBaseDir) {\n    moduleName = moduleName.replace(pathSepExpr, '/')\n\n    if (!this._names.has(moduleName)) {\n      return moduleExports\n    }\n\n    if (moduleBaseDir) {\n      moduleBaseDir = moduleBaseDir.replace(pathSepExpr, '/')\n    }\n\n    const moduleVersion = getVersion(moduleBaseDir)\n\n    Array.from(this._plugins.keys())\n      .filter(plugin => [].concat(plugin).some(instrumentation =>\n        filename(instrumentation) === moduleName && matchVersion(moduleVersion, instrumentation.versions)\n      ))\n      .forEach(plugin => this._validate(plugin, moduleName, moduleBaseDir, moduleVersion))\n\n    this._plugins\n      .forEach((meta, plugin) => {\n        try {\n          [].concat(plugin)\n            .filter(instrumentation => moduleName === filename(instrumentation))\n            .filter(instrumentation => matchVersion(moduleVersion, instrumentation.versions))\n            .forEach(instrumentation => {\n              const config = this._plugins.get(plugin).config\n\n              if (config.enabled !== false) {\n                moduleExports = this._instrumenter.patch(instrumentation, moduleExports, config) || moduleExports\n              }\n            })\n        } catch (e) {\n          log.error(e)\n          this._instrumenter.unload(plugin)\n          log.debug(`Error while trying to patch ${meta.name}. The plugin has been disabled.`)\n        }\n      })\n\n    return moduleExports\n  }\n\n  _validate (plugin, moduleName, moduleBaseDir, moduleVersion) {\n    const meta = this._plugins.get(plugin)\n    const instrumentations = [].concat(plugin)\n\n    for (let i = 0; i < instrumentations.length; i++) {\n      if (moduleName.indexOf(instrumentations[i].name) !== 0) continue\n      if (instrumentations[i].versions && !matchVersion(moduleVersion, instrumentations[i].versions)) continue\n      if (instrumentations[i].file && !exists(moduleBaseDir, instrumentations[i].file)) {\n        this._instrumenter.unload(plugin)\n        log.debug([\n          `Plugin \"${meta.name}\" requires \"${instrumentations[i].file}\" which was not found.`,\n          `The plugin was disabled.`\n        ].join(' '))\n        break\n      }\n    }\n  }\n}\n\nfunction getBasedir (id) {\n  return parse(id).basedir.replace(pathSepExpr, '/')\n}\n\nfunction matchVersion (version, ranges) {\n  return !version || (ranges && ranges.some(range => semver.satisfies(semver.coerce(version), range)))\n}\n\nfunction getVersion (moduleBaseDir) {\n  if (moduleBaseDir) {\n    const packageJSON = `${moduleBaseDir}/package.json`\n    return require(packageJSON).version\n  }\n}\n\nfunction filename (plugin) {\n  return [plugin.name, plugin.file].filter(val => val).join('/')\n}\n\nfunction exists (basedir, file) {\n  try {\n    require.resolve(`${basedir}/${file}`)\n    return true\n  } catch (e) {\n    return false\n  }\n}\n\nmodule.exports = Loader\n","'use strict'\n\n// TODO: capture every second and flush every 10 seconds\n\nconst v8 = require('v8')\nconst path = require('path')\nconst os = require('os')\nconst Client = require('./dogstatsd')\nconst log = require('../../log')\nconst Histogram = require('../../histogram')\n\nconst INTERVAL = 10 * 1000\n\nlet nativeMetrics = null\n\nlet metrics\nlet interval\nlet client\nlet time\nlet cpuUsage\nlet gauges\nlet counters\nlet histograms\n\nreset()\n\nmodule.exports = function () {\n  return metrics || (metrics = { // cache the metrics instance\n    start: (options) => {\n      const tags = []\n\n      Object.keys(this._config.tags)\n        .filter(key => typeof this._config.tags[key] === 'string')\n        .forEach(key => {\n          // https://docs.datadoghq.com/tagging/#defining-tags\n          const value = this._config.tags[key].replace(/[^a-z0-9_:./-]/ig, '_')\n\n          tags.push(`${key}:${value}`)\n        })\n\n      options = options || {}\n\n      try {\n        nativeMetrics = require('node-gyp-build')(path.join(__dirname, '..', '..', '..', '..', '..'))\n        nativeMetrics.start()\n      } catch (e) {\n        log.error(e)\n        nativeMetrics = null\n      }\n\n      client = new Client({\n        host: this._config.dogstatsd.hostname,\n        port: this._config.dogstatsd.port,\n        tags\n      })\n\n      time = process.hrtime()\n\n      if (nativeMetrics) {\n        interval = setInterval(() => {\n          captureCommonMetrics()\n          captureNativeMetrics()\n          client.flush()\n        }, INTERVAL)\n      } else {\n        cpuUsage = process.cpuUsage()\n\n        interval = setInterval(() => {\n          captureCommonMetrics()\n          captureCpuUsage()\n          captureHeapSpace()\n          client.flush()\n        }, INTERVAL)\n      }\n\n      interval.unref()\n    },\n\n    stop: () => {\n      if (nativeMetrics) {\n        nativeMetrics.stop()\n      }\n\n      clearInterval(interval)\n      reset()\n    },\n\n    track (span) {\n      if (nativeMetrics) {\n        const handle = nativeMetrics.track(span)\n\n        return {\n          finish: () => nativeMetrics.finish(handle)\n        }\n      }\n\n      return { finish: () => {} }\n    },\n\n    boolean (name, value, tag) {\n      metrics.gauge(name, value ? 1 : 0, tag)\n    },\n\n    histogram (name, value, tag) {\n      if (!client) return\n\n      histograms[name] = histograms[name] || new Map()\n\n      if (!histograms[name].has(tag)) {\n        histograms[name].set(tag, new Histogram())\n      }\n\n      histograms[name].get(tag).record(value)\n    },\n\n    count (name, count, tag, monotonic = false) {\n      if (!client) return\n      if (typeof tag === 'boolean') {\n        monotonic = tag\n        tag = undefined\n      }\n\n      const map = monotonic ? counters : gauges\n\n      map[name] = map[name] || new Map()\n\n      const value = map[name].get(tag) || 0\n\n      map[name].set(tag, value + count)\n    },\n\n    gauge (name, value, tag) {\n      if (!client) return\n\n      gauges[name] = gauges[name] || new Map()\n      gauges[name].set(tag, value)\n    },\n\n    increment (name, tag, monotonic) {\n      this.count(name, 1, tag, monotonic)\n    },\n\n    decrement (name, tag) {\n      this.count(name, -1, tag)\n    }\n  })\n}\n\nfunction reset () {\n  interval = null\n  client = null\n  time = null\n  cpuUsage = null\n  gauges = {}\n  counters = {}\n  histograms = {}\n}\n\nfunction captureCpuUsage () {\n  if (!process.cpuUsage) return\n\n  const elapsedTime = process.hrtime(time)\n  const elapsedUsage = process.cpuUsage(cpuUsage)\n\n  time = process.hrtime()\n  cpuUsage = process.cpuUsage()\n\n  const elapsedMs = elapsedTime[0] * 1000 + elapsedTime[1] / 1000000\n  const userPercent = 100 * elapsedUsage.user / 1000 / elapsedMs\n  const systemPercent = 100 * elapsedUsage.system / 1000 / elapsedMs\n  const totalPercent = userPercent + systemPercent\n\n  client.gauge('runtime.node.cpu.system', systemPercent.toFixed(2))\n  client.gauge('runtime.node.cpu.user', userPercent.toFixed(2))\n  client.gauge('runtime.node.cpu.total', totalPercent.toFixed(2))\n}\n\nfunction captureMemoryUsage () {\n  const stats = process.memoryUsage()\n\n  client.gauge('runtime.node.mem.heap_total', stats.heapTotal)\n  client.gauge('runtime.node.mem.heap_used', stats.heapUsed)\n  client.gauge('runtime.node.mem.rss', stats.rss)\n  client.gauge('runtime.node.mem.total', os.totalmem())\n  client.gauge('runtime.node.mem.free', os.freemem())\n\n  stats.external && client.gauge('runtime.node.mem.external', stats.external)\n}\n\nfunction captureProcess () {\n  client.gauge('runtime.node.process.uptime', Math.round(process.uptime()))\n}\n\nfunction captureHeapStats () {\n  const stats = v8.getHeapStatistics()\n\n  client.gauge('runtime.node.heap.total_heap_size', stats.total_heap_size)\n  client.gauge('runtime.node.heap.total_heap_size_executable', stats.total_heap_size_executable)\n  client.gauge('runtime.node.heap.total_physical_size', stats.total_physical_size)\n  client.gauge('runtime.node.heap.total_available_size', stats.total_available_size)\n  client.gauge('runtime.node.heap.heap_size_limit', stats.heap_size_limit)\n\n  stats.malloced_memory && client.gauge('runtime.node.heap.malloced_memory', stats.malloced_memory)\n  stats.peak_malloced_memory && client.gauge('runtime.node.heap.peak_malloced_memory', stats.peak_malloced_memory)\n}\n\nfunction captureHeapSpace () {\n  if (!v8.getHeapSpaceStatistics) return\n\n  const stats = v8.getHeapSpaceStatistics()\n\n  for (let i = 0, l = stats.length; i < l; i++) {\n    const tags = [`space:${stats[i].space_name}`]\n\n    client.gauge('runtime.node.heap.size.by.space', stats[i].space_size, tags)\n    client.gauge('runtime.node.heap.used_size.by.space', stats[i].space_used_size, tags)\n    client.gauge('runtime.node.heap.available_size.by.space', stats[i].space_available_size, tags)\n    client.gauge('runtime.node.heap.physical_size.by.space', stats[i].physical_space_size, tags)\n  }\n}\n\nfunction captureGauges () {\n  Object.keys(gauges).forEach(name => {\n    gauges[name].forEach((value, tag) => {\n      client.gauge(name, value, tag && [tag])\n    })\n  })\n}\n\nfunction captureCounters () {\n  Object.keys(counters).forEach(name => {\n    counters[name].forEach((value, tag) => {\n      client.increment(name, value, tag && [tag])\n    })\n  })\n\n  counters = {}\n}\n\nfunction captureHistograms () {\n  Object.keys(histograms).forEach(name => {\n    histograms[name].forEach((stats, tag) => {\n      histogram(name, stats, tag && [tag])\n      stats.reset()\n    })\n  })\n}\n\nfunction captureCommonMetrics () {\n  captureMemoryUsage()\n  captureProcess()\n  captureHeapStats()\n  captureGauges()\n  captureCounters()\n  captureHistograms()\n}\n\nfunction captureNativeMetrics () {\n  const stats = nativeMetrics.stats()\n  const spaces = stats.heap.spaces\n  const elapsedTime = process.hrtime(time)\n\n  time = process.hrtime()\n\n  const elapsedUs = elapsedTime[0] * 1e6 + elapsedTime[1] / 1e3\n  const userPercent = 100 * stats.cpu.user / elapsedUs\n  const systemPercent = 100 * stats.cpu.system / elapsedUs\n  const totalPercent = userPercent + systemPercent\n\n  client.gauge('runtime.node.cpu.system', systemPercent.toFixed(2))\n  client.gauge('runtime.node.cpu.user', userPercent.toFixed(2))\n  client.gauge('runtime.node.cpu.total', totalPercent.toFixed(2))\n\n  histogram('runtime.node.event_loop.delay', stats.eventLoop)\n\n  Object.keys(stats.gc).forEach(type => {\n    if (type === 'all') {\n      histogram('runtime.node.gc.pause', stats.gc[type])\n    } else {\n      histogram('runtime.node.gc.pause.by.type', stats.gc[type], [`gc_type:${type}`])\n    }\n  })\n\n  client.gauge('runtime.node.spans.finished', stats.spans.total.finished)\n  client.gauge('runtime.node.spans.unfinished', stats.spans.total.unfinished)\n\n  for (let i = 0, l = spaces.length; i < l; i++) {\n    const tags = [`heap_space:${spaces[i].space_name}`]\n\n    client.gauge('runtime.node.heap.size.by.space', spaces[i].space_size, tags)\n    client.gauge('runtime.node.heap.used_size.by.space', spaces[i].space_used_size, tags)\n    client.gauge('runtime.node.heap.available_size.by.space', spaces[i].space_available_size, tags)\n    client.gauge('runtime.node.heap.physical_size.by.space', spaces[i].physical_space_size, tags)\n  }\n\n  if (stats.spans.operations) {\n    const operations = stats.spans.operations\n\n    Object.keys(operations.finished).forEach(name => {\n      client.gauge('runtime.node.spans.finished.by.name', operations.finished[name], [`span_name:${name}`])\n    })\n\n    Object.keys(operations.unfinished).forEach(name => {\n      client.gauge('runtime.node.spans.unfinished.by.name', operations.unfinished[name], [`span_name:${name}`])\n    })\n  }\n}\n\nfunction histogram (name, stats, tags) {\n  tags = [].concat(tags)\n\n  client.gauge(`${name}.min`, stats.min, tags)\n  client.gauge(`${name}.max`, stats.max, tags)\n  client.increment(`${name}.sum`, stats.sum, tags)\n  client.increment(`${name}.total`, stats.sum, tags)\n  client.gauge(`${name}.avg`, stats.avg, tags)\n  client.increment(`${name}.count`, stats.count, tags)\n  client.gauge(`${name}.median`, stats.median, tags)\n  client.gauge(`${name}.95percentile`, stats.p95, tags)\n}\n","'use strict'\n\nmodule.exports = require('performance-now')\n","'use strict'\n\nconst path = require('path')\nconst readPkgUp = require('read-pkg-up')\n\nfunction findRoot () {\n  return require.main && require.main.filename ? path.dirname(require.main.filename) : process.cwd()\n}\n\nfunction findPkg () {\n  const cwd = findRoot()\n  const up = readPkgUp.sync({ cwd })\n\n  return up && up.pkg ? up.pkg : {}\n}\n\nmodule.exports = findPkg()\n","'use strict'\n\nconst log = require('../../log')\nconst { profiler, AgentExporter, FileExporter } = require('../../profiling')\n\nlet cached\n\nmodule.exports = config => cached || (cached = {\n  start: () => {\n    const { service, version, env } = config\n    const { enabled, sourceMap, exporters } = config.profiling\n    const logger = {\n      debug: (message) => log.debug(message),\n      info: (message) => log.info(message),\n      warn: (message) => log.warn(message),\n      error: (message) => log.error(message)\n    }\n\n    profiler.start({\n      enabled,\n      service,\n      version,\n      env,\n      logger,\n      sourceMap,\n      exporters: getExporters(exporters, config)\n    })\n  },\n\n  stop: () => {\n    profiler.stop()\n  }\n})\n\nfunction getExporters (names, { url, hostname, port }) {\n  const exporters = []\n\n  for (const name of names.split(',')) {\n    switch (name) {\n      case 'agent':\n        exporters.push(new AgentExporter({ url, hostname, port }))\n        break\n      case 'file':\n        exporters.push(new FileExporter())\n        break\n    }\n  }\n\n  return exporters\n}\n","'use strict'\n\nconst http = require('http')\nconst https = require('https')\nconst agents = require('./agents')\nconst containerInfo = require('container-info').sync() || {}\n\nconst containerId = containerInfo.containerId\n\nfunction request (options, callback) {\n  const platform = this\n\n  options = Object.assign({\n    headers: {},\n    data: [],\n    timeout: 2000\n  }, options)\n\n  const data = [].concat(options.data)\n  const isSecure = options.protocol === 'https:'\n  const { httpAgent, httpsAgent } = agents(platform._config)\n  const client = isSecure ? https : http\n  const agent = isSecure ? httpsAgent : httpAgent\n\n  options.agent = agent\n  options.headers['Content-Length'] = byteLength(data)\n\n  if (containerId) {\n    options.headers['Datadog-Container-ID'] = containerId\n  }\n\n  const req = client.request(options, res => {\n    let data = ''\n\n    res.setTimeout(options.timeout)\n\n    res.on('data', chunk => { data += chunk })\n    res.on('end', () => {\n      if (res.statusCode >= 200 && res.statusCode <= 299) {\n        callback(null, data, res.statusCode)\n      } else {\n        const error = new Error(`Error from the agent: ${res.statusCode} ${http.STATUS_CODES[res.statusCode]}`)\n        error.status = res.statusCode\n\n        callback(error, null, res.statusCode)\n      }\n    })\n  })\n\n  req.setTimeout(options.timeout, req.abort)\n  req.on('error', e => callback(new Error(`Network error trying to reach the agent: ${e.message}`)))\n\n  data.forEach(buffer => req.write(buffer))\n\n  req.end()\n}\n\nfunction byteLength (data) {\n  return data.length > 0 ? data.reduce((prev, next) => prev + next.length, 0) : 0\n}\n\nmodule.exports = request\n","'use strict'\n\nconst mainLogger = require('../../log')\nconst path = require('path')\nconst os = require('os')\nconst { inspect } = require('util')\nconst tracerVersion = require('../../../lib/version')\n\nconst logger = Object.create(mainLogger)\nlogger._enabled = true\n\nlet config\nlet instrumenter\nlet samplingRules = []\n\nlet alreadyRan = false\n\nfunction getIntegrationsAndAnalytics () {\n  const integrations = new Set()\n  const extras = {}\n  for (const plugin of instrumenter._instrumented.keys()) {\n    if (plugin.versions) {\n      try {\n        const version = require(path.join(plugin.name, 'package.json')).version\n        integrations.add(`${plugin.name}@${version}`)\n      } catch (e) {\n        integrations.add(plugin.name)\n      }\n    } else {\n      integrations.add(plugin.name)\n    }\n\n    const pluginData = instrumenter._plugins.get(plugin.name)\n    if (pluginData) {\n      const pluginConfig = pluginData.config\n      if (pluginConfig && pluginConfig.analytics) {\n        extras[`integration_${plugin.name}_analytics_enabled`] = true\n        if (typeof pluginConfig.analytics !== 'boolean') {\n          extras[`integration_${plugin.name}_sample_rate`] = pluginConfig.analytics\n        }\n      }\n    }\n  }\n  extras.integrations_loaded = Array.from(integrations)\n  return extras\n}\n\nfunction startupLog ({ agentError } = {}) {\n  if (!config || !instrumenter) {\n    return\n  }\n\n  if (alreadyRan) {\n    return\n  }\n\n  alreadyRan = true\n\n  if (!config.startupLogs) {\n    return\n  }\n\n  const url = config.url || `http://${config.hostname || 'localhost'}:${config.port}`\n\n  const out = {\n    [inspect.custom] () {\n      return String(this)\n    },\n    toString () {\n      return JSON.stringify(this)\n    }\n  }\n\n  out.date = new Date().toISOString()\n  out.os_name = os.type()\n  out.os_version = os.release()\n  out.architecture = os.arch()\n  out.version = tracerVersion\n  out.lang = 'nodejs'\n  out.lang_version = process.versions.node\n  out.env = config.env\n  out.enabled = config.enabled\n  out.scope_manager = config.scope\n  out.service = config.service\n  out.agent_url = url\n  if (agentError) {\n    out.agent_error = agentError.message\n  }\n  out.debug = !!config.debug\n  out.analytics_enabled = !!config.analytics\n  out.sample_rate = config.sampleRate\n  out.sampling_rules = samplingRules\n  out.tags = config.tags\n  if (config.tags && config.tags.version) {\n    out.dd_version = config.tags.version\n  }\n\n  out.log_injection_enabled = !!config.logInjection\n  out.runtime_metrics_enabled = !!config.runtimeMetrics\n  Object.assign(out, getIntegrationsAndAnalytics())\n\n  // // This next bunch is for features supported by other tracers, but not this\n  // // one. They may be implemented in the future.\n\n  // out.enabled_cli\n  // out.sampling_rules_error\n  // out.integration_XXX_analytics_enabled\n  // out.integration_XXX_sample_rate\n  // out.service_mapping\n  // out.service_mapping_error\n\n  logger.info('DATADOG TRACER CONFIGURATION - ' + out)\n  if (agentError) {\n    logger.warn('DATADOG TRACER DIAGNOSTIC - Agent Error: ' + agentError.message)\n  }\n\n  config = undefined\n  instrumenter = undefined\n  samplingRules = undefined\n}\n\nfunction setStartupLogConfig (aConfig) {\n  config = aConfig\n}\n\nfunction setStartupLogInstrumenter (theInstrumenter) {\n  instrumenter = theInstrumenter\n}\n\nfunction setSamplingRules (theRules) {\n  samplingRules = theRules\n}\n\nmodule.exports = {\n  startupLog,\n  setStartupLogConfig,\n  setStartupLogInstrumenter,\n  setSamplingRules\n}\n","'use strict'\n\nconst semver = require('semver')\n\nconst SUPPORTED_VERSIONS = '>=8'\n\nfunction validate () {\n  if (!semver.satisfies(process.versions.node, SUPPORTED_VERSIONS)) {\n    throw new Error([\n      `Node ${process.versions.node} is not supported.`,\n      `Only versions of Node matching \"${SUPPORTED_VERSIONS}\" are supported.`,\n      `Tracing has been disabled.`\n    ].join(' '))\n  }\n}\n\nmodule.exports = validate\n","'use strict'\n\nmodule.exports = {\n  'amqp10': require('../../../datadog-plugin-amqp10/src'),\n  'amqplib': require('../../../datadog-plugin-amqplib/src'),\n  'aws-sdk': require('../../../datadog-plugin-aws-sdk/src'),\n  'bluebird': require('../../../datadog-plugin-bluebird/src'),\n  'bunyan': require('../../../datadog-plugin-bunyan/src'),\n  'cassandra-driver': require('../../../datadog-plugin-cassandra-driver/src'),\n  'connect': require('../../../datadog-plugin-connect/src'),\n  'couchbase': require('../../../datadog-plugin-couchbase/src'),\n  'dns': require('../../../datadog-plugin-dns/src'),\n  'elasticsearch': require('../../../datadog-plugin-elasticsearch/src'),\n  'express': require('../../../datadog-plugin-express/src'),\n  'fastify': require('../../../datadog-plugin-fastify/src'),\n  'fs': require('../../../datadog-plugin-fs/src'),\n  'generic-pool': require('../../../datadog-plugin-generic-pool/src'),\n  'google-cloud-pubsub': require('../../../datadog-plugin-google-cloud-pubsub/src'),\n  'graphql': require('../../../datadog-plugin-graphql/src'),\n  'grpc': require('../../../datadog-plugin-grpc/src'),\n  'hapi': require('../../../datadog-plugin-hapi/src'),\n  'http': require('../../../datadog-plugin-http/src'),\n  'http2': require('../../../datadog-plugin-http2/src'),\n  'ioredis': require('../../../datadog-plugin-ioredis/src'),\n  'knex': require('../../../datadog-plugin-knex/src'),\n  'koa': require('../../../datadog-plugin-koa/src'),\n  'limitd-client': require('../../../datadog-plugin-limitd-client/src'),\n  'memcached': require('../../../datadog-plugin-memcached/src'),\n  'microgateway-core': require('../../../datadog-plugin-microgateway-core/src'),\n  'mongodb-core': require('../../../datadog-plugin-mongodb-core/src'),\n  'mongoose': require('../../../datadog-plugin-mongoose/src'),\n  'mysql': require('../../../datadog-plugin-mysql/src'),\n  'mysql2': require('../../../datadog-plugin-mysql2/src'),\n  'net': require('../../../datadog-plugin-net/src'),\n  'paperplane': require('../../../datadog-plugin-paperplane/src'),\n  'pg': require('../../../datadog-plugin-pg/src'),\n  'pino': require('../../../datadog-plugin-pino/src'),\n  'promise': require('../../../datadog-plugin-promise/src'),\n  'promise-js': require('../../../datadog-plugin-promise-js/src'),\n  'q': require('../../../datadog-plugin-q/src'),\n  'redis': require('../../../datadog-plugin-redis/src'),\n  'restify': require('../../../datadog-plugin-restify/src'),\n  'rhea': require('../../../datadog-plugin-rhea/src'),\n  'router': require('../../../datadog-plugin-router/src'),\n  'tedious': require('../../../datadog-plugin-tedious/src'),\n  'when': require('../../../datadog-plugin-when/src'),\n  'winston': require('../../../datadog-plugin-winston/src')\n}\n","'use strict'\n\nmodule.exports = {\n  createWrapThen (tracer, config) {\n    return function wrapThen (then) {\n      return function thenWithTrace (onFulfilled, onRejected, onProgress) {\n        arguments[0] = wrapCallback(tracer, onFulfilled)\n        arguments[1] = wrapCallback(tracer, onRejected)\n\n        // not standard but sometimes supported\n        if (onProgress) {\n          arguments[2] = wrapCallback(tracer, onProgress)\n        }\n\n        return then.apply(this, arguments)\n      }\n    }\n  }\n}\n\nfunction wrapCallback (tracer, callback) {\n  if (typeof callback !== 'function') return callback\n\n  const span = tracer.scope().active()\n\n  return function () {\n    return tracer.scope().activate(span, () => {\n      return callback.apply(this, arguments)\n    })\n  }\n}\n","'use strict'\n\nconst analyticsSampler = require('../../analytics_sampler')\nconst urlFilter = require('../util/urlfilter')\nconst tx = require('./tx')\n\nconst redis = {\n  // Ensure the configuration has the correct structure and defaults.\n  normalizeConfig (config) {\n    const filter = urlFilter.getFilter(config)\n\n    return Object.assign({}, config, {\n      filter\n    })\n  },\n\n  // Start a span for a Redis command.\n  instrument (tracer, config, db, command, args) {\n    const childOf = tracer.scope().active()\n    const span = tracer.startSpan('redis.command', {\n      childOf,\n      tags: {\n        'span.kind': 'client',\n        'resource.name': command,\n        'span.type': 'redis',\n        'db.type': 'redis',\n        'db.name': db || '0',\n        'out.host': '127.0.0.1',\n        'out.port': String(6379),\n        'redis.raw_command': formatCommand(command, args)\n      }\n    })\n\n    span.setTag('service.name', config.service || `${span.context()._tags['service.name']}-redis`)\n\n    analyticsSampler.sample(span, config.analytics)\n\n    return span\n  }\n}\n\nfunction formatCommand (command, args) {\n  command = command.toUpperCase()\n\n  if (!args) return command\n\n  for (let i = 0, l = args.length; i < l; i++) {\n    if (typeof args[i] === 'function') continue\n\n    command = `${command} ${formatArg(args[i])}`\n\n    if (command.length > 1000) return trim(command, 1000)\n  }\n\n  return command\n}\n\nfunction formatArg (arg) {\n  switch (typeof arg) {\n    case 'string':\n    case 'number':\n      return trim(String(arg), 100)\n    default:\n      return '?'\n  }\n}\n\nfunction trim (str, maxlen) {\n  if (str.length > maxlen) {\n    str = str.substr(0, maxlen - 3) + '...'\n  }\n\n  return str\n}\n\nmodule.exports = Object.assign({}, tx, redis)\n","'use strict'\n\nconst tx = {\n  // Set the outgoing host.\n  setHost (span, hostname, port) {\n    hostname && span.setTag('out.host', hostname)\n    port && span.setTag('out.port', port)\n  },\n\n  // Wrap a promise or a callback to also finish the span.\n  wrap (span, done) {\n    if (typeof done === 'function' || !done) {\n      return wrapCallback(span, done)\n    } else if (isPromise(done)) {\n      return wrapPromise(span, done)\n    }\n  }\n}\n\nfunction wrapCallback (span, callback) {\n  const scope = span.tracer().scope()\n  const previous = scope.active()\n\n  return function (err) {\n    finish(span, err)\n\n    if (callback) {\n      return scope.activate(previous, () => callback.apply(this, arguments))\n    }\n  }\n}\n\nfunction wrapPromise (span, promise) {\n  promise.then(\n    () => finish(span),\n    err => finish(span, err)\n  )\n\n  return promise\n}\n\nfunction finish (span, error) {\n  if (error) {\n    span.addTags({\n      'error.type': error.name,\n      'error.msg': error.message,\n      'error.stack': error.stack\n    })\n  }\n\n  span.finish()\n}\n\nfunction isPromise (obj) {\n  return isObject(obj) && typeof obj.then === 'function'\n}\n\nfunction isObject (obj) {\n  return typeof obj === 'object' && obj !== null\n}\n\nmodule.exports = tx\n","'use strict'\n\nconst log = require('../../log')\n\nconst urlFilter = {\n  getFilter (config) {\n    if (typeof config.filter === 'function') {\n      return config.filter\n    } else if (config.hasOwnProperty('filter')) {\n      log.error('Expected `filter` to be a function. Overriding filter property to default.')\n    }\n\n    const whitelist = config.whitelist || /.*/\n    const blacklist = config.blacklist || []\n\n    return uri => {\n      const whitelisted = applyFilter(whitelist, uri)\n      const blacklisted = applyFilter(blacklist, uri)\n      return whitelisted && !blacklisted\n    }\n\n    function applyFilter (filter, uri) {\n      if (typeof filter === 'function') {\n        return filter(uri)\n      } else if (filter instanceof RegExp) {\n        return filter.test(uri)\n      } else if (filter instanceof Array) {\n        return filter.some(filter => applyFilter(filter, uri))\n      }\n\n      return filter === uri\n    }\n  }\n}\n\nmodule.exports = urlFilter\n","'use strict'\n\nconst uniq = require('lodash.uniq')\nconst analyticsSampler = require('../../analytics_sampler')\nconst FORMAT_HTTP_HEADERS = require('opentracing').FORMAT_HTTP_HEADERS\nconst log = require('../../log')\nconst tags = require('../../../../../ext/tags')\nconst types = require('../../../../../ext/types')\nconst kinds = require('../../../../../ext/kinds')\nconst urlFilter = require('./urlfilter')\n\nconst WEB = types.WEB\nconst SERVER = kinds.SERVER\nconst RESOURCE_NAME = tags.RESOURCE_NAME\nconst SERVICE_NAME = tags.SERVICE_NAME\nconst SPAN_TYPE = tags.SPAN_TYPE\nconst SPAN_KIND = tags.SPAN_KIND\nconst ERROR = tags.ERROR\nconst HTTP_METHOD = tags.HTTP_METHOD\nconst HTTP_URL = tags.HTTP_URL\nconst HTTP_STATUS_CODE = tags.HTTP_STATUS_CODE\nconst HTTP_ROUTE = tags.HTTP_ROUTE\nconst HTTP_REQUEST_HEADERS = tags.HTTP_REQUEST_HEADERS\nconst HTTP_RESPONSE_HEADERS = tags.HTTP_RESPONSE_HEADERS\n\nconst HTTP2_HEADER_AUTHORITY = ':authority'\nconst HTTP2_HEADER_SCHEME = ':scheme'\nconst HTTP2_HEADER_PATH = ':path'\n\nconst web = {\n  // Ensure the configuration has the correct structure and defaults.\n  normalizeConfig (config) {\n    config = config.server || config\n\n    const headers = getHeadersToRecord(config)\n    const validateStatus = getStatusValidator(config)\n    const hooks = getHooks(config)\n    const filter = urlFilter.getFilter(config)\n    const middleware = getMiddlewareSetting(config)\n\n    return Object.assign({}, config, {\n      headers,\n      validateStatus,\n      hooks,\n      filter,\n      middleware\n    })\n  },\n\n  // Start a span and activate a scope for a request.\n  instrument (tracer, config, req, res, name, callback) {\n    this.patch(req)\n\n    const span = startSpan(tracer, config, req, res, name)\n\n    // TODO: replace this with a REFERENCE_NOOP after we split http/express/etc\n    if (!config.filter(req.url)) {\n      span.context()._traceFlags.sampled = false\n    }\n\n    if (config.service) {\n      span.setTag(SERVICE_NAME, config.service)\n    }\n\n    analyticsSampler.sample(span, config.analytics, true)\n\n    if (!req._datadog.instrumented) {\n      wrapEnd(req)\n      wrapEvents(req)\n\n      req._datadog.instrumented = true\n    }\n\n    return callback && tracer.scope().activate(span, () => callback(span))\n  },\n\n  // Reactivate the request scope in case it was changed by a middleware.\n  reactivate (req, fn) {\n    return reactivate(req, fn)\n  },\n\n  // Add a route segment that will be used for the resource name.\n  enterRoute (req, path) {\n    if (typeof path === 'string') {\n      req._datadog.paths.push(path)\n    }\n  },\n\n  // Remove the current route segment.\n  exitRoute (req) {\n    req._datadog.paths.pop()\n  },\n\n  // Start a new middleware span and activate a new scope with the span.\n  wrapMiddleware (req, middleware, name, fn) {\n    if (!this.active(req)) return fn()\n\n    const tracer = req._datadog.tracer\n    const childOf = this.active(req)\n\n    if (req._datadog.config.middleware === false) return this.bindAndWrapMiddlewareErrors(fn, req, tracer, childOf)\n\n    const span = tracer.startSpan(name, { childOf })\n\n    span.addTags({\n      [RESOURCE_NAME]: middleware._name || middleware.name || '<anonymous>'\n    })\n\n    req._datadog.middleware.push(span)\n\n    return tracer.scope().activate(span, fn)\n  },\n\n  // catch errors and apply to active span\n  bindAndWrapMiddlewareErrors (fn, req, tracer, activeSpan) {\n    try {\n      return tracer.scope().bind(fn, activeSpan).apply(this, arguments)\n    } catch (e) {\n      web.addError(req, e) // TODO: remove when error formatting is moved to Span\n      throw e\n    }\n  },\n\n  // Finish the active middleware span.\n  finish (req, error) {\n    if (!this.active(req)) return\n\n    const span = req._datadog.middleware.pop()\n\n    if (span) {\n      if (error) {\n        span.addTags({\n          'error.type': error.name,\n          'error.msg': error.message,\n          'error.stack': error.stack\n        })\n      }\n\n      span.finish()\n    }\n  },\n\n  // Register a callback to run before res.end() is called.\n  beforeEnd (req, callback) {\n    req._datadog.beforeEnd.push(callback)\n  },\n\n  // Prepare the request for instrumentation.\n  patch (req) {\n    if (req._datadog) return\n\n    if (req.stream && req.stream._datadog) {\n      req._datadog = req.stream._datadog\n      return\n    }\n\n    req._datadog = {\n      span: null,\n      paths: [],\n      middleware: [],\n      beforeEnd: [],\n      config: {}\n    }\n  },\n\n  // Return the request root span.\n  root (req) {\n    return req._datadog ? req._datadog.span : null\n  },\n\n  // Return the active span.\n  active (req) {\n    if (!req._datadog) return null\n    if (req._datadog.middleware.length === 0) return req._datadog.span || null\n\n    return req._datadog.middleware.slice(-1)[0]\n  },\n\n  // Extract the parent span from the headers and start a new span as its child\n  startChildSpan (tracer, name, headers) {\n    const childOf = tracer.extract(FORMAT_HTTP_HEADERS, headers)\n    const span = tracer.startSpan(name, { childOf })\n\n    return span\n  },\n\n  // Validate a request's status code and then add error tags if necessary\n  addStatusError (req, statusCode) {\n    const span = req._datadog.span\n    const error = req._datadog.error\n\n    if (!req._datadog.config.validateStatus(statusCode)) {\n      span.setTag(ERROR, error || true)\n    }\n  },\n\n  // Add an error to the request\n  addError (req, error) {\n    if (error instanceof Error) {\n      req._datadog.error = req._datadog.error || error\n    }\n  }\n}\n\nfunction startSpan (tracer, config, req, res, name) {\n  req._datadog.config = config\n\n  let span\n\n  if (req._datadog.span) {\n    req._datadog.span.context()._name = name\n    span = req._datadog.span\n  } else {\n    span = web.startChildSpan(tracer, name, req.headers)\n  }\n\n  configureDatadogObject(tracer, span, req, res)\n\n  return span\n}\n\nfunction configureDatadogObject (tracer, span, req, res) {\n  const ddObj = req._datadog\n  ddObj.tracer = tracer\n  ddObj.span = span\n  ddObj.res = res\n}\n\nfunction finish (req, res) {\n  if (req._datadog.finished && !req.stream) return\n\n  addRequestTags(req)\n  addResponseTags(req)\n\n  req._datadog.config.hooks.request(req._datadog.span, req, res)\n  addResourceTag(req)\n\n  req._datadog.span.finish()\n  req._datadog.finished = true\n}\n\nfunction finishMiddleware (req, res) {\n  if (req._datadog.finished) return\n\n  let span\n\n  while ((span = req._datadog.middleware.pop())) {\n    span.finish()\n  }\n}\n\nfunction wrapEnd (req) {\n  const res = req._datadog.res\n  const end = res.end\n\n  res.writeHead = wrapWriteHead(req)\n\n  res._datadog_end = function () {\n    for (const beforeEnd of req._datadog.beforeEnd) {\n      beforeEnd()\n    }\n\n    finishMiddleware(req, res)\n\n    const returnValue = end.apply(res, arguments)\n\n    finish(req, res)\n\n    return returnValue\n  }\n\n  res._datadog_req = req\n\n  if (!res._datadog_instrumented) {\n    const target = Reflect.getPrototypeOf(res)\n    Object.defineProperty(target, 'end', {\n      configurable: true,\n      get () {\n        return this._datadog_end || end\n      },\n      set (value) {\n        const req = this._datadog_req\n        if (req && req._datadog) {\n          const scope = req._datadog.tracer.scope()\n          this._datadog_end = scope.bind(value, req._datadog.span)\n        } else {\n          this._datadog_end = value\n        }\n      }\n    })\n    target._datadog_instrumented = true\n  }\n}\n\nfunction wrapWriteHead (req) {\n  const res = req._datadog.res\n  const writeHead = res.writeHead\n\n  return function (statusCode, statusMessage, headers) {\n    headers = typeof statusMessage === 'string' ? headers : statusMessage\n    headers = Object.assign(res.getHeaders(), headers)\n\n    if (req.method.toLowerCase() === 'options' && isOriginAllowed(req, headers)) {\n      addAllowHeaders(req, headers)\n    }\n\n    return writeHead.apply(this, arguments)\n  }\n}\n\nfunction addAllowHeaders (req, headers) {\n  const res = req._datadog.res\n  const allowHeaders = splitHeader(headers['access-control-allow-headers'])\n  const requestHeaders = splitHeader(req.headers['access-control-request-headers'])\n  const contextHeaders = [\n    'x-datadog-parent-id',\n    'x-datadog-sampled',\n    'x-datadog-sampling-priority',\n    'x-datadog-trace-id'\n  ]\n\n  for (const header of contextHeaders) {\n    if (~requestHeaders.indexOf(header)) {\n      allowHeaders.push(header)\n    }\n  }\n\n  if (allowHeaders.length > 0) {\n    res.setHeader('access-control-allow-headers', uniq(allowHeaders).join(','))\n  }\n}\n\nfunction isOriginAllowed (req, headers) {\n  const origin = req.headers['origin']\n  const allowOrigin = headers['access-control-allow-origin']\n\n  return origin && (allowOrigin === '*' || allowOrigin === origin)\n}\n\nfunction splitHeader (str) {\n  return typeof str === 'string' ? str.split(/\\s*,\\s*/) : []\n}\n\nfunction wrapEvents (req) {\n  const scope = req._datadog.tracer.scope()\n  const res = req._datadog.res\n\n  scope.bind(res, req._datadog.span)\n}\n\nfunction reactivate (req, fn) {\n  return req._datadog\n    ? req._datadog.tracer.scope().activate(req._datadog.span, fn)\n    : fn()\n}\n\nfunction addRequestTags (req) {\n  const url = extractURL(req)\n  const span = req._datadog.span\n\n  span.addTags({\n    [HTTP_URL]: url.split('?')[0],\n    [HTTP_METHOD]: req.method,\n    [SPAN_KIND]: SERVER,\n    [SPAN_TYPE]: WEB\n  })\n\n  addHeaders(req)\n}\n\nfunction addResponseTags (req) {\n  const span = req._datadog.span\n  const res = req._datadog.res\n\n  if (req._datadog.paths.length > 0) {\n    span.setTag(HTTP_ROUTE, req._datadog.paths.join(''))\n  }\n\n  span.addTags({\n    [HTTP_STATUS_CODE]: res.statusCode\n  })\n\n  web.addStatusError(req, res.statusCode)\n}\n\nfunction addResourceTag (req) {\n  const span = req._datadog.span\n  const tags = span.context()._tags\n\n  if (tags['resource.name']) return\n\n  const resource = [req.method, tags[HTTP_ROUTE]]\n    .filter(val => val)\n    .join(' ')\n\n  span.setTag(RESOURCE_NAME, resource)\n}\n\nfunction addHeaders (req) {\n  const span = req._datadog.span\n\n  req._datadog.config.headers.forEach(key => {\n    const reqHeader = req.headers[key]\n    const resHeader = req._datadog.res.getHeader(key)\n\n    if (reqHeader) {\n      span.setTag(`${HTTP_REQUEST_HEADERS}.${key}`, reqHeader)\n    }\n\n    if (resHeader) {\n      span.setTag(`${HTTP_RESPONSE_HEADERS}.${key}`, resHeader)\n    }\n  })\n}\n\nfunction extractURL (req) {\n  const headers = req.headers\n\n  if (req.stream) {\n    return `${headers[HTTP2_HEADER_SCHEME]}://${headers[HTTP2_HEADER_AUTHORITY]}${headers[HTTP2_HEADER_PATH]}`\n  } else {\n    const protocol = req.connection.encrypted ? 'https' : 'http'\n    return `${protocol}://${req.headers['host']}${req.originalUrl || req.url}`\n  }\n}\n\nfunction getHeadersToRecord (config) {\n  if (Array.isArray(config.headers)) {\n    try {\n      return config.headers.map(key => key.toLowerCase())\n    } catch (err) {\n      log.error(err)\n    }\n  } else if (config.hasOwnProperty('headers')) {\n    log.error('Expected `headers` to be an array of strings.')\n  }\n  return []\n}\n\nfunction getStatusValidator (config) {\n  if (typeof config.validateStatus === 'function') {\n    return config.validateStatus\n  } else if (config.hasOwnProperty('validateStatus')) {\n    log.error('Expected `validateStatus` to be a function.')\n  }\n  return code => code < 500\n}\n\nfunction getHooks (config) {\n  const noop = () => {}\n  const request = (config.hooks && config.hooks.request) || noop\n\n  return { request }\n}\n\nfunction getMiddlewareSetting (config) {\n  if (config && typeof config.middleware === 'boolean') {\n    return config.middleware\n  } else if (config && config.hasOwnProperty('middleware')) {\n    log.error('Expected `middleware` to be a boolean.')\n  }\n\n  return true\n}\n\nmodule.exports = web\n","'use strict'\n\nconst RateLimiter = require('./rate_limiter')\nconst Sampler = require('./sampler')\nconst ext = require('../../../ext')\nconst { setSamplingRules } = require('./platform').startupLog\n\nconst {\n  SAMPLING_RULE_DECISION,\n  SAMPLING_LIMIT_DECISION,\n  SAMPLING_AGENT_DECISION\n} = require('./constants')\n\nconst SERVICE_NAME = ext.tags.SERVICE_NAME\nconst SAMPLING_PRIORITY = ext.tags.SAMPLING_PRIORITY\nconst MANUAL_KEEP = ext.tags.MANUAL_KEEP\nconst MANUAL_DROP = ext.tags.MANUAL_DROP\nconst USER_REJECT = ext.priority.USER_REJECT\nconst AUTO_REJECT = ext.priority.AUTO_REJECT\nconst AUTO_KEEP = ext.priority.AUTO_KEEP\nconst USER_KEEP = ext.priority.USER_KEEP\nconst DEFAULT_KEY = 'service:,env:'\n\nclass PrioritySampler {\n  constructor (env, { sampleRate, rateLimit = 100, rules = [] } = {}) {\n    this._env = env\n    this._rules = this._normalizeRules(rules, sampleRate)\n    this._limiter = new RateLimiter(rateLimit)\n\n    setSamplingRules(this._rules)\n\n    this.update({})\n  }\n\n  isSampled (span) {\n    const context = this._getContext(span)\n    const rule = this._findRule(context)\n\n    return rule\n      ? this._isSampledByRule(context, rule) && this._isSampledByRateLimit(context)\n      : this._isSampledByAgent(context)\n  }\n\n  sample (span) {\n    if (!span) return\n\n    const context = this._getContext(span)\n\n    if (context._sampling.priority !== undefined) return\n\n    const tag = this._getPriority(context._tags)\n\n    if (this.validate(tag)) {\n      context._sampling.priority = tag\n      return\n    }\n\n    context._sampling.priority = this.isSampled(span) ? AUTO_KEEP : AUTO_REJECT\n  }\n\n  update (rates) {\n    const samplers = {}\n\n    for (const key in rates) {\n      const rate = rates[key]\n      const sampler = new Sampler(rate)\n\n      samplers[key] = sampler\n    }\n\n    samplers[DEFAULT_KEY] = samplers[DEFAULT_KEY] || new Sampler(AUTO_KEEP)\n\n    this._samplers = samplers\n  }\n\n  validate (samplingPriority) {\n    switch (samplingPriority) {\n      case USER_REJECT:\n      case USER_KEEP:\n      case AUTO_REJECT:\n      case AUTO_KEEP:\n        return true\n      default:\n        return false\n    }\n  }\n\n  _getContext (span) {\n    return typeof span.context === 'function' ? span.context() : span\n  }\n\n  _getPriority (tags) {\n    if (tags.hasOwnProperty(MANUAL_KEEP) && tags[MANUAL_KEEP] !== false) {\n      return USER_KEEP\n    } else if (tags.hasOwnProperty(MANUAL_DROP) && tags[MANUAL_DROP] !== false) {\n      return USER_REJECT\n    } else {\n      const priority = parseInt(tags[SAMPLING_PRIORITY], 10)\n\n      if (priority === 1 || priority === 2) {\n        return USER_KEEP\n      } else if (priority === 0 || priority === -1) {\n        return USER_REJECT\n      }\n    }\n  }\n\n  _isSampledByRule (context, rule) {\n    context._tags[SAMPLING_RULE_DECISION] = rule.sampleRate\n\n    return rule.sampler.isSampled(context)\n  }\n\n  _isSampledByRateLimit (context) {\n    const allowed = this._limiter.isAllowed()\n\n    context._tags[SAMPLING_LIMIT_DECISION] = this._limiter.effectiveRate()\n\n    return allowed\n  }\n\n  _isSampledByAgent (context) {\n    const key = `service:${context._tags[SERVICE_NAME]},env:${this._env}`\n    const sampler = this._samplers[key] || this._samplers[DEFAULT_KEY]\n\n    context._tags[SAMPLING_AGENT_DECISION] = sampler.rate()\n\n    return sampler.isSampled(context)\n  }\n\n  _normalizeRules (rules, sampleRate) {\n    return rules\n      .concat({ sampleRate })\n      .map(rule => ({ ...rule, sampleRate: parseFloat(rule.sampleRate) }))\n      .filter(rule => !isNaN(rule.sampleRate))\n      .map(rule => ({ ...rule, sampler: new Sampler(rule.sampleRate) }))\n  }\n\n  _findRule (context) {\n    for (let i = 0, l = this._rules.length; i < l; i++) {\n      if (this._matchRule(context, this._rules[i])) return this._rules[i]\n    }\n  }\n\n  _matchRule (context, rule) {\n    const name = context._name\n    const service = context._tags['service.name']\n\n    if (rule.name instanceof RegExp && !rule.name.test(name)) return false\n    if (rule.name && rule.name !== name) return false\n    if (rule.service instanceof RegExp && !rule.service.test(service)) return false\n    if (rule.service && rule.service !== service) return false\n\n    return true\n  }\n}\n\nmodule.exports = PrioritySampler\n","function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = function() { return []; };\nwebpackEmptyContext.resolve = webpackEmptyContext;\nmodule.exports = webpackEmptyContext;\nwebpackEmptyContext.id = \"../../node_modules/dd-trace/packages/dd-trace/src/profiling sync recursive\";","'use strict'\n\nconst coalesce = require('koalas')\nconst os = require('os')\nconst { AgentExporter } = require('./exporters/agent')\nconst { InspectorCpuProfiler } = require('./profilers/inspector/cpu')\nconst { InspectorHeapProfiler } = require('./profilers/inspector/heap')\nconst { ConsoleLogger } = require('./loggers/console')\nconst { tagger } = require('./tagger')\nconst platform = require('../platform')\n\nconst {\n  DD_PROFILING_ENABLED,\n  DD_ENV,\n  DD_TAGS,\n  DD_SERVICE,\n  DD_VERSION\n} = process.env\n\nclass Config {\n  constructor (options = {}) {\n    const enabled = coalesce(options.enabled, DD_PROFILING_ENABLED, true)\n    const env = coalesce(options.env, DD_ENV)\n    const service = coalesce(options.service, DD_SERVICE, platform.service())\n    const host = os.hostname()\n    const version = coalesce(options.version, DD_VERSION, platform.appVersion())\n    const flushInterval = 60 * 1000\n\n    this.enabled = String(enabled) !== 'false'\n    this.service = service\n    this.env = env\n    this.host = host\n    this.version = version\n    this.tags = Object.assign(\n      tagger.parse(DD_TAGS),\n      tagger.parse(options.tags),\n      tagger.parse({ env, host, service, version })\n    )\n    this.logger = options.logger || new ConsoleLogger()\n    this.flushInterval = flushInterval\n    this.exporters = options.exporters || [\n      new AgentExporter()\n    ]\n    this.profilers = options.profilers || [\n      new InspectorCpuProfiler(),\n      new InspectorHeapProfiler()\n    ]\n  }\n}\n\nmodule.exports = { Config }\n","'use strict'\n\nconst { gzip } = require('zlib')\nconst { perftools } = require('../../../../../protobuf/profile')\nconst { Profile } = perftools.profiles\n\nclass Encoder {\n  encode (profile, callback) {\n    try {\n      gzip(Profile.encode(profile).finish(), callback)\n    } catch (e) {\n      callback(e)\n    }\n  }\n}\n\nmodule.exports = { Encoder }\n","'use strict'\n\nconst FormData = require('form-data')\nconst { URL } = require('url')\nconst { Encoder } = require('../encoders/pprof')\nconst platform = require('../../platform')\nconst { eachOfSeries } = require('../util')\n\nclass AgentExporter {\n  constructor ({ url, hostname, port } = {}) {\n    this._url = new URL(url || `http://${hostname || 'localhost'}:${port || 8126}`)\n    this._encoder = new Encoder()\n  }\n\n  export ({ profiles, start, end, tags }, callback) {\n    const form = new FormData()\n    const types = Object.keys(profiles)\n    const runtime = platform.name()\n\n    form.append('recording-start', start.toISOString())\n    form.append('recording-end', end.toISOString())\n    form.append('language', 'javascript')\n    form.append('runtime', runtime)\n    form.append('format', 'pprof')\n\n    form.append('tags[]', 'language:javascript')\n    form.append('tags[]', `runtime:${runtime}`)\n    form.append('tags[]', 'format:pprof')\n\n    for (const key in tags) {\n      form.append('tags[]', `${key}:${tags[key]}`)\n    }\n\n    eachOfSeries(types, (type, index, callback) => {\n      const profile = profiles[type]\n\n      this._encoder.encode(profile, (err, buffer) => {\n        if (err) return callback(err)\n\n        form.append(`types[${index}]`, type)\n        form.append(`data[${index}]`, buffer, {\n          filename: `${type}.pb.gz`,\n          contentType: 'application/octet-stream',\n          knownLength: buffer.length\n        })\n\n        callback(null, buffer)\n      })\n    }, err => {\n      if (err) return callback(err)\n\n      const options = {\n        method: 'POST',\n        path: '/profiling/v1/input',\n        timeout: 10 * 1000\n      }\n\n      if (this._url.protocol === 'unix:') {\n        options.socketPath = this._url.pathname\n      } else {\n        options.protocol = this._url.protocol\n        options.hostname = this._url.hostname\n        options.port = this._url.port\n      }\n\n      form.submit(options, (err, res) => {\n        if (err) return callback(err)\n        if (res.statusCode >= 400) {\n          return callback(new Error(`Error from the agent: ${res.statusCode}`))\n        }\n\n        callback()\n      })\n    })\n  }\n}\n\nmodule.exports = { AgentExporter }\n","'use strict'\n\nconst { writeFile } = require('fs')\nconst { Encoder } = require('../encoders/pprof')\nconst { parallel } = require('../util')\n\nclass FileExporter {\n  constructor () {\n    this._encoder = new Encoder()\n  }\n\n  export ({ profiles }, callback) {\n    const types = Object.keys(profiles)\n    const tasks = types.map(type => cb => this._write(type, profiles[type], cb))\n\n    parallel(tasks, callback)\n  }\n\n  _write (type, profile, callback) {\n    this._encoder.encode(profile, (err, buffer) => {\n      if (err) return callback(err)\n\n      writeFile(`${type}.pb.gz`, buffer, callback)\n    })\n  }\n}\n\nmodule.exports = { FileExporter }\n","'use strict'\n\nconst { Profiler } = require('./profiler')\nconst { InspectorCpuProfiler } = require('./profilers/inspector/cpu')\nconst { InspectorHeapProfiler } = require('./profilers/inspector/heap')\nconst { NativeCpuProfiler } = require('./profilers/native/cpu')\nconst { NativeHeapProfiler } = require('./profilers/native/heap')\nconst { AgentExporter } = require('./exporters/agent')\nconst { FileExporter } = require('./exporters/file')\nconst { ConsoleLogger } = require('./loggers/console')\n\nconst profiler = new Profiler()\n\nmodule.exports = {\n  profiler,\n  AgentExporter,\n  FileExporter,\n  InspectorCpuProfiler,\n  InspectorHeapProfiler,\n  NativeCpuProfiler,\n  NativeHeapProfiler,\n  ConsoleLogger\n}\n","'use strict'\n\n// TODO: use sourceRoot when set, possibly from source-map-resolve\n\nconst fs = require('fs')\nconst { SourceMapConsumer } = require('source-map')\nconst sourceMapResolve = require('source-map-resolve')\nconst { fileURLToPath, pathToFileURL } = require('url')\n\nclass SourceMapper {\n  constructor () {\n    this._consumers = Object.create(null)\n    this._sources = Object.create(null)\n  }\n\n  async getSource (callFrame) {\n    const { url, lineNumber, columnNumber, functionName } = callFrame\n    const key = `${url}:${functionName}:${lineNumber}:${columnNumber}`\n\n    if (!this._sources[key]) {\n      this._sources[key] = await this._getMapping(callFrame)\n    }\n\n    return this._sources[key]\n  }\n\n  async _getConsumer (url) {\n    if (this._consumers[url] === undefined) {\n      this._consumers[url] = this._createConsumer(url)\n    }\n\n    return this._consumers[url]\n  }\n\n  async _createConsumer (url) {\n    try {\n      const map = await this._resolve(url)\n\n      return map ? new SourceMapConsumer(map) : null\n    } catch (e) {\n      return null\n    }\n  }\n\n  async _getMapping (callFrame) {\n    const { url, functionName, lineNumber, columnNumber } = callFrame\n\n    // Runtime.CallFrame is 0-based for both line and column numbers.\n    // When the line or column number is not known the value is -1.\n    // https://chromedevtools.github.io/devtools-protocol/v8/Runtime/#type-CallFrame\n    if (lineNumber < 0 || columnNumber < 0) return callFrame\n\n    const consumer = await this._getConsumer(url)\n\n    if (!consumer) return callFrame\n\n    // SourceMapConsumer is 1-based for lines and 0-based for columns\n    // https://github.com/mozilla/source-map/blob/0.7.3/lib/source-map-consumer.js#L464-L487\n    const map = consumer.originalPositionFor({\n      line: lineNumber + 1,\n      column: columnNumber\n    })\n\n    if (!map || !map.source || !map.line) return callFrame\n\n    return {\n      url: pathToFileURL(map.source).href,\n      lineNumber: map.line - 1, // reset to 0-based from 1-based\n      columnNumber: map.column !== null ? map.column : -1,\n      functionName: map.name || functionName\n    }\n  }\n\n  async _resolve (url) {\n    const filename = fileURLToPath(url)\n    const code = (await fs.promises.readFile(filename)).toString()\n\n    return new Promise((resolve, reject) => {\n      sourceMapResolve.resolve(code, filename, fs.readFile, (error, result) => {\n        if (!result || error) return resolve(null)\n\n        result.map.sourcesContent = result.sourcesContent\n        result.map.sources = result.sourcesResolved\n\n        resolve(result.map)\n      })\n    })\n  }\n}\n\nmodule.exports = { SourceMapper }\n","'use strict'\n\nconst { perftools } = require('../../../../protobuf/profile')\n\nclass Profile {\n  constructor (sampleType, periodType, period) {\n    this._stringTable = new Map([['', 0]])\n    this._locations = new Map()\n    this._functions = new Map()\n    this._samples = new Map()\n    this._links = new Map()\n    this._sampleType = this._toSampleType(sampleType)\n    this._periodType = this._toValueType(periodType)\n    this._period = period\n    this._timeNanos = Date.now() * 1e6\n    this._properties = {}\n  }\n\n  export () {\n    return new perftools.profiles.Profile({\n      sampleType: this._sampleType,\n      periodType: this._periodType,\n      sample: Array.from(this._samples.values()),\n      location: Array.from(this._locations.values()),\n      function: Array.from(this._functions.values()),\n      stringTable: Array.from(this._stringTable.keys()),\n      timeNanos: this._timeNanos,\n      durationNanos: this._durationNanos,\n      period: this._period\n    })\n  }\n\n  addDuration (nanoseconds) {\n    this._durationNanos = nanoseconds\n  }\n\n  addString (value) {\n    let idx = this._stringTable.get(value)\n\n    if (idx === undefined) {\n      idx = this._stringTable.size\n      this._stringTable.set(value, idx)\n    }\n\n    return idx\n  }\n\n  addFunction (functionName, url) {\n    const key = `${url}:${functionName}`\n\n    let fn = this._functions.get(key)\n\n    if (!fn) {\n      const filename = this.addString(url)\n      const name = this.addString(functionName || '(anonymous)')\n\n      fn = new perftools.profiles.Function({\n        filename,\n        systemName: name,\n        id: this._functions.size + 1,\n        name\n      })\n\n      this._functions.set(key, fn)\n    }\n\n    return fn\n  }\n\n  // TODO: compute location id\n  addLocation (functionId, locationId, lineNumber) {\n    const location = new perftools.profiles.Location({\n      id: locationId,\n      line: [\n        new perftools.profiles.Line({\n          functionId,\n          line: lineNumber + 1 // Runtime.CallFrame is 0-based\n        })\n      ]\n    })\n\n    this._locations.set(locationId, location)\n\n    return location\n  }\n\n  addSample (locationId, values) {\n    let sample = this._samples.get(locationId)\n\n    if (!sample) {\n      const locationIds = []\n\n      let link = locationId\n\n      do {\n        locationIds.push(link)\n      } while ((link = this._links.get(link)))\n\n      sample = new perftools.profiles.Sample({\n        locationId: locationIds,\n        value: values\n      })\n\n      this._samples.set(locationId, sample)\n    } else {\n      for (let i = 0; i < values.length; i++) {\n        sample.value[i] += values[i]\n      }\n    }\n\n    return sample\n  }\n\n  addLink (locationId, childId) {\n    this._links.set(childId, locationId)\n  }\n\n  _toSampleType (tuples) {\n    return tuples.map(tuple => this._toValueType(tuple))\n  }\n\n  _toValueType (tuple) {\n    return {\n      type: this.addString(tuple[0]),\n      unit: this.addString(tuple[1])\n    }\n  }\n}\n\nmodule.exports = { Profile }\n","'use strict'\n\nconst semver = require('semver')\nconst { EventEmitter } = require('events')\nconst { Config } = require('./config')\nconst { SourceMapper } = require('./mapper')\nconst { eachSeries } = require('./util')\n\nclass Profiler extends EventEmitter {\n  start (options) {\n    if (this._enabled) return\n\n    const config = this._config = new Config(options)\n\n    if (!config.enabled) return\n\n    this._logger = config.logger\n\n    if (!semver.satisfies(process.version, '>=10.12')) {\n      this._logger.error('Profiling could not be started because it requires Node >=10.12')\n      return this\n    }\n\n    this._enabled = true\n\n    try {\n      const mapper = config.sourceMap ? new SourceMapper() : null\n\n      for (const profiler of config.profilers) {\n        profiler.start({ mapper }) // TODO: move this outside of profilers\n      }\n    } catch (e) {\n      this._logger.error(e)\n      this.stop()\n    }\n\n    this._capture(config.flushInterval)\n\n    return this\n  }\n\n  stop () {\n    if (!this._enabled) return\n\n    this._enabled = false\n\n    for (const profiler of this._config.profilers) {\n      profiler.stop()\n    }\n\n    clearTimeout(this._timer)\n\n    return this\n  }\n\n  _capture (timeout) {\n    const start = new Date()\n\n    this._timer = setTimeout(() => this._collect(start), timeout)\n    this._timer.unref()\n  }\n\n  _collect (start) {\n    const end = new Date()\n    const profiles = {}\n\n    eachSeries(this._config.profilers, (profiler, callback) => {\n      profiler.profile((err, profile) => {\n        if (err) return callback(err)\n\n        profiles[profiler.type] = profile\n\n        callback(err, profile)\n      })\n    }, err => {\n      if (err) {\n        this._logger.error(err)\n        this.stop()\n      } else {\n        this._capture(this._config.flushInterval)\n        this._submit(profiles, start, end)\n      }\n    })\n  }\n\n  _submit (profiles, start, end) {\n    const { tags } = this._config\n\n    for (const exporter of this._config.exporters) {\n      exporter.export({ profiles, start, end, tags }, err => {\n        if (err) {\n          this._logger.error(err)\n        }\n      })\n    }\n  }\n}\n\nmodule.exports = { Profiler }\n","'use strict'\n\nconst { Profile } = require('../../profile')\n\nclass InspectorCpuProfiler {\n  constructor (options = {}) {\n    this.type = 'wall'\n    this._samplingInterval = options.samplingInterval || 10 * 1000\n  }\n\n  start ({ mapper }) {\n    const { Session } = require('inspector')\n\n    this._mapper = mapper\n\n    this._session = new Session()\n    this._session.connect()\n    this._session.post('Profiler.enable')\n    this._session.post('Profiler.setSamplingInterval', {\n      interval: this._samplingInterval\n    })\n    this._session.post('Profiler.start')\n  }\n\n  stop () {\n    this._session.post('Profiler.stop')\n    this._session.post('Profiler.disable')\n    this._session.disconnect()\n    this._session = null\n\n    this._mapper = null\n  }\n\n  profile (callback) {\n    this._session.post('Profiler.stop', (err, params) => {\n      if (err) return callback(err)\n\n      this._session.post('Profiler.start')\n\n      this._serialize(params.profile, callback)\n    })\n  }\n\n  _serialize ({ startTime, endTime, nodes, samples, timeDeltas }, callback) {\n    const sampleType = [['sample', 'count'], ['wall', 'microseconds']]\n    const periodType = ['wall', 'microseconds']\n    const period = this._samplingInterval\n    const profile = new Profile(sampleType, periodType, period)\n    const skippedLocationIds = new Set()\n\n    profile.addDuration((endTime - startTime) * 1000)\n\n    for (const node of nodes) {\n      // pprof has implicit root so skip root\n      if (node.callFrame.functionName === '(root)') continue\n\n      const { id, children, callFrame } = node\n      const { functionName, url, lineNumber } = callFrame // TODO: support source maps\n      const functionId = profile.addFunction(functionName, url).id\n      const locationId = profile.addLocation(functionId, id, lineNumber).id\n\n      // skip redundant samples that are handled by pprof and/or the backend\n      if (functionName === '(program)' || functionName === '(idle)') {\n        skippedLocationIds.add(locationId)\n      }\n\n      if (children) {\n        for (const childId of children) {\n          profile.addLink(locationId, childId)\n        }\n      }\n    }\n\n    for (let i = 0; i < samples.length; i++) {\n      if (skippedLocationIds.has(samples[i])) continue\n\n      profile.addSample(samples[i], [1, timeDeltas[i]])\n    }\n\n    callback(null, profile.export())\n  }\n}\n\nmodule.exports = { InspectorCpuProfiler }\n","'use strict'\n\nconst { Profile } = require('../../profile')\n\nclass InspectorHeapProfiler {\n  constructor (options = {}) {\n    this.type = 'space'\n    this._samplingInterval = options.samplingInterval || 512 * 1024\n  }\n\n  start ({ mapper }) {\n    const { Session } = require('inspector')\n\n    this._mapper = mapper\n\n    this._session = new Session()\n    this._session.connect()\n    this._session.post('HeapProfiler.enable')\n    this._session.post('HeapProfiler.startSampling', {\n      samplingInterval: this._samplingInterval\n    })\n  }\n\n  stop () {\n    this._session.post('HeapProfiler.stopSampling')\n    this._session.post('HeapProfiler.disable')\n    this._session.disconnect()\n    this._session = null\n\n    this._mapper = null\n  }\n\n  profile (callback) {\n    this._session.post('HeapProfiler.getSamplingProfile', (err, params) => {\n      if (err) return callback(err)\n\n      this._serialize(params.profile, callback)\n    })\n  }\n\n  _serialize ({ head, samples }, callback) {\n    const sampleType = [['space', 'bytes']]\n    const periodType = ['space', 'bytes']\n    const period = this._samplingInterval\n    const profile = new Profile(sampleType, periodType, period)\n    const nodes = head.children.slice() // pprof has implicit root so skip root\n\n    let node\n\n    while ((node = nodes.shift())) {\n      const { id, selfSize, callFrame, children } = node\n      const { functionName, url, lineNumber } = callFrame // TODO: support source maps\n      const functionId = profile.addFunction(functionName, url).id\n      const locationId = profile.addLocation(functionId, id, lineNumber).id\n\n      if (children) {\n        for (const child of children) {\n          nodes.push(child)\n          profile.addLink(locationId, child.id)\n        }\n      }\n\n      if (selfSize) {\n        profile.addSample(locationId, [selfSize])\n      }\n    }\n\n    callback(null, profile.export())\n  }\n}\n\nmodule.exports = { InspectorHeapProfiler }\n","'use strict'\n\nconst { maybeRequire } = require('../../util')\n\nclass NativeCpuProfiler {\n  constructor (options = {}) {\n    this.type = 'wall'\n    this._pprof = maybeRequire('pprof')\n    this._samplingInterval = options.samplingInterval || 10 * 1000\n  }\n\n  start () {\n    // pprof otherwise crashes in worker threads\n    if (!process._startProfilerIdleNotifier) {\n      process._startProfilerIdleNotifier = () => {}\n    }\n\n    this._record()\n  }\n\n  profile () {\n    const profile = this._stop()\n\n    this._record()\n\n    return profile\n  }\n\n  stop () {\n    this._stop()\n  }\n\n  _record () {\n    this._stop = this._pprof.time.start(this._samplingInterval)\n  }\n}\n\nmodule.exports = { NativeCpuProfiler }\n","'use strict'\n\nconst { maybeRequire } = require('../../util')\n\nclass NativeHeapProfiler {\n  constructor (options = {}) {\n    this.type = 'space'\n    this._pprof = maybeRequire('pprof')\n    this._samplingInterval = options.samplingInterval || 512 * 1024\n    this._stackDepth = options.stackDepth || 64\n  }\n\n  start () {\n    this._pprof.heap.start(this._samplingInterval, this._stackDepth)\n  }\n\n  profile () {\n    return this._pprof.heap.profile()\n  }\n\n  stop () {\n    this._pprof.heap.stop()\n  }\n}\n\nmodule.exports = { NativeHeapProfiler }\n","'use strict'\n\nconst tagger = {\n  parse (tags) {\n    if (!tags) return {}\n\n    switch (typeof tags) {\n      case 'object':\n        if (Array.isArray(tags)) {\n          return tags.reduce((prev, next) => {\n            const parts = next.split(':')\n            const key = parts.shift()\n            const value = parts.join(':')\n\n            if (!key || !value) return prev\n\n            return Object.assign(prev, { [key]: value })\n          }, {})\n        } else {\n          return tagger.parse(Object.keys(tags)\n            .filter(key => tags[key] !== undefined && tags[key] !== null)\n            .map(key => `${key}:${tags[key]}`))\n        }\n      case 'string':\n        return tagger.parse(tags.split(','))\n      default:\n        return {}\n    }\n  }\n}\n\nmodule.exports = { tagger }\n","'use strict'\n\nfunction maybeRequire (id) {\n  try {\n    return require(id)\n  } catch (e) {\n    return null\n  }\n}\n\nfunction eachSeries (collection, iteratee, callback) {\n  eachOfSeries(collection, (item, index, callback) => iteratee(item, callback), callback)\n}\n\nfunction eachOfSeries (collection, iteratee, callback = () => {}) {\n  const results = new Array(collection.length)\n  const next = index => {\n    if (collection[index]) {\n      iteratee(collection[index], index, (err, result) => {\n        if (err) return callback(err)\n\n        results[index] = result\n\n        next(index + 1)\n      })\n    } else {\n      callback(null, results)\n    }\n  }\n\n  next(0)\n}\n\nfunction parallel (tasks, callback) {\n  const results = new Array(tasks.length)\n\n  let counter = 0\n  let failing = false\n\n  for (let i = 0; i < tasks.length; i++) {\n    const taskIndex = i\n\n    tasks[taskIndex]((err, result) => {\n      if (failing) return\n      if (err) {\n        failing = true\n        return callback(err)\n      }\n\n      results[taskIndex] = result\n\n      if (++counter === tasks.length) {\n        callback(null, results)\n      }\n    })\n  }\n}\n\nmodule.exports = {\n  maybeRequire,\n  parallel,\n  eachSeries,\n  eachOfSeries\n}\n","'use strict'\n\nconst BaseTracer = require('opentracing').Tracer\nconst NoopTracer = require('./noop/tracer')\nconst DatadogTracer = require('./tracer')\nconst Config = require('./config')\nconst Instrumenter = require('./instrumenter')\nconst platform = require('./platform')\nconst log = require('./log')\nconst { setStartupLogInstrumenter } = platform.startupLog\nconst analyticsSampler = require('./analytics_sampler')\n\nconst noop = new NoopTracer()\n\nclass Tracer extends BaseTracer {\n  constructor () {\n    super()\n    this._tracer = noop\n    this._instrumenter = new Instrumenter(this)\n    this._deprecate = method => log.deprecate(`tracer.${method}`, [\n      `tracer.${method}() is deprecated.`,\n      'Please use tracer.startSpan() and tracer.scope() instead.',\n      'See: https://datadog.github.io/dd-trace-js/#manual-instrumentation.'\n    ].join(' '))\n  }\n\n  init (options) {\n    if (this._tracer === noop) {\n      try {\n        const config = new Config(options)\n\n        log.use(config.logger)\n        log.toggle(config.debug, config.logLevel, this)\n\n        platform.configure(config)\n        platform.profiler().start()\n\n        if (config.enabled) {\n          platform.validate()\n\n          if (config.runtimeMetrics) {\n            platform.metrics().start()\n          }\n\n          if (config.analytics) {\n            analyticsSampler.enable()\n          }\n\n          this._tracer = new DatadogTracer(config)\n          this._instrumenter.enable(config)\n          setStartupLogInstrumenter(this._instrumenter)\n        }\n      } catch (e) {\n        log.error(e)\n      }\n    }\n\n    return this\n  }\n\n  use () {\n    this._instrumenter.use.apply(this._instrumenter, arguments)\n    return this\n  }\n\n  trace (name, options, fn) {\n    if (!fn) {\n      fn = options\n      options = {}\n    }\n\n    if (typeof fn !== 'function') return\n\n    options = options || {}\n\n    return this._tracer.trace(name, options, fn)\n  }\n\n  wrap (name, options, fn) {\n    if (!fn) {\n      fn = options\n      options = {}\n    }\n\n    if (typeof fn !== 'function') return fn\n\n    options = options || {}\n\n    return this._tracer.wrap(name, options, fn)\n  }\n\n  setUrl () {\n    this._tracer.setUrl.apply(this._tracer, arguments)\n    return this\n  }\n\n  startSpan () {\n    return this._tracer.startSpan.apply(this._tracer, arguments)\n  }\n\n  inject () {\n    return this._tracer.inject.apply(this._tracer, arguments)\n  }\n\n  extract () {\n    return this._tracer.extract.apply(this._tracer, arguments)\n  }\n\n  scopeManager () {\n    this._deprecate('scopeManager')\n    return this._tracer.scopeManager.apply(this._tracer, arguments)\n  }\n\n  scope () {\n    return this._tracer.scope.apply(this._tracer, arguments)\n  }\n\n  currentSpan () {\n    this._deprecate('currentSpan')\n    return this._tracer.currentSpan.apply(this._tracer, arguments)\n  }\n\n  bind (callback) {\n    this._deprecate('bind')\n    return callback\n  }\n\n  bindEmitter () {\n    this._deprecate('bindEmitter')\n  }\n\n  getRumData () {\n    return this._tracer.getRumData.apply(this._tracer, arguments)\n  }\n}\n\nmodule.exports = Tracer\n","'use strict'\n\nconst asyncHooks = require('async_hooks')\nconst Base = require('./base')\nconst platform = require('../platform')\nconst semver = require('semver')\n\n// https://github.com/nodejs/node/issues/19859\nconst hasKeepAliveBug = !semver.satisfies(process.version, '^8.13 || >=10.14.2')\n\n// fixed in https://github.com/nodejs/node/pull/33801\nconst hasThenableBug = !semver.satisfies(process.version, '>=14.5 || ^12.19.0')\n\nlet singleton = null\n\nclass Scope extends Base {\n  constructor (config) {\n    if (singleton) return singleton\n\n    super()\n\n    singleton = this\n\n    this._trackAsyncScope = config.trackAsyncScope && hasThenableBug\n    this._debug = config.debug\n    this._current = null\n    this._spans = new Map()\n    this._types = new Map()\n    this._weaks = new WeakMap()\n    this._promises = [false]\n    this._stack = []\n    this._depth = 0\n    this._hook = asyncHooks.createHook({\n      init: this._init.bind(this),\n      before: this._before.bind(this),\n      after: this._after.bind(this),\n      destroy: this._destroy.bind(this)\n    })\n\n    this._enabled = true\n    this._hook.enable()\n  }\n\n  _active () {\n    return this._current\n  }\n\n  _activate (span, callback) {\n    const active = this._active()\n\n    this._enter(span)\n\n    try {\n      return callback()\n    } finally {\n      this._exit(active)\n    }\n  }\n\n  _enter (span) {\n    this._depth++\n    this._stack[this._depth] = this._current\n    this._current = span\n    this._promises[this._depth] = false\n  }\n\n  _exit (span) {\n    this._trackAsyncScope && this._await(span)\n    this._current = span\n    this._stack[this._depth] = null\n    this._depth--\n  }\n\n  _exitNative () {\n    this._current = null\n    this._promises[0] = false\n  }\n\n  _await (span) {\n    if (!this._promises[this._depth]) return\n\n    this._enabled = false\n    this._awaitAsync(span)\n    this._enabled = true\n  }\n\n  // https://github.com/nodejs/node/issues/22360\n  async _awaitAsync (span) {\n    await {\n      then: (resolve) => {\n        this._current = span\n        resolve()\n      }\n    }\n  }\n\n  _initPromise () {\n    if (!this._promises[this._depth]) {\n      this._promises[this._depth] = true\n      this._await(this._current)\n    }\n  }\n\n  _init (asyncId, type, triggerAsyncId, resource) {\n    if (!this._enabled) return\n\n    this._spans.set(asyncId, this._current)\n    this._types.set(asyncId, type)\n\n    if (hasKeepAliveBug && (type === 'TCPWRAP' || type === 'HTTPPARSER')) {\n      this._destroy(this._weaks.get(resource))\n      this._weaks.set(resource, asyncId)\n    }\n\n    if (this._debug) {\n      const metrics = platform.metrics()\n      metrics.increment('runtime.node.async.resources')\n      metrics.increment('runtime.node.async.resources.by.type', `resource_type:${type}`)\n    }\n\n    if (this._trackAsyncScope && type === 'PROMISE') {\n      this._initPromise()\n    }\n  }\n\n  _before (asyncId) {\n    this._depth === 0 && this._exitNative()\n    this._enter(this._spans.get(asyncId))\n  }\n\n  _after () {\n    this._exit(this._stack[this._depth])\n  }\n\n  _destroy (asyncId) {\n    const type = this._types.get(asyncId)\n\n    if (type && this._debug) {\n      const metrics = platform.metrics()\n      metrics.decrement('runtime.node.async.resources')\n      metrics.decrement('runtime.node.async.resources.by.type', `resource_type:${type}`)\n    }\n\n    this._spans.delete(asyncId)\n    this._types.delete(asyncId)\n  }\n}\n\nmodule.exports = Scope\n","'use strict'\n\nconst { AsyncLocalStorage } = require('async_hooks')\nconst Base = require('./base')\n\nlet singleton = null\n\nclass Scope extends Base {\n  constructor () {\n    if (singleton) return singleton\n\n    super()\n\n    singleton = this\n\n    this._storage = new AsyncLocalStorage()\n  }\n\n  _active () {\n    const store = this._storage.getStore()\n    return typeof store === 'undefined' ? null : store\n  }\n\n  _activate (span, callback) {\n    return this._storage.run(span, callback)\n  }\n}\n\nmodule.exports = Scope\n","'use strict'\n\nconst { createHook, executionAsyncResource } = require('async_hooks')\nconst Base = require('./base')\n\nclass Scope extends Base {\n  constructor (config) {\n    super()\n\n    this._ddResourceStore = Symbol('ddResourceStore')\n    this._config = config\n    this._stack = []\n    this._hook = createHook({\n      init: this._init.bind(this)\n    })\n\n    this.enable()\n  }\n\n  enable () {\n    this._enabled = true\n    this._hook.enable()\n  }\n\n  disable () {\n    this._enabled = false\n    this._stack = []\n    this._hook.disable()\n  }\n\n  _active () {\n    if (!this._enabled) return null\n\n    const resource = executionAsyncResource()\n\n    return resource[this._ddResourceStore] || null\n  }\n\n  _activate (span, callback) {\n    if (!this._enabled) return callback()\n\n    const resource = executionAsyncResource()\n\n    this._enter(span, resource)\n\n    try {\n      return callback()\n    } finally {\n      this._exit(resource)\n    }\n  }\n\n  _enter (span, resource) {\n    this._stack.push(resource[this._ddResourceStore])\n    resource[this._ddResourceStore] = span\n  }\n\n  _exit (resource) {\n    resource[this._ddResourceStore] = this._stack.pop()\n  }\n\n  _init (asyncId, type, triggerAsyncId, resource) {\n    const triggerResource = executionAsyncResource()\n    const span = triggerResource[this._ddResourceStore]\n\n    if (span) {\n      resource[this._ddResourceStore] = span\n    }\n  }\n}\n\nmodule.exports = Scope\n","'use strict'\n\nclass Scope {\n  active () {\n    return this._active() || null\n  }\n\n  activate (span, callback) {\n    if (typeof callback !== 'function') return callback\n\n    try {\n      return this._activate(span, callback)\n    } catch (e) {\n      if (span && typeof span.setTag === 'function') {\n        span.setTag('error', e)\n      }\n\n      throw e\n    }\n  }\n\n  bind (target, span) {\n    target = this._bindEmitter(target, span)\n    target = this._bindPromise(target, span)\n    target = this._bindFn(target, span)\n\n    return target\n  }\n\n  unbind (target) {\n    target = this._unbindFn(target)\n    target = this._unbindPromise(target)\n    target = this._unbindEmitter(target)\n\n    return target\n  }\n\n  _active () {\n    return null\n  }\n\n  _activate (span, callback) {\n    return callback()\n  }\n\n  _bindFn (fn, span) {\n    if (typeof fn !== 'function') return fn\n\n    const scope = this\n    const spanOrActive = this._spanOrActive(span)\n\n    const bound = function () {\n      return scope.activate(spanOrActive, () => {\n        return fn.apply(this, arguments)\n      })\n    }\n\n    bound._datadog_unbound = fn\n\n    return bound\n  }\n\n  _unbindFn (fn) {\n    if (typeof fn !== 'function') return fn\n\n    return fn._datadog_unbound || fn\n  }\n\n  _bindEmitter (emitter, span) {\n    if (!this._isEmitter(emitter)) return emitter\n    if (!emitter.__is_dd_emitter) {\n      Scope._wrapEmitter(emitter)\n    }\n    emitter.__dd_span = span\n    emitter.__dd_scope = this\n    return emitter\n  }\n\n  // Occasionally we want to wrap a prototype rather than emitter instances,\n  // so we're exposing this as a static method. This gives us a faster\n  // path for binding instances of known EventEmitter subclasses.\n  static _wrapEmitter (emitter) {\n    wrapMethod(emitter, 'addListener', wrapAddListener)\n    wrapMethod(emitter, 'prependListener', wrapAddListener)\n    wrapMethod(emitter, 'on', wrapAddListener)\n    wrapMethod(emitter, 'once', wrapAddListener)\n    wrapMethod(emitter, 'removeListener', wrapRemoveListener)\n    wrapMethod(emitter, 'off', wrapRemoveListener)\n    wrapMethod(emitter, 'removeAllListeners', wrapRemoveAllListeners)\n    emitter.__is_dd_emitter = true\n  }\n\n  _unbindEmitter (emitter) {\n    if (!this._isEmitter(emitter)) return emitter\n    delete emitter.__dd_scope\n    delete emitter.__dd_span\n    return emitter\n  }\n\n  _bindPromise (promise, span) {\n    if (!this._isPromise(promise)) return promise\n\n    wrapMethod(promise, 'then', wrapThen, this, span)\n\n    return promise\n  }\n\n  _unbindPromise (promise) {\n    if (!this._isPromise(promise)) return promise\n\n    promise.then = promise.then._datadog_unbound || promise.then\n\n    return promise\n  }\n\n  _spanOrActive (span) {\n    return span !== undefined ? span : this.active()\n  }\n\n  _isEmitter (emitter) {\n    return emitter &&\n      typeof emitter.emit === 'function' &&\n      typeof emitter.on === 'function' &&\n      typeof emitter.addListener === 'function' &&\n      typeof emitter.removeListener === 'function'\n  }\n\n  _isPromise (promise) {\n    return promise && typeof promise.then === 'function'\n  }\n}\n\nfunction wrapThen (then, scope, span) {\n  return function thenWithTrace (onFulfilled, onRejected) {\n    const args = new Array(arguments.length)\n\n    for (let i = 0, l = args.length; i < l; i++) {\n      args[i] = scope.bind(arguments[i], span)\n    }\n\n    return then.apply(this, args)\n  }\n}\n\nfunction wrapAddListener (addListener) {\n  return function addListenerWithTrace (eventName, listener) {\n    if (!this.__dd_scope || !listener || listener._datadog_unbound || listener.listener) {\n      return addListener.apply(this, arguments)\n    }\n    const scope = this.__dd_scope\n    const span = this.__dd_span\n\n    const bound = scope.bind(listener, scope._spanOrActive(span))\n\n    this._datadog_events = this._datadog_events || {}\n\n    if (!this._datadog_events[eventName]) {\n      this._datadog_events[eventName] = new WeakMap()\n    }\n\n    const events = this._datadog_events[eventName]\n\n    if (!events.has(listener)) {\n      events.set(listener, [])\n    }\n\n    events.get(listener).push(bound)\n\n    return addListener.call(this, eventName, bound)\n  }\n}\n\nfunction wrapRemoveListener (removeListener) {\n  return function removeListenerWithTrace (eventName, listener) {\n    if (!this.__dd_scope) {\n      return removeListener.apply(this, arguments)\n    }\n\n    const listeners = this._datadog_events && this._datadog_events[eventName]\n\n    if (!listener || !listeners || !listeners.has(listener)) {\n      return removeListener.apply(this, arguments)\n    }\n\n    for (const bound of listeners.get(listener)) {\n      removeListener.call(this, eventName, bound)\n    }\n\n    listeners.delete(listener)\n\n    return removeListener.call(this, eventName, listener)\n  }\n}\n\nfunction wrapRemoveAllListeners (removeAllListeners) {\n  return function removeAllListenersWithTrace (eventName) {\n    if (this.__dd_scope && this._datadog_events) {\n      if (eventName) {\n        delete this._datadog_events[eventName]\n      } else {\n        delete this._datadog_events\n      }\n    }\n\n    return removeAllListeners.call(this, eventName)\n  }\n}\n\nfunction wrapMethod (target, name, wrapper, ...args) {\n  if (!target[name] || target[name]._datadog_unbound) return\n\n  const original = target[name]\n\n  target[name] = wrapper(target[name], ...args)\n  target[name]._datadog_unbound = original\n}\n\nmodule.exports = Scope\n","'use strict'\n\nclass Scope {\n  constructor (span, finishSpanOnClose) {\n    this._span = span\n    this._finishSpanOnClose = finishSpanOnClose\n    this.close()\n  }\n\n  span () {\n    return this._span\n  }\n\n  close () {\n    if (this._finishSpanOnClose) {\n      this._span.finish()\n    }\n  }\n}\n\nmodule.exports = Scope\n","'use strict'\n\nconst Span = require('opentracing').Span\nconst Scope = require('./scope')\n\nlet singleton = null\n\nconst span = new Span()\n\nclass ScopeManager {\n  constructor () {\n    if (!singleton) {\n      singleton = this\n    }\n\n    return singleton\n  }\n\n  active () {\n    return new Scope(span)\n  }\n\n  activate (span, finishSpanOnClose) {\n    return new Scope(span, finishSpanOnClose)\n  }\n}\n\nmodule.exports = ScopeManager\n","'use strict'\n\nconst ScopeManager = require('./noop/scope_manager')\n\nmodule.exports = ScopeManager\n","const log = require('./log')\nconst format = require('./format')\n\nclass SpanProcessor {\n  constructor (exporter, prioritySampler) {\n    this._exporter = exporter\n    this._prioritySampler = prioritySampler\n  }\n\n  process (span) {\n    const spanContext = span.context()\n    const trace = spanContext._trace\n\n    if (trace.started.length === trace.finished.length) {\n      this._prioritySampler.sample(spanContext)\n\n      if (spanContext._traceFlags.sampled === false) {\n        log.debug(() => `Dropping trace due to user configured filtering: ${trace.started}`)\n        this._erase(trace)\n        return\n      }\n\n      const formattedSpans = trace.finished.map(format)\n      this._exporter.export(formattedSpans)\n      this._erase(trace)\n    }\n  }\n\n  _erase (trace) {\n    trace.finished.forEach(span => {\n      span.context()._tags = {}\n    })\n\n    trace.started = []\n    trace.finished = []\n  }\n}\n\nmodule.exports = SpanProcessor\n","'use strict'\n\nconst log = require('./log')\n\nfunction add (carrier, keyValuePairs) {\n  if (!carrier || !keyValuePairs) return\n\n  if (typeof keyValuePairs === 'string') {\n    return add(\n      carrier,\n      keyValuePairs\n        .split(',')\n        .filter(tag => tag.indexOf(':') !== -1)\n        .reduce((prev, next) => {\n          const tag = next.split(':')\n          const key = tag[0]\n          const value = tag.slice(1).join(':')\n\n          prev[key] = value\n\n          return prev\n        }, {})\n    )\n  }\n\n  if (Array.isArray(keyValuePairs)) {\n    return keyValuePairs.forEach(tags => add(carrier, tags))\n  }\n\n  try {\n    Object.keys(keyValuePairs).forEach(key => {\n      carrier[key] = keyValuePairs[key]\n    })\n  } catch (e) {\n    log.error(e)\n  }\n}\n\nmodule.exports = { add }\n","'use strict'\n\nconst Tracer = require('./opentracing/tracer')\nconst tags = require('../../../ext/tags')\nconst scopes = require('../../../ext/scopes')\nconst platform = require('./platform')\nconst { setStartupLogConfig } = platform.startupLog\n\nconst SPAN_TYPE = tags.SPAN_TYPE\nconst RESOURCE_NAME = tags.RESOURCE_NAME\nconst SERVICE_NAME = tags.SERVICE_NAME\nconst ANALYTICS = tags.ANALYTICS\nconst NOOP = scopes.NOOP\n\nclass DatadogTracer extends Tracer {\n  constructor (config) {\n    super(config)\n\n    this._scopeManager = getScopeManager(config)\n    this._scope = getScope(config)\n    setStartupLogConfig(config)\n  }\n\n  trace (name, options, fn) {\n    options = Object.assign({}, {\n      childOf: this.scope().active()\n    }, options)\n\n    if (!options.childOf && options.orphanable === false) {\n      return fn(null, () => {})\n    }\n\n    const span = this.startSpan(name, options)\n\n    addTags(span, options)\n\n    try {\n      if (fn.length > 1) {\n        return this.scope().activate(span, () => fn(span, err => {\n          addError(span, err)\n          span.finish()\n        }))\n      }\n\n      const result = this.scope().activate(span, () => fn(span))\n\n      if (result && typeof result.then === 'function') {\n        result.then(\n          () => span.finish(),\n          err => {\n            addError(span, err)\n            span.finish()\n          }\n        )\n      } else {\n        span.finish()\n      }\n\n      return result\n    } catch (e) {\n      addError(span, e)\n      span.finish()\n      throw e\n    }\n  }\n\n  wrap (name, options, fn) {\n    const tracer = this\n\n    return function () {\n      if (typeof options === 'function' && typeof fn === 'function') {\n        options = options.apply(this, arguments)\n      }\n\n      if (options.orphanable === false && !tracer.scope().active()) {\n        return fn.apply(this, arguments)\n      }\n\n      const lastArgId = arguments.length - 1\n      const cb = arguments[lastArgId]\n\n      if (typeof cb === 'function') {\n        const scopeBoundCb = tracer.scope().bind(cb)\n        return tracer.trace(name, options, (span, done) => {\n          arguments[lastArgId] = function (err) {\n            done(err)\n            return scopeBoundCb.apply(this, arguments)\n          }\n\n          return fn.apply(this, arguments)\n        })\n      } else {\n        return tracer.trace(name, options, () => fn.apply(this, arguments))\n      }\n    }\n  }\n\n  setUrl (url) {\n    this._exporter.setUrl(url)\n  }\n\n  scopeManager () {\n    return this._scopeManager\n  }\n\n  scope () {\n    return this._scope\n  }\n\n  currentSpan () {\n    return this.scope().active()\n  }\n\n  getRumData () {\n    if (!this._enableGetRumData) {\n      return ''\n    }\n    const span = this.scope().active().context()\n    const traceId = span.toTraceId()\n    const traceTime = Date.now()\n    return `\\\n<meta name=\"dd-trace-id\" content=\"${traceId}\" />\\\n<meta name=\"dd-trace-time\" content=\"${traceTime}\" />`\n  }\n}\n\nfunction addError (span, error) {\n  if (error && error instanceof Error) {\n    span.addTags({\n      'error.type': error.name,\n      'error.msg': error.message,\n      'error.stack': error.stack\n    })\n  }\n}\n\nfunction addTags (span, options) {\n  const tags = {}\n\n  if (options.type) tags[SPAN_TYPE] = options.type\n  if (options.service) tags[SERVICE_NAME] = options.service\n  if (options.resource) tags[RESOURCE_NAME] = options.resource\n\n  tags[ANALYTICS] = options.analytics\n\n  span.addTags(tags)\n}\n\nfunction getScopeManager (config) {\n  let ScopeManager\n\n  if (config.scope === NOOP) {\n    ScopeManager = require('./scope/noop/scope_manager')\n  } else {\n    ScopeManager = require('./scope/scope_manager')\n  }\n\n  return new ScopeManager()\n}\n\nfunction getScope (config) {\n  let Scope\n\n  if (config.scope === NOOP) {\n    Scope = require('./scope/base')\n  } else {\n    Scope = platform.getScope(config.scope)\n  }\n\n  return new Scope(config)\n}\n\nmodule.exports = DatadogTracer\n","'use strict'\n\nfunction isTrue (str) {\n  str = String(str).toLowerCase()\n  return str === 'true' || str === '1'\n}\n\nfunction isFalse (str) {\n  str = String(str).toLowerCase()\n  return str === 'false' || str === '0'\n}\n\nmodule.exports = {\n  isTrue,\n  isFalse\n}\n","/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/\n\"use strict\";\n\nvar $protobuf = require(\"protobufjs/minimal\");\n\n// Common aliases\nvar $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;\n\n// Exported root namespace\nvar $root = $protobuf.roots[\"default\"] || ($protobuf.roots[\"default\"] = {});\n\n$root.perftools = (function() {\n\n    /**\n     * Namespace perftools.\n     * @exports perftools\n     * @namespace\n     */\n    var perftools = {};\n\n    perftools.profiles = (function() {\n\n        /**\n         * Namespace profiles.\n         * @memberof perftools\n         * @namespace\n         */\n        var profiles = {};\n\n        profiles.Profile = (function() {\n\n            /**\n             * Properties of a Profile.\n             * @memberof perftools.profiles\n             * @interface IProfile\n             * @property {Array.<perftools.profiles.IValueType>|null} [sampleType] Profile sampleType\n             * @property {Array.<perftools.profiles.ISample>|null} [sample] Profile sample\n             * @property {Array.<perftools.profiles.IMapping>|null} [mapping] Profile mapping\n             * @property {Array.<perftools.profiles.ILocation>|null} [location] Profile location\n             * @property {Array.<perftools.profiles.IFunction>|null} [\"function\"] Profile function\n             * @property {Array.<string>|null} [stringTable] Profile stringTable\n             * @property {number|Long|null} [dropFrames] Profile dropFrames\n             * @property {number|Long|null} [keepFrames] Profile keepFrames\n             * @property {number|Long|null} [timeNanos] Profile timeNanos\n             * @property {number|Long|null} [durationNanos] Profile durationNanos\n             * @property {perftools.profiles.IValueType|null} [periodType] Profile periodType\n             * @property {number|Long|null} [period] Profile period\n             * @property {Array.<number|Long>|null} [comment] Profile comment\n             * @property {number|Long|null} [defaultSampleType] Profile defaultSampleType\n             */\n\n            /**\n             * Constructs a new Profile.\n             * @memberof perftools.profiles\n             * @classdesc Represents a Profile.\n             * @implements IProfile\n             * @constructor\n             * @param {perftools.profiles.IProfile=} [properties] Properties to set\n             */\n            function Profile(properties) {\n                this.sampleType = [];\n                this.sample = [];\n                this.mapping = [];\n                this.location = [];\n                this[\"function\"] = [];\n                this.stringTable = [];\n                this.comment = [];\n                if (properties)\n                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }\n\n            /**\n             * Profile sampleType.\n             * @member {Array.<perftools.profiles.IValueType>} sampleType\n             * @memberof perftools.profiles.Profile\n             * @instance\n             */\n            Profile.prototype.sampleType = $util.emptyArray;\n\n            /**\n             * Profile sample.\n             * @member {Array.<perftools.profiles.ISample>} sample\n             * @memberof perftools.profiles.Profile\n             * @instance\n             */\n            Profile.prototype.sample = $util.emptyArray;\n\n            /**\n             * Profile mapping.\n             * @member {Array.<perftools.profiles.IMapping>} mapping\n             * @memberof perftools.profiles.Profile\n             * @instance\n             */\n            Profile.prototype.mapping = $util.emptyArray;\n\n            /**\n             * Profile location.\n             * @member {Array.<perftools.profiles.ILocation>} location\n             * @memberof perftools.profiles.Profile\n             * @instance\n             */\n            Profile.prototype.location = $util.emptyArray;\n\n            /**\n             * Profile function.\n             * @member {Array.<perftools.profiles.IFunction>} function\n             * @memberof perftools.profiles.Profile\n             * @instance\n             */\n            Profile.prototype[\"function\"] = $util.emptyArray;\n\n            /**\n             * Profile stringTable.\n             * @member {Array.<string>} stringTable\n             * @memberof perftools.profiles.Profile\n             * @instance\n             */\n            Profile.prototype.stringTable = $util.emptyArray;\n\n            /**\n             * Profile dropFrames.\n             * @member {number|Long} dropFrames\n             * @memberof perftools.profiles.Profile\n             * @instance\n             */\n            Profile.prototype.dropFrames = $util.Long ? $util.Long.fromBits(0,0,false) : 0;\n\n            /**\n             * Profile keepFrames.\n             * @member {number|Long} keepFrames\n             * @memberof perftools.profiles.Profile\n             * @instance\n             */\n            Profile.prototype.keepFrames = $util.Long ? $util.Long.fromBits(0,0,false) : 0;\n\n            /**\n             * Profile timeNanos.\n             * @member {number|Long} timeNanos\n             * @memberof perftools.profiles.Profile\n             * @instance\n             */\n            Profile.prototype.timeNanos = $util.Long ? $util.Long.fromBits(0,0,false) : 0;\n\n            /**\n             * Profile durationNanos.\n             * @member {number|Long} durationNanos\n             * @memberof perftools.profiles.Profile\n             * @instance\n             */\n            Profile.prototype.durationNanos = $util.Long ? $util.Long.fromBits(0,0,false) : 0;\n\n            /**\n             * Profile periodType.\n             * @member {perftools.profiles.IValueType|null|undefined} periodType\n             * @memberof perftools.profiles.Profile\n             * @instance\n             */\n            Profile.prototype.periodType = null;\n\n            /**\n             * Profile period.\n             * @member {number|Long} period\n             * @memberof perftools.profiles.Profile\n             * @instance\n             */\n            Profile.prototype.period = $util.Long ? $util.Long.fromBits(0,0,false) : 0;\n\n            /**\n             * Profile comment.\n             * @member {Array.<number|Long>} comment\n             * @memberof perftools.profiles.Profile\n             * @instance\n             */\n            Profile.prototype.comment = $util.emptyArray;\n\n            /**\n             * Profile defaultSampleType.\n             * @member {number|Long} defaultSampleType\n             * @memberof perftools.profiles.Profile\n             * @instance\n             */\n            Profile.prototype.defaultSampleType = $util.Long ? $util.Long.fromBits(0,0,false) : 0;\n\n            /**\n             * Creates a new Profile instance using the specified properties.\n             * @function create\n             * @memberof perftools.profiles.Profile\n             * @static\n             * @param {perftools.profiles.IProfile=} [properties] Properties to set\n             * @returns {perftools.profiles.Profile} Profile instance\n             */\n            Profile.create = function create(properties) {\n                return new Profile(properties);\n            };\n\n            /**\n             * Encodes the specified Profile message. Does not implicitly {@link perftools.profiles.Profile.verify|verify} messages.\n             * @function encode\n             * @memberof perftools.profiles.Profile\n             * @static\n             * @param {perftools.profiles.IProfile} message Profile message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            Profile.encode = function encode(message, writer) {\n                if (!writer)\n                    writer = $Writer.create();\n                if (message.sampleType != null && message.sampleType.length)\n                    for (var i = 0; i < message.sampleType.length; ++i)\n                        $root.perftools.profiles.ValueType.encode(message.sampleType[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                if (message.sample != null && message.sample.length)\n                    for (var i = 0; i < message.sample.length; ++i)\n                        $root.perftools.profiles.Sample.encode(message.sample[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n                if (message.mapping != null && message.mapping.length)\n                    for (var i = 0; i < message.mapping.length; ++i)\n                        $root.perftools.profiles.Mapping.encode(message.mapping[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();\n                if (message.location != null && message.location.length)\n                    for (var i = 0; i < message.location.length; ++i)\n                        $root.perftools.profiles.Location.encode(message.location[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();\n                if (message[\"function\"] != null && message[\"function\"].length)\n                    for (var i = 0; i < message[\"function\"].length; ++i)\n                        $root.perftools.profiles.Function.encode(message[\"function\"][i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();\n                if (message.stringTable != null && message.stringTable.length)\n                    for (var i = 0; i < message.stringTable.length; ++i)\n                        writer.uint32(/* id 6, wireType 2 =*/50).string(message.stringTable[i]);\n                if (message.dropFrames != null && Object.hasOwnProperty.call(message, \"dropFrames\"))\n                    writer.uint32(/* id 7, wireType 0 =*/56).int64(message.dropFrames);\n                if (message.keepFrames != null && Object.hasOwnProperty.call(message, \"keepFrames\"))\n                    writer.uint32(/* id 8, wireType 0 =*/64).int64(message.keepFrames);\n                if (message.timeNanos != null && Object.hasOwnProperty.call(message, \"timeNanos\"))\n                    writer.uint32(/* id 9, wireType 0 =*/72).int64(message.timeNanos);\n                if (message.durationNanos != null && Object.hasOwnProperty.call(message, \"durationNanos\"))\n                    writer.uint32(/* id 10, wireType 0 =*/80).int64(message.durationNanos);\n                if (message.periodType != null && Object.hasOwnProperty.call(message, \"periodType\"))\n                    $root.perftools.profiles.ValueType.encode(message.periodType, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();\n                if (message.period != null && Object.hasOwnProperty.call(message, \"period\"))\n                    writer.uint32(/* id 12, wireType 0 =*/96).int64(message.period);\n                if (message.comment != null && message.comment.length) {\n                    writer.uint32(/* id 13, wireType 2 =*/106).fork();\n                    for (var i = 0; i < message.comment.length; ++i)\n                        writer.int64(message.comment[i]);\n                    writer.ldelim();\n                }\n                if (message.defaultSampleType != null && Object.hasOwnProperty.call(message, \"defaultSampleType\"))\n                    writer.uint32(/* id 14, wireType 0 =*/112).int64(message.defaultSampleType);\n                return writer;\n            };\n\n            /**\n             * Encodes the specified Profile message, length delimited. Does not implicitly {@link perftools.profiles.Profile.verify|verify} messages.\n             * @function encodeDelimited\n             * @memberof perftools.profiles.Profile\n             * @static\n             * @param {perftools.profiles.IProfile} message Profile message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            Profile.encodeDelimited = function encodeDelimited(message, writer) {\n                return this.encode(message, writer).ldelim();\n            };\n\n            /**\n             * Decodes a Profile message from the specified reader or buffer.\n             * @function decode\n             * @memberof perftools.profiles.Profile\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {perftools.profiles.Profile} Profile\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            Profile.decode = function decode(reader, length) {\n                if (!(reader instanceof $Reader))\n                    reader = $Reader.create(reader);\n                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.perftools.profiles.Profile();\n                while (reader.pos < end) {\n                    var tag = reader.uint32();\n                    switch (tag >>> 3) {\n                    case 1:\n                        if (!(message.sampleType && message.sampleType.length))\n                            message.sampleType = [];\n                        message.sampleType.push($root.perftools.profiles.ValueType.decode(reader, reader.uint32()));\n                        break;\n                    case 2:\n                        if (!(message.sample && message.sample.length))\n                            message.sample = [];\n                        message.sample.push($root.perftools.profiles.Sample.decode(reader, reader.uint32()));\n                        break;\n                    case 3:\n                        if (!(message.mapping && message.mapping.length))\n                            message.mapping = [];\n                        message.mapping.push($root.perftools.profiles.Mapping.decode(reader, reader.uint32()));\n                        break;\n                    case 4:\n                        if (!(message.location && message.location.length))\n                            message.location = [];\n                        message.location.push($root.perftools.profiles.Location.decode(reader, reader.uint32()));\n                        break;\n                    case 5:\n                        if (!(message[\"function\"] && message[\"function\"].length))\n                            message[\"function\"] = [];\n                        message[\"function\"].push($root.perftools.profiles.Function.decode(reader, reader.uint32()));\n                        break;\n                    case 6:\n                        if (!(message.stringTable && message.stringTable.length))\n                            message.stringTable = [];\n                        message.stringTable.push(reader.string());\n                        break;\n                    case 7:\n                        message.dropFrames = reader.int64();\n                        break;\n                    case 8:\n                        message.keepFrames = reader.int64();\n                        break;\n                    case 9:\n                        message.timeNanos = reader.int64();\n                        break;\n                    case 10:\n                        message.durationNanos = reader.int64();\n                        break;\n                    case 11:\n                        message.periodType = $root.perftools.profiles.ValueType.decode(reader, reader.uint32());\n                        break;\n                    case 12:\n                        message.period = reader.int64();\n                        break;\n                    case 13:\n                        if (!(message.comment && message.comment.length))\n                            message.comment = [];\n                        if ((tag & 7) === 2) {\n                            var end2 = reader.uint32() + reader.pos;\n                            while (reader.pos < end2)\n                                message.comment.push(reader.int64());\n                        } else\n                            message.comment.push(reader.int64());\n                        break;\n                    case 14:\n                        message.defaultSampleType = reader.int64();\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                    }\n                }\n                return message;\n            };\n\n            /**\n             * Decodes a Profile message from the specified reader or buffer, length delimited.\n             * @function decodeDelimited\n             * @memberof perftools.profiles.Profile\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @returns {perftools.profiles.Profile} Profile\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            Profile.decodeDelimited = function decodeDelimited(reader) {\n                if (!(reader instanceof $Reader))\n                    reader = new $Reader(reader);\n                return this.decode(reader, reader.uint32());\n            };\n\n            /**\n             * Verifies a Profile message.\n             * @function verify\n             * @memberof perftools.profiles.Profile\n             * @static\n             * @param {Object.<string,*>} message Plain object to verify\n             * @returns {string|null} `null` if valid, otherwise the reason why it is not\n             */\n            Profile.verify = function verify(message) {\n                if (typeof message !== \"object\" || message === null)\n                    return \"object expected\";\n                if (message.sampleType != null && message.hasOwnProperty(\"sampleType\")) {\n                    if (!Array.isArray(message.sampleType))\n                        return \"sampleType: array expected\";\n                    for (var i = 0; i < message.sampleType.length; ++i) {\n                        var error = $root.perftools.profiles.ValueType.verify(message.sampleType[i]);\n                        if (error)\n                            return \"sampleType.\" + error;\n                    }\n                }\n                if (message.sample != null && message.hasOwnProperty(\"sample\")) {\n                    if (!Array.isArray(message.sample))\n                        return \"sample: array expected\";\n                    for (var i = 0; i < message.sample.length; ++i) {\n                        var error = $root.perftools.profiles.Sample.verify(message.sample[i]);\n                        if (error)\n                            return \"sample.\" + error;\n                    }\n                }\n                if (message.mapping != null && message.hasOwnProperty(\"mapping\")) {\n                    if (!Array.isArray(message.mapping))\n                        return \"mapping: array expected\";\n                    for (var i = 0; i < message.mapping.length; ++i) {\n                        var error = $root.perftools.profiles.Mapping.verify(message.mapping[i]);\n                        if (error)\n                            return \"mapping.\" + error;\n                    }\n                }\n                if (message.location != null && message.hasOwnProperty(\"location\")) {\n                    if (!Array.isArray(message.location))\n                        return \"location: array expected\";\n                    for (var i = 0; i < message.location.length; ++i) {\n                        var error = $root.perftools.profiles.Location.verify(message.location[i]);\n                        if (error)\n                            return \"location.\" + error;\n                    }\n                }\n                if (message[\"function\"] != null && message.hasOwnProperty(\"function\")) {\n                    if (!Array.isArray(message[\"function\"]))\n                        return \"function: array expected\";\n                    for (var i = 0; i < message[\"function\"].length; ++i) {\n                        var error = $root.perftools.profiles.Function.verify(message[\"function\"][i]);\n                        if (error)\n                            return \"function.\" + error;\n                    }\n                }\n                if (message.stringTable != null && message.hasOwnProperty(\"stringTable\")) {\n                    if (!Array.isArray(message.stringTable))\n                        return \"stringTable: array expected\";\n                    for (var i = 0; i < message.stringTable.length; ++i)\n                        if (!$util.isString(message.stringTable[i]))\n                            return \"stringTable: string[] expected\";\n                }\n                if (message.dropFrames != null && message.hasOwnProperty(\"dropFrames\"))\n                    if (!$util.isInteger(message.dropFrames) && !(message.dropFrames && $util.isInteger(message.dropFrames.low) && $util.isInteger(message.dropFrames.high)))\n                        return \"dropFrames: integer|Long expected\";\n                if (message.keepFrames != null && message.hasOwnProperty(\"keepFrames\"))\n                    if (!$util.isInteger(message.keepFrames) && !(message.keepFrames && $util.isInteger(message.keepFrames.low) && $util.isInteger(message.keepFrames.high)))\n                        return \"keepFrames: integer|Long expected\";\n                if (message.timeNanos != null && message.hasOwnProperty(\"timeNanos\"))\n                    if (!$util.isInteger(message.timeNanos) && !(message.timeNanos && $util.isInteger(message.timeNanos.low) && $util.isInteger(message.timeNanos.high)))\n                        return \"timeNanos: integer|Long expected\";\n                if (message.durationNanos != null && message.hasOwnProperty(\"durationNanos\"))\n                    if (!$util.isInteger(message.durationNanos) && !(message.durationNanos && $util.isInteger(message.durationNanos.low) && $util.isInteger(message.durationNanos.high)))\n                        return \"durationNanos: integer|Long expected\";\n                if (message.periodType != null && message.hasOwnProperty(\"periodType\")) {\n                    var error = $root.perftools.profiles.ValueType.verify(message.periodType);\n                    if (error)\n                        return \"periodType.\" + error;\n                }\n                if (message.period != null && message.hasOwnProperty(\"period\"))\n                    if (!$util.isInteger(message.period) && !(message.period && $util.isInteger(message.period.low) && $util.isInteger(message.period.high)))\n                        return \"period: integer|Long expected\";\n                if (message.comment != null && message.hasOwnProperty(\"comment\")) {\n                    if (!Array.isArray(message.comment))\n                        return \"comment: array expected\";\n                    for (var i = 0; i < message.comment.length; ++i)\n                        if (!$util.isInteger(message.comment[i]) && !(message.comment[i] && $util.isInteger(message.comment[i].low) && $util.isInteger(message.comment[i].high)))\n                            return \"comment: integer|Long[] expected\";\n                }\n                if (message.defaultSampleType != null && message.hasOwnProperty(\"defaultSampleType\"))\n                    if (!$util.isInteger(message.defaultSampleType) && !(message.defaultSampleType && $util.isInteger(message.defaultSampleType.low) && $util.isInteger(message.defaultSampleType.high)))\n                        return \"defaultSampleType: integer|Long expected\";\n                return null;\n            };\n\n            /**\n             * Creates a Profile message from a plain object. Also converts values to their respective internal types.\n             * @function fromObject\n             * @memberof perftools.profiles.Profile\n             * @static\n             * @param {Object.<string,*>} object Plain object\n             * @returns {perftools.profiles.Profile} Profile\n             */\n            Profile.fromObject = function fromObject(object) {\n                if (object instanceof $root.perftools.profiles.Profile)\n                    return object;\n                var message = new $root.perftools.profiles.Profile();\n                if (object.sampleType) {\n                    if (!Array.isArray(object.sampleType))\n                        throw TypeError(\".perftools.profiles.Profile.sampleType: array expected\");\n                    message.sampleType = [];\n                    for (var i = 0; i < object.sampleType.length; ++i) {\n                        if (typeof object.sampleType[i] !== \"object\")\n                            throw TypeError(\".perftools.profiles.Profile.sampleType: object expected\");\n                        message.sampleType[i] = $root.perftools.profiles.ValueType.fromObject(object.sampleType[i]);\n                    }\n                }\n                if (object.sample) {\n                    if (!Array.isArray(object.sample))\n                        throw TypeError(\".perftools.profiles.Profile.sample: array expected\");\n                    message.sample = [];\n                    for (var i = 0; i < object.sample.length; ++i) {\n                        if (typeof object.sample[i] !== \"object\")\n                            throw TypeError(\".perftools.profiles.Profile.sample: object expected\");\n                        message.sample[i] = $root.perftools.profiles.Sample.fromObject(object.sample[i]);\n                    }\n                }\n                if (object.mapping) {\n                    if (!Array.isArray(object.mapping))\n                        throw TypeError(\".perftools.profiles.Profile.mapping: array expected\");\n                    message.mapping = [];\n                    for (var i = 0; i < object.mapping.length; ++i) {\n                        if (typeof object.mapping[i] !== \"object\")\n                            throw TypeError(\".perftools.profiles.Profile.mapping: object expected\");\n                        message.mapping[i] = $root.perftools.profiles.Mapping.fromObject(object.mapping[i]);\n                    }\n                }\n                if (object.location) {\n                    if (!Array.isArray(object.location))\n                        throw TypeError(\".perftools.profiles.Profile.location: array expected\");\n                    message.location = [];\n                    for (var i = 0; i < object.location.length; ++i) {\n                        if (typeof object.location[i] !== \"object\")\n                            throw TypeError(\".perftools.profiles.Profile.location: object expected\");\n                        message.location[i] = $root.perftools.profiles.Location.fromObject(object.location[i]);\n                    }\n                }\n                if (object[\"function\"]) {\n                    if (!Array.isArray(object[\"function\"]))\n                        throw TypeError(\".perftools.profiles.Profile.function: array expected\");\n                    message[\"function\"] = [];\n                    for (var i = 0; i < object[\"function\"].length; ++i) {\n                        if (typeof object[\"function\"][i] !== \"object\")\n                            throw TypeError(\".perftools.profiles.Profile.function: object expected\");\n                        message[\"function\"][i] = $root.perftools.profiles.Function.fromObject(object[\"function\"][i]);\n                    }\n                }\n                if (object.stringTable) {\n                    if (!Array.isArray(object.stringTable))\n                        throw TypeError(\".perftools.profiles.Profile.stringTable: array expected\");\n                    message.stringTable = [];\n                    for (var i = 0; i < object.stringTable.length; ++i)\n                        message.stringTable[i] = String(object.stringTable[i]);\n                }\n                if (object.dropFrames != null)\n                    if ($util.Long)\n                        (message.dropFrames = $util.Long.fromValue(object.dropFrames)).unsigned = false;\n                    else if (typeof object.dropFrames === \"string\")\n                        message.dropFrames = parseInt(object.dropFrames, 10);\n                    else if (typeof object.dropFrames === \"number\")\n                        message.dropFrames = object.dropFrames;\n                    else if (typeof object.dropFrames === \"object\")\n                        message.dropFrames = new $util.LongBits(object.dropFrames.low >>> 0, object.dropFrames.high >>> 0).toNumber();\n                if (object.keepFrames != null)\n                    if ($util.Long)\n                        (message.keepFrames = $util.Long.fromValue(object.keepFrames)).unsigned = false;\n                    else if (typeof object.keepFrames === \"string\")\n                        message.keepFrames = parseInt(object.keepFrames, 10);\n                    else if (typeof object.keepFrames === \"number\")\n                        message.keepFrames = object.keepFrames;\n                    else if (typeof object.keepFrames === \"object\")\n                        message.keepFrames = new $util.LongBits(object.keepFrames.low >>> 0, object.keepFrames.high >>> 0).toNumber();\n                if (object.timeNanos != null)\n                    if ($util.Long)\n                        (message.timeNanos = $util.Long.fromValue(object.timeNanos)).unsigned = false;\n                    else if (typeof object.timeNanos === \"string\")\n                        message.timeNanos = parseInt(object.timeNanos, 10);\n                    else if (typeof object.timeNanos === \"number\")\n                        message.timeNanos = object.timeNanos;\n                    else if (typeof object.timeNanos === \"object\")\n                        message.timeNanos = new $util.LongBits(object.timeNanos.low >>> 0, object.timeNanos.high >>> 0).toNumber();\n                if (object.durationNanos != null)\n                    if ($util.Long)\n                        (message.durationNanos = $util.Long.fromValue(object.durationNanos)).unsigned = false;\n                    else if (typeof object.durationNanos === \"string\")\n                        message.durationNanos = parseInt(object.durationNanos, 10);\n                    else if (typeof object.durationNanos === \"number\")\n                        message.durationNanos = object.durationNanos;\n                    else if (typeof object.durationNanos === \"object\")\n                        message.durationNanos = new $util.LongBits(object.durationNanos.low >>> 0, object.durationNanos.high >>> 0).toNumber();\n                if (object.periodType != null) {\n                    if (typeof object.periodType !== \"object\")\n                        throw TypeError(\".perftools.profiles.Profile.periodType: object expected\");\n                    message.periodType = $root.perftools.profiles.ValueType.fromObject(object.periodType);\n                }\n                if (object.period != null)\n                    if ($util.Long)\n                        (message.period = $util.Long.fromValue(object.period)).unsigned = false;\n                    else if (typeof object.period === \"string\")\n                        message.period = parseInt(object.period, 10);\n                    else if (typeof object.period === \"number\")\n                        message.period = object.period;\n                    else if (typeof object.period === \"object\")\n                        message.period = new $util.LongBits(object.period.low >>> 0, object.period.high >>> 0).toNumber();\n                if (object.comment) {\n                    if (!Array.isArray(object.comment))\n                        throw TypeError(\".perftools.profiles.Profile.comment: array expected\");\n                    message.comment = [];\n                    for (var i = 0; i < object.comment.length; ++i)\n                        if ($util.Long)\n                            (message.comment[i] = $util.Long.fromValue(object.comment[i])).unsigned = false;\n                        else if (typeof object.comment[i] === \"string\")\n                            message.comment[i] = parseInt(object.comment[i], 10);\n                        else if (typeof object.comment[i] === \"number\")\n                            message.comment[i] = object.comment[i];\n                        else if (typeof object.comment[i] === \"object\")\n                            message.comment[i] = new $util.LongBits(object.comment[i].low >>> 0, object.comment[i].high >>> 0).toNumber();\n                }\n                if (object.defaultSampleType != null)\n                    if ($util.Long)\n                        (message.defaultSampleType = $util.Long.fromValue(object.defaultSampleType)).unsigned = false;\n                    else if (typeof object.defaultSampleType === \"string\")\n                        message.defaultSampleType = parseInt(object.defaultSampleType, 10);\n                    else if (typeof object.defaultSampleType === \"number\")\n                        message.defaultSampleType = object.defaultSampleType;\n                    else if (typeof object.defaultSampleType === \"object\")\n                        message.defaultSampleType = new $util.LongBits(object.defaultSampleType.low >>> 0, object.defaultSampleType.high >>> 0).toNumber();\n                return message;\n            };\n\n            /**\n             * Creates a plain object from a Profile message. Also converts values to other types if specified.\n             * @function toObject\n             * @memberof perftools.profiles.Profile\n             * @static\n             * @param {perftools.profiles.Profile} message Profile\n             * @param {$protobuf.IConversionOptions} [options] Conversion options\n             * @returns {Object.<string,*>} Plain object\n             */\n            Profile.toObject = function toObject(message, options) {\n                if (!options)\n                    options = {};\n                var object = {};\n                if (options.arrays || options.defaults) {\n                    object.sampleType = [];\n                    object.sample = [];\n                    object.mapping = [];\n                    object.location = [];\n                    object[\"function\"] = [];\n                    object.stringTable = [];\n                    object.comment = [];\n                }\n                if (options.defaults) {\n                    if ($util.Long) {\n                        var long = new $util.Long(0, 0, false);\n                        object.dropFrames = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                    } else\n                        object.dropFrames = options.longs === String ? \"0\" : 0;\n                    if ($util.Long) {\n                        var long = new $util.Long(0, 0, false);\n                        object.keepFrames = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                    } else\n                        object.keepFrames = options.longs === String ? \"0\" : 0;\n                    if ($util.Long) {\n                        var long = new $util.Long(0, 0, false);\n                        object.timeNanos = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                    } else\n                        object.timeNanos = options.longs === String ? \"0\" : 0;\n                    if ($util.Long) {\n                        var long = new $util.Long(0, 0, false);\n                        object.durationNanos = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                    } else\n                        object.durationNanos = options.longs === String ? \"0\" : 0;\n                    object.periodType = null;\n                    if ($util.Long) {\n                        var long = new $util.Long(0, 0, false);\n                        object.period = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                    } else\n                        object.period = options.longs === String ? \"0\" : 0;\n                    if ($util.Long) {\n                        var long = new $util.Long(0, 0, false);\n                        object.defaultSampleType = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                    } else\n                        object.defaultSampleType = options.longs === String ? \"0\" : 0;\n                }\n                if (message.sampleType && message.sampleType.length) {\n                    object.sampleType = [];\n                    for (var j = 0; j < message.sampleType.length; ++j)\n                        object.sampleType[j] = $root.perftools.profiles.ValueType.toObject(message.sampleType[j], options);\n                }\n                if (message.sample && message.sample.length) {\n                    object.sample = [];\n                    for (var j = 0; j < message.sample.length; ++j)\n                        object.sample[j] = $root.perftools.profiles.Sample.toObject(message.sample[j], options);\n                }\n                if (message.mapping && message.mapping.length) {\n                    object.mapping = [];\n                    for (var j = 0; j < message.mapping.length; ++j)\n                        object.mapping[j] = $root.perftools.profiles.Mapping.toObject(message.mapping[j], options);\n                }\n                if (message.location && message.location.length) {\n                    object.location = [];\n                    for (var j = 0; j < message.location.length; ++j)\n                        object.location[j] = $root.perftools.profiles.Location.toObject(message.location[j], options);\n                }\n                if (message[\"function\"] && message[\"function\"].length) {\n                    object[\"function\"] = [];\n                    for (var j = 0; j < message[\"function\"].length; ++j)\n                        object[\"function\"][j] = $root.perftools.profiles.Function.toObject(message[\"function\"][j], options);\n                }\n                if (message.stringTable && message.stringTable.length) {\n                    object.stringTable = [];\n                    for (var j = 0; j < message.stringTable.length; ++j)\n                        object.stringTable[j] = message.stringTable[j];\n                }\n                if (message.dropFrames != null && message.hasOwnProperty(\"dropFrames\"))\n                    if (typeof message.dropFrames === \"number\")\n                        object.dropFrames = options.longs === String ? String(message.dropFrames) : message.dropFrames;\n                    else\n                        object.dropFrames = options.longs === String ? $util.Long.prototype.toString.call(message.dropFrames) : options.longs === Number ? new $util.LongBits(message.dropFrames.low >>> 0, message.dropFrames.high >>> 0).toNumber() : message.dropFrames;\n                if (message.keepFrames != null && message.hasOwnProperty(\"keepFrames\"))\n                    if (typeof message.keepFrames === \"number\")\n                        object.keepFrames = options.longs === String ? String(message.keepFrames) : message.keepFrames;\n                    else\n                        object.keepFrames = options.longs === String ? $util.Long.prototype.toString.call(message.keepFrames) : options.longs === Number ? new $util.LongBits(message.keepFrames.low >>> 0, message.keepFrames.high >>> 0).toNumber() : message.keepFrames;\n                if (message.timeNanos != null && message.hasOwnProperty(\"timeNanos\"))\n                    if (typeof message.timeNanos === \"number\")\n                        object.timeNanos = options.longs === String ? String(message.timeNanos) : message.timeNanos;\n                    else\n                        object.timeNanos = options.longs === String ? $util.Long.prototype.toString.call(message.timeNanos) : options.longs === Number ? new $util.LongBits(message.timeNanos.low >>> 0, message.timeNanos.high >>> 0).toNumber() : message.timeNanos;\n                if (message.durationNanos != null && message.hasOwnProperty(\"durationNanos\"))\n                    if (typeof message.durationNanos === \"number\")\n                        object.durationNanos = options.longs === String ? String(message.durationNanos) : message.durationNanos;\n                    else\n                        object.durationNanos = options.longs === String ? $util.Long.prototype.toString.call(message.durationNanos) : options.longs === Number ? new $util.LongBits(message.durationNanos.low >>> 0, message.durationNanos.high >>> 0).toNumber() : message.durationNanos;\n                if (message.periodType != null && message.hasOwnProperty(\"periodType\"))\n                    object.periodType = $root.perftools.profiles.ValueType.toObject(message.periodType, options);\n                if (message.period != null && message.hasOwnProperty(\"period\"))\n                    if (typeof message.period === \"number\")\n                        object.period = options.longs === String ? String(message.period) : message.period;\n                    else\n                        object.period = options.longs === String ? $util.Long.prototype.toString.call(message.period) : options.longs === Number ? new $util.LongBits(message.period.low >>> 0, message.period.high >>> 0).toNumber() : message.period;\n                if (message.comment && message.comment.length) {\n                    object.comment = [];\n                    for (var j = 0; j < message.comment.length; ++j)\n                        if (typeof message.comment[j] === \"number\")\n                            object.comment[j] = options.longs === String ? String(message.comment[j]) : message.comment[j];\n                        else\n                            object.comment[j] = options.longs === String ? $util.Long.prototype.toString.call(message.comment[j]) : options.longs === Number ? new $util.LongBits(message.comment[j].low >>> 0, message.comment[j].high >>> 0).toNumber() : message.comment[j];\n                }\n                if (message.defaultSampleType != null && message.hasOwnProperty(\"defaultSampleType\"))\n                    if (typeof message.defaultSampleType === \"number\")\n                        object.defaultSampleType = options.longs === String ? String(message.defaultSampleType) : message.defaultSampleType;\n                    else\n                        object.defaultSampleType = options.longs === String ? $util.Long.prototype.toString.call(message.defaultSampleType) : options.longs === Number ? new $util.LongBits(message.defaultSampleType.low >>> 0, message.defaultSampleType.high >>> 0).toNumber() : message.defaultSampleType;\n                return object;\n            };\n\n            /**\n             * Converts this Profile to JSON.\n             * @function toJSON\n             * @memberof perftools.profiles.Profile\n             * @instance\n             * @returns {Object.<string,*>} JSON object\n             */\n            Profile.prototype.toJSON = function toJSON() {\n                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n            };\n\n            return Profile;\n        })();\n\n        profiles.ValueType = (function() {\n\n            /**\n             * Properties of a ValueType.\n             * @memberof perftools.profiles\n             * @interface IValueType\n             * @property {number|Long|null} [type] ValueType type\n             * @property {number|Long|null} [unit] ValueType unit\n             */\n\n            /**\n             * Constructs a new ValueType.\n             * @memberof perftools.profiles\n             * @classdesc Represents a ValueType.\n             * @implements IValueType\n             * @constructor\n             * @param {perftools.profiles.IValueType=} [properties] Properties to set\n             */\n            function ValueType(properties) {\n                if (properties)\n                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }\n\n            /**\n             * ValueType type.\n             * @member {number|Long} type\n             * @memberof perftools.profiles.ValueType\n             * @instance\n             */\n            ValueType.prototype.type = $util.Long ? $util.Long.fromBits(0,0,false) : 0;\n\n            /**\n             * ValueType unit.\n             * @member {number|Long} unit\n             * @memberof perftools.profiles.ValueType\n             * @instance\n             */\n            ValueType.prototype.unit = $util.Long ? $util.Long.fromBits(0,0,false) : 0;\n\n            /**\n             * Creates a new ValueType instance using the specified properties.\n             * @function create\n             * @memberof perftools.profiles.ValueType\n             * @static\n             * @param {perftools.profiles.IValueType=} [properties] Properties to set\n             * @returns {perftools.profiles.ValueType} ValueType instance\n             */\n            ValueType.create = function create(properties) {\n                return new ValueType(properties);\n            };\n\n            /**\n             * Encodes the specified ValueType message. Does not implicitly {@link perftools.profiles.ValueType.verify|verify} messages.\n             * @function encode\n             * @memberof perftools.profiles.ValueType\n             * @static\n             * @param {perftools.profiles.IValueType} message ValueType message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            ValueType.encode = function encode(message, writer) {\n                if (!writer)\n                    writer = $Writer.create();\n                if (message.type != null && Object.hasOwnProperty.call(message, \"type\"))\n                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.type);\n                if (message.unit != null && Object.hasOwnProperty.call(message, \"unit\"))\n                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.unit);\n                return writer;\n            };\n\n            /**\n             * Encodes the specified ValueType message, length delimited. Does not implicitly {@link perftools.profiles.ValueType.verify|verify} messages.\n             * @function encodeDelimited\n             * @memberof perftools.profiles.ValueType\n             * @static\n             * @param {perftools.profiles.IValueType} message ValueType message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            ValueType.encodeDelimited = function encodeDelimited(message, writer) {\n                return this.encode(message, writer).ldelim();\n            };\n\n            /**\n             * Decodes a ValueType message from the specified reader or buffer.\n             * @function decode\n             * @memberof perftools.profiles.ValueType\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {perftools.profiles.ValueType} ValueType\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            ValueType.decode = function decode(reader, length) {\n                if (!(reader instanceof $Reader))\n                    reader = $Reader.create(reader);\n                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.perftools.profiles.ValueType();\n                while (reader.pos < end) {\n                    var tag = reader.uint32();\n                    switch (tag >>> 3) {\n                    case 1:\n                        message.type = reader.int64();\n                        break;\n                    case 2:\n                        message.unit = reader.int64();\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                    }\n                }\n                return message;\n            };\n\n            /**\n             * Decodes a ValueType message from the specified reader or buffer, length delimited.\n             * @function decodeDelimited\n             * @memberof perftools.profiles.ValueType\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @returns {perftools.profiles.ValueType} ValueType\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            ValueType.decodeDelimited = function decodeDelimited(reader) {\n                if (!(reader instanceof $Reader))\n                    reader = new $Reader(reader);\n                return this.decode(reader, reader.uint32());\n            };\n\n            /**\n             * Verifies a ValueType message.\n             * @function verify\n             * @memberof perftools.profiles.ValueType\n             * @static\n             * @param {Object.<string,*>} message Plain object to verify\n             * @returns {string|null} `null` if valid, otherwise the reason why it is not\n             */\n            ValueType.verify = function verify(message) {\n                if (typeof message !== \"object\" || message === null)\n                    return \"object expected\";\n                if (message.type != null && message.hasOwnProperty(\"type\"))\n                    if (!$util.isInteger(message.type) && !(message.type && $util.isInteger(message.type.low) && $util.isInteger(message.type.high)))\n                        return \"type: integer|Long expected\";\n                if (message.unit != null && message.hasOwnProperty(\"unit\"))\n                    if (!$util.isInteger(message.unit) && !(message.unit && $util.isInteger(message.unit.low) && $util.isInteger(message.unit.high)))\n                        return \"unit: integer|Long expected\";\n                return null;\n            };\n\n            /**\n             * Creates a ValueType message from a plain object. Also converts values to their respective internal types.\n             * @function fromObject\n             * @memberof perftools.profiles.ValueType\n             * @static\n             * @param {Object.<string,*>} object Plain object\n             * @returns {perftools.profiles.ValueType} ValueType\n             */\n            ValueType.fromObject = function fromObject(object) {\n                if (object instanceof $root.perftools.profiles.ValueType)\n                    return object;\n                var message = new $root.perftools.profiles.ValueType();\n                if (object.type != null)\n                    if ($util.Long)\n                        (message.type = $util.Long.fromValue(object.type)).unsigned = false;\n                    else if (typeof object.type === \"string\")\n                        message.type = parseInt(object.type, 10);\n                    else if (typeof object.type === \"number\")\n                        message.type = object.type;\n                    else if (typeof object.type === \"object\")\n                        message.type = new $util.LongBits(object.type.low >>> 0, object.type.high >>> 0).toNumber();\n                if (object.unit != null)\n                    if ($util.Long)\n                        (message.unit = $util.Long.fromValue(object.unit)).unsigned = false;\n                    else if (typeof object.unit === \"string\")\n                        message.unit = parseInt(object.unit, 10);\n                    else if (typeof object.unit === \"number\")\n                        message.unit = object.unit;\n                    else if (typeof object.unit === \"object\")\n                        message.unit = new $util.LongBits(object.unit.low >>> 0, object.unit.high >>> 0).toNumber();\n                return message;\n            };\n\n            /**\n             * Creates a plain object from a ValueType message. Also converts values to other types if specified.\n             * @function toObject\n             * @memberof perftools.profiles.ValueType\n             * @static\n             * @param {perftools.profiles.ValueType} message ValueType\n             * @param {$protobuf.IConversionOptions} [options] Conversion options\n             * @returns {Object.<string,*>} Plain object\n             */\n            ValueType.toObject = function toObject(message, options) {\n                if (!options)\n                    options = {};\n                var object = {};\n                if (options.defaults) {\n                    if ($util.Long) {\n                        var long = new $util.Long(0, 0, false);\n                        object.type = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                    } else\n                        object.type = options.longs === String ? \"0\" : 0;\n                    if ($util.Long) {\n                        var long = new $util.Long(0, 0, false);\n                        object.unit = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                    } else\n                        object.unit = options.longs === String ? \"0\" : 0;\n                }\n                if (message.type != null && message.hasOwnProperty(\"type\"))\n                    if (typeof message.type === \"number\")\n                        object.type = options.longs === String ? String(message.type) : message.type;\n                    else\n                        object.type = options.longs === String ? $util.Long.prototype.toString.call(message.type) : options.longs === Number ? new $util.LongBits(message.type.low >>> 0, message.type.high >>> 0).toNumber() : message.type;\n                if (message.unit != null && message.hasOwnProperty(\"unit\"))\n                    if (typeof message.unit === \"number\")\n                        object.unit = options.longs === String ? String(message.unit) : message.unit;\n                    else\n                        object.unit = options.longs === String ? $util.Long.prototype.toString.call(message.unit) : options.longs === Number ? new $util.LongBits(message.unit.low >>> 0, message.unit.high >>> 0).toNumber() : message.unit;\n                return object;\n            };\n\n            /**\n             * Converts this ValueType to JSON.\n             * @function toJSON\n             * @memberof perftools.profiles.ValueType\n             * @instance\n             * @returns {Object.<string,*>} JSON object\n             */\n            ValueType.prototype.toJSON = function toJSON() {\n                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n            };\n\n            return ValueType;\n        })();\n\n        profiles.Sample = (function() {\n\n            /**\n             * Properties of a Sample.\n             * @memberof perftools.profiles\n             * @interface ISample\n             * @property {Array.<number|Long>|null} [locationId] Sample locationId\n             * @property {Array.<number|Long>|null} [value] Sample value\n             * @property {Array.<perftools.profiles.ILabel>|null} [label] Sample label\n             */\n\n            /**\n             * Constructs a new Sample.\n             * @memberof perftools.profiles\n             * @classdesc Represents a Sample.\n             * @implements ISample\n             * @constructor\n             * @param {perftools.profiles.ISample=} [properties] Properties to set\n             */\n            function Sample(properties) {\n                this.locationId = [];\n                this.value = [];\n                this.label = [];\n                if (properties)\n                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }\n\n            /**\n             * Sample locationId.\n             * @member {Array.<number|Long>} locationId\n             * @memberof perftools.profiles.Sample\n             * @instance\n             */\n            Sample.prototype.locationId = $util.emptyArray;\n\n            /**\n             * Sample value.\n             * @member {Array.<number|Long>} value\n             * @memberof perftools.profiles.Sample\n             * @instance\n             */\n            Sample.prototype.value = $util.emptyArray;\n\n            /**\n             * Sample label.\n             * @member {Array.<perftools.profiles.ILabel>} label\n             * @memberof perftools.profiles.Sample\n             * @instance\n             */\n            Sample.prototype.label = $util.emptyArray;\n\n            /**\n             * Creates a new Sample instance using the specified properties.\n             * @function create\n             * @memberof perftools.profiles.Sample\n             * @static\n             * @param {perftools.profiles.ISample=} [properties] Properties to set\n             * @returns {perftools.profiles.Sample} Sample instance\n             */\n            Sample.create = function create(properties) {\n                return new Sample(properties);\n            };\n\n            /**\n             * Encodes the specified Sample message. Does not implicitly {@link perftools.profiles.Sample.verify|verify} messages.\n             * @function encode\n             * @memberof perftools.profiles.Sample\n             * @static\n             * @param {perftools.profiles.ISample} message Sample message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            Sample.encode = function encode(message, writer) {\n                if (!writer)\n                    writer = $Writer.create();\n                if (message.locationId != null && message.locationId.length) {\n                    writer.uint32(/* id 1, wireType 2 =*/10).fork();\n                    for (var i = 0; i < message.locationId.length; ++i)\n                        writer.uint64(message.locationId[i]);\n                    writer.ldelim();\n                }\n                if (message.value != null && message.value.length) {\n                    writer.uint32(/* id 2, wireType 2 =*/18).fork();\n                    for (var i = 0; i < message.value.length; ++i)\n                        writer.int64(message.value[i]);\n                    writer.ldelim();\n                }\n                if (message.label != null && message.label.length)\n                    for (var i = 0; i < message.label.length; ++i)\n                        $root.perftools.profiles.Label.encode(message.label[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();\n                return writer;\n            };\n\n            /**\n             * Encodes the specified Sample message, length delimited. Does not implicitly {@link perftools.profiles.Sample.verify|verify} messages.\n             * @function encodeDelimited\n             * @memberof perftools.profiles.Sample\n             * @static\n             * @param {perftools.profiles.ISample} message Sample message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            Sample.encodeDelimited = function encodeDelimited(message, writer) {\n                return this.encode(message, writer).ldelim();\n            };\n\n            /**\n             * Decodes a Sample message from the specified reader or buffer.\n             * @function decode\n             * @memberof perftools.profiles.Sample\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {perftools.profiles.Sample} Sample\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            Sample.decode = function decode(reader, length) {\n                if (!(reader instanceof $Reader))\n                    reader = $Reader.create(reader);\n                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.perftools.profiles.Sample();\n                while (reader.pos < end) {\n                    var tag = reader.uint32();\n                    switch (tag >>> 3) {\n                    case 1:\n                        if (!(message.locationId && message.locationId.length))\n                            message.locationId = [];\n                        if ((tag & 7) === 2) {\n                            var end2 = reader.uint32() + reader.pos;\n                            while (reader.pos < end2)\n                                message.locationId.push(reader.uint64());\n                        } else\n                            message.locationId.push(reader.uint64());\n                        break;\n                    case 2:\n                        if (!(message.value && message.value.length))\n                            message.value = [];\n                        if ((tag & 7) === 2) {\n                            var end2 = reader.uint32() + reader.pos;\n                            while (reader.pos < end2)\n                                message.value.push(reader.int64());\n                        } else\n                            message.value.push(reader.int64());\n                        break;\n                    case 3:\n                        if (!(message.label && message.label.length))\n                            message.label = [];\n                        message.label.push($root.perftools.profiles.Label.decode(reader, reader.uint32()));\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                    }\n                }\n                return message;\n            };\n\n            /**\n             * Decodes a Sample message from the specified reader or buffer, length delimited.\n             * @function decodeDelimited\n             * @memberof perftools.profiles.Sample\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @returns {perftools.profiles.Sample} Sample\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            Sample.decodeDelimited = function decodeDelimited(reader) {\n                if (!(reader instanceof $Reader))\n                    reader = new $Reader(reader);\n                return this.decode(reader, reader.uint32());\n            };\n\n            /**\n             * Verifies a Sample message.\n             * @function verify\n             * @memberof perftools.profiles.Sample\n             * @static\n             * @param {Object.<string,*>} message Plain object to verify\n             * @returns {string|null} `null` if valid, otherwise the reason why it is not\n             */\n            Sample.verify = function verify(message) {\n                if (typeof message !== \"object\" || message === null)\n                    return \"object expected\";\n                if (message.locationId != null && message.hasOwnProperty(\"locationId\")) {\n                    if (!Array.isArray(message.locationId))\n                        return \"locationId: array expected\";\n                    for (var i = 0; i < message.locationId.length; ++i)\n                        if (!$util.isInteger(message.locationId[i]) && !(message.locationId[i] && $util.isInteger(message.locationId[i].low) && $util.isInteger(message.locationId[i].high)))\n                            return \"locationId: integer|Long[] expected\";\n                }\n                if (message.value != null && message.hasOwnProperty(\"value\")) {\n                    if (!Array.isArray(message.value))\n                        return \"value: array expected\";\n                    for (var i = 0; i < message.value.length; ++i)\n                        if (!$util.isInteger(message.value[i]) && !(message.value[i] && $util.isInteger(message.value[i].low) && $util.isInteger(message.value[i].high)))\n                            return \"value: integer|Long[] expected\";\n                }\n                if (message.label != null && message.hasOwnProperty(\"label\")) {\n                    if (!Array.isArray(message.label))\n                        return \"label: array expected\";\n                    for (var i = 0; i < message.label.length; ++i) {\n                        var error = $root.perftools.profiles.Label.verify(message.label[i]);\n                        if (error)\n                            return \"label.\" + error;\n                    }\n                }\n                return null;\n            };\n\n            /**\n             * Creates a Sample message from a plain object. Also converts values to their respective internal types.\n             * @function fromObject\n             * @memberof perftools.profiles.Sample\n             * @static\n             * @param {Object.<string,*>} object Plain object\n             * @returns {perftools.profiles.Sample} Sample\n             */\n            Sample.fromObject = function fromObject(object) {\n                if (object instanceof $root.perftools.profiles.Sample)\n                    return object;\n                var message = new $root.perftools.profiles.Sample();\n                if (object.locationId) {\n                    if (!Array.isArray(object.locationId))\n                        throw TypeError(\".perftools.profiles.Sample.locationId: array expected\");\n                    message.locationId = [];\n                    for (var i = 0; i < object.locationId.length; ++i)\n                        if ($util.Long)\n                            (message.locationId[i] = $util.Long.fromValue(object.locationId[i])).unsigned = true;\n                        else if (typeof object.locationId[i] === \"string\")\n                            message.locationId[i] = parseInt(object.locationId[i], 10);\n                        else if (typeof object.locationId[i] === \"number\")\n                            message.locationId[i] = object.locationId[i];\n                        else if (typeof object.locationId[i] === \"object\")\n                            message.locationId[i] = new $util.LongBits(object.locationId[i].low >>> 0, object.locationId[i].high >>> 0).toNumber(true);\n                }\n                if (object.value) {\n                    if (!Array.isArray(object.value))\n                        throw TypeError(\".perftools.profiles.Sample.value: array expected\");\n                    message.value = [];\n                    for (var i = 0; i < object.value.length; ++i)\n                        if ($util.Long)\n                            (message.value[i] = $util.Long.fromValue(object.value[i])).unsigned = false;\n                        else if (typeof object.value[i] === \"string\")\n                            message.value[i] = parseInt(object.value[i], 10);\n                        else if (typeof object.value[i] === \"number\")\n                            message.value[i] = object.value[i];\n                        else if (typeof object.value[i] === \"object\")\n                            message.value[i] = new $util.LongBits(object.value[i].low >>> 0, object.value[i].high >>> 0).toNumber();\n                }\n                if (object.label) {\n                    if (!Array.isArray(object.label))\n                        throw TypeError(\".perftools.profiles.Sample.label: array expected\");\n                    message.label = [];\n                    for (var i = 0; i < object.label.length; ++i) {\n                        if (typeof object.label[i] !== \"object\")\n                            throw TypeError(\".perftools.profiles.Sample.label: object expected\");\n                        message.label[i] = $root.perftools.profiles.Label.fromObject(object.label[i]);\n                    }\n                }\n                return message;\n            };\n\n            /**\n             * Creates a plain object from a Sample message. Also converts values to other types if specified.\n             * @function toObject\n             * @memberof perftools.profiles.Sample\n             * @static\n             * @param {perftools.profiles.Sample} message Sample\n             * @param {$protobuf.IConversionOptions} [options] Conversion options\n             * @returns {Object.<string,*>} Plain object\n             */\n            Sample.toObject = function toObject(message, options) {\n                if (!options)\n                    options = {};\n                var object = {};\n                if (options.arrays || options.defaults) {\n                    object.locationId = [];\n                    object.value = [];\n                    object.label = [];\n                }\n                if (message.locationId && message.locationId.length) {\n                    object.locationId = [];\n                    for (var j = 0; j < message.locationId.length; ++j)\n                        if (typeof message.locationId[j] === \"number\")\n                            object.locationId[j] = options.longs === String ? String(message.locationId[j]) : message.locationId[j];\n                        else\n                            object.locationId[j] = options.longs === String ? $util.Long.prototype.toString.call(message.locationId[j]) : options.longs === Number ? new $util.LongBits(message.locationId[j].low >>> 0, message.locationId[j].high >>> 0).toNumber(true) : message.locationId[j];\n                }\n                if (message.value && message.value.length) {\n                    object.value = [];\n                    for (var j = 0; j < message.value.length; ++j)\n                        if (typeof message.value[j] === \"number\")\n                            object.value[j] = options.longs === String ? String(message.value[j]) : message.value[j];\n                        else\n                            object.value[j] = options.longs === String ? $util.Long.prototype.toString.call(message.value[j]) : options.longs === Number ? new $util.LongBits(message.value[j].low >>> 0, message.value[j].high >>> 0).toNumber() : message.value[j];\n                }\n                if (message.label && message.label.length) {\n                    object.label = [];\n                    for (var j = 0; j < message.label.length; ++j)\n                        object.label[j] = $root.perftools.profiles.Label.toObject(message.label[j], options);\n                }\n                return object;\n            };\n\n            /**\n             * Converts this Sample to JSON.\n             * @function toJSON\n             * @memberof perftools.profiles.Sample\n             * @instance\n             * @returns {Object.<string,*>} JSON object\n             */\n            Sample.prototype.toJSON = function toJSON() {\n                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n            };\n\n            return Sample;\n        })();\n\n        profiles.Label = (function() {\n\n            /**\n             * Properties of a Label.\n             * @memberof perftools.profiles\n             * @interface ILabel\n             * @property {number|Long|null} [key] Label key\n             * @property {number|Long|null} [str] Label str\n             * @property {number|Long|null} [num] Label num\n             * @property {number|Long|null} [numUnit] Label numUnit\n             */\n\n            /**\n             * Constructs a new Label.\n             * @memberof perftools.profiles\n             * @classdesc Represents a Label.\n             * @implements ILabel\n             * @constructor\n             * @param {perftools.profiles.ILabel=} [properties] Properties to set\n             */\n            function Label(properties) {\n                if (properties)\n                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }\n\n            /**\n             * Label key.\n             * @member {number|Long} key\n             * @memberof perftools.profiles.Label\n             * @instance\n             */\n            Label.prototype.key = $util.Long ? $util.Long.fromBits(0,0,false) : 0;\n\n            /**\n             * Label str.\n             * @member {number|Long} str\n             * @memberof perftools.profiles.Label\n             * @instance\n             */\n            Label.prototype.str = $util.Long ? $util.Long.fromBits(0,0,false) : 0;\n\n            /**\n             * Label num.\n             * @member {number|Long} num\n             * @memberof perftools.profiles.Label\n             * @instance\n             */\n            Label.prototype.num = $util.Long ? $util.Long.fromBits(0,0,false) : 0;\n\n            /**\n             * Label numUnit.\n             * @member {number|Long} numUnit\n             * @memberof perftools.profiles.Label\n             * @instance\n             */\n            Label.prototype.numUnit = $util.Long ? $util.Long.fromBits(0,0,false) : 0;\n\n            /**\n             * Creates a new Label instance using the specified properties.\n             * @function create\n             * @memberof perftools.profiles.Label\n             * @static\n             * @param {perftools.profiles.ILabel=} [properties] Properties to set\n             * @returns {perftools.profiles.Label} Label instance\n             */\n            Label.create = function create(properties) {\n                return new Label(properties);\n            };\n\n            /**\n             * Encodes the specified Label message. Does not implicitly {@link perftools.profiles.Label.verify|verify} messages.\n             * @function encode\n             * @memberof perftools.profiles.Label\n             * @static\n             * @param {perftools.profiles.ILabel} message Label message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            Label.encode = function encode(message, writer) {\n                if (!writer)\n                    writer = $Writer.create();\n                if (message.key != null && Object.hasOwnProperty.call(message, \"key\"))\n                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.key);\n                if (message.str != null && Object.hasOwnProperty.call(message, \"str\"))\n                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.str);\n                if (message.num != null && Object.hasOwnProperty.call(message, \"num\"))\n                    writer.uint32(/* id 3, wireType 0 =*/24).int64(message.num);\n                if (message.numUnit != null && Object.hasOwnProperty.call(message, \"numUnit\"))\n                    writer.uint32(/* id 4, wireType 0 =*/32).int64(message.numUnit);\n                return writer;\n            };\n\n            /**\n             * Encodes the specified Label message, length delimited. Does not implicitly {@link perftools.profiles.Label.verify|verify} messages.\n             * @function encodeDelimited\n             * @memberof perftools.profiles.Label\n             * @static\n             * @param {perftools.profiles.ILabel} message Label message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            Label.encodeDelimited = function encodeDelimited(message, writer) {\n                return this.encode(message, writer).ldelim();\n            };\n\n            /**\n             * Decodes a Label message from the specified reader or buffer.\n             * @function decode\n             * @memberof perftools.profiles.Label\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {perftools.profiles.Label} Label\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            Label.decode = function decode(reader, length) {\n                if (!(reader instanceof $Reader))\n                    reader = $Reader.create(reader);\n                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.perftools.profiles.Label();\n                while (reader.pos < end) {\n                    var tag = reader.uint32();\n                    switch (tag >>> 3) {\n                    case 1:\n                        message.key = reader.int64();\n                        break;\n                    case 2:\n                        message.str = reader.int64();\n                        break;\n                    case 3:\n                        message.num = reader.int64();\n                        break;\n                    case 4:\n                        message.numUnit = reader.int64();\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                    }\n                }\n                return message;\n            };\n\n            /**\n             * Decodes a Label message from the specified reader or buffer, length delimited.\n             * @function decodeDelimited\n             * @memberof perftools.profiles.Label\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @returns {perftools.profiles.Label} Label\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            Label.decodeDelimited = function decodeDelimited(reader) {\n                if (!(reader instanceof $Reader))\n                    reader = new $Reader(reader);\n                return this.decode(reader, reader.uint32());\n            };\n\n            /**\n             * Verifies a Label message.\n             * @function verify\n             * @memberof perftools.profiles.Label\n             * @static\n             * @param {Object.<string,*>} message Plain object to verify\n             * @returns {string|null} `null` if valid, otherwise the reason why it is not\n             */\n            Label.verify = function verify(message) {\n                if (typeof message !== \"object\" || message === null)\n                    return \"object expected\";\n                if (message.key != null && message.hasOwnProperty(\"key\"))\n                    if (!$util.isInteger(message.key) && !(message.key && $util.isInteger(message.key.low) && $util.isInteger(message.key.high)))\n                        return \"key: integer|Long expected\";\n                if (message.str != null && message.hasOwnProperty(\"str\"))\n                    if (!$util.isInteger(message.str) && !(message.str && $util.isInteger(message.str.low) && $util.isInteger(message.str.high)))\n                        return \"str: integer|Long expected\";\n                if (message.num != null && message.hasOwnProperty(\"num\"))\n                    if (!$util.isInteger(message.num) && !(message.num && $util.isInteger(message.num.low) && $util.isInteger(message.num.high)))\n                        return \"num: integer|Long expected\";\n                if (message.numUnit != null && message.hasOwnProperty(\"numUnit\"))\n                    if (!$util.isInteger(message.numUnit) && !(message.numUnit && $util.isInteger(message.numUnit.low) && $util.isInteger(message.numUnit.high)))\n                        return \"numUnit: integer|Long expected\";\n                return null;\n            };\n\n            /**\n             * Creates a Label message from a plain object. Also converts values to their respective internal types.\n             * @function fromObject\n             * @memberof perftools.profiles.Label\n             * @static\n             * @param {Object.<string,*>} object Plain object\n             * @returns {perftools.profiles.Label} Label\n             */\n            Label.fromObject = function fromObject(object) {\n                if (object instanceof $root.perftools.profiles.Label)\n                    return object;\n                var message = new $root.perftools.profiles.Label();\n                if (object.key != null)\n                    if ($util.Long)\n                        (message.key = $util.Long.fromValue(object.key)).unsigned = false;\n                    else if (typeof object.key === \"string\")\n                        message.key = parseInt(object.key, 10);\n                    else if (typeof object.key === \"number\")\n                        message.key = object.key;\n                    else if (typeof object.key === \"object\")\n                        message.key = new $util.LongBits(object.key.low >>> 0, object.key.high >>> 0).toNumber();\n                if (object.str != null)\n                    if ($util.Long)\n                        (message.str = $util.Long.fromValue(object.str)).unsigned = false;\n                    else if (typeof object.str === \"string\")\n                        message.str = parseInt(object.str, 10);\n                    else if (typeof object.str === \"number\")\n                        message.str = object.str;\n                    else if (typeof object.str === \"object\")\n                        message.str = new $util.LongBits(object.str.low >>> 0, object.str.high >>> 0).toNumber();\n                if (object.num != null)\n                    if ($util.Long)\n                        (message.num = $util.Long.fromValue(object.num)).unsigned = false;\n                    else if (typeof object.num === \"string\")\n                        message.num = parseInt(object.num, 10);\n                    else if (typeof object.num === \"number\")\n                        message.num = object.num;\n                    else if (typeof object.num === \"object\")\n                        message.num = new $util.LongBits(object.num.low >>> 0, object.num.high >>> 0).toNumber();\n                if (object.numUnit != null)\n                    if ($util.Long)\n                        (message.numUnit = $util.Long.fromValue(object.numUnit)).unsigned = false;\n                    else if (typeof object.numUnit === \"string\")\n                        message.numUnit = parseInt(object.numUnit, 10);\n                    else if (typeof object.numUnit === \"number\")\n                        message.numUnit = object.numUnit;\n                    else if (typeof object.numUnit === \"object\")\n                        message.numUnit = new $util.LongBits(object.numUnit.low >>> 0, object.numUnit.high >>> 0).toNumber();\n                return message;\n            };\n\n            /**\n             * Creates a plain object from a Label message. Also converts values to other types if specified.\n             * @function toObject\n             * @memberof perftools.profiles.Label\n             * @static\n             * @param {perftools.profiles.Label} message Label\n             * @param {$protobuf.IConversionOptions} [options] Conversion options\n             * @returns {Object.<string,*>} Plain object\n             */\n            Label.toObject = function toObject(message, options) {\n                if (!options)\n                    options = {};\n                var object = {};\n                if (options.defaults) {\n                    if ($util.Long) {\n                        var long = new $util.Long(0, 0, false);\n                        object.key = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                    } else\n                        object.key = options.longs === String ? \"0\" : 0;\n                    if ($util.Long) {\n                        var long = new $util.Long(0, 0, false);\n                        object.str = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                    } else\n                        object.str = options.longs === String ? \"0\" : 0;\n                    if ($util.Long) {\n                        var long = new $util.Long(0, 0, false);\n                        object.num = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                    } else\n                        object.num = options.longs === String ? \"0\" : 0;\n                    if ($util.Long) {\n                        var long = new $util.Long(0, 0, false);\n                        object.numUnit = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                    } else\n                        object.numUnit = options.longs === String ? \"0\" : 0;\n                }\n                if (message.key != null && message.hasOwnProperty(\"key\"))\n                    if (typeof message.key === \"number\")\n                        object.key = options.longs === String ? String(message.key) : message.key;\n                    else\n                        object.key = options.longs === String ? $util.Long.prototype.toString.call(message.key) : options.longs === Number ? new $util.LongBits(message.key.low >>> 0, message.key.high >>> 0).toNumber() : message.key;\n                if (message.str != null && message.hasOwnProperty(\"str\"))\n                    if (typeof message.str === \"number\")\n                        object.str = options.longs === String ? String(message.str) : message.str;\n                    else\n                        object.str = options.longs === String ? $util.Long.prototype.toString.call(message.str) : options.longs === Number ? new $util.LongBits(message.str.low >>> 0, message.str.high >>> 0).toNumber() : message.str;\n                if (message.num != null && message.hasOwnProperty(\"num\"))\n                    if (typeof message.num === \"number\")\n                        object.num = options.longs === String ? String(message.num) : message.num;\n                    else\n                        object.num = options.longs === String ? $util.Long.prototype.toString.call(message.num) : options.longs === Number ? new $util.LongBits(message.num.low >>> 0, message.num.high >>> 0).toNumber() : message.num;\n                if (message.numUnit != null && message.hasOwnProperty(\"numUnit\"))\n                    if (typeof message.numUnit === \"number\")\n                        object.numUnit = options.longs === String ? String(message.numUnit) : message.numUnit;\n                    else\n                        object.numUnit = options.longs === String ? $util.Long.prototype.toString.call(message.numUnit) : options.longs === Number ? new $util.LongBits(message.numUnit.low >>> 0, message.numUnit.high >>> 0).toNumber() : message.numUnit;\n                return object;\n            };\n\n            /**\n             * Converts this Label to JSON.\n             * @function toJSON\n             * @memberof perftools.profiles.Label\n             * @instance\n             * @returns {Object.<string,*>} JSON object\n             */\n            Label.prototype.toJSON = function toJSON() {\n                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n            };\n\n            return Label;\n        })();\n\n        profiles.Mapping = (function() {\n\n            /**\n             * Properties of a Mapping.\n             * @memberof perftools.profiles\n             * @interface IMapping\n             * @property {number|Long|null} [id] Mapping id\n             * @property {number|Long|null} [memoryStart] Mapping memoryStart\n             * @property {number|Long|null} [memoryLimit] Mapping memoryLimit\n             * @property {number|Long|null} [fileOffset] Mapping fileOffset\n             * @property {number|Long|null} [filename] Mapping filename\n             * @property {number|Long|null} [buildId] Mapping buildId\n             * @property {boolean|null} [hasFunctions] Mapping hasFunctions\n             * @property {boolean|null} [hasFilenames] Mapping hasFilenames\n             * @property {boolean|null} [hasLineNumbers] Mapping hasLineNumbers\n             * @property {boolean|null} [hasInlineFrames] Mapping hasInlineFrames\n             */\n\n            /**\n             * Constructs a new Mapping.\n             * @memberof perftools.profiles\n             * @classdesc Represents a Mapping.\n             * @implements IMapping\n             * @constructor\n             * @param {perftools.profiles.IMapping=} [properties] Properties to set\n             */\n            function Mapping(properties) {\n                if (properties)\n                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }\n\n            /**\n             * Mapping id.\n             * @member {number|Long} id\n             * @memberof perftools.profiles.Mapping\n             * @instance\n             */\n            Mapping.prototype.id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;\n\n            /**\n             * Mapping memoryStart.\n             * @member {number|Long} memoryStart\n             * @memberof perftools.profiles.Mapping\n             * @instance\n             */\n            Mapping.prototype.memoryStart = $util.Long ? $util.Long.fromBits(0,0,true) : 0;\n\n            /**\n             * Mapping memoryLimit.\n             * @member {number|Long} memoryLimit\n             * @memberof perftools.profiles.Mapping\n             * @instance\n             */\n            Mapping.prototype.memoryLimit = $util.Long ? $util.Long.fromBits(0,0,true) : 0;\n\n            /**\n             * Mapping fileOffset.\n             * @member {number|Long} fileOffset\n             * @memberof perftools.profiles.Mapping\n             * @instance\n             */\n            Mapping.prototype.fileOffset = $util.Long ? $util.Long.fromBits(0,0,true) : 0;\n\n            /**\n             * Mapping filename.\n             * @member {number|Long} filename\n             * @memberof perftools.profiles.Mapping\n             * @instance\n             */\n            Mapping.prototype.filename = $util.Long ? $util.Long.fromBits(0,0,false) : 0;\n\n            /**\n             * Mapping buildId.\n             * @member {number|Long} buildId\n             * @memberof perftools.profiles.Mapping\n             * @instance\n             */\n            Mapping.prototype.buildId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;\n\n            /**\n             * Mapping hasFunctions.\n             * @member {boolean} hasFunctions\n             * @memberof perftools.profiles.Mapping\n             * @instance\n             */\n            Mapping.prototype.hasFunctions = false;\n\n            /**\n             * Mapping hasFilenames.\n             * @member {boolean} hasFilenames\n             * @memberof perftools.profiles.Mapping\n             * @instance\n             */\n            Mapping.prototype.hasFilenames = false;\n\n            /**\n             * Mapping hasLineNumbers.\n             * @member {boolean} hasLineNumbers\n             * @memberof perftools.profiles.Mapping\n             * @instance\n             */\n            Mapping.prototype.hasLineNumbers = false;\n\n            /**\n             * Mapping hasInlineFrames.\n             * @member {boolean} hasInlineFrames\n             * @memberof perftools.profiles.Mapping\n             * @instance\n             */\n            Mapping.prototype.hasInlineFrames = false;\n\n            /**\n             * Creates a new Mapping instance using the specified properties.\n             * @function create\n             * @memberof perftools.profiles.Mapping\n             * @static\n             * @param {perftools.profiles.IMapping=} [properties] Properties to set\n             * @returns {perftools.profiles.Mapping} Mapping instance\n             */\n            Mapping.create = function create(properties) {\n                return new Mapping(properties);\n            };\n\n            /**\n             * Encodes the specified Mapping message. Does not implicitly {@link perftools.profiles.Mapping.verify|verify} messages.\n             * @function encode\n             * @memberof perftools.profiles.Mapping\n             * @static\n             * @param {perftools.profiles.IMapping} message Mapping message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            Mapping.encode = function encode(message, writer) {\n                if (!writer)\n                    writer = $Writer.create();\n                if (message.id != null && Object.hasOwnProperty.call(message, \"id\"))\n                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.id);\n                if (message.memoryStart != null && Object.hasOwnProperty.call(message, \"memoryStart\"))\n                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.memoryStart);\n                if (message.memoryLimit != null && Object.hasOwnProperty.call(message, \"memoryLimit\"))\n                    writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.memoryLimit);\n                if (message.fileOffset != null && Object.hasOwnProperty.call(message, \"fileOffset\"))\n                    writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.fileOffset);\n                if (message.filename != null && Object.hasOwnProperty.call(message, \"filename\"))\n                    writer.uint32(/* id 5, wireType 0 =*/40).int64(message.filename);\n                if (message.buildId != null && Object.hasOwnProperty.call(message, \"buildId\"))\n                    writer.uint32(/* id 6, wireType 0 =*/48).int64(message.buildId);\n                if (message.hasFunctions != null && Object.hasOwnProperty.call(message, \"hasFunctions\"))\n                    writer.uint32(/* id 7, wireType 0 =*/56).bool(message.hasFunctions);\n                if (message.hasFilenames != null && Object.hasOwnProperty.call(message, \"hasFilenames\"))\n                    writer.uint32(/* id 8, wireType 0 =*/64).bool(message.hasFilenames);\n                if (message.hasLineNumbers != null && Object.hasOwnProperty.call(message, \"hasLineNumbers\"))\n                    writer.uint32(/* id 9, wireType 0 =*/72).bool(message.hasLineNumbers);\n                if (message.hasInlineFrames != null && Object.hasOwnProperty.call(message, \"hasInlineFrames\"))\n                    writer.uint32(/* id 10, wireType 0 =*/80).bool(message.hasInlineFrames);\n                return writer;\n            };\n\n            /**\n             * Encodes the specified Mapping message, length delimited. Does not implicitly {@link perftools.profiles.Mapping.verify|verify} messages.\n             * @function encodeDelimited\n             * @memberof perftools.profiles.Mapping\n             * @static\n             * @param {perftools.profiles.IMapping} message Mapping message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            Mapping.encodeDelimited = function encodeDelimited(message, writer) {\n                return this.encode(message, writer).ldelim();\n            };\n\n            /**\n             * Decodes a Mapping message from the specified reader or buffer.\n             * @function decode\n             * @memberof perftools.profiles.Mapping\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {perftools.profiles.Mapping} Mapping\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            Mapping.decode = function decode(reader, length) {\n                if (!(reader instanceof $Reader))\n                    reader = $Reader.create(reader);\n                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.perftools.profiles.Mapping();\n                while (reader.pos < end) {\n                    var tag = reader.uint32();\n                    switch (tag >>> 3) {\n                    case 1:\n                        message.id = reader.uint64();\n                        break;\n                    case 2:\n                        message.memoryStart = reader.uint64();\n                        break;\n                    case 3:\n                        message.memoryLimit = reader.uint64();\n                        break;\n                    case 4:\n                        message.fileOffset = reader.uint64();\n                        break;\n                    case 5:\n                        message.filename = reader.int64();\n                        break;\n                    case 6:\n                        message.buildId = reader.int64();\n                        break;\n                    case 7:\n                        message.hasFunctions = reader.bool();\n                        break;\n                    case 8:\n                        message.hasFilenames = reader.bool();\n                        break;\n                    case 9:\n                        message.hasLineNumbers = reader.bool();\n                        break;\n                    case 10:\n                        message.hasInlineFrames = reader.bool();\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                    }\n                }\n                return message;\n            };\n\n            /**\n             * Decodes a Mapping message from the specified reader or buffer, length delimited.\n             * @function decodeDelimited\n             * @memberof perftools.profiles.Mapping\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @returns {perftools.profiles.Mapping} Mapping\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            Mapping.decodeDelimited = function decodeDelimited(reader) {\n                if (!(reader instanceof $Reader))\n                    reader = new $Reader(reader);\n                return this.decode(reader, reader.uint32());\n            };\n\n            /**\n             * Verifies a Mapping message.\n             * @function verify\n             * @memberof perftools.profiles.Mapping\n             * @static\n             * @param {Object.<string,*>} message Plain object to verify\n             * @returns {string|null} `null` if valid, otherwise the reason why it is not\n             */\n            Mapping.verify = function verify(message) {\n                if (typeof message !== \"object\" || message === null)\n                    return \"object expected\";\n                if (message.id != null && message.hasOwnProperty(\"id\"))\n                    if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))\n                        return \"id: integer|Long expected\";\n                if (message.memoryStart != null && message.hasOwnProperty(\"memoryStart\"))\n                    if (!$util.isInteger(message.memoryStart) && !(message.memoryStart && $util.isInteger(message.memoryStart.low) && $util.isInteger(message.memoryStart.high)))\n                        return \"memoryStart: integer|Long expected\";\n                if (message.memoryLimit != null && message.hasOwnProperty(\"memoryLimit\"))\n                    if (!$util.isInteger(message.memoryLimit) && !(message.memoryLimit && $util.isInteger(message.memoryLimit.low) && $util.isInteger(message.memoryLimit.high)))\n                        return \"memoryLimit: integer|Long expected\";\n                if (message.fileOffset != null && message.hasOwnProperty(\"fileOffset\"))\n                    if (!$util.isInteger(message.fileOffset) && !(message.fileOffset && $util.isInteger(message.fileOffset.low) && $util.isInteger(message.fileOffset.high)))\n                        return \"fileOffset: integer|Long expected\";\n                if (message.filename != null && message.hasOwnProperty(\"filename\"))\n                    if (!$util.isInteger(message.filename) && !(message.filename && $util.isInteger(message.filename.low) && $util.isInteger(message.filename.high)))\n                        return \"filename: integer|Long expected\";\n                if (message.buildId != null && message.hasOwnProperty(\"buildId\"))\n                    if (!$util.isInteger(message.buildId) && !(message.buildId && $util.isInteger(message.buildId.low) && $util.isInteger(message.buildId.high)))\n                        return \"buildId: integer|Long expected\";\n                if (message.hasFunctions != null && message.hasOwnProperty(\"hasFunctions\"))\n                    if (typeof message.hasFunctions !== \"boolean\")\n                        return \"hasFunctions: boolean expected\";\n                if (message.hasFilenames != null && message.hasOwnProperty(\"hasFilenames\"))\n                    if (typeof message.hasFilenames !== \"boolean\")\n                        return \"hasFilenames: boolean expected\";\n                if (message.hasLineNumbers != null && message.hasOwnProperty(\"hasLineNumbers\"))\n                    if (typeof message.hasLineNumbers !== \"boolean\")\n                        return \"hasLineNumbers: boolean expected\";\n                if (message.hasInlineFrames != null && message.hasOwnProperty(\"hasInlineFrames\"))\n                    if (typeof message.hasInlineFrames !== \"boolean\")\n                        return \"hasInlineFrames: boolean expected\";\n                return null;\n            };\n\n            /**\n             * Creates a Mapping message from a plain object. Also converts values to their respective internal types.\n             * @function fromObject\n             * @memberof perftools.profiles.Mapping\n             * @static\n             * @param {Object.<string,*>} object Plain object\n             * @returns {perftools.profiles.Mapping} Mapping\n             */\n            Mapping.fromObject = function fromObject(object) {\n                if (object instanceof $root.perftools.profiles.Mapping)\n                    return object;\n                var message = new $root.perftools.profiles.Mapping();\n                if (object.id != null)\n                    if ($util.Long)\n                        (message.id = $util.Long.fromValue(object.id)).unsigned = true;\n                    else if (typeof object.id === \"string\")\n                        message.id = parseInt(object.id, 10);\n                    else if (typeof object.id === \"number\")\n                        message.id = object.id;\n                    else if (typeof object.id === \"object\")\n                        message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);\n                if (object.memoryStart != null)\n                    if ($util.Long)\n                        (message.memoryStart = $util.Long.fromValue(object.memoryStart)).unsigned = true;\n                    else if (typeof object.memoryStart === \"string\")\n                        message.memoryStart = parseInt(object.memoryStart, 10);\n                    else if (typeof object.memoryStart === \"number\")\n                        message.memoryStart = object.memoryStart;\n                    else if (typeof object.memoryStart === \"object\")\n                        message.memoryStart = new $util.LongBits(object.memoryStart.low >>> 0, object.memoryStart.high >>> 0).toNumber(true);\n                if (object.memoryLimit != null)\n                    if ($util.Long)\n                        (message.memoryLimit = $util.Long.fromValue(object.memoryLimit)).unsigned = true;\n                    else if (typeof object.memoryLimit === \"string\")\n                        message.memoryLimit = parseInt(object.memoryLimit, 10);\n                    else if (typeof object.memoryLimit === \"number\")\n                        message.memoryLimit = object.memoryLimit;\n                    else if (typeof object.memoryLimit === \"object\")\n                        message.memoryLimit = new $util.LongBits(object.memoryLimit.low >>> 0, object.memoryLimit.high >>> 0).toNumber(true);\n                if (object.fileOffset != null)\n                    if ($util.Long)\n                        (message.fileOffset = $util.Long.fromValue(object.fileOffset)).unsigned = true;\n                    else if (typeof object.fileOffset === \"string\")\n                        message.fileOffset = parseInt(object.fileOffset, 10);\n                    else if (typeof object.fileOffset === \"number\")\n                        message.fileOffset = object.fileOffset;\n                    else if (typeof object.fileOffset === \"object\")\n                        message.fileOffset = new $util.LongBits(object.fileOffset.low >>> 0, object.fileOffset.high >>> 0).toNumber(true);\n                if (object.filename != null)\n                    if ($util.Long)\n                        (message.filename = $util.Long.fromValue(object.filename)).unsigned = false;\n                    else if (typeof object.filename === \"string\")\n                        message.filename = parseInt(object.filename, 10);\n                    else if (typeof object.filename === \"number\")\n                        message.filename = object.filename;\n                    else if (typeof object.filename === \"object\")\n                        message.filename = new $util.LongBits(object.filename.low >>> 0, object.filename.high >>> 0).toNumber();\n                if (object.buildId != null)\n                    if ($util.Long)\n                        (message.buildId = $util.Long.fromValue(object.buildId)).unsigned = false;\n                    else if (typeof object.buildId === \"string\")\n                        message.buildId = parseInt(object.buildId, 10);\n                    else if (typeof object.buildId === \"number\")\n                        message.buildId = object.buildId;\n                    else if (typeof object.buildId === \"object\")\n                        message.buildId = new $util.LongBits(object.buildId.low >>> 0, object.buildId.high >>> 0).toNumber();\n                if (object.hasFunctions != null)\n                    message.hasFunctions = Boolean(object.hasFunctions);\n                if (object.hasFilenames != null)\n                    message.hasFilenames = Boolean(object.hasFilenames);\n                if (object.hasLineNumbers != null)\n                    message.hasLineNumbers = Boolean(object.hasLineNumbers);\n                if (object.hasInlineFrames != null)\n                    message.hasInlineFrames = Boolean(object.hasInlineFrames);\n                return message;\n            };\n\n            /**\n             * Creates a plain object from a Mapping message. Also converts values to other types if specified.\n             * @function toObject\n             * @memberof perftools.profiles.Mapping\n             * @static\n             * @param {perftools.profiles.Mapping} message Mapping\n             * @param {$protobuf.IConversionOptions} [options] Conversion options\n             * @returns {Object.<string,*>} Plain object\n             */\n            Mapping.toObject = function toObject(message, options) {\n                if (!options)\n                    options = {};\n                var object = {};\n                if (options.defaults) {\n                    if ($util.Long) {\n                        var long = new $util.Long(0, 0, true);\n                        object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                    } else\n                        object.id = options.longs === String ? \"0\" : 0;\n                    if ($util.Long) {\n                        var long = new $util.Long(0, 0, true);\n                        object.memoryStart = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                    } else\n                        object.memoryStart = options.longs === String ? \"0\" : 0;\n                    if ($util.Long) {\n                        var long = new $util.Long(0, 0, true);\n                        object.memoryLimit = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                    } else\n                        object.memoryLimit = options.longs === String ? \"0\" : 0;\n                    if ($util.Long) {\n                        var long = new $util.Long(0, 0, true);\n                        object.fileOffset = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                    } else\n                        object.fileOffset = options.longs === String ? \"0\" : 0;\n                    if ($util.Long) {\n                        var long = new $util.Long(0, 0, false);\n                        object.filename = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                    } else\n                        object.filename = options.longs === String ? \"0\" : 0;\n                    if ($util.Long) {\n                        var long = new $util.Long(0, 0, false);\n                        object.buildId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                    } else\n                        object.buildId = options.longs === String ? \"0\" : 0;\n                    object.hasFunctions = false;\n                    object.hasFilenames = false;\n                    object.hasLineNumbers = false;\n                    object.hasInlineFrames = false;\n                }\n                if (message.id != null && message.hasOwnProperty(\"id\"))\n                    if (typeof message.id === \"number\")\n                        object.id = options.longs === String ? String(message.id) : message.id;\n                    else\n                        object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true) : message.id;\n                if (message.memoryStart != null && message.hasOwnProperty(\"memoryStart\"))\n                    if (typeof message.memoryStart === \"number\")\n                        object.memoryStart = options.longs === String ? String(message.memoryStart) : message.memoryStart;\n                    else\n                        object.memoryStart = options.longs === String ? $util.Long.prototype.toString.call(message.memoryStart) : options.longs === Number ? new $util.LongBits(message.memoryStart.low >>> 0, message.memoryStart.high >>> 0).toNumber(true) : message.memoryStart;\n                if (message.memoryLimit != null && message.hasOwnProperty(\"memoryLimit\"))\n                    if (typeof message.memoryLimit === \"number\")\n                        object.memoryLimit = options.longs === String ? String(message.memoryLimit) : message.memoryLimit;\n                    else\n                        object.memoryLimit = options.longs === String ? $util.Long.prototype.toString.call(message.memoryLimit) : options.longs === Number ? new $util.LongBits(message.memoryLimit.low >>> 0, message.memoryLimit.high >>> 0).toNumber(true) : message.memoryLimit;\n                if (message.fileOffset != null && message.hasOwnProperty(\"fileOffset\"))\n                    if (typeof message.fileOffset === \"number\")\n                        object.fileOffset = options.longs === String ? String(message.fileOffset) : message.fileOffset;\n                    else\n                        object.fileOffset = options.longs === String ? $util.Long.prototype.toString.call(message.fileOffset) : options.longs === Number ? new $util.LongBits(message.fileOffset.low >>> 0, message.fileOffset.high >>> 0).toNumber(true) : message.fileOffset;\n                if (message.filename != null && message.hasOwnProperty(\"filename\"))\n                    if (typeof message.filename === \"number\")\n                        object.filename = options.longs === String ? String(message.filename) : message.filename;\n                    else\n                        object.filename = options.longs === String ? $util.Long.prototype.toString.call(message.filename) : options.longs === Number ? new $util.LongBits(message.filename.low >>> 0, message.filename.high >>> 0).toNumber() : message.filename;\n                if (message.buildId != null && message.hasOwnProperty(\"buildId\"))\n                    if (typeof message.buildId === \"number\")\n                        object.buildId = options.longs === String ? String(message.buildId) : message.buildId;\n                    else\n                        object.buildId = options.longs === String ? $util.Long.prototype.toString.call(message.buildId) : options.longs === Number ? new $util.LongBits(message.buildId.low >>> 0, message.buildId.high >>> 0).toNumber() : message.buildId;\n                if (message.hasFunctions != null && message.hasOwnProperty(\"hasFunctions\"))\n                    object.hasFunctions = message.hasFunctions;\n                if (message.hasFilenames != null && message.hasOwnProperty(\"hasFilenames\"))\n                    object.hasFilenames = message.hasFilenames;\n                if (message.hasLineNumbers != null && message.hasOwnProperty(\"hasLineNumbers\"))\n                    object.hasLineNumbers = message.hasLineNumbers;\n                if (message.hasInlineFrames != null && message.hasOwnProperty(\"hasInlineFrames\"))\n                    object.hasInlineFrames = message.hasInlineFrames;\n                return object;\n            };\n\n            /**\n             * Converts this Mapping to JSON.\n             * @function toJSON\n             * @memberof perftools.profiles.Mapping\n             * @instance\n             * @returns {Object.<string,*>} JSON object\n             */\n            Mapping.prototype.toJSON = function toJSON() {\n                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n            };\n\n            return Mapping;\n        })();\n\n        profiles.Location = (function() {\n\n            /**\n             * Properties of a Location.\n             * @memberof perftools.profiles\n             * @interface ILocation\n             * @property {number|Long|null} [id] Location id\n             * @property {number|Long|null} [mappingId] Location mappingId\n             * @property {number|Long|null} [address] Location address\n             * @property {Array.<perftools.profiles.ILine>|null} [line] Location line\n             * @property {boolean|null} [isFolded] Location isFolded\n             */\n\n            /**\n             * Constructs a new Location.\n             * @memberof perftools.profiles\n             * @classdesc Represents a Location.\n             * @implements ILocation\n             * @constructor\n             * @param {perftools.profiles.ILocation=} [properties] Properties to set\n             */\n            function Location(properties) {\n                this.line = [];\n                if (properties)\n                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }\n\n            /**\n             * Location id.\n             * @member {number|Long} id\n             * @memberof perftools.profiles.Location\n             * @instance\n             */\n            Location.prototype.id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;\n\n            /**\n             * Location mappingId.\n             * @member {number|Long} mappingId\n             * @memberof perftools.profiles.Location\n             * @instance\n             */\n            Location.prototype.mappingId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;\n\n            /**\n             * Location address.\n             * @member {number|Long} address\n             * @memberof perftools.profiles.Location\n             * @instance\n             */\n            Location.prototype.address = $util.Long ? $util.Long.fromBits(0,0,true) : 0;\n\n            /**\n             * Location line.\n             * @member {Array.<perftools.profiles.ILine>} line\n             * @memberof perftools.profiles.Location\n             * @instance\n             */\n            Location.prototype.line = $util.emptyArray;\n\n            /**\n             * Location isFolded.\n             * @member {boolean} isFolded\n             * @memberof perftools.profiles.Location\n             * @instance\n             */\n            Location.prototype.isFolded = false;\n\n            /**\n             * Creates a new Location instance using the specified properties.\n             * @function create\n             * @memberof perftools.profiles.Location\n             * @static\n             * @param {perftools.profiles.ILocation=} [properties] Properties to set\n             * @returns {perftools.profiles.Location} Location instance\n             */\n            Location.create = function create(properties) {\n                return new Location(properties);\n            };\n\n            /**\n             * Encodes the specified Location message. Does not implicitly {@link perftools.profiles.Location.verify|verify} messages.\n             * @function encode\n             * @memberof perftools.profiles.Location\n             * @static\n             * @param {perftools.profiles.ILocation} message Location message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            Location.encode = function encode(message, writer) {\n                if (!writer)\n                    writer = $Writer.create();\n                if (message.id != null && Object.hasOwnProperty.call(message, \"id\"))\n                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.id);\n                if (message.mappingId != null && Object.hasOwnProperty.call(message, \"mappingId\"))\n                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.mappingId);\n                if (message.address != null && Object.hasOwnProperty.call(message, \"address\"))\n                    writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.address);\n                if (message.line != null && message.line.length)\n                    for (var i = 0; i < message.line.length; ++i)\n                        $root.perftools.profiles.Line.encode(message.line[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();\n                if (message.isFolded != null && Object.hasOwnProperty.call(message, \"isFolded\"))\n                    writer.uint32(/* id 5, wireType 0 =*/40).bool(message.isFolded);\n                return writer;\n            };\n\n            /**\n             * Encodes the specified Location message, length delimited. Does not implicitly {@link perftools.profiles.Location.verify|verify} messages.\n             * @function encodeDelimited\n             * @memberof perftools.profiles.Location\n             * @static\n             * @param {perftools.profiles.ILocation} message Location message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            Location.encodeDelimited = function encodeDelimited(message, writer) {\n                return this.encode(message, writer).ldelim();\n            };\n\n            /**\n             * Decodes a Location message from the specified reader or buffer.\n             * @function decode\n             * @memberof perftools.profiles.Location\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {perftools.profiles.Location} Location\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            Location.decode = function decode(reader, length) {\n                if (!(reader instanceof $Reader))\n                    reader = $Reader.create(reader);\n                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.perftools.profiles.Location();\n                while (reader.pos < end) {\n                    var tag = reader.uint32();\n                    switch (tag >>> 3) {\n                    case 1:\n                        message.id = reader.uint64();\n                        break;\n                    case 2:\n                        message.mappingId = reader.uint64();\n                        break;\n                    case 3:\n                        message.address = reader.uint64();\n                        break;\n                    case 4:\n                        if (!(message.line && message.line.length))\n                            message.line = [];\n                        message.line.push($root.perftools.profiles.Line.decode(reader, reader.uint32()));\n                        break;\n                    case 5:\n                        message.isFolded = reader.bool();\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                    }\n                }\n                return message;\n            };\n\n            /**\n             * Decodes a Location message from the specified reader or buffer, length delimited.\n             * @function decodeDelimited\n             * @memberof perftools.profiles.Location\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @returns {perftools.profiles.Location} Location\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            Location.decodeDelimited = function decodeDelimited(reader) {\n                if (!(reader instanceof $Reader))\n                    reader = new $Reader(reader);\n                return this.decode(reader, reader.uint32());\n            };\n\n            /**\n             * Verifies a Location message.\n             * @function verify\n             * @memberof perftools.profiles.Location\n             * @static\n             * @param {Object.<string,*>} message Plain object to verify\n             * @returns {string|null} `null` if valid, otherwise the reason why it is not\n             */\n            Location.verify = function verify(message) {\n                if (typeof message !== \"object\" || message === null)\n                    return \"object expected\";\n                if (message.id != null && message.hasOwnProperty(\"id\"))\n                    if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))\n                        return \"id: integer|Long expected\";\n                if (message.mappingId != null && message.hasOwnProperty(\"mappingId\"))\n                    if (!$util.isInteger(message.mappingId) && !(message.mappingId && $util.isInteger(message.mappingId.low) && $util.isInteger(message.mappingId.high)))\n                        return \"mappingId: integer|Long expected\";\n                if (message.address != null && message.hasOwnProperty(\"address\"))\n                    if (!$util.isInteger(message.address) && !(message.address && $util.isInteger(message.address.low) && $util.isInteger(message.address.high)))\n                        return \"address: integer|Long expected\";\n                if (message.line != null && message.hasOwnProperty(\"line\")) {\n                    if (!Array.isArray(message.line))\n                        return \"line: array expected\";\n                    for (var i = 0; i < message.line.length; ++i) {\n                        var error = $root.perftools.profiles.Line.verify(message.line[i]);\n                        if (error)\n                            return \"line.\" + error;\n                    }\n                }\n                if (message.isFolded != null && message.hasOwnProperty(\"isFolded\"))\n                    if (typeof message.isFolded !== \"boolean\")\n                        return \"isFolded: boolean expected\";\n                return null;\n            };\n\n            /**\n             * Creates a Location message from a plain object. Also converts values to their respective internal types.\n             * @function fromObject\n             * @memberof perftools.profiles.Location\n             * @static\n             * @param {Object.<string,*>} object Plain object\n             * @returns {perftools.profiles.Location} Location\n             */\n            Location.fromObject = function fromObject(object) {\n                if (object instanceof $root.perftools.profiles.Location)\n                    return object;\n                var message = new $root.perftools.profiles.Location();\n                if (object.id != null)\n                    if ($util.Long)\n                        (message.id = $util.Long.fromValue(object.id)).unsigned = true;\n                    else if (typeof object.id === \"string\")\n                        message.id = parseInt(object.id, 10);\n                    else if (typeof object.id === \"number\")\n                        message.id = object.id;\n                    else if (typeof object.id === \"object\")\n                        message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);\n                if (object.mappingId != null)\n                    if ($util.Long)\n                        (message.mappingId = $util.Long.fromValue(object.mappingId)).unsigned = true;\n                    else if (typeof object.mappingId === \"string\")\n                        message.mappingId = parseInt(object.mappingId, 10);\n                    else if (typeof object.mappingId === \"number\")\n                        message.mappingId = object.mappingId;\n                    else if (typeof object.mappingId === \"object\")\n                        message.mappingId = new $util.LongBits(object.mappingId.low >>> 0, object.mappingId.high >>> 0).toNumber(true);\n                if (object.address != null)\n                    if ($util.Long)\n                        (message.address = $util.Long.fromValue(object.address)).unsigned = true;\n                    else if (typeof object.address === \"string\")\n                        message.address = parseInt(object.address, 10);\n                    else if (typeof object.address === \"number\")\n                        message.address = object.address;\n                    else if (typeof object.address === \"object\")\n                        message.address = new $util.LongBits(object.address.low >>> 0, object.address.high >>> 0).toNumber(true);\n                if (object.line) {\n                    if (!Array.isArray(object.line))\n                        throw TypeError(\".perftools.profiles.Location.line: array expected\");\n                    message.line = [];\n                    for (var i = 0; i < object.line.length; ++i) {\n                        if (typeof object.line[i] !== \"object\")\n                            throw TypeError(\".perftools.profiles.Location.line: object expected\");\n                        message.line[i] = $root.perftools.profiles.Line.fromObject(object.line[i]);\n                    }\n                }\n                if (object.isFolded != null)\n                    message.isFolded = Boolean(object.isFolded);\n                return message;\n            };\n\n            /**\n             * Creates a plain object from a Location message. Also converts values to other types if specified.\n             * @function toObject\n             * @memberof perftools.profiles.Location\n             * @static\n             * @param {perftools.profiles.Location} message Location\n             * @param {$protobuf.IConversionOptions} [options] Conversion options\n             * @returns {Object.<string,*>} Plain object\n             */\n            Location.toObject = function toObject(message, options) {\n                if (!options)\n                    options = {};\n                var object = {};\n                if (options.arrays || options.defaults)\n                    object.line = [];\n                if (options.defaults) {\n                    if ($util.Long) {\n                        var long = new $util.Long(0, 0, true);\n                        object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                    } else\n                        object.id = options.longs === String ? \"0\" : 0;\n                    if ($util.Long) {\n                        var long = new $util.Long(0, 0, true);\n                        object.mappingId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                    } else\n                        object.mappingId = options.longs === String ? \"0\" : 0;\n                    if ($util.Long) {\n                        var long = new $util.Long(0, 0, true);\n                        object.address = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                    } else\n                        object.address = options.longs === String ? \"0\" : 0;\n                    object.isFolded = false;\n                }\n                if (message.id != null && message.hasOwnProperty(\"id\"))\n                    if (typeof message.id === \"number\")\n                        object.id = options.longs === String ? String(message.id) : message.id;\n                    else\n                        object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true) : message.id;\n                if (message.mappingId != null && message.hasOwnProperty(\"mappingId\"))\n                    if (typeof message.mappingId === \"number\")\n                        object.mappingId = options.longs === String ? String(message.mappingId) : message.mappingId;\n                    else\n                        object.mappingId = options.longs === String ? $util.Long.prototype.toString.call(message.mappingId) : options.longs === Number ? new $util.LongBits(message.mappingId.low >>> 0, message.mappingId.high >>> 0).toNumber(true) : message.mappingId;\n                if (message.address != null && message.hasOwnProperty(\"address\"))\n                    if (typeof message.address === \"number\")\n                        object.address = options.longs === String ? String(message.address) : message.address;\n                    else\n                        object.address = options.longs === String ? $util.Long.prototype.toString.call(message.address) : options.longs === Number ? new $util.LongBits(message.address.low >>> 0, message.address.high >>> 0).toNumber(true) : message.address;\n                if (message.line && message.line.length) {\n                    object.line = [];\n                    for (var j = 0; j < message.line.length; ++j)\n                        object.line[j] = $root.perftools.profiles.Line.toObject(message.line[j], options);\n                }\n                if (message.isFolded != null && message.hasOwnProperty(\"isFolded\"))\n                    object.isFolded = message.isFolded;\n                return object;\n            };\n\n            /**\n             * Converts this Location to JSON.\n             * @function toJSON\n             * @memberof perftools.profiles.Location\n             * @instance\n             * @returns {Object.<string,*>} JSON object\n             */\n            Location.prototype.toJSON = function toJSON() {\n                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n            };\n\n            return Location;\n        })();\n\n        profiles.Line = (function() {\n\n            /**\n             * Properties of a Line.\n             * @memberof perftools.profiles\n             * @interface ILine\n             * @property {number|Long|null} [functionId] Line functionId\n             * @property {number|Long|null} [line] Line line\n             */\n\n            /**\n             * Constructs a new Line.\n             * @memberof perftools.profiles\n             * @classdesc Represents a Line.\n             * @implements ILine\n             * @constructor\n             * @param {perftools.profiles.ILine=} [properties] Properties to set\n             */\n            function Line(properties) {\n                if (properties)\n                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }\n\n            /**\n             * Line functionId.\n             * @member {number|Long} functionId\n             * @memberof perftools.profiles.Line\n             * @instance\n             */\n            Line.prototype.functionId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;\n\n            /**\n             * Line line.\n             * @member {number|Long} line\n             * @memberof perftools.profiles.Line\n             * @instance\n             */\n            Line.prototype.line = $util.Long ? $util.Long.fromBits(0,0,false) : 0;\n\n            /**\n             * Creates a new Line instance using the specified properties.\n             * @function create\n             * @memberof perftools.profiles.Line\n             * @static\n             * @param {perftools.profiles.ILine=} [properties] Properties to set\n             * @returns {perftools.profiles.Line} Line instance\n             */\n            Line.create = function create(properties) {\n                return new Line(properties);\n            };\n\n            /**\n             * Encodes the specified Line message. Does not implicitly {@link perftools.profiles.Line.verify|verify} messages.\n             * @function encode\n             * @memberof perftools.profiles.Line\n             * @static\n             * @param {perftools.profiles.ILine} message Line message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            Line.encode = function encode(message, writer) {\n                if (!writer)\n                    writer = $Writer.create();\n                if (message.functionId != null && Object.hasOwnProperty.call(message, \"functionId\"))\n                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.functionId);\n                if (message.line != null && Object.hasOwnProperty.call(message, \"line\"))\n                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.line);\n                return writer;\n            };\n\n            /**\n             * Encodes the specified Line message, length delimited. Does not implicitly {@link perftools.profiles.Line.verify|verify} messages.\n             * @function encodeDelimited\n             * @memberof perftools.profiles.Line\n             * @static\n             * @param {perftools.profiles.ILine} message Line message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            Line.encodeDelimited = function encodeDelimited(message, writer) {\n                return this.encode(message, writer).ldelim();\n            };\n\n            /**\n             * Decodes a Line message from the specified reader or buffer.\n             * @function decode\n             * @memberof perftools.profiles.Line\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {perftools.profiles.Line} Line\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            Line.decode = function decode(reader, length) {\n                if (!(reader instanceof $Reader))\n                    reader = $Reader.create(reader);\n                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.perftools.profiles.Line();\n                while (reader.pos < end) {\n                    var tag = reader.uint32();\n                    switch (tag >>> 3) {\n                    case 1:\n                        message.functionId = reader.uint64();\n                        break;\n                    case 2:\n                        message.line = reader.int64();\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                    }\n                }\n                return message;\n            };\n\n            /**\n             * Decodes a Line message from the specified reader or buffer, length delimited.\n             * @function decodeDelimited\n             * @memberof perftools.profiles.Line\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @returns {perftools.profiles.Line} Line\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            Line.decodeDelimited = function decodeDelimited(reader) {\n                if (!(reader instanceof $Reader))\n                    reader = new $Reader(reader);\n                return this.decode(reader, reader.uint32());\n            };\n\n            /**\n             * Verifies a Line message.\n             * @function verify\n             * @memberof perftools.profiles.Line\n             * @static\n             * @param {Object.<string,*>} message Plain object to verify\n             * @returns {string|null} `null` if valid, otherwise the reason why it is not\n             */\n            Line.verify = function verify(message) {\n                if (typeof message !== \"object\" || message === null)\n                    return \"object expected\";\n                if (message.functionId != null && message.hasOwnProperty(\"functionId\"))\n                    if (!$util.isInteger(message.functionId) && !(message.functionId && $util.isInteger(message.functionId.low) && $util.isInteger(message.functionId.high)))\n                        return \"functionId: integer|Long expected\";\n                if (message.line != null && message.hasOwnProperty(\"line\"))\n                    if (!$util.isInteger(message.line) && !(message.line && $util.isInteger(message.line.low) && $util.isInteger(message.line.high)))\n                        return \"line: integer|Long expected\";\n                return null;\n            };\n\n            /**\n             * Creates a Line message from a plain object. Also converts values to their respective internal types.\n             * @function fromObject\n             * @memberof perftools.profiles.Line\n             * @static\n             * @param {Object.<string,*>} object Plain object\n             * @returns {perftools.profiles.Line} Line\n             */\n            Line.fromObject = function fromObject(object) {\n                if (object instanceof $root.perftools.profiles.Line)\n                    return object;\n                var message = new $root.perftools.profiles.Line();\n                if (object.functionId != null)\n                    if ($util.Long)\n                        (message.functionId = $util.Long.fromValue(object.functionId)).unsigned = true;\n                    else if (typeof object.functionId === \"string\")\n                        message.functionId = parseInt(object.functionId, 10);\n                    else if (typeof object.functionId === \"number\")\n                        message.functionId = object.functionId;\n                    else if (typeof object.functionId === \"object\")\n                        message.functionId = new $util.LongBits(object.functionId.low >>> 0, object.functionId.high >>> 0).toNumber(true);\n                if (object.line != null)\n                    if ($util.Long)\n                        (message.line = $util.Long.fromValue(object.line)).unsigned = false;\n                    else if (typeof object.line === \"string\")\n                        message.line = parseInt(object.line, 10);\n                    else if (typeof object.line === \"number\")\n                        message.line = object.line;\n                    else if (typeof object.line === \"object\")\n                        message.line = new $util.LongBits(object.line.low >>> 0, object.line.high >>> 0).toNumber();\n                return message;\n            };\n\n            /**\n             * Creates a plain object from a Line message. Also converts values to other types if specified.\n             * @function toObject\n             * @memberof perftools.profiles.Line\n             * @static\n             * @param {perftools.profiles.Line} message Line\n             * @param {$protobuf.IConversionOptions} [options] Conversion options\n             * @returns {Object.<string,*>} Plain object\n             */\n            Line.toObject = function toObject(message, options) {\n                if (!options)\n                    options = {};\n                var object = {};\n                if (options.defaults) {\n                    if ($util.Long) {\n                        var long = new $util.Long(0, 0, true);\n                        object.functionId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                    } else\n                        object.functionId = options.longs === String ? \"0\" : 0;\n                    if ($util.Long) {\n                        var long = new $util.Long(0, 0, false);\n                        object.line = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                    } else\n                        object.line = options.longs === String ? \"0\" : 0;\n                }\n                if (message.functionId != null && message.hasOwnProperty(\"functionId\"))\n                    if (typeof message.functionId === \"number\")\n                        object.functionId = options.longs === String ? String(message.functionId) : message.functionId;\n                    else\n                        object.functionId = options.longs === String ? $util.Long.prototype.toString.call(message.functionId) : options.longs === Number ? new $util.LongBits(message.functionId.low >>> 0, message.functionId.high >>> 0).toNumber(true) : message.functionId;\n                if (message.line != null && message.hasOwnProperty(\"line\"))\n                    if (typeof message.line === \"number\")\n                        object.line = options.longs === String ? String(message.line) : message.line;\n                    else\n                        object.line = options.longs === String ? $util.Long.prototype.toString.call(message.line) : options.longs === Number ? new $util.LongBits(message.line.low >>> 0, message.line.high >>> 0).toNumber() : message.line;\n                return object;\n            };\n\n            /**\n             * Converts this Line to JSON.\n             * @function toJSON\n             * @memberof perftools.profiles.Line\n             * @instance\n             * @returns {Object.<string,*>} JSON object\n             */\n            Line.prototype.toJSON = function toJSON() {\n                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n            };\n\n            return Line;\n        })();\n\n        profiles.Function = (function() {\n\n            /**\n             * Properties of a Function.\n             * @memberof perftools.profiles\n             * @interface IFunction\n             * @property {number|Long|null} [id] Function id\n             * @property {number|Long|null} [name] Function name\n             * @property {number|Long|null} [systemName] Function systemName\n             * @property {number|Long|null} [filename] Function filename\n             * @property {number|Long|null} [startLine] Function startLine\n             */\n\n            /**\n             * Constructs a new Function.\n             * @memberof perftools.profiles\n             * @classdesc Represents a Function.\n             * @implements IFunction\n             * @constructor\n             * @param {perftools.profiles.IFunction=} [properties] Properties to set\n             */\n            function Function(properties) {\n                if (properties)\n                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }\n\n            /**\n             * Function id.\n             * @member {number|Long} id\n             * @memberof perftools.profiles.Function\n             * @instance\n             */\n            Function.prototype.id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;\n\n            /**\n             * Function name.\n             * @member {number|Long} name\n             * @memberof perftools.profiles.Function\n             * @instance\n             */\n            Function.prototype.name = $util.Long ? $util.Long.fromBits(0,0,false) : 0;\n\n            /**\n             * Function systemName.\n             * @member {number|Long} systemName\n             * @memberof perftools.profiles.Function\n             * @instance\n             */\n            Function.prototype.systemName = $util.Long ? $util.Long.fromBits(0,0,false) : 0;\n\n            /**\n             * Function filename.\n             * @member {number|Long} filename\n             * @memberof perftools.profiles.Function\n             * @instance\n             */\n            Function.prototype.filename = $util.Long ? $util.Long.fromBits(0,0,false) : 0;\n\n            /**\n             * Function startLine.\n             * @member {number|Long} startLine\n             * @memberof perftools.profiles.Function\n             * @instance\n             */\n            Function.prototype.startLine = $util.Long ? $util.Long.fromBits(0,0,false) : 0;\n\n            /**\n             * Creates a new Function instance using the specified properties.\n             * @function create\n             * @memberof perftools.profiles.Function\n             * @static\n             * @param {perftools.profiles.IFunction=} [properties] Properties to set\n             * @returns {perftools.profiles.Function} Function instance\n             */\n            Function.create = function create(properties) {\n                return new Function(properties);\n            };\n\n            /**\n             * Encodes the specified Function message. Does not implicitly {@link perftools.profiles.Function.verify|verify} messages.\n             * @function encode\n             * @memberof perftools.profiles.Function\n             * @static\n             * @param {perftools.profiles.IFunction} message Function message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            Function.encode = function encode(message, writer) {\n                if (!writer)\n                    writer = $Writer.create();\n                if (message.id != null && Object.hasOwnProperty.call(message, \"id\"))\n                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.id);\n                if (message.name != null && Object.hasOwnProperty.call(message, \"name\"))\n                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.name);\n                if (message.systemName != null && Object.hasOwnProperty.call(message, \"systemName\"))\n                    writer.uint32(/* id 3, wireType 0 =*/24).int64(message.systemName);\n                if (message.filename != null && Object.hasOwnProperty.call(message, \"filename\"))\n                    writer.uint32(/* id 4, wireType 0 =*/32).int64(message.filename);\n                if (message.startLine != null && Object.hasOwnProperty.call(message, \"startLine\"))\n                    writer.uint32(/* id 5, wireType 0 =*/40).int64(message.startLine);\n                return writer;\n            };\n\n            /**\n             * Encodes the specified Function message, length delimited. Does not implicitly {@link perftools.profiles.Function.verify|verify} messages.\n             * @function encodeDelimited\n             * @memberof perftools.profiles.Function\n             * @static\n             * @param {perftools.profiles.IFunction} message Function message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            Function.encodeDelimited = function encodeDelimited(message, writer) {\n                return this.encode(message, writer).ldelim();\n            };\n\n            /**\n             * Decodes a Function message from the specified reader or buffer.\n             * @function decode\n             * @memberof perftools.profiles.Function\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {perftools.profiles.Function} Function\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            Function.decode = function decode(reader, length) {\n                if (!(reader instanceof $Reader))\n                    reader = $Reader.create(reader);\n                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.perftools.profiles.Function();\n                while (reader.pos < end) {\n                    var tag = reader.uint32();\n                    switch (tag >>> 3) {\n                    case 1:\n                        message.id = reader.uint64();\n                        break;\n                    case 2:\n                        message.name = reader.int64();\n                        break;\n                    case 3:\n                        message.systemName = reader.int64();\n                        break;\n                    case 4:\n                        message.filename = reader.int64();\n                        break;\n                    case 5:\n                        message.startLine = reader.int64();\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                    }\n                }\n                return message;\n            };\n\n            /**\n             * Decodes a Function message from the specified reader or buffer, length delimited.\n             * @function decodeDelimited\n             * @memberof perftools.profiles.Function\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @returns {perftools.profiles.Function} Function\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            Function.decodeDelimited = function decodeDelimited(reader) {\n                if (!(reader instanceof $Reader))\n                    reader = new $Reader(reader);\n                return this.decode(reader, reader.uint32());\n            };\n\n            /**\n             * Verifies a Function message.\n             * @function verify\n             * @memberof perftools.profiles.Function\n             * @static\n             * @param {Object.<string,*>} message Plain object to verify\n             * @returns {string|null} `null` if valid, otherwise the reason why it is not\n             */\n            Function.verify = function verify(message) {\n                if (typeof message !== \"object\" || message === null)\n                    return \"object expected\";\n                if (message.id != null && message.hasOwnProperty(\"id\"))\n                    if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))\n                        return \"id: integer|Long expected\";\n                if (message.name != null && message.hasOwnProperty(\"name\"))\n                    if (!$util.isInteger(message.name) && !(message.name && $util.isInteger(message.name.low) && $util.isInteger(message.name.high)))\n                        return \"name: integer|Long expected\";\n                if (message.systemName != null && message.hasOwnProperty(\"systemName\"))\n                    if (!$util.isInteger(message.systemName) && !(message.systemName && $util.isInteger(message.systemName.low) && $util.isInteger(message.systemName.high)))\n                        return \"systemName: integer|Long expected\";\n                if (message.filename != null && message.hasOwnProperty(\"filename\"))\n                    if (!$util.isInteger(message.filename) && !(message.filename && $util.isInteger(message.filename.low) && $util.isInteger(message.filename.high)))\n                        return \"filename: integer|Long expected\";\n                if (message.startLine != null && message.hasOwnProperty(\"startLine\"))\n                    if (!$util.isInteger(message.startLine) && !(message.startLine && $util.isInteger(message.startLine.low) && $util.isInteger(message.startLine.high)))\n                        return \"startLine: integer|Long expected\";\n                return null;\n            };\n\n            /**\n             * Creates a Function message from a plain object. Also converts values to their respective internal types.\n             * @function fromObject\n             * @memberof perftools.profiles.Function\n             * @static\n             * @param {Object.<string,*>} object Plain object\n             * @returns {perftools.profiles.Function} Function\n             */\n            Function.fromObject = function fromObject(object) {\n                if (object instanceof $root.perftools.profiles.Function)\n                    return object;\n                var message = new $root.perftools.profiles.Function();\n                if (object.id != null)\n                    if ($util.Long)\n                        (message.id = $util.Long.fromValue(object.id)).unsigned = true;\n                    else if (typeof object.id === \"string\")\n                        message.id = parseInt(object.id, 10);\n                    else if (typeof object.id === \"number\")\n                        message.id = object.id;\n                    else if (typeof object.id === \"object\")\n                        message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);\n                if (object.name != null)\n                    if ($util.Long)\n                        (message.name = $util.Long.fromValue(object.name)).unsigned = false;\n                    else if (typeof object.name === \"string\")\n                        message.name = parseInt(object.name, 10);\n                    else if (typeof object.name === \"number\")\n                        message.name = object.name;\n                    else if (typeof object.name === \"object\")\n                        message.name = new $util.LongBits(object.name.low >>> 0, object.name.high >>> 0).toNumber();\n                if (object.systemName != null)\n                    if ($util.Long)\n                        (message.systemName = $util.Long.fromValue(object.systemName)).unsigned = false;\n                    else if (typeof object.systemName === \"string\")\n                        message.systemName = parseInt(object.systemName, 10);\n                    else if (typeof object.systemName === \"number\")\n                        message.systemName = object.systemName;\n                    else if (typeof object.systemName === \"object\")\n                        message.systemName = new $util.LongBits(object.systemName.low >>> 0, object.systemName.high >>> 0).toNumber();\n                if (object.filename != null)\n                    if ($util.Long)\n                        (message.filename = $util.Long.fromValue(object.filename)).unsigned = false;\n                    else if (typeof object.filename === \"string\")\n                        message.filename = parseInt(object.filename, 10);\n                    else if (typeof object.filename === \"number\")\n                        message.filename = object.filename;\n                    else if (typeof object.filename === \"object\")\n                        message.filename = new $util.LongBits(object.filename.low >>> 0, object.filename.high >>> 0).toNumber();\n                if (object.startLine != null)\n                    if ($util.Long)\n                        (message.startLine = $util.Long.fromValue(object.startLine)).unsigned = false;\n                    else if (typeof object.startLine === \"string\")\n                        message.startLine = parseInt(object.startLine, 10);\n                    else if (typeof object.startLine === \"number\")\n                        message.startLine = object.startLine;\n                    else if (typeof object.startLine === \"object\")\n                        message.startLine = new $util.LongBits(object.startLine.low >>> 0, object.startLine.high >>> 0).toNumber();\n                return message;\n            };\n\n            /**\n             * Creates a plain object from a Function message. Also converts values to other types if specified.\n             * @function toObject\n             * @memberof perftools.profiles.Function\n             * @static\n             * @param {perftools.profiles.Function} message Function\n             * @param {$protobuf.IConversionOptions} [options] Conversion options\n             * @returns {Object.<string,*>} Plain object\n             */\n            Function.toObject = function toObject(message, options) {\n                if (!options)\n                    options = {};\n                var object = {};\n                if (options.defaults) {\n                    if ($util.Long) {\n                        var long = new $util.Long(0, 0, true);\n                        object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                    } else\n                        object.id = options.longs === String ? \"0\" : 0;\n                    if ($util.Long) {\n                        var long = new $util.Long(0, 0, false);\n                        object.name = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                    } else\n                        object.name = options.longs === String ? \"0\" : 0;\n                    if ($util.Long) {\n                        var long = new $util.Long(0, 0, false);\n                        object.systemName = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                    } else\n                        object.systemName = options.longs === String ? \"0\" : 0;\n                    if ($util.Long) {\n                        var long = new $util.Long(0, 0, false);\n                        object.filename = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                    } else\n                        object.filename = options.longs === String ? \"0\" : 0;\n                    if ($util.Long) {\n                        var long = new $util.Long(0, 0, false);\n                        object.startLine = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                    } else\n                        object.startLine = options.longs === String ? \"0\" : 0;\n                }\n                if (message.id != null && message.hasOwnProperty(\"id\"))\n                    if (typeof message.id === \"number\")\n                        object.id = options.longs === String ? String(message.id) : message.id;\n                    else\n                        object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true) : message.id;\n                if (message.name != null && message.hasOwnProperty(\"name\"))\n                    if (typeof message.name === \"number\")\n                        object.name = options.longs === String ? String(message.name) : message.name;\n                    else\n                        object.name = options.longs === String ? $util.Long.prototype.toString.call(message.name) : options.longs === Number ? new $util.LongBits(message.name.low >>> 0, message.name.high >>> 0).toNumber() : message.name;\n                if (message.systemName != null && message.hasOwnProperty(\"systemName\"))\n                    if (typeof message.systemName === \"number\")\n                        object.systemName = options.longs === String ? String(message.systemName) : message.systemName;\n                    else\n                        object.systemName = options.longs === String ? $util.Long.prototype.toString.call(message.systemName) : options.longs === Number ? new $util.LongBits(message.systemName.low >>> 0, message.systemName.high >>> 0).toNumber() : message.systemName;\n                if (message.filename != null && message.hasOwnProperty(\"filename\"))\n                    if (typeof message.filename === \"number\")\n                        object.filename = options.longs === String ? String(message.filename) : message.filename;\n                    else\n                        object.filename = options.longs === String ? $util.Long.prototype.toString.call(message.filename) : options.longs === Number ? new $util.LongBits(message.filename.low >>> 0, message.filename.high >>> 0).toNumber() : message.filename;\n                if (message.startLine != null && message.hasOwnProperty(\"startLine\"))\n                    if (typeof message.startLine === \"number\")\n                        object.startLine = options.longs === String ? String(message.startLine) : message.startLine;\n                    else\n                        object.startLine = options.longs === String ? $util.Long.prototype.toString.call(message.startLine) : options.longs === Number ? new $util.LongBits(message.startLine.low >>> 0, message.startLine.high >>> 0).toNumber() : message.startLine;\n                return object;\n            };\n\n            /**\n             * Converts this Function to JSON.\n             * @function toJSON\n             * @memberof perftools.profiles.Function\n             * @instance\n             * @returns {Object.<string,*>} JSON object\n             */\n            Function.prototype.toJSON = function toJSON() {\n                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n            };\n\n            return Function;\n        })();\n\n        return profiles;\n    })();\n\n    return perftools;\n})();\n\nmodule.exports = $root;\n","'use strict';\nvar token = '%[a-f0-9]{2}';\nvar singleMatcher = new RegExp(token, 'gi');\nvar multiMatcher = new RegExp('(' + token + ')+', 'gi');\n\nfunction decodeComponents(components, split) {\n\ttry {\n\t\t// Try to decode the entire string first\n\t\treturn decodeURIComponent(components.join(''));\n\t} catch (err) {\n\t\t// Do nothing\n\t}\n\n\tif (components.length === 1) {\n\t\treturn components;\n\t}\n\n\tsplit = split || 1;\n\n\t// Split the array in 2 parts\n\tvar left = components.slice(0, split);\n\tvar right = components.slice(split);\n\n\treturn Array.prototype.concat.call([], decodeComponents(left), decodeComponents(right));\n}\n\nfunction decode(input) {\n\ttry {\n\t\treturn decodeURIComponent(input);\n\t} catch (err) {\n\t\tvar tokens = input.match(singleMatcher);\n\n\t\tfor (var i = 1; i < tokens.length; i++) {\n\t\t\tinput = decodeComponents(tokens, i).join('');\n\n\t\t\ttokens = input.match(singleMatcher);\n\t\t}\n\n\t\treturn input;\n\t}\n}\n\nfunction customDecodeURIComponent(input) {\n\t// Keep track of all the replacements and prefill the map with the `BOM`\n\tvar replaceMap = {\n\t\t'%FE%FF': '\\uFFFD\\uFFFD',\n\t\t'%FF%FE': '\\uFFFD\\uFFFD'\n\t};\n\n\tvar match = multiMatcher.exec(input);\n\twhile (match) {\n\t\ttry {\n\t\t\t// Decode as big chunks as possible\n\t\t\treplaceMap[match[0]] = decodeURIComponent(match[0]);\n\t\t} catch (err) {\n\t\t\tvar result = decode(match[0]);\n\n\t\t\tif (result !== match[0]) {\n\t\t\t\treplaceMap[match[0]] = result;\n\t\t\t}\n\t\t}\n\n\t\tmatch = multiMatcher.exec(input);\n\t}\n\n\t// Add `%C2` at the end of the map to make sure it does not replace the combinator before everything else\n\treplaceMap['%C2'] = '\\uFFFD';\n\n\tvar entries = Object.keys(replaceMap);\n\n\tfor (var i = 0; i < entries.length; i++) {\n\t\t// Replace all decoded components\n\t\tvar key = entries[i];\n\t\tinput = input.replace(new RegExp(key, 'g'), replaceMap[key]);\n\t}\n\n\treturn input;\n}\n\nmodule.exports = function (encodedURI) {\n\tif (typeof encodedURI !== 'string') {\n\t\tthrow new TypeError('Expected `encodedURI` to be of type `string`, got `' + typeof encodedURI + '`');\n\t}\n\n\ttry {\n\t\tencodedURI = encodedURI.replace(/\\+/g, ' ');\n\n\t\t// Try the built in decoder first\n\t\treturn decodeURIComponent(encodedURI);\n\t} catch (err) {\n\t\t// Fallback to a more advanced decoder\n\t\treturn customDecodeURIComponent(encodedURI);\n\t}\n};\n","'use strict'\n\nmodule.exports = clone\n\nvar getPrototypeOf = Object.getPrototypeOf || function (obj) {\n  return obj.__proto__\n}\n\nfunction clone (obj) {\n  if (obj === null || typeof obj !== 'object')\n    return obj\n\n  if (obj instanceof Object)\n    var copy = { __proto__: getPrototypeOf(obj) }\n  else\n    var copy = Object.create(null)\n\n  Object.getOwnPropertyNames(obj).forEach(function (key) {\n    Object.defineProperty(copy, key, Object.getOwnPropertyDescriptor(obj, key))\n  })\n\n  return copy\n}\n","var fs = require('fs')\nvar polyfills = require('./polyfills.js')\nvar legacy = require('./legacy-streams.js')\nvar clone = require('./clone.js')\n\nvar util = require('util')\n\n/* istanbul ignore next - node 0.x polyfill */\nvar gracefulQueue\nvar previousSymbol\n\n/* istanbul ignore else - node 0.x polyfill */\nif (typeof Symbol === 'function' && typeof Symbol.for === 'function') {\n  gracefulQueue = Symbol.for('graceful-fs.queue')\n  // This is used in testing by future versions\n  previousSymbol = Symbol.for('graceful-fs.previous')\n} else {\n  gracefulQueue = '___graceful-fs.queue'\n  previousSymbol = '___graceful-fs.previous'\n}\n\nfunction noop () {}\n\nfunction publishQueue(context, queue) {\n  Object.defineProperty(context, gracefulQueue, {\n    get: function() {\n      return queue\n    }\n  })\n}\n\nvar debug = noop\nif (util.debuglog)\n  debug = util.debuglog('gfs4')\nelse if (/\\bgfs4\\b/i.test(process.env.NODE_DEBUG || ''))\n  debug = function() {\n    var m = util.format.apply(util, arguments)\n    m = 'GFS4: ' + m.split(/\\n/).join('\\nGFS4: ')\n    console.error(m)\n  }\n\n// Once time initialization\nif (!fs[gracefulQueue]) {\n  // This queue can be shared by multiple loaded instances\n  var queue = global[gracefulQueue] || []\n  publishQueue(fs, queue)\n\n  // Patch fs.close/closeSync to shared queue version, because we need\n  // to retry() whenever a close happens *anywhere* in the program.\n  // This is essential when multiple graceful-fs instances are\n  // in play at the same time.\n  fs.close = (function (fs$close) {\n    function close (fd, cb) {\n      return fs$close.call(fs, fd, function (err) {\n        // This function uses the graceful-fs shared queue\n        if (!err) {\n          resetQueue()\n        }\n\n        if (typeof cb === 'function')\n          cb.apply(this, arguments)\n      })\n    }\n\n    Object.defineProperty(close, previousSymbol, {\n      value: fs$close\n    })\n    return close\n  })(fs.close)\n\n  fs.closeSync = (function (fs$closeSync) {\n    function closeSync (fd) {\n      // This function uses the graceful-fs shared queue\n      fs$closeSync.apply(fs, arguments)\n      resetQueue()\n    }\n\n    Object.defineProperty(closeSync, previousSymbol, {\n      value: fs$closeSync\n    })\n    return closeSync\n  })(fs.closeSync)\n\n  if (/\\bgfs4\\b/i.test(process.env.NODE_DEBUG || '')) {\n    process.on('exit', function() {\n      debug(fs[gracefulQueue])\n      require('assert').equal(fs[gracefulQueue].length, 0)\n    })\n  }\n}\n\nif (!global[gracefulQueue]) {\n  publishQueue(global, fs[gracefulQueue]);\n}\n\nmodule.exports = patch(clone(fs))\nif (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs.__patched) {\n    module.exports = patch(fs)\n    fs.__patched = true;\n}\n\nfunction patch (fs) {\n  // Everything that references the open() function needs to be in here\n  polyfills(fs)\n  fs.gracefulify = patch\n\n  fs.createReadStream = createReadStream\n  fs.createWriteStream = createWriteStream\n  var fs$readFile = fs.readFile\n  fs.readFile = readFile\n  function readFile (path, options, cb) {\n    if (typeof options === 'function')\n      cb = options, options = null\n\n    return go$readFile(path, options, cb)\n\n    function go$readFile (path, options, cb, startTime) {\n      return fs$readFile(path, options, function (err) {\n        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))\n          enqueue([go$readFile, [path, options, cb], err, startTime || Date.now(), Date.now()])\n        else {\n          if (typeof cb === 'function')\n            cb.apply(this, arguments)\n        }\n      })\n    }\n  }\n\n  var fs$writeFile = fs.writeFile\n  fs.writeFile = writeFile\n  function writeFile (path, data, options, cb) {\n    if (typeof options === 'function')\n      cb = options, options = null\n\n    return go$writeFile(path, data, options, cb)\n\n    function go$writeFile (path, data, options, cb, startTime) {\n      return fs$writeFile(path, data, options, function (err) {\n        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))\n          enqueue([go$writeFile, [path, data, options, cb], err, startTime || Date.now(), Date.now()])\n        else {\n          if (typeof cb === 'function')\n            cb.apply(this, arguments)\n        }\n      })\n    }\n  }\n\n  var fs$appendFile = fs.appendFile\n  if (fs$appendFile)\n    fs.appendFile = appendFile\n  function appendFile (path, data, options, cb) {\n    if (typeof options === 'function')\n      cb = options, options = null\n\n    return go$appendFile(path, data, options, cb)\n\n    function go$appendFile (path, data, options, cb, startTime) {\n      return fs$appendFile(path, data, options, function (err) {\n        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))\n          enqueue([go$appendFile, [path, data, options, cb], err, startTime || Date.now(), Date.now()])\n        else {\n          if (typeof cb === 'function')\n            cb.apply(this, arguments)\n        }\n      })\n    }\n  }\n\n  var fs$copyFile = fs.copyFile\n  if (fs$copyFile)\n    fs.copyFile = copyFile\n  function copyFile (src, dest, flags, cb) {\n    if (typeof flags === 'function') {\n      cb = flags\n      flags = 0\n    }\n    return go$copyFile(src, dest, flags, cb)\n\n    function go$copyFile (src, dest, flags, cb, startTime) {\n      return fs$copyFile(src, dest, flags, function (err) {\n        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))\n          enqueue([go$copyFile, [src, dest, flags, cb], err, startTime || Date.now(), Date.now()])\n        else {\n          if (typeof cb === 'function')\n            cb.apply(this, arguments)\n        }\n      })\n    }\n  }\n\n  var fs$readdir = fs.readdir\n  fs.readdir = readdir\n  function readdir (path, options, cb) {\n    if (typeof options === 'function')\n      cb = options, options = null\n\n    return go$readdir(path, options, cb)\n\n    function go$readdir (path, options, cb, startTime) {\n      return fs$readdir(path, options, function (err, files) {\n        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))\n          enqueue([go$readdir, [path, options, cb], err, startTime || Date.now(), Date.now()])\n        else {\n          if (files && files.sort)\n            files.sort()\n\n          if (typeof cb === 'function')\n            cb.call(this, err, files)\n        }\n      })\n    }\n  }\n\n  if (process.version.substr(0, 4) === 'v0.8') {\n    var legStreams = legacy(fs)\n    ReadStream = legStreams.ReadStream\n    WriteStream = legStreams.WriteStream\n  }\n\n  var fs$ReadStream = fs.ReadStream\n  if (fs$ReadStream) {\n    ReadStream.prototype = Object.create(fs$ReadStream.prototype)\n    ReadStream.prototype.open = ReadStream$open\n  }\n\n  var fs$WriteStream = fs.WriteStream\n  if (fs$WriteStream) {\n    WriteStream.prototype = Object.create(fs$WriteStream.prototype)\n    WriteStream.prototype.open = WriteStream$open\n  }\n\n  Object.defineProperty(fs, 'ReadStream', {\n    get: function () {\n      return ReadStream\n    },\n    set: function (val) {\n      ReadStream = val\n    },\n    enumerable: true,\n    configurable: true\n  })\n  Object.defineProperty(fs, 'WriteStream', {\n    get: function () {\n      return WriteStream\n    },\n    set: function (val) {\n      WriteStream = val\n    },\n    enumerable: true,\n    configurable: true\n  })\n\n  // legacy names\n  var FileReadStream = ReadStream\n  Object.defineProperty(fs, 'FileReadStream', {\n    get: function () {\n      return FileReadStream\n    },\n    set: function (val) {\n      FileReadStream = val\n    },\n    enumerable: true,\n    configurable: true\n  })\n  var FileWriteStream = WriteStream\n  Object.defineProperty(fs, 'FileWriteStream', {\n    get: function () {\n      return FileWriteStream\n    },\n    set: function (val) {\n      FileWriteStream = val\n    },\n    enumerable: true,\n    configurable: true\n  })\n\n  function ReadStream (path, options) {\n    if (this instanceof ReadStream)\n      return fs$ReadStream.apply(this, arguments), this\n    else\n      return ReadStream.apply(Object.create(ReadStream.prototype), arguments)\n  }\n\n  function ReadStream$open () {\n    var that = this\n    open(that.path, that.flags, that.mode, function (err, fd) {\n      if (err) {\n        if (that.autoClose)\n          that.destroy()\n\n        that.emit('error', err)\n      } else {\n        that.fd = fd\n        that.emit('open', fd)\n        that.read()\n      }\n    })\n  }\n\n  function WriteStream (path, options) {\n    if (this instanceof WriteStream)\n      return fs$WriteStream.apply(this, arguments), this\n    else\n      return WriteStream.apply(Object.create(WriteStream.prototype), arguments)\n  }\n\n  function WriteStream$open () {\n    var that = this\n    open(that.path, that.flags, that.mode, function (err, fd) {\n      if (err) {\n        that.destroy()\n        that.emit('error', err)\n      } else {\n        that.fd = fd\n        that.emit('open', fd)\n      }\n    })\n  }\n\n  function createReadStream (path, options) {\n    return new fs.ReadStream(path, options)\n  }\n\n  function createWriteStream (path, options) {\n    return new fs.WriteStream(path, options)\n  }\n\n  var fs$open = fs.open\n  fs.open = open\n  function open (path, flags, mode, cb) {\n    if (typeof mode === 'function')\n      cb = mode, mode = null\n\n    return go$open(path, flags, mode, cb)\n\n    function go$open (path, flags, mode, cb, startTime) {\n      return fs$open(path, flags, mode, function (err, fd) {\n        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))\n          enqueue([go$open, [path, flags, mode, cb], err, startTime || Date.now(), Date.now()])\n        else {\n          if (typeof cb === 'function')\n            cb.apply(this, arguments)\n        }\n      })\n    }\n  }\n\n  return fs\n}\n\nfunction enqueue (elem) {\n  debug('ENQUEUE', elem[0].name, elem[1])\n  fs[gracefulQueue].push(elem)\n  retry()\n}\n\n// keep track of the timeout between retry() calls\nvar retryTimer\n\n// reset the startTime and lastTime to now\n// this resets the start of the 60 second overall timeout as well as the\n// delay between attempts so that we'll retry these jobs sooner\nfunction resetQueue () {\n  var now = Date.now()\n  for (var i = 0; i < fs[gracefulQueue].length; ++i) {\n    // entries that are only a length of 2 are from an older version, don't\n    // bother modifying those since they'll be retried anyway.\n    if (fs[gracefulQueue][i].length > 2) {\n      fs[gracefulQueue][i][3] = now // startTime\n      fs[gracefulQueue][i][4] = now // lastTime\n    }\n  }\n  // call retry to make sure we're actively processing the queue\n  retry()\n}\n\nfunction retry () {\n  // clear the timer and remove it to help prevent unintended concurrency\n  clearTimeout(retryTimer)\n  retryTimer = undefined\n\n  if (fs[gracefulQueue].length === 0)\n    return\n\n  var elem = fs[gracefulQueue].shift()\n  var fn = elem[0]\n  var args = elem[1]\n  // these items may be unset if they were added by an older graceful-fs\n  var err = elem[2]\n  var startTime = elem[3]\n  var lastTime = elem[4]\n\n  // if we don't have a startTime we have no way of knowing if we've waited\n  // long enough, so go ahead and retry this item now\n  if (startTime === undefined) {\n    debug('RETRY', fn.name, args)\n    fn.apply(null, args)\n  } else if (Date.now() - startTime >= 60000) {\n    // it's been more than 60 seconds total, bail now\n    debug('TIMEOUT', fn.name, args)\n    var cb = args.pop()\n    if (typeof cb === 'function')\n      cb.call(null, err)\n  } else {\n    // the amount of time between the last attempt and right now\n    var sinceAttempt = Date.now() - lastTime\n    // the amount of time between when we first tried, and when we last tried\n    // rounded up to at least 1\n    var sinceStart = Math.max(lastTime - startTime, 1)\n    // backoff. wait longer than the total time we've been retrying, but only\n    // up to a maximum of 100ms\n    var desiredDelay = Math.min(sinceStart * 1.2, 100)\n    // it's been long enough since the last retry, do it again\n    if (sinceAttempt >= desiredDelay) {\n      debug('RETRY', fn.name, args)\n      fn.apply(null, args.concat([startTime]))\n    } else {\n      // if we can't do this job yet, push it to the end of the queue\n      // and let the next iteration check again\n      fs[gracefulQueue].push(elem)\n    }\n  }\n\n  // schedule our next run if one isn't already scheduled\n  if (retryTimer === undefined) {\n    retryTimer = setTimeout(retry, 0)\n  }\n}\n","var Stream = require('stream').Stream\n\nmodule.exports = legacy\n\nfunction legacy (fs) {\n  return {\n    ReadStream: ReadStream,\n    WriteStream: WriteStream\n  }\n\n  function ReadStream (path, options) {\n    if (!(this instanceof ReadStream)) return new ReadStream(path, options);\n\n    Stream.call(this);\n\n    var self = this;\n\n    this.path = path;\n    this.fd = null;\n    this.readable = true;\n    this.paused = false;\n\n    this.flags = 'r';\n    this.mode = 438; /*=0666*/\n    this.bufferSize = 64 * 1024;\n\n    options = options || {};\n\n    // Mixin options into this\n    var keys = Object.keys(options);\n    for (var index = 0, length = keys.length; index < length; index++) {\n      var key = keys[index];\n      this[key] = options[key];\n    }\n\n    if (this.encoding) this.setEncoding(this.encoding);\n\n    if (this.start !== undefined) {\n      if ('number' !== typeof this.start) {\n        throw TypeError('start must be a Number');\n      }\n      if (this.end === undefined) {\n        this.end = Infinity;\n      } else if ('number' !== typeof this.end) {\n        throw TypeError('end must be a Number');\n      }\n\n      if (this.start > this.end) {\n        throw new Error('start must be <= end');\n      }\n\n      this.pos = this.start;\n    }\n\n    if (this.fd !== null) {\n      process.nextTick(function() {\n        self._read();\n      });\n      return;\n    }\n\n    fs.open(this.path, this.flags, this.mode, function (err, fd) {\n      if (err) {\n        self.emit('error', err);\n        self.readable = false;\n        return;\n      }\n\n      self.fd = fd;\n      self.emit('open', fd);\n      self._read();\n    })\n  }\n\n  function WriteStream (path, options) {\n    if (!(this instanceof WriteStream)) return new WriteStream(path, options);\n\n    Stream.call(this);\n\n    this.path = path;\n    this.fd = null;\n    this.writable = true;\n\n    this.flags = 'w';\n    this.encoding = 'binary';\n    this.mode = 438; /*=0666*/\n    this.bytesWritten = 0;\n\n    options = options || {};\n\n    // Mixin options into this\n    var keys = Object.keys(options);\n    for (var index = 0, length = keys.length; index < length; index++) {\n      var key = keys[index];\n      this[key] = options[key];\n    }\n\n    if (this.start !== undefined) {\n      if ('number' !== typeof this.start) {\n        throw TypeError('start must be a Number');\n      }\n      if (this.start < 0) {\n        throw new Error('start must be >= zero');\n      }\n\n      this.pos = this.start;\n    }\n\n    this.busy = false;\n    this._queue = [];\n\n    if (this.fd === null) {\n      this._open = fs.open;\n      this._queue.push([this._open, this.path, this.flags, this.mode, undefined]);\n      this.flush();\n    }\n  }\n}\n","var constants = require('constants')\n\nvar origCwd = process.cwd\nvar cwd = null\n\nvar platform = process.env.GRACEFUL_FS_PLATFORM || process.platform\n\nprocess.cwd = function() {\n  if (!cwd)\n    cwd = origCwd.call(process)\n  return cwd\n}\ntry {\n  process.cwd()\n} catch (er) {}\n\n// This check is needed until node.js 12 is required\nif (typeof process.chdir === 'function') {\n  var chdir = process.chdir\n  process.chdir = function (d) {\n    cwd = null\n    chdir.call(process, d)\n  }\n  if (Object.setPrototypeOf) Object.setPrototypeOf(process.chdir, chdir)\n}\n\nmodule.exports = patch\n\nfunction patch (fs) {\n  // (re-)implement some things that are known busted or missing.\n\n  // lchmod, broken prior to 0.6.2\n  // back-port the fix here.\n  if (constants.hasOwnProperty('O_SYMLINK') &&\n      process.version.match(/^v0\\.6\\.[0-2]|^v0\\.5\\./)) {\n    patchLchmod(fs)\n  }\n\n  // lutimes implementation, or no-op\n  if (!fs.lutimes) {\n    patchLutimes(fs)\n  }\n\n  // https://github.com/isaacs/node-graceful-fs/issues/4\n  // Chown should not fail on einval or eperm if non-root.\n  // It should not fail on enosys ever, as this just indicates\n  // that a fs doesn't support the intended operation.\n\n  fs.chown = chownFix(fs.chown)\n  fs.fchown = chownFix(fs.fchown)\n  fs.lchown = chownFix(fs.lchown)\n\n  fs.chmod = chmodFix(fs.chmod)\n  fs.fchmod = chmodFix(fs.fchmod)\n  fs.lchmod = chmodFix(fs.lchmod)\n\n  fs.chownSync = chownFixSync(fs.chownSync)\n  fs.fchownSync = chownFixSync(fs.fchownSync)\n  fs.lchownSync = chownFixSync(fs.lchownSync)\n\n  fs.chmodSync = chmodFixSync(fs.chmodSync)\n  fs.fchmodSync = chmodFixSync(fs.fchmodSync)\n  fs.lchmodSync = chmodFixSync(fs.lchmodSync)\n\n  fs.stat = statFix(fs.stat)\n  fs.fstat = statFix(fs.fstat)\n  fs.lstat = statFix(fs.lstat)\n\n  fs.statSync = statFixSync(fs.statSync)\n  fs.fstatSync = statFixSync(fs.fstatSync)\n  fs.lstatSync = statFixSync(fs.lstatSync)\n\n  // if lchmod/lchown do not exist, then make them no-ops\n  if (!fs.lchmod) {\n    fs.lchmod = function (path, mode, cb) {\n      if (cb) process.nextTick(cb)\n    }\n    fs.lchmodSync = function () {}\n  }\n  if (!fs.lchown) {\n    fs.lchown = function (path, uid, gid, cb) {\n      if (cb) process.nextTick(cb)\n    }\n    fs.lchownSync = function () {}\n  }\n\n  // on Windows, A/V software can lock the directory, causing this\n  // to fail with an EACCES or EPERM if the directory contains newly\n  // created files.  Try again on failure, for up to 60 seconds.\n\n  // Set the timeout this long because some Windows Anti-Virus, such as Parity\n  // bit9, may lock files for up to a minute, causing npm package install\n  // failures. Also, take care to yield the scheduler. Windows scheduling gives\n  // CPU to a busy looping process, which can cause the program causing the lock\n  // contention to be starved of CPU by node, so the contention doesn't resolve.\n  if (platform === \"win32\") {\n    fs.rename = (function (fs$rename) { return function (from, to, cb) {\n      var start = Date.now()\n      var backoff = 0;\n      fs$rename(from, to, function CB (er) {\n        if (er\n            && (er.code === \"EACCES\" || er.code === \"EPERM\")\n            && Date.now() - start < 60000) {\n          setTimeout(function() {\n            fs.stat(to, function (stater, st) {\n              if (stater && stater.code === \"ENOENT\")\n                fs$rename(from, to, CB);\n              else\n                cb(er)\n            })\n          }, backoff)\n          if (backoff < 100)\n            backoff += 10;\n          return;\n        }\n        if (cb) cb(er)\n      })\n    }})(fs.rename)\n  }\n\n  // if read() returns EAGAIN, then just try it again.\n  fs.read = (function (fs$read) {\n    function read (fd, buffer, offset, length, position, callback_) {\n      var callback\n      if (callback_ && typeof callback_ === 'function') {\n        var eagCounter = 0\n        callback = function (er, _, __) {\n          if (er && er.code === 'EAGAIN' && eagCounter < 10) {\n            eagCounter ++\n            return fs$read.call(fs, fd, buffer, offset, length, position, callback)\n          }\n          callback_.apply(this, arguments)\n        }\n      }\n      return fs$read.call(fs, fd, buffer, offset, length, position, callback)\n    }\n\n    // This ensures `util.promisify` works as it does for native `fs.read`.\n    if (Object.setPrototypeOf) Object.setPrototypeOf(read, fs$read)\n    return read\n  })(fs.read)\n\n  fs.readSync = (function (fs$readSync) { return function (fd, buffer, offset, length, position) {\n    var eagCounter = 0\n    while (true) {\n      try {\n        return fs$readSync.call(fs, fd, buffer, offset, length, position)\n      } catch (er) {\n        if (er.code === 'EAGAIN' && eagCounter < 10) {\n          eagCounter ++\n          continue\n        }\n        throw er\n      }\n    }\n  }})(fs.readSync)\n\n  function patchLchmod (fs) {\n    fs.lchmod = function (path, mode, callback) {\n      fs.open( path\n             , constants.O_WRONLY | constants.O_SYMLINK\n             , mode\n             , function (err, fd) {\n        if (err) {\n          if (callback) callback(err)\n          return\n        }\n        // prefer to return the chmod error, if one occurs,\n        // but still try to close, and report closing errors if they occur.\n        fs.fchmod(fd, mode, function (err) {\n          fs.close(fd, function(err2) {\n            if (callback) callback(err || err2)\n          })\n        })\n      })\n    }\n\n    fs.lchmodSync = function (path, mode) {\n      var fd = fs.openSync(path, constants.O_WRONLY | constants.O_SYMLINK, mode)\n\n      // prefer to return the chmod error, if one occurs,\n      // but still try to close, and report closing errors if they occur.\n      var threw = true\n      var ret\n      try {\n        ret = fs.fchmodSync(fd, mode)\n        threw = false\n      } finally {\n        if (threw) {\n          try {\n            fs.closeSync(fd)\n          } catch (er) {}\n        } else {\n          fs.closeSync(fd)\n        }\n      }\n      return ret\n    }\n  }\n\n  function patchLutimes (fs) {\n    if (constants.hasOwnProperty(\"O_SYMLINK\")) {\n      fs.lutimes = function (path, at, mt, cb) {\n        fs.open(path, constants.O_SYMLINK, function (er, fd) {\n          if (er) {\n            if (cb) cb(er)\n            return\n          }\n          fs.futimes(fd, at, mt, function (er) {\n            fs.close(fd, function (er2) {\n              if (cb) cb(er || er2)\n            })\n          })\n        })\n      }\n\n      fs.lutimesSync = function (path, at, mt) {\n        var fd = fs.openSync(path, constants.O_SYMLINK)\n        var ret\n        var threw = true\n        try {\n          ret = fs.futimesSync(fd, at, mt)\n          threw = false\n        } finally {\n          if (threw) {\n            try {\n              fs.closeSync(fd)\n            } catch (er) {}\n          } else {\n            fs.closeSync(fd)\n          }\n        }\n        return ret\n      }\n\n    } else {\n      fs.lutimes = function (_a, _b, _c, cb) { if (cb) process.nextTick(cb) }\n      fs.lutimesSync = function () {}\n    }\n  }\n\n  function chmodFix (orig) {\n    if (!orig) return orig\n    return function (target, mode, cb) {\n      return orig.call(fs, target, mode, function (er) {\n        if (chownErOk(er)) er = null\n        if (cb) cb.apply(this, arguments)\n      })\n    }\n  }\n\n  function chmodFixSync (orig) {\n    if (!orig) return orig\n    return function (target, mode) {\n      try {\n        return orig.call(fs, target, mode)\n      } catch (er) {\n        if (!chownErOk(er)) throw er\n      }\n    }\n  }\n\n\n  function chownFix (orig) {\n    if (!orig) return orig\n    return function (target, uid, gid, cb) {\n      return orig.call(fs, target, uid, gid, function (er) {\n        if (chownErOk(er)) er = null\n        if (cb) cb.apply(this, arguments)\n      })\n    }\n  }\n\n  function chownFixSync (orig) {\n    if (!orig) return orig\n    return function (target, uid, gid) {\n      try {\n        return orig.call(fs, target, uid, gid)\n      } catch (er) {\n        if (!chownErOk(er)) throw er\n      }\n    }\n  }\n\n  function statFix (orig) {\n    if (!orig) return orig\n    // Older versions of Node erroneously returned signed integers for\n    // uid + gid.\n    return function (target, options, cb) {\n      if (typeof options === 'function') {\n        cb = options\n        options = null\n      }\n      function callback (er, stats) {\n        if (stats) {\n          if (stats.uid < 0) stats.uid += 0x100000000\n          if (stats.gid < 0) stats.gid += 0x100000000\n        }\n        if (cb) cb.apply(this, arguments)\n      }\n      return options ? orig.call(fs, target, options, callback)\n        : orig.call(fs, target, callback)\n    }\n  }\n\n  function statFixSync (orig) {\n    if (!orig) return orig\n    // Older versions of Node erroneously returned signed integers for\n    // uid + gid.\n    return function (target, options) {\n      var stats = options ? orig.call(fs, target, options)\n        : orig.call(fs, target)\n      if (stats.uid < 0) stats.uid += 0x100000000\n      if (stats.gid < 0) stats.gid += 0x100000000\n      return stats;\n    }\n  }\n\n  // ENOSYS means that the fs doesn't support the op. Just ignore\n  // that, because it doesn't matter.\n  //\n  // if there's no getuid, or if getuid() is something other\n  // than 0, and the error is EINVAL or EPERM, then just ignore\n  // it.\n  //\n  // This specific case is a silent failure in cp, install, tar,\n  // and most other unix tools that manage permissions.\n  //\n  // When running as root, or if other types of errors are\n  // encountered, then it's strict.\n  function chownErOk (er) {\n    if (!er)\n      return true\n\n    if (er.code === \"ENOSYS\")\n      return true\n\n    var nonroot = !process.getuid || process.getuid() !== 0\n    if (nonroot) {\n      if (er.code === \"EINVAL\" || er.code === \"EPERM\")\n        return true\n    }\n\n    return false\n  }\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * This is a TypeScript port of the original Java version, which was written by\n * Gil Tene as described in\n * https://github.com/HdrHistogram/HdrHistogram\n * and released to the public domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\nvar ByteBuffer_1 = require(\"./ByteBuffer\");\nvar AbstractHistogram_1 = require(\"./AbstractHistogram\");\nvar ZigZagEncoding_1 = require(\"./ZigZagEncoding\");\nvar max = Math.max;\nvar V2EncodingCookieBase = 0x1c849303;\nvar V2CompressedEncodingCookieBase = 0x1c849304;\nvar V2maxWordSizeInBytes = 9; // LEB128-64b9B + ZigZag require up to 9 bytes per word\nvar encodingCookie = V2EncodingCookieBase | 0x10; // LSBit of wordsize byte indicates TLZE Encoding\nvar compressedEncodingCookie = V2CompressedEncodingCookieBase | 0x10; // LSBit of wordsize byte indicates TLZE Encoding\nfunction fillBufferFromCountsArray(self, buffer) {\n    var countsLimit = self.countsArrayIndex(self.maxValue) + 1;\n    var srcIndex = 0;\n    while (srcIndex < countsLimit) {\n        // V2 encoding format uses a ZigZag LEB128-64b9B encoded long. Positive values are counts,\n        // while negative values indicate a repeat zero counts.\n        var count = self.getCountAtIndex(srcIndex++);\n        if (count < 0) {\n            throw new Error(\"Cannot encode histogram containing negative counts (\" +\n                count +\n                \") at index \" +\n                srcIndex +\n                \", corresponding the value range [\" +\n                self.lowestEquivalentValue(self.valueFromIndex(srcIndex)) +\n                \",\" +\n                self.nextNonEquivalentValue(self.valueFromIndex(srcIndex)) +\n                \")\");\n        }\n        // Count trailing 0s (which follow this count):\n        var zerosCount = 0;\n        if (count == 0) {\n            zerosCount = 1;\n            while (srcIndex < countsLimit && self.getCountAtIndex(srcIndex) == 0) {\n                zerosCount++;\n                srcIndex++;\n            }\n        }\n        if (zerosCount > 1) {\n            ZigZagEncoding_1.default.encode(buffer, -zerosCount);\n        }\n        else {\n            ZigZagEncoding_1.default.encode(buffer, count);\n        }\n    }\n}\n/**\n * Encode this histogram into a ByteBuffer\n * @param buffer The buffer to encode into\n * @return The number of bytes written to the buffer\n */\nfunction encodeIntoByteBuffer(buffer) {\n    var self = this;\n    var initialPosition = buffer.position;\n    buffer.putInt32(encodingCookie);\n    buffer.putInt32(0); // Placeholder for payload length in bytes.\n    buffer.putInt32(1);\n    buffer.putInt32(self.numberOfSignificantValueDigits);\n    buffer.putInt64(self.lowestDiscernibleValue);\n    buffer.putInt64(self.highestTrackableValue);\n    buffer.putInt64(1);\n    var payloadStartPosition = buffer.position;\n    fillBufferFromCountsArray(self, buffer);\n    var backupIndex = buffer.position;\n    buffer.position = initialPosition + 4;\n    buffer.putInt32(backupIndex - payloadStartPosition); // Record the payload length\n    buffer.position = backupIndex;\n    return backupIndex - initialPosition;\n}\nexports.encodeIntoByteBuffer = encodeIntoByteBuffer;\nfunction fillCountsArrayFromSourceBuffer(self, sourceBuffer, lengthInBytes, wordSizeInBytes) {\n    if (wordSizeInBytes != 2 &&\n        wordSizeInBytes != 4 &&\n        wordSizeInBytes != 8 &&\n        wordSizeInBytes != V2maxWordSizeInBytes) {\n        throw new Error(\"word size must be 2, 4, 8, or V2maxWordSizeInBytes (\" +\n            V2maxWordSizeInBytes +\n            \") bytes\");\n    }\n    var dstIndex = 0;\n    var endPosition = sourceBuffer.position + lengthInBytes;\n    while (sourceBuffer.position < endPosition) {\n        var zerosCount = 0;\n        var count = ZigZagEncoding_1.default.decode(sourceBuffer);\n        if (count < 0) {\n            zerosCount = -count;\n            dstIndex += zerosCount; // No need to set zeros in array. Just skip them.\n        }\n        else {\n            self.setCountAtIndex(dstIndex++, count);\n        }\n    }\n    return dstIndex; // this is the destination length\n}\nfunction getCookieBase(cookie) {\n    return cookie & ~0xf0;\n}\nfunction getWordSizeInBytesFromCookie(cookie) {\n    if (getCookieBase(cookie) == V2EncodingCookieBase ||\n        getCookieBase(cookie) == V2CompressedEncodingCookieBase) {\n        return V2maxWordSizeInBytes;\n    }\n    var sizeByte = (cookie & 0xf0) >> 4;\n    return sizeByte & 0xe;\n}\nfunction doDecodeFromByteBuffer(buffer, histogramConstr, minBarForHighestTrackableValue) {\n    var cookie = buffer.getInt32();\n    var payloadLengthInBytes;\n    var numberOfSignificantValueDigits;\n    var lowestTrackableUnitValue;\n    var highestTrackableValue;\n    if (getCookieBase(cookie) === V2EncodingCookieBase) {\n        if (getWordSizeInBytesFromCookie(cookie) != V2maxWordSizeInBytes) {\n            throw new Error(\"The buffer does not contain a Histogram (no valid cookie found)\");\n        }\n        payloadLengthInBytes = buffer.getInt32();\n        buffer.getInt32(); // normalizingIndexOffset not used\n        numberOfSignificantValueDigits = buffer.getInt32();\n        lowestTrackableUnitValue = buffer.getInt64();\n        highestTrackableValue = buffer.getInt64();\n        buffer.getInt64(); // integerToDoubleValueConversionRatio not used\n    }\n    else {\n        throw new Error(\"The buffer does not contain a Histogram (no valid V2 encoding cookie found)\");\n    }\n    highestTrackableValue = max(highestTrackableValue, minBarForHighestTrackableValue);\n    var histogram = new histogramConstr(lowestTrackableUnitValue, highestTrackableValue, numberOfSignificantValueDigits);\n    var filledLength = fillCountsArrayFromSourceBuffer(histogram, buffer, payloadLengthInBytes, V2maxWordSizeInBytes);\n    histogram.establishInternalTackingValues(filledLength);\n    return histogram;\n}\nexports.doDecodeFromByteBuffer = doDecodeFromByteBuffer;\nfunction findDeflateFunction() {\n    try {\n        return eval('require(\"zlib\").deflateSync');\n    }\n    catch (error) {\n        var pako = require(\"pako/lib/deflate\");\n        return pako.deflate;\n    }\n}\nfunction findInflateFunction() {\n    try {\n        return eval('require(\"zlib\").inflateSync');\n    }\n    catch (error) {\n        var pako = require(\"pako/lib/inflate\");\n        return pako.inflate;\n    }\n}\nvar deflate = findDeflateFunction();\nvar inflate = findInflateFunction();\nfunction doDecodeFromCompressedByteBuffer(buffer, histogramConstr, minBarForHighestTrackableValue) {\n    var initialTargetPosition = buffer.position;\n    var cookie = buffer.getInt32();\n    if ((cookie & ~0xf0) !== V2CompressedEncodingCookieBase) {\n        throw new Error(\"Encoding not supported, only V2 is supported\");\n    }\n    var lengthOfCompressedContents = buffer.getInt32();\n    var uncompressedBuffer = inflate(buffer.data.slice(initialTargetPosition + 8, initialTargetPosition + 8 + lengthOfCompressedContents));\n    return doDecodeFromByteBuffer(new ByteBuffer_1.default(uncompressedBuffer), histogramConstr, minBarForHighestTrackableValue);\n}\nexports.doDecodeFromCompressedByteBuffer = doDecodeFromCompressedByteBuffer;\n/**\n * Encode this histogram in compressed form into a byte array\n * @param targetBuffer The buffer to encode into\n * @return The number of bytes written to the array\n */\nfunction encodeIntoCompressedByteBuffer(targetBuffer, compressionLevel) {\n    var self = this;\n    var intermediateUncompressedByteBuffer = ByteBuffer_1.default.allocate();\n    var uncompressedLength = self.encodeIntoByteBuffer(intermediateUncompressedByteBuffer);\n    targetBuffer.putInt32(compressedEncodingCookie);\n    var compressionOptions = compressionLevel\n        ? { level: compressionLevel }\n        : {};\n    var compressedArray = deflate(intermediateUncompressedByteBuffer.data.slice(0, uncompressedLength), compressionOptions);\n    targetBuffer.putInt32(compressedArray.byteLength);\n    targetBuffer.putArray(compressedArray);\n    return targetBuffer.position;\n}\nexports.encodeIntoCompressedByteBuffer = encodeIntoCompressedByteBuffer;\nAbstractHistogram_1.AbstractHistogram.decodeFromByteBuffer = doDecodeFromByteBuffer;\nAbstractHistogram_1.AbstractHistogram.decodeFromCompressedByteBuffer = doDecodeFromCompressedByteBuffer;\nAbstractHistogram_1.AbstractHistogram.prototype.encodeIntoByteBuffer = encodeIntoByteBuffer;\nAbstractHistogram_1.AbstractHistogram.prototype.encodeIntoCompressedByteBuffer = encodeIntoCompressedByteBuffer;\n//# sourceMappingURL=AbstractHistogram.encoding.js.map","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * This is a TypeScript port of the original Java version, which was written by\n * Gil Tene as described in\n * https://github.com/HdrHistogram/HdrHistogram\n * and released to the public domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\nvar AbstractHistogramBase_1 = require(\"./AbstractHistogramBase\");\nvar RecordedValuesIterator_1 = require(\"./RecordedValuesIterator\");\nvar PercentileIterator_1 = require(\"./PercentileIterator\");\nvar formatters_1 = require(\"./formatters\");\nvar ulp_1 = require(\"./ulp\");\nvar pow = Math.pow, floor = Math.floor, ceil = Math.ceil, log2 = Math.log2, max = Math.max, min = Math.min;\nvar AbstractHistogram = /** @class */ (function (_super) {\n    __extends(AbstractHistogram, _super);\n    function AbstractHistogram(lowestDiscernibleValue, highestTrackableValue, numberOfSignificantValueDigits) {\n        var _this = _super.call(this) || this;\n        _this.maxValue = 0;\n        _this.minNonZeroValue = Number.MAX_SAFE_INTEGER;\n        // Verify argument validity\n        if (lowestDiscernibleValue < 1) {\n            throw new Error(\"lowestDiscernibleValue must be >= 1\");\n        }\n        if (highestTrackableValue < 2 * lowestDiscernibleValue) {\n            throw new Error(\"highestTrackableValue must be >= 2 * lowestDiscernibleValue ( 2 * \" + lowestDiscernibleValue + \" )\");\n        }\n        if (numberOfSignificantValueDigits < 0 ||\n            numberOfSignificantValueDigits > 5) {\n            throw new Error(\"numberOfSignificantValueDigits must be between 0 and 5\");\n        }\n        _this.identity = AbstractHistogramBase_1.AbstractHistogramBase.identityBuilder++;\n        _this.init(lowestDiscernibleValue, highestTrackableValue, numberOfSignificantValueDigits, 1.0, 0);\n        return _this;\n    }\n    AbstractHistogram.prototype.updatedMaxValue = function (value) {\n        var internalValue = value + this.unitMagnitudeMask;\n        this.maxValue = internalValue;\n    };\n    AbstractHistogram.prototype.updateMinNonZeroValue = function (value) {\n        if (value <= this.unitMagnitudeMask) {\n            return;\n        }\n        var internalValue = floor(value / this.lowestDiscernibleValueRounded) *\n            this.lowestDiscernibleValueRounded;\n        this.minNonZeroValue = internalValue;\n    };\n    AbstractHistogram.prototype.resetMinNonZeroValue = function (minNonZeroValue) {\n        var internalValue = floor(minNonZeroValue / this.lowestDiscernibleValueRounded) *\n            this.lowestDiscernibleValueRounded;\n        this.minNonZeroValue =\n            minNonZeroValue === Number.MAX_SAFE_INTEGER\n                ? minNonZeroValue\n                : internalValue;\n    };\n    AbstractHistogram.prototype.init = function (lowestDiscernibleValue, highestTrackableValue, numberOfSignificantValueDigits, integerToDoubleValueConversionRatio, normalizingIndexOffset) {\n        this.lowestDiscernibleValue = lowestDiscernibleValue;\n        this.highestTrackableValue = highestTrackableValue;\n        this.numberOfSignificantValueDigits = numberOfSignificantValueDigits;\n        this.integerToDoubleValueConversionRatio = integerToDoubleValueConversionRatio;\n        if (normalizingIndexOffset !== 0) {\n            this.setNormalizingIndexOffset(normalizingIndexOffset);\n        }\n        /*\n         * Given a 3 decimal point accuracy, the expectation is obviously for \"+/- 1 unit at 1000\". It also means that\n         * it's \"ok to be +/- 2 units at 2000\". The \"tricky\" thing is that it is NOT ok to be +/- 2 units at 1999. Only\n         * starting at 2000. So internally, we need to maintain single unit resolution to 2x 10^decimalPoints.\n         */\n        var largestValueWithSingleUnitResolution = 2 * floor(pow(10, numberOfSignificantValueDigits));\n        this.unitMagnitude = floor(log2(lowestDiscernibleValue));\n        this.lowestDiscernibleValueRounded = pow(2, this.unitMagnitude);\n        this.unitMagnitudeMask = this.lowestDiscernibleValueRounded - 1;\n        // We need to maintain power-of-two subBucketCount (for clean direct indexing) that is large enough to\n        // provide unit resolution to at least largestValueWithSingleUnitResolution. So figure out\n        // largestValueWithSingleUnitResolution's nearest power-of-two (rounded up), and use that:\n        var subBucketCountMagnitude = ceil(log2(largestValueWithSingleUnitResolution));\n        this.subBucketHalfCountMagnitude =\n            (subBucketCountMagnitude > 1 ? subBucketCountMagnitude : 1) - 1;\n        this.subBucketCount = pow(2, this.subBucketHalfCountMagnitude + 1);\n        this.subBucketHalfCount = this.subBucketCount / 2;\n        this.subBucketMask =\n            (floor(this.subBucketCount) - 1) * pow(2, this.unitMagnitude);\n        this.establishSize(highestTrackableValue);\n        this.leadingZeroCountBase =\n            53 - this.unitMagnitude - this.subBucketHalfCountMagnitude - 1;\n        this.percentileIterator = new PercentileIterator_1.default(this, 1);\n        this.recordedValuesIterator = new RecordedValuesIterator_1.default(this);\n    };\n    /**\n     * The buckets (each of which has subBucketCount sub-buckets, here assumed to be 2048 as an example) overlap:\n     *\n     * <pre>\n     * The 0'th bucket covers from 0...2047 in multiples of 1, using all 2048 sub-buckets\n     * The 1'th bucket covers from 2048..4097 in multiples of 2, using only the top 1024 sub-buckets\n     * The 2'th bucket covers from 4096..8191 in multiple of 4, using only the top 1024 sub-buckets\n     * ...\n     * </pre>\n     *\n     * Bucket 0 is \"special\" here. It is the only one that has 2048 entries. All the rest have 1024 entries (because\n     * their bottom half overlaps with and is already covered by the all of the previous buckets put together). In other\n     * words, the k'th bucket could represent 0 * 2^k to 2048 * 2^k in 2048 buckets with 2^k precision, but the midpoint\n     * of 1024 * 2^k = 2048 * 2^(k-1) = the k-1'th bucket's end, so we would use the previous bucket for those lower\n     * values as it has better precision.\n     */\n    AbstractHistogram.prototype.establishSize = function (newHighestTrackableValue) {\n        // establish counts array length:\n        this.countsArrayLength = this.determineArrayLengthNeeded(newHighestTrackableValue);\n        // establish exponent range needed to support the trackable value with no overflow:\n        this.bucketCount = this.getBucketsNeededToCoverValue(newHighestTrackableValue);\n        // establish the new highest trackable value:\n        this.highestTrackableValue = newHighestTrackableValue;\n    };\n    AbstractHistogram.prototype.determineArrayLengthNeeded = function (highestTrackableValue) {\n        if (highestTrackableValue < 2 * this.lowestDiscernibleValue) {\n            throw new Error(\"highestTrackableValue (\" +\n                highestTrackableValue +\n                \") cannot be < (2 * lowestDiscernibleValue)\");\n        }\n        //determine counts array length needed:\n        var countsArrayLength = this.getLengthForNumberOfBuckets(this.getBucketsNeededToCoverValue(highestTrackableValue));\n        return countsArrayLength;\n    };\n    /**\n     * If we have N such that subBucketCount * 2^N > max value, we need storage for N+1 buckets, each with enough\n     * slots to hold the top half of the subBucketCount (the lower half is covered by previous buckets), and the +1\n     * being used for the lower half of the 0'th bucket. Or, equivalently, we need 1 more bucket to capture the max\n     * value if we consider the sub-bucket length to be halved.\n     */\n    AbstractHistogram.prototype.getLengthForNumberOfBuckets = function (numberOfBuckets) {\n        var lengthNeeded = (numberOfBuckets + 1) * (this.subBucketCount / 2);\n        return lengthNeeded;\n    };\n    AbstractHistogram.prototype.getBucketsNeededToCoverValue = function (value) {\n        // the k'th bucket can express from 0 * 2^k to subBucketCount * 2^k in units of 2^k\n        var smallestUntrackableValue = this.subBucketCount * pow(2, this.unitMagnitude);\n        // always have at least 1 bucket\n        var bucketsNeeded = 1;\n        while (smallestUntrackableValue <= value) {\n            if (smallestUntrackableValue > Number.MAX_SAFE_INTEGER / 2) {\n                // TODO check array max size in JavaScript\n                // next shift will overflow, meaning that bucket could represent values up to ones greater than\n                // Number.MAX_SAFE_INTEGER, so it's the last bucket\n                return bucketsNeeded + 1;\n            }\n            smallestUntrackableValue = smallestUntrackableValue * 2;\n            bucketsNeeded++;\n        }\n        return bucketsNeeded;\n    };\n    /**\n     * Record a value in the histogram\n     *\n     * @param value The value to be recorded\n     * @throws may throw Error if value is exceeds highestTrackableValue\n     */\n    AbstractHistogram.prototype.recordValue = function (value) {\n        this.recordSingleValue(value);\n    };\n    AbstractHistogram.prototype.recordSingleValue = function (value) {\n        var countsIndex = this.countsArrayIndex(value);\n        if (countsIndex >= this.countsArrayLength) {\n            this.handleRecordException(1, value);\n        }\n        else {\n            this.incrementCountAtIndex(countsIndex);\n        }\n        this.updateMinAndMax(value);\n        this.incrementTotalCount();\n    };\n    AbstractHistogram.prototype.handleRecordException = function (count, value) {\n        if (!this.autoResize) {\n            throw new Error(\"Value \" + value + \" is outside of histogram covered range\");\n        }\n        this.resize(value);\n        var countsIndex = this.countsArrayIndex(value);\n        this.addToCountAtIndex(countsIndex, count);\n        this.highestTrackableValue = this.highestEquivalentValue(this.valueFromIndex(this.countsArrayLength - 1));\n    };\n    AbstractHistogram.prototype.countsArrayIndex = function (value) {\n        if (value < 0) {\n            throw new Error(\"Histogram recorded value cannot be negative.\");\n        }\n        var bucketIndex = this.getBucketIndex(value);\n        var subBucketIndex = this.getSubBucketIndex(value, bucketIndex);\n        return this.computeCountsArrayIndex(bucketIndex, subBucketIndex);\n    };\n    AbstractHistogram.prototype.computeCountsArrayIndex = function (bucketIndex, subBucketIndex) {\n        // TODO\n        //assert(subBucketIndex < subBucketCount);\n        //assert(bucketIndex == 0 || (subBucketIndex >= subBucketHalfCount));\n        // Calculate the index for the first entry that will be used in the bucket (halfway through subBucketCount).\n        // For bucketIndex 0, all subBucketCount entries may be used, but bucketBaseIndex is still set in the middle.\n        var bucketBaseIndex = (bucketIndex + 1) * pow(2, this.subBucketHalfCountMagnitude);\n        // Calculate the offset in the bucket. This subtraction will result in a positive value in all buckets except\n        // the 0th bucket (since a value in that bucket may be less than half the bucket's 0 to subBucketCount range).\n        // However, this works out since we give bucket 0 twice as much space.\n        var offsetInBucket = subBucketIndex - this.subBucketHalfCount;\n        // The following is the equivalent of ((subBucketIndex  - subBucketHalfCount) + bucketBaseIndex;\n        return bucketBaseIndex + offsetInBucket;\n    };\n    /**\n     * @return the lowest (and therefore highest precision) bucket index that can represent the value\n     */\n    AbstractHistogram.prototype.getBucketIndex = function (value) {\n        // Calculates the number of powers of two by which the value is greater than the biggest value that fits in\n        // bucket 0. This is the bucket index since each successive bucket can hold a value 2x greater.\n        // The mask maps small values to bucket 0.\n        // return this.leadingZeroCountBase - Long.numberOfLeadingZeros(value | subBucketMask);\n        return max(floor(log2(value)) -\n            this.subBucketHalfCountMagnitude -\n            this.unitMagnitude, 0);\n    };\n    AbstractHistogram.prototype.getSubBucketIndex = function (value, bucketIndex) {\n        // For bucketIndex 0, this is just value, so it may be anywhere in 0 to subBucketCount.\n        // For other bucketIndex, this will always end up in the top half of subBucketCount: assume that for some bucket\n        // k > 0, this calculation will yield a value in the bottom half of 0 to subBucketCount. Then, because of how\n        // buckets overlap, it would have also been in the top half of bucket k-1, and therefore would have\n        // returned k-1 in getBucketIndex(). Since we would then shift it one fewer bits here, it would be twice as big,\n        // and therefore in the top half of subBucketCount.\n        return floor(value / pow(2, bucketIndex + this.unitMagnitude));\n    };\n    AbstractHistogram.prototype.updateMinAndMax = function (value) {\n        if (value > this.maxValue) {\n            this.updatedMaxValue(value);\n        }\n        if (value < this.minNonZeroValue && value !== 0) {\n            this.updateMinNonZeroValue(value);\n        }\n    };\n    /**\n     * Get the value at a given percentile.\n     * When the given percentile is &gt; 0.0, the value returned is the value that the given\n     * percentage of the overall recorded value entries in the histogram are either smaller than\n     * or equivalent to. When the given percentile is 0.0, the value returned is the value that all value\n     * entries in the histogram are either larger than or equivalent to.\n     * <p>\n     * Note that two values are \"equivalent\" in this statement if\n     * {@link org.HdrHistogram.AbstractHistogram#valuesAreEquivalent} would return true.\n     *\n     * @param percentile  The percentile for which to return the associated value\n     * @return The value that the given percentage of the overall recorded value entries in the\n     * histogram are either smaller than or equivalent to. When the percentile is 0.0, returns the\n     * value that all value entries in the histogram are either larger than or equivalent to.\n     */\n    AbstractHistogram.prototype.getValueAtPercentile = function (percentile) {\n        var requestedPercentile = min(percentile, 100); // Truncate down to 100%\n        // round count up to nearest integer, to ensure that the largest value that the requested percentile\n        // of overall recorded values is actually included. However, this must be done with care:\n        //\n        // First, Compute fp value for count at the requested percentile. Note that fp result end up\n        // being 1 ulp larger than the correct integer count for this percentile:\n        var fpCountAtPercentile = (requestedPercentile / 100.0) * this.getTotalCount();\n        // Next, round up, but make sure to prevent <= 1 ulp inaccurancies in the above fp math from\n        // making us skip a count:\n        var countAtPercentile = max(ceil(fpCountAtPercentile - ulp_1.default(fpCountAtPercentile)), // round up\n        1 // Make sure we at least reach the first recorded entry\n        );\n        var totalToCurrentIndex = 0;\n        for (var i = 0; i < this.countsArrayLength; i++) {\n            totalToCurrentIndex += this.getCountAtIndex(i);\n            if (totalToCurrentIndex >= countAtPercentile) {\n                var valueAtIndex = this.valueFromIndex(i);\n                return percentile === 0.0\n                    ? this.lowestEquivalentValue(valueAtIndex)\n                    : this.highestEquivalentValue(valueAtIndex);\n            }\n        }\n        return 0;\n    };\n    AbstractHistogram.prototype.valueFromIndexes = function (bucketIndex, subBucketIndex) {\n        return subBucketIndex * pow(2, bucketIndex + this.unitMagnitude);\n    };\n    AbstractHistogram.prototype.valueFromIndex = function (index) {\n        var bucketIndex = floor(index / this.subBucketHalfCount) - 1;\n        var subBucketIndex = (index % this.subBucketHalfCount) + this.subBucketHalfCount;\n        if (bucketIndex < 0) {\n            subBucketIndex -= this.subBucketHalfCount;\n            bucketIndex = 0;\n        }\n        return this.valueFromIndexes(bucketIndex, subBucketIndex);\n    };\n    /**\n     * Get the lowest value that is equivalent to the given value within the histogram's resolution.\n     * Where \"equivalent\" means that value samples recorded for any two\n     * equivalent values are counted in a common total count.\n     *\n     * @param value The given value\n     * @return The lowest value that is equivalent to the given value within the histogram's resolution.\n     */\n    AbstractHistogram.prototype.lowestEquivalentValue = function (value) {\n        var bucketIndex = this.getBucketIndex(value);\n        var subBucketIndex = this.getSubBucketIndex(value, bucketIndex);\n        var thisValueBaseLevel = this.valueFromIndexes(bucketIndex, subBucketIndex);\n        return thisValueBaseLevel;\n    };\n    /**\n     * Get the highest value that is equivalent to the given value within the histogram's resolution.\n     * Where \"equivalent\" means that value samples recorded for any two\n     * equivalent values are counted in a common total count.\n     *\n     * @param value The given value\n     * @return The highest value that is equivalent to the given value within the histogram's resolution.\n     */\n    AbstractHistogram.prototype.highestEquivalentValue = function (value) {\n        return this.nextNonEquivalentValue(value) - 1;\n    };\n    /**\n     * Get the next value that is not equivalent to the given value within the histogram's resolution.\n     * Where \"equivalent\" means that value samples recorded for any two\n     * equivalent values are counted in a common total count.\n     *\n     * @param value The given value\n     * @return The next value that is not equivalent to the given value within the histogram's resolution.\n     */\n    AbstractHistogram.prototype.nextNonEquivalentValue = function (value) {\n        return (this.lowestEquivalentValue(value) + this.sizeOfEquivalentValueRange(value));\n    };\n    /**\n     * Get the size (in value units) of the range of values that are equivalent to the given value within the\n     * histogram's resolution. Where \"equivalent\" means that value samples recorded for any two\n     * equivalent values are counted in a common total count.\n     *\n     * @param value The given value\n     * @return The size of the range of values equivalent to the given value.\n     */\n    AbstractHistogram.prototype.sizeOfEquivalentValueRange = function (value) {\n        var bucketIndex = this.getBucketIndex(value);\n        var subBucketIndex = this.getSubBucketIndex(value, bucketIndex);\n        var distanceToNextValue = pow(2, this.unitMagnitude +\n            (subBucketIndex >= this.subBucketCount ? bucketIndex + 1 : bucketIndex));\n        return distanceToNextValue;\n    };\n    /**\n     * Get a value that lies in the middle (rounded up) of the range of values equivalent the given value.\n     * Where \"equivalent\" means that value samples recorded for any two\n     * equivalent values are counted in a common total count.\n     *\n     * @param value The given value\n     * @return The value lies in the middle (rounded up) of the range of values equivalent the given value.\n     */\n    AbstractHistogram.prototype.medianEquivalentValue = function (value) {\n        return (this.lowestEquivalentValue(value) +\n            floor(this.sizeOfEquivalentValueRange(value) / 2));\n    };\n    /**\n     * Get the computed mean value of all recorded values in the histogram\n     *\n     * @return the mean value (in value units) of the histogram data\n     */\n    AbstractHistogram.prototype.getMean = function () {\n        if (this.getTotalCount() === 0) {\n            return 0;\n        }\n        this.recordedValuesIterator.reset();\n        var totalValue = 0;\n        while (this.recordedValuesIterator.hasNext()) {\n            var iterationValue = this.recordedValuesIterator.next();\n            totalValue +=\n                this.medianEquivalentValue(iterationValue.valueIteratedTo) *\n                    iterationValue.countAtValueIteratedTo;\n        }\n        return (totalValue * 1.0) / this.getTotalCount();\n    };\n    /**\n     * Get the computed standard deviation of all recorded values in the histogram\n     *\n     * @return the standard deviation (in value units) of the histogram data\n     */\n    AbstractHistogram.prototype.getStdDeviation = function () {\n        if (this.getTotalCount() === 0) {\n            return 0;\n        }\n        var mean = this.getMean();\n        var geometric_deviation_total = 0.0;\n        this.recordedValuesIterator.reset();\n        while (this.recordedValuesIterator.hasNext()) {\n            var iterationValue = this.recordedValuesIterator.next();\n            var deviation = this.medianEquivalentValue(iterationValue.valueIteratedTo) - mean;\n            geometric_deviation_total +=\n                deviation * deviation * iterationValue.countAddedInThisIterationStep;\n        }\n        var std_deviation = Math.sqrt(geometric_deviation_total / this.getTotalCount());\n        return std_deviation;\n    };\n    /**\n     * Produce textual representation of the value distribution of histogram data by percentile. The distribution is\n     * output with exponentially increasing resolution, with each exponentially decreasing half-distance containing\n     * <i>dumpTicksPerHalf</i> percentile reporting tick points.\n     *\n     * @param printStream    Stream into which the distribution will be output\n     * <p>\n     * @param percentileTicksPerHalfDistance  The number of reporting points per exponentially decreasing half-distance\n     * <p>\n     * @param outputValueUnitScalingRatio    The scaling factor by which to divide histogram recorded values units in\n     *                                     output\n     * @param useCsvFormat  Output in CSV format if true. Otherwise use plain text form.\n     */\n    AbstractHistogram.prototype.outputPercentileDistribution = function (percentileTicksPerHalfDistance, outputValueUnitScalingRatio, useCsvFormat) {\n        if (percentileTicksPerHalfDistance === void 0) { percentileTicksPerHalfDistance = 5; }\n        if (outputValueUnitScalingRatio === void 0) { outputValueUnitScalingRatio = 1; }\n        if (useCsvFormat === void 0) { useCsvFormat = false; }\n        var result = \"\";\n        if (useCsvFormat) {\n            result += '\"Value\",\"Percentile\",\"TotalCount\",\"1/(1-Percentile)\"\\n';\n        }\n        else {\n            result += \"       Value     Percentile TotalCount 1/(1-Percentile)\\n\\n\";\n        }\n        var iterator = this.percentileIterator;\n        iterator.reset(percentileTicksPerHalfDistance);\n        var lineFormatter;\n        var lastLineFormatter;\n        if (useCsvFormat) {\n            var valueFormatter_1 = formatters_1.floatFormatter(0, this.numberOfSignificantValueDigits);\n            var percentileFormatter_1 = formatters_1.floatFormatter(0, 12);\n            var lastFormatter_1 = formatters_1.floatFormatter(0, 2);\n            lineFormatter = function (iterationValue) {\n                return valueFormatter_1(iterationValue.valueIteratedTo / outputValueUnitScalingRatio) +\n                    \",\" +\n                    percentileFormatter_1(iterationValue.percentileLevelIteratedTo / 100) +\n                    \",\" +\n                    iterationValue.totalCountToThisValue +\n                    \",\" +\n                    lastFormatter_1(1 / (1 - iterationValue.percentileLevelIteratedTo / 100)) +\n                    \"\\n\";\n            };\n            lastLineFormatter = function (iterationValue) {\n                return valueFormatter_1(iterationValue.valueIteratedTo / outputValueUnitScalingRatio) +\n                    \",\" +\n                    percentileFormatter_1(iterationValue.percentileLevelIteratedTo / 100) +\n                    \",\" +\n                    iterationValue.totalCountToThisValue +\n                    \",Infinity\\n\";\n            };\n        }\n        else {\n            var valueFormatter_2 = formatters_1.floatFormatter(12, this.numberOfSignificantValueDigits);\n            var percentileFormatter_2 = formatters_1.floatFormatter(2, 12);\n            var totalCountFormatter_1 = formatters_1.integerFormatter(10);\n            var lastFormatter_2 = formatters_1.floatFormatter(14, 2);\n            lineFormatter = function (iterationValue) {\n                return valueFormatter_2(iterationValue.valueIteratedTo / outputValueUnitScalingRatio) +\n                    \" \" +\n                    percentileFormatter_2(iterationValue.percentileLevelIteratedTo / 100) +\n                    \" \" +\n                    totalCountFormatter_1(iterationValue.totalCountToThisValue) +\n                    \" \" +\n                    lastFormatter_2(1 / (1 - iterationValue.percentileLevelIteratedTo / 100)) +\n                    \"\\n\";\n            };\n            lastLineFormatter = function (iterationValue) {\n                return valueFormatter_2(iterationValue.valueIteratedTo / outputValueUnitScalingRatio) +\n                    \" \" +\n                    percentileFormatter_2(iterationValue.percentileLevelIteratedTo / 100) +\n                    \" \" +\n                    totalCountFormatter_1(iterationValue.totalCountToThisValue) +\n                    \"\\n\";\n            };\n        }\n        while (iterator.hasNext()) {\n            var iterationValue = iterator.next();\n            if (iterationValue.percentileLevelIteratedTo < 100) {\n                result += lineFormatter(iterationValue);\n            }\n            else {\n                result += lastLineFormatter(iterationValue);\n            }\n        }\n        if (!useCsvFormat) {\n            // Calculate and output mean and std. deviation.\n            // Note: mean/std. deviation numbers are very often completely irrelevant when\n            // data is extremely non-normal in distribution (e.g. in cases of strong multi-modal\n            // response time distribution associated with GC pauses). However, reporting these numbers\n            // can be very useful for contrasting with the detailed percentile distribution\n            // reported by outputPercentileDistribution(). It is not at all surprising to find\n            // percentile distributions where results fall many tens or even hundreds of standard\n            // deviations away from the mean - such results simply indicate that the data sampled\n            // exhibits a very non-normal distribution, highlighting situations for which the std.\n            // deviation metric is a useless indicator.\n            //\n            var formatter = formatters_1.floatFormatter(12, this.numberOfSignificantValueDigits);\n            var mean = formatter(this.getMean() / outputValueUnitScalingRatio);\n            var std_deviation = formatter(this.getStdDeviation() / outputValueUnitScalingRatio);\n            var max_1 = formatter(this.maxValue / outputValueUnitScalingRatio);\n            var intFormatter = formatters_1.integerFormatter(12);\n            var totalCount = intFormatter(this.getTotalCount());\n            var bucketCount = intFormatter(this.bucketCount);\n            var subBucketCount = intFormatter(this.subBucketCount);\n            result += \"#[Mean    = \" + mean + \", StdDeviation   = \" + std_deviation + \"]\\n#[Max     = \" + max_1 + \", Total count    = \" + totalCount + \"]\\n#[Buckets = \" + bucketCount + \", SubBuckets     = \" + subBucketCount + \"]\\n\";\n        }\n        return result;\n    };\n    /**\n     * Provide a (conservatively high) estimate of the Histogram's total footprint in bytes\n     *\n     * @return a (conservatively high) estimate of the Histogram's total footprint in bytes\n     */\n    AbstractHistogram.prototype.getEstimatedFootprintInBytes = function () {\n        return this._getEstimatedFootprintInBytes();\n    };\n    AbstractHistogram.prototype.recordSingleValueWithExpectedInterval = function (value, expectedIntervalBetweenValueSamples) {\n        this.recordSingleValue(value);\n        if (expectedIntervalBetweenValueSamples <= 0) {\n            return;\n        }\n        for (var missingValue = value - expectedIntervalBetweenValueSamples; missingValue >= expectedIntervalBetweenValueSamples; missingValue -= expectedIntervalBetweenValueSamples) {\n            this.recordSingleValue(missingValue);\n        }\n    };\n    AbstractHistogram.prototype.recordCountAtValue = function (count, value) {\n        var countsIndex = this.countsArrayIndex(value);\n        if (countsIndex >= this.countsArrayLength) {\n            this.handleRecordException(count, value);\n        }\n        else {\n            this.addToCountAtIndex(countsIndex, count);\n        }\n        this.updateMinAndMax(value);\n        this.addToTotalCount(count);\n    };\n    /**\n     * Record a value in the histogram (adding to the value's current count)\n     *\n     * @param value The value to be recorded\n     * @param count The number of occurrences of this value to record\n     * @throws ArrayIndexOutOfBoundsException (may throw) if value is exceeds highestTrackableValue\n     */\n    AbstractHistogram.prototype.recordValueWithCount = function (value, count) {\n        this.recordCountAtValue(count, value);\n    };\n    /**\n     * Record a value in the histogram.\n     * <p>\n     * To compensate for the loss of sampled values when a recorded value is larger than the expected\n     * interval between value samples, Histogram will auto-generate an additional series of decreasingly-smaller\n     * (down to the expectedIntervalBetweenValueSamples) value records.\n     * <p>\n     * Note: This is a at-recording correction method, as opposed to the post-recording correction method provided\n     * by {@link #copyCorrectedForCoordinatedOmission(long)}.\n     * The two methods are mutually exclusive, and only one of the two should be be used on a given data set to correct\n     * for the same coordinated omission issue.\n     * <p>\n     * See notes in the description of the Histogram calls for an illustration of why this corrective behavior is\n     * important.\n     *\n     * @param value The value to record\n     * @param expectedIntervalBetweenValueSamples If expectedIntervalBetweenValueSamples is larger than 0, add\n     *                                           auto-generated value records as appropriate if value is larger\n     *                                           than expectedIntervalBetweenValueSamples\n     * @throws ArrayIndexOutOfBoundsException (may throw) if value is exceeds highestTrackableValue\n     */\n    AbstractHistogram.prototype.recordValueWithExpectedInterval = function (value, expectedIntervalBetweenValueSamples) {\n        this.recordSingleValueWithExpectedInterval(value, expectedIntervalBetweenValueSamples);\n    };\n    AbstractHistogram.prototype.recordValueWithCountAndExpectedInterval = function (value, count, expectedIntervalBetweenValueSamples) {\n        this.recordCountAtValue(count, value);\n        if (expectedIntervalBetweenValueSamples <= 0) {\n            return;\n        }\n        for (var missingValue = value - expectedIntervalBetweenValueSamples; missingValue >= expectedIntervalBetweenValueSamples; missingValue -= expectedIntervalBetweenValueSamples) {\n            this.recordCountAtValue(count, missingValue);\n        }\n    };\n    /**\n     * Add the contents of another histogram to this one, while correcting the incoming data for coordinated omission.\n     * <p>\n     * To compensate for the loss of sampled values when a recorded value is larger than the expected\n     * interval between value samples, the values added will include an auto-generated additional series of\n     * decreasingly-smaller (down to the expectedIntervalBetweenValueSamples) value records for each count found\n     * in the current histogram that is larger than the expectedIntervalBetweenValueSamples.\n     *\n     * Note: This is a post-recording correction method, as opposed to the at-recording correction method provided\n     * by {@link #recordValueWithExpectedInterval(long, long) recordValueWithExpectedInterval}. The two\n     * methods are mutually exclusive, and only one of the two should be be used on a given data set to correct\n     * for the same coordinated omission issue.\n     * by\n     * <p>\n     * See notes in the description of the Histogram calls for an illustration of why this corrective behavior is\n     * important.\n     *\n     * @param otherHistogram The other histogram. highestTrackableValue and largestValueWithSingleUnitResolution must match.\n     * @param expectedIntervalBetweenValueSamples If expectedIntervalBetweenValueSamples is larger than 0, add\n     *                                           auto-generated value records as appropriate if value is larger\n     *                                           than expectedIntervalBetweenValueSamples\n     * @throws ArrayIndexOutOfBoundsException (may throw) if values exceed highestTrackableValue\n     */\n    AbstractHistogram.prototype.addWhileCorrectingForCoordinatedOmission = function (otherHistogram, expectedIntervalBetweenValueSamples) {\n        var toHistogram = this;\n        var otherValues = new RecordedValuesIterator_1.default(otherHistogram);\n        while (otherValues.hasNext()) {\n            var v = otherValues.next();\n            toHistogram.recordValueWithCountAndExpectedInterval(v.valueIteratedTo, v.countAtValueIteratedTo, expectedIntervalBetweenValueSamples);\n        }\n    };\n    /**\n     * Add the contents of another histogram to this one.\n     * <p>\n     * As part of adding the contents, the start/end timestamp range of this histogram will be\n     * extended to include the start/end timestamp range of the other histogram.\n     *\n     * @param otherHistogram The other histogram.\n     * @throws (may throw) if values in fromHistogram's are\n     * higher than highestTrackableValue.\n     */\n    AbstractHistogram.prototype.add = function (otherHistogram) {\n        var highestRecordableValue = this.highestEquivalentValue(this.valueFromIndex(this.countsArrayLength - 1));\n        if (highestRecordableValue < otherHistogram.maxValue) {\n            if (!this.autoResize) {\n                throw new Error(\"The other histogram includes values that do not fit in this histogram's range.\");\n            }\n            this.resize(otherHistogram.maxValue);\n        }\n        if (this.bucketCount === otherHistogram.bucketCount &&\n            this.subBucketCount === otherHistogram.subBucketCount &&\n            this.unitMagnitude === otherHistogram.unitMagnitude) {\n            // Counts arrays are of the same length and meaning, so we can just iterate and add directly:\n            var observedOtherTotalCount = 0;\n            for (var i = 0; i < otherHistogram.countsArrayLength; i++) {\n                var otherCount = otherHistogram.getCountAtIndex(i);\n                if (otherCount > 0) {\n                    this.addToCountAtIndex(i, otherCount);\n                    observedOtherTotalCount += otherCount;\n                }\n            }\n            this.setTotalCount(this.getTotalCount() + observedOtherTotalCount);\n            this.updatedMaxValue(max(this.maxValue, otherHistogram.maxValue));\n            this.updateMinNonZeroValue(min(this.minNonZeroValue, otherHistogram.minNonZeroValue));\n        }\n        else {\n            // Arrays are not a direct match (or the other could change on the fly in some valid way),\n            // so we can't just stream through and add them. Instead, go through the array and add each\n            // non-zero value found at it's proper value:\n            // Do max value first, to avoid max value updates on each iteration:\n            var otherMaxIndex = otherHistogram.countsArrayIndex(otherHistogram.maxValue);\n            var otherCount = otherHistogram.getCountAtIndex(otherMaxIndex);\n            this.recordCountAtValue(otherCount, otherHistogram.maxValue);\n            // Record the remaining values, up to but not including the max value:\n            for (var i = 0; i < otherMaxIndex; i++) {\n                otherCount = otherHistogram.getCountAtIndex(i);\n                if (otherCount > 0) {\n                    this.recordCountAtValue(otherCount, otherHistogram.valueFromIndex(i));\n                }\n            }\n        }\n        this.startTimeStampMsec = min(this.startTimeStampMsec, otherHistogram.startTimeStampMsec);\n        this.endTimeStampMsec = max(this.endTimeStampMsec, otherHistogram.endTimeStampMsec);\n    };\n    /**\n     * Get the count of recorded values at a specific value (to within the histogram resolution at the value level).\n     *\n     * @param value The value for which to provide the recorded count\n     * @return The total count of values recorded in the histogram within the value range that is\n     * {@literal >=} lowestEquivalentValue(<i>value</i>) and {@literal <=} highestEquivalentValue(<i>value</i>)\n     */\n    AbstractHistogram.prototype.getCountAtValue = function (value) {\n        var index = min(max(0, this.countsArrayIndex(value)), this.countsArrayLength - 1);\n        return this.getCountAtIndex(index);\n    };\n    /**\n     * Subtract the contents of another histogram from this one.\n     * <p>\n     * The start/end timestamps of this histogram will remain unchanged.\n     *\n     * @param otherHistogram The other histogram.\n     * @throws ArrayIndexOutOfBoundsException (may throw) if values in otherHistogram's are higher than highestTrackableValue.\n     *\n     */\n    AbstractHistogram.prototype.subtract = function (otherHistogram) {\n        var highestRecordableValue = this.valueFromIndex(this.countsArrayLength - 1);\n        if (highestRecordableValue < otherHistogram.maxValue) {\n            if (!this.autoResize) {\n                throw new Error(\"The other histogram includes values that do not fit in this histogram's range.\");\n            }\n            this.resize(otherHistogram.maxValue);\n        }\n        if (this.bucketCount === otherHistogram.bucketCount &&\n            this.subBucketCount === otherHistogram.subBucketCount &&\n            this.unitMagnitude === otherHistogram.unitMagnitude) {\n            // optim\n            // Counts arrays are of the same length and meaning, so we can just iterate and add directly:\n            for (var i = 0; i < otherHistogram.countsArrayLength; i++) {\n                var otherCount = otherHistogram.getCountAtIndex(i);\n                if (otherCount > 0) {\n                    this.addToCountAtIndex(i, -otherCount);\n                }\n            }\n        }\n        else {\n            for (var i = 0; i < otherHistogram.countsArrayLength; i++) {\n                var otherCount = otherHistogram.getCountAtIndex(i);\n                if (otherCount > 0) {\n                    var otherValue = otherHistogram.valueFromIndex(i);\n                    if (this.getCountAtValue(otherValue) < otherCount) {\n                        throw new Error(\"otherHistogram count (\" +\n                            otherCount +\n                            \") at value \" +\n                            otherValue +\n                            \" is larger than this one's (\" +\n                            this.getCountAtValue(otherValue) +\n                            \")\");\n                    }\n                    this.recordCountAtValue(-otherCount, otherValue);\n                }\n            }\n        }\n        // With subtraction, the max and minNonZero values could have changed:\n        if (this.getCountAtValue(this.maxValue) <= 0 ||\n            this.getCountAtValue(this.minNonZeroValue) <= 0) {\n            this.establishInternalTackingValues();\n        }\n    };\n    AbstractHistogram.prototype.establishInternalTackingValues = function (lengthToCover) {\n        if (lengthToCover === void 0) { lengthToCover = this.countsArrayLength; }\n        this.maxValue = 0;\n        this.minNonZeroValue = Number.MAX_VALUE;\n        var maxIndex = -1;\n        var minNonZeroIndex = -1;\n        var observedTotalCount = 0;\n        for (var index = 0; index < lengthToCover; index++) {\n            var countAtIndex = this.getCountAtIndex(index);\n            if (countAtIndex > 0) {\n                observedTotalCount += countAtIndex;\n                maxIndex = index;\n                if (minNonZeroIndex == -1 && index != 0) {\n                    minNonZeroIndex = index;\n                }\n            }\n        }\n        if (maxIndex >= 0) {\n            this.updatedMaxValue(this.highestEquivalentValue(this.valueFromIndex(maxIndex)));\n        }\n        if (minNonZeroIndex >= 0) {\n            this.updateMinNonZeroValue(this.valueFromIndex(minNonZeroIndex));\n        }\n        this.setTotalCount(observedTotalCount);\n    };\n    AbstractHistogram.prototype.reset = function () {\n        this.clearCounts();\n        this.setTotalCount(0);\n        this.startTimeStampMsec = 0;\n        this.endTimeStampMsec = 0;\n        this.tag = AbstractHistogramBase_1.NO_TAG;\n        this.maxValue = 0;\n        this.minNonZeroValue = Number.MAX_SAFE_INTEGER;\n    };\n    return AbstractHistogram;\n}(AbstractHistogramBase_1.AbstractHistogramBase));\nexports.AbstractHistogram = AbstractHistogram;\nexports.default = AbstractHistogram;\n//# sourceMappingURL=AbstractHistogram.js.map","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * This is a TypeScript port of the original Java version, which was written by\n * Gil Tene as described in\n * https://github.com/HdrHistogram/HdrHistogram\n * and released to the public domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\nvar EncodableHistogram_1 = require(\"./EncodableHistogram\");\nexports.NO_TAG = \"NO TAG\";\nvar AbstractHistogramBase = /** @class */ (function (_super) {\n    __extends(AbstractHistogramBase, _super);\n    //intermediateUncompressedByteBuffer : ByteBuffer = null;\n    //intermediateUncompressedByteArray : number[] = null;\n    /* useless ?\n    getIntegerToDoubleValueConversionRatio(): number {\n        return this.integerToDoubleValueConversionRatio;\n    }\n  \n    setIntegerToDoubleValueConversionRatio(integerToDoubleValueConversionRatio: number) {\n        this.integerToDoubleValueConversionRatio = integerToDoubleValueConversionRatio;\n    }*/\n    function AbstractHistogramBase() {\n        var _this = _super.call(this) || this;\n        _this.autoResize = false;\n        _this.startTimeStampMsec = Number.MAX_SAFE_INTEGER;\n        _this.endTimeStampMsec = 0;\n        _this.tag = exports.NO_TAG;\n        _this.integerToDoubleValueConversionRatio = 1.0;\n        _this.identity = 0;\n        _this.highestTrackableValue = 0;\n        _this.lowestDiscernibleValue = 0;\n        _this.numberOfSignificantValueDigits = 0;\n        _this.bucketCount = 0;\n        _this.subBucketCount = 0;\n        _this.countsArrayLength = 0;\n        _this.wordSizeInBytes = 0;\n        return _this;\n    }\n    return AbstractHistogramBase;\n}(EncodableHistogram_1.EncodableHistogram));\nexports.AbstractHistogramBase = AbstractHistogramBase;\n//# sourceMappingURL=AbstractHistogramBase.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar HistogramIterationValue_1 = require(\"./HistogramIterationValue\");\n/**\n * Used for iterating through histogram values.\n */\nvar AbstractHistogramIterator /* implements Iterator<HistogramIterationValue> */ = /** @class */ (function () {\n    function AbstractHistogramIterator() {\n        this.currentIterationValue = new HistogramIterationValue_1.default();\n    }\n    AbstractHistogramIterator.prototype.resetIterator = function (histogram) {\n        this.histogram = histogram;\n        this.savedHistogramTotalRawCount = histogram.getTotalCount();\n        this.arrayTotalCount = histogram.getTotalCount();\n        this.currentIndex = 0;\n        this.currentValueAtIndex = 0;\n        this.nextValueAtIndex = Math.pow(2, histogram.unitMagnitude);\n        this.prevValueIteratedTo = 0;\n        this.totalCountToPrevIndex = 0;\n        this.totalCountToCurrentIndex = 0;\n        this.totalValueToCurrentIndex = 0;\n        this.countAtThisValue = 0;\n        this.freshSubBucket = true;\n        this.currentIterationValue.reset();\n    };\n    /**\n     * Returns true if the iteration has more elements. (In other words, returns true if next would return an\n     * element rather than throwing an exception.)\n     *\n     * @return true if the iterator has more elements.\n     */\n    AbstractHistogramIterator.prototype.hasNext = function () {\n        if (this.histogram.getTotalCount() !== this.savedHistogramTotalRawCount) {\n            throw \"Concurrent Modification Exception\";\n        }\n        return this.totalCountToCurrentIndex < this.arrayTotalCount;\n    };\n    /**\n     * Returns the next element in the iteration.\n     *\n     * @return the {@link HistogramIterationValue} associated with the next element in the iteration.\n     */\n    AbstractHistogramIterator.prototype.next = function () {\n        // Move through the sub buckets and buckets until we hit the next reporting level:\n        while (!this.exhaustedSubBuckets()) {\n            this.countAtThisValue = this.histogram.getCountAtIndex(this.currentIndex);\n            if (this.freshSubBucket) {\n                // Don't add unless we've incremented since last bucket...\n                this.totalCountToCurrentIndex += this.countAtThisValue;\n                this.totalValueToCurrentIndex +=\n                    this.countAtThisValue *\n                        this.histogram.highestEquivalentValue(this.currentValueAtIndex);\n                this.freshSubBucket = false;\n            }\n            if (this.reachedIterationLevel()) {\n                var valueIteratedTo = this.getValueIteratedTo();\n                Object.assign(this.currentIterationValue, {\n                    valueIteratedTo: valueIteratedTo,\n                    valueIteratedFrom: this.prevValueIteratedTo,\n                    countAtValueIteratedTo: this.countAtThisValue,\n                    countAddedInThisIterationStep: this.totalCountToCurrentIndex - this.totalCountToPrevIndex,\n                    totalCountToThisValue: this.totalCountToCurrentIndex,\n                    totalValueToThisValue: this.totalValueToCurrentIndex,\n                    percentile: 100 * this.totalCountToCurrentIndex / this.arrayTotalCount,\n                    percentileLevelIteratedTo: this.getPercentileIteratedTo()\n                });\n                this.prevValueIteratedTo = valueIteratedTo;\n                this.totalCountToPrevIndex = this.totalCountToCurrentIndex;\n                this.incrementIterationLevel();\n                if (this.histogram.getTotalCount() !== this.savedHistogramTotalRawCount) {\n                    throw new Error(\"Concurrent Modification Exception\");\n                }\n                return this.currentIterationValue;\n            }\n            this.incrementSubBucket();\n        }\n        throw new Error(\"Index Out Of Bounds Exception\");\n    };\n    AbstractHistogramIterator.prototype.getPercentileIteratedTo = function () {\n        return 100 * this.totalCountToCurrentIndex / this.arrayTotalCount;\n    };\n    AbstractHistogramIterator.prototype.getPercentileIteratedFrom = function () {\n        return 100 * this.totalCountToPrevIndex / this.arrayTotalCount;\n    };\n    AbstractHistogramIterator.prototype.getValueIteratedTo = function () {\n        return this.histogram.highestEquivalentValue(this.currentValueAtIndex);\n    };\n    AbstractHistogramIterator.prototype.exhaustedSubBuckets = function () {\n        return this.currentIndex >= this.histogram.countsArrayLength;\n    };\n    AbstractHistogramIterator.prototype.incrementSubBucket = function () {\n        this.freshSubBucket = true;\n        this.currentIndex++;\n        this.currentValueAtIndex = this.histogram.valueFromIndex(this.currentIndex);\n        this.nextValueAtIndex = this.histogram.valueFromIndex(this.currentIndex + 1);\n    };\n    return AbstractHistogramIterator;\n}());\nexports.default = AbstractHistogramIterator;\n//# sourceMappingURL=AbstractHistogramIterator.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar pow = Math.pow, floor = Math.floor;\nvar TWO_POW_32 = pow(2, 32);\n/**\n * Mimic Java's ByteBufffer with big endian order\n */\nvar ByteBuffer = /** @class */ (function () {\n    function ByteBuffer(data) {\n        this.position = 0;\n        this.data = data;\n        this.int32ArrayForConvert = new Uint32Array(1);\n        this.int8ArrayForConvert = new Uint8Array(this.int32ArrayForConvert.buffer);\n    }\n    ByteBuffer.allocate = function (size) {\n        if (size === void 0) { size = 16; }\n        return new ByteBuffer(new Uint8Array(size));\n    };\n    ByteBuffer.prototype.put = function (value) {\n        if (this.position === this.data.length) {\n            var oldArray = this.data;\n            this.data = new Uint8Array(this.data.length * 2);\n            this.data.set(oldArray);\n        }\n        this.data[this.position] = value;\n        this.position++;\n    };\n    ByteBuffer.prototype.putInt32 = function (value) {\n        if (this.data.length - this.position < 4) {\n            var oldArray = this.data;\n            this.data = new Uint8Array(this.data.length * 2 + 4);\n            this.data.set(oldArray);\n        }\n        this.int32ArrayForConvert[0] = value;\n        this.data.set(this.int8ArrayForConvert.reverse(), this.position);\n        this.position += 4;\n    };\n    ByteBuffer.prototype.putInt64 = function (value) {\n        this.putInt32(floor(value / TWO_POW_32));\n        this.putInt32(value);\n    };\n    ByteBuffer.prototype.putArray = function (array) {\n        if (this.data.length - this.position < array.byteLength) {\n            var oldArray = this.data;\n            this.data = new Uint8Array(this.position + array.byteLength);\n            this.data.set(oldArray);\n        }\n        this.data.set(array, this.position);\n        this.position += array.byteLength;\n    };\n    ByteBuffer.prototype.get = function () {\n        var value = this.data[this.position];\n        this.position++;\n        return value;\n    };\n    ByteBuffer.prototype.getInt32 = function () {\n        this.int8ArrayForConvert.set(this.data.slice(this.position, this.position + 4).reverse());\n        var value = this.int32ArrayForConvert[0];\n        this.position += 4;\n        return value;\n    };\n    ByteBuffer.prototype.getInt64 = function () {\n        var high = this.getInt32();\n        var low = this.getInt32();\n        return high * TWO_POW_32 + low;\n    };\n    ByteBuffer.prototype.resetPosition = function () {\n        this.position = 0;\n    };\n    return ByteBuffer;\n}());\nexports.default = ByteBuffer;\n//# sourceMappingURL=ByteBuffer.js.map","\"use strict\";\n/*\n * This is a TypeScript port of the original Java version, which was written by\n * Gil Tene as described in\n * https://github.com/HdrHistogram/HdrHistogram\n * and released to the public domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar EncodableHistogram = /** @class */ (function () {\n    function EncodableHistogram() {\n    }\n    return EncodableHistogram;\n}());\nexports.EncodableHistogram = EncodableHistogram;\n//# sourceMappingURL=EncodableHistogram.js.map","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * This is a TypeScript port of the original Java version, which was written by\n * Gil Tene as described in\n * https://github.com/HdrHistogram/HdrHistogram\n * and released to the public domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\nvar AbstractHistogram_1 = require(\"./AbstractHistogram\");\nvar Float64Histogram = /** @class */ (function (_super) {\n    __extends(Float64Histogram, _super);\n    function Float64Histogram(lowestDiscernibleValue, highestTrackableValue, numberOfSignificantValueDigits) {\n        var _this = _super.call(this, lowestDiscernibleValue, highestTrackableValue, numberOfSignificantValueDigits) || this;\n        _this.totalCount = 0;\n        _this.counts = new Float64Array(_this.countsArrayLength);\n        return _this;\n    }\n    Float64Histogram.prototype.clearCounts = function () {\n        this.counts.fill(0);\n    };\n    Float64Histogram.prototype.incrementCountAtIndex = function (index) {\n        var currentCount = this.counts[index];\n        var newCount = currentCount + 1;\n        if (newCount < 0) {\n            throw newCount + \" would overflow short integer count\";\n        }\n        this.counts[index] = newCount;\n    };\n    Float64Histogram.prototype.addToCountAtIndex = function (index, value) {\n        var currentCount = this.counts[index];\n        var newCount = currentCount + value;\n        if (newCount < Number.MIN_SAFE_INTEGER ||\n            newCount > Number.MAX_SAFE_INTEGER) {\n            throw newCount + \" would overflow integer count\";\n        }\n        this.counts[index] = newCount;\n    };\n    Float64Histogram.prototype.setCountAtIndex = function (index, value) {\n        if (value < Number.MIN_SAFE_INTEGER || value > Number.MAX_SAFE_INTEGER) {\n            throw value + \" would overflow integer count\";\n        }\n        this.counts[index] = value;\n    };\n    Float64Histogram.prototype.resize = function (newHighestTrackableValue) {\n        this.establishSize(newHighestTrackableValue);\n        var newCounts = new Float64Array(this.countsArrayLength);\n        newCounts.set(this.counts);\n        this.counts = newCounts;\n    };\n    Float64Histogram.prototype.setNormalizingIndexOffset = function (normalizingIndexOffset) { };\n    Float64Histogram.prototype.incrementTotalCount = function () {\n        this.totalCount++;\n    };\n    Float64Histogram.prototype.addToTotalCount = function (value) {\n        this.totalCount += value;\n    };\n    Float64Histogram.prototype.setTotalCount = function (value) {\n        this.totalCount = value;\n    };\n    Float64Histogram.prototype.getTotalCount = function () {\n        return this.totalCount;\n    };\n    Float64Histogram.prototype.getCountAtIndex = function (index) {\n        return this.counts[index];\n    };\n    Float64Histogram.prototype._getEstimatedFootprintInBytes = function () {\n        return 512 + 8 * this.counts.length;\n    };\n    Float64Histogram.prototype.copyCorrectedForCoordinatedOmission = function (expectedIntervalBetweenValueSamples) {\n        var copy = new Float64Histogram(this.lowestDiscernibleValue, this.highestTrackableValue, this.numberOfSignificantValueDigits);\n        copy.addWhileCorrectingForCoordinatedOmission(this, expectedIntervalBetweenValueSamples);\n        return copy;\n    };\n    return Float64Histogram;\n}(AbstractHistogram_1.default));\nexports.default = Float64Histogram;\n//# sourceMappingURL=Float64Histogram.js.map","\"use strict\";\n/*\n * This is a TypeScript port of the original Java version, which was written by\n * Gil Tene as described in\n * https://github.com/HdrHistogram/HdrHistogram\n * and released to the public domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Represents a value point iterated through in a Histogram, with associated stats.\n * <ul>\n * <li><b><code>valueIteratedTo</code></b> :<br> The actual value level that was iterated to by the iterator</li>\n * <li><b><code>prevValueIteratedTo</code></b> :<br> The actual value level that was iterated from by the iterator</li>\n * <li><b><code>countAtValueIteratedTo</code></b> :<br> The count of recorded values in the histogram that\n * exactly match this [lowestEquivalentValue(valueIteratedTo)...highestEquivalentValue(valueIteratedTo)] value\n * range.</li>\n * <li><b><code>countAddedInThisIterationStep</code></b> :<br> The count of recorded values in the histogram that\n * were added to the totalCountToThisValue (below) as a result on this iteration step. Since multiple iteration\n * steps may occur with overlapping equivalent value ranges, the count may be lower than the count found at\n * the value (e.g. multiple linear steps or percentile levels can occur within a single equivalent value range)</li>\n * <li><b><code>totalCountToThisValue</code></b> :<br> The total count of all recorded values in the histogram at\n * values equal or smaller than valueIteratedTo.</li>\n * <li><b><code>totalValueToThisValue</code></b> :<br> The sum of all recorded values in the histogram at values\n * equal or smaller than valueIteratedTo.</li>\n * <li><b><code>percentile</code></b> :<br> The percentile of recorded values in the histogram at values equal\n * or smaller than valueIteratedTo.</li>\n * <li><b><code>percentileLevelIteratedTo</code></b> :<br> The percentile level that the iterator returning this\n * HistogramIterationValue had iterated to. Generally, percentileLevelIteratedTo will be equal to or smaller than\n * percentile, but the same value point can contain multiple iteration levels for some iterators. E.g. a\n * PercentileIterator can stop multiple times in the exact same value point (if the count at that value covers a\n * range of multiple percentiles in the requested percentile iteration points).</li>\n * </ul>\n */\nvar HistogramIterationValue = /** @class */ (function () {\n    function HistogramIterationValue() {\n        this.reset();\n    }\n    HistogramIterationValue.prototype.reset = function () {\n        this.valueIteratedTo = 0;\n        this.valueIteratedFrom = 0;\n        this.countAtValueIteratedTo = 0;\n        this.countAddedInThisIterationStep = 0;\n        this.totalCountToThisValue = 0;\n        this.totalValueToThisValue = 0;\n        this.percentile = 0.0;\n        this.percentileLevelIteratedTo = 0.0;\n    };\n    return HistogramIterationValue;\n}());\nexports.default = HistogramIterationValue;\n//# sourceMappingURL=HistogramIterationValue.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * This is a TypeScript port of the original Java version, which was written by\n * Gil Tene as described in\n * https://github.com/HdrHistogram/HdrHistogram\n * and released to the public domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\nvar AbstractHistogramBase_1 = require(\"./AbstractHistogramBase\");\nvar Int32Histogram_1 = require(\"./Int32Histogram\");\nvar encoding_1 = require(\"./encoding\");\nvar TAG_PREFIX = \"Tag=\";\nvar TAG_PREFIX_LENGTH = \"Tag=\".length;\n/**\n * A histogram log reader.\n * <p>\n * Histogram logs are used to capture full fidelity, per-time-interval\n * histograms of a recorded value.\n * <p>\n * For example, a histogram log can be used to capture high fidelity\n * reaction-time logs for some measured system or subsystem component.\n * Such a log would capture a full reaction time histogram for each\n * logged interval, and could be used to later reconstruct a full\n * HdrHistogram of the measured reaction time behavior for any arbitrary\n * time range within the log, by adding [only] the relevant interval\n * histograms.\n * <h3>Histogram log format:</h3>\n * A histogram log file consists of text lines. Lines beginning with\n * the \"#\" character are optional and treated as comments. Lines\n * containing the legend (starting with \"Timestamp\") are also optional\n * and ignored in parsing the histogram log. All other lines must\n * be valid interval description lines. Text fields are delimited by\n * commas, spaces.\n * <p>\n * A valid interval description line contains an optional Tag=tagString\n * text field, followed by an interval description.\n * <p>\n * A valid interval description must contain exactly four text fields:\n * <ul>\n * <li>StartTimestamp: The first field must contain a number parse-able as a Double value,\n * representing the start timestamp of the interval in seconds.</li>\n * <li>intervalLength: The second field must contain a number parse-able as a Double value,\n * representing the length of the interval in seconds.</li>\n * <li>Interval_Max: The third field must contain a number parse-able as a Double value,\n * which generally represents the maximum value of the interval histogram.</li>\n * <li>Interval_Compressed_Histogram: The fourth field must contain a text field\n * parse-able as a Base64 text representation of a compressed HdrHistogram.</li>\n * </ul>\n * The log file may contain an optional indication of a starting time. Starting time\n * is indicated using a special comments starting with \"#[StartTime: \" and followed\n * by a number parse-able as a double, representing the start time (in seconds)\n * that may be added to timestamps in the file to determine an absolute\n * timestamp (e.g. since the epoch) for each interval.\n */\nvar HistogramLogReader = /** @class */ (function () {\n    function HistogramLogReader(logContent, options) {\n        var _a;\n        this.lines = splitLines(logContent);\n        this.currentLineIndex = 0;\n        this.histogramConstr = ((_a = options) === null || _a === void 0 ? void 0 : _a.histogramConstr) || Int32Histogram_1.default;\n    }\n    /**\n     * Read the next interval histogram from the log. Returns a Histogram object if\n     * an interval line was found, or null if not.\n     * <p>Upon encountering any unexpected format errors in reading the next interval\n     * from the file, this method will return a null.\n     * @return a DecodedInterval, or a null if no appropriate interval found\n     */\n    HistogramLogReader.prototype.nextIntervalHistogram = function (rangeStartTimeSec, rangeEndTimeSec) {\n        if (rangeStartTimeSec === void 0) { rangeStartTimeSec = 0; }\n        if (rangeEndTimeSec === void 0) { rangeEndTimeSec = Number.MAX_VALUE; }\n        while (this.currentLineIndex < this.lines.length) {\n            var currentLine = this.lines[this.currentLineIndex];\n            this.currentLineIndex++;\n            if (currentLine.startsWith(\"#[StartTime:\")) {\n                this.parseStartTimeFromLine(currentLine);\n            }\n            else if (currentLine.startsWith(\"#[BaseTime:\")) {\n                this.parseBaseTimeFromLine(currentLine);\n            }\n            else if (currentLine.startsWith(\"#\") ||\n                currentLine.startsWith('\"StartTimestamp\"')) {\n                // skip legend & meta data for now\n            }\n            else if (currentLine.includes(\",\")) {\n                var tokens = currentLine.split(\",\");\n                var firstToken = tokens[0];\n                var tag = void 0;\n                if (firstToken.startsWith(TAG_PREFIX)) {\n                    tag = firstToken.substring(TAG_PREFIX_LENGTH);\n                    tokens.shift();\n                }\n                else {\n                    tag = AbstractHistogramBase_1.NO_TAG;\n                }\n                var rawLogTimeStampInSec = tokens[0], rawIntervalLengthSec = tokens[1], base64Histogram = tokens[3];\n                var logTimeStampInSec = Number.parseFloat(rawLogTimeStampInSec);\n                if (!this.baseTimeSec) {\n                    // No explicit base time noted. Deduce from 1st observed time (compared to start time):\n                    if (logTimeStampInSec < this.startTimeSec - 365 * 24 * 3600.0) {\n                        // Criteria Note: if log timestamp is more than a year in the past (compared to\n                        // StartTime), we assume that timestamps in the log are not absolute\n                        this.baseTimeSec = this.startTimeSec;\n                    }\n                    else {\n                        // Timestamps are absolute\n                        this.baseTimeSec = 0.0;\n                    }\n                }\n                if (rangeEndTimeSec < logTimeStampInSec) {\n                    return null;\n                }\n                if (logTimeStampInSec < rangeStartTimeSec) {\n                    continue;\n                }\n                var histogram = encoding_1.decodeFromCompressedBase64(base64Histogram, this.histogramConstr);\n                histogram.startTimeStampMsec =\n                    (this.baseTimeSec + logTimeStampInSec) * 1000;\n                var intervalLengthSec = Number.parseFloat(rawIntervalLengthSec);\n                histogram.endTimeStampMsec =\n                    (this.baseTimeSec + logTimeStampInSec + intervalLengthSec) * 1000;\n                histogram.tag = tag;\n                return histogram;\n            }\n        }\n        return null;\n    };\n    HistogramLogReader.prototype.parseStartTimeFromLine = function (line) {\n        this.startTimeSec = Number.parseFloat(line.split(\" \")[1]);\n    };\n    HistogramLogReader.prototype.parseBaseTimeFromLine = function (line) {\n        this.baseTimeSec = Number.parseFloat(line.split(\" \")[1]);\n    };\n    return HistogramLogReader;\n}());\nvar splitLines = function (logContent) { return logContent.split(/\\r\\n|\\r|\\n/g); };\nvar shouldIncludeNoTag = function (lines) {\n    return lines.find(function (line) {\n        return !line.startsWith(\"#\") &&\n            !line.startsWith('\"') &&\n            !line.startsWith(TAG_PREFIX) &&\n            line.includes(\",\");\n    });\n};\nexports.listTags = function (content) {\n    var lines = splitLines(content);\n    var tags = lines\n        .filter(function (line) { return line.includes(\",\") && line.startsWith(TAG_PREFIX); })\n        .map(function (line) { return line.substring(TAG_PREFIX_LENGTH, line.indexOf(\",\")); });\n    var tagsWithoutDuplicates = new Set(tags);\n    var result = Array.from(tagsWithoutDuplicates);\n    if (shouldIncludeNoTag(lines)) {\n        result.unshift(\"NO TAG\");\n    }\n    return result;\n};\nexports.default = HistogramLogReader;\n//# sourceMappingURL=HistogramLogReader.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar AbstractHistogramBase_1 = require(\"./AbstractHistogramBase\");\nvar encoding_1 = require(\"./encoding\");\nvar formatters_1 = require(\"./formatters\");\nvar HISTOGRAM_LOG_FORMAT_VERSION = \"1.3\";\nvar timeFormatter = formatters_1.floatFormatter(5, 3);\nvar HistogramLogWriter = /** @class */ (function () {\n    function HistogramLogWriter(log) {\n        this.log = log;\n        /**\n         * Base time to subtract from supplied histogram start/end timestamps when\n         * logging based on histogram timestamps.\n         * Base time is expected to be in msec since the epoch, as histogram start/end times\n         * are typically stamped with absolute times in msec since the epoch.\n         */\n        this.baseTime = 0;\n    }\n    /**\n     * Output an interval histogram, with the given timestamp information and the [optional] tag\n     * associated with the histogram, using a configurable maxValueUnitRatio. (note that the\n     * specified timestamp information will be used, and the timestamp information in the actual\n     * histogram will be ignored).\n     * The max value reported with the interval line will be scaled by the given maxValueUnitRatio.\n     * @param startTimeStampSec The start timestamp to log with the interval histogram, in seconds.\n     * @param endTimeStampSec The end timestamp to log with the interval histogram, in seconds.\n     * @param histogram The interval histogram to log.\n     * @param maxValueUnitRatio The ratio by which to divide the histogram's max value when reporting on it.\n     */\n    HistogramLogWriter.prototype.outputIntervalHistogram = function (histogram, startTimeStampSec, endTimeStampSec, maxValueUnitRatio) {\n        if (startTimeStampSec === void 0) { startTimeStampSec = (histogram.startTimeStampMsec - this.baseTime) / 1000; }\n        if (endTimeStampSec === void 0) { endTimeStampSec = (histogram.endTimeStampMsec - this.baseTime) / 1000; }\n        if (maxValueUnitRatio === void 0) { maxValueUnitRatio = 1000; }\n        var base64 = encoding_1.encodeIntoBase64String(histogram);\n        var start = timeFormatter(startTimeStampSec);\n        var duration = timeFormatter(endTimeStampSec - startTimeStampSec);\n        var max = timeFormatter(histogram.maxValue / maxValueUnitRatio);\n        var lineContent = start + \",\" + duration + \",\" + max + \",\" + base64 + \"\\n\";\n        if (histogram.tag && histogram.tag !== AbstractHistogramBase_1.NO_TAG) {\n            this.log(\"Tag=\" + histogram.tag + \",\" + lineContent);\n        }\n        else {\n            this.log(lineContent);\n        }\n    };\n    /**\n     * Log a comment to the log.\n     * Comments will be preceded with with the '#' character.\n     * @param comment the comment string.\n     */\n    HistogramLogWriter.prototype.outputComment = function (comment) {\n        this.log(\"#\" + comment + \"\\n\");\n    };\n    /**\n     * Log a start time in the log.\n     * @param startTimeMsec time (in milliseconds) since the absolute start time (the epoch)\n     */\n    HistogramLogWriter.prototype.outputStartTime = function (startTimeMsec) {\n        this.outputComment(\"[StartTime: \" + formatters_1.floatFormatter(5, 3)(startTimeMsec / 1000) + \" (seconds since epoch), \" + new Date(startTimeMsec) + \"]\\n\");\n    };\n    /**\n     * Output a legend line to the log.\n     */\n    HistogramLogWriter.prototype.outputLegend = function () {\n        this.log('\"StartTimestamp\",\"Interval_Length\",\"Interval_Max\",\"Interval_Compressed_Histogram\"\\n');\n    };\n    /**\n     * Output a log format version to the log.\n     */\n    HistogramLogWriter.prototype.outputLogFormatVersion = function () {\n        this.outputComment(\"[Histogram log format version \" + HISTOGRAM_LOG_FORMAT_VERSION + \"]\");\n    };\n    return HistogramLogWriter;\n}());\nexports.default = HistogramLogWriter;\n//# sourceMappingURL=HistogramLogWriter.js.map","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * This is a TypeScript port of the original Java version, which was written by\n * Gil Tene as described in\n * https://github.com/HdrHistogram/HdrHistogram\n * and released to the public domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\nvar AbstractHistogram_1 = require(\"./AbstractHistogram\");\nvar Int16Histogram = /** @class */ (function (_super) {\n    __extends(Int16Histogram, _super);\n    function Int16Histogram(lowestDiscernibleValue, highestTrackableValue, numberOfSignificantValueDigits) {\n        var _this = _super.call(this, lowestDiscernibleValue, highestTrackableValue, numberOfSignificantValueDigits) || this;\n        _this.totalCount = 0;\n        _this.counts = new Uint16Array(_this.countsArrayLength);\n        return _this;\n    }\n    Int16Histogram.prototype.clearCounts = function () {\n        this.counts.fill(0);\n    };\n    Int16Histogram.prototype.incrementCountAtIndex = function (index) {\n        var currentCount = this.counts[index];\n        var newCount = currentCount + 1;\n        if (newCount < 0) {\n            throw newCount + \" would overflow short integer count\";\n        }\n        this.counts[index] = newCount;\n    };\n    Int16Histogram.prototype.addToCountAtIndex = function (index, value) {\n        var currentCount = this.counts[index];\n        var newCount = currentCount + value;\n        if (newCount < Number.MIN_SAFE_INTEGER ||\n            newCount > Number.MAX_SAFE_INTEGER) {\n            throw newCount + \" would overflow integer count\";\n        }\n        this.counts[index] = newCount;\n    };\n    Int16Histogram.prototype.setCountAtIndex = function (index, value) {\n        if (value < Number.MIN_SAFE_INTEGER || value > Number.MAX_SAFE_INTEGER) {\n            throw value + \" would overflow integer count\";\n        }\n        this.counts[index] = value;\n    };\n    Int16Histogram.prototype.resize = function (newHighestTrackableValue) {\n        this.establishSize(newHighestTrackableValue);\n        var newCounts = new Uint16Array(this.countsArrayLength);\n        newCounts.set(this.counts);\n        this.counts = newCounts;\n    };\n    Int16Histogram.prototype.setNormalizingIndexOffset = function (normalizingIndexOffset) { };\n    Int16Histogram.prototype.incrementTotalCount = function () {\n        this.totalCount++;\n    };\n    Int16Histogram.prototype.addToTotalCount = function (value) {\n        this.totalCount += value;\n    };\n    Int16Histogram.prototype.setTotalCount = function (value) {\n        this.totalCount = value;\n    };\n    Int16Histogram.prototype.getTotalCount = function () {\n        return this.totalCount;\n    };\n    Int16Histogram.prototype.getCountAtIndex = function (index) {\n        return this.counts[index];\n    };\n    Int16Histogram.prototype._getEstimatedFootprintInBytes = function () {\n        return 512 + 2 * this.counts.length;\n    };\n    Int16Histogram.prototype.copyCorrectedForCoordinatedOmission = function (expectedIntervalBetweenValueSamples) {\n        var copy = new Int16Histogram(this.lowestDiscernibleValue, this.highestTrackableValue, this.numberOfSignificantValueDigits);\n        copy.addWhileCorrectingForCoordinatedOmission(this, expectedIntervalBetweenValueSamples);\n        return copy;\n    };\n    return Int16Histogram;\n}(AbstractHistogram_1.default));\nexports.default = Int16Histogram;\n//# sourceMappingURL=Int16Histogram.js.map","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * This is a TypeScript port of the original Java version, which was written by\n * Gil Tene as described in\n * https://github.com/HdrHistogram/HdrHistogram\n * and released to the public domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\nvar AbstractHistogram_1 = require(\"./AbstractHistogram\");\nvar Int32Histogram = /** @class */ (function (_super) {\n    __extends(Int32Histogram, _super);\n    function Int32Histogram(lowestDiscernibleValue, highestTrackableValue, numberOfSignificantValueDigits) {\n        var _this = _super.call(this, lowestDiscernibleValue, highestTrackableValue, numberOfSignificantValueDigits) || this;\n        _this.totalCount = 0;\n        _this.counts = new Uint32Array(_this.countsArrayLength);\n        return _this;\n    }\n    Int32Histogram.prototype.clearCounts = function () {\n        this.counts.fill(0);\n    };\n    Int32Histogram.prototype.incrementCountAtIndex = function (index) {\n        var currentCount = this.counts[index];\n        var newCount = currentCount + 1;\n        if (newCount < 0) {\n            throw newCount + \" would overflow short integer count\";\n        }\n        this.counts[index] = newCount;\n    };\n    Int32Histogram.prototype.addToCountAtIndex = function (index, value) {\n        var currentCount = this.counts[index];\n        var newCount = currentCount + value;\n        if (newCount < Number.MIN_SAFE_INTEGER ||\n            newCount > Number.MAX_SAFE_INTEGER) {\n            throw newCount + \" would overflow integer count\";\n        }\n        this.counts[index] = newCount;\n    };\n    Int32Histogram.prototype.setCountAtIndex = function (index, value) {\n        if (value < Number.MIN_SAFE_INTEGER || value > Number.MAX_SAFE_INTEGER) {\n            throw value + \" would overflow integer count\";\n        }\n        this.counts[index] = value;\n    };\n    Int32Histogram.prototype.resize = function (newHighestTrackableValue) {\n        this.establishSize(newHighestTrackableValue);\n        var newCounts = new Uint32Array(this.countsArrayLength);\n        newCounts.set(this.counts);\n        this.counts = newCounts;\n    };\n    Int32Histogram.prototype.setNormalizingIndexOffset = function (normalizingIndexOffset) { };\n    Int32Histogram.prototype.incrementTotalCount = function () {\n        this.totalCount++;\n    };\n    Int32Histogram.prototype.addToTotalCount = function (value) {\n        this.totalCount += value;\n    };\n    Int32Histogram.prototype.setTotalCount = function (value) {\n        this.totalCount = value;\n    };\n    Int32Histogram.prototype.getTotalCount = function () {\n        return this.totalCount;\n    };\n    Int32Histogram.prototype.getCountAtIndex = function (index) {\n        return this.counts[index];\n    };\n    Int32Histogram.prototype._getEstimatedFootprintInBytes = function () {\n        return 512 + 4 * this.counts.length;\n    };\n    Int32Histogram.prototype.copyCorrectedForCoordinatedOmission = function (expectedIntervalBetweenValueSamples) {\n        var copy = new Int32Histogram(this.lowestDiscernibleValue, this.highestTrackableValue, this.numberOfSignificantValueDigits);\n        copy.addWhileCorrectingForCoordinatedOmission(this, expectedIntervalBetweenValueSamples);\n        return copy;\n    };\n    return Int32Histogram;\n}(AbstractHistogram_1.default));\nexports.default = Int32Histogram;\n//# sourceMappingURL=Int32Histogram.js.map","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * This is a TypeScript port of the original Java version, which was written by\n * Gil Tene as described in\n * https://github.com/HdrHistogram/HdrHistogram\n * and released to the public domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\nvar AbstractHistogram_1 = require(\"./AbstractHistogram\");\nvar Int8Histogram = /** @class */ (function (_super) {\n    __extends(Int8Histogram, _super);\n    function Int8Histogram(lowestDiscernibleValue, highestTrackableValue, numberOfSignificantValueDigits) {\n        var _this = _super.call(this, lowestDiscernibleValue, highestTrackableValue, numberOfSignificantValueDigits) || this;\n        _this.totalCount = 0;\n        _this.counts = new Uint8Array(_this.countsArrayLength);\n        return _this;\n    }\n    Int8Histogram.prototype.clearCounts = function () {\n        this.counts.fill(0);\n    };\n    Int8Histogram.prototype.incrementCountAtIndex = function (index) {\n        var currentCount = this.counts[index];\n        var newCount = currentCount + 1;\n        if (newCount < 0) {\n            throw newCount + \" would overflow short integer count\";\n        }\n        this.counts[index] = newCount;\n    };\n    Int8Histogram.prototype.addToCountAtIndex = function (index, value) {\n        var currentCount = this.counts[index];\n        var newCount = currentCount + value;\n        if (newCount < Number.MIN_SAFE_INTEGER ||\n            newCount > Number.MAX_SAFE_INTEGER) {\n            throw newCount + \" would overflow integer count\";\n        }\n        this.counts[index] = newCount;\n    };\n    Int8Histogram.prototype.setCountAtIndex = function (index, value) {\n        if (value < Number.MIN_SAFE_INTEGER || value > Number.MAX_SAFE_INTEGER) {\n            throw value + \" would overflow integer count\";\n        }\n        this.counts[index] = value;\n    };\n    Int8Histogram.prototype.resize = function (newHighestTrackableValue) {\n        this.establishSize(newHighestTrackableValue);\n        var newCounts = new Uint8Array(this.countsArrayLength);\n        newCounts.set(this.counts);\n        this.counts = newCounts;\n    };\n    Int8Histogram.prototype.setNormalizingIndexOffset = function (normalizingIndexOffset) { };\n    Int8Histogram.prototype.incrementTotalCount = function () {\n        this.totalCount++;\n    };\n    Int8Histogram.prototype.addToTotalCount = function (value) {\n        this.totalCount += value;\n    };\n    Int8Histogram.prototype.setTotalCount = function (value) {\n        this.totalCount = value;\n    };\n    Int8Histogram.prototype.getTotalCount = function () {\n        return this.totalCount;\n    };\n    Int8Histogram.prototype.getCountAtIndex = function (index) {\n        return this.counts[index];\n    };\n    Int8Histogram.prototype._getEstimatedFootprintInBytes = function () {\n        return 512 + this.counts.length;\n    };\n    Int8Histogram.prototype.copyCorrectedForCoordinatedOmission = function (expectedIntervalBetweenValueSamples) {\n        var copy = new Int8Histogram(this.lowestDiscernibleValue, this.highestTrackableValue, this.numberOfSignificantValueDigits);\n        copy.addWhileCorrectingForCoordinatedOmission(this, expectedIntervalBetweenValueSamples);\n        return copy;\n    };\n    return Int8Histogram;\n}(AbstractHistogram_1.default));\nexports.default = Int8Histogram;\n//# sourceMappingURL=Int8Histogram.js.map","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * This is a TypeScript port of the original Java version, which was written by\n * Gil Tene as described in\n * https://github.com/HdrHistogram/HdrHistogram\n * and released to the public domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\nvar AbstractHistogram_1 = require(\"./AbstractHistogram\");\nvar PackedArray_1 = require(\"./packedarray/PackedArray\");\n/**\n * <h3>A High Dynamic Range (HDR) Histogram that uses a packed internal representation</h3>\n * <p>\n * {@link PackedHistogram} supports the recording and analyzing sampled data value counts across a configurable\n * integer value range with configurable value precision within the range. Value precision is expressed as the\n * number of significant digits in the value recording, and provides control over value quantization behavior\n * across the value range and the subsequent value resolution at any given level.\n * <p>\n * {@link PackedHistogram} tracks value counts in a packed internal representation optimized\n * for typical histogram recoded values are sparse in the value range and tend to be incremented in small unit counts.\n * This packed representation tends to require significantly smaller amounts of stoarge when compared to unpacked\n * representations, but can incur additional recording cost due to resizing and repacking operations that may\n * occur as previously unrecorded values are encountered.\n * <p>\n * For example, a {@link PackedHistogram} could be configured to track the counts of observed integer values between 0 and\n * 3,600,000,000,000 while maintaining a value precision of 3 significant digits across that range. Value quantization\n * within the range will thus be no larger than 1/1,000th (or 0.1%) of any value. This example Histogram could\n * be used to track and analyze the counts of observed response times ranging between 1 nanosecond and 1 hour\n * in magnitude, while maintaining a value resolution of 1 microsecond up to 1 millisecond, a resolution of\n * 1 millisecond (or better) up to one second, and a resolution of 1 second (or better) up to 1,000 seconds. At its\n * maximum tracked value (1 hour), it would still maintain a resolution of 3.6 seconds (or better).\n * <p>\n * Auto-resizing: When constructed with no specified value range range (or when auto-resize is turned on with {@link\n * Histogram#setAutoResize}) a {@link PackedHistogram} will auto-resize its dynamic range to include recorded values as\n * they are encountered. Note that recording calls that cause auto-resizing may take longer to execute, as resizing\n * incurs allocation and copying of internal data structures.\n * <p>\n */\nvar PackedHistogram = /** @class */ (function (_super) {\n    __extends(PackedHistogram, _super);\n    function PackedHistogram(lowestDiscernibleValue, highestTrackableValue, numberOfSignificantValueDigits) {\n        var _this = _super.call(this, lowestDiscernibleValue, highestTrackableValue, numberOfSignificantValueDigits) || this;\n        _this.totalCount = 0;\n        _this.packedCounts = new PackedArray_1.PackedArray(_this.countsArrayLength);\n        return _this;\n    }\n    PackedHistogram.prototype.clearCounts = function () {\n        this.packedCounts.clear();\n        this.totalCount = 0;\n    };\n    PackedHistogram.prototype.incrementCountAtIndex = function (index) {\n        this.packedCounts.increment(index);\n    };\n    PackedHistogram.prototype.addToCountAtIndex = function (index, value) {\n        this.packedCounts.add(index, value);\n    };\n    PackedHistogram.prototype.setCountAtIndex = function (index, value) {\n        /* TODO move in packed array\n        if (value < Number.MIN_SAFE_INTEGER || value > Number.MAX_SAFE_INTEGER) {\n          throw value + \" would overflow integer count\";\n        }*/\n        this.packedCounts.set(index, value);\n    };\n    PackedHistogram.prototype.resize = function (newHighestTrackableValue) {\n        this.establishSize(newHighestTrackableValue);\n        this.packedCounts.setVirtualLength(this.countsArrayLength);\n    };\n    PackedHistogram.prototype.setNormalizingIndexOffset = function (normalizingIndexOffset) { };\n    PackedHistogram.prototype.incrementTotalCount = function () {\n        this.totalCount++;\n    };\n    PackedHistogram.prototype.addToTotalCount = function (value) {\n        this.totalCount += value;\n    };\n    PackedHistogram.prototype.setTotalCount = function (value) {\n        this.totalCount = value;\n    };\n    PackedHistogram.prototype.getTotalCount = function () {\n        return this.totalCount;\n    };\n    PackedHistogram.prototype.getCountAtIndex = function (index) {\n        return this.packedCounts.get(index);\n    };\n    PackedHistogram.prototype._getEstimatedFootprintInBytes = function () {\n        return 192 + 8 * this.packedCounts.getPhysicalLength();\n    };\n    PackedHistogram.prototype.copyCorrectedForCoordinatedOmission = function (expectedIntervalBetweenValueSamples) {\n        var copy = new PackedHistogram(this.lowestDiscernibleValue, this.highestTrackableValue, this.numberOfSignificantValueDigits);\n        copy.addWhileCorrectingForCoordinatedOmission(this, expectedIntervalBetweenValueSamples);\n        return copy;\n    };\n    return PackedHistogram;\n}(AbstractHistogram_1.default));\nexports.default = PackedHistogram;\n//# sourceMappingURL=PackedHistogram.js.map","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar AbstractHistogramIterator_1 = require(\"./AbstractHistogramIterator\");\nvar pow = Math.pow, floor = Math.floor, log2 = Math.log2;\n/**\n * Used for iterating through histogram values according to percentile levels. The iteration is\n * performed in steps that start at 0% and reduce their distance to 100% according to the\n * <i>percentileTicksPerHalfDistance</i> parameter, ultimately reaching 100% when all recorded histogram\n * values are exhausted.\n */\nvar PercentileIterator = /** @class */ (function (_super) {\n    __extends(PercentileIterator, _super);\n    /**\n     * @param histogram The histogram this iterator will operate on\n     * @param percentileTicksPerHalfDistance The number of equal-sized iteration steps per half-distance to 100%.\n     */\n    function PercentileIterator(histogram, percentileTicksPerHalfDistance) {\n        var _this = _super.call(this) || this;\n        _this.percentileTicksPerHalfDistance = 0;\n        _this.percentileLevelToIterateTo = 0;\n        _this.percentileLevelToIterateFrom = 0;\n        _this.reachedLastRecordedValue = false;\n        _this.doReset(histogram, percentileTicksPerHalfDistance);\n        return _this;\n    }\n    /**\n     * Reset iterator for re-use in a fresh iteration over the same histogram data set.\n     *\n     * @param percentileTicksPerHalfDistance The number of iteration steps per half-distance to 100%.\n     */\n    PercentileIterator.prototype.reset = function (percentileTicksPerHalfDistance) {\n        this.doReset(this.histogram, percentileTicksPerHalfDistance);\n    };\n    PercentileIterator.prototype.doReset = function (histogram, percentileTicksPerHalfDistance) {\n        _super.prototype.resetIterator.call(this, histogram);\n        this.percentileTicksPerHalfDistance = percentileTicksPerHalfDistance;\n        this.percentileLevelToIterateTo = 0;\n        this.percentileLevelToIterateFrom = 0;\n        this.reachedLastRecordedValue = false;\n    };\n    PercentileIterator.prototype.hasNext = function () {\n        if (_super.prototype.hasNext.call(this))\n            return true;\n        if (!this.reachedLastRecordedValue && this.arrayTotalCount > 0) {\n            this.percentileLevelToIterateTo = 100;\n            this.reachedLastRecordedValue = true;\n            return true;\n        }\n        return false;\n    };\n    PercentileIterator.prototype.incrementIterationLevel = function () {\n        this.percentileLevelToIterateFrom = this.percentileLevelToIterateTo;\n        // The choice to maintain fixed-sized \"ticks\" in each half-distance to 100% [starting\n        // from 0%], as opposed to a \"tick\" size that varies with each interval, was made to\n        // make the steps easily comprehensible and readable to humans. The resulting percentile\n        // steps are much easier to browse through in a percentile distribution output, for example.\n        //\n        // We calculate the number of equal-sized \"ticks\" that the 0-100 range will be divided\n        // by at the current scale. The scale is detemined by the percentile level we are\n        // iterating to. The following math determines the tick size for the current scale,\n        // and maintain a fixed tick size for the remaining \"half the distance to 100%\"\n        // [from either 0% or from the previous half-distance]. When that half-distance is\n        // crossed, the scale changes and the tick size is effectively cut in half.\n        // percentileTicksPerHalfDistance = 5\n        // percentileReportingTicks = 10,\n        var percentileReportingTicks = this.percentileTicksPerHalfDistance *\n            pow(2, floor(log2(100 / (100 - this.percentileLevelToIterateTo))) + 1);\n        this.percentileLevelToIterateTo += 100 / percentileReportingTicks;\n    };\n    PercentileIterator.prototype.reachedIterationLevel = function () {\n        if (this.countAtThisValue === 0) {\n            return false;\n        }\n        var currentPercentile = 100 * this.totalCountToCurrentIndex / this.arrayTotalCount;\n        return currentPercentile >= this.percentileLevelToIterateTo;\n    };\n    PercentileIterator.prototype.getPercentileIteratedTo = function () {\n        return this.percentileLevelToIterateTo;\n    };\n    PercentileIterator.prototype.getPercentileIteratedFrom = function () {\n        return this.percentileLevelToIterateFrom;\n    };\n    return PercentileIterator;\n}(AbstractHistogramIterator_1.default));\nexports.default = PercentileIterator;\n//# sourceMappingURL=PercentileIterator.js.map","\"use strict\";\n/*\n * This is a TypeScript port of the original Java version, which was written by\n * Gil Tene as described in\n * https://github.com/HdrHistogram/HdrHistogram\n * and released to the public domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar AbstractHistogramIterator_1 = require(\"./AbstractHistogramIterator\");\n/**\n * Used for iterating through all recorded histogram values using the finest granularity steps supported by the\n * underlying representation. The iteration steps through all non-zero recorded value counts, and terminates when\n * all recorded histogram values are exhausted.\n */\nvar RecordedValuesIterator = /** @class */ (function (_super) {\n    __extends(RecordedValuesIterator, _super);\n    /**\n     * @param histogram The histogram this iterator will operate on\n     */\n    function RecordedValuesIterator(histogram) {\n        var _this = _super.call(this) || this;\n        _this.doReset(histogram);\n        return _this;\n    }\n    /**\n     * Reset iterator for re-use in a fresh iteration over the same histogram data set.\n     */\n    RecordedValuesIterator.prototype.reset = function () {\n        this.doReset(this.histogram);\n    };\n    RecordedValuesIterator.prototype.doReset = function (histogram) {\n        _super.prototype.resetIterator.call(this, histogram);\n        this.visitedIndex = -1;\n    };\n    RecordedValuesIterator.prototype.incrementIterationLevel = function () {\n        this.visitedIndex = this.currentIndex;\n    };\n    RecordedValuesIterator.prototype.reachedIterationLevel = function () {\n        var currentCount = this.histogram.getCountAtIndex(this.currentIndex);\n        return currentCount != 0 && this.visitedIndex !== this.currentIndex;\n    };\n    return RecordedValuesIterator;\n}(AbstractHistogramIterator_1.default));\nexports.default = RecordedValuesIterator;\n//# sourceMappingURL=RecordedValuesIterator.js.map","\"use strict\";\n/*\n * This is a TypeScript port of the original Java version, which was written by\n * Gil Tene as described in\n * https://github.com/HdrHistogram/HdrHistogram\n * and released to the public domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Int32Histogram_1 = require(\"./Int32Histogram\");\nvar PackedHistogram_1 = require(\"./PackedHistogram\");\n/**\n * Records integer values, and provides stable interval {@link Histogram} samples from\n * live recorded data without interrupting or stalling active recording of values. Each interval\n * histogram provided contains all value counts accumulated since the previous interval histogram\n * was taken.\n * <p>\n * This pattern is commonly used in logging interval histogram information while recording is ongoing.\n * <p>\n * {@link Recorder} supports concurrent\n * {@link Recorder#recordValue} or\n * {@link Recorder#recordValueWithExpectedInterval} calls.\n *\n */\nvar Recorder = /** @class */ (function () {\n    /**\n     * Construct an auto-resizing {@link Recorder} with a lowest discernible value of\n     * 1 and an auto-adjusting highestTrackableValue. Can auto-resize up to track values up to Number.MAX_SAFE_INTEGER.\n     *\n     * @param numberOfSignificantValueDigits Specifies the precision to use. This is the number of significant\n     *                                       decimal digits to which the histogram will maintain value resolution\n     *                                       and separation. Must be a non-negative integer between 0 and 5.\n     * @param packed Specifies whether the recorder will uses a packed internal representation or not.\n     * @param clock (for testing purpose) an action that give current time in ms since 1970\n     */\n    function Recorder(numberOfSignificantValueDigits, packed, clock) {\n        if (numberOfSignificantValueDigits === void 0) { numberOfSignificantValueDigits = 3; }\n        if (packed === void 0) { packed = false; }\n        if (clock === void 0) { clock = function () { return new Date().getTime(); }; }\n        this.numberOfSignificantValueDigits = numberOfSignificantValueDigits;\n        this.packed = packed;\n        this.clock = clock;\n        this.histogramConstr = packed ? PackedHistogram_1.default : Int32Histogram_1.default;\n        this.activeHistogram = new this.histogramConstr(1, Number.MAX_SAFE_INTEGER, numberOfSignificantValueDigits);\n        Recorder.idGenerator++;\n        this.activeHistogram.containingInstanceId = Recorder.idGenerator;\n        this.activeHistogram.startTimeStampMsec = clock();\n    }\n    /**\n     * Record a value in the histogram\n     *\n     * @param value The value to be recorded\n     * @throws may throw Error if value is exceeds highestTrackableValue\n     */\n    Recorder.prototype.recordValue = function (value) {\n        this.activeHistogram.recordValue(value);\n    };\n    /**\n     * Record a value in the histogram (adding to the value's current count)\n     *\n     * @param value The value to be recorded\n     * @param count The number of occurrences of this value to record\n     * @throws ArrayIndexOutOfBoundsException (may throw) if value is exceeds highestTrackableValue\n     */\n    Recorder.prototype.recordValueWithCount = function (value, count) {\n        this.activeHistogram.recordValueWithCount(value, count);\n    };\n    /**\n     * Record a value\n     * <p>\n     * To compensate for the loss of sampled values when a recorded value is larger than the expected\n     * interval between value samples, Histogram will auto-generate an additional series of decreasingly-smaller\n     * (down to the expectedIntervalBetweenValueSamples) value records.\n     * <p>\n     * See related notes {@link AbstractHistogram#recordValueWithExpectedInterval(long, long)}\n     * for more explanations about coordinated omission and expected interval correction.\n     *      *\n     * @param value The value to record\n     * @param expectedIntervalBetweenValueSamples If expectedIntervalBetweenValueSamples is larger than 0, add\n     *                                           auto-generated value records as appropriate if value is larger\n     *                                           than expectedIntervalBetweenValueSamples\n     * @throws ArrayIndexOutOfBoundsException (may throw) if value is exceeds highestTrackableValue\n     */\n    Recorder.prototype.recordValueWithExpectedInterval = function (value, expectedIntervalBetweenValueSamples) {\n        this.activeHistogram.recordValueWithExpectedInterval(value, expectedIntervalBetweenValueSamples);\n    };\n    /**\n     * Get an interval histogram, which will include a stable, consistent view of all value counts\n     * accumulated since the last interval histogram was taken.\n     * <p>\n     * {@link Recorder#getIntervalHistogram(Histogram histogramToRecycle)\n     * getIntervalHistogram(histogramToRecycle)}\n     * accepts a previously returned interval histogram that can be recycled internally to avoid allocation\n     * and content copying operations, and is therefore significantly more efficient for repeated use than\n     * {@link Recorder#getIntervalHistogram()} and\n     * {@link Recorder#getIntervalHistogramInto getIntervalHistogramInto()}. The provided\n     * {@code histogramToRecycle} must\n     * be either be null or an interval histogram returned by a previous call to\n     * {@link Recorder#getIntervalHistogram(Histogram histogramToRecycle)\n     * getIntervalHistogram(histogramToRecycle)} or\n     * {@link Recorder#getIntervalHistogram()}.\n     * <p>\n     * NOTE: The caller is responsible for not recycling the same returned interval histogram more than once. If\n     * the same interval histogram instance is recycled more than once, behavior is undefined.\n     * <p>\n     * Calling {@link Recorder#getIntervalHistogram(Histogram histogramToRecycle)\n     * getIntervalHistogram(histogramToRecycle)} will reset the value counts, and start accumulating value\n     * counts for the next interval\n     *\n     * @param histogramToRecycle a previously returned interval histogram that may be recycled to avoid allocation and\n     *                           copy operations.\n     * @return a histogram containing the value counts accumulated since the last interval histogram was taken.\n     */\n    Recorder.prototype.getIntervalHistogram = function (histogramToRecycle) {\n        if (histogramToRecycle) {\n            var histogramToRecycleWithId = histogramToRecycle;\n            if (histogramToRecycleWithId.containingInstanceId !==\n                this.activeHistogram.containingInstanceId) {\n                throw \"replacement histogram must have been obtained via a previous getIntervalHistogram() call from this Recorder\";\n            }\n        }\n        this.inactiveHistogram = histogramToRecycle;\n        this.performIntervalSample();\n        var sampledHistogram = this.inactiveHistogram;\n        this.inactiveHistogram = null; // Once we expose the sample, we can't reuse it internally until it is recycled\n        return sampledHistogram;\n    };\n    /**\n     * Place a copy of the value counts accumulated since accumulated (since the last interval histogram\n     * was taken) into {@code targetHistogram}.\n     *\n     * Calling {@link Recorder#getIntervalHistogramInto getIntervalHistogramInto()} will reset\n     * the value counts, and start accumulating value counts for the next interval.\n     *\n     * @param targetHistogram the histogram into which the interval histogram's data should be copied\n     */\n    Recorder.prototype.getIntervalHistogramInto = function (targetHistogram) {\n        this.performIntervalSample();\n        if (this.inactiveHistogram) {\n            targetHistogram.add(this.inactiveHistogram);\n            targetHistogram.startTimeStampMsec = this.inactiveHistogram.startTimeStampMsec;\n            targetHistogram.endTimeStampMsec = this.inactiveHistogram.endTimeStampMsec;\n        }\n    };\n    /**\n     * Reset any value counts accumulated thus far.\n     */\n    Recorder.prototype.reset = function () {\n        this.activeHistogram.reset();\n        this.activeHistogram.startTimeStampMsec = this.clock();\n    };\n    Recorder.prototype.performIntervalSample = function () {\n        if (!this.inactiveHistogram) {\n            this.inactiveHistogram = new this.histogramConstr(1, Number.MAX_SAFE_INTEGER, this.numberOfSignificantValueDigits);\n            this.inactiveHistogram.containingInstanceId = this.activeHistogram.containingInstanceId;\n        }\n        this.inactiveHistogram.reset();\n        var tempHistogram = this.activeHistogram;\n        this.activeHistogram = this.inactiveHistogram;\n        this.inactiveHistogram = tempHistogram;\n        var currentTimeInMs = this.clock();\n        this.inactiveHistogram.endTimeStampMsec = currentTimeInMs;\n        this.activeHistogram.startTimeStampMsec = currentTimeInMs;\n    };\n    Recorder.idGenerator = 0;\n    return Recorder;\n}());\nexports.default = Recorder;\n//# sourceMappingURL=Recorder.js.map","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * This is a TypeScript port of the original Java version, which was written by\n * Gil Tene as described in\n * https://github.com/HdrHistogram/HdrHistogram\n * and released to the public domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\nvar AbstractHistogram_1 = require(\"./AbstractHistogram\");\nvar SparseArrayHistogram = /** @class */ (function (_super) {\n    __extends(SparseArrayHistogram, _super);\n    function SparseArrayHistogram(lowestDiscernibleValue, highestTrackableValue, numberOfSignificantValueDigits) {\n        var _this = _super.call(this, lowestDiscernibleValue, highestTrackableValue, numberOfSignificantValueDigits) || this;\n        _this.totalCount = 0;\n        _this.counts = new Array();\n        return _this;\n    }\n    SparseArrayHistogram.prototype.clearCounts = function () {\n        this.counts.fill(0);\n    };\n    SparseArrayHistogram.prototype.incrementCountAtIndex = function (index) {\n        var currentCount = this.counts[index] || 0;\n        var newCount = currentCount + 1;\n        if (newCount < 0) {\n            throw newCount + \" would overflow short integer count\";\n        }\n        this.counts[index] = newCount;\n    };\n    SparseArrayHistogram.prototype.addToCountAtIndex = function (index, value) {\n        var currentCount = this.counts[index] || 0;\n        var newCount = currentCount + value;\n        if (newCount < Number.MIN_SAFE_INTEGER ||\n            newCount > Number.MAX_SAFE_INTEGER) {\n            throw newCount + \" would overflow integer count\";\n        }\n        this.counts[index] = newCount;\n    };\n    SparseArrayHistogram.prototype.setCountAtIndex = function (index, value) {\n        if (value < Number.MIN_SAFE_INTEGER || value > Number.MAX_SAFE_INTEGER) {\n            throw value + \" would overflow integer count\";\n        }\n        this.counts[index] = value;\n    };\n    SparseArrayHistogram.prototype.resize = function (newHighestTrackableValue) {\n        this.establishSize(newHighestTrackableValue);\n    };\n    SparseArrayHistogram.prototype.setNormalizingIndexOffset = function (normalizingIndexOffset) { };\n    SparseArrayHistogram.prototype.incrementTotalCount = function () {\n        this.totalCount++;\n    };\n    SparseArrayHistogram.prototype.addToTotalCount = function (value) {\n        this.totalCount += value;\n    };\n    SparseArrayHistogram.prototype.setTotalCount = function (value) {\n        this.totalCount = value;\n    };\n    SparseArrayHistogram.prototype.getTotalCount = function () {\n        return this.totalCount;\n    };\n    SparseArrayHistogram.prototype.getCountAtIndex = function (index) {\n        return this.counts[index] || 0;\n    };\n    SparseArrayHistogram.prototype._getEstimatedFootprintInBytes = function () {\n        return 512 + this.counts.length;\n    };\n    SparseArrayHistogram.prototype.copyCorrectedForCoordinatedOmission = function (expectedIntervalBetweenValueSamples) {\n        var copy = new SparseArrayHistogram(this.lowestDiscernibleValue, this.highestTrackableValue, this.numberOfSignificantValueDigits);\n        copy.addWhileCorrectingForCoordinatedOmission(this, expectedIntervalBetweenValueSamples);\n        return copy;\n    };\n    return SparseArrayHistogram;\n}(AbstractHistogram_1.default));\nexports.default = SparseArrayHistogram;\n//# sourceMappingURL=SparseArrayHistogram.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar pow = Math.pow, floor = Math.floor;\nvar TWO_POW_7 = pow(2, 7);\nvar TWO_POW_14 = pow(2, 14);\nvar TWO_POW_21 = pow(2, 21);\nvar TWO_POW_28 = pow(2, 28);\nvar TWO_POW_35 = pow(2, 35);\nvar TWO_POW_42 = pow(2, 42);\nvar TWO_POW_49 = pow(2, 49);\nvar TWO_POW_56 = pow(2, 56);\n/**\n * This class provides encoding and decoding methods for writing and reading\n * ZigZag-encoded LEB128-64b9B-variant (Little Endian Base 128) values to/from a\n * {@link ByteBuffer}. LEB128's variable length encoding provides for using a\n * smaller nuber of bytes for smaller values, and the use of ZigZag encoding\n * allows small (closer to zero) negative values to use fewer bytes. Details\n * on both LEB128 and ZigZag can be readily found elsewhere.\n *\n * The LEB128-64b9B-variant encoding used here diverges from the \"original\"\n * LEB128 as it extends to 64 bit values: In the original LEB128, a 64 bit\n * value can take up to 10 bytes in the stream, where this variant's encoding\n * of a 64 bit values will max out at 9 bytes.\n *\n * As such, this encoder/decoder should NOT be used for encoding or decoding\n * \"standard\" LEB128 formats (e.g. Google Protocol Buffers).\n */\nvar ZigZagEncoding = /** @class */ (function () {\n    function ZigZagEncoding() {\n    }\n    /**\n     * Writes a long value to the given buffer in LEB128 ZigZag encoded format\n     * (negative numbers not supported)\n     * @param buffer the buffer to write to\n     * @param value  the value to write to the buffer\n     */\n    ZigZagEncoding.encode = function (buffer, value) {\n        if (value >= 0) {\n            value = value * 2;\n        }\n        else {\n            value = -value * 2 - 1;\n        }\n        if (value < TWO_POW_7) {\n            buffer.put(value);\n        }\n        else {\n            buffer.put(value | 0x80);\n            if (value < TWO_POW_14) {\n                buffer.put(floor(value / TWO_POW_7));\n            }\n            else {\n                buffer.put(floor(value / TWO_POW_7) | 0x80);\n                if (value < TWO_POW_21) {\n                    buffer.put(floor(value / TWO_POW_14));\n                }\n                else {\n                    buffer.put(floor(value / TWO_POW_14) | 0x80);\n                    if (value < TWO_POW_28) {\n                        buffer.put(floor(value / TWO_POW_21));\n                    }\n                    else {\n                        buffer.put(floor(value / TWO_POW_21) | 0x80);\n                        if (value < TWO_POW_35) {\n                            buffer.put(floor(value / TWO_POW_28));\n                        }\n                        else {\n                            buffer.put(floor(value / TWO_POW_28) | 0x80);\n                            if (value < TWO_POW_42) {\n                                buffer.put(floor(value / TWO_POW_35));\n                            }\n                            else {\n                                buffer.put(floor(value / TWO_POW_35) | 0x80);\n                                if (value < TWO_POW_49) {\n                                    buffer.put(floor(value / TWO_POW_42));\n                                }\n                                else {\n                                    buffer.put(floor(value / TWO_POW_42) | 0x80);\n                                    if (value < TWO_POW_56) {\n                                        buffer.put(floor(value / TWO_POW_49));\n                                    }\n                                    else {\n                                        // should not happen\n                                        buffer.put(floor(value / TWO_POW_49) + 0x80);\n                                        buffer.put(floor(value / TWO_POW_56));\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    };\n    /**\n     * Read an LEB128-64b9B ZigZag encoded long value from the given buffer\n     * (negative numbers not supported)\n     * @param buffer the buffer to read from\n     * @return the value read from the buffer\n     */\n    ZigZagEncoding.decode = function (buffer) {\n        var v = buffer.get();\n        var value = v & 0x7f;\n        if ((v & 0x80) != 0) {\n            v = buffer.get();\n            value += (v & 0x7f) * TWO_POW_7;\n            if ((v & 0x80) != 0) {\n                v = buffer.get();\n                value += (v & 0x7f) * TWO_POW_14;\n                if ((v & 0x80) != 0) {\n                    v = buffer.get();\n                    value += (v & 0x7f) * TWO_POW_21;\n                    if ((v & 0x80) != 0) {\n                        v = buffer.get();\n                        value += (v & 0x7f) * TWO_POW_28;\n                        if ((v & 0x80) != 0) {\n                            v = buffer.get();\n                            value += (v & 0x7f) * TWO_POW_35;\n                            if ((v & 0x80) != 0) {\n                                v = buffer.get();\n                                value += (v & 0x7f) * TWO_POW_42;\n                                if ((v & 0x80) != 0) {\n                                    v = buffer.get();\n                                    value += (v & 0x7f) * TWO_POW_49;\n                                    if ((v & 0x80) != 0) {\n                                        v = buffer.get();\n                                        value += (v & 0x7f) * TWO_POW_56;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        if (value % 2 === 0) {\n            value = value / 2;\n        }\n        else {\n            value = -(value + 1) / 2;\n        }\n        return value;\n    };\n    return ZigZagEncoding;\n}());\nexports.default = ZigZagEncoding;\n//# sourceMappingURL=ZigZagEncoding.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * This is a TypeScript port of the original Java version, which was written by\n * Gil Tene as described in\n * https://github.com/HdrHistogram/HdrHistogram\n * and released to the public domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\nvar ByteBuffer_1 = require(\"./ByteBuffer\");\nvar AbstractHistogram_1 = require(\"./AbstractHistogram\");\nvar Int32Histogram_1 = require(\"./Int32Histogram\");\nrequire(\"./AbstractHistogram.encoding\");\nvar base64 = require(\"base64-js\");\nvar decodeFromCompressedBase64 = function (base64String, histogramConstr, minBarForHighestTrackableValue) {\n    if (histogramConstr === void 0) { histogramConstr = Int32Histogram_1.default; }\n    if (minBarForHighestTrackableValue === void 0) { minBarForHighestTrackableValue = 0; }\n    var buffer = new ByteBuffer_1.default(base64.toByteArray(base64String.trim()));\n    return AbstractHistogram_1.AbstractHistogram.decodeFromCompressedByteBuffer(buffer, histogramConstr, minBarForHighestTrackableValue);\n};\nexports.decodeFromCompressedBase64 = decodeFromCompressedBase64;\nvar encodeIntoBase64String = function (histogram, compressionLevel) {\n    var buffer = ByteBuffer_1.default.allocate();\n    var bufferSize = histogram.encodeIntoCompressedByteBuffer(buffer, compressionLevel);\n    var encodedBuffer = buffer.data.slice(0, bufferSize);\n    return base64.fromByteArray(encodedBuffer);\n};\nexports.encodeIntoBase64String = encodeIntoBase64String;\n//# sourceMappingURL=encoding.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar leftPadding = function (size) {\n    return function (input) {\n        if (input.length < size) {\n            return \" \".repeat(size - input.length) + input;\n        }\n        return input;\n    };\n};\nexports.integerFormatter = function (size) {\n    var padding = leftPadding(size);\n    return function (integer) { return padding(\"\" + integer); };\n};\nexports.floatFormatter = function (size, fractionDigits) {\n    var numberFormatter = new Intl.NumberFormat(\"en-US\", {\n        maximumFractionDigits: fractionDigits,\n        minimumFractionDigits: fractionDigits,\n        useGrouping: false\n    });\n    var padding = leftPadding(size);\n    return function (float) { return padding(numberFormatter.format(float)); };\n};\n//# sourceMappingURL=formatters.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * This is a TypeScript port of the original Java version, which was written by\n * Gil Tene as described in\n * https://github.com/HdrHistogram/HdrHistogram\n * and released to the public domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\nvar ByteBuffer_1 = require(\"./ByteBuffer\");\nexports.ByteBuffer = ByteBuffer_1.default;\nvar Int8Histogram_1 = require(\"./Int8Histogram\");\nexports.Int8Histogram = Int8Histogram_1.default;\nvar Int16Histogram_1 = require(\"./Int16Histogram\");\nexports.Int16Histogram = Int16Histogram_1.default;\nvar Int32Histogram_1 = require(\"./Int32Histogram\");\nexports.Int32Histogram = Int32Histogram_1.default;\nvar Float64Histogram_1 = require(\"./Float64Histogram\");\nexports.Float64Histogram = Float64Histogram_1.default;\nvar PackedHistogram_1 = require(\"./PackedHistogram\");\nexports.PackedHistogram = PackedHistogram_1.default;\nvar SparseArrayHistogram_1 = require(\"./SparseArrayHistogram\");\nexports.SparseArrayHistogram = SparseArrayHistogram_1.default;\nvar AbstractHistogram_1 = require(\"./AbstractHistogram\");\nexports.AbstractHistogram = AbstractHistogram_1.default;\nexports.Histogram = AbstractHistogram_1.default;\nvar HistogramLogReader_1 = require(\"./HistogramLogReader\");\nexports.HistogramLogReader = HistogramLogReader_1.default;\nexports.listTags = HistogramLogReader_1.listTags;\nvar HistogramLogWriter_1 = require(\"./HistogramLogWriter\");\nexports.HistogramLogWriter = HistogramLogWriter_1.default;\nvar encoding_1 = require(\"./encoding\");\nexports.decodeFromCompressedBase64 = encoding_1.decodeFromCompressedBase64;\nexports.encodeIntoBase64String = encoding_1.encodeIntoBase64String;\nvar Recorder_1 = require(\"./Recorder\");\nexports.Recorder = Recorder_1.default;\nvar defaultRequest = {\n    bitBucketSize: 32,\n    autoResize: true,\n    lowestDiscernibleValue: 1,\n    highestTrackableValue: 2,\n    numberOfSignificantValueDigits: 3\n};\nexports.defaultRequest = defaultRequest;\n/*const bigIntAvailable = (() => {\n  try {\n    eval(\"123n\");\n    return true;\n  } catch (e) {\n    return false;\n  }\n})();*/\nvar build = function (request) {\n    if (request === void 0) { request = defaultRequest; }\n    var parameters = Object.assign({}, defaultRequest, request);\n    var histogramConstr;\n    switch (parameters.bitBucketSize) {\n        case 8:\n            histogramConstr = Int8Histogram_1.default;\n            break;\n        case 16:\n            histogramConstr = Int16Histogram_1.default;\n            break;\n        case 32:\n            histogramConstr = Int32Histogram_1.default;\n            break;\n        case \"sparse_array\":\n            histogramConstr = SparseArrayHistogram_1.default;\n            break;\n        case \"packed\":\n            histogramConstr = PackedHistogram_1.default;\n            break;\n        default:\n            //histogramConstr = bigIntAvailable ? BigIntHistogram : Float64Histogram;\n            histogramConstr = Float64Histogram_1.default;\n    }\n    var histogram = new histogramConstr(parameters.lowestDiscernibleValue, parameters.highestTrackableValue, parameters.numberOfSignificantValueDigits);\n    histogram.autoResize = parameters.autoResize;\n    return histogram;\n};\nexports.build = build;\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * This is a TypeScript port of the original Java version, which was written by\n * Gil Tene as described in\n * https://github.com/HdrHistogram/HdrHistogram\n * and released to the public domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\nvar PackedArrayContext_1 = require(\"./PackedArrayContext\");\nvar ResizeError_1 = require(\"./ResizeError\");\nvar NUMBER_OF_SETS = 8;\nvar pow = Math.pow, floor = Math.floor;\n/**\n * A Packed array of signed 64 bit values, and supports {@link #get get()}, {@link #set set()},\n * {@link #add add()} and {@link #increment increment()} operations on the logical contents of the array.\n *\n * An {@link PackedLongArray} Uses {@link PackedArrayContext} to track\n * the array's logical contents. Contexts may be switched when a context requires resizing\n * to complete logical array operations (get, set, add, increment). Contexts are\n * established and used within critical sections in order to facilitate concurrent\n * implementors.\n *\n */\nvar PackedArray = /** @class */ (function () {\n    function PackedArray(virtualLength, initialPhysicalLength) {\n        if (initialPhysicalLength === void 0) { initialPhysicalLength = PackedArrayContext_1.MINIMUM_INITIAL_PACKED_ARRAY_CAPACITY; }\n        this.arrayContext = new PackedArrayContext_1.PackedArrayContext(virtualLength, initialPhysicalLength);\n    }\n    PackedArray.prototype.setVirtualLength = function (newVirtualArrayLength) {\n        if (newVirtualArrayLength < this.length()) {\n            throw new Error(\"Cannot set virtual length, as requested length \" +\n                newVirtualArrayLength +\n                \" is smaller than the current virtual length \" +\n                this.length());\n        }\n        var currentArrayContext = this.arrayContext;\n        if (currentArrayContext.isPacked &&\n            currentArrayContext.determineTopLevelShiftForVirtualLength(newVirtualArrayLength) == currentArrayContext.getTopLevelShift()) {\n            // No changes to the array context contents is needed. Just change the virtual length.\n            currentArrayContext.setVirtualLength(newVirtualArrayLength);\n            return;\n        }\n        this.arrayContext = currentArrayContext.copyAndIncreaseSize(this.getPhysicalLength(), newVirtualArrayLength);\n    };\n    /**\n     * Get value at virtual index in the array\n     * @param index the virtual array index\n     * @return the array value at the virtual index given\n     */\n    PackedArray.prototype.get = function (index) {\n        var value = 0;\n        for (var byteNum = 0; byteNum < NUMBER_OF_SETS; byteNum++) {\n            var byteValueAtPackedIndex = 0;\n            // Deal with unpacked context:\n            if (!this.arrayContext.isPacked) {\n                return this.arrayContext.getAtUnpackedIndex(index);\n            }\n            // Context is packed:\n            var packedIndex = this.arrayContext.getPackedIndex(byteNum, index, false);\n            if (packedIndex < 0) {\n                return value;\n            }\n            byteValueAtPackedIndex =\n                this.arrayContext.getAtByteIndex(packedIndex) * pow(2, byteNum << 3);\n            value += byteValueAtPackedIndex;\n        }\n        return value;\n    };\n    /**\n     * Increment value at a virrual index in the array\n     * @param index virtual index of value to increment\n     */\n    PackedArray.prototype.increment = function (index) {\n        this.add(index, 1);\n    };\n    PackedArray.prototype.safeGetPackedIndexgetPackedIndex = function (setNumber, virtualIndex) {\n        do {\n            try {\n                return this.arrayContext.getPackedIndex(setNumber, virtualIndex, true);\n            }\n            catch (ex) {\n                if (ex instanceof ResizeError_1.ResizeError) {\n                    this.arrayContext.resizeArray(ex.newSize);\n                }\n                else {\n                    throw ex;\n                }\n            }\n        } while (true);\n    };\n    /**\n     * Add to a value at a virtual index in the array\n     * @param index the virtual index of the value to be added to\n     * @param value the value to add\n     */\n    PackedArray.prototype.add = function (index, value) {\n        var remainingValueToAdd = value;\n        for (var byteNum = 0, byteShift = 0; byteNum < NUMBER_OF_SETS; byteNum++, byteShift += 8) {\n            // Deal with unpacked context:\n            if (!this.arrayContext.isPacked) {\n                this.arrayContext.addAndGetAtUnpackedIndex(index, value);\n                return;\n            }\n            // Context is packed:\n            var packedIndex = this.safeGetPackedIndexgetPackedIndex(byteNum, index);\n            var byteToAdd = remainingValueToAdd & 0xff;\n            var afterAddByteValue = this.arrayContext.addAtByteIndex(packedIndex, byteToAdd);\n            // Reduce remaining value to add by amount just added:\n            remainingValueToAdd -= byteToAdd;\n            remainingValueToAdd = remainingValueToAdd / pow(2, 8);\n            // Account for carry:\n            remainingValueToAdd += floor(afterAddByteValue / pow(2, 8));\n            if (remainingValueToAdd == 0) {\n                return; // nothing to add to higher magnitudes\n            }\n        }\n    };\n    /**\n     * Set the value at a virtual index in the array\n     * @param index the virtual index of the value to set\n     * @param value the value to set\n     */\n    PackedArray.prototype.set = function (index, value) {\n        var bytesAlreadySet = 0;\n        do {\n            var valueForNextLevels = value;\n            try {\n                for (var byteNum = 0; byteNum < NUMBER_OF_SETS; byteNum++) {\n                    // Establish context within: critical section\n                    // Deal with unpacked context:\n                    if (!this.arrayContext.isPacked) {\n                        this.arrayContext.setAtUnpackedIndex(index, value);\n                        return;\n                    }\n                    // Context is packed:\n                    if (valueForNextLevels == 0) {\n                        // Special-case zeros to avoid inflating packed array for no reason\n                        var packedIndex_1 = this.arrayContext.getPackedIndex(byteNum, index, false);\n                        if (packedIndex_1 < 0) {\n                            return; // no need to create entries for zero values if they don't already exist\n                        }\n                    }\n                    // Make sure byte is populated:\n                    var packedIndex = this.arrayContext.getPackedIndex(byteNum, index, true);\n                    // Determine value to write, and prepare for next levels\n                    var byteToWrite = valueForNextLevels & 0xff;\n                    valueForNextLevels = floor(valueForNextLevels / pow(2, 8));\n                    if (byteNum < bytesAlreadySet) {\n                        // We want to avoid writing to the same byte twice when not doing so for the\n                        // entire 64 bit value atomically, as doing so opens a race with e.g. concurrent\n                        // adders. So dobn't actually write the byte if has been written before.\n                        continue;\n                    }\n                    this.arrayContext.setAtByteIndex(packedIndex, byteToWrite);\n                    bytesAlreadySet++;\n                }\n                return;\n            }\n            catch (ex) {\n                if (ex instanceof ResizeError_1.ResizeError) {\n                    this.arrayContext.resizeArray(ex.newSize);\n                }\n                else {\n                    throw ex;\n                }\n            }\n        } while (true);\n    };\n    /**\n     * Get the current physical length (in longs) of the array's backing storage\n     * @return the current physical length (in longs) of the array's current backing storage\n     */\n    PackedArray.prototype.getPhysicalLength = function () {\n        return this.arrayContext.physicalLength;\n    };\n    /**\n     * Get the (virtual) length of the array\n     * @return the (virtual) length of the array\n     */\n    PackedArray.prototype.length = function () {\n        return this.arrayContext.getVirtualLength();\n    };\n    /**\n     * Clear the array contents\n     */\n    PackedArray.prototype.clear = function () {\n        this.arrayContext.clear();\n    };\n    PackedArray.prototype.toString = function () {\n        var output = \"PackedArray:\\n\";\n        output += this.arrayContext.toString();\n        return output;\n    };\n    return PackedArray;\n}());\nexports.PackedArray = PackedArray;\n//# sourceMappingURL=PackedArray.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * This is a TypeScript port of the original Java version, which was written by\n * Gil Tene as described in\n * https://github.com/HdrHistogram/HdrHistogram\n * and released to the public domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\nvar ResizeError_1 = require(\"./ResizeError\");\n/**\n * A packed-value, sparse array context used for storing 64 bit signed values.\n *\n * An array context is optimised for tracking sparsely set (as in mostly zeros) values that tend to not make\n * use pof the full 64 bit value range even when they are non-zero. The array context's internal representation\n * is such that the packed value at each virtual array index may be represented by 0-8 bytes of actual storage.\n *\n * An array context encodes the packed values in 8 \"set trees\" with each set tree representing one byte of the\n * packed value at the virtual index in question. The {@link #getPackedIndex(int, int, boolean)} method is used\n * to look up the byte-index corresponding to the given (set tree) value byte of the given virtual index, and can\n * be used to add entries to represent that byte as needed. As a succesful {@link #getPackedIndex(int, int, boolean)}\n * may require a resizing of the array, it can throw a {@link ResizeException} to indicate that the requested\n * packed index cannot be found or added without a resize of the physical storage.\n *\n */\nexports.MINIMUM_INITIAL_PACKED_ARRAY_CAPACITY = 16;\nvar MAX_SUPPORTED_PACKED_COUNTS_ARRAY_LENGTH = Math.pow(2, 13) - 1; //(Short.MAX_VALUE / 4);  TODO ALEX why ???\nvar SET_0_START_INDEX = 0;\nvar NUMBER_OF_SETS = 8;\nvar LEAF_LEVEL_SHIFT = 3;\nvar NON_LEAF_ENTRY_SLOT_INDICATORS_OFFSET = 0;\nvar NON_LEAF_ENTRY_HEADER_SIZE_IN_SHORTS = 1;\nvar PACKED_ARRAY_GROWTH_INCREMENT = 16;\nvar PACKED_ARRAY_GROWTH_FRACTION_POW2 = 4;\nvar pow = Math.pow, ceil = Math.ceil, log2 = Math.log2, max = Math.max;\nvar bitCount = function (n) {\n    var bits = 0;\n    while (n !== 0) {\n        bits += bitCount32(n | 0);\n        n /= 0x100000000;\n    }\n    return bits;\n};\nvar bitCount32 = function (n) {\n    n = n - ((n >> 1) & 0x55555555);\n    n = (n & 0x33333333) + ((n >> 2) & 0x33333333);\n    return (((n + (n >> 4)) & 0xf0f0f0f) * 0x1010101) >> 24;\n};\nvar PackedArrayContext = /** @class */ (function () {\n    function PackedArrayContext(virtualLength, initialPhysicalLength) {\n        this.populatedShortLength = 0;\n        this.topLevelShift = Number.MAX_VALUE; // Make it non-sensical until properly initialized.\n        this.physicalLength = Math.max(initialPhysicalLength, exports.MINIMUM_INITIAL_PACKED_ARRAY_CAPACITY);\n        this.isPacked =\n            this.physicalLength <= MAX_SUPPORTED_PACKED_COUNTS_ARRAY_LENGTH;\n        if (!this.isPacked) {\n            this.physicalLength = virtualLength;\n        }\n        this.array = new ArrayBuffer(this.physicalLength * 8);\n        this.initArrayViews(this.array);\n        this.init(virtualLength);\n    }\n    PackedArrayContext.prototype.initArrayViews = function (array) {\n        this.byteArray = new Uint8Array(array);\n        this.shortArray = new Uint16Array(array);\n        this.longArray = new Float64Array(array);\n    };\n    PackedArrayContext.prototype.init = function (virtualLength) {\n        if (!this.isPacked) {\n            // Deal with non-packed context init:\n            this.virtualLength = virtualLength;\n            return;\n        }\n        this.populatedShortLength = SET_0_START_INDEX + 8;\n        // Populate empty root entries, and point to them from the root indexes:\n        for (var i = 0; i < NUMBER_OF_SETS; i++) {\n            this.setAtShortIndex(SET_0_START_INDEX + i, 0);\n        }\n        this.setVirtualLength(virtualLength);\n    };\n    PackedArrayContext.prototype.clear = function () {\n        this.byteArray.fill(0);\n    };\n    PackedArrayContext.prototype.copyAndIncreaseSize = function (newPhysicalArrayLength, newVirtualArrayLength) {\n        var ctx = new PackedArrayContext(newVirtualArrayLength, newPhysicalArrayLength);\n        if (this.isPacked) {\n            ctx.populateEquivalentEntriesWithEntriesFromOther(this);\n        }\n        return ctx;\n    };\n    PackedArrayContext.prototype.getPopulatedShortLength = function () {\n        return this.populatedShortLength;\n    };\n    PackedArrayContext.prototype.getPopulatedLongLength = function () {\n        return (this.getPopulatedShortLength() + 3) >> 2; // round up\n    };\n    PackedArrayContext.prototype.setAtByteIndex = function (byteIndex, value) {\n        this.byteArray[byteIndex] = value;\n    };\n    PackedArrayContext.prototype.getAtByteIndex = function (byteIndex) {\n        return this.byteArray[byteIndex];\n    };\n    /**\n     * add a byte value to a current byte value in the array\n     * @param byteIndex index of byte value to add to\n     * @param valueToAdd byte value to add\n     * @return the afterAddValue. ((afterAddValue & 0x100) != 0) indicates a carry.\n     */\n    PackedArrayContext.prototype.addAtByteIndex = function (byteIndex, valueToAdd) {\n        var newValue = this.byteArray[byteIndex] + valueToAdd;\n        this.byteArray[byteIndex] = newValue;\n        return newValue;\n    };\n    PackedArrayContext.prototype.setPopulatedLongLength = function (newPopulatedLongLength) {\n        this.populatedShortLength = newPopulatedLongLength << 2;\n    };\n    PackedArrayContext.prototype.getVirtualLength = function () {\n        return this.virtualLength;\n    };\n    PackedArrayContext.prototype.length = function () {\n        return this.physicalLength;\n    };\n    PackedArrayContext.prototype.setAtShortIndex = function (shortIndex, value) {\n        this.shortArray[shortIndex] = value;\n    };\n    PackedArrayContext.prototype.setAtLongIndex = function (longIndex, value) {\n        this.longArray[longIndex] = value;\n    };\n    PackedArrayContext.prototype.getAtShortIndex = function (shortIndex) {\n        return this.shortArray[shortIndex];\n    };\n    PackedArrayContext.prototype.getIndexAtShortIndex = function (shortIndex) {\n        return this.shortArray[shortIndex];\n    };\n    PackedArrayContext.prototype.setPackedSlotIndicators = function (entryIndex, newPackedSlotIndicators) {\n        this.setAtShortIndex(entryIndex + NON_LEAF_ENTRY_SLOT_INDICATORS_OFFSET, newPackedSlotIndicators);\n    };\n    PackedArrayContext.prototype.getPackedSlotIndicators = function (entryIndex) {\n        return (this.shortArray[entryIndex + NON_LEAF_ENTRY_SLOT_INDICATORS_OFFSET] &\n            0xffff);\n    };\n    PackedArrayContext.prototype.getIndexAtEntrySlot = function (entryIndex, slot) {\n        return this.getAtShortIndex(entryIndex + NON_LEAF_ENTRY_HEADER_SIZE_IN_SHORTS + slot);\n    };\n    PackedArrayContext.prototype.setIndexAtEntrySlot = function (entryIndex, slot, newIndexValue) {\n        this.setAtShortIndex(entryIndex + NON_LEAF_ENTRY_HEADER_SIZE_IN_SHORTS + slot, newIndexValue);\n    };\n    PackedArrayContext.prototype.expandArrayIfNeeded = function (entryLengthInLongs) {\n        var currentLength = this.length();\n        if (currentLength < this.getPopulatedLongLength() + entryLengthInLongs) {\n            var growthIncrement = max(entryLengthInLongs, PACKED_ARRAY_GROWTH_INCREMENT, this.getPopulatedLongLength() >> PACKED_ARRAY_GROWTH_FRACTION_POW2);\n            throw new ResizeError_1.ResizeError(currentLength + growthIncrement);\n        }\n    };\n    PackedArrayContext.prototype.newEntry = function (entryLengthInShorts) {\n        // Add entry at the end of the array:\n        var newEntryIndex = this.populatedShortLength;\n        this.expandArrayIfNeeded((entryLengthInShorts >> 2) + 1);\n        this.populatedShortLength = newEntryIndex + entryLengthInShorts;\n        for (var i = 0; i < entryLengthInShorts; i++) {\n            this.setAtShortIndex(newEntryIndex + i, -1); // Poison value -1. Must be overriden before reads\n        }\n        return newEntryIndex;\n    };\n    PackedArrayContext.prototype.newLeafEntry = function () {\n        // Add entry at the end of the array:\n        var newEntryIndex;\n        newEntryIndex = this.getPopulatedLongLength();\n        this.expandArrayIfNeeded(1);\n        this.setPopulatedLongLength(newEntryIndex + 1);\n        this.setAtLongIndex(newEntryIndex, 0);\n        return newEntryIndex;\n    };\n    /**\n     * Consolidate entry with previous entry verison if one exists\n     *\n     * @param entryIndex The shortIndex of the entry to be consolidated\n     * @param previousVersionIndex the index of the previous version of the entry\n     */\n    PackedArrayContext.prototype.consolidateEntry = function (entryIndex, previousVersionIndex) {\n        var previousVersionPackedSlotsIndicators = this.getPackedSlotIndicators(previousVersionIndex);\n        // Previous version exists, needs consolidation\n        var packedSlotsIndicators = this.getPackedSlotIndicators(entryIndex);\n        var insertedSlotMask = packedSlotsIndicators ^ previousVersionPackedSlotsIndicators; // the only bit that differs\n        var slotsBelowBitNumber = packedSlotsIndicators & (insertedSlotMask - 1);\n        var insertedSlotIndex = bitCount(slotsBelowBitNumber);\n        var numberOfSlotsInEntry = bitCount(packedSlotsIndicators);\n        // Copy the entry slots from previous version, skipping the newly inserted slot in the target:\n        var sourceSlot = 0;\n        for (var targetSlot = 0; targetSlot < numberOfSlotsInEntry; targetSlot++) {\n            if (targetSlot !== insertedSlotIndex) {\n                var indexAtSlot = this.getIndexAtEntrySlot(previousVersionIndex, sourceSlot);\n                if (indexAtSlot !== 0) {\n                    this.setIndexAtEntrySlot(entryIndex, targetSlot, indexAtSlot);\n                }\n                sourceSlot++;\n            }\n        }\n    };\n    /**\n     * Expand entry as indicated.\n     *\n     * @param existingEntryIndex the index of the entry\n     * @param entryPointerIndex  index to the slot pointing to the entry (needs to be fixed up)\n     * @param insertedSlotIndex  realtive [packed] index of slot being inserted into entry\n     * @param insertedSlotMask   mask value fo slot being inserted\n     * @param nextLevelIsLeaf    the level below this one is a leaf level\n     * @return the updated index of the entry (-1 if epansion failed due to conflict)\n     * @throws RetryException if expansion fails due to concurrent conflict, and caller should try again.\n     */\n    PackedArrayContext.prototype.expandEntry = function (existingEntryIndex, entryPointerIndex, insertedSlotIndex, insertedSlotMask, nextLevelIsLeaf) {\n        var packedSlotIndicators = this.getAtShortIndex(existingEntryIndex) & 0xffff;\n        packedSlotIndicators |= insertedSlotMask;\n        var numberOfslotsInExpandedEntry = bitCount(packedSlotIndicators);\n        if (insertedSlotIndex >= numberOfslotsInExpandedEntry) {\n            throw new Error(\"inserted slot index is out of range given provided masks\");\n        }\n        var expandedEntryLength = numberOfslotsInExpandedEntry + NON_LEAF_ENTRY_HEADER_SIZE_IN_SHORTS;\n        // Create new next-level entry to refer to from slot at this level:\n        var indexOfNewNextLevelEntry = 0;\n        if (nextLevelIsLeaf) {\n            indexOfNewNextLevelEntry = this.newLeafEntry(); // Establish long-index to new leaf entry\n        }\n        else {\n            // TODO: Optimize this by creating the whole sub-tree here, rather than a step that will immediaterly expand\n            // Create a new 1 word (empty, no slots set) entry for the next level:\n            indexOfNewNextLevelEntry = this.newEntry(NON_LEAF_ENTRY_HEADER_SIZE_IN_SHORTS); // Establish short-index to new leaf entry\n            this.setPackedSlotIndicators(indexOfNewNextLevelEntry, 0);\n        }\n        var insertedSlotValue = indexOfNewNextLevelEntry;\n        var expandedEntryIndex = this.newEntry(expandedEntryLength);\n        // populate the packed indicators word:\n        this.setPackedSlotIndicators(expandedEntryIndex, packedSlotIndicators);\n        // Populate the inserted slot with the index of the new next level entry:\n        this.setIndexAtEntrySlot(expandedEntryIndex, insertedSlotIndex, insertedSlotValue);\n        this.setAtShortIndex(entryPointerIndex, expandedEntryIndex);\n        this.consolidateEntry(expandedEntryIndex, existingEntryIndex);\n        return expandedEntryIndex;\n    };\n    //\n    //   ######   ######## ########    ##     ##    ###    ##             ## #### ##    ## ########  ######## ##     ##\n    //  ##    ##  ##          ##       ##     ##   ## ##   ##            ##   ##  ###   ## ##     ## ##        ##   ##\n    //  ##        ##          ##       ##     ##  ##   ##  ##           ##    ##  ####  ## ##     ## ##         ## ##\n    //  ##   #### ######      ##       ##     ## ##     ## ##          ##     ##  ## ## ## ##     ## ######      ###\n    //  ##    ##  ##          ##        ##   ##  ######### ##         ##      ##  ##  #### ##     ## ##         ## ##\n    //  ##    ##  ##          ##         ## ##   ##     ## ##        ##       ##  ##   ### ##     ## ##        ##   ##\n    //   ######   ########    ##          ###    ##     ## ######## ##       #### ##    ## ########  ######## ##     ##\n    //\n    PackedArrayContext.prototype.getRootEntry = function (setNumber, insertAsNeeded) {\n        if (insertAsNeeded === void 0) { insertAsNeeded = false; }\n        var entryPointerIndex = SET_0_START_INDEX + setNumber;\n        var entryIndex = this.getIndexAtShortIndex(entryPointerIndex);\n        if (entryIndex == 0) {\n            if (!insertAsNeeded) {\n                return 0; // Index does not currently exist in packed array;\n            }\n            entryIndex = this.newEntry(NON_LEAF_ENTRY_HEADER_SIZE_IN_SHORTS);\n            // Create a new empty (no slots set) entry for the next level:\n            this.setPackedSlotIndicators(entryIndex, 0);\n            this.setAtShortIndex(entryPointerIndex, entryIndex);\n        }\n        return entryIndex;\n    };\n    /**\n     * Get the byte-index (into the packed array) corresponding to a given (set tree) value byte of given virtual index.\n     * Inserts new set tree nodes as needed if indicated.\n     *\n     * @param setNumber      The set tree number (0-7, 0 corresponding with the LSByte set tree)\n     * @param virtualIndex   The virtual index into the PackedArray\n     * @param insertAsNeeded If true, will insert new set tree nodes as needed if they do not already exist\n     * @return the byte-index corresponding to the given (set tree) value byte of the given virtual index\n     */\n    PackedArrayContext.prototype.getPackedIndex = function (setNumber, virtualIndex, insertAsNeeded) {\n        if (virtualIndex >= this.virtualLength) {\n            throw new Error(\"Attempting access at index \" + virtualIndex + \", beyond virtualLength \" + this.virtualLength);\n        }\n        var entryPointerIndex = SET_0_START_INDEX + setNumber; // TODO init needed ?\n        var entryIndex = this.getRootEntry(setNumber, insertAsNeeded);\n        if (entryIndex == 0) {\n            return -1; // Index does not currently exist in packed array;\n        }\n        // Work down the levels of non-leaf entries:\n        for (var indexShift = this.topLevelShift; indexShift >= LEAF_LEVEL_SHIFT; indexShift -= 4) {\n            var nextLevelIsLeaf = indexShift === LEAF_LEVEL_SHIFT;\n            // Target is a packedSlotIndicators entry\n            var packedSlotIndicators = this.getPackedSlotIndicators(entryIndex);\n            var slotBitNumber = (virtualIndex / pow(2, indexShift)) & 0xf; //(virtualIndex >>> indexShift) & 0xf;\n            var slotMask = 1 << slotBitNumber;\n            var slotsBelowBitNumber = packedSlotIndicators & (slotMask - 1);\n            var slotNumber = bitCount(slotsBelowBitNumber);\n            if ((packedSlotIndicators & slotMask) === 0) {\n                // The entryIndex slot does not have the contents we want\n                if (!insertAsNeeded) {\n                    return -1; // Index does not currently exist in packed array;\n                }\n                // Expand the entry, adding the index to new entry at the proper slot:\n                entryIndex = this.expandEntry(entryIndex, entryPointerIndex, slotNumber, slotMask, nextLevelIsLeaf);\n            }\n            // Next level's entry pointer index is in the appropriate slot in in the entries array in this entry:\n            entryPointerIndex =\n                entryIndex + NON_LEAF_ENTRY_HEADER_SIZE_IN_SHORTS + slotNumber;\n            entryIndex = this.getIndexAtShortIndex(entryPointerIndex);\n        }\n        // entryIndex is the long-index of a leaf entry that contains the value byte for the given set\n        var byteIndex = (entryIndex << 3) + (virtualIndex & 0x7); // Determine byte index offset within leaf entry\n        return byteIndex;\n    };\n    PackedArrayContext.prototype.determineTopLevelShiftForVirtualLength = function (virtualLength) {\n        var sizeMagnitude = ceil(log2(virtualLength));\n        var eightsSizeMagnitude = sizeMagnitude - 3;\n        var multipleOfFourSizeMagnitude = ceil(eightsSizeMagnitude / 4) * 4;\n        multipleOfFourSizeMagnitude = max(multipleOfFourSizeMagnitude, 8);\n        var topLevelShiftNeeded = multipleOfFourSizeMagnitude - 4 + 3;\n        return topLevelShiftNeeded;\n    };\n    PackedArrayContext.prototype.setVirtualLength = function (virtualLength) {\n        if (!this.isPacked) {\n            throw new Error(\"Should never be adjusting the virtual size of a non-packed context\");\n        }\n        this.topLevelShift = this.determineTopLevelShiftForVirtualLength(virtualLength);\n        this.virtualLength = virtualLength;\n    };\n    PackedArrayContext.prototype.getTopLevelShift = function () {\n        return this.topLevelShift;\n    };\n    //\n    //  ##     ##         ########   #######  ########  ##     ## ##          ###    ######## ########\n    //   ##   ##          ##     ## ##     ## ##     ## ##     ## ##         ## ##      ##    ##\n    //    ## ##           ##     ## ##     ## ##     ## ##     ## ##        ##   ##     ##    ##\n    //     ###    ####### ########  ##     ## ########  ##     ## ##       ##     ##    ##    ######\n    //    ## ##           ##        ##     ## ##        ##     ## ##       #########    ##    ##\n    //   ##   ##          ##        ##     ## ##        ##     ## ##       ##     ##    ##    ##\n    //  ##     ##         ##         #######  ##         #######  ######## ##     ##    ##    ########\n    //\n    PackedArrayContext.prototype.resizeArray = function (newLength) {\n        var tmp = new Uint8Array(newLength * 8);\n        tmp.set(this.byteArray);\n        this.array = tmp.buffer;\n        this.initArrayViews(this.array);\n        this.physicalLength = newLength;\n    };\n    PackedArrayContext.prototype.populateEquivalentEntriesWithEntriesFromOther = function (other) {\n        if (this.virtualLength < other.getVirtualLength()) {\n            throw new Error(\"Cannot populate array of smaller virtual length\");\n        }\n        for (var i = 0; i < NUMBER_OF_SETS; i++) {\n            var otherEntryIndex = other.getAtShortIndex(SET_0_START_INDEX + i);\n            if (otherEntryIndex == 0)\n                continue; // No tree to duplicate\n            var entryIndexPointer = SET_0_START_INDEX + i;\n            for (var i_1 = this.topLevelShift; i_1 > other.topLevelShift; i_1 -= 4) {\n                // for each inserted level:\n                // Allocate entry in other:\n                var sizeOfEntry = NON_LEAF_ENTRY_HEADER_SIZE_IN_SHORTS + 1;\n                var newEntryIndex = this.newEntry(sizeOfEntry);\n                // Link new level in.\n                this.setAtShortIndex(entryIndexPointer, newEntryIndex);\n                // Populate new level entry, use pointer to slot 0 as place to populate under:\n                this.setPackedSlotIndicators(newEntryIndex, 0x1); // Slot 0 populated\n                entryIndexPointer =\n                    newEntryIndex + NON_LEAF_ENTRY_HEADER_SIZE_IN_SHORTS; // Where the slot 0 index goes.\n            }\n            this.copyEntriesAtLevelFromOther(other, otherEntryIndex, entryIndexPointer, other.topLevelShift);\n        }\n    };\n    PackedArrayContext.prototype.copyEntriesAtLevelFromOther = function (other, otherLevelEntryIndex, levelEntryIndexPointer, otherIndexShift) {\n        var nextLevelIsLeaf = otherIndexShift == LEAF_LEVEL_SHIFT;\n        var packedSlotIndicators = other.getPackedSlotIndicators(otherLevelEntryIndex);\n        var numberOfSlots = bitCount(packedSlotIndicators);\n        var sizeOfEntry = NON_LEAF_ENTRY_HEADER_SIZE_IN_SHORTS + numberOfSlots;\n        var entryIndex = this.newEntry(sizeOfEntry);\n        this.setAtShortIndex(levelEntryIndexPointer, entryIndex);\n        this.setAtShortIndex(entryIndex + NON_LEAF_ENTRY_SLOT_INDICATORS_OFFSET, packedSlotIndicators);\n        for (var i = 0; i < numberOfSlots; i++) {\n            if (nextLevelIsLeaf) {\n                // Make leaf in other:\n                var leafEntryIndex = this.newLeafEntry();\n                this.setIndexAtEntrySlot(entryIndex, i, leafEntryIndex);\n                // OPTIM\n                // avoid iteration on all the values of the source ctx\n                var otherNextLevelEntryIndex = other.getIndexAtEntrySlot(otherLevelEntryIndex, i);\n                this.longArray[leafEntryIndex] =\n                    other.longArray[otherNextLevelEntryIndex];\n            }\n            else {\n                var otherNextLevelEntryIndex = other.getIndexAtEntrySlot(otherLevelEntryIndex, i);\n                this.copyEntriesAtLevelFromOther(other, otherNextLevelEntryIndex, entryIndex + NON_LEAF_ENTRY_HEADER_SIZE_IN_SHORTS + i, otherIndexShift - 4);\n            }\n        }\n    };\n    PackedArrayContext.prototype.getAtUnpackedIndex = function (index) {\n        return this.longArray[index];\n    };\n    PackedArrayContext.prototype.setAtUnpackedIndex = function (index, newValue) {\n        this.longArray[index] = newValue;\n    };\n    PackedArrayContext.prototype.lazysetAtUnpackedIndex = function (index, newValue) {\n        this.longArray[index] = newValue;\n    };\n    PackedArrayContext.prototype.incrementAndGetAtUnpackedIndex = function (index) {\n        this.longArray[index]++;\n        return this.longArray[index];\n    };\n    PackedArrayContext.prototype.addAndGetAtUnpackedIndex = function (index, valueToAdd) {\n        this.longArray[index] += valueToAdd;\n        return this.longArray[index];\n    };\n    //\n    //   ########  #######           ######  ######## ########  #### ##    ##  ######\n    //      ##    ##     ##         ##    ##    ##    ##     ##  ##  ###   ## ##    ##\n    //      ##    ##     ##         ##          ##    ##     ##  ##  ####  ## ##\n    //      ##    ##     ## #######  ######     ##    ########   ##  ## ## ## ##   ####\n    //      ##    ##     ##               ##    ##    ##   ##    ##  ##  #### ##    ##\n    //      ##    ##     ##         ##    ##    ##    ##    ##   ##  ##   ### ##    ##\n    //      ##     #######           ######     ##    ##     ## #### ##    ##  ######\n    //\n    PackedArrayContext.prototype.nonLeafEntryToString = function (entryIndex, indexShift, indentLevel) {\n        var output = \"\";\n        for (var i = 0; i < indentLevel; i++) {\n            output += \"  \";\n        }\n        try {\n            var packedSlotIndicators = this.getPackedSlotIndicators(entryIndex);\n            output += \"slotIndiators: 0x\" + toHex(packedSlotIndicators) + \", prevVersionIndex: 0: [ \";\n            var numberOfslotsInEntry = bitCount(packedSlotIndicators);\n            for (var i = 0; i < numberOfslotsInEntry; i++) {\n                output += this.getIndexAtEntrySlot(entryIndex, i);\n                if (i < numberOfslotsInEntry - 1) {\n                    output += \", \";\n                }\n            }\n            output += \" ] (indexShift = \" + indexShift + \")\\n\";\n            var nextLevelIsLeaf = indexShift == LEAF_LEVEL_SHIFT;\n            for (var i = 0; i < numberOfslotsInEntry; i++) {\n                var nextLevelEntryIndex = this.getIndexAtEntrySlot(entryIndex, i);\n                if (nextLevelIsLeaf) {\n                    output += this.leafEntryToString(nextLevelEntryIndex, indentLevel + 4);\n                }\n                else {\n                    output += this.nonLeafEntryToString(nextLevelEntryIndex, indexShift - 4, indentLevel + 4);\n                }\n            }\n        }\n        catch (ex) {\n            output += \"Exception thrown at nonLeafEnty at index \" + entryIndex + \" with indexShift \" + indexShift + \"\\n\";\n        }\n        return output;\n    };\n    PackedArrayContext.prototype.leafEntryToString = function (entryIndex, indentLevel) {\n        var output = \"\";\n        for (var i = 0; i < indentLevel; i++) {\n            output += \"  \";\n        }\n        try {\n            output += \"Leaf bytes : \";\n            for (var i = 0; i < 8; i++) {\n                output += \"0x\" + toHex(this.byteArray[entryIndex * 8 + i]) + \" \";\n            }\n            output += \"\\n\";\n        }\n        catch (ex) {\n            output += \"Exception thrown at leafEnty at index \" + entryIndex + \"\\n\";\n        }\n        return output;\n    };\n    PackedArrayContext.prototype.toString = function () {\n        var output = \"PackedArrayContext:\\n\";\n        if (!this.isPacked) {\n            return output + \"Context is unpacked:\\n\"; // unpackedToString();\n        }\n        for (var setNumber = 0; setNumber < NUMBER_OF_SETS; setNumber++) {\n            try {\n                var entryPointerIndex = SET_0_START_INDEX + setNumber;\n                var entryIndex = this.getIndexAtShortIndex(entryPointerIndex);\n                output += \"Set \" + setNumber + \": root = \" + entryIndex + \" \\n\";\n                if (entryIndex == 0)\n                    continue;\n                output += this.nonLeafEntryToString(entryIndex, this.topLevelShift, 4);\n            }\n            catch (ex) {\n                output += \"Exception thrown in set \" + setNumber + \"%d\\n\";\n            }\n        }\n        //output += recordedValuesToString();\n        return output;\n    };\n    return PackedArrayContext;\n}());\nexports.PackedArrayContext = PackedArrayContext;\nvar toHex = function (n) {\n    return Number(n)\n        .toString(16)\n        .padStart(2, \"0\");\n};\n//# sourceMappingURL=PackedArrayContext.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * This is a TypeScript port of the original Java version, which was written by\n * Gil Tene as described in\n * https://github.com/HdrHistogram/HdrHistogram\n * and released to the public domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\nvar ResizeError = /** @class */ (function () {\n    function ResizeError(newSize) {\n        this.newSize = newSize;\n    }\n    return ResizeError;\n}());\nexports.ResizeError = ResizeError;\n//# sourceMappingURL=ResizeError.js.map","\"use strict\";\n/*\n * This is a TypeScript port of the original Java version, which was written by\n * Gil Tene as described in\n * https://github.com/HdrHistogram/HdrHistogram\n * and released to the public domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ulp = function (x) { return Math.pow(2, Math.floor(Math.log2(x)) - 52); };\nexports.default = ulp;\n//# sourceMappingURL=ulp.js.map","'use strict'\n\nmodule.exports = parseJson\nfunction parseJson (txt, reviver, context) {\n  context = context || 20\n  try {\n    return JSON.parse(txt, reviver)\n  } catch (e) {\n    if (typeof txt !== 'string') {\n      const isEmptyArray = Array.isArray(txt) && txt.length === 0\n      const errorMessage = 'Cannot parse ' +\n      (isEmptyArray ? 'an empty array' : String(txt))\n      throw new TypeError(errorMessage)\n    }\n    const syntaxErr = e.message.match(/^Unexpected token.*position\\s+(\\d+)/i)\n    const errIdx = syntaxErr\n    ? +syntaxErr[1]\n    : e.message.match(/^Unexpected end of JSON.*/i)\n    ? txt.length - 1\n    : null\n    if (errIdx != null) {\n      const start = errIdx <= context\n      ? 0\n      : errIdx - context\n      const end = errIdx + context >= txt.length\n      ? txt.length\n      : errIdx + context\n      e.message += ` while parsing near '${\n        start === 0 ? '' : '...'\n      }${txt.slice(start, end)}${\n        end === txt.length ? '' : '...'\n      }'`\n    } else {\n      e.message += ` while parsing '${txt.slice(0, context * 2)}'`\n    }\n    throw e\n  }\n}\n","'use strict';\nconst path = require('path');\nconst fs = require('graceful-fs');\nconst stripBom = require('strip-bom');\nconst parseJson = require('parse-json');\nconst pify = require('pify');\n\nconst parse = (data, fp) => parseJson(stripBom(data), path.relative('.', fp));\n\nmodule.exports = fp => pify(fs.readFile)(fp, 'utf8').then(data => parse(data, fp));\nmodule.exports.sync = fp => parse(fs.readFileSync(fp, 'utf8'), fp);\n","'use strict';\nconst errorEx = require('error-ex');\nconst fallback = require('json-parse-better-errors');\n\nconst JSONError = errorEx('JSONError', {\n\tfileName: errorEx.append('in %s')\n});\n\nmodule.exports = (input, reviver, filename) => {\n\tif (typeof reviver === 'string') {\n\t\tfilename = reviver;\n\t\treviver = null;\n\t}\n\n\ttry {\n\t\ttry {\n\t\t\treturn JSON.parse(input, reviver);\n\t\t} catch (err) {\n\t\t\tfallback(input, reviver);\n\n\t\t\tthrow err;\n\t\t}\n\t} catch (err) {\n\t\terr.message = err.message.replace(/\\n/g, '');\n\n\t\tconst jsonErr = new JSONError(err);\n\t\tif (filename) {\n\t\t\tjsonErr.fileName = filename;\n\t\t}\n\n\t\tthrow jsonErr;\n\t}\n};\n","'use strict';\n\nconst processFn = (fn, opts) => function () {\n\tconst P = opts.promiseModule;\n\tconst args = new Array(arguments.length);\n\n\tfor (let i = 0; i < arguments.length; i++) {\n\t\targs[i] = arguments[i];\n\t}\n\n\treturn new P((resolve, reject) => {\n\t\tif (opts.errorFirst) {\n\t\t\targs.push(function (err, result) {\n\t\t\t\tif (opts.multiArgs) {\n\t\t\t\t\tconst results = new Array(arguments.length - 1);\n\n\t\t\t\t\tfor (let i = 1; i < arguments.length; i++) {\n\t\t\t\t\t\tresults[i - 1] = arguments[i];\n\t\t\t\t\t}\n\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\tresults.unshift(err);\n\t\t\t\t\t\treject(results);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresolve(results);\n\t\t\t\t\t}\n\t\t\t\t} else if (err) {\n\t\t\t\t\treject(err);\n\t\t\t\t} else {\n\t\t\t\t\tresolve(result);\n\t\t\t\t}\n\t\t\t});\n\t\t} else {\n\t\t\targs.push(function (result) {\n\t\t\t\tif (opts.multiArgs) {\n\t\t\t\t\tconst results = new Array(arguments.length - 1);\n\n\t\t\t\t\tfor (let i = 0; i < arguments.length; i++) {\n\t\t\t\t\t\tresults[i] = arguments[i];\n\t\t\t\t\t}\n\n\t\t\t\t\tresolve(results);\n\t\t\t\t} else {\n\t\t\t\t\tresolve(result);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tfn.apply(this, args);\n\t});\n};\n\nmodule.exports = (obj, opts) => {\n\topts = Object.assign({\n\t\texclude: [/.+(Sync|Stream)$/],\n\t\terrorFirst: true,\n\t\tpromiseModule: Promise\n\t}, opts);\n\n\tconst filter = key => {\n\t\tconst match = pattern => typeof pattern === 'string' ? key === pattern : pattern.test(key);\n\t\treturn opts.include ? opts.include.some(match) : !opts.exclude.some(match);\n\t};\n\n\tlet ret;\n\tif (typeof obj === 'function') {\n\t\tret = function () {\n\t\t\tif (opts.excludeMain) {\n\t\t\t\treturn obj.apply(this, arguments);\n\t\t\t}\n\n\t\t\treturn processFn(obj, opts).apply(this, arguments);\n\t\t};\n\t} else {\n\t\tret = Object.create(Object.getPrototypeOf(obj));\n\t}\n\n\tfor (const key in obj) { // eslint-disable-line guard-for-in\n\t\tconst x = obj[key];\n\t\tret[key] = typeof x === 'function' && filter(key) ? processFn(x, opts) : x;\n\t}\n\n\treturn ret;\n};\n","'use strict';\nmodule.exports = x => {\n\tif (typeof x !== 'string') {\n\t\tthrow new TypeError('Expected a string, got ' + typeof x);\n\t}\n\n\t// Catches EFBBBF (UTF-8 BOM) because the buffer-to-string\n\t// conversion translates it to FEFF (UTF-16 BOM)\n\tif (x.charCodeAt(0) === 0xFEFF) {\n\t\treturn x.slice(1);\n\t}\n\n\treturn x;\n};\n","'use strict';\n\n\nvar zlib_deflate = require('./zlib/deflate');\nvar utils        = require('./utils/common');\nvar strings      = require('./utils/strings');\nvar msg          = require('./zlib/messages');\nvar ZStream      = require('./zlib/zstream');\n\nvar toString = Object.prototype.toString;\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\nvar Z_NO_FLUSH      = 0;\nvar Z_FINISH        = 4;\n\nvar Z_OK            = 0;\nvar Z_STREAM_END    = 1;\nvar Z_SYNC_FLUSH    = 2;\n\nvar Z_DEFAULT_COMPRESSION = -1;\n\nvar Z_DEFAULT_STRATEGY    = 0;\n\nvar Z_DEFLATED  = 8;\n\n/* ===========================================================================*/\n\n\n/**\n * class Deflate\n *\n * Generic JS-style wrapper for zlib calls. If you don't need\n * streaming behaviour - use more simple functions: [[deflate]],\n * [[deflateRaw]] and [[gzip]].\n **/\n\n/* internal\n * Deflate.chunks -> Array\n *\n * Chunks of output data, if [[Deflate#onData]] not overridden.\n **/\n\n/**\n * Deflate.result -> Uint8Array|Array\n *\n * Compressed result, generated by default [[Deflate#onData]]\n * and [[Deflate#onEnd]] handlers. Filled after you push last chunk\n * (call [[Deflate#push]] with `Z_FINISH` / `true` param)  or if you\n * push a chunk with explicit flush (call [[Deflate#push]] with\n * `Z_SYNC_FLUSH` param).\n **/\n\n/**\n * Deflate.err -> Number\n *\n * Error code after deflate finished. 0 (Z_OK) on success.\n * You will not need it in real life, because deflate errors\n * are possible only on wrong options or bad `onData` / `onEnd`\n * custom handlers.\n **/\n\n/**\n * Deflate.msg -> String\n *\n * Error message, if [[Deflate.err]] != 0\n **/\n\n\n/**\n * new Deflate(options)\n * - options (Object): zlib deflate options.\n *\n * Creates new deflator instance with specified params. Throws exception\n * on bad params. Supported options:\n *\n * - `level`\n * - `windowBits`\n * - `memLevel`\n * - `strategy`\n * - `dictionary`\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information on these.\n *\n * Additional options, for internal needs:\n *\n * - `chunkSize` - size of generated data chunks (16K by default)\n * - `raw` (Boolean) - do raw deflate\n * - `gzip` (Boolean) - create gzip wrapper\n * - `to` (String) - if equal to 'string', then result will be \"binary string\"\n *    (each char code [0..255])\n * - `header` (Object) - custom header for gzip\n *   - `text` (Boolean) - true if compressed data believed to be text\n *   - `time` (Number) - modification time, unix timestamp\n *   - `os` (Number) - operation system code\n *   - `extra` (Array) - array of bytes with extra data (max 65536)\n *   - `name` (String) - file name (binary string)\n *   - `comment` (String) - comment (binary string)\n *   - `hcrc` (Boolean) - true if header crc should be added\n *\n * ##### Example:\n *\n * ```javascript\n * var pako = require('pako')\n *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])\n *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);\n *\n * var deflate = new pako.Deflate({ level: 3});\n *\n * deflate.push(chunk1, false);\n * deflate.push(chunk2, true);  // true -> last chunk\n *\n * if (deflate.err) { throw new Error(deflate.err); }\n *\n * console.log(deflate.result);\n * ```\n **/\nfunction Deflate(options) {\n  if (!(this instanceof Deflate)) return new Deflate(options);\n\n  this.options = utils.assign({\n    level: Z_DEFAULT_COMPRESSION,\n    method: Z_DEFLATED,\n    chunkSize: 16384,\n    windowBits: 15,\n    memLevel: 8,\n    strategy: Z_DEFAULT_STRATEGY,\n    to: ''\n  }, options || {});\n\n  var opt = this.options;\n\n  if (opt.raw && (opt.windowBits > 0)) {\n    opt.windowBits = -opt.windowBits;\n  }\n\n  else if (opt.gzip && (opt.windowBits > 0) && (opt.windowBits < 16)) {\n    opt.windowBits += 16;\n  }\n\n  this.err    = 0;      // error code, if happens (0 = Z_OK)\n  this.msg    = '';     // error message\n  this.ended  = false;  // used to avoid multiple onEnd() calls\n  this.chunks = [];     // chunks of compressed data\n\n  this.strm = new ZStream();\n  this.strm.avail_out = 0;\n\n  var status = zlib_deflate.deflateInit2(\n    this.strm,\n    opt.level,\n    opt.method,\n    opt.windowBits,\n    opt.memLevel,\n    opt.strategy\n  );\n\n  if (status !== Z_OK) {\n    throw new Error(msg[status]);\n  }\n\n  if (opt.header) {\n    zlib_deflate.deflateSetHeader(this.strm, opt.header);\n  }\n\n  if (opt.dictionary) {\n    var dict;\n    // Convert data if needed\n    if (typeof opt.dictionary === 'string') {\n      // If we need to compress text, change encoding to utf8.\n      dict = strings.string2buf(opt.dictionary);\n    } else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {\n      dict = new Uint8Array(opt.dictionary);\n    } else {\n      dict = opt.dictionary;\n    }\n\n    status = zlib_deflate.deflateSetDictionary(this.strm, dict);\n\n    if (status !== Z_OK) {\n      throw new Error(msg[status]);\n    }\n\n    this._dict_set = true;\n  }\n}\n\n/**\n * Deflate#push(data[, mode]) -> Boolean\n * - data (Uint8Array|Array|ArrayBuffer|String): input data. Strings will be\n *   converted to utf8 byte sequence.\n * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.\n *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.\n *\n * Sends input data to deflate pipe, generating [[Deflate#onData]] calls with\n * new compressed chunks. Returns `true` on success. The last data block must have\n * mode Z_FINISH (or `true`). That will flush internal pending buffers and call\n * [[Deflate#onEnd]]. For interim explicit flushes (without ending the stream) you\n * can use mode Z_SYNC_FLUSH, keeping the compression context.\n *\n * On fail call [[Deflate#onEnd]] with error code and return false.\n *\n * We strongly recommend to use `Uint8Array` on input for best speed (output\n * array format is detected automatically). Also, don't skip last param and always\n * use the same type in your code (boolean or number). That will improve JS speed.\n *\n * For regular `Array`-s make sure all elements are [0..255].\n *\n * ##### Example\n *\n * ```javascript\n * push(chunk, false); // push one of data chunks\n * ...\n * push(chunk, true);  // push last chunk\n * ```\n **/\nDeflate.prototype.push = function (data, mode) {\n  var strm = this.strm;\n  var chunkSize = this.options.chunkSize;\n  var status, _mode;\n\n  if (this.ended) { return false; }\n\n  _mode = (mode === ~~mode) ? mode : ((mode === true) ? Z_FINISH : Z_NO_FLUSH);\n\n  // Convert data if needed\n  if (typeof data === 'string') {\n    // If we need to compress text, change encoding to utf8.\n    strm.input = strings.string2buf(data);\n  } else if (toString.call(data) === '[object ArrayBuffer]') {\n    strm.input = new Uint8Array(data);\n  } else {\n    strm.input = data;\n  }\n\n  strm.next_in = 0;\n  strm.avail_in = strm.input.length;\n\n  do {\n    if (strm.avail_out === 0) {\n      strm.output = new utils.Buf8(chunkSize);\n      strm.next_out = 0;\n      strm.avail_out = chunkSize;\n    }\n    status = zlib_deflate.deflate(strm, _mode);    /* no bad return value */\n\n    if (status !== Z_STREAM_END && status !== Z_OK) {\n      this.onEnd(status);\n      this.ended = true;\n      return false;\n    }\n    if (strm.avail_out === 0 || (strm.avail_in === 0 && (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH))) {\n      if (this.options.to === 'string') {\n        this.onData(strings.buf2binstring(utils.shrinkBuf(strm.output, strm.next_out)));\n      } else {\n        this.onData(utils.shrinkBuf(strm.output, strm.next_out));\n      }\n    }\n  } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END);\n\n  // Finalize on the last chunk.\n  if (_mode === Z_FINISH) {\n    status = zlib_deflate.deflateEnd(this.strm);\n    this.onEnd(status);\n    this.ended = true;\n    return status === Z_OK;\n  }\n\n  // callback interim results if Z_SYNC_FLUSH.\n  if (_mode === Z_SYNC_FLUSH) {\n    this.onEnd(Z_OK);\n    strm.avail_out = 0;\n    return true;\n  }\n\n  return true;\n};\n\n\n/**\n * Deflate#onData(chunk) -> Void\n * - chunk (Uint8Array|Array|String): output data. Type of array depends\n *   on js engine support. When string output requested, each chunk\n *   will be string.\n *\n * By default, stores data blocks in `chunks[]` property and glue\n * those in `onEnd`. Override this handler, if you need another behaviour.\n **/\nDeflate.prototype.onData = function (chunk) {\n  this.chunks.push(chunk);\n};\n\n\n/**\n * Deflate#onEnd(status) -> Void\n * - status (Number): deflate status. 0 (Z_OK) on success,\n *   other if not.\n *\n * Called once after you tell deflate that the input stream is\n * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)\n * or if an error happened. By default - join collected chunks,\n * free memory and fill `results` / `err` properties.\n **/\nDeflate.prototype.onEnd = function (status) {\n  // On success - join\n  if (status === Z_OK) {\n    if (this.options.to === 'string') {\n      this.result = this.chunks.join('');\n    } else {\n      this.result = utils.flattenChunks(this.chunks);\n    }\n  }\n  this.chunks = [];\n  this.err = status;\n  this.msg = this.strm.msg;\n};\n\n\n/**\n * deflate(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to compress.\n * - options (Object): zlib deflate options.\n *\n * Compress `data` with deflate algorithm and `options`.\n *\n * Supported options are:\n *\n * - level\n * - windowBits\n * - memLevel\n * - strategy\n * - dictionary\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information on these.\n *\n * Sugar (options):\n *\n * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify\n *   negative windowBits implicitly.\n * - `to` (String) - if equal to 'string', then result will be \"binary string\"\n *    (each char code [0..255])\n *\n * ##### Example:\n *\n * ```javascript\n * var pako = require('pako')\n *   , data = Uint8Array([1,2,3,4,5,6,7,8,9]);\n *\n * console.log(pako.deflate(data));\n * ```\n **/\nfunction deflate(input, options) {\n  var deflator = new Deflate(options);\n\n  deflator.push(input, true);\n\n  // That will never happens, if you don't cheat with options :)\n  if (deflator.err) { throw deflator.msg || msg[deflator.err]; }\n\n  return deflator.result;\n}\n\n\n/**\n * deflateRaw(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to compress.\n * - options (Object): zlib deflate options.\n *\n * The same as [[deflate]], but creates raw data, without wrapper\n * (header and adler32 crc).\n **/\nfunction deflateRaw(input, options) {\n  options = options || {};\n  options.raw = true;\n  return deflate(input, options);\n}\n\n\n/**\n * gzip(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to compress.\n * - options (Object): zlib deflate options.\n *\n * The same as [[deflate]], but create gzip wrapper instead of\n * deflate one.\n **/\nfunction gzip(input, options) {\n  options = options || {};\n  options.gzip = true;\n  return deflate(input, options);\n}\n\n\nexports.Deflate = Deflate;\nexports.deflate = deflate;\nexports.deflateRaw = deflateRaw;\nexports.gzip = gzip;\n","'use strict';\n\n\nvar zlib_inflate = require('./zlib/inflate');\nvar utils        = require('./utils/common');\nvar strings      = require('./utils/strings');\nvar c            = require('./zlib/constants');\nvar msg          = require('./zlib/messages');\nvar ZStream      = require('./zlib/zstream');\nvar GZheader     = require('./zlib/gzheader');\n\nvar toString = Object.prototype.toString;\n\n/**\n * class Inflate\n *\n * Generic JS-style wrapper for zlib calls. If you don't need\n * streaming behaviour - use more simple functions: [[inflate]]\n * and [[inflateRaw]].\n **/\n\n/* internal\n * inflate.chunks -> Array\n *\n * Chunks of output data, if [[Inflate#onData]] not overridden.\n **/\n\n/**\n * Inflate.result -> Uint8Array|Array|String\n *\n * Uncompressed result, generated by default [[Inflate#onData]]\n * and [[Inflate#onEnd]] handlers. Filled after you push last chunk\n * (call [[Inflate#push]] with `Z_FINISH` / `true` param) or if you\n * push a chunk with explicit flush (call [[Inflate#push]] with\n * `Z_SYNC_FLUSH` param).\n **/\n\n/**\n * Inflate.err -> Number\n *\n * Error code after inflate finished. 0 (Z_OK) on success.\n * Should be checked if broken data possible.\n **/\n\n/**\n * Inflate.msg -> String\n *\n * Error message, if [[Inflate.err]] != 0\n **/\n\n\n/**\n * new Inflate(options)\n * - options (Object): zlib inflate options.\n *\n * Creates new inflator instance with specified params. Throws exception\n * on bad params. Supported options:\n *\n * - `windowBits`\n * - `dictionary`\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information on these.\n *\n * Additional options, for internal needs:\n *\n * - `chunkSize` - size of generated data chunks (16K by default)\n * - `raw` (Boolean) - do raw inflate\n * - `to` (String) - if equal to 'string', then result will be converted\n *   from utf8 to utf16 (javascript) string. When string output requested,\n *   chunk length can differ from `chunkSize`, depending on content.\n *\n * By default, when no options set, autodetect deflate/gzip data format via\n * wrapper header.\n *\n * ##### Example:\n *\n * ```javascript\n * var pako = require('pako')\n *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])\n *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);\n *\n * var inflate = new pako.Inflate({ level: 3});\n *\n * inflate.push(chunk1, false);\n * inflate.push(chunk2, true);  // true -> last chunk\n *\n * if (inflate.err) { throw new Error(inflate.err); }\n *\n * console.log(inflate.result);\n * ```\n **/\nfunction Inflate(options) {\n  if (!(this instanceof Inflate)) return new Inflate(options);\n\n  this.options = utils.assign({\n    chunkSize: 16384,\n    windowBits: 0,\n    to: ''\n  }, options || {});\n\n  var opt = this.options;\n\n  // Force window size for `raw` data, if not set directly,\n  // because we have no header for autodetect.\n  if (opt.raw && (opt.windowBits >= 0) && (opt.windowBits < 16)) {\n    opt.windowBits = -opt.windowBits;\n    if (opt.windowBits === 0) { opt.windowBits = -15; }\n  }\n\n  // If `windowBits` not defined (and mode not raw) - set autodetect flag for gzip/deflate\n  if ((opt.windowBits >= 0) && (opt.windowBits < 16) &&\n      !(options && options.windowBits)) {\n    opt.windowBits += 32;\n  }\n\n  // Gzip header has no info about windows size, we can do autodetect only\n  // for deflate. So, if window size not set, force it to max when gzip possible\n  if ((opt.windowBits > 15) && (opt.windowBits < 48)) {\n    // bit 3 (16) -> gzipped data\n    // bit 4 (32) -> autodetect gzip/deflate\n    if ((opt.windowBits & 15) === 0) {\n      opt.windowBits |= 15;\n    }\n  }\n\n  this.err    = 0;      // error code, if happens (0 = Z_OK)\n  this.msg    = '';     // error message\n  this.ended  = false;  // used to avoid multiple onEnd() calls\n  this.chunks = [];     // chunks of compressed data\n\n  this.strm   = new ZStream();\n  this.strm.avail_out = 0;\n\n  var status  = zlib_inflate.inflateInit2(\n    this.strm,\n    opt.windowBits\n  );\n\n  if (status !== c.Z_OK) {\n    throw new Error(msg[status]);\n  }\n\n  this.header = new GZheader();\n\n  zlib_inflate.inflateGetHeader(this.strm, this.header);\n\n  // Setup dictionary\n  if (opt.dictionary) {\n    // Convert data if needed\n    if (typeof opt.dictionary === 'string') {\n      opt.dictionary = strings.string2buf(opt.dictionary);\n    } else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {\n      opt.dictionary = new Uint8Array(opt.dictionary);\n    }\n    if (opt.raw) { //In raw mode we need to set the dictionary early\n      status = zlib_inflate.inflateSetDictionary(this.strm, opt.dictionary);\n      if (status !== c.Z_OK) {\n        throw new Error(msg[status]);\n      }\n    }\n  }\n}\n\n/**\n * Inflate#push(data[, mode]) -> Boolean\n * - data (Uint8Array|Array|ArrayBuffer|String): input data\n * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.\n *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.\n *\n * Sends input data to inflate pipe, generating [[Inflate#onData]] calls with\n * new output chunks. Returns `true` on success. The last data block must have\n * mode Z_FINISH (or `true`). That will flush internal pending buffers and call\n * [[Inflate#onEnd]]. For interim explicit flushes (without ending the stream) you\n * can use mode Z_SYNC_FLUSH, keeping the decompression context.\n *\n * On fail call [[Inflate#onEnd]] with error code and return false.\n *\n * We strongly recommend to use `Uint8Array` on input for best speed (output\n * format is detected automatically). Also, don't skip last param and always\n * use the same type in your code (boolean or number). That will improve JS speed.\n *\n * For regular `Array`-s make sure all elements are [0..255].\n *\n * ##### Example\n *\n * ```javascript\n * push(chunk, false); // push one of data chunks\n * ...\n * push(chunk, true);  // push last chunk\n * ```\n **/\nInflate.prototype.push = function (data, mode) {\n  var strm = this.strm;\n  var chunkSize = this.options.chunkSize;\n  var dictionary = this.options.dictionary;\n  var status, _mode;\n  var next_out_utf8, tail, utf8str;\n\n  // Flag to properly process Z_BUF_ERROR on testing inflate call\n  // when we check that all output data was flushed.\n  var allowBufError = false;\n\n  if (this.ended) { return false; }\n  _mode = (mode === ~~mode) ? mode : ((mode === true) ? c.Z_FINISH : c.Z_NO_FLUSH);\n\n  // Convert data if needed\n  if (typeof data === 'string') {\n    // Only binary strings can be decompressed on practice\n    strm.input = strings.binstring2buf(data);\n  } else if (toString.call(data) === '[object ArrayBuffer]') {\n    strm.input = new Uint8Array(data);\n  } else {\n    strm.input = data;\n  }\n\n  strm.next_in = 0;\n  strm.avail_in = strm.input.length;\n\n  do {\n    if (strm.avail_out === 0) {\n      strm.output = new utils.Buf8(chunkSize);\n      strm.next_out = 0;\n      strm.avail_out = chunkSize;\n    }\n\n    status = zlib_inflate.inflate(strm, c.Z_NO_FLUSH);    /* no bad return value */\n\n    if (status === c.Z_NEED_DICT && dictionary) {\n      status = zlib_inflate.inflateSetDictionary(this.strm, dictionary);\n    }\n\n    if (status === c.Z_BUF_ERROR && allowBufError === true) {\n      status = c.Z_OK;\n      allowBufError = false;\n    }\n\n    if (status !== c.Z_STREAM_END && status !== c.Z_OK) {\n      this.onEnd(status);\n      this.ended = true;\n      return false;\n    }\n\n    if (strm.next_out) {\n      if (strm.avail_out === 0 || status === c.Z_STREAM_END || (strm.avail_in === 0 && (_mode === c.Z_FINISH || _mode === c.Z_SYNC_FLUSH))) {\n\n        if (this.options.to === 'string') {\n\n          next_out_utf8 = strings.utf8border(strm.output, strm.next_out);\n\n          tail = strm.next_out - next_out_utf8;\n          utf8str = strings.buf2string(strm.output, next_out_utf8);\n\n          // move tail\n          strm.next_out = tail;\n          strm.avail_out = chunkSize - tail;\n          if (tail) { utils.arraySet(strm.output, strm.output, next_out_utf8, tail, 0); }\n\n          this.onData(utf8str);\n\n        } else {\n          this.onData(utils.shrinkBuf(strm.output, strm.next_out));\n        }\n      }\n    }\n\n    // When no more input data, we should check that internal inflate buffers\n    // are flushed. The only way to do it when avail_out = 0 - run one more\n    // inflate pass. But if output data not exists, inflate return Z_BUF_ERROR.\n    // Here we set flag to process this error properly.\n    //\n    // NOTE. Deflate does not return error in this case and does not needs such\n    // logic.\n    if (strm.avail_in === 0 && strm.avail_out === 0) {\n      allowBufError = true;\n    }\n\n  } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== c.Z_STREAM_END);\n\n  if (status === c.Z_STREAM_END) {\n    _mode = c.Z_FINISH;\n  }\n\n  // Finalize on the last chunk.\n  if (_mode === c.Z_FINISH) {\n    status = zlib_inflate.inflateEnd(this.strm);\n    this.onEnd(status);\n    this.ended = true;\n    return status === c.Z_OK;\n  }\n\n  // callback interim results if Z_SYNC_FLUSH.\n  if (_mode === c.Z_SYNC_FLUSH) {\n    this.onEnd(c.Z_OK);\n    strm.avail_out = 0;\n    return true;\n  }\n\n  return true;\n};\n\n\n/**\n * Inflate#onData(chunk) -> Void\n * - chunk (Uint8Array|Array|String): output data. Type of array depends\n *   on js engine support. When string output requested, each chunk\n *   will be string.\n *\n * By default, stores data blocks in `chunks[]` property and glue\n * those in `onEnd`. Override this handler, if you need another behaviour.\n **/\nInflate.prototype.onData = function (chunk) {\n  this.chunks.push(chunk);\n};\n\n\n/**\n * Inflate#onEnd(status) -> Void\n * - status (Number): inflate status. 0 (Z_OK) on success,\n *   other if not.\n *\n * Called either after you tell inflate that the input stream is\n * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)\n * or if an error happened. By default - join collected chunks,\n * free memory and fill `results` / `err` properties.\n **/\nInflate.prototype.onEnd = function (status) {\n  // On success - join\n  if (status === c.Z_OK) {\n    if (this.options.to === 'string') {\n      // Glue & convert here, until we teach pako to send\n      // utf8 aligned strings to onData\n      this.result = this.chunks.join('');\n    } else {\n      this.result = utils.flattenChunks(this.chunks);\n    }\n  }\n  this.chunks = [];\n  this.err = status;\n  this.msg = this.strm.msg;\n};\n\n\n/**\n * inflate(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to decompress.\n * - options (Object): zlib inflate options.\n *\n * Decompress `data` with inflate/ungzip and `options`. Autodetect\n * format via wrapper header by default. That's why we don't provide\n * separate `ungzip` method.\n *\n * Supported options are:\n *\n * - windowBits\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information.\n *\n * Sugar (options):\n *\n * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify\n *   negative windowBits implicitly.\n * - `to` (String) - if equal to 'string', then result will be converted\n *   from utf8 to utf16 (javascript) string. When string output requested,\n *   chunk length can differ from `chunkSize`, depending on content.\n *\n *\n * ##### Example:\n *\n * ```javascript\n * var pako = require('pako')\n *   , input = pako.deflate([1,2,3,4,5,6,7,8,9])\n *   , output;\n *\n * try {\n *   output = pako.inflate(input);\n * } catch (err)\n *   console.log(err);\n * }\n * ```\n **/\nfunction inflate(input, options) {\n  var inflator = new Inflate(options);\n\n  inflator.push(input, true);\n\n  // That will never happens, if you don't cheat with options :)\n  if (inflator.err) { throw inflator.msg || msg[inflator.err]; }\n\n  return inflator.result;\n}\n\n\n/**\n * inflateRaw(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to decompress.\n * - options (Object): zlib inflate options.\n *\n * The same as [[inflate]], but creates raw data, without wrapper\n * (header and adler32 crc).\n **/\nfunction inflateRaw(input, options) {\n  options = options || {};\n  options.raw = true;\n  return inflate(input, options);\n}\n\n\n/**\n * ungzip(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to decompress.\n * - options (Object): zlib inflate options.\n *\n * Just shortcut to [[inflate]], because it autodetects format\n * by header.content. Done for convenience.\n **/\n\n\nexports.Inflate = Inflate;\nexports.inflate = inflate;\nexports.inflateRaw = inflateRaw;\nexports.ungzip  = inflate;\n","'use strict';\n\n\nvar TYPED_OK =  (typeof Uint8Array !== 'undefined') &&\n                (typeof Uint16Array !== 'undefined') &&\n                (typeof Int32Array !== 'undefined');\n\nfunction _has(obj, key) {\n  return Object.prototype.hasOwnProperty.call(obj, key);\n}\n\nexports.assign = function (obj /*from1, from2, from3, ...*/) {\n  var sources = Array.prototype.slice.call(arguments, 1);\n  while (sources.length) {\n    var source = sources.shift();\n    if (!source) { continue; }\n\n    if (typeof source !== 'object') {\n      throw new TypeError(source + 'must be non-object');\n    }\n\n    for (var p in source) {\n      if (_has(source, p)) {\n        obj[p] = source[p];\n      }\n    }\n  }\n\n  return obj;\n};\n\n\n// reduce buffer size, avoiding mem copy\nexports.shrinkBuf = function (buf, size) {\n  if (buf.length === size) { return buf; }\n  if (buf.subarray) { return buf.subarray(0, size); }\n  buf.length = size;\n  return buf;\n};\n\n\nvar fnTyped = {\n  arraySet: function (dest, src, src_offs, len, dest_offs) {\n    if (src.subarray && dest.subarray) {\n      dest.set(src.subarray(src_offs, src_offs + len), dest_offs);\n      return;\n    }\n    // Fallback to ordinary array\n    for (var i = 0; i < len; i++) {\n      dest[dest_offs + i] = src[src_offs + i];\n    }\n  },\n  // Join array of chunks to single array.\n  flattenChunks: function (chunks) {\n    var i, l, len, pos, chunk, result;\n\n    // calculate data length\n    len = 0;\n    for (i = 0, l = chunks.length; i < l; i++) {\n      len += chunks[i].length;\n    }\n\n    // join chunks\n    result = new Uint8Array(len);\n    pos = 0;\n    for (i = 0, l = chunks.length; i < l; i++) {\n      chunk = chunks[i];\n      result.set(chunk, pos);\n      pos += chunk.length;\n    }\n\n    return result;\n  }\n};\n\nvar fnUntyped = {\n  arraySet: function (dest, src, src_offs, len, dest_offs) {\n    for (var i = 0; i < len; i++) {\n      dest[dest_offs + i] = src[src_offs + i];\n    }\n  },\n  // Join array of chunks to single array.\n  flattenChunks: function (chunks) {\n    return [].concat.apply([], chunks);\n  }\n};\n\n\n// Enable/Disable typed arrays use, for testing\n//\nexports.setTyped = function (on) {\n  if (on) {\n    exports.Buf8  = Uint8Array;\n    exports.Buf16 = Uint16Array;\n    exports.Buf32 = Int32Array;\n    exports.assign(exports, fnTyped);\n  } else {\n    exports.Buf8  = Array;\n    exports.Buf16 = Array;\n    exports.Buf32 = Array;\n    exports.assign(exports, fnUntyped);\n  }\n};\n\nexports.setTyped(TYPED_OK);\n","// String encode/decode helpers\n'use strict';\n\n\nvar utils = require('./common');\n\n\n// Quick check if we can use fast array to bin string conversion\n//\n// - apply(Array) can fail on Android 2.2\n// - apply(Uint8Array) can fail on iOS 5.1 Safari\n//\nvar STR_APPLY_OK = true;\nvar STR_APPLY_UIA_OK = true;\n\ntry { String.fromCharCode.apply(null, [ 0 ]); } catch (__) { STR_APPLY_OK = false; }\ntry { String.fromCharCode.apply(null, new Uint8Array(1)); } catch (__) { STR_APPLY_UIA_OK = false; }\n\n\n// Table with utf8 lengths (calculated by first byte of sequence)\n// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,\n// because max possible codepoint is 0x10ffff\nvar _utf8len = new utils.Buf8(256);\nfor (var q = 0; q < 256; q++) {\n  _utf8len[q] = (q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1);\n}\n_utf8len[254] = _utf8len[254] = 1; // Invalid sequence start\n\n\n// convert string to array (typed, when possible)\nexports.string2buf = function (str) {\n  var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;\n\n  // count binary size\n  for (m_pos = 0; m_pos < str_len; m_pos++) {\n    c = str.charCodeAt(m_pos);\n    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {\n      c2 = str.charCodeAt(m_pos + 1);\n      if ((c2 & 0xfc00) === 0xdc00) {\n        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);\n        m_pos++;\n      }\n    }\n    buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;\n  }\n\n  // allocate buffer\n  buf = new utils.Buf8(buf_len);\n\n  // convert\n  for (i = 0, m_pos = 0; i < buf_len; m_pos++) {\n    c = str.charCodeAt(m_pos);\n    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {\n      c2 = str.charCodeAt(m_pos + 1);\n      if ((c2 & 0xfc00) === 0xdc00) {\n        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);\n        m_pos++;\n      }\n    }\n    if (c < 0x80) {\n      /* one byte */\n      buf[i++] = c;\n    } else if (c < 0x800) {\n      /* two bytes */\n      buf[i++] = 0xC0 | (c >>> 6);\n      buf[i++] = 0x80 | (c & 0x3f);\n    } else if (c < 0x10000) {\n      /* three bytes */\n      buf[i++] = 0xE0 | (c >>> 12);\n      buf[i++] = 0x80 | (c >>> 6 & 0x3f);\n      buf[i++] = 0x80 | (c & 0x3f);\n    } else {\n      /* four bytes */\n      buf[i++] = 0xf0 | (c >>> 18);\n      buf[i++] = 0x80 | (c >>> 12 & 0x3f);\n      buf[i++] = 0x80 | (c >>> 6 & 0x3f);\n      buf[i++] = 0x80 | (c & 0x3f);\n    }\n  }\n\n  return buf;\n};\n\n// Helper (used in 2 places)\nfunction buf2binstring(buf, len) {\n  // On Chrome, the arguments in a function call that are allowed is `65534`.\n  // If the length of the buffer is smaller than that, we can use this optimization,\n  // otherwise we will take a slower path.\n  if (len < 65534) {\n    if ((buf.subarray && STR_APPLY_UIA_OK) || (!buf.subarray && STR_APPLY_OK)) {\n      return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len));\n    }\n  }\n\n  var result = '';\n  for (var i = 0; i < len; i++) {\n    result += String.fromCharCode(buf[i]);\n  }\n  return result;\n}\n\n\n// Convert byte array to binary string\nexports.buf2binstring = function (buf) {\n  return buf2binstring(buf, buf.length);\n};\n\n\n// Convert binary string (typed, when possible)\nexports.binstring2buf = function (str) {\n  var buf = new utils.Buf8(str.length);\n  for (var i = 0, len = buf.length; i < len; i++) {\n    buf[i] = str.charCodeAt(i);\n  }\n  return buf;\n};\n\n\n// convert array to string\nexports.buf2string = function (buf, max) {\n  var i, out, c, c_len;\n  var len = max || buf.length;\n\n  // Reserve max possible length (2 words per char)\n  // NB: by unknown reasons, Array is significantly faster for\n  //     String.fromCharCode.apply than Uint16Array.\n  var utf16buf = new Array(len * 2);\n\n  for (out = 0, i = 0; i < len;) {\n    c = buf[i++];\n    // quick process ascii\n    if (c < 0x80) { utf16buf[out++] = c; continue; }\n\n    c_len = _utf8len[c];\n    // skip 5 & 6 byte codes\n    if (c_len > 4) { utf16buf[out++] = 0xfffd; i += c_len - 1; continue; }\n\n    // apply mask on first byte\n    c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;\n    // join the rest\n    while (c_len > 1 && i < len) {\n      c = (c << 6) | (buf[i++] & 0x3f);\n      c_len--;\n    }\n\n    // terminated by end of string?\n    if (c_len > 1) { utf16buf[out++] = 0xfffd; continue; }\n\n    if (c < 0x10000) {\n      utf16buf[out++] = c;\n    } else {\n      c -= 0x10000;\n      utf16buf[out++] = 0xd800 | ((c >> 10) & 0x3ff);\n      utf16buf[out++] = 0xdc00 | (c & 0x3ff);\n    }\n  }\n\n  return buf2binstring(utf16buf, out);\n};\n\n\n// Calculate max possible position in utf8 buffer,\n// that will not break sequence. If that's not possible\n// - (very small limits) return max size as is.\n//\n// buf[] - utf8 bytes array\n// max   - length limit (mandatory);\nexports.utf8border = function (buf, max) {\n  var pos;\n\n  max = max || buf.length;\n  if (max > buf.length) { max = buf.length; }\n\n  // go back from last position, until start of sequence found\n  pos = max - 1;\n  while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) { pos--; }\n\n  // Very small and broken sequence,\n  // return max, because we should return something anyway.\n  if (pos < 0) { return max; }\n\n  // If we came to start of buffer - that means buffer is too small,\n  // return max too.\n  if (pos === 0) { return max; }\n\n  return (pos + _utf8len[buf[pos]] > max) ? pos : max;\n};\n","'use strict';\n\n// Note: adler32 takes 12% for level 0 and 2% for level 6.\n// It isn't worth it to make additional optimizations as in original.\n// Small size is preferable.\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nfunction adler32(adler, buf, len, pos) {\n  var s1 = (adler & 0xffff) |0,\n      s2 = ((adler >>> 16) & 0xffff) |0,\n      n = 0;\n\n  while (len !== 0) {\n    // Set limit ~ twice less than 5552, to keep\n    // s2 in 31-bits, because we force signed ints.\n    // in other case %= will fail.\n    n = len > 2000 ? 2000 : len;\n    len -= n;\n\n    do {\n      s1 = (s1 + buf[pos++]) |0;\n      s2 = (s2 + s1) |0;\n    } while (--n);\n\n    s1 %= 65521;\n    s2 %= 65521;\n  }\n\n  return (s1 | (s2 << 16)) |0;\n}\n\n\nmodule.exports = adler32;\n","'use strict';\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nmodule.exports = {\n\n  /* Allowed flush values; see deflate() and inflate() below for details */\n  Z_NO_FLUSH:         0,\n  Z_PARTIAL_FLUSH:    1,\n  Z_SYNC_FLUSH:       2,\n  Z_FULL_FLUSH:       3,\n  Z_FINISH:           4,\n  Z_BLOCK:            5,\n  Z_TREES:            6,\n\n  /* Return codes for the compression/decompression functions. Negative values\n  * are errors, positive values are used for special but normal events.\n  */\n  Z_OK:               0,\n  Z_STREAM_END:       1,\n  Z_NEED_DICT:        2,\n  Z_ERRNO:           -1,\n  Z_STREAM_ERROR:    -2,\n  Z_DATA_ERROR:      -3,\n  //Z_MEM_ERROR:     -4,\n  Z_BUF_ERROR:       -5,\n  //Z_VERSION_ERROR: -6,\n\n  /* compression levels */\n  Z_NO_COMPRESSION:         0,\n  Z_BEST_SPEED:             1,\n  Z_BEST_COMPRESSION:       9,\n  Z_DEFAULT_COMPRESSION:   -1,\n\n\n  Z_FILTERED:               1,\n  Z_HUFFMAN_ONLY:           2,\n  Z_RLE:                    3,\n  Z_FIXED:                  4,\n  Z_DEFAULT_STRATEGY:       0,\n\n  /* Possible values of the data_type field (though see inflate()) */\n  Z_BINARY:                 0,\n  Z_TEXT:                   1,\n  //Z_ASCII:                1, // = Z_TEXT (deprecated)\n  Z_UNKNOWN:                2,\n\n  /* The deflate compression method */\n  Z_DEFLATED:               8\n  //Z_NULL:                 null // Use -1 or null inline, depending on var type\n};\n","'use strict';\n\n// Note: we can't get significant speed boost here.\n// So write code to minimize size - no pregenerated tables\n// and array tools dependencies.\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\n// Use ordinary array, since untyped makes no boost here\nfunction makeTable() {\n  var c, table = [];\n\n  for (var n = 0; n < 256; n++) {\n    c = n;\n    for (var k = 0; k < 8; k++) {\n      c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));\n    }\n    table[n] = c;\n  }\n\n  return table;\n}\n\n// Create table on load. Just 255 signed longs. Not a problem.\nvar crcTable = makeTable();\n\n\nfunction crc32(crc, buf, len, pos) {\n  var t = crcTable,\n      end = pos + len;\n\n  crc ^= -1;\n\n  for (var i = pos; i < end; i++) {\n    crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xFF];\n  }\n\n  return (crc ^ (-1)); // >>> 0;\n}\n\n\nmodule.exports = crc32;\n","'use strict';\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nvar utils   = require('../utils/common');\nvar trees   = require('./trees');\nvar adler32 = require('./adler32');\nvar crc32   = require('./crc32');\nvar msg     = require('./messages');\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\n\n/* Allowed flush values; see deflate() and inflate() below for details */\nvar Z_NO_FLUSH      = 0;\nvar Z_PARTIAL_FLUSH = 1;\n//var Z_SYNC_FLUSH    = 2;\nvar Z_FULL_FLUSH    = 3;\nvar Z_FINISH        = 4;\nvar Z_BLOCK         = 5;\n//var Z_TREES         = 6;\n\n\n/* Return codes for the compression/decompression functions. Negative values\n * are errors, positive values are used for special but normal events.\n */\nvar Z_OK            = 0;\nvar Z_STREAM_END    = 1;\n//var Z_NEED_DICT     = 2;\n//var Z_ERRNO         = -1;\nvar Z_STREAM_ERROR  = -2;\nvar Z_DATA_ERROR    = -3;\n//var Z_MEM_ERROR     = -4;\nvar Z_BUF_ERROR     = -5;\n//var Z_VERSION_ERROR = -6;\n\n\n/* compression levels */\n//var Z_NO_COMPRESSION      = 0;\n//var Z_BEST_SPEED          = 1;\n//var Z_BEST_COMPRESSION    = 9;\nvar Z_DEFAULT_COMPRESSION = -1;\n\n\nvar Z_FILTERED            = 1;\nvar Z_HUFFMAN_ONLY        = 2;\nvar Z_RLE                 = 3;\nvar Z_FIXED               = 4;\nvar Z_DEFAULT_STRATEGY    = 0;\n\n/* Possible values of the data_type field (though see inflate()) */\n//var Z_BINARY              = 0;\n//var Z_TEXT                = 1;\n//var Z_ASCII               = 1; // = Z_TEXT\nvar Z_UNKNOWN             = 2;\n\n\n/* The deflate compression method */\nvar Z_DEFLATED  = 8;\n\n/*============================================================================*/\n\n\nvar MAX_MEM_LEVEL = 9;\n/* Maximum value for memLevel in deflateInit2 */\nvar MAX_WBITS = 15;\n/* 32K LZ77 window */\nvar DEF_MEM_LEVEL = 8;\n\n\nvar LENGTH_CODES  = 29;\n/* number of length codes, not counting the special END_BLOCK code */\nvar LITERALS      = 256;\n/* number of literal bytes 0..255 */\nvar L_CODES       = LITERALS + 1 + LENGTH_CODES;\n/* number of Literal or Length codes, including the END_BLOCK code */\nvar D_CODES       = 30;\n/* number of distance codes */\nvar BL_CODES      = 19;\n/* number of codes used to transfer the bit lengths */\nvar HEAP_SIZE     = 2 * L_CODES + 1;\n/* maximum heap size */\nvar MAX_BITS  = 15;\n/* All codes must not exceed MAX_BITS bits */\n\nvar MIN_MATCH = 3;\nvar MAX_MATCH = 258;\nvar MIN_LOOKAHEAD = (MAX_MATCH + MIN_MATCH + 1);\n\nvar PRESET_DICT = 0x20;\n\nvar INIT_STATE = 42;\nvar EXTRA_STATE = 69;\nvar NAME_STATE = 73;\nvar COMMENT_STATE = 91;\nvar HCRC_STATE = 103;\nvar BUSY_STATE = 113;\nvar FINISH_STATE = 666;\n\nvar BS_NEED_MORE      = 1; /* block not completed, need more input or more output */\nvar BS_BLOCK_DONE     = 2; /* block flush performed */\nvar BS_FINISH_STARTED = 3; /* finish started, need only more output at next deflate */\nvar BS_FINISH_DONE    = 4; /* finish done, accept no more input or output */\n\nvar OS_CODE = 0x03; // Unix :) . Don't detect, use this default.\n\nfunction err(strm, errorCode) {\n  strm.msg = msg[errorCode];\n  return errorCode;\n}\n\nfunction rank(f) {\n  return ((f) << 1) - ((f) > 4 ? 9 : 0);\n}\n\nfunction zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }\n\n\n/* =========================================================================\n * Flush as much pending output as possible. All deflate() output goes\n * through this function so some applications may wish to modify it\n * to avoid allocating a large strm->output buffer and copying into it.\n * (See also read_buf()).\n */\nfunction flush_pending(strm) {\n  var s = strm.state;\n\n  //_tr_flush_bits(s);\n  var len = s.pending;\n  if (len > strm.avail_out) {\n    len = strm.avail_out;\n  }\n  if (len === 0) { return; }\n\n  utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);\n  strm.next_out += len;\n  s.pending_out += len;\n  strm.total_out += len;\n  strm.avail_out -= len;\n  s.pending -= len;\n  if (s.pending === 0) {\n    s.pending_out = 0;\n  }\n}\n\n\nfunction flush_block_only(s, last) {\n  trees._tr_flush_block(s, (s.block_start >= 0 ? s.block_start : -1), s.strstart - s.block_start, last);\n  s.block_start = s.strstart;\n  flush_pending(s.strm);\n}\n\n\nfunction put_byte(s, b) {\n  s.pending_buf[s.pending++] = b;\n}\n\n\n/* =========================================================================\n * Put a short in the pending buffer. The 16-bit value is put in MSB order.\n * IN assertion: the stream state is correct and there is enough room in\n * pending_buf.\n */\nfunction putShortMSB(s, b) {\n//  put_byte(s, (Byte)(b >> 8));\n//  put_byte(s, (Byte)(b & 0xff));\n  s.pending_buf[s.pending++] = (b >>> 8) & 0xff;\n  s.pending_buf[s.pending++] = b & 0xff;\n}\n\n\n/* ===========================================================================\n * Read a new buffer from the current input stream, update the adler32\n * and total number of bytes read.  All deflate() input goes through\n * this function so some applications may wish to modify it to avoid\n * allocating a large strm->input buffer and copying from it.\n * (See also flush_pending()).\n */\nfunction read_buf(strm, buf, start, size) {\n  var len = strm.avail_in;\n\n  if (len > size) { len = size; }\n  if (len === 0) { return 0; }\n\n  strm.avail_in -= len;\n\n  // zmemcpy(buf, strm->next_in, len);\n  utils.arraySet(buf, strm.input, strm.next_in, len, start);\n  if (strm.state.wrap === 1) {\n    strm.adler = adler32(strm.adler, buf, len, start);\n  }\n\n  else if (strm.state.wrap === 2) {\n    strm.adler = crc32(strm.adler, buf, len, start);\n  }\n\n  strm.next_in += len;\n  strm.total_in += len;\n\n  return len;\n}\n\n\n/* ===========================================================================\n * Set match_start to the longest match starting at the given string and\n * return its length. Matches shorter or equal to prev_length are discarded,\n * in which case the result is equal to prev_length and match_start is\n * garbage.\n * IN assertions: cur_match is the head of the hash chain for the current\n *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1\n * OUT assertion: the match length is not greater than s->lookahead.\n */\nfunction longest_match(s, cur_match) {\n  var chain_length = s.max_chain_length;      /* max hash chain length */\n  var scan = s.strstart; /* current string */\n  var match;                       /* matched string */\n  var len;                           /* length of current match */\n  var best_len = s.prev_length;              /* best match length so far */\n  var nice_match = s.nice_match;             /* stop if match long enough */\n  var limit = (s.strstart > (s.w_size - MIN_LOOKAHEAD)) ?\n      s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0/*NIL*/;\n\n  var _win = s.window; // shortcut\n\n  var wmask = s.w_mask;\n  var prev  = s.prev;\n\n  /* Stop when cur_match becomes <= limit. To simplify the code,\n   * we prevent matches with the string of window index 0.\n   */\n\n  var strend = s.strstart + MAX_MATCH;\n  var scan_end1  = _win[scan + best_len - 1];\n  var scan_end   = _win[scan + best_len];\n\n  /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.\n   * It is easy to get rid of this optimization if necessary.\n   */\n  // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, \"Code too clever\");\n\n  /* Do not waste too much time if we already have a good match: */\n  if (s.prev_length >= s.good_match) {\n    chain_length >>= 2;\n  }\n  /* Do not look for matches beyond the end of the input. This is necessary\n   * to make deflate deterministic.\n   */\n  if (nice_match > s.lookahead) { nice_match = s.lookahead; }\n\n  // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, \"need lookahead\");\n\n  do {\n    // Assert(cur_match < s->strstart, \"no future\");\n    match = cur_match;\n\n    /* Skip to next match if the match length cannot increase\n     * or if the match length is less than 2.  Note that the checks below\n     * for insufficient lookahead only occur occasionally for performance\n     * reasons.  Therefore uninitialized memory will be accessed, and\n     * conditional jumps will be made that depend on those values.\n     * However the length of the match is limited to the lookahead, so\n     * the output of deflate is not affected by the uninitialized values.\n     */\n\n    if (_win[match + best_len]     !== scan_end  ||\n        _win[match + best_len - 1] !== scan_end1 ||\n        _win[match]                !== _win[scan] ||\n        _win[++match]              !== _win[scan + 1]) {\n      continue;\n    }\n\n    /* The check at best_len-1 can be removed because it will be made\n     * again later. (This heuristic is not always a win.)\n     * It is not necessary to compare scan[2] and match[2] since they\n     * are always equal when the other bytes match, given that\n     * the hash keys are equal and that HASH_BITS >= 8.\n     */\n    scan += 2;\n    match++;\n    // Assert(*scan == *match, \"match[2]?\");\n\n    /* We check for insufficient lookahead only every 8th comparison;\n     * the 256th check will be made at strstart+258.\n     */\n    do {\n      /*jshint noempty:false*/\n    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             scan < strend);\n\n    // Assert(scan <= s->window+(unsigned)(s->window_size-1), \"wild scan\");\n\n    len = MAX_MATCH - (strend - scan);\n    scan = strend - MAX_MATCH;\n\n    if (len > best_len) {\n      s.match_start = cur_match;\n      best_len = len;\n      if (len >= nice_match) {\n        break;\n      }\n      scan_end1  = _win[scan + best_len - 1];\n      scan_end   = _win[scan + best_len];\n    }\n  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);\n\n  if (best_len <= s.lookahead) {\n    return best_len;\n  }\n  return s.lookahead;\n}\n\n\n/* ===========================================================================\n * Fill the window when the lookahead becomes insufficient.\n * Updates strstart and lookahead.\n *\n * IN assertion: lookahead < MIN_LOOKAHEAD\n * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD\n *    At least one byte has been read, or avail_in == 0; reads are\n *    performed for at least two bytes (required for the zip translate_eol\n *    option -- not supported here).\n */\nfunction fill_window(s) {\n  var _w_size = s.w_size;\n  var p, n, m, more, str;\n\n  //Assert(s->lookahead < MIN_LOOKAHEAD, \"already enough lookahead\");\n\n  do {\n    more = s.window_size - s.lookahead - s.strstart;\n\n    // JS ints have 32 bit, block below not needed\n    /* Deal with !@#$% 64K limit: */\n    //if (sizeof(int) <= 2) {\n    //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {\n    //        more = wsize;\n    //\n    //  } else if (more == (unsigned)(-1)) {\n    //        /* Very unlikely, but possible on 16 bit machine if\n    //         * strstart == 0 && lookahead == 1 (input done a byte at time)\n    //         */\n    //        more--;\n    //    }\n    //}\n\n\n    /* If the window is almost full and there is insufficient lookahead,\n     * move the upper half to the lower one to make room in the upper half.\n     */\n    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {\n\n      utils.arraySet(s.window, s.window, _w_size, _w_size, 0);\n      s.match_start -= _w_size;\n      s.strstart -= _w_size;\n      /* we now have strstart >= MAX_DIST */\n      s.block_start -= _w_size;\n\n      /* Slide the hash table (could be avoided with 32 bit values\n       at the expense of memory usage). We slide even when level == 0\n       to keep the hash table consistent if we switch back to level > 0\n       later. (Using level 0 permanently is not an optimal usage of\n       zlib, so we don't care about this pathological case.)\n       */\n\n      n = s.hash_size;\n      p = n;\n      do {\n        m = s.head[--p];\n        s.head[p] = (m >= _w_size ? m - _w_size : 0);\n      } while (--n);\n\n      n = _w_size;\n      p = n;\n      do {\n        m = s.prev[--p];\n        s.prev[p] = (m >= _w_size ? m - _w_size : 0);\n        /* If n is not on any hash chain, prev[n] is garbage but\n         * its value will never be used.\n         */\n      } while (--n);\n\n      more += _w_size;\n    }\n    if (s.strm.avail_in === 0) {\n      break;\n    }\n\n    /* If there was no sliding:\n     *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&\n     *    more == window_size - lookahead - strstart\n     * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)\n     * => more >= window_size - 2*WSIZE + 2\n     * In the BIG_MEM or MMAP case (not yet supported),\n     *   window_size == input_size + MIN_LOOKAHEAD  &&\n     *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.\n     * Otherwise, window_size == 2*WSIZE so more >= 2.\n     * If there was sliding, more >= WSIZE. So in all cases, more >= 2.\n     */\n    //Assert(more >= 2, \"more < 2\");\n    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);\n    s.lookahead += n;\n\n    /* Initialize the hash value now that we have some input: */\n    if (s.lookahead + s.insert >= MIN_MATCH) {\n      str = s.strstart - s.insert;\n      s.ins_h = s.window[str];\n\n      /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */\n      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + 1]) & s.hash_mask;\n//#if MIN_MATCH != 3\n//        Call update_hash() MIN_MATCH-3 more times\n//#endif\n      while (s.insert) {\n        /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */\n        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;\n\n        s.prev[str & s.w_mask] = s.head[s.ins_h];\n        s.head[s.ins_h] = str;\n        str++;\n        s.insert--;\n        if (s.lookahead + s.insert < MIN_MATCH) {\n          break;\n        }\n      }\n    }\n    /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,\n     * but this is not important since only literal bytes will be emitted.\n     */\n\n  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);\n\n  /* If the WIN_INIT bytes after the end of the current data have never been\n   * written, then zero those bytes in order to avoid memory check reports of\n   * the use of uninitialized (or uninitialised as Julian writes) bytes by\n   * the longest match routines.  Update the high water mark for the next\n   * time through here.  WIN_INIT is set to MAX_MATCH since the longest match\n   * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.\n   */\n//  if (s.high_water < s.window_size) {\n//    var curr = s.strstart + s.lookahead;\n//    var init = 0;\n//\n//    if (s.high_water < curr) {\n//      /* Previous high water mark below current data -- zero WIN_INIT\n//       * bytes or up to end of window, whichever is less.\n//       */\n//      init = s.window_size - curr;\n//      if (init > WIN_INIT)\n//        init = WIN_INIT;\n//      zmemzero(s->window + curr, (unsigned)init);\n//      s->high_water = curr + init;\n//    }\n//    else if (s->high_water < (ulg)curr + WIN_INIT) {\n//      /* High water mark at or above current data, but below current data\n//       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up\n//       * to end of window, whichever is less.\n//       */\n//      init = (ulg)curr + WIN_INIT - s->high_water;\n//      if (init > s->window_size - s->high_water)\n//        init = s->window_size - s->high_water;\n//      zmemzero(s->window + s->high_water, (unsigned)init);\n//      s->high_water += init;\n//    }\n//  }\n//\n//  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,\n//    \"not enough room for search\");\n}\n\n/* ===========================================================================\n * Copy without compression as much as possible from the input stream, return\n * the current block state.\n * This function does not insert new strings in the dictionary since\n * uncompressible data is probably not useful. This function is used\n * only for the level=0 compression option.\n * NOTE: this function should be optimized to avoid extra copying from\n * window to pending_buf.\n */\nfunction deflate_stored(s, flush) {\n  /* Stored blocks are limited to 0xffff bytes, pending_buf is limited\n   * to pending_buf_size, and each stored block has a 5 byte header:\n   */\n  var max_block_size = 0xffff;\n\n  if (max_block_size > s.pending_buf_size - 5) {\n    max_block_size = s.pending_buf_size - 5;\n  }\n\n  /* Copy as much as possible from input to output: */\n  for (;;) {\n    /* Fill the window as much as possible: */\n    if (s.lookahead <= 1) {\n\n      //Assert(s->strstart < s->w_size+MAX_DIST(s) ||\n      //  s->block_start >= (long)s->w_size, \"slide too late\");\n//      if (!(s.strstart < s.w_size + (s.w_size - MIN_LOOKAHEAD) ||\n//        s.block_start >= s.w_size)) {\n//        throw  new Error(\"slide too late\");\n//      }\n\n      fill_window(s);\n      if (s.lookahead === 0 && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE;\n      }\n\n      if (s.lookahead === 0) {\n        break;\n      }\n      /* flush the current block */\n    }\n    //Assert(s->block_start >= 0L, \"block gone\");\n//    if (s.block_start < 0) throw new Error(\"block gone\");\n\n    s.strstart += s.lookahead;\n    s.lookahead = 0;\n\n    /* Emit a stored block if pending_buf will be full: */\n    var max_start = s.block_start + max_block_size;\n\n    if (s.strstart === 0 || s.strstart >= max_start) {\n      /* strstart == 0 is possible when wraparound on 16-bit machine */\n      s.lookahead = s.strstart - max_start;\n      s.strstart = max_start;\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n\n\n    }\n    /* Flush if we may have to slide, otherwise block_start may become\n     * negative and the data will be gone:\n     */\n    if (s.strstart - s.block_start >= (s.w_size - MIN_LOOKAHEAD)) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n\n  s.insert = 0;\n\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n\n  if (s.strstart > s.block_start) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n\n  return BS_NEED_MORE;\n}\n\n/* ===========================================================================\n * Compress as much as possible from the input stream, return the current\n * block state.\n * This function does not perform lazy evaluation of matches and inserts\n * new strings in the dictionary only for unmatched strings or for short\n * matches. It is used only for the fast compression options.\n */\nfunction deflate_fast(s, flush) {\n  var hash_head;        /* head of the hash chain */\n  var bflush;           /* set if current block must be flushed */\n\n  for (;;) {\n    /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the next match, plus MIN_MATCH bytes to insert the\n     * string following the next match.\n     */\n    if (s.lookahead < MIN_LOOKAHEAD) {\n      fill_window(s);\n      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE;\n      }\n      if (s.lookahead === 0) {\n        break; /* flush the current block */\n      }\n    }\n\n    /* Insert the string window[strstart .. strstart+2] in the\n     * dictionary, and set hash_head to the head of the hash chain:\n     */\n    hash_head = 0/*NIL*/;\n    if (s.lookahead >= MIN_MATCH) {\n      /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n      s.head[s.ins_h] = s.strstart;\n      /***/\n    }\n\n    /* Find the longest match, discarding those <= prev_length.\n     * At this point we have always match_length < MIN_MATCH\n     */\n    if (hash_head !== 0/*NIL*/ && ((s.strstart - hash_head) <= (s.w_size - MIN_LOOKAHEAD))) {\n      /* To simplify the code, we prevent matches with the string\n       * of window index 0 (in particular we have to avoid a match\n       * of the string with itself at the start of the input file).\n       */\n      s.match_length = longest_match(s, hash_head);\n      /* longest_match() sets match_start */\n    }\n    if (s.match_length >= MIN_MATCH) {\n      // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only\n\n      /*** _tr_tally_dist(s, s.strstart - s.match_start,\n                     s.match_length - MIN_MATCH, bflush); ***/\n      bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);\n\n      s.lookahead -= s.match_length;\n\n      /* Insert new strings in the hash table only if the match length\n       * is not too large. This saves time but degrades compression.\n       */\n      if (s.match_length <= s.max_lazy_match/*max_insert_length*/ && s.lookahead >= MIN_MATCH) {\n        s.match_length--; /* string at strstart already in table */\n        do {\n          s.strstart++;\n          /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n          s.head[s.ins_h] = s.strstart;\n          /***/\n          /* strstart never exceeds WSIZE-MAX_MATCH, so there are\n           * always MIN_MATCH bytes ahead.\n           */\n        } while (--s.match_length !== 0);\n        s.strstart++;\n      } else\n      {\n        s.strstart += s.match_length;\n        s.match_length = 0;\n        s.ins_h = s.window[s.strstart];\n        /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */\n        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + 1]) & s.hash_mask;\n\n//#if MIN_MATCH != 3\n//                Call UPDATE_HASH() MIN_MATCH-3 more times\n//#endif\n        /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not\n         * matter since it will be recomputed at next deflate call.\n         */\n      }\n    } else {\n      /* No match, output a literal byte */\n      //Tracevv((stderr,\"%c\", s.window[s.strstart]));\n      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);\n\n      s.lookahead--;\n      s.strstart++;\n    }\n    if (bflush) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n  s.insert = ((s.strstart < (MIN_MATCH - 1)) ? s.strstart : MIN_MATCH - 1);\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.last_lit) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n  return BS_BLOCK_DONE;\n}\n\n/* ===========================================================================\n * Same as above, but achieves better compression. We use a lazy\n * evaluation for matches: a match is finally adopted only if there is\n * no better match at the next window position.\n */\nfunction deflate_slow(s, flush) {\n  var hash_head;          /* head of hash chain */\n  var bflush;              /* set if current block must be flushed */\n\n  var max_insert;\n\n  /* Process the input block. */\n  for (;;) {\n    /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the next match, plus MIN_MATCH bytes to insert the\n     * string following the next match.\n     */\n    if (s.lookahead < MIN_LOOKAHEAD) {\n      fill_window(s);\n      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE;\n      }\n      if (s.lookahead === 0) { break; } /* flush the current block */\n    }\n\n    /* Insert the string window[strstart .. strstart+2] in the\n     * dictionary, and set hash_head to the head of the hash chain:\n     */\n    hash_head = 0/*NIL*/;\n    if (s.lookahead >= MIN_MATCH) {\n      /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n      s.head[s.ins_h] = s.strstart;\n      /***/\n    }\n\n    /* Find the longest match, discarding those <= prev_length.\n     */\n    s.prev_length = s.match_length;\n    s.prev_match = s.match_start;\n    s.match_length = MIN_MATCH - 1;\n\n    if (hash_head !== 0/*NIL*/ && s.prev_length < s.max_lazy_match &&\n        s.strstart - hash_head <= (s.w_size - MIN_LOOKAHEAD)/*MAX_DIST(s)*/) {\n      /* To simplify the code, we prevent matches with the string\n       * of window index 0 (in particular we have to avoid a match\n       * of the string with itself at the start of the input file).\n       */\n      s.match_length = longest_match(s, hash_head);\n      /* longest_match() sets match_start */\n\n      if (s.match_length <= 5 &&\n         (s.strategy === Z_FILTERED || (s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096/*TOO_FAR*/))) {\n\n        /* If prev_match is also MIN_MATCH, match_start is garbage\n         * but we will ignore the current match anyway.\n         */\n        s.match_length = MIN_MATCH - 1;\n      }\n    }\n    /* If there was a match at the previous step and the current\n     * match is not better, output the previous match:\n     */\n    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {\n      max_insert = s.strstart + s.lookahead - MIN_MATCH;\n      /* Do not insert strings in hash table beyond this. */\n\n      //check_match(s, s.strstart-1, s.prev_match, s.prev_length);\n\n      /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,\n                     s.prev_length - MIN_MATCH, bflush);***/\n      bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);\n      /* Insert in hash table all strings up to the end of the match.\n       * strstart-1 and strstart are already inserted. If there is not\n       * enough lookahead, the last two strings are not inserted in\n       * the hash table.\n       */\n      s.lookahead -= s.prev_length - 1;\n      s.prev_length -= 2;\n      do {\n        if (++s.strstart <= max_insert) {\n          /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n          s.head[s.ins_h] = s.strstart;\n          /***/\n        }\n      } while (--s.prev_length !== 0);\n      s.match_available = 0;\n      s.match_length = MIN_MATCH - 1;\n      s.strstart++;\n\n      if (bflush) {\n        /*** FLUSH_BLOCK(s, 0); ***/\n        flush_block_only(s, false);\n        if (s.strm.avail_out === 0) {\n          return BS_NEED_MORE;\n        }\n        /***/\n      }\n\n    } else if (s.match_available) {\n      /* If there was no match at the previous position, output a\n       * single literal. If there was a match but the current match\n       * is longer, truncate the previous match to a single literal.\n       */\n      //Tracevv((stderr,\"%c\", s->window[s->strstart-1]));\n      /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/\n      bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);\n\n      if (bflush) {\n        /*** FLUSH_BLOCK_ONLY(s, 0) ***/\n        flush_block_only(s, false);\n        /***/\n      }\n      s.strstart++;\n      s.lookahead--;\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n    } else {\n      /* There is no previous match to compare with, wait for\n       * the next step to decide.\n       */\n      s.match_available = 1;\n      s.strstart++;\n      s.lookahead--;\n    }\n  }\n  //Assert (flush != Z_NO_FLUSH, \"no flush?\");\n  if (s.match_available) {\n    //Tracevv((stderr,\"%c\", s->window[s->strstart-1]));\n    /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/\n    bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);\n\n    s.match_available = 0;\n  }\n  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.last_lit) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n\n  return BS_BLOCK_DONE;\n}\n\n\n/* ===========================================================================\n * For Z_RLE, simply look for runs of bytes, generate matches only of distance\n * one.  Do not maintain a hash table.  (It will be regenerated if this run of\n * deflate switches away from Z_RLE.)\n */\nfunction deflate_rle(s, flush) {\n  var bflush;            /* set if current block must be flushed */\n  var prev;              /* byte at distance one to match */\n  var scan, strend;      /* scan goes up to strend for length of run */\n\n  var _win = s.window;\n\n  for (;;) {\n    /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the longest run, plus one for the unrolled loop.\n     */\n    if (s.lookahead <= MAX_MATCH) {\n      fill_window(s);\n      if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE;\n      }\n      if (s.lookahead === 0) { break; } /* flush the current block */\n    }\n\n    /* See how many times the previous byte repeats */\n    s.match_length = 0;\n    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {\n      scan = s.strstart - 1;\n      prev = _win[scan];\n      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {\n        strend = s.strstart + MAX_MATCH;\n        do {\n          /*jshint noempty:false*/\n        } while (prev === _win[++scan] && prev === _win[++scan] &&\n                 prev === _win[++scan] && prev === _win[++scan] &&\n                 prev === _win[++scan] && prev === _win[++scan] &&\n                 prev === _win[++scan] && prev === _win[++scan] &&\n                 scan < strend);\n        s.match_length = MAX_MATCH - (strend - scan);\n        if (s.match_length > s.lookahead) {\n          s.match_length = s.lookahead;\n        }\n      }\n      //Assert(scan <= s->window+(uInt)(s->window_size-1), \"wild scan\");\n    }\n\n    /* Emit match if have run of MIN_MATCH or longer, else emit literal */\n    if (s.match_length >= MIN_MATCH) {\n      //check_match(s, s.strstart, s.strstart - 1, s.match_length);\n\n      /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/\n      bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);\n\n      s.lookahead -= s.match_length;\n      s.strstart += s.match_length;\n      s.match_length = 0;\n    } else {\n      /* No match, output a literal byte */\n      //Tracevv((stderr,\"%c\", s->window[s->strstart]));\n      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);\n\n      s.lookahead--;\n      s.strstart++;\n    }\n    if (bflush) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n  s.insert = 0;\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.last_lit) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n  return BS_BLOCK_DONE;\n}\n\n/* ===========================================================================\n * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.\n * (It will be regenerated if this run of deflate switches away from Huffman.)\n */\nfunction deflate_huff(s, flush) {\n  var bflush;             /* set if current block must be flushed */\n\n  for (;;) {\n    /* Make sure that we have a literal to write. */\n    if (s.lookahead === 0) {\n      fill_window(s);\n      if (s.lookahead === 0) {\n        if (flush === Z_NO_FLUSH) {\n          return BS_NEED_MORE;\n        }\n        break;      /* flush the current block */\n      }\n    }\n\n    /* Output a literal byte */\n    s.match_length = 0;\n    //Tracevv((stderr,\"%c\", s->window[s->strstart]));\n    /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n    bflush = trees._tr_tally(s, 0, s.window[s.strstart]);\n    s.lookahead--;\n    s.strstart++;\n    if (bflush) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n  s.insert = 0;\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.last_lit) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n  return BS_BLOCK_DONE;\n}\n\n/* Values for max_lazy_match, good_match and max_chain_length, depending on\n * the desired pack level (0..9). The values given below have been tuned to\n * exclude worst case performance for pathological files. Better values may be\n * found for specific files.\n */\nfunction Config(good_length, max_lazy, nice_length, max_chain, func) {\n  this.good_length = good_length;\n  this.max_lazy = max_lazy;\n  this.nice_length = nice_length;\n  this.max_chain = max_chain;\n  this.func = func;\n}\n\nvar configuration_table;\n\nconfiguration_table = [\n  /*      good lazy nice chain */\n  new Config(0, 0, 0, 0, deflate_stored),          /* 0 store only */\n  new Config(4, 4, 8, 4, deflate_fast),            /* 1 max speed, no lazy matches */\n  new Config(4, 5, 16, 8, deflate_fast),           /* 2 */\n  new Config(4, 6, 32, 32, deflate_fast),          /* 3 */\n\n  new Config(4, 4, 16, 16, deflate_slow),          /* 4 lazy matches */\n  new Config(8, 16, 32, 32, deflate_slow),         /* 5 */\n  new Config(8, 16, 128, 128, deflate_slow),       /* 6 */\n  new Config(8, 32, 128, 256, deflate_slow),       /* 7 */\n  new Config(32, 128, 258, 1024, deflate_slow),    /* 8 */\n  new Config(32, 258, 258, 4096, deflate_slow)     /* 9 max compression */\n];\n\n\n/* ===========================================================================\n * Initialize the \"longest match\" routines for a new zlib stream\n */\nfunction lm_init(s) {\n  s.window_size = 2 * s.w_size;\n\n  /*** CLEAR_HASH(s); ***/\n  zero(s.head); // Fill with NIL (= 0);\n\n  /* Set the default configuration parameters:\n   */\n  s.max_lazy_match = configuration_table[s.level].max_lazy;\n  s.good_match = configuration_table[s.level].good_length;\n  s.nice_match = configuration_table[s.level].nice_length;\n  s.max_chain_length = configuration_table[s.level].max_chain;\n\n  s.strstart = 0;\n  s.block_start = 0;\n  s.lookahead = 0;\n  s.insert = 0;\n  s.match_length = s.prev_length = MIN_MATCH - 1;\n  s.match_available = 0;\n  s.ins_h = 0;\n}\n\n\nfunction DeflateState() {\n  this.strm = null;            /* pointer back to this zlib stream */\n  this.status = 0;            /* as the name implies */\n  this.pending_buf = null;      /* output still pending */\n  this.pending_buf_size = 0;  /* size of pending_buf */\n  this.pending_out = 0;       /* next pending byte to output to the stream */\n  this.pending = 0;           /* nb of bytes in the pending buffer */\n  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */\n  this.gzhead = null;         /* gzip header information to write */\n  this.gzindex = 0;           /* where in extra, name, or comment */\n  this.method = Z_DEFLATED; /* can only be DEFLATED */\n  this.last_flush = -1;   /* value of flush param for previous deflate call */\n\n  this.w_size = 0;  /* LZ77 window size (32K by default) */\n  this.w_bits = 0;  /* log2(w_size)  (8..16) */\n  this.w_mask = 0;  /* w_size - 1 */\n\n  this.window = null;\n  /* Sliding window. Input bytes are read into the second half of the window,\n   * and move to the first half later to keep a dictionary of at least wSize\n   * bytes. With this organization, matches are limited to a distance of\n   * wSize-MAX_MATCH bytes, but this ensures that IO is always\n   * performed with a length multiple of the block size.\n   */\n\n  this.window_size = 0;\n  /* Actual size of window: 2*wSize, except when the user input buffer\n   * is directly used as sliding window.\n   */\n\n  this.prev = null;\n  /* Link to older string with same hash index. To limit the size of this\n   * array to 64K, this link is maintained only for the last 32K strings.\n   * An index in this array is thus a window index modulo 32K.\n   */\n\n  this.head = null;   /* Heads of the hash chains or NIL. */\n\n  this.ins_h = 0;       /* hash index of string to be inserted */\n  this.hash_size = 0;   /* number of elements in hash table */\n  this.hash_bits = 0;   /* log2(hash_size) */\n  this.hash_mask = 0;   /* hash_size-1 */\n\n  this.hash_shift = 0;\n  /* Number of bits by which ins_h must be shifted at each input\n   * step. It must be such that after MIN_MATCH steps, the oldest\n   * byte no longer takes part in the hash key, that is:\n   *   hash_shift * MIN_MATCH >= hash_bits\n   */\n\n  this.block_start = 0;\n  /* Window position at the beginning of the current output block. Gets\n   * negative when the window is moved backwards.\n   */\n\n  this.match_length = 0;      /* length of best match */\n  this.prev_match = 0;        /* previous match */\n  this.match_available = 0;   /* set if previous match exists */\n  this.strstart = 0;          /* start of string to insert */\n  this.match_start = 0;       /* start of matching string */\n  this.lookahead = 0;         /* number of valid bytes ahead in window */\n\n  this.prev_length = 0;\n  /* Length of the best match at previous step. Matches not greater than this\n   * are discarded. This is used in the lazy match evaluation.\n   */\n\n  this.max_chain_length = 0;\n  /* To speed up deflation, hash chains are never searched beyond this\n   * length.  A higher limit improves compression ratio but degrades the\n   * speed.\n   */\n\n  this.max_lazy_match = 0;\n  /* Attempt to find a better match only when the current match is strictly\n   * smaller than this value. This mechanism is used only for compression\n   * levels >= 4.\n   */\n  // That's alias to max_lazy_match, don't use directly\n  //this.max_insert_length = 0;\n  /* Insert new strings in the hash table only if the match length is not\n   * greater than this length. This saves time but degrades compression.\n   * max_insert_length is used only for compression levels <= 3.\n   */\n\n  this.level = 0;     /* compression level (1..9) */\n  this.strategy = 0;  /* favor or force Huffman coding*/\n\n  this.good_match = 0;\n  /* Use a faster search when the previous match is longer than this */\n\n  this.nice_match = 0; /* Stop searching when current match exceeds this */\n\n              /* used by trees.c: */\n\n  /* Didn't use ct_data typedef below to suppress compiler warning */\n\n  // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */\n  // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */\n  // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */\n\n  // Use flat array of DOUBLE size, with interleaved fata,\n  // because JS does not support effective\n  this.dyn_ltree  = new utils.Buf16(HEAP_SIZE * 2);\n  this.dyn_dtree  = new utils.Buf16((2 * D_CODES + 1) * 2);\n  this.bl_tree    = new utils.Buf16((2 * BL_CODES + 1) * 2);\n  zero(this.dyn_ltree);\n  zero(this.dyn_dtree);\n  zero(this.bl_tree);\n\n  this.l_desc   = null;         /* desc. for literal tree */\n  this.d_desc   = null;         /* desc. for distance tree */\n  this.bl_desc  = null;         /* desc. for bit length tree */\n\n  //ush bl_count[MAX_BITS+1];\n  this.bl_count = new utils.Buf16(MAX_BITS + 1);\n  /* number of codes at each bit length for an optimal tree */\n\n  //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */\n  this.heap = new utils.Buf16(2 * L_CODES + 1);  /* heap used to build the Huffman trees */\n  zero(this.heap);\n\n  this.heap_len = 0;               /* number of elements in the heap */\n  this.heap_max = 0;               /* element of largest frequency */\n  /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.\n   * The same heap array is used to build all trees.\n   */\n\n  this.depth = new utils.Buf16(2 * L_CODES + 1); //uch depth[2*L_CODES+1];\n  zero(this.depth);\n  /* Depth of each subtree used as tie breaker for trees of equal frequency\n   */\n\n  this.l_buf = 0;          /* buffer index for literals or lengths */\n\n  this.lit_bufsize = 0;\n  /* Size of match buffer for literals/lengths.  There are 4 reasons for\n   * limiting lit_bufsize to 64K:\n   *   - frequencies can be kept in 16 bit counters\n   *   - if compression is not successful for the first block, all input\n   *     data is still in the window so we can still emit a stored block even\n   *     when input comes from standard input.  (This can also be done for\n   *     all blocks if lit_bufsize is not greater than 32K.)\n   *   - if compression is not successful for a file smaller than 64K, we can\n   *     even emit a stored file instead of a stored block (saving 5 bytes).\n   *     This is applicable only for zip (not gzip or zlib).\n   *   - creating new Huffman trees less frequently may not provide fast\n   *     adaptation to changes in the input data statistics. (Take for\n   *     example a binary file with poorly compressible code followed by\n   *     a highly compressible string table.) Smaller buffer sizes give\n   *     fast adaptation but have of course the overhead of transmitting\n   *     trees more frequently.\n   *   - I can't count above 4\n   */\n\n  this.last_lit = 0;      /* running index in l_buf */\n\n  this.d_buf = 0;\n  /* Buffer index for distances. To simplify the code, d_buf and l_buf have\n   * the same number of elements. To use different lengths, an extra flag\n   * array would be necessary.\n   */\n\n  this.opt_len = 0;       /* bit length of current block with optimal trees */\n  this.static_len = 0;    /* bit length of current block with static trees */\n  this.matches = 0;       /* number of string matches in current block */\n  this.insert = 0;        /* bytes at end of window left to insert */\n\n\n  this.bi_buf = 0;\n  /* Output buffer. bits are inserted starting at the bottom (least\n   * significant bits).\n   */\n  this.bi_valid = 0;\n  /* Number of valid bits in bi_buf.  All bits above the last valid bit\n   * are always zero.\n   */\n\n  // Used for window memory init. We safely ignore it for JS. That makes\n  // sense only for pointers and memory check tools.\n  //this.high_water = 0;\n  /* High water mark offset in window for initialized bytes -- bytes above\n   * this are set to zero in order to avoid memory check warnings when\n   * longest match routines access bytes past the input.  This is then\n   * updated to the new high water mark.\n   */\n}\n\n\nfunction deflateResetKeep(strm) {\n  var s;\n\n  if (!strm || !strm.state) {\n    return err(strm, Z_STREAM_ERROR);\n  }\n\n  strm.total_in = strm.total_out = 0;\n  strm.data_type = Z_UNKNOWN;\n\n  s = strm.state;\n  s.pending = 0;\n  s.pending_out = 0;\n\n  if (s.wrap < 0) {\n    s.wrap = -s.wrap;\n    /* was made negative by deflate(..., Z_FINISH); */\n  }\n  s.status = (s.wrap ? INIT_STATE : BUSY_STATE);\n  strm.adler = (s.wrap === 2) ?\n    0  // crc32(0, Z_NULL, 0)\n  :\n    1; // adler32(0, Z_NULL, 0)\n  s.last_flush = Z_NO_FLUSH;\n  trees._tr_init(s);\n  return Z_OK;\n}\n\n\nfunction deflateReset(strm) {\n  var ret = deflateResetKeep(strm);\n  if (ret === Z_OK) {\n    lm_init(strm.state);\n  }\n  return ret;\n}\n\n\nfunction deflateSetHeader(strm, head) {\n  if (!strm || !strm.state) { return Z_STREAM_ERROR; }\n  if (strm.state.wrap !== 2) { return Z_STREAM_ERROR; }\n  strm.state.gzhead = head;\n  return Z_OK;\n}\n\n\nfunction deflateInit2(strm, level, method, windowBits, memLevel, strategy) {\n  if (!strm) { // === Z_NULL\n    return Z_STREAM_ERROR;\n  }\n  var wrap = 1;\n\n  if (level === Z_DEFAULT_COMPRESSION) {\n    level = 6;\n  }\n\n  if (windowBits < 0) { /* suppress zlib wrapper */\n    wrap = 0;\n    windowBits = -windowBits;\n  }\n\n  else if (windowBits > 15) {\n    wrap = 2;           /* write gzip wrapper instead */\n    windowBits -= 16;\n  }\n\n\n  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED ||\n    windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||\n    strategy < 0 || strategy > Z_FIXED) {\n    return err(strm, Z_STREAM_ERROR);\n  }\n\n\n  if (windowBits === 8) {\n    windowBits = 9;\n  }\n  /* until 256-byte window bug fixed */\n\n  var s = new DeflateState();\n\n  strm.state = s;\n  s.strm = strm;\n\n  s.wrap = wrap;\n  s.gzhead = null;\n  s.w_bits = windowBits;\n  s.w_size = 1 << s.w_bits;\n  s.w_mask = s.w_size - 1;\n\n  s.hash_bits = memLevel + 7;\n  s.hash_size = 1 << s.hash_bits;\n  s.hash_mask = s.hash_size - 1;\n  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);\n\n  s.window = new utils.Buf8(s.w_size * 2);\n  s.head = new utils.Buf16(s.hash_size);\n  s.prev = new utils.Buf16(s.w_size);\n\n  // Don't need mem init magic for JS.\n  //s.high_water = 0;  /* nothing written to s->window yet */\n\n  s.lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */\n\n  s.pending_buf_size = s.lit_bufsize * 4;\n\n  //overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);\n  //s->pending_buf = (uchf *) overlay;\n  s.pending_buf = new utils.Buf8(s.pending_buf_size);\n\n  // It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)\n  //s->d_buf = overlay + s->lit_bufsize/sizeof(ush);\n  s.d_buf = 1 * s.lit_bufsize;\n\n  //s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;\n  s.l_buf = (1 + 2) * s.lit_bufsize;\n\n  s.level = level;\n  s.strategy = strategy;\n  s.method = method;\n\n  return deflateReset(strm);\n}\n\nfunction deflateInit(strm, level) {\n  return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);\n}\n\n\nfunction deflate(strm, flush) {\n  var old_flush, s;\n  var beg, val; // for gzip header write only\n\n  if (!strm || !strm.state ||\n    flush > Z_BLOCK || flush < 0) {\n    return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;\n  }\n\n  s = strm.state;\n\n  if (!strm.output ||\n      (!strm.input && strm.avail_in !== 0) ||\n      (s.status === FINISH_STATE && flush !== Z_FINISH)) {\n    return err(strm, (strm.avail_out === 0) ? Z_BUF_ERROR : Z_STREAM_ERROR);\n  }\n\n  s.strm = strm; /* just in case */\n  old_flush = s.last_flush;\n  s.last_flush = flush;\n\n  /* Write the header */\n  if (s.status === INIT_STATE) {\n\n    if (s.wrap === 2) { // GZIP header\n      strm.adler = 0;  //crc32(0L, Z_NULL, 0);\n      put_byte(s, 31);\n      put_byte(s, 139);\n      put_byte(s, 8);\n      if (!s.gzhead) { // s->gzhead == Z_NULL\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, s.level === 9 ? 2 :\n                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?\n                     4 : 0));\n        put_byte(s, OS_CODE);\n        s.status = BUSY_STATE;\n      }\n      else {\n        put_byte(s, (s.gzhead.text ? 1 : 0) +\n                    (s.gzhead.hcrc ? 2 : 0) +\n                    (!s.gzhead.extra ? 0 : 4) +\n                    (!s.gzhead.name ? 0 : 8) +\n                    (!s.gzhead.comment ? 0 : 16)\n        );\n        put_byte(s, s.gzhead.time & 0xff);\n        put_byte(s, (s.gzhead.time >> 8) & 0xff);\n        put_byte(s, (s.gzhead.time >> 16) & 0xff);\n        put_byte(s, (s.gzhead.time >> 24) & 0xff);\n        put_byte(s, s.level === 9 ? 2 :\n                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?\n                     4 : 0));\n        put_byte(s, s.gzhead.os & 0xff);\n        if (s.gzhead.extra && s.gzhead.extra.length) {\n          put_byte(s, s.gzhead.extra.length & 0xff);\n          put_byte(s, (s.gzhead.extra.length >> 8) & 0xff);\n        }\n        if (s.gzhead.hcrc) {\n          strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);\n        }\n        s.gzindex = 0;\n        s.status = EXTRA_STATE;\n      }\n    }\n    else // DEFLATE header\n    {\n      var header = (Z_DEFLATED + ((s.w_bits - 8) << 4)) << 8;\n      var level_flags = -1;\n\n      if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {\n        level_flags = 0;\n      } else if (s.level < 6) {\n        level_flags = 1;\n      } else if (s.level === 6) {\n        level_flags = 2;\n      } else {\n        level_flags = 3;\n      }\n      header |= (level_flags << 6);\n      if (s.strstart !== 0) { header |= PRESET_DICT; }\n      header += 31 - (header % 31);\n\n      s.status = BUSY_STATE;\n      putShortMSB(s, header);\n\n      /* Save the adler32 of the preset dictionary: */\n      if (s.strstart !== 0) {\n        putShortMSB(s, strm.adler >>> 16);\n        putShortMSB(s, strm.adler & 0xffff);\n      }\n      strm.adler = 1; // adler32(0L, Z_NULL, 0);\n    }\n  }\n\n//#ifdef GZIP\n  if (s.status === EXTRA_STATE) {\n    if (s.gzhead.extra/* != Z_NULL*/) {\n      beg = s.pending;  /* start of bytes to update crc */\n\n      while (s.gzindex < (s.gzhead.extra.length & 0xffff)) {\n        if (s.pending === s.pending_buf_size) {\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n          }\n          flush_pending(strm);\n          beg = s.pending;\n          if (s.pending === s.pending_buf_size) {\n            break;\n          }\n        }\n        put_byte(s, s.gzhead.extra[s.gzindex] & 0xff);\n        s.gzindex++;\n      }\n      if (s.gzhead.hcrc && s.pending > beg) {\n        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n      }\n      if (s.gzindex === s.gzhead.extra.length) {\n        s.gzindex = 0;\n        s.status = NAME_STATE;\n      }\n    }\n    else {\n      s.status = NAME_STATE;\n    }\n  }\n  if (s.status === NAME_STATE) {\n    if (s.gzhead.name/* != Z_NULL*/) {\n      beg = s.pending;  /* start of bytes to update crc */\n      //int val;\n\n      do {\n        if (s.pending === s.pending_buf_size) {\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n          }\n          flush_pending(strm);\n          beg = s.pending;\n          if (s.pending === s.pending_buf_size) {\n            val = 1;\n            break;\n          }\n        }\n        // JS specific: little magic to add zero terminator to end of string\n        if (s.gzindex < s.gzhead.name.length) {\n          val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;\n        } else {\n          val = 0;\n        }\n        put_byte(s, val);\n      } while (val !== 0);\n\n      if (s.gzhead.hcrc && s.pending > beg) {\n        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n      }\n      if (val === 0) {\n        s.gzindex = 0;\n        s.status = COMMENT_STATE;\n      }\n    }\n    else {\n      s.status = COMMENT_STATE;\n    }\n  }\n  if (s.status === COMMENT_STATE) {\n    if (s.gzhead.comment/* != Z_NULL*/) {\n      beg = s.pending;  /* start of bytes to update crc */\n      //int val;\n\n      do {\n        if (s.pending === s.pending_buf_size) {\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n          }\n          flush_pending(strm);\n          beg = s.pending;\n          if (s.pending === s.pending_buf_size) {\n            val = 1;\n            break;\n          }\n        }\n        // JS specific: little magic to add zero terminator to end of string\n        if (s.gzindex < s.gzhead.comment.length) {\n          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;\n        } else {\n          val = 0;\n        }\n        put_byte(s, val);\n      } while (val !== 0);\n\n      if (s.gzhead.hcrc && s.pending > beg) {\n        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n      }\n      if (val === 0) {\n        s.status = HCRC_STATE;\n      }\n    }\n    else {\n      s.status = HCRC_STATE;\n    }\n  }\n  if (s.status === HCRC_STATE) {\n    if (s.gzhead.hcrc) {\n      if (s.pending + 2 > s.pending_buf_size) {\n        flush_pending(strm);\n      }\n      if (s.pending + 2 <= s.pending_buf_size) {\n        put_byte(s, strm.adler & 0xff);\n        put_byte(s, (strm.adler >> 8) & 0xff);\n        strm.adler = 0; //crc32(0L, Z_NULL, 0);\n        s.status = BUSY_STATE;\n      }\n    }\n    else {\n      s.status = BUSY_STATE;\n    }\n  }\n//#endif\n\n  /* Flush as much pending output as possible */\n  if (s.pending !== 0) {\n    flush_pending(strm);\n    if (strm.avail_out === 0) {\n      /* Since avail_out is 0, deflate will be called again with\n       * more output space, but possibly with both pending and\n       * avail_in equal to zero. There won't be anything to do,\n       * but this is not an error situation so make sure we\n       * return OK instead of BUF_ERROR at next call of deflate:\n       */\n      s.last_flush = -1;\n      return Z_OK;\n    }\n\n    /* Make sure there is something to do and avoid duplicate consecutive\n     * flushes. For repeated and useless calls with Z_FINISH, we keep\n     * returning Z_STREAM_END instead of Z_BUF_ERROR.\n     */\n  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) &&\n    flush !== Z_FINISH) {\n    return err(strm, Z_BUF_ERROR);\n  }\n\n  /* User must not provide more input after the first FINISH: */\n  if (s.status === FINISH_STATE && strm.avail_in !== 0) {\n    return err(strm, Z_BUF_ERROR);\n  }\n\n  /* Start a new block or continue the current one.\n   */\n  if (strm.avail_in !== 0 || s.lookahead !== 0 ||\n    (flush !== Z_NO_FLUSH && s.status !== FINISH_STATE)) {\n    var bstate = (s.strategy === Z_HUFFMAN_ONLY) ? deflate_huff(s, flush) :\n      (s.strategy === Z_RLE ? deflate_rle(s, flush) :\n        configuration_table[s.level].func(s, flush));\n\n    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {\n      s.status = FINISH_STATE;\n    }\n    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {\n      if (strm.avail_out === 0) {\n        s.last_flush = -1;\n        /* avoid BUF_ERROR next call, see above */\n      }\n      return Z_OK;\n      /* If flush != Z_NO_FLUSH && avail_out == 0, the next call\n       * of deflate should use the same flush parameter to make sure\n       * that the flush is complete. So we don't have to output an\n       * empty block here, this will be done at next call. This also\n       * ensures that for a very small output buffer, we emit at most\n       * one empty block.\n       */\n    }\n    if (bstate === BS_BLOCK_DONE) {\n      if (flush === Z_PARTIAL_FLUSH) {\n        trees._tr_align(s);\n      }\n      else if (flush !== Z_BLOCK) { /* FULL_FLUSH or SYNC_FLUSH */\n\n        trees._tr_stored_block(s, 0, 0, false);\n        /* For a full flush, this empty block will be recognized\n         * as a special marker by inflate_sync().\n         */\n        if (flush === Z_FULL_FLUSH) {\n          /*** CLEAR_HASH(s); ***/             /* forget history */\n          zero(s.head); // Fill with NIL (= 0);\n\n          if (s.lookahead === 0) {\n            s.strstart = 0;\n            s.block_start = 0;\n            s.insert = 0;\n          }\n        }\n      }\n      flush_pending(strm);\n      if (strm.avail_out === 0) {\n        s.last_flush = -1; /* avoid BUF_ERROR at next call, see above */\n        return Z_OK;\n      }\n    }\n  }\n  //Assert(strm->avail_out > 0, \"bug2\");\n  //if (strm.avail_out <= 0) { throw new Error(\"bug2\");}\n\n  if (flush !== Z_FINISH) { return Z_OK; }\n  if (s.wrap <= 0) { return Z_STREAM_END; }\n\n  /* Write the trailer */\n  if (s.wrap === 2) {\n    put_byte(s, strm.adler & 0xff);\n    put_byte(s, (strm.adler >> 8) & 0xff);\n    put_byte(s, (strm.adler >> 16) & 0xff);\n    put_byte(s, (strm.adler >> 24) & 0xff);\n    put_byte(s, strm.total_in & 0xff);\n    put_byte(s, (strm.total_in >> 8) & 0xff);\n    put_byte(s, (strm.total_in >> 16) & 0xff);\n    put_byte(s, (strm.total_in >> 24) & 0xff);\n  }\n  else\n  {\n    putShortMSB(s, strm.adler >>> 16);\n    putShortMSB(s, strm.adler & 0xffff);\n  }\n\n  flush_pending(strm);\n  /* If avail_out is zero, the application will call deflate again\n   * to flush the rest.\n   */\n  if (s.wrap > 0) { s.wrap = -s.wrap; }\n  /* write the trailer only once! */\n  return s.pending !== 0 ? Z_OK : Z_STREAM_END;\n}\n\nfunction deflateEnd(strm) {\n  var status;\n\n  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {\n    return Z_STREAM_ERROR;\n  }\n\n  status = strm.state.status;\n  if (status !== INIT_STATE &&\n    status !== EXTRA_STATE &&\n    status !== NAME_STATE &&\n    status !== COMMENT_STATE &&\n    status !== HCRC_STATE &&\n    status !== BUSY_STATE &&\n    status !== FINISH_STATE\n  ) {\n    return err(strm, Z_STREAM_ERROR);\n  }\n\n  strm.state = null;\n\n  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;\n}\n\n\n/* =========================================================================\n * Initializes the compression dictionary from the given byte\n * sequence without producing any compressed output.\n */\nfunction deflateSetDictionary(strm, dictionary) {\n  var dictLength = dictionary.length;\n\n  var s;\n  var str, n;\n  var wrap;\n  var avail;\n  var next;\n  var input;\n  var tmpDict;\n\n  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {\n    return Z_STREAM_ERROR;\n  }\n\n  s = strm.state;\n  wrap = s.wrap;\n\n  if (wrap === 2 || (wrap === 1 && s.status !== INIT_STATE) || s.lookahead) {\n    return Z_STREAM_ERROR;\n  }\n\n  /* when using zlib wrappers, compute Adler-32 for provided dictionary */\n  if (wrap === 1) {\n    /* adler32(strm->adler, dictionary, dictLength); */\n    strm.adler = adler32(strm.adler, dictionary, dictLength, 0);\n  }\n\n  s.wrap = 0;   /* avoid computing Adler-32 in read_buf */\n\n  /* if dictionary would fill window, just replace the history */\n  if (dictLength >= s.w_size) {\n    if (wrap === 0) {            /* already empty otherwise */\n      /*** CLEAR_HASH(s); ***/\n      zero(s.head); // Fill with NIL (= 0);\n      s.strstart = 0;\n      s.block_start = 0;\n      s.insert = 0;\n    }\n    /* use the tail */\n    // dictionary = dictionary.slice(dictLength - s.w_size);\n    tmpDict = new utils.Buf8(s.w_size);\n    utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);\n    dictionary = tmpDict;\n    dictLength = s.w_size;\n  }\n  /* insert dictionary into window and hash */\n  avail = strm.avail_in;\n  next = strm.next_in;\n  input = strm.input;\n  strm.avail_in = dictLength;\n  strm.next_in = 0;\n  strm.input = dictionary;\n  fill_window(s);\n  while (s.lookahead >= MIN_MATCH) {\n    str = s.strstart;\n    n = s.lookahead - (MIN_MATCH - 1);\n    do {\n      /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */\n      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;\n\n      s.prev[str & s.w_mask] = s.head[s.ins_h];\n\n      s.head[s.ins_h] = str;\n      str++;\n    } while (--n);\n    s.strstart = str;\n    s.lookahead = MIN_MATCH - 1;\n    fill_window(s);\n  }\n  s.strstart += s.lookahead;\n  s.block_start = s.strstart;\n  s.insert = s.lookahead;\n  s.lookahead = 0;\n  s.match_length = s.prev_length = MIN_MATCH - 1;\n  s.match_available = 0;\n  strm.next_in = next;\n  strm.input = input;\n  strm.avail_in = avail;\n  s.wrap = wrap;\n  return Z_OK;\n}\n\n\nexports.deflateInit = deflateInit;\nexports.deflateInit2 = deflateInit2;\nexports.deflateReset = deflateReset;\nexports.deflateResetKeep = deflateResetKeep;\nexports.deflateSetHeader = deflateSetHeader;\nexports.deflate = deflate;\nexports.deflateEnd = deflateEnd;\nexports.deflateSetDictionary = deflateSetDictionary;\nexports.deflateInfo = 'pako deflate (from Nodeca project)';\n\n/* Not implemented\nexports.deflateBound = deflateBound;\nexports.deflateCopy = deflateCopy;\nexports.deflateParams = deflateParams;\nexports.deflatePending = deflatePending;\nexports.deflatePrime = deflatePrime;\nexports.deflateTune = deflateTune;\n*/\n","'use strict';\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nfunction GZheader() {\n  /* true if compressed data believed to be text */\n  this.text       = 0;\n  /* modification time */\n  this.time       = 0;\n  /* extra flags (not used when writing a gzip file) */\n  this.xflags     = 0;\n  /* operating system */\n  this.os         = 0;\n  /* pointer to extra field or Z_NULL if none */\n  this.extra      = null;\n  /* extra field length (valid if extra != Z_NULL) */\n  this.extra_len  = 0; // Actually, we don't need it in JS,\n                       // but leave for few code modifications\n\n  //\n  // Setup limits is not necessary because in js we should not preallocate memory\n  // for inflate use constant limit in 65536 bytes\n  //\n\n  /* space at extra (only when reading header) */\n  // this.extra_max  = 0;\n  /* pointer to zero-terminated file name or Z_NULL */\n  this.name       = '';\n  /* space at name (only when reading header) */\n  // this.name_max   = 0;\n  /* pointer to zero-terminated comment or Z_NULL */\n  this.comment    = '';\n  /* space at comment (only when reading header) */\n  // this.comm_max   = 0;\n  /* true if there was or will be a header crc */\n  this.hcrc       = 0;\n  /* true when done reading gzip header (not used when writing a gzip file) */\n  this.done       = false;\n}\n\nmodule.exports = GZheader;\n","'use strict';\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\n// See state defs from inflate.js\nvar BAD = 30;       /* got a data error -- remain here until reset */\nvar TYPE = 12;      /* i: waiting for type bits, including last-flag bit */\n\n/*\n   Decode literal, length, and distance codes and write out the resulting\n   literal and match bytes until either not enough input or output is\n   available, an end-of-block is encountered, or a data error is encountered.\n   When large enough input and output buffers are supplied to inflate(), for\n   example, a 16K input buffer and a 64K output buffer, more than 95% of the\n   inflate execution time is spent in this routine.\n\n   Entry assumptions:\n\n        state.mode === LEN\n        strm.avail_in >= 6\n        strm.avail_out >= 258\n        start >= strm.avail_out\n        state.bits < 8\n\n   On return, state.mode is one of:\n\n        LEN -- ran out of enough output space or enough available input\n        TYPE -- reached end of block code, inflate() to interpret next block\n        BAD -- error in block data\n\n   Notes:\n\n    - The maximum input bits used by a length/distance pair is 15 bits for the\n      length code, 5 bits for the length extra, 15 bits for the distance code,\n      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.\n      Therefore if strm.avail_in >= 6, then there is enough input to avoid\n      checking for available input while decoding.\n\n    - The maximum bytes that a single length/distance pair can output is 258\n      bytes, which is the maximum length that can be coded.  inflate_fast()\n      requires strm.avail_out >= 258 for each loop to avoid checking for\n      output space.\n */\nmodule.exports = function inflate_fast(strm, start) {\n  var state;\n  var _in;                    /* local strm.input */\n  var last;                   /* have enough input while in < last */\n  var _out;                   /* local strm.output */\n  var beg;                    /* inflate()'s initial strm.output */\n  var end;                    /* while out < end, enough space available */\n//#ifdef INFLATE_STRICT\n  var dmax;                   /* maximum distance from zlib header */\n//#endif\n  var wsize;                  /* window size or zero if not using window */\n  var whave;                  /* valid bytes in the window */\n  var wnext;                  /* window write index */\n  // Use `s_window` instead `window`, avoid conflict with instrumentation tools\n  var s_window;               /* allocated sliding window, if wsize != 0 */\n  var hold;                   /* local strm.hold */\n  var bits;                   /* local strm.bits */\n  var lcode;                  /* local strm.lencode */\n  var dcode;                  /* local strm.distcode */\n  var lmask;                  /* mask for first level of length codes */\n  var dmask;                  /* mask for first level of distance codes */\n  var here;                   /* retrieved table entry */\n  var op;                     /* code bits, operation, extra bits, or */\n                              /*  window position, window bytes to copy */\n  var len;                    /* match length, unused bytes */\n  var dist;                   /* match distance */\n  var from;                   /* where to copy match from */\n  var from_source;\n\n\n  var input, output; // JS specific, because we have no pointers\n\n  /* copy state to local variables */\n  state = strm.state;\n  //here = state.here;\n  _in = strm.next_in;\n  input = strm.input;\n  last = _in + (strm.avail_in - 5);\n  _out = strm.next_out;\n  output = strm.output;\n  beg = _out - (start - strm.avail_out);\n  end = _out + (strm.avail_out - 257);\n//#ifdef INFLATE_STRICT\n  dmax = state.dmax;\n//#endif\n  wsize = state.wsize;\n  whave = state.whave;\n  wnext = state.wnext;\n  s_window = state.window;\n  hold = state.hold;\n  bits = state.bits;\n  lcode = state.lencode;\n  dcode = state.distcode;\n  lmask = (1 << state.lenbits) - 1;\n  dmask = (1 << state.distbits) - 1;\n\n\n  /* decode literals and length/distances until end-of-block or not enough\n     input data or output space */\n\n  top:\n  do {\n    if (bits < 15) {\n      hold += input[_in++] << bits;\n      bits += 8;\n      hold += input[_in++] << bits;\n      bits += 8;\n    }\n\n    here = lcode[hold & lmask];\n\n    dolen:\n    for (;;) { // Goto emulation\n      op = here >>> 24/*here.bits*/;\n      hold >>>= op;\n      bits -= op;\n      op = (here >>> 16) & 0xff/*here.op*/;\n      if (op === 0) {                          /* literal */\n        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?\n        //        \"inflate:         literal '%c'\\n\" :\n        //        \"inflate:         literal 0x%02x\\n\", here.val));\n        output[_out++] = here & 0xffff/*here.val*/;\n      }\n      else if (op & 16) {                     /* length base */\n        len = here & 0xffff/*here.val*/;\n        op &= 15;                           /* number of extra bits */\n        if (op) {\n          if (bits < op) {\n            hold += input[_in++] << bits;\n            bits += 8;\n          }\n          len += hold & ((1 << op) - 1);\n          hold >>>= op;\n          bits -= op;\n        }\n        //Tracevv((stderr, \"inflate:         length %u\\n\", len));\n        if (bits < 15) {\n          hold += input[_in++] << bits;\n          bits += 8;\n          hold += input[_in++] << bits;\n          bits += 8;\n        }\n        here = dcode[hold & dmask];\n\n        dodist:\n        for (;;) { // goto emulation\n          op = here >>> 24/*here.bits*/;\n          hold >>>= op;\n          bits -= op;\n          op = (here >>> 16) & 0xff/*here.op*/;\n\n          if (op & 16) {                      /* distance base */\n            dist = here & 0xffff/*here.val*/;\n            op &= 15;                       /* number of extra bits */\n            if (bits < op) {\n              hold += input[_in++] << bits;\n              bits += 8;\n              if (bits < op) {\n                hold += input[_in++] << bits;\n                bits += 8;\n              }\n            }\n            dist += hold & ((1 << op) - 1);\n//#ifdef INFLATE_STRICT\n            if (dist > dmax) {\n              strm.msg = 'invalid distance too far back';\n              state.mode = BAD;\n              break top;\n            }\n//#endif\n            hold >>>= op;\n            bits -= op;\n            //Tracevv((stderr, \"inflate:         distance %u\\n\", dist));\n            op = _out - beg;                /* max distance in output */\n            if (dist > op) {                /* see if copy from window */\n              op = dist - op;               /* distance back in window */\n              if (op > whave) {\n                if (state.sane) {\n                  strm.msg = 'invalid distance too far back';\n                  state.mode = BAD;\n                  break top;\n                }\n\n// (!) This block is disabled in zlib defaults,\n// don't enable it for binary compatibility\n//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR\n//                if (len <= op - whave) {\n//                  do {\n//                    output[_out++] = 0;\n//                  } while (--len);\n//                  continue top;\n//                }\n//                len -= op - whave;\n//                do {\n//                  output[_out++] = 0;\n//                } while (--op > whave);\n//                if (op === 0) {\n//                  from = _out - dist;\n//                  do {\n//                    output[_out++] = output[from++];\n//                  } while (--len);\n//                  continue top;\n//                }\n//#endif\n              }\n              from = 0; // window index\n              from_source = s_window;\n              if (wnext === 0) {           /* very common case */\n                from += wsize - op;\n                if (op < len) {         /* some from window */\n                  len -= op;\n                  do {\n                    output[_out++] = s_window[from++];\n                  } while (--op);\n                  from = _out - dist;  /* rest from output */\n                  from_source = output;\n                }\n              }\n              else if (wnext < op) {      /* wrap around window */\n                from += wsize + wnext - op;\n                op -= wnext;\n                if (op < len) {         /* some from end of window */\n                  len -= op;\n                  do {\n                    output[_out++] = s_window[from++];\n                  } while (--op);\n                  from = 0;\n                  if (wnext < len) {  /* some from start of window */\n                    op = wnext;\n                    len -= op;\n                    do {\n                      output[_out++] = s_window[from++];\n                    } while (--op);\n                    from = _out - dist;      /* rest from output */\n                    from_source = output;\n                  }\n                }\n              }\n              else {                      /* contiguous in window */\n                from += wnext - op;\n                if (op < len) {         /* some from window */\n                  len -= op;\n                  do {\n                    output[_out++] = s_window[from++];\n                  } while (--op);\n                  from = _out - dist;  /* rest from output */\n                  from_source = output;\n                }\n              }\n              while (len > 2) {\n                output[_out++] = from_source[from++];\n                output[_out++] = from_source[from++];\n                output[_out++] = from_source[from++];\n                len -= 3;\n              }\n              if (len) {\n                output[_out++] = from_source[from++];\n                if (len > 1) {\n                  output[_out++] = from_source[from++];\n                }\n              }\n            }\n            else {\n              from = _out - dist;          /* copy direct from output */\n              do {                        /* minimum length is three */\n                output[_out++] = output[from++];\n                output[_out++] = output[from++];\n                output[_out++] = output[from++];\n                len -= 3;\n              } while (len > 2);\n              if (len) {\n                output[_out++] = output[from++];\n                if (len > 1) {\n                  output[_out++] = output[from++];\n                }\n              }\n            }\n          }\n          else if ((op & 64) === 0) {          /* 2nd level distance code */\n            here = dcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];\n            continue dodist;\n          }\n          else {\n            strm.msg = 'invalid distance code';\n            state.mode = BAD;\n            break top;\n          }\n\n          break; // need to emulate goto via \"continue\"\n        }\n      }\n      else if ((op & 64) === 0) {              /* 2nd level length code */\n        here = lcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];\n        continue dolen;\n      }\n      else if (op & 32) {                     /* end-of-block */\n        //Tracevv((stderr, \"inflate:         end of block\\n\"));\n        state.mode = TYPE;\n        break top;\n      }\n      else {\n        strm.msg = 'invalid literal/length code';\n        state.mode = BAD;\n        break top;\n      }\n\n      break; // need to emulate goto via \"continue\"\n    }\n  } while (_in < last && _out < end);\n\n  /* return unused bytes (on entry, bits < 8, so in won't go too far back) */\n  len = bits >> 3;\n  _in -= len;\n  bits -= len << 3;\n  hold &= (1 << bits) - 1;\n\n  /* update state and return */\n  strm.next_in = _in;\n  strm.next_out = _out;\n  strm.avail_in = (_in < last ? 5 + (last - _in) : 5 - (_in - last));\n  strm.avail_out = (_out < end ? 257 + (end - _out) : 257 - (_out - end));\n  state.hold = hold;\n  state.bits = bits;\n  return;\n};\n","'use strict';\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nvar utils         = require('../utils/common');\nvar adler32       = require('./adler32');\nvar crc32         = require('./crc32');\nvar inflate_fast  = require('./inffast');\nvar inflate_table = require('./inftrees');\n\nvar CODES = 0;\nvar LENS = 1;\nvar DISTS = 2;\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\n\n/* Allowed flush values; see deflate() and inflate() below for details */\n//var Z_NO_FLUSH      = 0;\n//var Z_PARTIAL_FLUSH = 1;\n//var Z_SYNC_FLUSH    = 2;\n//var Z_FULL_FLUSH    = 3;\nvar Z_FINISH        = 4;\nvar Z_BLOCK         = 5;\nvar Z_TREES         = 6;\n\n\n/* Return codes for the compression/decompression functions. Negative values\n * are errors, positive values are used for special but normal events.\n */\nvar Z_OK            = 0;\nvar Z_STREAM_END    = 1;\nvar Z_NEED_DICT     = 2;\n//var Z_ERRNO         = -1;\nvar Z_STREAM_ERROR  = -2;\nvar Z_DATA_ERROR    = -3;\nvar Z_MEM_ERROR     = -4;\nvar Z_BUF_ERROR     = -5;\n//var Z_VERSION_ERROR = -6;\n\n/* The deflate compression method */\nvar Z_DEFLATED  = 8;\n\n\n/* STATES ====================================================================*/\n/* ===========================================================================*/\n\n\nvar    HEAD = 1;       /* i: waiting for magic header */\nvar    FLAGS = 2;      /* i: waiting for method and flags (gzip) */\nvar    TIME = 3;       /* i: waiting for modification time (gzip) */\nvar    OS = 4;         /* i: waiting for extra flags and operating system (gzip) */\nvar    EXLEN = 5;      /* i: waiting for extra length (gzip) */\nvar    EXTRA = 6;      /* i: waiting for extra bytes (gzip) */\nvar    NAME = 7;       /* i: waiting for end of file name (gzip) */\nvar    COMMENT = 8;    /* i: waiting for end of comment (gzip) */\nvar    HCRC = 9;       /* i: waiting for header crc (gzip) */\nvar    DICTID = 10;    /* i: waiting for dictionary check value */\nvar    DICT = 11;      /* waiting for inflateSetDictionary() call */\nvar        TYPE = 12;      /* i: waiting for type bits, including last-flag bit */\nvar        TYPEDO = 13;    /* i: same, but skip check to exit inflate on new block */\nvar        STORED = 14;    /* i: waiting for stored size (length and complement) */\nvar        COPY_ = 15;     /* i/o: same as COPY below, but only first time in */\nvar        COPY = 16;      /* i/o: waiting for input or output to copy stored block */\nvar        TABLE = 17;     /* i: waiting for dynamic block table lengths */\nvar        LENLENS = 18;   /* i: waiting for code length code lengths */\nvar        CODELENS = 19;  /* i: waiting for length/lit and distance code lengths */\nvar            LEN_ = 20;      /* i: same as LEN below, but only first time in */\nvar            LEN = 21;       /* i: waiting for length/lit/eob code */\nvar            LENEXT = 22;    /* i: waiting for length extra bits */\nvar            DIST = 23;      /* i: waiting for distance code */\nvar            DISTEXT = 24;   /* i: waiting for distance extra bits */\nvar            MATCH = 25;     /* o: waiting for output space to copy string */\nvar            LIT = 26;       /* o: waiting for output space to write literal */\nvar    CHECK = 27;     /* i: waiting for 32-bit check value */\nvar    LENGTH = 28;    /* i: waiting for 32-bit length (gzip) */\nvar    DONE = 29;      /* finished check, done -- remain here until reset */\nvar    BAD = 30;       /* got a data error -- remain here until reset */\nvar    MEM = 31;       /* got an inflate() memory error -- remain here until reset */\nvar    SYNC = 32;      /* looking for synchronization bytes to restart inflate() */\n\n/* ===========================================================================*/\n\n\n\nvar ENOUGH_LENS = 852;\nvar ENOUGH_DISTS = 592;\n//var ENOUGH =  (ENOUGH_LENS+ENOUGH_DISTS);\n\nvar MAX_WBITS = 15;\n/* 32K LZ77 window */\nvar DEF_WBITS = MAX_WBITS;\n\n\nfunction zswap32(q) {\n  return  (((q >>> 24) & 0xff) +\n          ((q >>> 8) & 0xff00) +\n          ((q & 0xff00) << 8) +\n          ((q & 0xff) << 24));\n}\n\n\nfunction InflateState() {\n  this.mode = 0;             /* current inflate mode */\n  this.last = false;          /* true if processing last block */\n  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */\n  this.havedict = false;      /* true if dictionary provided */\n  this.flags = 0;             /* gzip header method and flags (0 if zlib) */\n  this.dmax = 0;              /* zlib header max distance (INFLATE_STRICT) */\n  this.check = 0;             /* protected copy of check value */\n  this.total = 0;             /* protected copy of output count */\n  // TODO: may be {}\n  this.head = null;           /* where to save gzip header information */\n\n  /* sliding window */\n  this.wbits = 0;             /* log base 2 of requested window size */\n  this.wsize = 0;             /* window size or zero if not using window */\n  this.whave = 0;             /* valid bytes in the window */\n  this.wnext = 0;             /* window write index */\n  this.window = null;         /* allocated sliding window, if needed */\n\n  /* bit accumulator */\n  this.hold = 0;              /* input bit accumulator */\n  this.bits = 0;              /* number of bits in \"in\" */\n\n  /* for string and stored block copying */\n  this.length = 0;            /* literal or length of data to copy */\n  this.offset = 0;            /* distance back to copy string from */\n\n  /* for table and code decoding */\n  this.extra = 0;             /* extra bits needed */\n\n  /* fixed and dynamic code tables */\n  this.lencode = null;          /* starting table for length/literal codes */\n  this.distcode = null;         /* starting table for distance codes */\n  this.lenbits = 0;           /* index bits for lencode */\n  this.distbits = 0;          /* index bits for distcode */\n\n  /* dynamic table building */\n  this.ncode = 0;             /* number of code length code lengths */\n  this.nlen = 0;              /* number of length code lengths */\n  this.ndist = 0;             /* number of distance code lengths */\n  this.have = 0;              /* number of code lengths in lens[] */\n  this.next = null;              /* next available space in codes[] */\n\n  this.lens = new utils.Buf16(320); /* temporary storage for code lengths */\n  this.work = new utils.Buf16(288); /* work area for code table building */\n\n  /*\n   because we don't have pointers in js, we use lencode and distcode directly\n   as buffers so we don't need codes\n  */\n  //this.codes = new utils.Buf32(ENOUGH);       /* space for code tables */\n  this.lendyn = null;              /* dynamic table for length/literal codes (JS specific) */\n  this.distdyn = null;             /* dynamic table for distance codes (JS specific) */\n  this.sane = 0;                   /* if false, allow invalid distance too far */\n  this.back = 0;                   /* bits back of last unprocessed length/lit */\n  this.was = 0;                    /* initial length of match */\n}\n\nfunction inflateResetKeep(strm) {\n  var state;\n\n  if (!strm || !strm.state) { return Z_STREAM_ERROR; }\n  state = strm.state;\n  strm.total_in = strm.total_out = state.total = 0;\n  strm.msg = ''; /*Z_NULL*/\n  if (state.wrap) {       /* to support ill-conceived Java test suite */\n    strm.adler = state.wrap & 1;\n  }\n  state.mode = HEAD;\n  state.last = 0;\n  state.havedict = 0;\n  state.dmax = 32768;\n  state.head = null/*Z_NULL*/;\n  state.hold = 0;\n  state.bits = 0;\n  //state.lencode = state.distcode = state.next = state.codes;\n  state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);\n  state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);\n\n  state.sane = 1;\n  state.back = -1;\n  //Tracev((stderr, \"inflate: reset\\n\"));\n  return Z_OK;\n}\n\nfunction inflateReset(strm) {\n  var state;\n\n  if (!strm || !strm.state) { return Z_STREAM_ERROR; }\n  state = strm.state;\n  state.wsize = 0;\n  state.whave = 0;\n  state.wnext = 0;\n  return inflateResetKeep(strm);\n\n}\n\nfunction inflateReset2(strm, windowBits) {\n  var wrap;\n  var state;\n\n  /* get the state */\n  if (!strm || !strm.state) { return Z_STREAM_ERROR; }\n  state = strm.state;\n\n  /* extract wrap request from windowBits parameter */\n  if (windowBits < 0) {\n    wrap = 0;\n    windowBits = -windowBits;\n  }\n  else {\n    wrap = (windowBits >> 4) + 1;\n    if (windowBits < 48) {\n      windowBits &= 15;\n    }\n  }\n\n  /* set number of window bits, free window if different */\n  if (windowBits && (windowBits < 8 || windowBits > 15)) {\n    return Z_STREAM_ERROR;\n  }\n  if (state.window !== null && state.wbits !== windowBits) {\n    state.window = null;\n  }\n\n  /* update state and reset the rest of it */\n  state.wrap = wrap;\n  state.wbits = windowBits;\n  return inflateReset(strm);\n}\n\nfunction inflateInit2(strm, windowBits) {\n  var ret;\n  var state;\n\n  if (!strm) { return Z_STREAM_ERROR; }\n  //strm.msg = Z_NULL;                 /* in case we return an error */\n\n  state = new InflateState();\n\n  //if (state === Z_NULL) return Z_MEM_ERROR;\n  //Tracev((stderr, \"inflate: allocated\\n\"));\n  strm.state = state;\n  state.window = null/*Z_NULL*/;\n  ret = inflateReset2(strm, windowBits);\n  if (ret !== Z_OK) {\n    strm.state = null/*Z_NULL*/;\n  }\n  return ret;\n}\n\nfunction inflateInit(strm) {\n  return inflateInit2(strm, DEF_WBITS);\n}\n\n\n/*\n Return state with length and distance decoding tables and index sizes set to\n fixed code decoding.  Normally this returns fixed tables from inffixed.h.\n If BUILDFIXED is defined, then instead this routine builds the tables the\n first time it's called, and returns those tables the first time and\n thereafter.  This reduces the size of the code by about 2K bytes, in\n exchange for a little execution time.  However, BUILDFIXED should not be\n used for threaded applications, since the rewriting of the tables and virgin\n may not be thread-safe.\n */\nvar virgin = true;\n\nvar lenfix, distfix; // We have no pointers in JS, so keep tables separate\n\nfunction fixedtables(state) {\n  /* build fixed huffman tables if first call (may not be thread safe) */\n  if (virgin) {\n    var sym;\n\n    lenfix = new utils.Buf32(512);\n    distfix = new utils.Buf32(32);\n\n    /* literal/length table */\n    sym = 0;\n    while (sym < 144) { state.lens[sym++] = 8; }\n    while (sym < 256) { state.lens[sym++] = 9; }\n    while (sym < 280) { state.lens[sym++] = 7; }\n    while (sym < 288) { state.lens[sym++] = 8; }\n\n    inflate_table(LENS,  state.lens, 0, 288, lenfix,   0, state.work, { bits: 9 });\n\n    /* distance table */\n    sym = 0;\n    while (sym < 32) { state.lens[sym++] = 5; }\n\n    inflate_table(DISTS, state.lens, 0, 32,   distfix, 0, state.work, { bits: 5 });\n\n    /* do this just once */\n    virgin = false;\n  }\n\n  state.lencode = lenfix;\n  state.lenbits = 9;\n  state.distcode = distfix;\n  state.distbits = 5;\n}\n\n\n/*\n Update the window with the last wsize (normally 32K) bytes written before\n returning.  If window does not exist yet, create it.  This is only called\n when a window is already in use, or when output has been written during this\n inflate call, but the end of the deflate stream has not been reached yet.\n It is also called to create a window for dictionary data when a dictionary\n is loaded.\n\n Providing output buffers larger than 32K to inflate() should provide a speed\n advantage, since only the last 32K of output is copied to the sliding window\n upon return from inflate(), and since all distances after the first 32K of\n output will fall in the output data, making match copies simpler and faster.\n The advantage may be dependent on the size of the processor's data caches.\n */\nfunction updatewindow(strm, src, end, copy) {\n  var dist;\n  var state = strm.state;\n\n  /* if it hasn't been done already, allocate space for the window */\n  if (state.window === null) {\n    state.wsize = 1 << state.wbits;\n    state.wnext = 0;\n    state.whave = 0;\n\n    state.window = new utils.Buf8(state.wsize);\n  }\n\n  /* copy state->wsize or less output bytes into the circular window */\n  if (copy >= state.wsize) {\n    utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);\n    state.wnext = 0;\n    state.whave = state.wsize;\n  }\n  else {\n    dist = state.wsize - state.wnext;\n    if (dist > copy) {\n      dist = copy;\n    }\n    //zmemcpy(state->window + state->wnext, end - copy, dist);\n    utils.arraySet(state.window, src, end - copy, dist, state.wnext);\n    copy -= dist;\n    if (copy) {\n      //zmemcpy(state->window, end - copy, copy);\n      utils.arraySet(state.window, src, end - copy, copy, 0);\n      state.wnext = copy;\n      state.whave = state.wsize;\n    }\n    else {\n      state.wnext += dist;\n      if (state.wnext === state.wsize) { state.wnext = 0; }\n      if (state.whave < state.wsize) { state.whave += dist; }\n    }\n  }\n  return 0;\n}\n\nfunction inflate(strm, flush) {\n  var state;\n  var input, output;          // input/output buffers\n  var next;                   /* next input INDEX */\n  var put;                    /* next output INDEX */\n  var have, left;             /* available input and output */\n  var hold;                   /* bit buffer */\n  var bits;                   /* bits in bit buffer */\n  var _in, _out;              /* save starting available input and output */\n  var copy;                   /* number of stored or match bytes to copy */\n  var from;                   /* where to copy match bytes from */\n  var from_source;\n  var here = 0;               /* current decoding table entry */\n  var here_bits, here_op, here_val; // paked \"here\" denormalized (JS specific)\n  //var last;                   /* parent table entry */\n  var last_bits, last_op, last_val; // paked \"last\" denormalized (JS specific)\n  var len;                    /* length to copy for repeats, bits to drop */\n  var ret;                    /* return code */\n  var hbuf = new utils.Buf8(4);    /* buffer for gzip header crc calculation */\n  var opts;\n\n  var n; // temporary var for NEED_BITS\n\n  var order = /* permutation of code lengths */\n    [ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ];\n\n\n  if (!strm || !strm.state || !strm.output ||\n      (!strm.input && strm.avail_in !== 0)) {\n    return Z_STREAM_ERROR;\n  }\n\n  state = strm.state;\n  if (state.mode === TYPE) { state.mode = TYPEDO; }    /* skip check */\n\n\n  //--- LOAD() ---\n  put = strm.next_out;\n  output = strm.output;\n  left = strm.avail_out;\n  next = strm.next_in;\n  input = strm.input;\n  have = strm.avail_in;\n  hold = state.hold;\n  bits = state.bits;\n  //---\n\n  _in = have;\n  _out = left;\n  ret = Z_OK;\n\n  inf_leave: // goto emulation\n  for (;;) {\n    switch (state.mode) {\n      case HEAD:\n        if (state.wrap === 0) {\n          state.mode = TYPEDO;\n          break;\n        }\n        //=== NEEDBITS(16);\n        while (bits < 16) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        if ((state.wrap & 2) && hold === 0x8b1f) {  /* gzip header */\n          state.check = 0/*crc32(0L, Z_NULL, 0)*/;\n          //=== CRC2(state.check, hold);\n          hbuf[0] = hold & 0xff;\n          hbuf[1] = (hold >>> 8) & 0xff;\n          state.check = crc32(state.check, hbuf, 2, 0);\n          //===//\n\n          //=== INITBITS();\n          hold = 0;\n          bits = 0;\n          //===//\n          state.mode = FLAGS;\n          break;\n        }\n        state.flags = 0;           /* expect zlib header */\n        if (state.head) {\n          state.head.done = false;\n        }\n        if (!(state.wrap & 1) ||   /* check if zlib header allowed */\n          (((hold & 0xff)/*BITS(8)*/ << 8) + (hold >> 8)) % 31) {\n          strm.msg = 'incorrect header check';\n          state.mode = BAD;\n          break;\n        }\n        if ((hold & 0x0f)/*BITS(4)*/ !== Z_DEFLATED) {\n          strm.msg = 'unknown compression method';\n          state.mode = BAD;\n          break;\n        }\n        //--- DROPBITS(4) ---//\n        hold >>>= 4;\n        bits -= 4;\n        //---//\n        len = (hold & 0x0f)/*BITS(4)*/ + 8;\n        if (state.wbits === 0) {\n          state.wbits = len;\n        }\n        else if (len > state.wbits) {\n          strm.msg = 'invalid window size';\n          state.mode = BAD;\n          break;\n        }\n        state.dmax = 1 << len;\n        //Tracev((stderr, \"inflate:   zlib header ok\\n\"));\n        strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;\n        state.mode = hold & 0x200 ? DICTID : TYPE;\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        break;\n      case FLAGS:\n        //=== NEEDBITS(16); */\n        while (bits < 16) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        state.flags = hold;\n        if ((state.flags & 0xff) !== Z_DEFLATED) {\n          strm.msg = 'unknown compression method';\n          state.mode = BAD;\n          break;\n        }\n        if (state.flags & 0xe000) {\n          strm.msg = 'unknown header flags set';\n          state.mode = BAD;\n          break;\n        }\n        if (state.head) {\n          state.head.text = ((hold >> 8) & 1);\n        }\n        if (state.flags & 0x0200) {\n          //=== CRC2(state.check, hold);\n          hbuf[0] = hold & 0xff;\n          hbuf[1] = (hold >>> 8) & 0xff;\n          state.check = crc32(state.check, hbuf, 2, 0);\n          //===//\n        }\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        state.mode = TIME;\n        /* falls through */\n      case TIME:\n        //=== NEEDBITS(32); */\n        while (bits < 32) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        if (state.head) {\n          state.head.time = hold;\n        }\n        if (state.flags & 0x0200) {\n          //=== CRC4(state.check, hold)\n          hbuf[0] = hold & 0xff;\n          hbuf[1] = (hold >>> 8) & 0xff;\n          hbuf[2] = (hold >>> 16) & 0xff;\n          hbuf[3] = (hold >>> 24) & 0xff;\n          state.check = crc32(state.check, hbuf, 4, 0);\n          //===\n        }\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        state.mode = OS;\n        /* falls through */\n      case OS:\n        //=== NEEDBITS(16); */\n        while (bits < 16) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        if (state.head) {\n          state.head.xflags = (hold & 0xff);\n          state.head.os = (hold >> 8);\n        }\n        if (state.flags & 0x0200) {\n          //=== CRC2(state.check, hold);\n          hbuf[0] = hold & 0xff;\n          hbuf[1] = (hold >>> 8) & 0xff;\n          state.check = crc32(state.check, hbuf, 2, 0);\n          //===//\n        }\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        state.mode = EXLEN;\n        /* falls through */\n      case EXLEN:\n        if (state.flags & 0x0400) {\n          //=== NEEDBITS(16); */\n          while (bits < 16) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          state.length = hold;\n          if (state.head) {\n            state.head.extra_len = hold;\n          }\n          if (state.flags & 0x0200) {\n            //=== CRC2(state.check, hold);\n            hbuf[0] = hold & 0xff;\n            hbuf[1] = (hold >>> 8) & 0xff;\n            state.check = crc32(state.check, hbuf, 2, 0);\n            //===//\n          }\n          //=== INITBITS();\n          hold = 0;\n          bits = 0;\n          //===//\n        }\n        else if (state.head) {\n          state.head.extra = null/*Z_NULL*/;\n        }\n        state.mode = EXTRA;\n        /* falls through */\n      case EXTRA:\n        if (state.flags & 0x0400) {\n          copy = state.length;\n          if (copy > have) { copy = have; }\n          if (copy) {\n            if (state.head) {\n              len = state.head.extra_len - state.length;\n              if (!state.head.extra) {\n                // Use untyped array for more convenient processing later\n                state.head.extra = new Array(state.head.extra_len);\n              }\n              utils.arraySet(\n                state.head.extra,\n                input,\n                next,\n                // extra field is limited to 65536 bytes\n                // - no need for additional size check\n                copy,\n                /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/\n                len\n              );\n              //zmemcpy(state.head.extra + len, next,\n              //        len + copy > state.head.extra_max ?\n              //        state.head.extra_max - len : copy);\n            }\n            if (state.flags & 0x0200) {\n              state.check = crc32(state.check, input, copy, next);\n            }\n            have -= copy;\n            next += copy;\n            state.length -= copy;\n          }\n          if (state.length) { break inf_leave; }\n        }\n        state.length = 0;\n        state.mode = NAME;\n        /* falls through */\n      case NAME:\n        if (state.flags & 0x0800) {\n          if (have === 0) { break inf_leave; }\n          copy = 0;\n          do {\n            // TODO: 2 or 1 bytes?\n            len = input[next + copy++];\n            /* use constant limit because in js we should not preallocate memory */\n            if (state.head && len &&\n                (state.length < 65536 /*state.head.name_max*/)) {\n              state.head.name += String.fromCharCode(len);\n            }\n          } while (len && copy < have);\n\n          if (state.flags & 0x0200) {\n            state.check = crc32(state.check, input, copy, next);\n          }\n          have -= copy;\n          next += copy;\n          if (len) { break inf_leave; }\n        }\n        else if (state.head) {\n          state.head.name = null;\n        }\n        state.length = 0;\n        state.mode = COMMENT;\n        /* falls through */\n      case COMMENT:\n        if (state.flags & 0x1000) {\n          if (have === 0) { break inf_leave; }\n          copy = 0;\n          do {\n            len = input[next + copy++];\n            /* use constant limit because in js we should not preallocate memory */\n            if (state.head && len &&\n                (state.length < 65536 /*state.head.comm_max*/)) {\n              state.head.comment += String.fromCharCode(len);\n            }\n          } while (len && copy < have);\n          if (state.flags & 0x0200) {\n            state.check = crc32(state.check, input, copy, next);\n          }\n          have -= copy;\n          next += copy;\n          if (len) { break inf_leave; }\n        }\n        else if (state.head) {\n          state.head.comment = null;\n        }\n        state.mode = HCRC;\n        /* falls through */\n      case HCRC:\n        if (state.flags & 0x0200) {\n          //=== NEEDBITS(16); */\n          while (bits < 16) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          if (hold !== (state.check & 0xffff)) {\n            strm.msg = 'header crc mismatch';\n            state.mode = BAD;\n            break;\n          }\n          //=== INITBITS();\n          hold = 0;\n          bits = 0;\n          //===//\n        }\n        if (state.head) {\n          state.head.hcrc = ((state.flags >> 9) & 1);\n          state.head.done = true;\n        }\n        strm.adler = state.check = 0;\n        state.mode = TYPE;\n        break;\n      case DICTID:\n        //=== NEEDBITS(32); */\n        while (bits < 32) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        strm.adler = state.check = zswap32(hold);\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        state.mode = DICT;\n        /* falls through */\n      case DICT:\n        if (state.havedict === 0) {\n          //--- RESTORE() ---\n          strm.next_out = put;\n          strm.avail_out = left;\n          strm.next_in = next;\n          strm.avail_in = have;\n          state.hold = hold;\n          state.bits = bits;\n          //---\n          return Z_NEED_DICT;\n        }\n        strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;\n        state.mode = TYPE;\n        /* falls through */\n      case TYPE:\n        if (flush === Z_BLOCK || flush === Z_TREES) { break inf_leave; }\n        /* falls through */\n      case TYPEDO:\n        if (state.last) {\n          //--- BYTEBITS() ---//\n          hold >>>= bits & 7;\n          bits -= bits & 7;\n          //---//\n          state.mode = CHECK;\n          break;\n        }\n        //=== NEEDBITS(3); */\n        while (bits < 3) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        state.last = (hold & 0x01)/*BITS(1)*/;\n        //--- DROPBITS(1) ---//\n        hold >>>= 1;\n        bits -= 1;\n        //---//\n\n        switch ((hold & 0x03)/*BITS(2)*/) {\n          case 0:                             /* stored block */\n            //Tracev((stderr, \"inflate:     stored block%s\\n\",\n            //        state.last ? \" (last)\" : \"\"));\n            state.mode = STORED;\n            break;\n          case 1:                             /* fixed block */\n            fixedtables(state);\n            //Tracev((stderr, \"inflate:     fixed codes block%s\\n\",\n            //        state.last ? \" (last)\" : \"\"));\n            state.mode = LEN_;             /* decode codes */\n            if (flush === Z_TREES) {\n              //--- DROPBITS(2) ---//\n              hold >>>= 2;\n              bits -= 2;\n              //---//\n              break inf_leave;\n            }\n            break;\n          case 2:                             /* dynamic block */\n            //Tracev((stderr, \"inflate:     dynamic codes block%s\\n\",\n            //        state.last ? \" (last)\" : \"\"));\n            state.mode = TABLE;\n            break;\n          case 3:\n            strm.msg = 'invalid block type';\n            state.mode = BAD;\n        }\n        //--- DROPBITS(2) ---//\n        hold >>>= 2;\n        bits -= 2;\n        //---//\n        break;\n      case STORED:\n        //--- BYTEBITS() ---// /* go to byte boundary */\n        hold >>>= bits & 7;\n        bits -= bits & 7;\n        //---//\n        //=== NEEDBITS(32); */\n        while (bits < 32) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        if ((hold & 0xffff) !== ((hold >>> 16) ^ 0xffff)) {\n          strm.msg = 'invalid stored block lengths';\n          state.mode = BAD;\n          break;\n        }\n        state.length = hold & 0xffff;\n        //Tracev((stderr, \"inflate:       stored length %u\\n\",\n        //        state.length));\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        state.mode = COPY_;\n        if (flush === Z_TREES) { break inf_leave; }\n        /* falls through */\n      case COPY_:\n        state.mode = COPY;\n        /* falls through */\n      case COPY:\n        copy = state.length;\n        if (copy) {\n          if (copy > have) { copy = have; }\n          if (copy > left) { copy = left; }\n          if (copy === 0) { break inf_leave; }\n          //--- zmemcpy(put, next, copy); ---\n          utils.arraySet(output, input, next, copy, put);\n          //---//\n          have -= copy;\n          next += copy;\n          left -= copy;\n          put += copy;\n          state.length -= copy;\n          break;\n        }\n        //Tracev((stderr, \"inflate:       stored end\\n\"));\n        state.mode = TYPE;\n        break;\n      case TABLE:\n        //=== NEEDBITS(14); */\n        while (bits < 14) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        state.nlen = (hold & 0x1f)/*BITS(5)*/ + 257;\n        //--- DROPBITS(5) ---//\n        hold >>>= 5;\n        bits -= 5;\n        //---//\n        state.ndist = (hold & 0x1f)/*BITS(5)*/ + 1;\n        //--- DROPBITS(5) ---//\n        hold >>>= 5;\n        bits -= 5;\n        //---//\n        state.ncode = (hold & 0x0f)/*BITS(4)*/ + 4;\n        //--- DROPBITS(4) ---//\n        hold >>>= 4;\n        bits -= 4;\n        //---//\n//#ifndef PKZIP_BUG_WORKAROUND\n        if (state.nlen > 286 || state.ndist > 30) {\n          strm.msg = 'too many length or distance symbols';\n          state.mode = BAD;\n          break;\n        }\n//#endif\n        //Tracev((stderr, \"inflate:       table sizes ok\\n\"));\n        state.have = 0;\n        state.mode = LENLENS;\n        /* falls through */\n      case LENLENS:\n        while (state.have < state.ncode) {\n          //=== NEEDBITS(3);\n          while (bits < 3) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          state.lens[order[state.have++]] = (hold & 0x07);//BITS(3);\n          //--- DROPBITS(3) ---//\n          hold >>>= 3;\n          bits -= 3;\n          //---//\n        }\n        while (state.have < 19) {\n          state.lens[order[state.have++]] = 0;\n        }\n        // We have separate tables & no pointers. 2 commented lines below not needed.\n        //state.next = state.codes;\n        //state.lencode = state.next;\n        // Switch to use dynamic table\n        state.lencode = state.lendyn;\n        state.lenbits = 7;\n\n        opts = { bits: state.lenbits };\n        ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);\n        state.lenbits = opts.bits;\n\n        if (ret) {\n          strm.msg = 'invalid code lengths set';\n          state.mode = BAD;\n          break;\n        }\n        //Tracev((stderr, \"inflate:       code lengths ok\\n\"));\n        state.have = 0;\n        state.mode = CODELENS;\n        /* falls through */\n      case CODELENS:\n        while (state.have < state.nlen + state.ndist) {\n          for (;;) {\n            here = state.lencode[hold & ((1 << state.lenbits) - 1)];/*BITS(state.lenbits)*/\n            here_bits = here >>> 24;\n            here_op = (here >>> 16) & 0xff;\n            here_val = here & 0xffff;\n\n            if ((here_bits) <= bits) { break; }\n            //--- PULLBYTE() ---//\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n            //---//\n          }\n          if (here_val < 16) {\n            //--- DROPBITS(here.bits) ---//\n            hold >>>= here_bits;\n            bits -= here_bits;\n            //---//\n            state.lens[state.have++] = here_val;\n          }\n          else {\n            if (here_val === 16) {\n              //=== NEEDBITS(here.bits + 2);\n              n = here_bits + 2;\n              while (bits < n) {\n                if (have === 0) { break inf_leave; }\n                have--;\n                hold += input[next++] << bits;\n                bits += 8;\n              }\n              //===//\n              //--- DROPBITS(here.bits) ---//\n              hold >>>= here_bits;\n              bits -= here_bits;\n              //---//\n              if (state.have === 0) {\n                strm.msg = 'invalid bit length repeat';\n                state.mode = BAD;\n                break;\n              }\n              len = state.lens[state.have - 1];\n              copy = 3 + (hold & 0x03);//BITS(2);\n              //--- DROPBITS(2) ---//\n              hold >>>= 2;\n              bits -= 2;\n              //---//\n            }\n            else if (here_val === 17) {\n              //=== NEEDBITS(here.bits + 3);\n              n = here_bits + 3;\n              while (bits < n) {\n                if (have === 0) { break inf_leave; }\n                have--;\n                hold += input[next++] << bits;\n                bits += 8;\n              }\n              //===//\n              //--- DROPBITS(here.bits) ---//\n              hold >>>= here_bits;\n              bits -= here_bits;\n              //---//\n              len = 0;\n              copy = 3 + (hold & 0x07);//BITS(3);\n              //--- DROPBITS(3) ---//\n              hold >>>= 3;\n              bits -= 3;\n              //---//\n            }\n            else {\n              //=== NEEDBITS(here.bits + 7);\n              n = here_bits + 7;\n              while (bits < n) {\n                if (have === 0) { break inf_leave; }\n                have--;\n                hold += input[next++] << bits;\n                bits += 8;\n              }\n              //===//\n              //--- DROPBITS(here.bits) ---//\n              hold >>>= here_bits;\n              bits -= here_bits;\n              //---//\n              len = 0;\n              copy = 11 + (hold & 0x7f);//BITS(7);\n              //--- DROPBITS(7) ---//\n              hold >>>= 7;\n              bits -= 7;\n              //---//\n            }\n            if (state.have + copy > state.nlen + state.ndist) {\n              strm.msg = 'invalid bit length repeat';\n              state.mode = BAD;\n              break;\n            }\n            while (copy--) {\n              state.lens[state.have++] = len;\n            }\n          }\n        }\n\n        /* handle error breaks in while */\n        if (state.mode === BAD) { break; }\n\n        /* check for end-of-block code (better have one) */\n        if (state.lens[256] === 0) {\n          strm.msg = 'invalid code -- missing end-of-block';\n          state.mode = BAD;\n          break;\n        }\n\n        /* build code tables -- note: do not change the lenbits or distbits\n           values here (9 and 6) without reading the comments in inftrees.h\n           concerning the ENOUGH constants, which depend on those values */\n        state.lenbits = 9;\n\n        opts = { bits: state.lenbits };\n        ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);\n        // We have separate tables & no pointers. 2 commented lines below not needed.\n        // state.next_index = opts.table_index;\n        state.lenbits = opts.bits;\n        // state.lencode = state.next;\n\n        if (ret) {\n          strm.msg = 'invalid literal/lengths set';\n          state.mode = BAD;\n          break;\n        }\n\n        state.distbits = 6;\n        //state.distcode.copy(state.codes);\n        // Switch to use dynamic table\n        state.distcode = state.distdyn;\n        opts = { bits: state.distbits };\n        ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);\n        // We have separate tables & no pointers. 2 commented lines below not needed.\n        // state.next_index = opts.table_index;\n        state.distbits = opts.bits;\n        // state.distcode = state.next;\n\n        if (ret) {\n          strm.msg = 'invalid distances set';\n          state.mode = BAD;\n          break;\n        }\n        //Tracev((stderr, 'inflate:       codes ok\\n'));\n        state.mode = LEN_;\n        if (flush === Z_TREES) { break inf_leave; }\n        /* falls through */\n      case LEN_:\n        state.mode = LEN;\n        /* falls through */\n      case LEN:\n        if (have >= 6 && left >= 258) {\n          //--- RESTORE() ---\n          strm.next_out = put;\n          strm.avail_out = left;\n          strm.next_in = next;\n          strm.avail_in = have;\n          state.hold = hold;\n          state.bits = bits;\n          //---\n          inflate_fast(strm, _out);\n          //--- LOAD() ---\n          put = strm.next_out;\n          output = strm.output;\n          left = strm.avail_out;\n          next = strm.next_in;\n          input = strm.input;\n          have = strm.avail_in;\n          hold = state.hold;\n          bits = state.bits;\n          //---\n\n          if (state.mode === TYPE) {\n            state.back = -1;\n          }\n          break;\n        }\n        state.back = 0;\n        for (;;) {\n          here = state.lencode[hold & ((1 << state.lenbits) - 1)];  /*BITS(state.lenbits)*/\n          here_bits = here >>> 24;\n          here_op = (here >>> 16) & 0xff;\n          here_val = here & 0xffff;\n\n          if (here_bits <= bits) { break; }\n          //--- PULLBYTE() ---//\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n          //---//\n        }\n        if (here_op && (here_op & 0xf0) === 0) {\n          last_bits = here_bits;\n          last_op = here_op;\n          last_val = here_val;\n          for (;;) {\n            here = state.lencode[last_val +\n                    ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];\n            here_bits = here >>> 24;\n            here_op = (here >>> 16) & 0xff;\n            here_val = here & 0xffff;\n\n            if ((last_bits + here_bits) <= bits) { break; }\n            //--- PULLBYTE() ---//\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n            //---//\n          }\n          //--- DROPBITS(last.bits) ---//\n          hold >>>= last_bits;\n          bits -= last_bits;\n          //---//\n          state.back += last_bits;\n        }\n        //--- DROPBITS(here.bits) ---//\n        hold >>>= here_bits;\n        bits -= here_bits;\n        //---//\n        state.back += here_bits;\n        state.length = here_val;\n        if (here_op === 0) {\n          //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?\n          //        \"inflate:         literal '%c'\\n\" :\n          //        \"inflate:         literal 0x%02x\\n\", here.val));\n          state.mode = LIT;\n          break;\n        }\n        if (here_op & 32) {\n          //Tracevv((stderr, \"inflate:         end of block\\n\"));\n          state.back = -1;\n          state.mode = TYPE;\n          break;\n        }\n        if (here_op & 64) {\n          strm.msg = 'invalid literal/length code';\n          state.mode = BAD;\n          break;\n        }\n        state.extra = here_op & 15;\n        state.mode = LENEXT;\n        /* falls through */\n      case LENEXT:\n        if (state.extra) {\n          //=== NEEDBITS(state.extra);\n          n = state.extra;\n          while (bits < n) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          state.length += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;\n          //--- DROPBITS(state.extra) ---//\n          hold >>>= state.extra;\n          bits -= state.extra;\n          //---//\n          state.back += state.extra;\n        }\n        //Tracevv((stderr, \"inflate:         length %u\\n\", state.length));\n        state.was = state.length;\n        state.mode = DIST;\n        /* falls through */\n      case DIST:\n        for (;;) {\n          here = state.distcode[hold & ((1 << state.distbits) - 1)];/*BITS(state.distbits)*/\n          here_bits = here >>> 24;\n          here_op = (here >>> 16) & 0xff;\n          here_val = here & 0xffff;\n\n          if ((here_bits) <= bits) { break; }\n          //--- PULLBYTE() ---//\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n          //---//\n        }\n        if ((here_op & 0xf0) === 0) {\n          last_bits = here_bits;\n          last_op = here_op;\n          last_val = here_val;\n          for (;;) {\n            here = state.distcode[last_val +\n                    ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];\n            here_bits = here >>> 24;\n            here_op = (here >>> 16) & 0xff;\n            here_val = here & 0xffff;\n\n            if ((last_bits + here_bits) <= bits) { break; }\n            //--- PULLBYTE() ---//\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n            //---//\n          }\n          //--- DROPBITS(last.bits) ---//\n          hold >>>= last_bits;\n          bits -= last_bits;\n          //---//\n          state.back += last_bits;\n        }\n        //--- DROPBITS(here.bits) ---//\n        hold >>>= here_bits;\n        bits -= here_bits;\n        //---//\n        state.back += here_bits;\n        if (here_op & 64) {\n          strm.msg = 'invalid distance code';\n          state.mode = BAD;\n          break;\n        }\n        state.offset = here_val;\n        state.extra = (here_op) & 15;\n        state.mode = DISTEXT;\n        /* falls through */\n      case DISTEXT:\n        if (state.extra) {\n          //=== NEEDBITS(state.extra);\n          n = state.extra;\n          while (bits < n) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          state.offset += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;\n          //--- DROPBITS(state.extra) ---//\n          hold >>>= state.extra;\n          bits -= state.extra;\n          //---//\n          state.back += state.extra;\n        }\n//#ifdef INFLATE_STRICT\n        if (state.offset > state.dmax) {\n          strm.msg = 'invalid distance too far back';\n          state.mode = BAD;\n          break;\n        }\n//#endif\n        //Tracevv((stderr, \"inflate:         distance %u\\n\", state.offset));\n        state.mode = MATCH;\n        /* falls through */\n      case MATCH:\n        if (left === 0) { break inf_leave; }\n        copy = _out - left;\n        if (state.offset > copy) {         /* copy from window */\n          copy = state.offset - copy;\n          if (copy > state.whave) {\n            if (state.sane) {\n              strm.msg = 'invalid distance too far back';\n              state.mode = BAD;\n              break;\n            }\n// (!) This block is disabled in zlib defaults,\n// don't enable it for binary compatibility\n//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR\n//          Trace((stderr, \"inflate.c too far\\n\"));\n//          copy -= state.whave;\n//          if (copy > state.length) { copy = state.length; }\n//          if (copy > left) { copy = left; }\n//          left -= copy;\n//          state.length -= copy;\n//          do {\n//            output[put++] = 0;\n//          } while (--copy);\n//          if (state.length === 0) { state.mode = LEN; }\n//          break;\n//#endif\n          }\n          if (copy > state.wnext) {\n            copy -= state.wnext;\n            from = state.wsize - copy;\n          }\n          else {\n            from = state.wnext - copy;\n          }\n          if (copy > state.length) { copy = state.length; }\n          from_source = state.window;\n        }\n        else {                              /* copy from output */\n          from_source = output;\n          from = put - state.offset;\n          copy = state.length;\n        }\n        if (copy > left) { copy = left; }\n        left -= copy;\n        state.length -= copy;\n        do {\n          output[put++] = from_source[from++];\n        } while (--copy);\n        if (state.length === 0) { state.mode = LEN; }\n        break;\n      case LIT:\n        if (left === 0) { break inf_leave; }\n        output[put++] = state.length;\n        left--;\n        state.mode = LEN;\n        break;\n      case CHECK:\n        if (state.wrap) {\n          //=== NEEDBITS(32);\n          while (bits < 32) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            // Use '|' instead of '+' to make sure that result is signed\n            hold |= input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          _out -= left;\n          strm.total_out += _out;\n          state.total += _out;\n          if (_out) {\n            strm.adler = state.check =\n                /*UPDATE(state.check, put - _out, _out);*/\n                (state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out));\n\n          }\n          _out = left;\n          // NB: crc32 stored as signed 32-bit int, zswap32 returns signed too\n          if ((state.flags ? hold : zswap32(hold)) !== state.check) {\n            strm.msg = 'incorrect data check';\n            state.mode = BAD;\n            break;\n          }\n          //=== INITBITS();\n          hold = 0;\n          bits = 0;\n          //===//\n          //Tracev((stderr, \"inflate:   check matches trailer\\n\"));\n        }\n        state.mode = LENGTH;\n        /* falls through */\n      case LENGTH:\n        if (state.wrap && state.flags) {\n          //=== NEEDBITS(32);\n          while (bits < 32) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          if (hold !== (state.total & 0xffffffff)) {\n            strm.msg = 'incorrect length check';\n            state.mode = BAD;\n            break;\n          }\n          //=== INITBITS();\n          hold = 0;\n          bits = 0;\n          //===//\n          //Tracev((stderr, \"inflate:   length matches trailer\\n\"));\n        }\n        state.mode = DONE;\n        /* falls through */\n      case DONE:\n        ret = Z_STREAM_END;\n        break inf_leave;\n      case BAD:\n        ret = Z_DATA_ERROR;\n        break inf_leave;\n      case MEM:\n        return Z_MEM_ERROR;\n      case SYNC:\n        /* falls through */\n      default:\n        return Z_STREAM_ERROR;\n    }\n  }\n\n  // inf_leave <- here is real place for \"goto inf_leave\", emulated via \"break inf_leave\"\n\n  /*\n     Return from inflate(), updating the total counts and the check value.\n     If there was no progress during the inflate() call, return a buffer\n     error.  Call updatewindow() to create and/or update the window state.\n     Note: a memory error from inflate() is non-recoverable.\n   */\n\n  //--- RESTORE() ---\n  strm.next_out = put;\n  strm.avail_out = left;\n  strm.next_in = next;\n  strm.avail_in = have;\n  state.hold = hold;\n  state.bits = bits;\n  //---\n\n  if (state.wsize || (_out !== strm.avail_out && state.mode < BAD &&\n                      (state.mode < CHECK || flush !== Z_FINISH))) {\n    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {\n      state.mode = MEM;\n      return Z_MEM_ERROR;\n    }\n  }\n  _in -= strm.avail_in;\n  _out -= strm.avail_out;\n  strm.total_in += _in;\n  strm.total_out += _out;\n  state.total += _out;\n  if (state.wrap && _out) {\n    strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/\n      (state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out));\n  }\n  strm.data_type = state.bits + (state.last ? 64 : 0) +\n                    (state.mode === TYPE ? 128 : 0) +\n                    (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);\n  if (((_in === 0 && _out === 0) || flush === Z_FINISH) && ret === Z_OK) {\n    ret = Z_BUF_ERROR;\n  }\n  return ret;\n}\n\nfunction inflateEnd(strm) {\n\n  if (!strm || !strm.state /*|| strm->zfree == (free_func)0*/) {\n    return Z_STREAM_ERROR;\n  }\n\n  var state = strm.state;\n  if (state.window) {\n    state.window = null;\n  }\n  strm.state = null;\n  return Z_OK;\n}\n\nfunction inflateGetHeader(strm, head) {\n  var state;\n\n  /* check state */\n  if (!strm || !strm.state) { return Z_STREAM_ERROR; }\n  state = strm.state;\n  if ((state.wrap & 2) === 0) { return Z_STREAM_ERROR; }\n\n  /* save header structure */\n  state.head = head;\n  head.done = false;\n  return Z_OK;\n}\n\nfunction inflateSetDictionary(strm, dictionary) {\n  var dictLength = dictionary.length;\n\n  var state;\n  var dictid;\n  var ret;\n\n  /* check state */\n  if (!strm /* == Z_NULL */ || !strm.state /* == Z_NULL */) { return Z_STREAM_ERROR; }\n  state = strm.state;\n\n  if (state.wrap !== 0 && state.mode !== DICT) {\n    return Z_STREAM_ERROR;\n  }\n\n  /* check for correct dictionary identifier */\n  if (state.mode === DICT) {\n    dictid = 1; /* adler32(0, null, 0)*/\n    /* dictid = adler32(dictid, dictionary, dictLength); */\n    dictid = adler32(dictid, dictionary, dictLength, 0);\n    if (dictid !== state.check) {\n      return Z_DATA_ERROR;\n    }\n  }\n  /* copy dictionary to window using updatewindow(), which will amend the\n   existing dictionary if appropriate */\n  ret = updatewindow(strm, dictionary, dictLength, dictLength);\n  if (ret) {\n    state.mode = MEM;\n    return Z_MEM_ERROR;\n  }\n  state.havedict = 1;\n  // Tracev((stderr, \"inflate:   dictionary set\\n\"));\n  return Z_OK;\n}\n\nexports.inflateReset = inflateReset;\nexports.inflateReset2 = inflateReset2;\nexports.inflateResetKeep = inflateResetKeep;\nexports.inflateInit = inflateInit;\nexports.inflateInit2 = inflateInit2;\nexports.inflate = inflate;\nexports.inflateEnd = inflateEnd;\nexports.inflateGetHeader = inflateGetHeader;\nexports.inflateSetDictionary = inflateSetDictionary;\nexports.inflateInfo = 'pako inflate (from Nodeca project)';\n\n/* Not implemented\nexports.inflateCopy = inflateCopy;\nexports.inflateGetDictionary = inflateGetDictionary;\nexports.inflateMark = inflateMark;\nexports.inflatePrime = inflatePrime;\nexports.inflateSync = inflateSync;\nexports.inflateSyncPoint = inflateSyncPoint;\nexports.inflateUndermine = inflateUndermine;\n*/\n","'use strict';\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nvar utils = require('../utils/common');\n\nvar MAXBITS = 15;\nvar ENOUGH_LENS = 852;\nvar ENOUGH_DISTS = 592;\n//var ENOUGH = (ENOUGH_LENS+ENOUGH_DISTS);\n\nvar CODES = 0;\nvar LENS = 1;\nvar DISTS = 2;\n\nvar lbase = [ /* Length codes 257..285 base */\n  3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,\n  35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0\n];\n\nvar lext = [ /* Length codes 257..285 extra */\n  16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,\n  19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78\n];\n\nvar dbase = [ /* Distance codes 0..29 base */\n  1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,\n  257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,\n  8193, 12289, 16385, 24577, 0, 0\n];\n\nvar dext = [ /* Distance codes 0..29 extra */\n  16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,\n  23, 23, 24, 24, 25, 25, 26, 26, 27, 27,\n  28, 28, 29, 29, 64, 64\n];\n\nmodule.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts)\n{\n  var bits = opts.bits;\n      //here = opts.here; /* table entry for duplication */\n\n  var len = 0;               /* a code's length in bits */\n  var sym = 0;               /* index of code symbols */\n  var min = 0, max = 0;          /* minimum and maximum code lengths */\n  var root = 0;              /* number of index bits for root table */\n  var curr = 0;              /* number of index bits for current table */\n  var drop = 0;              /* code bits to drop for sub-table */\n  var left = 0;                   /* number of prefix codes available */\n  var used = 0;              /* code entries in table used */\n  var huff = 0;              /* Huffman code */\n  var incr;              /* for incrementing code, index */\n  var fill;              /* index for replicating entries */\n  var low;               /* low bits for current root entry */\n  var mask;              /* mask for low root bits */\n  var next;             /* next available space in table */\n  var base = null;     /* base value table to use */\n  var base_index = 0;\n//  var shoextra;    /* extra bits table to use */\n  var end;                    /* use base and extra for symbol > end */\n  var count = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];    /* number of codes of each length */\n  var offs = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];     /* offsets in table for each length */\n  var extra = null;\n  var extra_index = 0;\n\n  var here_bits, here_op, here_val;\n\n  /*\n   Process a set of code lengths to create a canonical Huffman code.  The\n   code lengths are lens[0..codes-1].  Each length corresponds to the\n   symbols 0..codes-1.  The Huffman code is generated by first sorting the\n   symbols by length from short to long, and retaining the symbol order\n   for codes with equal lengths.  Then the code starts with all zero bits\n   for the first code of the shortest length, and the codes are integer\n   increments for the same length, and zeros are appended as the length\n   increases.  For the deflate format, these bits are stored backwards\n   from their more natural integer increment ordering, and so when the\n   decoding tables are built in the large loop below, the integer codes\n   are incremented backwards.\n\n   This routine assumes, but does not check, that all of the entries in\n   lens[] are in the range 0..MAXBITS.  The caller must assure this.\n   1..MAXBITS is interpreted as that code length.  zero means that that\n   symbol does not occur in this code.\n\n   The codes are sorted by computing a count of codes for each length,\n   creating from that a table of starting indices for each length in the\n   sorted table, and then entering the symbols in order in the sorted\n   table.  The sorted table is work[], with that space being provided by\n   the caller.\n\n   The length counts are used for other purposes as well, i.e. finding\n   the minimum and maximum length codes, determining if there are any\n   codes at all, checking for a valid set of lengths, and looking ahead\n   at length counts to determine sub-table sizes when building the\n   decoding tables.\n   */\n\n  /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */\n  for (len = 0; len <= MAXBITS; len++) {\n    count[len] = 0;\n  }\n  for (sym = 0; sym < codes; sym++) {\n    count[lens[lens_index + sym]]++;\n  }\n\n  /* bound code lengths, force root to be within code lengths */\n  root = bits;\n  for (max = MAXBITS; max >= 1; max--) {\n    if (count[max] !== 0) { break; }\n  }\n  if (root > max) {\n    root = max;\n  }\n  if (max === 0) {                     /* no symbols to code at all */\n    //table.op[opts.table_index] = 64;  //here.op = (var char)64;    /* invalid code marker */\n    //table.bits[opts.table_index] = 1;   //here.bits = (var char)1;\n    //table.val[opts.table_index++] = 0;   //here.val = (var short)0;\n    table[table_index++] = (1 << 24) | (64 << 16) | 0;\n\n\n    //table.op[opts.table_index] = 64;\n    //table.bits[opts.table_index] = 1;\n    //table.val[opts.table_index++] = 0;\n    table[table_index++] = (1 << 24) | (64 << 16) | 0;\n\n    opts.bits = 1;\n    return 0;     /* no symbols, but wait for decoding to report error */\n  }\n  for (min = 1; min < max; min++) {\n    if (count[min] !== 0) { break; }\n  }\n  if (root < min) {\n    root = min;\n  }\n\n  /* check for an over-subscribed or incomplete set of lengths */\n  left = 1;\n  for (len = 1; len <= MAXBITS; len++) {\n    left <<= 1;\n    left -= count[len];\n    if (left < 0) {\n      return -1;\n    }        /* over-subscribed */\n  }\n  if (left > 0 && (type === CODES || max !== 1)) {\n    return -1;                      /* incomplete set */\n  }\n\n  /* generate offsets into symbol table for each length for sorting */\n  offs[1] = 0;\n  for (len = 1; len < MAXBITS; len++) {\n    offs[len + 1] = offs[len] + count[len];\n  }\n\n  /* sort symbols by length, by symbol order within each length */\n  for (sym = 0; sym < codes; sym++) {\n    if (lens[lens_index + sym] !== 0) {\n      work[offs[lens[lens_index + sym]]++] = sym;\n    }\n  }\n\n  /*\n   Create and fill in decoding tables.  In this loop, the table being\n   filled is at next and has curr index bits.  The code being used is huff\n   with length len.  That code is converted to an index by dropping drop\n   bits off of the bottom.  For codes where len is less than drop + curr,\n   those top drop + curr - len bits are incremented through all values to\n   fill the table with replicated entries.\n\n   root is the number of index bits for the root table.  When len exceeds\n   root, sub-tables are created pointed to by the root entry with an index\n   of the low root bits of huff.  This is saved in low to check for when a\n   new sub-table should be started.  drop is zero when the root table is\n   being filled, and drop is root when sub-tables are being filled.\n\n   When a new sub-table is needed, it is necessary to look ahead in the\n   code lengths to determine what size sub-table is needed.  The length\n   counts are used for this, and so count[] is decremented as codes are\n   entered in the tables.\n\n   used keeps track of how many table entries have been allocated from the\n   provided *table space.  It is checked for LENS and DIST tables against\n   the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in\n   the initial root table size constants.  See the comments in inftrees.h\n   for more information.\n\n   sym increments through all symbols, and the loop terminates when\n   all codes of length max, i.e. all codes, have been processed.  This\n   routine permits incomplete codes, so another loop after this one fills\n   in the rest of the decoding tables with invalid code markers.\n   */\n\n  /* set up for code type */\n  // poor man optimization - use if-else instead of switch,\n  // to avoid deopts in old v8\n  if (type === CODES) {\n    base = extra = work;    /* dummy value--not used */\n    end = 19;\n\n  } else if (type === LENS) {\n    base = lbase;\n    base_index -= 257;\n    extra = lext;\n    extra_index -= 257;\n    end = 256;\n\n  } else {                    /* DISTS */\n    base = dbase;\n    extra = dext;\n    end = -1;\n  }\n\n  /* initialize opts for loop */\n  huff = 0;                   /* starting code */\n  sym = 0;                    /* starting code symbol */\n  len = min;                  /* starting code length */\n  next = table_index;              /* current table to fill in */\n  curr = root;                /* current table index bits */\n  drop = 0;                   /* current bits to drop from code for index */\n  low = -1;                   /* trigger new sub-table when len > root */\n  used = 1 << root;          /* use root table entries */\n  mask = used - 1;            /* mask for comparing low */\n\n  /* check available table space */\n  if ((type === LENS && used > ENOUGH_LENS) ||\n    (type === DISTS && used > ENOUGH_DISTS)) {\n    return 1;\n  }\n\n  /* process all codes and make table entries */\n  for (;;) {\n    /* create table entry */\n    here_bits = len - drop;\n    if (work[sym] < end) {\n      here_op = 0;\n      here_val = work[sym];\n    }\n    else if (work[sym] > end) {\n      here_op = extra[extra_index + work[sym]];\n      here_val = base[base_index + work[sym]];\n    }\n    else {\n      here_op = 32 + 64;         /* end of block */\n      here_val = 0;\n    }\n\n    /* replicate for those indices with low len bits equal to huff */\n    incr = 1 << (len - drop);\n    fill = 1 << curr;\n    min = fill;                 /* save offset to next table */\n    do {\n      fill -= incr;\n      table[next + (huff >> drop) + fill] = (here_bits << 24) | (here_op << 16) | here_val |0;\n    } while (fill !== 0);\n\n    /* backwards increment the len-bit code huff */\n    incr = 1 << (len - 1);\n    while (huff & incr) {\n      incr >>= 1;\n    }\n    if (incr !== 0) {\n      huff &= incr - 1;\n      huff += incr;\n    } else {\n      huff = 0;\n    }\n\n    /* go to next symbol, update count, len */\n    sym++;\n    if (--count[len] === 0) {\n      if (len === max) { break; }\n      len = lens[lens_index + work[sym]];\n    }\n\n    /* create new sub-table if needed */\n    if (len > root && (huff & mask) !== low) {\n      /* if first time, transition to sub-tables */\n      if (drop === 0) {\n        drop = root;\n      }\n\n      /* increment past last table */\n      next += min;            /* here min is 1 << curr */\n\n      /* determine length of next table */\n      curr = len - drop;\n      left = 1 << curr;\n      while (curr + drop < max) {\n        left -= count[curr + drop];\n        if (left <= 0) { break; }\n        curr++;\n        left <<= 1;\n      }\n\n      /* check for enough space */\n      used += 1 << curr;\n      if ((type === LENS && used > ENOUGH_LENS) ||\n        (type === DISTS && used > ENOUGH_DISTS)) {\n        return 1;\n      }\n\n      /* point entry in root table to sub-table */\n      low = huff & mask;\n      /*table.op[low] = curr;\n      table.bits[low] = root;\n      table.val[low] = next - opts.table_index;*/\n      table[low] = (root << 24) | (curr << 16) | (next - table_index) |0;\n    }\n  }\n\n  /* fill in remaining table entry if code is incomplete (guaranteed to have\n   at most one remaining entry, since if the code is incomplete, the\n   maximum code length that was allowed to get this far is one bit) */\n  if (huff !== 0) {\n    //table.op[next + huff] = 64;            /* invalid code marker */\n    //table.bits[next + huff] = len - drop;\n    //table.val[next + huff] = 0;\n    table[next + huff] = ((len - drop) << 24) | (64 << 16) |0;\n  }\n\n  /* set return parameters */\n  //opts.table_index += used;\n  opts.bits = root;\n  return 0;\n};\n","'use strict';\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nmodule.exports = {\n  2:      'need dictionary',     /* Z_NEED_DICT       2  */\n  1:      'stream end',          /* Z_STREAM_END      1  */\n  0:      '',                    /* Z_OK              0  */\n  '-1':   'file error',          /* Z_ERRNO         (-1) */\n  '-2':   'stream error',        /* Z_STREAM_ERROR  (-2) */\n  '-3':   'data error',          /* Z_DATA_ERROR    (-3) */\n  '-4':   'insufficient memory', /* Z_MEM_ERROR     (-4) */\n  '-5':   'buffer error',        /* Z_BUF_ERROR     (-5) */\n  '-6':   'incompatible version' /* Z_VERSION_ERROR (-6) */\n};\n","'use strict';\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\n/* eslint-disable space-unary-ops */\n\nvar utils = require('../utils/common');\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\n\n//var Z_FILTERED          = 1;\n//var Z_HUFFMAN_ONLY      = 2;\n//var Z_RLE               = 3;\nvar Z_FIXED               = 4;\n//var Z_DEFAULT_STRATEGY  = 0;\n\n/* Possible values of the data_type field (though see inflate()) */\nvar Z_BINARY              = 0;\nvar Z_TEXT                = 1;\n//var Z_ASCII             = 1; // = Z_TEXT\nvar Z_UNKNOWN             = 2;\n\n/*============================================================================*/\n\n\nfunction zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }\n\n// From zutil.h\n\nvar STORED_BLOCK = 0;\nvar STATIC_TREES = 1;\nvar DYN_TREES    = 2;\n/* The three kinds of block type */\n\nvar MIN_MATCH    = 3;\nvar MAX_MATCH    = 258;\n/* The minimum and maximum match lengths */\n\n// From deflate.h\n/* ===========================================================================\n * Internal compression state.\n */\n\nvar LENGTH_CODES  = 29;\n/* number of length codes, not counting the special END_BLOCK code */\n\nvar LITERALS      = 256;\n/* number of literal bytes 0..255 */\n\nvar L_CODES       = LITERALS + 1 + LENGTH_CODES;\n/* number of Literal or Length codes, including the END_BLOCK code */\n\nvar D_CODES       = 30;\n/* number of distance codes */\n\nvar BL_CODES      = 19;\n/* number of codes used to transfer the bit lengths */\n\nvar HEAP_SIZE     = 2 * L_CODES + 1;\n/* maximum heap size */\n\nvar MAX_BITS      = 15;\n/* All codes must not exceed MAX_BITS bits */\n\nvar Buf_size      = 16;\n/* size of bit buffer in bi_buf */\n\n\n/* ===========================================================================\n * Constants\n */\n\nvar MAX_BL_BITS = 7;\n/* Bit length codes must not exceed MAX_BL_BITS bits */\n\nvar END_BLOCK   = 256;\n/* end of block literal code */\n\nvar REP_3_6     = 16;\n/* repeat previous bit length 3-6 times (2 bits of repeat count) */\n\nvar REPZ_3_10   = 17;\n/* repeat a zero length 3-10 times  (3 bits of repeat count) */\n\nvar REPZ_11_138 = 18;\n/* repeat a zero length 11-138 times  (7 bits of repeat count) */\n\n/* eslint-disable comma-spacing,array-bracket-spacing */\nvar extra_lbits =   /* extra bits for each length code */\n  [0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0];\n\nvar extra_dbits =   /* extra bits for each distance code */\n  [0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13];\n\nvar extra_blbits =  /* extra bits for each bit length code */\n  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7];\n\nvar bl_order =\n  [16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];\n/* eslint-enable comma-spacing,array-bracket-spacing */\n\n/* The lengths of the bit length codes are sent in order of decreasing\n * probability, to avoid transmitting the lengths for unused bit length codes.\n */\n\n/* ===========================================================================\n * Local data. These are initialized only once.\n */\n\n// We pre-fill arrays with 0 to avoid uninitialized gaps\n\nvar DIST_CODE_LEN = 512; /* see definition of array dist_code below */\n\n// !!!! Use flat array instead of structure, Freq = i*2, Len = i*2+1\nvar static_ltree  = new Array((L_CODES + 2) * 2);\nzero(static_ltree);\n/* The static literal tree. Since the bit lengths are imposed, there is no\n * need for the L_CODES extra codes used during heap construction. However\n * The codes 286 and 287 are needed to build a canonical tree (see _tr_init\n * below).\n */\n\nvar static_dtree  = new Array(D_CODES * 2);\nzero(static_dtree);\n/* The static distance tree. (Actually a trivial tree since all codes use\n * 5 bits.)\n */\n\nvar _dist_code    = new Array(DIST_CODE_LEN);\nzero(_dist_code);\n/* Distance codes. The first 256 values correspond to the distances\n * 3 .. 258, the last 256 values correspond to the top 8 bits of\n * the 15 bit distances.\n */\n\nvar _length_code  = new Array(MAX_MATCH - MIN_MATCH + 1);\nzero(_length_code);\n/* length code for each normalized match length (0 == MIN_MATCH) */\n\nvar base_length   = new Array(LENGTH_CODES);\nzero(base_length);\n/* First normalized length for each code (0 = MIN_MATCH) */\n\nvar base_dist     = new Array(D_CODES);\nzero(base_dist);\n/* First normalized distance for each code (0 = distance of 1) */\n\n\nfunction StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {\n\n  this.static_tree  = static_tree;  /* static tree or NULL */\n  this.extra_bits   = extra_bits;   /* extra bits for each code or NULL */\n  this.extra_base   = extra_base;   /* base index for extra_bits */\n  this.elems        = elems;        /* max number of elements in the tree */\n  this.max_length   = max_length;   /* max bit length for the codes */\n\n  // show if `static_tree` has data or dummy - needed for monomorphic objects\n  this.has_stree    = static_tree && static_tree.length;\n}\n\n\nvar static_l_desc;\nvar static_d_desc;\nvar static_bl_desc;\n\n\nfunction TreeDesc(dyn_tree, stat_desc) {\n  this.dyn_tree = dyn_tree;     /* the dynamic tree */\n  this.max_code = 0;            /* largest code with non zero frequency */\n  this.stat_desc = stat_desc;   /* the corresponding static tree */\n}\n\n\n\nfunction d_code(dist) {\n  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];\n}\n\n\n/* ===========================================================================\n * Output a short LSB first on the stream.\n * IN assertion: there is enough room in pendingBuf.\n */\nfunction put_short(s, w) {\n//    put_byte(s, (uch)((w) & 0xff));\n//    put_byte(s, (uch)((ush)(w) >> 8));\n  s.pending_buf[s.pending++] = (w) & 0xff;\n  s.pending_buf[s.pending++] = (w >>> 8) & 0xff;\n}\n\n\n/* ===========================================================================\n * Send a value on a given number of bits.\n * IN assertion: length <= 16 and value fits in length bits.\n */\nfunction send_bits(s, value, length) {\n  if (s.bi_valid > (Buf_size - length)) {\n    s.bi_buf |= (value << s.bi_valid) & 0xffff;\n    put_short(s, s.bi_buf);\n    s.bi_buf = value >> (Buf_size - s.bi_valid);\n    s.bi_valid += length - Buf_size;\n  } else {\n    s.bi_buf |= (value << s.bi_valid) & 0xffff;\n    s.bi_valid += length;\n  }\n}\n\n\nfunction send_code(s, c, tree) {\n  send_bits(s, tree[c * 2]/*.Code*/, tree[c * 2 + 1]/*.Len*/);\n}\n\n\n/* ===========================================================================\n * Reverse the first len bits of a code, using straightforward code (a faster\n * method would use a table)\n * IN assertion: 1 <= len <= 15\n */\nfunction bi_reverse(code, len) {\n  var res = 0;\n  do {\n    res |= code & 1;\n    code >>>= 1;\n    res <<= 1;\n  } while (--len > 0);\n  return res >>> 1;\n}\n\n\n/* ===========================================================================\n * Flush the bit buffer, keeping at most 7 bits in it.\n */\nfunction bi_flush(s) {\n  if (s.bi_valid === 16) {\n    put_short(s, s.bi_buf);\n    s.bi_buf = 0;\n    s.bi_valid = 0;\n\n  } else if (s.bi_valid >= 8) {\n    s.pending_buf[s.pending++] = s.bi_buf & 0xff;\n    s.bi_buf >>= 8;\n    s.bi_valid -= 8;\n  }\n}\n\n\n/* ===========================================================================\n * Compute the optimal bit lengths for a tree and update the total bit length\n * for the current block.\n * IN assertion: the fields freq and dad are set, heap[heap_max] and\n *    above are the tree nodes sorted by increasing frequency.\n * OUT assertions: the field len is set to the optimal bit length, the\n *     array bl_count contains the frequencies for each bit length.\n *     The length opt_len is updated; static_len is also updated if stree is\n *     not null.\n */\nfunction gen_bitlen(s, desc)\n//    deflate_state *s;\n//    tree_desc *desc;    /* the tree descriptor */\n{\n  var tree            = desc.dyn_tree;\n  var max_code        = desc.max_code;\n  var stree           = desc.stat_desc.static_tree;\n  var has_stree       = desc.stat_desc.has_stree;\n  var extra           = desc.stat_desc.extra_bits;\n  var base            = desc.stat_desc.extra_base;\n  var max_length      = desc.stat_desc.max_length;\n  var h;              /* heap index */\n  var n, m;           /* iterate over the tree elements */\n  var bits;           /* bit length */\n  var xbits;          /* extra bits */\n  var f;              /* frequency */\n  var overflow = 0;   /* number of elements with bit length too large */\n\n  for (bits = 0; bits <= MAX_BITS; bits++) {\n    s.bl_count[bits] = 0;\n  }\n\n  /* In a first pass, compute the optimal bit lengths (which may\n   * overflow in the case of the bit length tree).\n   */\n  tree[s.heap[s.heap_max] * 2 + 1]/*.Len*/ = 0; /* root of the heap */\n\n  for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {\n    n = s.heap[h];\n    bits = tree[tree[n * 2 + 1]/*.Dad*/ * 2 + 1]/*.Len*/ + 1;\n    if (bits > max_length) {\n      bits = max_length;\n      overflow++;\n    }\n    tree[n * 2 + 1]/*.Len*/ = bits;\n    /* We overwrite tree[n].Dad which is no longer needed */\n\n    if (n > max_code) { continue; } /* not a leaf node */\n\n    s.bl_count[bits]++;\n    xbits = 0;\n    if (n >= base) {\n      xbits = extra[n - base];\n    }\n    f = tree[n * 2]/*.Freq*/;\n    s.opt_len += f * (bits + xbits);\n    if (has_stree) {\n      s.static_len += f * (stree[n * 2 + 1]/*.Len*/ + xbits);\n    }\n  }\n  if (overflow === 0) { return; }\n\n  // Trace((stderr,\"\\nbit length overflow\\n\"));\n  /* This happens for example on obj2 and pic of the Calgary corpus */\n\n  /* Find the first bit length which could increase: */\n  do {\n    bits = max_length - 1;\n    while (s.bl_count[bits] === 0) { bits--; }\n    s.bl_count[bits]--;      /* move one leaf down the tree */\n    s.bl_count[bits + 1] += 2; /* move one overflow item as its brother */\n    s.bl_count[max_length]--;\n    /* The brother of the overflow item also moves one step up,\n     * but this does not affect bl_count[max_length]\n     */\n    overflow -= 2;\n  } while (overflow > 0);\n\n  /* Now recompute all bit lengths, scanning in increasing frequency.\n   * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all\n   * lengths instead of fixing only the wrong ones. This idea is taken\n   * from 'ar' written by Haruhiko Okumura.)\n   */\n  for (bits = max_length; bits !== 0; bits--) {\n    n = s.bl_count[bits];\n    while (n !== 0) {\n      m = s.heap[--h];\n      if (m > max_code) { continue; }\n      if (tree[m * 2 + 1]/*.Len*/ !== bits) {\n        // Trace((stderr,\"code %d bits %d->%d\\n\", m, tree[m].Len, bits));\n        s.opt_len += (bits - tree[m * 2 + 1]/*.Len*/) * tree[m * 2]/*.Freq*/;\n        tree[m * 2 + 1]/*.Len*/ = bits;\n      }\n      n--;\n    }\n  }\n}\n\n\n/* ===========================================================================\n * Generate the codes for a given tree and bit counts (which need not be\n * optimal).\n * IN assertion: the array bl_count contains the bit length statistics for\n * the given tree and the field len is set for all tree elements.\n * OUT assertion: the field code is set for all tree elements of non\n *     zero code length.\n */\nfunction gen_codes(tree, max_code, bl_count)\n//    ct_data *tree;             /* the tree to decorate */\n//    int max_code;              /* largest code with non zero frequency */\n//    ushf *bl_count;            /* number of codes at each bit length */\n{\n  var next_code = new Array(MAX_BITS + 1); /* next code value for each bit length */\n  var code = 0;              /* running code value */\n  var bits;                  /* bit index */\n  var n;                     /* code index */\n\n  /* The distribution counts are first used to generate the code values\n   * without bit reversal.\n   */\n  for (bits = 1; bits <= MAX_BITS; bits++) {\n    next_code[bits] = code = (code + bl_count[bits - 1]) << 1;\n  }\n  /* Check that the bit counts in bl_count are consistent. The last code\n   * must be all ones.\n   */\n  //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,\n  //        \"inconsistent bit counts\");\n  //Tracev((stderr,\"\\ngen_codes: max_code %d \", max_code));\n\n  for (n = 0;  n <= max_code; n++) {\n    var len = tree[n * 2 + 1]/*.Len*/;\n    if (len === 0) { continue; }\n    /* Now reverse the bits */\n    tree[n * 2]/*.Code*/ = bi_reverse(next_code[len]++, len);\n\n    //Tracecv(tree != static_ltree, (stderr,\"\\nn %3d %c l %2d c %4x (%x) \",\n    //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));\n  }\n}\n\n\n/* ===========================================================================\n * Initialize the various 'constant' tables.\n */\nfunction tr_static_init() {\n  var n;        /* iterates over tree elements */\n  var bits;     /* bit counter */\n  var length;   /* length value */\n  var code;     /* code value */\n  var dist;     /* distance index */\n  var bl_count = new Array(MAX_BITS + 1);\n  /* number of codes at each bit length for an optimal tree */\n\n  // do check in _tr_init()\n  //if (static_init_done) return;\n\n  /* For some embedded targets, global variables are not initialized: */\n/*#ifdef NO_INIT_GLOBAL_POINTERS\n  static_l_desc.static_tree = static_ltree;\n  static_l_desc.extra_bits = extra_lbits;\n  static_d_desc.static_tree = static_dtree;\n  static_d_desc.extra_bits = extra_dbits;\n  static_bl_desc.extra_bits = extra_blbits;\n#endif*/\n\n  /* Initialize the mapping length (0..255) -> length code (0..28) */\n  length = 0;\n  for (code = 0; code < LENGTH_CODES - 1; code++) {\n    base_length[code] = length;\n    for (n = 0; n < (1 << extra_lbits[code]); n++) {\n      _length_code[length++] = code;\n    }\n  }\n  //Assert (length == 256, \"tr_static_init: length != 256\");\n  /* Note that the length 255 (match length 258) can be represented\n   * in two different ways: code 284 + 5 bits or code 285, so we\n   * overwrite length_code[255] to use the best encoding:\n   */\n  _length_code[length - 1] = code;\n\n  /* Initialize the mapping dist (0..32K) -> dist code (0..29) */\n  dist = 0;\n  for (code = 0; code < 16; code++) {\n    base_dist[code] = dist;\n    for (n = 0; n < (1 << extra_dbits[code]); n++) {\n      _dist_code[dist++] = code;\n    }\n  }\n  //Assert (dist == 256, \"tr_static_init: dist != 256\");\n  dist >>= 7; /* from now on, all distances are divided by 128 */\n  for (; code < D_CODES; code++) {\n    base_dist[code] = dist << 7;\n    for (n = 0; n < (1 << (extra_dbits[code] - 7)); n++) {\n      _dist_code[256 + dist++] = code;\n    }\n  }\n  //Assert (dist == 256, \"tr_static_init: 256+dist != 512\");\n\n  /* Construct the codes of the static literal tree */\n  for (bits = 0; bits <= MAX_BITS; bits++) {\n    bl_count[bits] = 0;\n  }\n\n  n = 0;\n  while (n <= 143) {\n    static_ltree[n * 2 + 1]/*.Len*/ = 8;\n    n++;\n    bl_count[8]++;\n  }\n  while (n <= 255) {\n    static_ltree[n * 2 + 1]/*.Len*/ = 9;\n    n++;\n    bl_count[9]++;\n  }\n  while (n <= 279) {\n    static_ltree[n * 2 + 1]/*.Len*/ = 7;\n    n++;\n    bl_count[7]++;\n  }\n  while (n <= 287) {\n    static_ltree[n * 2 + 1]/*.Len*/ = 8;\n    n++;\n    bl_count[8]++;\n  }\n  /* Codes 286 and 287 do not exist, but we must include them in the\n   * tree construction to get a canonical Huffman tree (longest code\n   * all ones)\n   */\n  gen_codes(static_ltree, L_CODES + 1, bl_count);\n\n  /* The static distance tree is trivial: */\n  for (n = 0; n < D_CODES; n++) {\n    static_dtree[n * 2 + 1]/*.Len*/ = 5;\n    static_dtree[n * 2]/*.Code*/ = bi_reverse(n, 5);\n  }\n\n  // Now data ready and we can init static trees\n  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);\n  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0,          D_CODES, MAX_BITS);\n  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0,         BL_CODES, MAX_BL_BITS);\n\n  //static_init_done = true;\n}\n\n\n/* ===========================================================================\n * Initialize a new block.\n */\nfunction init_block(s) {\n  var n; /* iterates over tree elements */\n\n  /* Initialize the trees. */\n  for (n = 0; n < L_CODES;  n++) { s.dyn_ltree[n * 2]/*.Freq*/ = 0; }\n  for (n = 0; n < D_CODES;  n++) { s.dyn_dtree[n * 2]/*.Freq*/ = 0; }\n  for (n = 0; n < BL_CODES; n++) { s.bl_tree[n * 2]/*.Freq*/ = 0; }\n\n  s.dyn_ltree[END_BLOCK * 2]/*.Freq*/ = 1;\n  s.opt_len = s.static_len = 0;\n  s.last_lit = s.matches = 0;\n}\n\n\n/* ===========================================================================\n * Flush the bit buffer and align the output on a byte boundary\n */\nfunction bi_windup(s)\n{\n  if (s.bi_valid > 8) {\n    put_short(s, s.bi_buf);\n  } else if (s.bi_valid > 0) {\n    //put_byte(s, (Byte)s->bi_buf);\n    s.pending_buf[s.pending++] = s.bi_buf;\n  }\n  s.bi_buf = 0;\n  s.bi_valid = 0;\n}\n\n/* ===========================================================================\n * Copy a stored block, storing first the length and its\n * one's complement if requested.\n */\nfunction copy_block(s, buf, len, header)\n//DeflateState *s;\n//charf    *buf;    /* the input data */\n//unsigned len;     /* its length */\n//int      header;  /* true if block header must be written */\n{\n  bi_windup(s);        /* align on byte boundary */\n\n  if (header) {\n    put_short(s, len);\n    put_short(s, ~len);\n  }\n//  while (len--) {\n//    put_byte(s, *buf++);\n//  }\n  utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);\n  s.pending += len;\n}\n\n/* ===========================================================================\n * Compares to subtrees, using the tree depth as tie breaker when\n * the subtrees have equal frequency. This minimizes the worst case length.\n */\nfunction smaller(tree, n, m, depth) {\n  var _n2 = n * 2;\n  var _m2 = m * 2;\n  return (tree[_n2]/*.Freq*/ < tree[_m2]/*.Freq*/ ||\n         (tree[_n2]/*.Freq*/ === tree[_m2]/*.Freq*/ && depth[n] <= depth[m]));\n}\n\n/* ===========================================================================\n * Restore the heap property by moving down the tree starting at node k,\n * exchanging a node with the smallest of its two sons if necessary, stopping\n * when the heap property is re-established (each father smaller than its\n * two sons).\n */\nfunction pqdownheap(s, tree, k)\n//    deflate_state *s;\n//    ct_data *tree;  /* the tree to restore */\n//    int k;               /* node to move down */\n{\n  var v = s.heap[k];\n  var j = k << 1;  /* left son of k */\n  while (j <= s.heap_len) {\n    /* Set j to the smallest of the two sons: */\n    if (j < s.heap_len &&\n      smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {\n      j++;\n    }\n    /* Exit if v is smaller than both sons */\n    if (smaller(tree, v, s.heap[j], s.depth)) { break; }\n\n    /* Exchange v with the smallest son */\n    s.heap[k] = s.heap[j];\n    k = j;\n\n    /* And continue down the tree, setting j to the left son of k */\n    j <<= 1;\n  }\n  s.heap[k] = v;\n}\n\n\n// inlined manually\n// var SMALLEST = 1;\n\n/* ===========================================================================\n * Send the block data compressed using the given Huffman trees\n */\nfunction compress_block(s, ltree, dtree)\n//    deflate_state *s;\n//    const ct_data *ltree; /* literal tree */\n//    const ct_data *dtree; /* distance tree */\n{\n  var dist;           /* distance of matched string */\n  var lc;             /* match length or unmatched char (if dist == 0) */\n  var lx = 0;         /* running index in l_buf */\n  var code;           /* the code to send */\n  var extra;          /* number of extra bits to send */\n\n  if (s.last_lit !== 0) {\n    do {\n      dist = (s.pending_buf[s.d_buf + lx * 2] << 8) | (s.pending_buf[s.d_buf + lx * 2 + 1]);\n      lc = s.pending_buf[s.l_buf + lx];\n      lx++;\n\n      if (dist === 0) {\n        send_code(s, lc, ltree); /* send a literal byte */\n        //Tracecv(isgraph(lc), (stderr,\" '%c' \", lc));\n      } else {\n        /* Here, lc is the match length - MIN_MATCH */\n        code = _length_code[lc];\n        send_code(s, code + LITERALS + 1, ltree); /* send the length code */\n        extra = extra_lbits[code];\n        if (extra !== 0) {\n          lc -= base_length[code];\n          send_bits(s, lc, extra);       /* send the extra length bits */\n        }\n        dist--; /* dist is now the match distance - 1 */\n        code = d_code(dist);\n        //Assert (code < D_CODES, \"bad d_code\");\n\n        send_code(s, code, dtree);       /* send the distance code */\n        extra = extra_dbits[code];\n        if (extra !== 0) {\n          dist -= base_dist[code];\n          send_bits(s, dist, extra);   /* send the extra distance bits */\n        }\n      } /* literal or match pair ? */\n\n      /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */\n      //Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,\n      //       \"pendingBuf overflow\");\n\n    } while (lx < s.last_lit);\n  }\n\n  send_code(s, END_BLOCK, ltree);\n}\n\n\n/* ===========================================================================\n * Construct one Huffman tree and assigns the code bit strings and lengths.\n * Update the total bit length for the current block.\n * IN assertion: the field freq is set for all tree elements.\n * OUT assertions: the fields len and code are set to the optimal bit length\n *     and corresponding code. The length opt_len is updated; static_len is\n *     also updated if stree is not null. The field max_code is set.\n */\nfunction build_tree(s, desc)\n//    deflate_state *s;\n//    tree_desc *desc; /* the tree descriptor */\n{\n  var tree     = desc.dyn_tree;\n  var stree    = desc.stat_desc.static_tree;\n  var has_stree = desc.stat_desc.has_stree;\n  var elems    = desc.stat_desc.elems;\n  var n, m;          /* iterate over heap elements */\n  var max_code = -1; /* largest code with non zero frequency */\n  var node;          /* new node being created */\n\n  /* Construct the initial heap, with least frequent element in\n   * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].\n   * heap[0] is not used.\n   */\n  s.heap_len = 0;\n  s.heap_max = HEAP_SIZE;\n\n  for (n = 0; n < elems; n++) {\n    if (tree[n * 2]/*.Freq*/ !== 0) {\n      s.heap[++s.heap_len] = max_code = n;\n      s.depth[n] = 0;\n\n    } else {\n      tree[n * 2 + 1]/*.Len*/ = 0;\n    }\n  }\n\n  /* The pkzip format requires that at least one distance code exists,\n   * and that at least one bit should be sent even if there is only one\n   * possible code. So to avoid special checks later on we force at least\n   * two codes of non zero frequency.\n   */\n  while (s.heap_len < 2) {\n    node = s.heap[++s.heap_len] = (max_code < 2 ? ++max_code : 0);\n    tree[node * 2]/*.Freq*/ = 1;\n    s.depth[node] = 0;\n    s.opt_len--;\n\n    if (has_stree) {\n      s.static_len -= stree[node * 2 + 1]/*.Len*/;\n    }\n    /* node is 0 or 1 so it does not have extra bits */\n  }\n  desc.max_code = max_code;\n\n  /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,\n   * establish sub-heaps of increasing lengths:\n   */\n  for (n = (s.heap_len >> 1/*int /2*/); n >= 1; n--) { pqdownheap(s, tree, n); }\n\n  /* Construct the Huffman tree by repeatedly combining the least two\n   * frequent nodes.\n   */\n  node = elems;              /* next internal node of the tree */\n  do {\n    //pqremove(s, tree, n);  /* n = node of least frequency */\n    /*** pqremove ***/\n    n = s.heap[1/*SMALLEST*/];\n    s.heap[1/*SMALLEST*/] = s.heap[s.heap_len--];\n    pqdownheap(s, tree, 1/*SMALLEST*/);\n    /***/\n\n    m = s.heap[1/*SMALLEST*/]; /* m = node of next least frequency */\n\n    s.heap[--s.heap_max] = n; /* keep the nodes sorted by frequency */\n    s.heap[--s.heap_max] = m;\n\n    /* Create a new node father of n and m */\n    tree[node * 2]/*.Freq*/ = tree[n * 2]/*.Freq*/ + tree[m * 2]/*.Freq*/;\n    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;\n    tree[n * 2 + 1]/*.Dad*/ = tree[m * 2 + 1]/*.Dad*/ = node;\n\n    /* and insert the new node in the heap */\n    s.heap[1/*SMALLEST*/] = node++;\n    pqdownheap(s, tree, 1/*SMALLEST*/);\n\n  } while (s.heap_len >= 2);\n\n  s.heap[--s.heap_max] = s.heap[1/*SMALLEST*/];\n\n  /* At this point, the fields freq and dad are set. We can now\n   * generate the bit lengths.\n   */\n  gen_bitlen(s, desc);\n\n  /* The field len is now set, we can generate the bit codes */\n  gen_codes(tree, max_code, s.bl_count);\n}\n\n\n/* ===========================================================================\n * Scan a literal or distance tree to determine the frequencies of the codes\n * in the bit length tree.\n */\nfunction scan_tree(s, tree, max_code)\n//    deflate_state *s;\n//    ct_data *tree;   /* the tree to be scanned */\n//    int max_code;    /* and its largest code of non zero frequency */\n{\n  var n;                     /* iterates over all tree elements */\n  var prevlen = -1;          /* last emitted length */\n  var curlen;                /* length of current code */\n\n  var nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */\n\n  var count = 0;             /* repeat count of the current code */\n  var max_count = 7;         /* max repeat count */\n  var min_count = 4;         /* min repeat count */\n\n  if (nextlen === 0) {\n    max_count = 138;\n    min_count = 3;\n  }\n  tree[(max_code + 1) * 2 + 1]/*.Len*/ = 0xffff; /* guard */\n\n  for (n = 0; n <= max_code; n++) {\n    curlen = nextlen;\n    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;\n\n    if (++count < max_count && curlen === nextlen) {\n      continue;\n\n    } else if (count < min_count) {\n      s.bl_tree[curlen * 2]/*.Freq*/ += count;\n\n    } else if (curlen !== 0) {\n\n      if (curlen !== prevlen) { s.bl_tree[curlen * 2]/*.Freq*/++; }\n      s.bl_tree[REP_3_6 * 2]/*.Freq*/++;\n\n    } else if (count <= 10) {\n      s.bl_tree[REPZ_3_10 * 2]/*.Freq*/++;\n\n    } else {\n      s.bl_tree[REPZ_11_138 * 2]/*.Freq*/++;\n    }\n\n    count = 0;\n    prevlen = curlen;\n\n    if (nextlen === 0) {\n      max_count = 138;\n      min_count = 3;\n\n    } else if (curlen === nextlen) {\n      max_count = 6;\n      min_count = 3;\n\n    } else {\n      max_count = 7;\n      min_count = 4;\n    }\n  }\n}\n\n\n/* ===========================================================================\n * Send a literal or distance tree in compressed form, using the codes in\n * bl_tree.\n */\nfunction send_tree(s, tree, max_code)\n//    deflate_state *s;\n//    ct_data *tree; /* the tree to be scanned */\n//    int max_code;       /* and its largest code of non zero frequency */\n{\n  var n;                     /* iterates over all tree elements */\n  var prevlen = -1;          /* last emitted length */\n  var curlen;                /* length of current code */\n\n  var nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */\n\n  var count = 0;             /* repeat count of the current code */\n  var max_count = 7;         /* max repeat count */\n  var min_count = 4;         /* min repeat count */\n\n  /* tree[max_code+1].Len = -1; */  /* guard already set */\n  if (nextlen === 0) {\n    max_count = 138;\n    min_count = 3;\n  }\n\n  for (n = 0; n <= max_code; n++) {\n    curlen = nextlen;\n    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;\n\n    if (++count < max_count && curlen === nextlen) {\n      continue;\n\n    } else if (count < min_count) {\n      do { send_code(s, curlen, s.bl_tree); } while (--count !== 0);\n\n    } else if (curlen !== 0) {\n      if (curlen !== prevlen) {\n        send_code(s, curlen, s.bl_tree);\n        count--;\n      }\n      //Assert(count >= 3 && count <= 6, \" 3_6?\");\n      send_code(s, REP_3_6, s.bl_tree);\n      send_bits(s, count - 3, 2);\n\n    } else if (count <= 10) {\n      send_code(s, REPZ_3_10, s.bl_tree);\n      send_bits(s, count - 3, 3);\n\n    } else {\n      send_code(s, REPZ_11_138, s.bl_tree);\n      send_bits(s, count - 11, 7);\n    }\n\n    count = 0;\n    prevlen = curlen;\n    if (nextlen === 0) {\n      max_count = 138;\n      min_count = 3;\n\n    } else if (curlen === nextlen) {\n      max_count = 6;\n      min_count = 3;\n\n    } else {\n      max_count = 7;\n      min_count = 4;\n    }\n  }\n}\n\n\n/* ===========================================================================\n * Construct the Huffman tree for the bit lengths and return the index in\n * bl_order of the last bit length code to send.\n */\nfunction build_bl_tree(s) {\n  var max_blindex;  /* index of last bit length code of non zero freq */\n\n  /* Determine the bit length frequencies for literal and distance trees */\n  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);\n  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);\n\n  /* Build the bit length tree: */\n  build_tree(s, s.bl_desc);\n  /* opt_len now includes the length of the tree representations, except\n   * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.\n   */\n\n  /* Determine the number of bit length codes to send. The pkzip format\n   * requires that at least 4 bit length codes be sent. (appnote.txt says\n   * 3 but the actual value used is 4.)\n   */\n  for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {\n    if (s.bl_tree[bl_order[max_blindex] * 2 + 1]/*.Len*/ !== 0) {\n      break;\n    }\n  }\n  /* Update opt_len to include the bit length tree and counts */\n  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;\n  //Tracev((stderr, \"\\ndyn trees: dyn %ld, stat %ld\",\n  //        s->opt_len, s->static_len));\n\n  return max_blindex;\n}\n\n\n/* ===========================================================================\n * Send the header for a block using dynamic Huffman trees: the counts, the\n * lengths of the bit length codes, the literal tree and the distance tree.\n * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.\n */\nfunction send_all_trees(s, lcodes, dcodes, blcodes)\n//    deflate_state *s;\n//    int lcodes, dcodes, blcodes; /* number of codes for each tree */\n{\n  var rank;                    /* index in bl_order */\n\n  //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, \"not enough codes\");\n  //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,\n  //        \"too many codes\");\n  //Tracev((stderr, \"\\nbl counts: \"));\n  send_bits(s, lcodes - 257, 5); /* not +255 as stated in appnote.txt */\n  send_bits(s, dcodes - 1,   5);\n  send_bits(s, blcodes - 4,  4); /* not -3 as stated in appnote.txt */\n  for (rank = 0; rank < blcodes; rank++) {\n    //Tracev((stderr, \"\\nbl code %2d \", bl_order[rank]));\n    send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1]/*.Len*/, 3);\n  }\n  //Tracev((stderr, \"\\nbl tree: sent %ld\", s->bits_sent));\n\n  send_tree(s, s.dyn_ltree, lcodes - 1); /* literal tree */\n  //Tracev((stderr, \"\\nlit tree: sent %ld\", s->bits_sent));\n\n  send_tree(s, s.dyn_dtree, dcodes - 1); /* distance tree */\n  //Tracev((stderr, \"\\ndist tree: sent %ld\", s->bits_sent));\n}\n\n\n/* ===========================================================================\n * Check if the data type is TEXT or BINARY, using the following algorithm:\n * - TEXT if the two conditions below are satisfied:\n *    a) There are no non-portable control characters belonging to the\n *       \"black list\" (0..6, 14..25, 28..31).\n *    b) There is at least one printable character belonging to the\n *       \"white list\" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).\n * - BINARY otherwise.\n * - The following partially-portable control characters form a\n *   \"gray list\" that is ignored in this detection algorithm:\n *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).\n * IN assertion: the fields Freq of dyn_ltree are set.\n */\nfunction detect_data_type(s) {\n  /* black_mask is the bit mask of black-listed bytes\n   * set bits 0..6, 14..25, and 28..31\n   * 0xf3ffc07f = binary 11110011111111111100000001111111\n   */\n  var black_mask = 0xf3ffc07f;\n  var n;\n\n  /* Check for non-textual (\"black-listed\") bytes. */\n  for (n = 0; n <= 31; n++, black_mask >>>= 1) {\n    if ((black_mask & 1) && (s.dyn_ltree[n * 2]/*.Freq*/ !== 0)) {\n      return Z_BINARY;\n    }\n  }\n\n  /* Check for textual (\"white-listed\") bytes. */\n  if (s.dyn_ltree[9 * 2]/*.Freq*/ !== 0 || s.dyn_ltree[10 * 2]/*.Freq*/ !== 0 ||\n      s.dyn_ltree[13 * 2]/*.Freq*/ !== 0) {\n    return Z_TEXT;\n  }\n  for (n = 32; n < LITERALS; n++) {\n    if (s.dyn_ltree[n * 2]/*.Freq*/ !== 0) {\n      return Z_TEXT;\n    }\n  }\n\n  /* There are no \"black-listed\" or \"white-listed\" bytes:\n   * this stream either is empty or has tolerated (\"gray-listed\") bytes only.\n   */\n  return Z_BINARY;\n}\n\n\nvar static_init_done = false;\n\n/* ===========================================================================\n * Initialize the tree data structures for a new zlib stream.\n */\nfunction _tr_init(s)\n{\n\n  if (!static_init_done) {\n    tr_static_init();\n    static_init_done = true;\n  }\n\n  s.l_desc  = new TreeDesc(s.dyn_ltree, static_l_desc);\n  s.d_desc  = new TreeDesc(s.dyn_dtree, static_d_desc);\n  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);\n\n  s.bi_buf = 0;\n  s.bi_valid = 0;\n\n  /* Initialize the first block of the first file: */\n  init_block(s);\n}\n\n\n/* ===========================================================================\n * Send a stored block\n */\nfunction _tr_stored_block(s, buf, stored_len, last)\n//DeflateState *s;\n//charf *buf;       /* input block */\n//ulg stored_len;   /* length of input block */\n//int last;         /* one if this is the last block for a file */\n{\n  send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);    /* send block type */\n  copy_block(s, buf, stored_len, true); /* with header */\n}\n\n\n/* ===========================================================================\n * Send one empty static block to give enough lookahead for inflate.\n * This takes 10 bits, of which 7 may remain in the bit buffer.\n */\nfunction _tr_align(s) {\n  send_bits(s, STATIC_TREES << 1, 3);\n  send_code(s, END_BLOCK, static_ltree);\n  bi_flush(s);\n}\n\n\n/* ===========================================================================\n * Determine the best encoding for the current block: dynamic trees, static\n * trees or store, and output the encoded block to the zip file.\n */\nfunction _tr_flush_block(s, buf, stored_len, last)\n//DeflateState *s;\n//charf *buf;       /* input block, or NULL if too old */\n//ulg stored_len;   /* length of input block */\n//int last;         /* one if this is the last block for a file */\n{\n  var opt_lenb, static_lenb;  /* opt_len and static_len in bytes */\n  var max_blindex = 0;        /* index of last bit length code of non zero freq */\n\n  /* Build the Huffman trees unless a stored block is forced */\n  if (s.level > 0) {\n\n    /* Check if the file is binary or text */\n    if (s.strm.data_type === Z_UNKNOWN) {\n      s.strm.data_type = detect_data_type(s);\n    }\n\n    /* Construct the literal and distance trees */\n    build_tree(s, s.l_desc);\n    // Tracev((stderr, \"\\nlit data: dyn %ld, stat %ld\", s->opt_len,\n    //        s->static_len));\n\n    build_tree(s, s.d_desc);\n    // Tracev((stderr, \"\\ndist data: dyn %ld, stat %ld\", s->opt_len,\n    //        s->static_len));\n    /* At this point, opt_len and static_len are the total bit lengths of\n     * the compressed block data, excluding the tree representations.\n     */\n\n    /* Build the bit length tree for the above two trees, and get the index\n     * in bl_order of the last bit length code to send.\n     */\n    max_blindex = build_bl_tree(s);\n\n    /* Determine the best encoding. Compute the block lengths in bytes. */\n    opt_lenb = (s.opt_len + 3 + 7) >>> 3;\n    static_lenb = (s.static_len + 3 + 7) >>> 3;\n\n    // Tracev((stderr, \"\\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u \",\n    //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,\n    //        s->last_lit));\n\n    if (static_lenb <= opt_lenb) { opt_lenb = static_lenb; }\n\n  } else {\n    // Assert(buf != (char*)0, \"lost buf\");\n    opt_lenb = static_lenb = stored_len + 5; /* force a stored block */\n  }\n\n  if ((stored_len + 4 <= opt_lenb) && (buf !== -1)) {\n    /* 4: two words for the lengths */\n\n    /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.\n     * Otherwise we can't have processed more than WSIZE input bytes since\n     * the last block flush, because compression would have been\n     * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to\n     * transform a block into a stored block.\n     */\n    _tr_stored_block(s, buf, stored_len, last);\n\n  } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {\n\n    send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);\n    compress_block(s, static_ltree, static_dtree);\n\n  } else {\n    send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);\n    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);\n    compress_block(s, s.dyn_ltree, s.dyn_dtree);\n  }\n  // Assert (s->compressed_len == s->bits_sent, \"bad compressed size\");\n  /* The above check is made mod 2^32, for files larger than 512 MB\n   * and uLong implemented on 32 bits.\n   */\n  init_block(s);\n\n  if (last) {\n    bi_windup(s);\n  }\n  // Tracev((stderr,\"\\ncomprlen %lu(%lu) \", s->compressed_len>>3,\n  //       s->compressed_len-7*last));\n}\n\n/* ===========================================================================\n * Save the match info and tally the frequency counts. Return true if\n * the current block must be flushed.\n */\nfunction _tr_tally(s, dist, lc)\n//    deflate_state *s;\n//    unsigned dist;  /* distance of matched string */\n//    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */\n{\n  //var out_length, in_length, dcode;\n\n  s.pending_buf[s.d_buf + s.last_lit * 2]     = (dist >>> 8) & 0xff;\n  s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 0xff;\n\n  s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff;\n  s.last_lit++;\n\n  if (dist === 0) {\n    /* lc is the unmatched char */\n    s.dyn_ltree[lc * 2]/*.Freq*/++;\n  } else {\n    s.matches++;\n    /* Here, lc is the match length - MIN_MATCH */\n    dist--;             /* dist = match distance - 1 */\n    //Assert((ush)dist < (ush)MAX_DIST(s) &&\n    //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&\n    //       (ush)d_code(dist) < (ush)D_CODES,  \"_tr_tally: bad match\");\n\n    s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]/*.Freq*/++;\n    s.dyn_dtree[d_code(dist) * 2]/*.Freq*/++;\n  }\n\n// (!) This block is disabled in zlib defaults,\n// don't enable it for binary compatibility\n\n//#ifdef TRUNCATE_BLOCK\n//  /* Try to guess if it is profitable to stop the current block here */\n//  if ((s.last_lit & 0x1fff) === 0 && s.level > 2) {\n//    /* Compute an upper bound for the compressed length */\n//    out_length = s.last_lit*8;\n//    in_length = s.strstart - s.block_start;\n//\n//    for (dcode = 0; dcode < D_CODES; dcode++) {\n//      out_length += s.dyn_dtree[dcode*2]/*.Freq*/ * (5 + extra_dbits[dcode]);\n//    }\n//    out_length >>>= 3;\n//    //Tracev((stderr,\"\\nlast_lit %u, in %ld, out ~%ld(%ld%%) \",\n//    //       s->last_lit, in_length, out_length,\n//    //       100L - out_length*100L/in_length));\n//    if (s.matches < (s.last_lit>>1)/*int /2*/ && out_length < (in_length>>1)/*int /2*/) {\n//      return true;\n//    }\n//  }\n//#endif\n\n  return (s.last_lit === s.lit_bufsize - 1);\n  /* We avoid equality with lit_bufsize because of wraparound at 64K\n   * on 16 bit machines and because stored blocks are restricted to\n   * 64K-1 bytes.\n   */\n}\n\nexports._tr_init  = _tr_init;\nexports._tr_stored_block = _tr_stored_block;\nexports._tr_flush_block  = _tr_flush_block;\nexports._tr_tally = _tr_tally;\nexports._tr_align = _tr_align;\n","'use strict';\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nfunction ZStream() {\n  /* next input byte */\n  this.input = null; // JS specific, because we have no pointers\n  this.next_in = 0;\n  /* number of bytes available at input */\n  this.avail_in = 0;\n  /* total number of input bytes read so far */\n  this.total_in = 0;\n  /* next output byte should be put there */\n  this.output = null; // JS specific, because we have no pointers\n  this.next_out = 0;\n  /* remaining free space at output */\n  this.avail_out = 0;\n  /* total number of bytes output so far */\n  this.total_out = 0;\n  /* last error message, NULL if no error */\n  this.msg = ''/*Z_NULL*/;\n  /* not visible by applications */\n  this.state = null;\n  /* best guess about the data type: binary or text */\n  this.data_type = 2/*Z_UNKNOWN*/;\n  /* adler32 value of the uncompressed data */\n  this.adler = 0;\n}\n\nmodule.exports = ZStream;\n","'use strict';\n\nvar has = Object.prototype.hasOwnProperty\n  , undef;\n\n/**\n * Decode a URI encoded string.\n *\n * @param {String} input The URI encoded string.\n * @returns {String|Null} The decoded string.\n * @api private\n */\nfunction decode(input) {\n  try {\n    return decodeURIComponent(input.replace(/\\+/g, ' '));\n  } catch (e) {\n    return null;\n  }\n}\n\n/**\n * Attempts to encode a given input.\n *\n * @param {String} input The string that needs to be encoded.\n * @returns {String|Null} The encoded string.\n * @api private\n */\nfunction encode(input) {\n  try {\n    return encodeURIComponent(input);\n  } catch (e) {\n    return null;\n  }\n}\n\n/**\n * Simple query string parser.\n *\n * @param {String} query The query string that needs to be parsed.\n * @returns {Object}\n * @api public\n */\nfunction querystring(query) {\n  var parser = /([^=?#&]+)=?([^&]*)/g\n    , result = {}\n    , part;\n\n  while (part = parser.exec(query)) {\n    var key = decode(part[1])\n      , value = decode(part[2]);\n\n    //\n    // Prevent overriding of existing properties. This ensures that build-in\n    // methods like `toString` or __proto__ are not overriden by malicious\n    // querystrings.\n    //\n    // In the case if failed decoding, we want to omit the key/value pairs\n    // from the result.\n    //\n    if (key === null || value === null || key in result) continue;\n    result[key] = value;\n  }\n\n  return result;\n}\n\n/**\n * Transform a query string to an object.\n *\n * @param {Object} obj Object that should be transformed.\n * @param {String} prefix Optional prefix.\n * @returns {String}\n * @api public\n */\nfunction querystringify(obj, prefix) {\n  prefix = prefix || '';\n\n  var pairs = []\n    , value\n    , key;\n\n  //\n  // Optionally prefix with a '?' if needed\n  //\n  if ('string' !== typeof prefix) prefix = '?';\n\n  for (key in obj) {\n    if (has.call(obj, key)) {\n      value = obj[key];\n\n      //\n      // Edge cases where we actually want to encode the value to an empty\n      // string instead of the stringified value.\n      //\n      if (!value && (value === null || value === undef || isNaN(value))) {\n        value = '';\n      }\n\n      key = encode(key);\n      value = encode(value);\n\n      //\n      // If we failed to encode the strings, we should bail out as we don't\n      // want to add invalid strings to the query.\n      //\n      if (key === null || value === null) continue;\n      pairs.push(key +'='+ value);\n    }\n  }\n\n  return pairs.length ? prefix + pairs.join('&') : '';\n}\n\n//\n// Expose the module.\n//\nexports.stringify = querystringify;\nexports.parse = querystring;\n","'use strict';\n\n/**\n * Check if we're required to add a port number.\n *\n * @see https://url.spec.whatwg.org/#default-port\n * @param {Number|String} port Port number we need to check\n * @param {String} protocol Protocol we need to check against.\n * @returns {Boolean} Is it a default port for the given protocol\n * @api private\n */\nmodule.exports = function required(port, protocol) {\n  protocol = protocol.split(':')[0];\n  port = +port;\n\n  if (!port) return false;\n\n  switch (protocol) {\n    case 'http':\n    case 'ws':\n    return port !== 80;\n\n    case 'https':\n    case 'wss':\n    return port !== 443;\n\n    case 'ftp':\n    return port !== 21;\n\n    case 'gopher':\n    return port !== 70;\n\n    case 'file':\n    return false;\n  }\n\n  return port !== 0;\n};\n","var atob = require(\"atob\")\nvar urlLib = require(\"url\")\nvar pathLib = require(\"path\")\nvar decodeUriComponentLib = require(\"decode-uri-component\")\n\n\n\nfunction resolveUrl(/* ...urls */) {\n  return Array.prototype.reduce.call(arguments, function(resolved, nextUrl) {\n    return urlLib.resolve(resolved, nextUrl)\n  })\n}\n\nfunction convertWindowsPath(aPath) {\n  return pathLib.sep === \"\\\\\" ? aPath.replace(/\\\\/g, \"/\").replace(/^[a-z]:\\/?/i, \"/\") : aPath\n}\n\nfunction customDecodeUriComponent(string) {\n  // `decodeUriComponentLib` turns `+` into ` `, but that's not wanted.\n  return decodeUriComponentLib(string.replace(/\\+/g, \"%2B\"))\n}\n\nfunction callbackAsync(callback, error, result) {\n  setImmediate(function() { callback(error, result) })\n}\n\nfunction parseMapToJSON(string, data) {\n  try {\n    return JSON.parse(string.replace(/^\\)\\]\\}'/, \"\"))\n  } catch (error) {\n    error.sourceMapData = data\n    throw error\n  }\n}\n\nfunction readSync(read, url, data) {\n  var readUrl = customDecodeUriComponent(url)\n  try {\n    return String(read(readUrl))\n  } catch (error) {\n    error.sourceMapData = data\n    throw error\n  }\n}\n\n\n\nvar innerRegex = /[#@] sourceMappingURL=([^\\s'\"]*)/\n\nvar sourceMappingURLRegex = RegExp(\n  \"(?:\" +\n    \"/\\\\*\" +\n    \"(?:\\\\s*\\r?\\n(?://)?)?\" +\n    \"(?:\" + innerRegex.source + \")\" +\n    \"\\\\s*\" +\n    \"\\\\*/\" +\n    \"|\" +\n    \"//(?:\" + innerRegex.source + \")\" +\n  \")\" +\n  \"\\\\s*\"\n)\n\nfunction getSourceMappingUrl(code) {\n  var match = code.match(sourceMappingURLRegex)\n  return match ? match[1] || match[2] || \"\" : null\n}\n\n\n\nfunction resolveSourceMap(code, codeUrl, read, callback) {\n  var mapData\n  try {\n    mapData = resolveSourceMapHelper(code, codeUrl)\n  } catch (error) {\n    return callbackAsync(callback, error)\n  }\n  if (!mapData || mapData.map) {\n    return callbackAsync(callback, null, mapData)\n  }\n  var readUrl = customDecodeUriComponent(mapData.url)\n  read(readUrl, function(error, result) {\n    if (error) {\n      error.sourceMapData = mapData\n      return callback(error)\n    }\n    mapData.map = String(result)\n    try {\n      mapData.map = parseMapToJSON(mapData.map, mapData)\n    } catch (error) {\n      return callback(error)\n    }\n    callback(null, mapData)\n  })\n}\n\nfunction resolveSourceMapSync(code, codeUrl, read) {\n  var mapData = resolveSourceMapHelper(code, codeUrl)\n  if (!mapData || mapData.map) {\n    return mapData\n  }\n  mapData.map = readSync(read, mapData.url, mapData)\n  mapData.map = parseMapToJSON(mapData.map, mapData)\n  return mapData\n}\n\nvar dataUriRegex = /^data:([^,;]*)(;[^,;]*)*(?:,(.*))?$/\n\n/**\n * The media type for JSON text is application/json.\n *\n * {@link https://tools.ietf.org/html/rfc8259#section-11 | IANA Considerations }\n *\n * `text/json` is non-standard media type\n */\nvar jsonMimeTypeRegex = /^(?:application|text)\\/json$/\n\n/**\n * JSON text exchanged between systems that are not part of a closed ecosystem\n * MUST be encoded using UTF-8.\n *\n * {@link https://tools.ietf.org/html/rfc8259#section-8.1 | Character Encoding}\n */\nvar jsonCharacterEncoding = \"utf-8\"\n\nfunction base64ToBuf(b64) {\n  var binStr = atob(b64)\n  var len = binStr.length\n  var arr = new Uint8Array(len)\n  for (var i = 0; i < len; i++) {\n    arr[i] = binStr.charCodeAt(i)\n  }\n  return arr\n}\n\nfunction decodeBase64String(b64) {\n  if (typeof TextDecoder === \"undefined\" || typeof Uint8Array === \"undefined\") {\n    return atob(b64)\n  }\n  var buf = base64ToBuf(b64);\n  // Note: `decoder.decode` method will throw a `DOMException` with the\n  // `\"EncodingError\"` value when an coding error is found.\n  var decoder = new TextDecoder(jsonCharacterEncoding, {fatal: true})\n  return decoder.decode(buf);\n}\n\nfunction resolveSourceMapHelper(code, codeUrl) {\n  codeUrl = convertWindowsPath(codeUrl)\n\n  var url = getSourceMappingUrl(code)\n  if (!url) {\n    return null\n  }\n\n  var dataUri = url.match(dataUriRegex)\n  if (dataUri) {\n    var mimeType = dataUri[1] || \"text/plain\"\n    var lastParameter = dataUri[2] || \"\"\n    var encoded = dataUri[3] || \"\"\n    var data = {\n      sourceMappingURL: url,\n      url: null,\n      sourcesRelativeTo: codeUrl,\n      map: encoded\n    }\n    if (!jsonMimeTypeRegex.test(mimeType)) {\n      var error = new Error(\"Unuseful data uri mime type: \" + mimeType)\n      error.sourceMapData = data\n      throw error\n    }\n    try {\n      data.map = parseMapToJSON(\n        lastParameter === \";base64\" ? decodeBase64String(encoded) : decodeURIComponent(encoded),\n        data\n      )\n    } catch (error) {\n      error.sourceMapData = data\n      throw error\n    }\n    return data\n  }\n\n  var mapUrl = resolveUrl(codeUrl, url)\n  return {\n    sourceMappingURL: url,\n    url: mapUrl,\n    sourcesRelativeTo: mapUrl,\n    map: null\n  }\n}\n\n\n\nfunction resolveSources(map, mapUrl, read, options, callback) {\n  if (typeof options === \"function\") {\n    callback = options\n    options = {}\n  }\n  var pending = map.sources ? map.sources.length : 0\n  var result = {\n    sourcesResolved: [],\n    sourcesContent:  []\n  }\n\n  if (pending === 0) {\n    callbackAsync(callback, null, result)\n    return\n  }\n\n  var done = function() {\n    pending--\n    if (pending === 0) {\n      callback(null, result)\n    }\n  }\n\n  resolveSourcesHelper(map, mapUrl, options, function(fullUrl, sourceContent, index) {\n    result.sourcesResolved[index] = fullUrl\n    if (typeof sourceContent === \"string\") {\n      result.sourcesContent[index] = sourceContent\n      callbackAsync(done, null)\n    } else {\n      var readUrl = customDecodeUriComponent(fullUrl)\n      read(readUrl, function(error, source) {\n        result.sourcesContent[index] = error ? error : String(source)\n        done()\n      })\n    }\n  })\n}\n\nfunction resolveSourcesSync(map, mapUrl, read, options) {\n  var result = {\n    sourcesResolved: [],\n    sourcesContent:  []\n  }\n\n  if (!map.sources || map.sources.length === 0) {\n    return result\n  }\n\n  resolveSourcesHelper(map, mapUrl, options, function(fullUrl, sourceContent, index) {\n    result.sourcesResolved[index] = fullUrl\n    if (read !== null) {\n      if (typeof sourceContent === \"string\") {\n        result.sourcesContent[index] = sourceContent\n      } else {\n        var readUrl = customDecodeUriComponent(fullUrl)\n        try {\n          result.sourcesContent[index] = String(read(readUrl))\n        } catch (error) {\n          result.sourcesContent[index] = error\n        }\n      }\n    }\n  })\n\n  return result\n}\n\nvar endingSlash = /\\/?$/\n\nfunction resolveSourcesHelper(map, mapUrl, options, fn) {\n  options = options || {}\n  mapUrl = convertWindowsPath(mapUrl)\n  var fullUrl\n  var sourceContent\n  var sourceRoot\n  for (var index = 0, len = map.sources.length; index < len; index++) {\n    sourceRoot = null\n    if (typeof options.sourceRoot === \"string\") {\n      sourceRoot = options.sourceRoot\n    } else if (typeof map.sourceRoot === \"string\" && options.sourceRoot !== false) {\n      sourceRoot = map.sourceRoot\n    }\n    // If the sourceRoot is the empty string, it is equivalent to not setting\n    // the property at all.\n    if (sourceRoot === null || sourceRoot === '') {\n      fullUrl = resolveUrl(mapUrl, map.sources[index])\n    } else {\n      // Make sure that the sourceRoot ends with a slash, so that `/scripts/subdir` becomes\n      // `/scripts/subdir/<source>`, not `/scripts/<source>`. Pointing to a file as source root\n      // does not make sense.\n      fullUrl = resolveUrl(mapUrl, sourceRoot.replace(endingSlash, \"/\"), map.sources[index])\n    }\n    sourceContent = (map.sourcesContent || [])[index]\n    fn(fullUrl, sourceContent, index)\n  }\n}\n\n\n\nfunction resolve(code, codeUrl, read, options, callback) {\n  if (typeof options === \"function\") {\n    callback = options\n    options = {}\n  }\n  if (code === null) {\n    var mapUrl = codeUrl\n    var data = {\n      sourceMappingURL: null,\n      url: mapUrl,\n      sourcesRelativeTo: mapUrl,\n      map: null\n    }\n    var readUrl = customDecodeUriComponent(mapUrl)\n    read(readUrl, function(error, result) {\n      if (error) {\n        error.sourceMapData = data\n        return callback(error)\n      }\n      data.map = String(result)\n      try {\n        data.map = parseMapToJSON(data.map, data)\n      } catch (error) {\n        return callback(error)\n      }\n      _resolveSources(data)\n    })\n  } else {\n    resolveSourceMap(code, codeUrl, read, function(error, mapData) {\n      if (error) {\n        return callback(error)\n      }\n      if (!mapData) {\n        return callback(null, null)\n      }\n      _resolveSources(mapData)\n    })\n  }\n\n  function _resolveSources(mapData) {\n    resolveSources(mapData.map, mapData.sourcesRelativeTo, read, options, function(error, result) {\n      if (error) {\n        return callback(error)\n      }\n      mapData.sourcesResolved = result.sourcesResolved\n      mapData.sourcesContent  = result.sourcesContent\n      callback(null, mapData)\n    })\n  }\n}\n\nfunction resolveSync(code, codeUrl, read, options) {\n  var mapData\n  if (code === null) {\n    var mapUrl = codeUrl\n    mapData = {\n      sourceMappingURL: null,\n      url: mapUrl,\n      sourcesRelativeTo: mapUrl,\n      map: null\n    }\n    mapData.map = readSync(read, mapUrl, mapData)\n    mapData.map = parseMapToJSON(mapData.map, mapData)\n  } else {\n    mapData = resolveSourceMapSync(code, codeUrl, read)\n    if (!mapData) {\n      return null\n    }\n  }\n  var result = resolveSourcesSync(mapData.map, mapData.sourcesRelativeTo, read, options)\n  mapData.sourcesResolved = result.sourcesResolved\n  mapData.sourcesContent  = result.sourcesContent\n  return mapData\n}\n\n\n\nmodule.exports = {\n  resolveSourceMap:     resolveSourceMap,\n  resolveSourceMapSync: resolveSourceMapSync,\n  resolveSources:       resolveSources,\n  resolveSourcesSync:   resolveSourcesSync,\n  resolve:              resolve,\n  resolveSync:          resolveSync,\n  parseMapToJSON:       parseMapToJSON\n}\n","'use strict';\n\nvar required = require('requires-port')\n  , qs = require('querystringify')\n  , slashes = /^[A-Za-z][A-Za-z0-9+-.]*:\\/\\//\n  , protocolre = /^([a-z][a-z0-9.+-]*:)?(\\/\\/)?([\\\\/]+)?([\\S\\s]*)/i\n  , windowsDriveLetter = /^[a-zA-Z]:/\n  , whitespace = '[\\\\x09\\\\x0A\\\\x0B\\\\x0C\\\\x0D\\\\x20\\\\xA0\\\\u1680\\\\u180E\\\\u2000\\\\u2001\\\\u2002\\\\u2003\\\\u2004\\\\u2005\\\\u2006\\\\u2007\\\\u2008\\\\u2009\\\\u200A\\\\u202F\\\\u205F\\\\u3000\\\\u2028\\\\u2029\\\\uFEFF]'\n  , left = new RegExp('^'+ whitespace +'+');\n\n/**\n * Trim a given string.\n *\n * @param {String} str String to trim.\n * @public\n */\nfunction trimLeft(str) {\n  return (str ? str : '').toString().replace(left, '');\n}\n\n/**\n * These are the parse rules for the URL parser, it informs the parser\n * about:\n *\n * 0. The char it Needs to parse, if it's a string it should be done using\n *    indexOf, RegExp using exec and NaN means set as current value.\n * 1. The property we should set when parsing this value.\n * 2. Indication if it's backwards or forward parsing, when set as number it's\n *    the value of extra chars that should be split off.\n * 3. Inherit from location if non existing in the parser.\n * 4. `toLowerCase` the resulting value.\n */\nvar rules = [\n  ['#', 'hash'],                        // Extract from the back.\n  ['?', 'query'],                       // Extract from the back.\n  function sanitize(address, url) {     // Sanitize what is left of the address\n    return isSpecial(url.protocol) ? address.replace(/\\\\/g, '/') : address;\n  },\n  ['/', 'pathname'],                    // Extract from the back.\n  ['@', 'auth', 1],                     // Extract from the front.\n  [NaN, 'host', undefined, 1, 1],       // Set left over value.\n  [/:(\\d+)$/, 'port', undefined, 1],    // RegExp the back.\n  [NaN, 'hostname', undefined, 1, 1]    // Set left over.\n];\n\n/**\n * These properties should not be copied or inherited from. This is only needed\n * for all non blob URL's as a blob URL does not include a hash, only the\n * origin.\n *\n * @type {Object}\n * @private\n */\nvar ignore = { hash: 1, query: 1 };\n\n/**\n * The location object differs when your code is loaded through a normal page,\n * Worker or through a worker using a blob. And with the blobble begins the\n * trouble as the location object will contain the URL of the blob, not the\n * location of the page where our code is loaded in. The actual origin is\n * encoded in the `pathname` so we can thankfully generate a good \"default\"\n * location from it so we can generate proper relative URL's again.\n *\n * @param {Object|String} loc Optional default location object.\n * @returns {Object} lolcation object.\n * @public\n */\nfunction lolcation(loc) {\n  var globalVar;\n\n  if (typeof window !== 'undefined') globalVar = window;\n  else if (typeof global !== 'undefined') globalVar = global;\n  else if (typeof self !== 'undefined') globalVar = self;\n  else globalVar = {};\n\n  var location = globalVar.location || {};\n  loc = loc || location;\n\n  var finaldestination = {}\n    , type = typeof loc\n    , key;\n\n  if ('blob:' === loc.protocol) {\n    finaldestination = new Url(unescape(loc.pathname), {});\n  } else if ('string' === type) {\n    finaldestination = new Url(loc, {});\n    for (key in ignore) delete finaldestination[key];\n  } else if ('object' === type) {\n    for (key in loc) {\n      if (key in ignore) continue;\n      finaldestination[key] = loc[key];\n    }\n\n    if (finaldestination.slashes === undefined) {\n      finaldestination.slashes = slashes.test(loc.href);\n    }\n  }\n\n  return finaldestination;\n}\n\n/**\n * Check whether a protocol scheme is special.\n *\n * @param {String} The protocol scheme of the URL\n * @return {Boolean} `true` if the protocol scheme is special, else `false`\n * @private\n */\nfunction isSpecial(scheme) {\n  return (\n    scheme === 'file:' ||\n    scheme === 'ftp:' ||\n    scheme === 'http:' ||\n    scheme === 'https:' ||\n    scheme === 'ws:' ||\n    scheme === 'wss:'\n  );\n}\n\n/**\n * @typedef ProtocolExtract\n * @type Object\n * @property {String} protocol Protocol matched in the URL, in lowercase.\n * @property {Boolean} slashes `true` if protocol is followed by \"//\", else `false`.\n * @property {String} rest Rest of the URL that is not part of the protocol.\n */\n\n/**\n * Extract protocol information from a URL with/without double slash (\"//\").\n *\n * @param {String} address URL we want to extract from.\n * @param {Object} location\n * @return {ProtocolExtract} Extracted information.\n * @private\n */\nfunction extractProtocol(address, location) {\n  address = trimLeft(address);\n  location = location || {};\n\n  var match = protocolre.exec(address);\n  var protocol = match[1] ? match[1].toLowerCase() : '';\n  var forwardSlashes = !!match[2];\n  var otherSlashes = !!match[3];\n  var slashesCount = 0;\n  var rest;\n\n  if (forwardSlashes) {\n    if (otherSlashes) {\n      rest = match[2] + match[3] + match[4];\n      slashesCount = match[2].length + match[3].length;\n    } else {\n      rest = match[2] + match[4];\n      slashesCount = match[2].length;\n    }\n  } else {\n    if (otherSlashes) {\n      rest = match[3] + match[4];\n      slashesCount = match[3].length;\n    } else {\n      rest = match[4]\n    }\n  }\n\n  if (protocol === 'file:') {\n    if (slashesCount >= 2) {\n      rest = rest.slice(2);\n    }\n  } else if (isSpecial(protocol)) {\n    rest = match[4];\n  } else if (protocol) {\n    if (forwardSlashes) {\n      rest = rest.slice(2);\n    }\n  } else if (slashesCount >= 2 && isSpecial(location.protocol)) {\n    rest = match[4];\n  }\n\n  return {\n    protocol: protocol,\n    slashes: forwardSlashes || isSpecial(protocol),\n    slashesCount: slashesCount,\n    rest: rest\n  };\n}\n\n/**\n * Resolve a relative URL pathname against a base URL pathname.\n *\n * @param {String} relative Pathname of the relative URL.\n * @param {String} base Pathname of the base URL.\n * @return {String} Resolved pathname.\n * @private\n */\nfunction resolve(relative, base) {\n  if (relative === '') return base;\n\n  var path = (base || '/').split('/').slice(0, -1).concat(relative.split('/'))\n    , i = path.length\n    , last = path[i - 1]\n    , unshift = false\n    , up = 0;\n\n  while (i--) {\n    if (path[i] === '.') {\n      path.splice(i, 1);\n    } else if (path[i] === '..') {\n      path.splice(i, 1);\n      up++;\n    } else if (up) {\n      if (i === 0) unshift = true;\n      path.splice(i, 1);\n      up--;\n    }\n  }\n\n  if (unshift) path.unshift('');\n  if (last === '.' || last === '..') path.push('');\n\n  return path.join('/');\n}\n\n/**\n * The actual URL instance. Instead of returning an object we've opted-in to\n * create an actual constructor as it's much more memory efficient and\n * faster and it pleases my OCD.\n *\n * It is worth noting that we should not use `URL` as class name to prevent\n * clashes with the global URL instance that got introduced in browsers.\n *\n * @constructor\n * @param {String} address URL we want to parse.\n * @param {Object|String} [location] Location defaults for relative paths.\n * @param {Boolean|Function} [parser] Parser for the query string.\n * @private\n */\nfunction Url(address, location, parser) {\n  address = trimLeft(address);\n\n  if (!(this instanceof Url)) {\n    return new Url(address, location, parser);\n  }\n\n  var relative, extracted, parse, instruction, index, key\n    , instructions = rules.slice()\n    , type = typeof location\n    , url = this\n    , i = 0;\n\n  //\n  // The following if statements allows this module two have compatibility with\n  // 2 different API:\n  //\n  // 1. Node.js's `url.parse` api which accepts a URL, boolean as arguments\n  //    where the boolean indicates that the query string should also be parsed.\n  //\n  // 2. The `URL` interface of the browser which accepts a URL, object as\n  //    arguments. The supplied object will be used as default values / fall-back\n  //    for relative paths.\n  //\n  if ('object' !== type && 'string' !== type) {\n    parser = location;\n    location = null;\n  }\n\n  if (parser && 'function' !== typeof parser) parser = qs.parse;\n\n  location = lolcation(location);\n\n  //\n  // Extract protocol information before running the instructions.\n  //\n  extracted = extractProtocol(address || '', location);\n  relative = !extracted.protocol && !extracted.slashes;\n  url.slashes = extracted.slashes || relative && location.slashes;\n  url.protocol = extracted.protocol || location.protocol || '';\n  address = extracted.rest;\n\n  //\n  // When the authority component is absent the URL starts with a path\n  // component.\n  //\n  if (\n    extracted.protocol === 'file:' && (\n      extracted.slashesCount !== 2 || windowsDriveLetter.test(address)) ||\n    (!extracted.slashes &&\n      (extracted.protocol ||\n        extracted.slashesCount < 2 ||\n        !isSpecial(url.protocol)))\n  ) {\n    instructions[3] = [/(.*)/, 'pathname'];\n  }\n\n  for (; i < instructions.length; i++) {\n    instruction = instructions[i];\n\n    if (typeof instruction === 'function') {\n      address = instruction(address, url);\n      continue;\n    }\n\n    parse = instruction[0];\n    key = instruction[1];\n\n    if (parse !== parse) {\n      url[key] = address;\n    } else if ('string' === typeof parse) {\n      if (~(index = address.indexOf(parse))) {\n        if ('number' === typeof instruction[2]) {\n          url[key] = address.slice(0, index);\n          address = address.slice(index + instruction[2]);\n        } else {\n          url[key] = address.slice(index);\n          address = address.slice(0, index);\n        }\n      }\n    } else if ((index = parse.exec(address))) {\n      url[key] = index[1];\n      address = address.slice(0, index.index);\n    }\n\n    url[key] = url[key] || (\n      relative && instruction[3] ? location[key] || '' : ''\n    );\n\n    //\n    // Hostname, host and protocol should be lowercased so they can be used to\n    // create a proper `origin`.\n    //\n    if (instruction[4]) url[key] = url[key].toLowerCase();\n  }\n\n  //\n  // Also parse the supplied query string in to an object. If we're supplied\n  // with a custom parser as function use that instead of the default build-in\n  // parser.\n  //\n  if (parser) url.query = parser(url.query);\n\n  //\n  // If the URL is relative, resolve the pathname against the base URL.\n  //\n  if (\n      relative\n    && location.slashes\n    && url.pathname.charAt(0) !== '/'\n    && (url.pathname !== '' || location.pathname !== '')\n  ) {\n    url.pathname = resolve(url.pathname, location.pathname);\n  }\n\n  //\n  // Default to a / for pathname if none exists. This normalizes the URL\n  // to always have a /\n  //\n  if (url.pathname.charAt(0) !== '/' && isSpecial(url.protocol)) {\n    url.pathname = '/' + url.pathname;\n  }\n\n  //\n  // We should not add port numbers if they are already the default port number\n  // for a given protocol. As the host also contains the port number we're going\n  // override it with the hostname which contains no port number.\n  //\n  if (!required(url.port, url.protocol)) {\n    url.host = url.hostname;\n    url.port = '';\n  }\n\n  //\n  // Parse down the `auth` for the username and password.\n  //\n  url.username = url.password = '';\n  if (url.auth) {\n    instruction = url.auth.split(':');\n    url.username = instruction[0] || '';\n    url.password = instruction[1] || '';\n  }\n\n  url.origin = url.protocol !== 'file:' && isSpecial(url.protocol) && url.host\n    ? url.protocol +'//'+ url.host\n    : 'null';\n\n  //\n  // The href is just the compiled result.\n  //\n  url.href = url.toString();\n}\n\n/**\n * This is convenience method for changing properties in the URL instance to\n * insure that they all propagate correctly.\n *\n * @param {String} part          Property we need to adjust.\n * @param {Mixed} value          The newly assigned value.\n * @param {Boolean|Function} fn  When setting the query, it will be the function\n *                               used to parse the query.\n *                               When setting the protocol, double slash will be\n *                               removed from the final url if it is true.\n * @returns {URL} URL instance for chaining.\n * @public\n */\nfunction set(part, value, fn) {\n  var url = this;\n\n  switch (part) {\n    case 'query':\n      if ('string' === typeof value && value.length) {\n        value = (fn || qs.parse)(value);\n      }\n\n      url[part] = value;\n      break;\n\n    case 'port':\n      url[part] = value;\n\n      if (!required(value, url.protocol)) {\n        url.host = url.hostname;\n        url[part] = '';\n      } else if (value) {\n        url.host = url.hostname +':'+ value;\n      }\n\n      break;\n\n    case 'hostname':\n      url[part] = value;\n\n      if (url.port) value += ':'+ url.port;\n      url.host = value;\n      break;\n\n    case 'host':\n      url[part] = value;\n\n      if (/:\\d+$/.test(value)) {\n        value = value.split(':');\n        url.port = value.pop();\n        url.hostname = value.join(':');\n      } else {\n        url.hostname = value;\n        url.port = '';\n      }\n\n      break;\n\n    case 'protocol':\n      url.protocol = value.toLowerCase();\n      url.slashes = !fn;\n      break;\n\n    case 'pathname':\n    case 'hash':\n      if (value) {\n        var char = part === 'pathname' ? '/' : '#';\n        url[part] = value.charAt(0) !== char ? char + value : value;\n      } else {\n        url[part] = value;\n      }\n      break;\n\n    default:\n      url[part] = value;\n  }\n\n  for (var i = 0; i < rules.length; i++) {\n    var ins = rules[i];\n\n    if (ins[4]) url[ins[1]] = url[ins[1]].toLowerCase();\n  }\n\n  url.origin = url.protocol !== 'file:' && isSpecial(url.protocol) && url.host\n    ? url.protocol +'//'+ url.host\n    : 'null';\n\n  url.href = url.toString();\n\n  return url;\n}\n\n/**\n * Transform the properties back in to a valid and full URL string.\n *\n * @param {Function} stringify Optional query stringify function.\n * @returns {String} Compiled version of the URL.\n * @public\n */\nfunction toString(stringify) {\n  if (!stringify || 'function' !== typeof stringify) stringify = qs.stringify;\n\n  var query\n    , url = this\n    , protocol = url.protocol;\n\n  if (protocol && protocol.charAt(protocol.length - 1) !== ':') protocol += ':';\n\n  var result = protocol + (url.slashes || isSpecial(url.protocol) ? '//' : '');\n\n  if (url.username) {\n    result += url.username;\n    if (url.password) result += ':'+ url.password;\n    result += '@';\n  }\n\n  result += url.host + url.pathname;\n\n  query = 'object' === typeof url.query ? stringify(url.query) : url.query;\n  if (query) result += '?' !== query.charAt(0) ? '?'+ query : query;\n\n  if (url.hash) result += url.hash;\n\n  return result;\n}\n\nUrl.prototype = { set: set, toString: toString };\n\n//\n// Expose the URL parser and some additional properties that might be useful for\n// others or testing.\n//\nUrl.extractProtocol = extractProtocol;\nUrl.location = lolcation;\nUrl.trimLeft = trimLeft;\nUrl.qs = qs;\n\nmodule.exports = Url;\n","module.exports = require(\"child_process\");","module.exports = require(\"constants\");","module.exports = require(\"inspector\");"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA;AAEA;AACA;AACA;AACA;AACA;AAOA;AAAA;AACA;AADA;AACA;AAKA;AAKA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAFA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AAFA;AACA;AAOA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AAKA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAlCA;AAkCA;AACA;AA9CA;AAAA;AAAA;AAgDA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAzDA;AAAA;AAAA;AA2DA;AAAA;AAAA;AACA;AAAA;AACA;AA7DA;AAAA;AAAA;AA8DA;AAAA;AAAA;AACA;AAAA;AACA;AAhEA;AAAA;AAAA;AAiEA;AAAA;AAAA;AACA;AAAA;AACA;AAnEA;AAAA;AAAA;AAoEA;AAAA;AAAA;AACA;AAAA;AACA;AAtEA;AAAA;AAAA;AAuEA;AAAA;AAAA;AACA;AAAA;AACA;AAzEA;AAAA;AAAA;AA4EA;AACA;AA7EA;AAAA;AAAA;AAgFA;AACA;AACA;AACA;AAnFA;AACA;AADA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACrJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;ACvFA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC/CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC9BA;AACA;AACA;AACA;;;;;;;;;;;;;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACnFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC9CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACvFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACnGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC9GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC1GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC/EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACruCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC5ZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACnZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACjiBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC1GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC1JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACzKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACxFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACtHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACnCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC5DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACpEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACnQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACrIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACxMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC1HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACjHA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACrhBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACnDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACrJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACnfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC7QA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC1LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACxDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC3MA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AChXA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AChQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACxNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC3KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACzGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC1JA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC1DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACrEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACrHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACzGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC1FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;AC3IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACxGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACxGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACzEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACtEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACrQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACxKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC7GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;AChGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACXA;;;;;;;;;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC9KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACjDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;AC1OA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACzVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;ACvIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC7LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACnDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACvKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACtPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACvJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC3CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACxDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC/OA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACvIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACvKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AChGA;AACA;AACA;;;;;;;;;;;;;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AClBA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC5DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AChKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC/TA;AACA;AACA;;;;;;;;;;;;;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACjDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC7DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC1IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC/CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;AC3EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC7DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACnCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACjdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC7JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AClDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC7EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC1FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACjIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;AClGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACnFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACvEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC/DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;ACxIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACpJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACvEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACzNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC3BA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC5KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC18FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;AC7FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC5aA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACrHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACzVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACjMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC3vBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACxDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACnGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACxEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC1FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACnDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC9JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC3EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC1FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC1FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC1FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC5GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AClGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC1DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACxKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACvFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AClJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACjFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACrMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC9eA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACnFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC/YA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACtaA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACxGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC1LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AClDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACnEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC1DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACj1DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACzDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACxVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACnhDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACtVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACrsCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC9CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACrHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACxXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC7gBA;;;;;;;;;;;;ACAA;;;;;;;;;;;;;;;ACAA;;;;A","sourceRoot":""}