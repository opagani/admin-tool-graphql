exports.id = "index";
exports.modules = {

/***/ "../../modules/monitor-node/src/plugins/node-vitals-plugin/nodeVitals.ts":
/*!************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/modules/monitor-node/src/plugins/node-vitals-plugin/nodeVitals.ts ***!
  \************************************************************************************************************************/
/*! exports provided: Bytes, default */
/*! exports used: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export Bytes */
/* harmony import */ var core_js_modules_es_array_for_each_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! core-js/modules/es.array.for-each.js */ "../../node_modules/core-js/modules/es.array.for-each.js");
/* harmony import */ var core_js_modules_es_array_for_each_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_for_each_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var core_js_modules_web_dom_collections_for_each_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! core-js/modules/web.dom-collections.for-each.js */ "../../node_modules/core-js/modules/web.dom-collections.for-each.js");
/* harmony import */ var core_js_modules_web_dom_collections_for_each_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_web_dom_collections_for_each_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var core_js_modules_es_array_concat_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! core-js/modules/es.array.concat.js */ "../../node_modules/core-js/modules/es.array.concat.js");
/* harmony import */ var core_js_modules_es_array_concat_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_concat_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var core_js_modules_es_regexp_exec_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! core-js/modules/es.regexp.exec.js */ "../../node_modules/core-js/modules/es.regexp.exec.js");
/* harmony import */ var core_js_modules_es_regexp_exec_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_regexp_exec_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var core_js_modules_es_string_split_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! core-js/modules/es.string.split.js */ "../../node_modules/core-js/modules/es.string.split.js");
/* harmony import */ var core_js_modules_es_string_split_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_string_split_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var core_js_modules_es_string_replace_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! core-js/modules/es.string.replace.js */ "../../node_modules/core-js/modules/es.string.replace.js");
/* harmony import */ var core_js_modules_es_string_replace_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_string_replace_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var core_js_modules_es_date_to_string_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! core-js/modules/es.date.to-string.js */ "../../node_modules/core-js/modules/es.date.to-string.js");
/* harmony import */ var core_js_modules_es_date_to_string_js__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_date_to_string_js__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var core_js_modules_es_object_to_string_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! core-js/modules/es.object.to-string.js */ "../../node_modules/core-js/modules/es.object.to-string.js");
/* harmony import */ var core_js_modules_es_object_to_string_js__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_object_to_string_js__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var core_js_modules_es_regexp_to_string_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! core-js/modules/es.regexp.to-string.js */ "../../node_modules/core-js/modules/es.regexp.to-string.js");
/* harmony import */ var core_js_modules_es_regexp_to_string_js__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_regexp_to_string_js__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var core_js_modules_es_parse_int_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! core-js/modules/es.parse-int.js */ "../../node_modules/core-js/modules/es.parse-int.js");
/* harmony import */ var core_js_modules_es_parse_int_js__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_parse_int_js__WEBPACK_IMPORTED_MODULE_9__);
/* harmony import */ var core_js_modules_es_object_define_property_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! core-js/modules/es.object.define-property.js */ "../../node_modules/core-js/modules/es.object.define-property.js");
/* harmony import */ var core_js_modules_es_object_define_property_js__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_object_define_property_js__WEBPACK_IMPORTED_MODULE_10__);
/* harmony import */ var os__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! os */ "os");
/* harmony import */ var os__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(os__WEBPACK_IMPORTED_MODULE_11__);
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! fs */ "fs");
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_12___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_12__);
/* harmony import */ var v8__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! v8 */ "v8");
/* harmony import */ var v8__WEBPACK_IMPORTED_MODULE_13___default = /*#__PURE__*/__webpack_require__.n(v8__WEBPACK_IMPORTED_MODULE_13__);
/* harmony import */ var perf_hooks__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! perf_hooks */ "perf_hooks");
/* harmony import */ var perf_hooks__WEBPACK_IMPORTED_MODULE_14___default = /*#__PURE__*/__webpack_require__.n(perf_hooks__WEBPACK_IMPORTED_MODULE_14__);
/* harmony import */ var event_loop_stats__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! event-loop-stats */ "../../node_modules/event-loop-stats/src/eventLoopStats.js");
/* harmony import */ var event_loop_stats__WEBPACK_IMPORTED_MODULE_15___default = /*#__PURE__*/__webpack_require__.n(event_loop_stats__WEBPACK_IMPORTED_MODULE_15__);
var _gcFlagMap;













function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }






var gcFlagMap = (_gcFlagMap = {}, _defineProperty(_gcFlagMap, perf_hooks__WEBPACK_IMPORTED_MODULE_14__["constants"].NODE_PERFORMANCE_GC_MAJOR, 'MarkSweepCompact'), _defineProperty(_gcFlagMap, perf_hooks__WEBPACK_IMPORTED_MODULE_14__["constants"].NODE_PERFORMANCE_GC_MINOR, 'Scavange'), _defineProperty(_gcFlagMap, perf_hooks__WEBPACK_IMPORTED_MODULE_14__["constants"].NODE_PERFORMANCE_GC_INCREMENTAL, 'IncrementalMarking'), _defineProperty(_gcFlagMap, perf_hooks__WEBPACK_IMPORTED_MODULE_14__["constants"].NODE_PERFORMANCE_GC_WEAKCB, 'ProcessWeakCallbacks'), _gcFlagMap);
var observer;
var Bytes = {
  toKb: function toKb(bytes) {
    return Math.round(bytes / 1024);
  },
  toMb: function toMb(bytes) {
    return Math.round(bytes / 1024 / 1024);
  }
};
/* harmony default export */ __webpack_exports__["a"] = ({
  start: function start(_ref) {
    var increment = _ref.increment;

    if (increment) {
      increment({
        name: 'App startup',
        amount: 1
      });
      observer = new perf_hooks__WEBPACK_IMPORTED_MODULE_14__["PerformanceObserver"](function (list) {
        list.getEntries().forEach(function (entry) {
          // @ts-ignore the type definition is missing this property
          var kindFlag = entry.kind;
          var typeName = "".concat(kindFlag, "-").concat(gcFlagMap[kindFlag]);
          var pauseMS = Math.round(entry.duration);
          increment({
            name: 'gc type ' + typeName,
            amount: 1
          });
          increment({
            name: 'gc pause ms',
            amount: pauseMS
          });
          increment({
            name: 'gc type ' + typeName + ' pause ms',
            amount: pauseMS
          });
        });
      });
      observer.observe({
        entryTypes: ['gc']
      });
    }
  },
  stop: function stop() {
    observer.disconnect();
  },
  record: function record(_ref2) {
    var buildInfo = _ref2.buildInfo,
        increment = _ref2.increment,
        gauge = _ref2.gauge;
    var serverType = buildInfo.serverType;
    var loopStats = event_loop_stats__WEBPACK_IMPORTED_MODULE_15___default.a.sense();

    if (increment) {
      increment({
        name: 'App heartbeat ' + serverType,
        amount: 1
      });
      increment({
        name: 'App heartbeat type-build ' + serverType + ' ' + buildInfo.buildNumber,
        amount: 1
      });
      increment({
        name: 'App heartbeat type-commit ' + serverType + ' ' + buildInfo.gitCommit,
        amount: 1
      });
      increment({
        name: 'App heartbeat build ' + buildInfo.buildNumber,
        amount: 1
      });
      increment({
        name: 'App heartbeat commit ' + buildInfo.gitCommit,
        amount: 1
      });
      increment({
        name: 'event loops',
        amount: loopStats.num
      });
    }

    if (gauge) {
      var loadavg = os__WEBPACK_IMPORTED_MODULE_11___default.a.loadavg();
      var loadavgScaler = 1000; //pontoon rounds to integer, scale for additional precision

      gauge({
        name: 'os load avg 1m',
        amount: loadavg[0] * loadavgScaler
      });
      gauge({
        name: 'os load avg 5m',
        amount: loadavg[1] * loadavgScaler
      });
      gauge({
        name: 'os load avg 15m',
        amount: loadavg[2] * loadavgScaler
      });
      var totalmem = os__WEBPACK_IMPORTED_MODULE_11___default.a.totalmem();
      var freemem = os__WEBPACK_IMPORTED_MODULE_11___default.a.freemem();
      var usedmem = totalmem - freemem;
      gauge({
        name: 'memory total MB',
        amount: Bytes.toMb(totalmem)
      });
      gauge({
        name: 'memory free MB',
        amount: Bytes.toMb(freemem)
      });
      gauge({
        name: 'memory used MB',
        amount: Bytes.toMb(usedmem)
      });
      var memoryUsage = process.memoryUsage();
      gauge({
        name: 'node memory mb rss',
        amount: Bytes.toMb(memoryUsage.rss)
      });
      gauge({
        name: 'node memory mb heapTotal',
        amount: Bytes.toMb(memoryUsage.heapTotal)
      });
      gauge({
        name: 'node memory mb heapUsed',
        amount: Bytes.toMb(memoryUsage.heapUsed)
      });
      gauge({
        name: 'node memory mb external',
        amount: Bytes.toMb(memoryUsage.external)
      });
      v8__WEBPACK_IMPORTED_MODULE_13___default.a.getHeapSpaceStatistics().forEach(function (_ref3) {
        var space_name = _ref3.space_name,
            space_size = _ref3.space_size,
            space_used_size = _ref3.space_used_size,
            space_available_size = _ref3.space_available_size,
            physical_space_size = _ref3.physical_space_size;
        var prefix = 'v8 heap kb ' + space_name + ' ';
        gauge({
          name: prefix + 'space_size',
          amount: Bytes.toKb(space_size)
        });
        gauge({
          name: prefix + 'space_used_size',
          amount: Bytes.toKb(space_used_size)
        });
        gauge({
          name: prefix + 'space_available_size',
          amount: Bytes.toKb(space_available_size)
        });
        gauge({
          name: prefix + 'physical_space_size',
          amount: Bytes.toKb(physical_space_size)
        });
      });
      gauge({
        name: 'event loop ms max',
        amount: loopStats.max
      });
      gauge({
        name: 'event loop ms min',
        amount: loopStats.min
      });
      gauge({
        name: 'event loop ms avg',
        amount: loopStats.sum / loopStats.num
      });
      fs__WEBPACK_IMPORTED_MODULE_12___default.a.readFile('/proc/sys/fs/file-nr', function (err, out) {
        if (!err) {
          var fileNrParts = out.toString().replace(/\n/g, '').split(' ');
          var fileHandles = parseInt(fileNrParts[0], 10);
          gauge({
            name: 'file-nr allocated file handles',
            amount: fileHandles
          });
        }
      });
    }
  }
});

/***/ }),

/***/ "../../modules/particles-js-healthcheck/src/index.ts":
/*!****************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/modules/particles-js-healthcheck/src/index.ts ***!
  \****************************************************************************************************/
/*! exports provided: BAD_SHUTDOWN_TOKEN_MSG, GOOD_STATUS_CODE, SHUTDOWN_STATUS_CODE, Healthcheck */
/*! exports used: Healthcheck */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export BAD_SHUTDOWN_TOKEN_MSG */
/* unused harmony export GOOD_STATUS_CODE */
/* unused harmony export SHUTDOWN_STATUS_CODE */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Healthcheck; });
/* harmony import */ var core_js_modules_es_number_constructor_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! core-js/modules/es.number.constructor.js */ "../../node_modules/core-js/modules/es.number.constructor.js");
/* harmony import */ var core_js_modules_es_number_constructor_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_number_constructor_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var core_js_modules_es_string_starts_with_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! core-js/modules/es.string.starts-with.js */ "../../node_modules/core-js/modules/es.string.starts-with.js");
/* harmony import */ var core_js_modules_es_string_starts_with_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_string_starts_with_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var core_js_modules_es_function_name_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! core-js/modules/es.function.name.js */ "../../node_modules/core-js/modules/es.function.name.js");
/* harmony import */ var core_js_modules_es_function_name_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_function_name_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var core_js_modules_es_array_includes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! core-js/modules/es.array.includes.js */ "../../node_modules/core-js/modules/es.array.includes.js");
/* harmony import */ var core_js_modules_es_array_includes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_includes_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var core_js_modules_es_string_includes_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! core-js/modules/es.string.includes.js */ "../../node_modules/core-js/modules/es.string.includes.js");
/* harmony import */ var core_js_modules_es_string_includes_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_string_includes_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var core_js_modules_es_object_define_property_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! core-js/modules/es.object.define-property.js */ "../../node_modules/core-js/modules/es.object.define-property.js");
/* harmony import */ var core_js_modules_es_object_define_property_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_object_define_property_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var core_js_modules_es_object_keys_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! core-js/modules/es.object.keys.js */ "../../node_modules/core-js/modules/es.object.keys.js");
/* harmony import */ var core_js_modules_es_object_keys_js__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_object_keys_js__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var core_js_modules_es_symbol_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! core-js/modules/es.symbol.js */ "../../node_modules/core-js/modules/es.symbol.js");
/* harmony import */ var core_js_modules_es_symbol_js__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_symbol_js__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var core_js_modules_es_array_filter_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! core-js/modules/es.array.filter.js */ "../../node_modules/core-js/modules/es.array.filter.js");
/* harmony import */ var core_js_modules_es_array_filter_js__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_filter_js__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var core_js_modules_es_object_get_own_property_descriptor_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! core-js/modules/es.object.get-own-property-descriptor.js */ "../../node_modules/core-js/modules/es.object.get-own-property-descriptor.js");
/* harmony import */ var core_js_modules_es_object_get_own_property_descriptor_js__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_object_get_own_property_descriptor_js__WEBPACK_IMPORTED_MODULE_9__);
/* harmony import */ var core_js_modules_es_array_for_each_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! core-js/modules/es.array.for-each.js */ "../../node_modules/core-js/modules/es.array.for-each.js");
/* harmony import */ var core_js_modules_es_array_for_each_js__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_for_each_js__WEBPACK_IMPORTED_MODULE_10__);
/* harmony import */ var core_js_modules_web_dom_collections_for_each_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! core-js/modules/web.dom-collections.for-each.js */ "../../node_modules/core-js/modules/web.dom-collections.for-each.js");
/* harmony import */ var core_js_modules_web_dom_collections_for_each_js__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_web_dom_collections_for_each_js__WEBPACK_IMPORTED_MODULE_11__);
/* harmony import */ var core_js_modules_es_object_get_own_property_descriptors_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! core-js/modules/es.object.get-own-property-descriptors.js */ "../../node_modules/core-js/modules/es.object.get-own-property-descriptors.js");
/* harmony import */ var core_js_modules_es_object_get_own_property_descriptors_js__WEBPACK_IMPORTED_MODULE_12___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_object_get_own_property_descriptors_js__WEBPACK_IMPORTED_MODULE_12__);
/* harmony import */ var core_js_modules_es_object_define_properties_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! core-js/modules/es.object.define-properties.js */ "../../node_modules/core-js/modules/es.object.define-properties.js");
/* harmony import */ var core_js_modules_es_object_define_properties_js__WEBPACK_IMPORTED_MODULE_13___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_object_define_properties_js__WEBPACK_IMPORTED_MODULE_13__);
/* harmony import */ var _zg_rentals_particles_js_utils__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @zg-rentals/particles-js-utils */ "../../modules/particles-js-utils/src/index.ts");
/* harmony import */ var os__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! os */ "os");
/* harmony import */ var os__WEBPACK_IMPORTED_MODULE_15___default = /*#__PURE__*/__webpack_require__.n(os__WEBPACK_IMPORTED_MODULE_15__);
/* harmony import */ var read_pkg__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! read-pkg */ "../../node_modules/read-pkg/index.js");
/* harmony import */ var read_pkg__WEBPACK_IMPORTED_MODULE_16___default = /*#__PURE__*/__webpack_require__.n(read_pkg__WEBPACK_IMPORTED_MODULE_16__);
/* harmony import */ var v8__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! v8 */ "v8");
/* harmony import */ var v8__WEBPACK_IMPORTED_MODULE_17___default = /*#__PURE__*/__webpack_require__.n(v8__WEBPACK_IMPORTED_MODULE_17__);















function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }





var BAD_SHUTDOWN_TOKEN_MSG = 'invalid shutdown token provided.';
var GOOD_STATUS_CODE = 200;
var SHUTDOWN_STATUS_CODE = 555;
var Healthcheck = /*#__PURE__*/function () {
  function Healthcheck(_ref) {
    var _this = this,
        _this$logger7;

    var logger = _ref.logger,
        shutdownToken = _ref.shutdownToken,
        accessToken = _ref.accessToken,
        _ref$buildNumber = _ref.buildNumber,
        buildNumber = _ref$buildNumber === void 0 ? 0 : _ref$buildNumber,
        onPing = _ref.onPing,
        _ref$protectedQueryPa = _ref.protectedQueryParams,
        protectedQueryParams = _ref$protectedQueryPa === void 0 ? ['runscope', 'sonar', 'liveliness', 'site_liveliness'] : _ref$protectedQueryPa,
        _ref$maxMemoryThresho = _ref.maxMemoryThresholdMb,
        maxMemoryThresholdMb = _ref$maxMemoryThresho === void 0 ? 5120 : _ref$maxMemoryThresho;

    _classCallCheck(this, Healthcheck);

    _defineProperty(this, "shutdownToken", void 0);

    _defineProperty(this, "protectedQueryParams", void 0);

    _defineProperty(this, "accessToken", void 0);

    _defineProperty(this, "isShuttingDown", void 0);

    _defineProperty(this, "logger", void 0);

    _defineProperty(this, "packageJson", void 0);

    _defineProperty(this, "buildNumber", void 0);

    _defineProperty(this, "onPing", void 0);

    _defineProperty(this, "maxMemoryThresholdMb", void 0);

    _defineProperty(this, "setupPm2GracefulExit", function () {
      if (_zg_rentals_particles_js_utils__WEBPACK_IMPORTED_MODULE_14__[/* Utils */ "b"].isProd() && process && process.send) {
        var _this$logger;

        (_this$logger = _this.logger) === null || _this$logger === void 0 ? void 0 : _this$logger.debug('setting up pm2 graceful exit');
        process.on('message', function (message) {
          var _this$logger2;

          (_this$logger2 = _this.logger) === null || _this$logger2 === void 0 ? void 0 : _this$logger2.warn(message, 'healthcheck received a process message');
          var topic = message.topic;

          if (topic === 'TRIGGER_SHUTDOWN') {
            _this.isShuttingDown = true;
          }
        });
      }
    });

    _defineProperty(this, "hasAccess", function (req) {
      if (!_this.accessToken) return false;
      if (req.query.accessToken === _this.accessToken) return true;
      return false;
    });

    _defineProperty(this, "aggregateConfidentialData", function (req) {
      var data = _objectSpread(_objectSpread(_objectSpread({}, _this.getPackageJsonData()), _this.getEnvironmentData()), _this.getServerData());

      if (_this.isMemoryOverloaded(data.memory_used)) {
        _this.isShuttingDown = true;
      }

      if (!_this.hasAccess(req)) {
        return;
      }

      return data;
    });

    _defineProperty(this, "getStatusCode", function (req) {
      if (_this.isShuttingDown) {
        var _this$logger4;

        if (_this.shouldIgnoreShutdown(req)) {
          var _this$logger3;

          (_this$logger3 = _this.logger) === null || _this$logger3 === void 0 ? void 0 : _this$logger3.warn("app is ignoring shutdown mode, returning status code=".concat(GOOD_STATUS_CODE));
          return GOOD_STATUS_CODE;
        }

        (_this$logger4 = _this.logger) === null || _this$logger4 === void 0 ? void 0 : _this$logger4.warn("app is in shutdown mode, returning status code=".concat(SHUTDOWN_STATUS_CODE));
        return SHUTDOWN_STATUS_CODE;
      } else {
        return GOOD_STATUS_CODE;
      }
    });

    _defineProperty(this, "check", function (req, res) {
      try {
        var confidentialData = _this.aggregateConfidentialData(req);

        var baseResponse = _this.generateBaseResponse();

        var status = _this.getStatusCode(req);

        var response = _objectSpread(_objectSpread({}, confidentialData), baseResponse);

        if (_this.onPing) {
          res.status(status).json(_this.onPing({
            hasAccess: _this.hasAccess(req),
            isProtected: _this.shouldIgnoreShutdown(req),
            response: response
          }));
        } else {
          res.status(status).json(response);
        }
      } catch (err) {
        res.status(500).json({
          error: err.message,
          success: false
        });
      }
    });

    _defineProperty(this, "shutdown", function (req, res) {
      var reqShutdownToken = req.query.secretToken;
      var isNotEmpty = reqShutdownToken !== '';
      var isDefined = typeof reqShutdownToken !== 'undefined' && typeof _this.shutdownToken !== 'undefined';

      if (isDefined && isNotEmpty && reqShutdownToken === _this.shutdownToken) {
        var _this$logger5;

        _this.isShuttingDown = true;
        (_this$logger5 = _this.logger) === null || _this$logger5 === void 0 ? void 0 : _this$logger5.warn('successful shutdownToken received, putting app in shutdown mode');
        res.status(200).json({
          success: true,
          statusCode: SHUTDOWN_STATUS_CODE
        });
      } else {
        var _this$logger6;

        (_this$logger6 = _this.logger) === null || _this$logger6 === void 0 ? void 0 : _this$logger6.warn('incorrect or missing shutdown token');
        res.status(500).json({
          success: false,
          error: BAD_SHUTDOWN_TOKEN_MSG
        });
      }
    });

    this.logger = logger;
    this.accessToken = accessToken;
    this.shutdownToken = shutdownToken;
    this.protectedQueryParams = protectedQueryParams;
    this.isShuttingDown = false;
    this.buildNumber = Number(buildNumber);
    this.setupPm2GracefulExit();
    this.packageJson = read_pkg__WEBPACK_IMPORTED_MODULE_16___default.a.sync();
    this.onPing = onPing;
    this.maxMemoryThresholdMb = maxMemoryThresholdMb;
    (_this$logger7 = this.logger) === null || _this$logger7 === void 0 ? void 0 : _this$logger7.info('instantiating healthcheck');
  }

  _createClass(Healthcheck, [{
    key: "bytesToMb",
    value: function bytesToMb(bytes) {
      if (bytes === 0) return 0;
      return bytes / 1024 / 1024;
    }
  }, {
    key: "getPackageJsonData",
    value: function getPackageJsonData() {
      var data = {
        dependencies: {},
        devDependencies: {}
      };
      var _this$packageJson = this.packageJson,
          _this$packageJson$dep = _this$packageJson.dependencies,
          dependencies = _this$packageJson$dep === void 0 ? {} : _this$packageJson$dep,
          _this$packageJson$dev = _this$packageJson.devDependencies,
          devDependencies = _this$packageJson$dev === void 0 ? {} : _this$packageJson$dev;

      for (var dependency in dependencies) {
        if (dependency.startsWith('@zg-rentals/')) {
          data.dependencies[dependency] = dependencies[dependency];
        }
      }

      for (var _dependency in devDependencies) {
        if (_dependency.startsWith('@zg-rentals/')) {
          data.devDependencies[_dependency] = devDependencies[_dependency];
        }
      }

      return data;
    }
  }, {
    key: "getEnvironmentData",
    value: function getEnvironmentData() {
      return {
        NODE_ENV: "development" || false,
        node_version: process.versions.node,
        gitCommit: process.env.GIT_COMMIT || '',
        gitUsername: process.env.GIT_COMMIT_AUTHOR || '',
        gitBranch: process.env.BRANCH_NAME || '',
        buildDate: process.env.BUILD_TIME || ''
      };
    }
  }, {
    key: "getServerData",
    value: function getServerData() {
      return {
        host: os__WEBPACK_IMPORTED_MODULE_15___default.a.hostname(),
        uptime: process.uptime(),
        memory_used: process.memoryUsage(),
        memory_total: os__WEBPACK_IMPORTED_MODULE_15___default.a.totalmem(),
        memory_free: os__WEBPACK_IMPORTED_MODULE_15___default.a.freemem(),
        average_load: os__WEBPACK_IMPORTED_MODULE_15___default.a.loadavg(),
        heap: v8__WEBPACK_IMPORTED_MODULE_17___default.a.getHeapStatistics()
      };
    }
  }, {
    key: "isMemoryOverloaded",
    value: function isMemoryOverloaded(memoryUsage) {
      if (!memoryUsage || !memoryUsage.rss) {
        return false;
      }

      var mb = this.bytesToMb(memoryUsage.rss);

      if (mb >= Number(this.maxMemoryThresholdMb)) {
        return true;
      }

      return false;
    }
  }, {
    key: "generateBaseResponse",
    value: function generateBaseResponse() {
      return {
        name: this.packageJson.name,
        buildNumber: this.buildNumber
      };
    }
  }, {
    key: "shouldIgnoreShutdown",
    value: function shouldIgnoreShutdown(req) {
      if (typeof req.query.mode === 'string' && this.protectedQueryParams.includes(req.query.mode)) {
        return true;
      }

      return false;
    }
  }]);

  return Healthcheck;
}();

/***/ }),

/***/ "../../modules/particles-js-node-logger/src/pinoLogger.ts":
/*!*********************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/modules/particles-js-node-logger/src/pinoLogger.ts ***!
  \*********************************************************************************************************/
/*! exports provided: PinoLogger */
/*! exports used: PinoLogger */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return PinoLogger; });
/* harmony import */ var core_js_modules_es_array_join_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! core-js/modules/es.array.join.js */ "../../node_modules/core-js/modules/es.array.join.js");
/* harmony import */ var core_js_modules_es_array_join_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_join_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var core_js_modules_es_object_define_property_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! core-js/modules/es.object.define-property.js */ "../../node_modules/core-js/modules/es.object.define-property.js");
/* harmony import */ var core_js_modules_es_object_define_property_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_object_define_property_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var core_js_modules_es_object_set_prototype_of_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! core-js/modules/es.object.set-prototype-of.js */ "../../node_modules/core-js/modules/es.object.set-prototype-of.js");
/* harmony import */ var core_js_modules_es_object_set_prototype_of_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_object_set_prototype_of_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var core_js_modules_es_object_get_prototype_of_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! core-js/modules/es.object.get-prototype-of.js */ "../../node_modules/core-js/modules/es.object.get-prototype-of.js");
/* harmony import */ var core_js_modules_es_object_get_prototype_of_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_object_get_prototype_of_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var core_js_modules_es_reflect_construct_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! core-js/modules/es.reflect.construct.js */ "../../node_modules/core-js/modules/es.reflect.construct.js");
/* harmony import */ var core_js_modules_es_reflect_construct_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_reflect_construct_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var core_js_modules_es_object_create_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! core-js/modules/es.object.create.js */ "../../node_modules/core-js/modules/es.object.create.js");
/* harmony import */ var core_js_modules_es_object_create_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_object_create_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var core_js_modules_es_object_keys_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! core-js/modules/es.object.keys.js */ "../../node_modules/core-js/modules/es.object.keys.js");
/* harmony import */ var core_js_modules_es_object_keys_js__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_object_keys_js__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var core_js_modules_es_symbol_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! core-js/modules/es.symbol.js */ "../../node_modules/core-js/modules/es.symbol.js");
/* harmony import */ var core_js_modules_es_symbol_js__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_symbol_js__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var core_js_modules_es_array_filter_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! core-js/modules/es.array.filter.js */ "../../node_modules/core-js/modules/es.array.filter.js");
/* harmony import */ var core_js_modules_es_array_filter_js__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_filter_js__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var core_js_modules_es_object_get_own_property_descriptor_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! core-js/modules/es.object.get-own-property-descriptor.js */ "../../node_modules/core-js/modules/es.object.get-own-property-descriptor.js");
/* harmony import */ var core_js_modules_es_object_get_own_property_descriptor_js__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_object_get_own_property_descriptor_js__WEBPACK_IMPORTED_MODULE_9__);
/* harmony import */ var core_js_modules_es_array_for_each_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! core-js/modules/es.array.for-each.js */ "../../node_modules/core-js/modules/es.array.for-each.js");
/* harmony import */ var core_js_modules_es_array_for_each_js__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_for_each_js__WEBPACK_IMPORTED_MODULE_10__);
/* harmony import */ var core_js_modules_web_dom_collections_for_each_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! core-js/modules/web.dom-collections.for-each.js */ "../../node_modules/core-js/modules/web.dom-collections.for-each.js");
/* harmony import */ var core_js_modules_web_dom_collections_for_each_js__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_web_dom_collections_for_each_js__WEBPACK_IMPORTED_MODULE_11__);
/* harmony import */ var core_js_modules_es_object_get_own_property_descriptors_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! core-js/modules/es.object.get-own-property-descriptors.js */ "../../node_modules/core-js/modules/es.object.get-own-property-descriptors.js");
/* harmony import */ var core_js_modules_es_object_get_own_property_descriptors_js__WEBPACK_IMPORTED_MODULE_12___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_object_get_own_property_descriptors_js__WEBPACK_IMPORTED_MODULE_12__);
/* harmony import */ var core_js_modules_es_object_define_properties_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! core-js/modules/es.object.define-properties.js */ "../../node_modules/core-js/modules/es.object.define-properties.js");
/* harmony import */ var core_js_modules_es_object_define_properties_js__WEBPACK_IMPORTED_MODULE_13___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_object_define_properties_js__WEBPACK_IMPORTED_MODULE_13__);
/* harmony import */ var core_js_modules_es_symbol_description_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! core-js/modules/es.symbol.description.js */ "../../node_modules/core-js/modules/es.symbol.description.js");
/* harmony import */ var core_js_modules_es_symbol_description_js__WEBPACK_IMPORTED_MODULE_14___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_symbol_description_js__WEBPACK_IMPORTED_MODULE_14__);
/* harmony import */ var core_js_modules_es_object_to_string_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! core-js/modules/es.object.to-string.js */ "../../node_modules/core-js/modules/es.object.to-string.js");
/* harmony import */ var core_js_modules_es_object_to_string_js__WEBPACK_IMPORTED_MODULE_15___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_object_to_string_js__WEBPACK_IMPORTED_MODULE_15__);
/* harmony import */ var core_js_modules_es_symbol_iterator_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! core-js/modules/es.symbol.iterator.js */ "../../node_modules/core-js/modules/es.symbol.iterator.js");
/* harmony import */ var core_js_modules_es_symbol_iterator_js__WEBPACK_IMPORTED_MODULE_16___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_symbol_iterator_js__WEBPACK_IMPORTED_MODULE_16__);
/* harmony import */ var core_js_modules_es_array_iterator_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! core-js/modules/es.array.iterator.js */ "../../node_modules/core-js/modules/es.array.iterator.js");
/* harmony import */ var core_js_modules_es_array_iterator_js__WEBPACK_IMPORTED_MODULE_17___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_iterator_js__WEBPACK_IMPORTED_MODULE_17__);
/* harmony import */ var core_js_modules_es_string_iterator_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! core-js/modules/es.string.iterator.js */ "../../node_modules/core-js/modules/es.string.iterator.js");
/* harmony import */ var core_js_modules_es_string_iterator_js__WEBPACK_IMPORTED_MODULE_18___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_string_iterator_js__WEBPACK_IMPORTED_MODULE_18__);
/* harmony import */ var core_js_modules_web_dom_collections_iterator_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! core-js/modules/web.dom-collections.iterator.js */ "../../node_modules/core-js/modules/web.dom-collections.iterator.js");
/* harmony import */ var core_js_modules_web_dom_collections_iterator_js__WEBPACK_IMPORTED_MODULE_19___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_web_dom_collections_iterator_js__WEBPACK_IMPORTED_MODULE_19__);
/* harmony import */ var _zg_rentals_particles_js_base_logger__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! @zg-rentals/particles-js-base-logger */ "../../modules/particles-js-base-logger/src/index.ts");
/* harmony import */ var child_process__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! child_process */ "child_process");
/* harmony import */ var child_process__WEBPACK_IMPORTED_MODULE_21___default = /*#__PURE__*/__webpack_require__.n(child_process__WEBPACK_IMPORTED_MODULE_21__);
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! fs */ "fs");
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_22___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_22__);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! path */ "path");
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_23___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_23__);
/* harmony import */ var pino__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! pino */ "../../modules/particles-js-node-logger/node_modules/pino/pino.js");
/* harmony import */ var pino__WEBPACK_IMPORTED_MODULE_24___default = /*#__PURE__*/__webpack_require__.n(pino__WEBPACK_IMPORTED_MODULE_24__);
/* harmony import */ var stream__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! stream */ "stream");
/* harmony import */ var stream__WEBPACK_IMPORTED_MODULE_25___default = /*#__PURE__*/__webpack_require__.n(stream__WEBPACK_IMPORTED_MODULE_25__);
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }






















function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }







var PinoLogger = /*#__PURE__*/function (_BaseLogger) {
  _inherits(PinoLogger, _BaseLogger);

  var _super = _createSuper(PinoLogger);

  function PinoLogger() {
    var _this;

    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$pinoArgs = _ref.pinoArgs,
        pinoArgs = _ref$pinoArgs === void 0 ? {} : _ref$pinoArgs,
        _ref$logPath = _ref.logPath,
        logPath = _ref$logPath === void 0 ? '' : _ref$logPath,
        _ref$prettyPath = _ref.prettyPath,
        prettyPath = _ref$prettyPath === void 0 ? 'node_modules/pino-pretty/bin.js' : _ref$prettyPath,
        _ref$__reset = _ref.__reset,
        __reset = _ref$__reset === void 0 ? function () {} : _ref$__reset;

    _classCallCheck(this, PinoLogger);

    _this = _super.call(this, {
      __reset: __reset,
      runtime: 'node'
    });

    _defineProperty(_assertThisInitialized(_this), "logger", void 0);

    _defineProperty(_assertThisInitialized(_this), "prettyLogger", void 0);

    _defineProperty(_assertThisInitialized(_this), "_enableLogSync", true);

    _defineProperty(_assertThisInitialized(_this), "runtime", void 0);

    _this.runtime = 'node';
    var cwd = process.cwd();
    var logThrough = new stream__WEBPACK_IMPORTED_MODULE_25___default.a.PassThrough();
    _this.logger = pino__WEBPACK_IMPORTED_MODULE_24___default()(_objectSpread({
      level: 'info'
    }, pinoArgs), logThrough);

    if (logPath) {
      logThrough.pipe(fs__WEBPACK_IMPORTED_MODULE_22___default.a.createWriteStream(logPath, {
        flags: 'a'
      }));
    }

    if (prettyPath) {
      var prettyLogger = child_process__WEBPACK_IMPORTED_MODULE_21___default.a.spawn(process.execPath, [path__WEBPACK_IMPORTED_MODULE_23___default.a.join(process.cwd(), prettyPath), '-c'], {
        cwd: cwd,
        env: process.env
      });
      logThrough.pipe(prettyLogger.stdin);
      prettyLogger.stdout.pipe(process.stdout);
      _this.prettyLogger = prettyLogger;
    } else {
      logThrough.pipe(process.stdout);
    }

    return _this;
  }

  _createClass(PinoLogger, [{
    key: "child",
    value: function child(name, bindings) {
      if (name.length > 255) {
        throw new Error("child logger name length is ".concat(name.length, ", must be less than 255"));
      }

      var logger = this.logger.child(_objectSpread(_objectSpread({}, bindings), {}, {
        name: name
      }));

      this._children.set(name, logger);

      return logger;
    }
  }, {
    key: "error",
    value: function error() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      this.logger.error(args);
    }
  }, {
    key: "warn",
    value: function warn() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      this.logger.warn(args);
    }
  }, {
    key: "info",
    value: function info() {
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }

      this.logger.info(args);
    }
  }, {
    key: "debug",
    value: function debug() {
      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }

      this.logger.debug(args);
    }
  }, {
    key: "trace",
    value: function trace() {
      for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
        args[_key5] = arguments[_key5];
      }

      this.logger.trace(args);
    }
  }, {
    key: "_getChildLogger",
    value: function _getChildLogger(name) {
      return this._children.get(name);
    }
  }, {
    key: "setChildLogLevel",
    value: function setChildLogLevel(name, level) {
      var logger = this._getChildLogger(name);

      if (logger) logger.level = level || process.env.LOG_LEVEL || 'warn';
    }
  }]);

  return PinoLogger;
}(_zg_rentals_particles_js_base_logger__WEBPACK_IMPORTED_MODULE_20__[/* BaseLogger */ "a"]);

/***/ }),

/***/ "../../node_modules/@datadog/native-appsec/index.js":
/*!***************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/@datadog/native-appsec/index.js ***!
  \***************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/). Copyright 2021 Datadog, Inc.
 **/

const { DDWAF } = __webpack_require__(/*! ./lib/loader */ "../../node_modules/@datadog/native-appsec/lib/loader.js").load()

module.exports.DDWAF = DDWAF


/***/ }),

/***/ "../../node_modules/@datadog/native-appsec/lib/loader.js":
/*!********************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/@datadog/native-appsec/lib/loader.js ***!
  \********************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/). Copyright 2021 Datadog, Inc.
 **/

const os = __webpack_require__(/*! os */ "os")
const detectLibc = __webpack_require__(/*! detect-libc */ "../../node_modules/detect-libc/lib/detect-libc.js")

const getDir = module.exports.getDir = function () {
  return `${os.platform()}-${os.arch()}-${detectLibc.family || 'unknown'}`
}

module.exports.load = function () {
  return __webpack_require__("../../node_modules/@datadog/native-appsec/vendor sync recursive ^\\.\\/.*\\/appsec\\.node$")(`./${getDir()}/appsec.node`)
}


/***/ }),

/***/ "../../node_modules/@datadog/native-appsec/vendor sync recursive ^\\.\\/.*\\/appsec\\.node$":
/*!*****************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/@datadog/native-appsec/vendor sync ^\.\/.*\/appsec\.node$ ***!
  \*****************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports) {

function webpackEmptyContext(req) {
	var e = new Error("Cannot find module '" + req + "'");
	e.code = 'MODULE_NOT_FOUND';
	throw e;
}
webpackEmptyContext.keys = function() { return []; };
webpackEmptyContext.resolve = webpackEmptyContext;
module.exports = webpackEmptyContext;
webpackEmptyContext.id = "../../node_modules/@datadog/native-appsec/vendor sync recursive ^\\.\\/.*\\/appsec\\.node$";

/***/ }),

/***/ "../../node_modules/@datadog/native-metrics/index.js":
/*!****************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/@datadog/native-metrics/index.js ***!
  \****************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const nativeMetrics = __webpack_require__(/*! node-gyp-build */ "../../node_modules/node-gyp-build/index.js")(__dirname)

module.exports = nativeMetrics


/***/ }),

/***/ "../../node_modules/@datadog/pprof/node_modules/pify/index.js":
/*!*************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/@datadog/pprof/node_modules/pify/index.js ***!
  \*************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const processFn = (fn, options, proxy, unwrapped) => function (...arguments_) {
	const P = options.promiseModule;

	return new P((resolve, reject) => {
		if (options.multiArgs) {
			arguments_.push((...result) => {
				if (options.errorFirst) {
					if (result[0]) {
						reject(result);
					} else {
						result.shift();
						resolve(result);
					}
				} else {
					resolve(result);
				}
			});
		} else if (options.errorFirst) {
			arguments_.push((error, result) => {
				if (error) {
					reject(error);
				} else {
					resolve(result);
				}
			});
		} else {
			arguments_.push(resolve);
		}

		const self = this === proxy ? unwrapped : this;
		Reflect.apply(fn, self, arguments_);
	});
};

const filterCache = new WeakMap();

module.exports = (input, options) => {
	options = {
		exclude: [/.+(?:Sync|Stream)$/],
		errorFirst: true,
		promiseModule: Promise,
		...options
	};

	const objectType = typeof input;
	if (!(input !== null && (objectType === 'object' || objectType === 'function'))) {
		throw new TypeError(`Expected \`input\` to be a \`Function\` or \`Object\`, got \`${input === null ? 'null' : objectType}\``);
	}

	const filter = (target, key) => {
		let cached = filterCache.get(target);

		if (!cached) {
			cached = {};
			filterCache.set(target, cached);
		}

		if (key in cached) {
			return cached[key];
		}

		const match = pattern => (typeof pattern === 'string' || typeof key === 'symbol') ? key === pattern : pattern.test(key);
		const desc = Reflect.getOwnPropertyDescriptor(target, key);
		const writableOrConfigurableOwn = (desc === undefined || desc.writable || desc.configurable);
		const included = options.include ? options.include.some(match) : !options.exclude.some(match);
		const shouldFilter = included && writableOrConfigurableOwn;
		cached[key] = shouldFilter;
		return shouldFilter;
	};

	const cache = new WeakMap();

	const proxy = new Proxy(input, {
		apply(target, thisArg, args) {
			const cached = cache.get(target);

			if (cached) {
				return Reflect.apply(cached, thisArg, args);
			}

			const pified = options.excludeMain ? target : processFn(target, options, proxy, target);
			cache.set(target, pified);
			return Reflect.apply(pified, thisArg, args);
		},

		get(target, key) {
			const property = target[key];

			// eslint-disable-next-line no-use-extend-native/no-use-extend-native
			if (!filter(target, key) || property === Function.prototype[key]) {
				return property;
			}

			const cached = cache.get(property);

			if (cached) {
				return cached;
			}

			if (typeof property === 'function') {
				const pified = processFn(property, options, proxy, target);
				cache.set(property, pified);
				return pified;
			}

			return property;
		}
	});

	return proxy;
};


/***/ }),

/***/ "../../node_modules/@datadog/pprof/node_modules/source-map/lib/array-set.js":
/*!***************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/@datadog/pprof/node_modules/source-map/lib/array-set.js ***!
  \***************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports) {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

/**
 * A data structure which is a combination of an array and a set. Adding a new
 * member is O(1), testing for membership is O(1), and finding the index of an
 * element is O(1). Removing elements from the set is not supported. Only
 * strings are supported for membership.
 */
class ArraySet {
  constructor() {
    this._array = [];
    this._set = new Map();
  }

  /**
   * Static method for creating ArraySet instances from an existing array.
   */
  static fromArray(aArray, aAllowDuplicates) {
    const set = new ArraySet();
    for (let i = 0, len = aArray.length; i < len; i++) {
      set.add(aArray[i], aAllowDuplicates);
    }
    return set;
  }

  /**
   * Return how many unique items are in this ArraySet. If duplicates have been
   * added, than those do not count towards the size.
   *
   * @returns Number
   */
  size() {
    return this._set.size;
  }

  /**
   * Add the given string to this set.
   *
   * @param String aStr
   */
  add(aStr, aAllowDuplicates) {
    const isDuplicate = this.has(aStr);
    const idx = this._array.length;
    if (!isDuplicate || aAllowDuplicates) {
      this._array.push(aStr);
    }
    if (!isDuplicate) {
      this._set.set(aStr, idx);
    }
  }

  /**
   * Is the given string a member of this set?
   *
   * @param String aStr
   */
  has(aStr) {
      return this._set.has(aStr);
  }

  /**
   * What is the index of the given string in the array?
   *
   * @param String aStr
   */
  indexOf(aStr) {
    const idx = this._set.get(aStr);
    if (idx >= 0) {
        return idx;
    }
    throw new Error('"' + aStr + '" is not in the set.');
  }

  /**
   * What is the element at the given index?
   *
   * @param Number aIdx
   */
  at(aIdx) {
    if (aIdx >= 0 && aIdx < this._array.length) {
      return this._array[aIdx];
    }
    throw new Error("No element indexed by " + aIdx);
  }

  /**
   * Returns the array representation of this set (which has the proper indices
   * indicated by indexOf). Note that this is a copy of the internal array used
   * for storing the members so that no one can mess with internal state.
   */
  toArray() {
    return this._array.slice();
  }
}
exports.ArraySet = ArraySet;


/***/ }),

/***/ "../../node_modules/@datadog/pprof/node_modules/source-map/lib/base64-vlq.js":
/*!****************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/@datadog/pprof/node_modules/source-map/lib/base64-vlq.js ***!
  \****************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 *
 * Based on the Base 64 VLQ implementation in Closure Compiler:
 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
 *
 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *  * Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above
 *    copyright notice, this list of conditions and the following
 *    disclaimer in the documentation and/or other materials provided
 *    with the distribution.
 *  * Neither the name of Google Inc. nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

const base64 = __webpack_require__(/*! ./base64 */ "../../node_modules/@datadog/pprof/node_modules/source-map/lib/base64.js");

// A single base 64 digit can contain 6 bits of data. For the base 64 variable
// length quantities we use in the source map spec, the first bit is the sign,
// the next four bits are the actual value, and the 6th bit is the
// continuation bit. The continuation bit tells us whether there are more
// digits in this value following this digit.
//
//   Continuation
//   |    Sign
//   |    |
//   V    V
//   101011

const VLQ_BASE_SHIFT = 5;

// binary: 100000
const VLQ_BASE = 1 << VLQ_BASE_SHIFT;

// binary: 011111
const VLQ_BASE_MASK = VLQ_BASE - 1;

// binary: 100000
const VLQ_CONTINUATION_BIT = VLQ_BASE;

/**
 * Converts from a two-complement value to a value where the sign bit is
 * placed in the least significant bit.  For example, as decimals:
 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
 */
function toVLQSigned(aValue) {
  return aValue < 0
    ? ((-aValue) << 1) + 1
    : (aValue << 1) + 0;
}

/**
 * Converts to a two-complement value from a value where the sign bit is
 * placed in the least significant bit.  For example, as decimals:
 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
 */
// eslint-disable-next-line no-unused-vars
function fromVLQSigned(aValue) {
  const isNegative = (aValue & 1) === 1;
  const shifted = aValue >> 1;
  return isNegative
    ? -shifted
    : shifted;
}

/**
 * Returns the base 64 VLQ encoded value.
 */
exports.encode = function base64VLQ_encode(aValue) {
  let encoded = "";
  let digit;

  let vlq = toVLQSigned(aValue);

  do {
    digit = vlq & VLQ_BASE_MASK;
    vlq >>>= VLQ_BASE_SHIFT;
    if (vlq > 0) {
      // There are still more digits in this value, so we must make sure the
      // continuation bit is marked.
      digit |= VLQ_CONTINUATION_BIT;
    }
    encoded += base64.encode(digit);
  } while (vlq > 0);

  return encoded;
};


/***/ }),

/***/ "../../node_modules/@datadog/pprof/node_modules/source-map/lib/base64.js":
/*!************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/@datadog/pprof/node_modules/source-map/lib/base64.js ***!
  \************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports) {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

const intToCharMap = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");

/**
 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
 */
exports.encode = function(number) {
  if (0 <= number && number < intToCharMap.length) {
    return intToCharMap[number];
  }
  throw new TypeError("Must be between 0 and 63: " + number);
};


/***/ }),

/***/ "../../node_modules/@datadog/pprof/node_modules/source-map/lib/binary-search.js":
/*!*******************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/@datadog/pprof/node_modules/source-map/lib/binary-search.js ***!
  \*******************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports) {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

exports.GREATEST_LOWER_BOUND = 1;
exports.LEAST_UPPER_BOUND = 2;

/**
 * Recursive implementation of binary search.
 *
 * @param aLow Indices here and lower do not contain the needle.
 * @param aHigh Indices here and higher do not contain the needle.
 * @param aNeedle The element being searched for.
 * @param aHaystack The non-empty array being searched.
 * @param aCompare Function which takes two elements and returns -1, 0, or 1.
 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 */
function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
  // This function terminates when one of the following is true:
  //
  //   1. We find the exact element we are looking for.
  //
  //   2. We did not find the exact element, but we can return the index of
  //      the next-closest element.
  //
  //   3. We did not find the exact element, and there is no next-closest
  //      element than the one we are searching for, so we return -1.
  const mid = Math.floor((aHigh - aLow) / 2) + aLow;
  const cmp = aCompare(aNeedle, aHaystack[mid], true);
  if (cmp === 0) {
    // Found the element we are looking for.
    return mid;
  } else if (cmp > 0) {
    // Our needle is greater than aHaystack[mid].
    if (aHigh - mid > 1) {
      // The element is in the upper half.
      return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
    }

    // The exact needle element was not found in this haystack. Determine if
    // we are in termination case (3) or (2) and return the appropriate thing.
    if (aBias == exports.LEAST_UPPER_BOUND) {
      return aHigh < aHaystack.length ? aHigh : -1;
    }
    return mid;
  }

  // Our needle is less than aHaystack[mid].
  if (mid - aLow > 1) {
    // The element is in the lower half.
    return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
  }

  // we are in termination case (3) or (2) and return the appropriate thing.
  if (aBias == exports.LEAST_UPPER_BOUND) {
    return mid;
  }
  return aLow < 0 ? -1 : aLow;
}

/**
 * This is an implementation of binary search which will always try and return
 * the index of the closest element if there is no exact hit. This is because
 * mappings between original and generated line/col pairs are single points,
 * and there is an implicit region between each of them, so a miss just means
 * that you aren't on the very start of a region.
 *
 * @param aNeedle The element you are looking for.
 * @param aHaystack The array that is being searched.
 * @param aCompare A function which takes the needle and an element in the
 *     array and returns -1, 0, or 1 depending on whether the needle is less
 *     than, equal to, or greater than the element, respectively.
 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.
 */
exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
  if (aHaystack.length === 0) {
    return -1;
  }

  let index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack,
                              aCompare, aBias || exports.GREATEST_LOWER_BOUND);
  if (index < 0) {
    return -1;
  }

  // We have found either the exact element, or the next-closest element than
  // the one we are searching for. However, there may be more than one such
  // element. Make sure we always return the smallest of these.
  while (index - 1 >= 0) {
    if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
      break;
    }
    --index;
  }

  return index;
};


/***/ }),

/***/ "../../node_modules/@datadog/pprof/node_modules/source-map/lib/mapping-list.js":
/*!******************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/@datadog/pprof/node_modules/source-map/lib/mapping-list.js ***!
  \******************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2014 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

const util = __webpack_require__(/*! ./util */ "../../node_modules/@datadog/pprof/node_modules/source-map/lib/util.js");

/**
 * Determine whether mappingB is after mappingA with respect to generated
 * position.
 */
function generatedPositionAfter(mappingA, mappingB) {
  // Optimized for most common case
  const lineA = mappingA.generatedLine;
  const lineB = mappingB.generatedLine;
  const columnA = mappingA.generatedColumn;
  const columnB = mappingB.generatedColumn;
  return lineB > lineA || lineB == lineA && columnB >= columnA ||
         util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
}

/**
 * A data structure to provide a sorted view of accumulated mappings in a
 * performance conscious manner. It trades a negligible overhead in general
 * case for a large speedup in case of mappings being added in order.
 */
class MappingList {
  constructor() {
    this._array = [];
    this._sorted = true;
    // Serves as infimum
    this._last = {generatedLine: -1, generatedColumn: 0};
  }

  /**
   * Iterate through internal items. This method takes the same arguments that
   * `Array.prototype.forEach` takes.
   *
   * NOTE: The order of the mappings is NOT guaranteed.
   */
  unsortedForEach(aCallback, aThisArg) {
    this._array.forEach(aCallback, aThisArg);
  }

  /**
   * Add the given source mapping.
   *
   * @param Object aMapping
   */
  add(aMapping) {
    if (generatedPositionAfter(this._last, aMapping)) {
      this._last = aMapping;
      this._array.push(aMapping);
    } else {
      this._sorted = false;
      this._array.push(aMapping);
    }
  }

  /**
   * Returns the flat, sorted array of mappings. The mappings are sorted by
   * generated position.
   *
   * WARNING: This method returns internal data without copying, for
   * performance. The return value must NOT be mutated, and should be treated as
   * an immutable borrow. If you want to take ownership, you must make your own
   * copy.
   */
  toArray() {
    if (!this._sorted) {
      this._array.sort(util.compareByGeneratedPositionsInflated);
      this._sorted = true;
    }
    return this._array;
  }
}

exports.MappingList = MappingList;


/***/ }),

/***/ "../../node_modules/@datadog/pprof/node_modules/source-map/lib/read-wasm.js":
/*!***************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/@datadog/pprof/node_modules/source-map/lib/read-wasm.js ***!
  \***************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

if (typeof fetch === "function") {
  // Web version of reading a wasm file into an array buffer.

  let mappingsWasmUrl = null;

  module.exports = function readWasm() {
    if (typeof mappingsWasmUrl !== "string") {
      throw new Error("You must provide the URL of lib/mappings.wasm by calling " +
                      "SourceMapConsumer.initialize({ 'lib/mappings.wasm': ... }) " +
                      "before using SourceMapConsumer");
    }

    return fetch(mappingsWasmUrl)
      .then(response => response.arrayBuffer());
  };

  module.exports.initialize = url => mappingsWasmUrl = url;
} else {
  // Node version of reading a wasm file into an array buffer.
  const fs = __webpack_require__(/*! fs */ "fs");
  const path = __webpack_require__(/*! path */ "path");

  module.exports = function readWasm() {
    return new Promise((resolve, reject) => {
      const wasmPath = path.join(__dirname, "mappings.wasm");
      fs.readFile(wasmPath, null, (error, data) => {
        if (error) {
          reject(error);
          return;
        }

        resolve(data.buffer);
      });
    });
  };

  module.exports.initialize = _ => {
    console.debug("SourceMapConsumer.initialize is a no-op when running in node.js");
  };
}


/***/ }),

/***/ "../../node_modules/@datadog/pprof/node_modules/source-map/lib/source-map-consumer.js":
/*!*************************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/@datadog/pprof/node_modules/source-map/lib/source-map-consumer.js ***!
  \*************************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

const util = __webpack_require__(/*! ./util */ "../../node_modules/@datadog/pprof/node_modules/source-map/lib/util.js");
const binarySearch = __webpack_require__(/*! ./binary-search */ "../../node_modules/@datadog/pprof/node_modules/source-map/lib/binary-search.js");
const ArraySet = __webpack_require__(/*! ./array-set */ "../../node_modules/@datadog/pprof/node_modules/source-map/lib/array-set.js").ArraySet;
const base64VLQ = __webpack_require__(/*! ./base64-vlq */ "../../node_modules/@datadog/pprof/node_modules/source-map/lib/base64-vlq.js"); // eslint-disable-line no-unused-vars
const readWasm = __webpack_require__(/*! ../lib/read-wasm */ "../../node_modules/@datadog/pprof/node_modules/source-map/lib/read-wasm.js");
const wasm = __webpack_require__(/*! ./wasm */ "../../node_modules/@datadog/pprof/node_modules/source-map/lib/wasm.js");

const INTERNAL = Symbol("smcInternal");

class SourceMapConsumer {
  constructor(aSourceMap, aSourceMapURL) {
    // If the constructor was called by super(), just return Promise<this>.
    // Yes, this is a hack to retain the pre-existing API of the base-class
    // constructor also being an async factory function.
    if (aSourceMap == INTERNAL) {
      return Promise.resolve(this);
    }

    return _factory(aSourceMap, aSourceMapURL);
  }

  static initialize(opts) {
    readWasm.initialize(opts["lib/mappings.wasm"]);
  }

  static fromSourceMap(aSourceMap, aSourceMapURL) {
    return _factoryBSM(aSourceMap, aSourceMapURL);
  }

  /**
   * Construct a new `SourceMapConsumer` from `rawSourceMap` and `sourceMapUrl`
   * (see the `SourceMapConsumer` constructor for details. Then, invoke the `async
   * function f(SourceMapConsumer) -> T` with the newly constructed consumer, wait
   * for `f` to complete, call `destroy` on the consumer, and return `f`'s return
   * value.
   *
   * You must not use the consumer after `f` completes!
   *
   * By using `with`, you do not have to remember to manually call `destroy` on
   * the consumer, since it will be called automatically once `f` completes.
   *
   * ```js
   * const xSquared = await SourceMapConsumer.with(
   *   myRawSourceMap,
   *   null,
   *   async function (consumer) {
   *     // Use `consumer` inside here and don't worry about remembering
   *     // to call `destroy`.
   *
   *     const x = await whatever(consumer);
   *     return x * x;
   *   }
   * );
   *
   * // You may not use that `consumer` anymore out here; it has
   * // been destroyed. But you can use `xSquared`.
   * console.log(xSquared);
   * ```
   */
  static with(rawSourceMap, sourceMapUrl, f) {
    // Note: The `acorn` version that `webpack` currently depends on doesn't
    // support `async` functions, and the nodes that we support don't all have
    // `.finally`. Therefore, this is written a bit more convolutedly than it
    // should really be.

    let consumer = null;
    const promise = new SourceMapConsumer(rawSourceMap, sourceMapUrl);
    return promise
      .then(c => {
        consumer = c;
        return f(c);
      })
      .then(x => {
        if (consumer) {
          consumer.destroy();
        }
        return x;
      }, e => {
        if (consumer) {
          consumer.destroy();
        }
        throw e;
      });
  }

  /**
   * Parse the mappings in a string in to a data structure which we can easily
   * query (the ordered arrays in the `this.__generatedMappings` and
   * `this.__originalMappings` properties).
   */
  _parseMappings(aStr, aSourceRoot) {
    throw new Error("Subclasses must implement _parseMappings");
  }

  /**
   * Iterate over each mapping between an original source/line/column and a
   * generated line/column in this source map.
   *
   * @param Function aCallback
   *        The function that is called with each mapping.
   * @param Object aContext
   *        Optional. If specified, this object will be the value of `this` every
   *        time that `aCallback` is called.
   * @param aOrder
   *        Either `SourceMapConsumer.GENERATED_ORDER` or
   *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
   *        iterate over the mappings sorted by the generated file's line/column
   *        order or the original's source/line/column order, respectively. Defaults to
   *        `SourceMapConsumer.GENERATED_ORDER`.
   */
  eachMapping(aCallback, aContext, aOrder) {
    throw new Error("Subclasses must implement eachMapping");
  }

  /**
   * Returns all generated line and column information for the original source,
   * line, and column provided. If no column is provided, returns all mappings
   * corresponding to a either the line we are searching for or the next
   * closest line that has any mappings. Otherwise, returns all mappings
   * corresponding to the given line and either the column we are searching for
   * or the next closest column that has any offsets.
   *
   * The only argument is an object with the following properties:
   *
   *   - source: The filename of the original source.
   *   - line: The line number in the original source.  The line number is 1-based.
   *   - column: Optional. the column number in the original source.
   *    The column number is 0-based.
   *
   * and an array of objects is returned, each with the following properties:
   *
   *   - line: The line number in the generated source, or null.  The
   *    line number is 1-based.
   *   - column: The column number in the generated source, or null.
   *    The column number is 0-based.
   */
  allGeneratedPositionsFor(aArgs) {
    throw new Error("Subclasses must implement allGeneratedPositionsFor");
  }

  destroy() {
    throw new Error("Subclasses must implement destroy");
  }
}

/**
 * The version of the source mapping spec that we are consuming.
 */
SourceMapConsumer.prototype._version = 3;
SourceMapConsumer.GENERATED_ORDER = 1;
SourceMapConsumer.ORIGINAL_ORDER = 2;

SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
SourceMapConsumer.LEAST_UPPER_BOUND = 2;

exports.SourceMapConsumer = SourceMapConsumer;

/**
 * A BasicSourceMapConsumer instance represents a parsed source map which we can
 * query for information about the original file positions by giving it a file
 * position in the generated source.
 *
 * The first parameter is the raw source map (either as a JSON string, or
 * already parsed to an object). According to the spec, source maps have the
 * following attributes:
 *
 *   - version: Which version of the source map spec this map is following.
 *   - sources: An array of URLs to the original source files.
 *   - names: An array of identifiers which can be referenced by individual mappings.
 *   - sourceRoot: Optional. The URL root from which all sources are relative.
 *   - sourcesContent: Optional. An array of contents of the original source files.
 *   - mappings: A string of base64 VLQs which contain the actual mappings.
 *   - file: Optional. The generated file this source map is associated with.
 *
 * Here is an example source map, taken from the source map spec[0]:
 *
 *     {
 *       version : 3,
 *       file: "out.js",
 *       sourceRoot : "",
 *       sources: ["foo.js", "bar.js"],
 *       names: ["src", "maps", "are", "fun"],
 *       mappings: "AA,AB;;ABCDE;"
 *     }
 *
 * The second parameter, if given, is a string whose value is the URL
 * at which the source map was found.  This URL is used to compute the
 * sources array.
 *
 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#
 */
class BasicSourceMapConsumer extends SourceMapConsumer {
  constructor(aSourceMap, aSourceMapURL) {
    return super(INTERNAL).then(that => {
      let sourceMap = aSourceMap;
      if (typeof aSourceMap === "string") {
        sourceMap = util.parseSourceMapInput(aSourceMap);
      }

      const version = util.getArg(sourceMap, "version");
      let sources = util.getArg(sourceMap, "sources");
      // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which
      // requires the array) to play nice here.
      const names = util.getArg(sourceMap, "names", []);
      let sourceRoot = util.getArg(sourceMap, "sourceRoot", null);
      const sourcesContent = util.getArg(sourceMap, "sourcesContent", null);
      const mappings = util.getArg(sourceMap, "mappings");
      const file = util.getArg(sourceMap, "file", null);

      // Once again, Sass deviates from the spec and supplies the version as a
      // string rather than a number, so we use loose equality checking here.
      if (version != that._version) {
        throw new Error("Unsupported version: " + version);
      }

      if (sourceRoot) {
        sourceRoot = util.normalize(sourceRoot);
      }

      sources = sources
        .map(String)
        // Some source maps produce relative source paths like "./foo.js" instead of
        // "foo.js".  Normalize these first so that future comparisons will succeed.
        // See bugzil.la/1090768.
        .map(util.normalize)
        // Always ensure that absolute sources are internally stored relative to
        // the source root, if the source root is absolute. Not doing this would
        // be particularly problematic when the source root is a prefix of the
        // source (valid, but why??). See github issue #199 and bugzil.la/1188982.
        .map(function(source) {
          return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source)
            ? util.relative(sourceRoot, source)
            : source;
        });

      // Pass `true` below to allow duplicate names and sources. While source maps
      // are intended to be compressed and deduplicated, the TypeScript compiler
      // sometimes generates source maps with duplicates in them. See Github issue
      // #72 and bugzil.la/889492.
      that._names = ArraySet.fromArray(names.map(String), true);
      that._sources = ArraySet.fromArray(sources, true);

      that._absoluteSources = that._sources.toArray().map(function(s) {
        return util.computeSourceURL(sourceRoot, s, aSourceMapURL);
      });

      that.sourceRoot = sourceRoot;
      that.sourcesContent = sourcesContent;
      that._mappings = mappings;
      that._sourceMapURL = aSourceMapURL;
      that.file = file;

      that._computedColumnSpans = false;
      that._mappingsPtr = 0;
      that._wasm = null;

      return wasm().then(w => {
        that._wasm = w;
        return that;
      });
    });
  }

  /**
   * Utility function to find the index of a source.  Returns -1 if not
   * found.
   */
  _findSourceIndex(aSource) {
    let relativeSource = aSource;
    if (this.sourceRoot != null) {
      relativeSource = util.relative(this.sourceRoot, relativeSource);
    }

    if (this._sources.has(relativeSource)) {
      return this._sources.indexOf(relativeSource);
    }

    // Maybe aSource is an absolute URL as returned by |sources|.  In
    // this case we can't simply undo the transform.
    for (let i = 0; i < this._absoluteSources.length; ++i) {
      if (this._absoluteSources[i] == aSource) {
        return i;
      }
    }

    return -1;
  }

  /**
   * Create a BasicSourceMapConsumer from a SourceMapGenerator.
   *
   * @param SourceMapGenerator aSourceMap
   *        The source map that will be consumed.
   * @param String aSourceMapURL
   *        The URL at which the source map can be found (optional)
   * @returns BasicSourceMapConsumer
   */
  static fromSourceMap(aSourceMap, aSourceMapURL) {
    return new BasicSourceMapConsumer(aSourceMap.toString());
  }

  get sources() {
    return this._absoluteSources.slice();
  }

  _getMappingsPtr() {
    if (this._mappingsPtr === 0) {
      this._parseMappings(this._mappings, this.sourceRoot);
    }

    return this._mappingsPtr;
  }

  /**
   * Parse the mappings in a string in to a data structure which we can easily
   * query (the ordered arrays in the `this.__generatedMappings` and
   * `this.__originalMappings` properties).
   */
  _parseMappings(aStr, aSourceRoot) {
    const size = aStr.length;

    const mappingsBufPtr = this._wasm.exports.allocate_mappings(size);
    const mappingsBuf = new Uint8Array(this._wasm.exports.memory.buffer, mappingsBufPtr, size);
    for (let i = 0; i < size; i++) {
      mappingsBuf[i] = aStr.charCodeAt(i);
    }

    const mappingsPtr = this._wasm.exports.parse_mappings(mappingsBufPtr);

    if (!mappingsPtr) {
      const error = this._wasm.exports.get_last_error();
      let msg = `Error parsing mappings (code ${error}): `;

      // XXX: keep these error codes in sync with `fitzgen/source-map-mappings`.
      switch (error) {
        case 1:
          msg += "the mappings contained a negative line, column, source index, or name index";
          break;
        case 2:
          msg += "the mappings contained a number larger than 2**32";
          break;
        case 3:
          msg += "reached EOF while in the middle of parsing a VLQ";
          break;
        case 4:
          msg += "invalid base 64 character while parsing a VLQ";
          break;
        default:
          msg += "unknown error code";
          break;
      }

      throw new Error(msg);
    }

    this._mappingsPtr = mappingsPtr;
  }

  eachMapping(aCallback, aContext, aOrder) {
    const context = aContext || null;
    const order = aOrder || SourceMapConsumer.GENERATED_ORDER;
    const sourceRoot = this.sourceRoot;

    this._wasm.withMappingCallback(
      mapping => {
        if (mapping.source !== null) {
          mapping.source = this._sources.at(mapping.source);
          mapping.source = util.computeSourceURL(sourceRoot, mapping.source, this._sourceMapURL);

          if (mapping.name !== null) {
            mapping.name = this._names.at(mapping.name);
          }
        }

        aCallback.call(context, mapping);
      },
      () => {
        switch (order) {
        case SourceMapConsumer.GENERATED_ORDER:
          this._wasm.exports.by_generated_location(this._getMappingsPtr());
          break;
        case SourceMapConsumer.ORIGINAL_ORDER:
          this._wasm.exports.by_original_location(this._getMappingsPtr());
          break;
        default:
          throw new Error("Unknown order of iteration.");
        }
      }
    );
  }

  allGeneratedPositionsFor(aArgs) {
    let source = util.getArg(aArgs, "source");
    const originalLine = util.getArg(aArgs, "line");
    const originalColumn = aArgs.column || 0;

    source = this._findSourceIndex(source);
    if (source < 0) {
      return [];
    }

    if (originalLine < 1) {
      throw new Error("Line numbers must be >= 1");
    }

    if (originalColumn < 0) {
      throw new Error("Column numbers must be >= 0");
    }

    const mappings = [];

    this._wasm.withMappingCallback(
      m => {
        let lastColumn = m.lastGeneratedColumn;
        if (this._computedColumnSpans && lastColumn === null) {
          lastColumn = Infinity;
        }
        mappings.push({
          line: m.generatedLine,
          column: m.generatedColumn,
          lastColumn,
        });
      }, () => {
        this._wasm.exports.all_generated_locations_for(
          this._getMappingsPtr(),
          source,
          originalLine - 1,
          "column" in aArgs,
          originalColumn
        );
      }
    );

    return mappings;
  }

  destroy() {
    if (this._mappingsPtr !== 0) {
      this._wasm.exports.free_mappings(this._mappingsPtr);
      this._mappingsPtr = 0;
    }
  }

  /**
   * Compute the last column for each generated mapping. The last column is
   * inclusive.
   */
  computeColumnSpans() {
    if (this._computedColumnSpans) {
      return;
    }

    this._wasm.exports.compute_column_spans(this._getMappingsPtr());
    this._computedColumnSpans = true;
  }

  /**
   * Returns the original source, line, and column information for the generated
   * source's line and column positions provided. The only argument is an object
   * with the following properties:
   *
   *   - line: The line number in the generated source.  The line number
   *     is 1-based.
   *   - column: The column number in the generated source.  The column
   *     number is 0-based.
   *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
   *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
   *     closest element that is smaller than or greater than the one we are
   *     searching for, respectively, if the exact element cannot be found.
   *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
   *
   * and an object is returned with the following properties:
   *
   *   - source: The original source file, or null.
   *   - line: The line number in the original source, or null.  The
   *     line number is 1-based.
   *   - column: The column number in the original source, or null.  The
   *     column number is 0-based.
   *   - name: The original identifier, or null.
   */
  originalPositionFor(aArgs) {
    const needle = {
      generatedLine: util.getArg(aArgs, "line"),
      generatedColumn: util.getArg(aArgs, "column")
    };

    if (needle.generatedLine < 1) {
      throw new Error("Line numbers must be >= 1");
    }

    if (needle.generatedColumn < 0) {
      throw new Error("Column numbers must be >= 0");
    }

    let bias = util.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND);
    if (bias == null) {
      bias = SourceMapConsumer.GREATEST_LOWER_BOUND;
    }

    let mapping;
    this._wasm.withMappingCallback(m => mapping = m, () => {
      this._wasm.exports.original_location_for(
        this._getMappingsPtr(),
        needle.generatedLine - 1,
        needle.generatedColumn,
        bias
      );
    });

    if (mapping) {
      if (mapping.generatedLine === needle.generatedLine) {
        let source = util.getArg(mapping, "source", null);
        if (source !== null) {
          source = this._sources.at(source);
          source = util.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);
        }

        let name = util.getArg(mapping, "name", null);
        if (name !== null) {
          name = this._names.at(name);
        }

        return {
          source,
          line: util.getArg(mapping, "originalLine", null),
          column: util.getArg(mapping, "originalColumn", null),
          name
        };
      }
    }

    return {
      source: null,
      line: null,
      column: null,
      name: null
    };
  }

  /**
   * Return true if we have the source content for every source in the source
   * map, false otherwise.
   */
  hasContentsOfAllSources() {
    if (!this.sourcesContent) {
      return false;
    }
    return this.sourcesContent.length >= this._sources.size() &&
      !this.sourcesContent.some(function(sc) { return sc == null; });
  }

  /**
   * Returns the original source content. The only argument is the url of the
   * original source file. Returns null if no original source content is
   * available.
   */
  sourceContentFor(aSource, nullOnMissing) {
    if (!this.sourcesContent) {
      return null;
    }

    const index = this._findSourceIndex(aSource);
    if (index >= 0) {
      return this.sourcesContent[index];
    }

    let relativeSource = aSource;
    if (this.sourceRoot != null) {
      relativeSource = util.relative(this.sourceRoot, relativeSource);
    }

    let url;
    if (this.sourceRoot != null
        && (url = util.urlParse(this.sourceRoot))) {
      // XXX: file:// URIs and absolute paths lead to unexpected behavior for
      // many users. We can help them out when they expect file:// URIs to
      // behave like it would if they were running a local HTTP server. See
      // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.
      const fileUriAbsPath = relativeSource.replace(/^file:\/\//, "");
      if (url.scheme == "file"
          && this._sources.has(fileUriAbsPath)) {
        return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];
      }

      if ((!url.path || url.path == "/")
          && this._sources.has("/" + relativeSource)) {
        return this.sourcesContent[this._sources.indexOf("/" + relativeSource)];
      }
    }

    // This function is used recursively from
    // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we
    // don't want to throw if we can't find the source - we just want to
    // return null, so we provide a flag to exit gracefully.
    if (nullOnMissing) {
      return null;
    }

    throw new Error('"' + relativeSource + '" is not in the SourceMap.');
  }

  /**
   * Returns the generated line and column information for the original source,
   * line, and column positions provided. The only argument is an object with
   * the following properties:
   *
   *   - source: The filename of the original source.
   *   - line: The line number in the original source.  The line number
   *     is 1-based.
   *   - column: The column number in the original source.  The column
   *     number is 0-based.
   *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
   *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
   *     closest element that is smaller than or greater than the one we are
   *     searching for, respectively, if the exact element cannot be found.
   *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
   *
   * and an object is returned with the following properties:
   *
   *   - line: The line number in the generated source, or null.  The
   *     line number is 1-based.
   *   - column: The column number in the generated source, or null.
   *     The column number is 0-based.
   */
  generatedPositionFor(aArgs) {
    let source = util.getArg(aArgs, "source");
    source = this._findSourceIndex(source);
    if (source < 0) {
      return {
        line: null,
        column: null,
        lastColumn: null
      };
    }

    const needle = {
      source,
      originalLine: util.getArg(aArgs, "line"),
      originalColumn: util.getArg(aArgs, "column")
    };

    if (needle.originalLine < 1) {
      throw new Error("Line numbers must be >= 1");
    }

    if (needle.originalColumn < 0) {
      throw new Error("Column numbers must be >= 0");
    }

    let bias = util.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND);
    if (bias == null) {
      bias = SourceMapConsumer.GREATEST_LOWER_BOUND;
    }

    let mapping;
    this._wasm.withMappingCallback(m => mapping = m, () => {
      this._wasm.exports.generated_location_for(
        this._getMappingsPtr(),
        needle.source,
        needle.originalLine - 1,
        needle.originalColumn,
        bias
      );
    });

    if (mapping) {
      if (mapping.source === needle.source) {
        let lastColumn = mapping.lastGeneratedColumn;
        if (this._computedColumnSpans && lastColumn === null) {
          lastColumn = Infinity;
        }
        return {
          line: util.getArg(mapping, "generatedLine", null),
          column: util.getArg(mapping, "generatedColumn", null),
          lastColumn,
        };
      }
    }

    return {
      line: null,
      column: null,
      lastColumn: null
    };
  }
}

BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;
exports.BasicSourceMapConsumer = BasicSourceMapConsumer;

/**
 * An IndexedSourceMapConsumer instance represents a parsed source map which
 * we can query for information. It differs from BasicSourceMapConsumer in
 * that it takes "indexed" source maps (i.e. ones with a "sections" field) as
 * input.
 *
 * The first parameter is a raw source map (either as a JSON string, or already
 * parsed to an object). According to the spec for indexed source maps, they
 * have the following attributes:
 *
 *   - version: Which version of the source map spec this map is following.
 *   - file: Optional. The generated file this source map is associated with.
 *   - sections: A list of section definitions.
 *
 * Each value under the "sections" field has two fields:
 *   - offset: The offset into the original specified at which this section
 *       begins to apply, defined as an object with a "line" and "column"
 *       field.
 *   - map: A source map definition. This source map could also be indexed,
 *       but doesn't have to be.
 *
 * Instead of the "map" field, it's also possible to have a "url" field
 * specifying a URL to retrieve a source map from, but that's currently
 * unsupported.
 *
 * Here's an example source map, taken from the source map spec[0], but
 * modified to omit a section which uses the "url" field.
 *
 *  {
 *    version : 3,
 *    file: "app.js",
 *    sections: [{
 *      offset: {line:100, column:10},
 *      map: {
 *        version : 3,
 *        file: "section.js",
 *        sources: ["foo.js", "bar.js"],
 *        names: ["src", "maps", "are", "fun"],
 *        mappings: "AAAA,E;;ABCDE;"
 *      }
 *    }],
 *  }
 *
 * The second parameter, if given, is a string whose value is the URL
 * at which the source map was found.  This URL is used to compute the
 * sources array.
 *
 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt
 */
class IndexedSourceMapConsumer extends SourceMapConsumer {
  constructor(aSourceMap, aSourceMapURL) {
    return super(INTERNAL).then(that => {
      let sourceMap = aSourceMap;
      if (typeof aSourceMap === "string") {
        sourceMap = util.parseSourceMapInput(aSourceMap);
      }

      const version = util.getArg(sourceMap, "version");
      const sections = util.getArg(sourceMap, "sections");

      if (version != that._version) {
        throw new Error("Unsupported version: " + version);
      }

      that._sources = new ArraySet();
      that._names = new ArraySet();
      that.__generatedMappings = null;
      that.__originalMappings = null;
      that.__generatedMappingsUnsorted = null;
      that.__originalMappingsUnsorted = null;

      let lastOffset = {
        line: -1,
        column: 0
      };
      return Promise.all(sections.map(s => {
        if (s.url) {
          // The url field will require support for asynchronicity.
          // See https://github.com/mozilla/source-map/issues/16
          throw new Error("Support for url field in sections not implemented.");
        }
        const offset = util.getArg(s, "offset");
        const offsetLine = util.getArg(offset, "line");
        const offsetColumn = util.getArg(offset, "column");

        if (offsetLine < lastOffset.line ||
            (offsetLine === lastOffset.line && offsetColumn < lastOffset.column)) {
          throw new Error("Section offsets must be ordered and non-overlapping.");
        }
        lastOffset = offset;

        const cons = new SourceMapConsumer(util.getArg(s, "map"), aSourceMapURL);
        return cons.then(consumer => {
          return {
            generatedOffset: {
              // The offset fields are 0-based, but we use 1-based indices when
              // encoding/decoding from VLQ.
              generatedLine: offsetLine + 1,
              generatedColumn: offsetColumn + 1
            },
            consumer
          };
        });
      })).then(s => {
        that._sections = s;
        return that;
      });
    });
  }

  // `__generatedMappings` and `__originalMappings` are arrays that hold the
  // parsed mapping coordinates from the source map's "mappings" attribute. They
  // are lazily instantiated, accessed via the `_generatedMappings` and
  // `_originalMappings` getters respectively, and we only parse the mappings
  // and create these arrays once queried for a source location. We jump through
  // these hoops because there can be many thousands of mappings, and parsing
  // them is expensive, so we only want to do it if we must.
  //
  // Each object in the arrays is of the form:
  //
  //     {
  //       generatedLine: The line number in the generated code,
  //       generatedColumn: The column number in the generated code,
  //       source: The path to the original source file that generated this
  //               chunk of code,
  //       originalLine: The line number in the original source that
  //                     corresponds to this chunk of generated code,
  //       originalColumn: The column number in the original source that
  //                       corresponds to this chunk of generated code,
  //       name: The name of the original symbol which generated this chunk of
  //             code.
  //     }
  //
  // All properties except for `generatedLine` and `generatedColumn` can be
  // `null`.
  //
  // `_generatedMappings` is ordered by the generated positions.
  //
  // `_originalMappings` is ordered by the original positions.
  get _generatedMappings() {
    if (!this.__generatedMappings) {
      this._sortGeneratedMappings();
    }

    return this.__generatedMappings;
  }

  get _originalMappings() {
    if (!this.__originalMappings) {
      this._sortOriginalMappings();
    }

    return this.__originalMappings;
  }

  get _generatedMappingsUnsorted() {
    if (!this.__generatedMappingsUnsorted) {
      this._parseMappings(this._mappings, this.sourceRoot);
    }

    return this.__generatedMappingsUnsorted;
  }

  get _originalMappingsUnsorted() {
    if (!this.__originalMappingsUnsorted) {
      this._parseMappings(this._mappings, this.sourceRoot);
    }

    return this.__originalMappingsUnsorted;
  }

  _sortGeneratedMappings() {
    const mappings = this._generatedMappingsUnsorted;
    mappings.sort(util.compareByGeneratedPositionsDeflated);
    this.__generatedMappings = mappings;
  }

  _sortOriginalMappings() {
    const mappings = this._originalMappingsUnsorted;
    mappings.sort(util.compareByOriginalPositions);
    this.__originalMappings = mappings;
  }

  /**
   * The list of original sources.
   */
  get sources() {
    const sources = [];
    for (let i = 0; i < this._sections.length; i++) {
      for (let j = 0; j < this._sections[i].consumer.sources.length; j++) {
        sources.push(this._sections[i].consumer.sources[j]);
      }
    }
    return sources;
  }

  /**
   * Returns the original source, line, and column information for the generated
   * source's line and column positions provided. The only argument is an object
   * with the following properties:
   *
   *   - line: The line number in the generated source.  The line number
   *     is 1-based.
   *   - column: The column number in the generated source.  The column
   *     number is 0-based.
   *
   * and an object is returned with the following properties:
   *
   *   - source: The original source file, or null.
   *   - line: The line number in the original source, or null.  The
   *     line number is 1-based.
   *   - column: The column number in the original source, or null.  The
   *     column number is 0-based.
   *   - name: The original identifier, or null.
   */
  originalPositionFor(aArgs) {
    const needle = {
      generatedLine: util.getArg(aArgs, "line"),
      generatedColumn: util.getArg(aArgs, "column")
    };

    // Find the section containing the generated position we're trying to map
    // to an original position.
    const sectionIndex = binarySearch.search(needle, this._sections,
      function(aNeedle, section) {
        const cmp = aNeedle.generatedLine - section.generatedOffset.generatedLine;
        if (cmp) {
          return cmp;
        }

        return (aNeedle.generatedColumn -
                section.generatedOffset.generatedColumn);
      });
    const section = this._sections[sectionIndex];

    if (!section) {
      return {
        source: null,
        line: null,
        column: null,
        name: null
      };
    }

    return section.consumer.originalPositionFor({
      line: needle.generatedLine -
        (section.generatedOffset.generatedLine - 1),
      column: needle.generatedColumn -
        (section.generatedOffset.generatedLine === needle.generatedLine
         ? section.generatedOffset.generatedColumn - 1
         : 0),
      bias: aArgs.bias
    });
  }

  /**
   * Return true if we have the source content for every source in the source
   * map, false otherwise.
   */
  hasContentsOfAllSources() {
    return this._sections.every(function(s) {
      return s.consumer.hasContentsOfAllSources();
    });
  }

  /**
   * Returns the original source content. The only argument is the url of the
   * original source file. Returns null if no original source content is
   * available.
   */
  sourceContentFor(aSource, nullOnMissing) {
    for (let i = 0; i < this._sections.length; i++) {
      const section = this._sections[i];

      const content = section.consumer.sourceContentFor(aSource, true);
      if (content) {
        return content;
      }
    }
    if (nullOnMissing) {
      return null;
    }
    throw new Error('"' + aSource + '" is not in the SourceMap.');
  }

  /**
   * Returns the generated line and column information for the original source,
   * line, and column positions provided. The only argument is an object with
   * the following properties:
   *
   *   - source: The filename of the original source.
   *   - line: The line number in the original source.  The line number
   *     is 1-based.
   *   - column: The column number in the original source.  The column
   *     number is 0-based.
   *
   * and an object is returned with the following properties:
   *
   *   - line: The line number in the generated source, or null.  The
   *     line number is 1-based.
   *   - column: The column number in the generated source, or null.
   *     The column number is 0-based.
   */
  generatedPositionFor(aArgs) {
    for (let i = 0; i < this._sections.length; i++) {
      const section = this._sections[i];

      // Only consider this section if the requested source is in the list of
      // sources of the consumer.
      if (section.consumer._findSourceIndex(util.getArg(aArgs, "source")) === -1) {
        continue;
      }
      const generatedPosition = section.consumer.generatedPositionFor(aArgs);
      if (generatedPosition) {
        const ret = {
          line: generatedPosition.line +
            (section.generatedOffset.generatedLine - 1),
          column: generatedPosition.column +
            (section.generatedOffset.generatedLine === generatedPosition.line
             ? section.generatedOffset.generatedColumn - 1
             : 0)
        };
        return ret;
      }
    }

    return {
      line: null,
      column: null
    };
  }

  /**
   * Parse the mappings in a string in to a data structure which we can easily
   * query (the ordered arrays in the `this.__generatedMappings` and
   * `this.__originalMappings` properties).
   */
  _parseMappings(aStr, aSourceRoot) {
    const generatedMappings = this.__generatedMappingsUnsorted = [];
    const originalMappings = this.__originalMappingsUnsorted = [];
    for (let i = 0; i < this._sections.length; i++) {
      const section = this._sections[i];

      const sectionMappings = [];
      section.consumer.eachMapping(m => sectionMappings.push(m));

      for (let j = 0; j < sectionMappings.length; j++) {
        const mapping = sectionMappings[j];

        // TODO: test if null is correct here.  The original code used
        // `source`, which would actually have gotten used as null because
        // var's get hoisted.
        // See: https://github.com/mozilla/source-map/issues/333
        let source = util.computeSourceURL(section.consumer.sourceRoot, null, this._sourceMapURL);
        this._sources.add(source);
        source = this._sources.indexOf(source);

        let name = null;
        if (mapping.name) {
          this._names.add(mapping.name);
          name = this._names.indexOf(mapping.name);
        }

        // The mappings coming from the consumer for the section have
        // generated positions relative to the start of the section, so we
        // need to offset them to be relative to the start of the concatenated
        // generated file.
        const adjustedMapping = {
          source,
          generatedLine: mapping.generatedLine +
            (section.generatedOffset.generatedLine - 1),
          generatedColumn: mapping.generatedColumn +
            (section.generatedOffset.generatedLine === mapping.generatedLine
            ? section.generatedOffset.generatedColumn - 1
            : 0),
          originalLine: mapping.originalLine,
          originalColumn: mapping.originalColumn,
          name
        };

        generatedMappings.push(adjustedMapping);
        if (typeof adjustedMapping.originalLine === "number") {
          originalMappings.push(adjustedMapping);
        }
      }
    }
  }

  eachMapping(aCallback, aContext, aOrder) {
    const context = aContext || null;
    const order = aOrder || SourceMapConsumer.GENERATED_ORDER;

    let mappings;
    switch (order) {
    case SourceMapConsumer.GENERATED_ORDER:
      mappings = this._generatedMappings;
      break;
    case SourceMapConsumer.ORIGINAL_ORDER:
      mappings = this._originalMappings;
      break;
    default:
      throw new Error("Unknown order of iteration.");
    }

    const sourceRoot = this.sourceRoot;
    mappings.map(function(mapping) {
      let source = null;
      if (mapping.source !== null) {
        source = this._sources.at(mapping.source);
        source = util.computeSourceURL(sourceRoot, source, this._sourceMapURL);
      }
      return {
        source,
        generatedLine: mapping.generatedLine,
        generatedColumn: mapping.generatedColumn,
        originalLine: mapping.originalLine,
        originalColumn: mapping.originalColumn,
        name: mapping.name === null ? null : this._names.at(mapping.name)
      };
    }, this).forEach(aCallback, context);
  }

  /**
   * Find the mapping that best matches the hypothetical "needle" mapping that
   * we are searching for in the given "haystack" of mappings.
   */
  _findMapping(aNeedle, aMappings, aLineName,
              aColumnName, aComparator, aBias) {
    // To return the position we are searching for, we must first find the
    // mapping for the given position and then return the opposite position it
    // points to. Because the mappings are sorted, we can use binary search to
    // find the best mapping.

    if (aNeedle[aLineName] <= 0) {
      throw new TypeError("Line must be greater than or equal to 1, got "
                          + aNeedle[aLineName]);
    }
    if (aNeedle[aColumnName] < 0) {
      throw new TypeError("Column must be greater than or equal to 0, got "
                          + aNeedle[aColumnName]);
    }

    return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
  }

  allGeneratedPositionsFor(aArgs) {
    const line = util.getArg(aArgs, "line");

    // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping
    // returns the index of the closest mapping less than the needle. By
    // setting needle.originalColumn to 0, we thus find the last mapping for
    // the given line, provided such a mapping exists.
    const needle = {
      source: util.getArg(aArgs, "source"),
      originalLine: line,
      originalColumn: util.getArg(aArgs, "column", 0)
    };

    needle.source = this._findSourceIndex(needle.source);
    if (needle.source < 0) {
      return [];
    }

    if (needle.originalLine < 1) {
      throw new Error("Line numbers must be >= 1");
    }

    if (needle.originalColumn < 0) {
      throw new Error("Column numbers must be >= 0");
    }

    const mappings = [];

    let index = this._findMapping(needle,
                                  this._originalMappings,
                                  "originalLine",
                                  "originalColumn",
                                  util.compareByOriginalPositions,
                                  binarySearch.LEAST_UPPER_BOUND);
    if (index >= 0) {
      let mapping = this._originalMappings[index];

      if (aArgs.column === undefined) {
        const originalLine = mapping.originalLine;

        // Iterate until either we run out of mappings, or we run into
        // a mapping for a different line than the one we found. Since
        // mappings are sorted, this is guaranteed to find all mappings for
        // the line we found.
        while (mapping && mapping.originalLine === originalLine) {
          let lastColumn = mapping.lastGeneratedColumn;
          if (this._computedColumnSpans && lastColumn === null) {
            lastColumn = Infinity;
          }
          mappings.push({
            line: util.getArg(mapping, "generatedLine", null),
            column: util.getArg(mapping, "generatedColumn", null),
            lastColumn,
          });

          mapping = this._originalMappings[++index];
        }
      } else {
        const originalColumn = mapping.originalColumn;

        // Iterate until either we run out of mappings, or we run into
        // a mapping for a different line than the one we were searching for.
        // Since mappings are sorted, this is guaranteed to find all mappings for
        // the line we are searching for.
        while (mapping &&
               mapping.originalLine === line &&
               mapping.originalColumn == originalColumn) {
          let lastColumn = mapping.lastGeneratedColumn;
          if (this._computedColumnSpans && lastColumn === null) {
            lastColumn = Infinity;
          }
          mappings.push({
            line: util.getArg(mapping, "generatedLine", null),
            column: util.getArg(mapping, "generatedColumn", null),
            lastColumn,
          });

          mapping = this._originalMappings[++index];
        }
      }
    }

    return mappings;
  }

  destroy() {
    for (let i = 0; i < this._sections.length; i++) {
      this._sections[i].consumer.destroy();
    }
  }
}
exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;

/*
 * Cheat to get around inter-twingled classes.  `factory()` can be at the end
 * where it has access to non-hoisted classes, but it gets hoisted itself.
 */
function _factory(aSourceMap, aSourceMapURL) {
  let sourceMap = aSourceMap;
  if (typeof aSourceMap === "string") {
    sourceMap = util.parseSourceMapInput(aSourceMap);
  }

  const consumer = sourceMap.sections != null
      ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL)
      : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);
  return Promise.resolve(consumer);
}

function _factoryBSM(aSourceMap, aSourceMapURL) {
  return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);
}


/***/ }),

/***/ "../../node_modules/@datadog/pprof/node_modules/source-map/lib/source-map-generator.js":
/*!**************************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/@datadog/pprof/node_modules/source-map/lib/source-map-generator.js ***!
  \**************************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

const base64VLQ = __webpack_require__(/*! ./base64-vlq */ "../../node_modules/@datadog/pprof/node_modules/source-map/lib/base64-vlq.js");
const util = __webpack_require__(/*! ./util */ "../../node_modules/@datadog/pprof/node_modules/source-map/lib/util.js");
const ArraySet = __webpack_require__(/*! ./array-set */ "../../node_modules/@datadog/pprof/node_modules/source-map/lib/array-set.js").ArraySet;
const MappingList = __webpack_require__(/*! ./mapping-list */ "../../node_modules/@datadog/pprof/node_modules/source-map/lib/mapping-list.js").MappingList;

/**
 * An instance of the SourceMapGenerator represents a source map which is
 * being built incrementally. You may pass an object with the following
 * properties:
 *
 *   - file: The filename of the generated source.
 *   - sourceRoot: A root for all relative URLs in this source map.
 */
class SourceMapGenerator {
  constructor(aArgs) {
    if (!aArgs) {
      aArgs = {};
    }
    this._file = util.getArg(aArgs, "file", null);
    this._sourceRoot = util.getArg(aArgs, "sourceRoot", null);
    this._skipValidation = util.getArg(aArgs, "skipValidation", false);
    this._sources = new ArraySet();
    this._names = new ArraySet();
    this._mappings = new MappingList();
    this._sourcesContents = null;
  }

  /**
   * Creates a new SourceMapGenerator based on a SourceMapConsumer
   *
   * @param aSourceMapConsumer The SourceMap.
   */
  static fromSourceMap(aSourceMapConsumer) {
    const sourceRoot = aSourceMapConsumer.sourceRoot;
    const generator = new SourceMapGenerator({
      file: aSourceMapConsumer.file,
      sourceRoot
    });
    aSourceMapConsumer.eachMapping(function(mapping) {
      const newMapping = {
        generated: {
          line: mapping.generatedLine,
          column: mapping.generatedColumn
        }
      };

      if (mapping.source != null) {
        newMapping.source = mapping.source;
        if (sourceRoot != null) {
          newMapping.source = util.relative(sourceRoot, newMapping.source);
        }

        newMapping.original = {
          line: mapping.originalLine,
          column: mapping.originalColumn
        };

        if (mapping.name != null) {
          newMapping.name = mapping.name;
        }
      }

      generator.addMapping(newMapping);
    });
    aSourceMapConsumer.sources.forEach(function(sourceFile) {
      let sourceRelative = sourceFile;
      if (sourceRoot !== null) {
        sourceRelative = util.relative(sourceRoot, sourceFile);
      }

      if (!generator._sources.has(sourceRelative)) {
        generator._sources.add(sourceRelative);
      }

      const content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        generator.setSourceContent(sourceFile, content);
      }
    });
    return generator;
  }

  /**
   * Add a single mapping from original source line and column to the generated
   * source's line and column for this source map being created. The mapping
   * object should have the following properties:
   *
   *   - generated: An object with the generated line and column positions.
   *   - original: An object with the original line and column positions.
   *   - source: The original source file (relative to the sourceRoot).
   *   - name: An optional original token name for this mapping.
   */
  addMapping(aArgs) {
    const generated = util.getArg(aArgs, "generated");
    const original = util.getArg(aArgs, "original", null);
    let source = util.getArg(aArgs, "source", null);
    let name = util.getArg(aArgs, "name", null);

    if (!this._skipValidation) {
      this._validateMapping(generated, original, source, name);
    }

    if (source != null) {
      source = String(source);
      if (!this._sources.has(source)) {
        this._sources.add(source);
      }
    }

    if (name != null) {
      name = String(name);
      if (!this._names.has(name)) {
        this._names.add(name);
      }
    }

    this._mappings.add({
      generatedLine: generated.line,
      generatedColumn: generated.column,
      originalLine: original != null && original.line,
      originalColumn: original != null && original.column,
      source,
      name
    });
  }

  /**
   * Set the source content for a source file.
   */
  setSourceContent(aSourceFile, aSourceContent) {
    let source = aSourceFile;
    if (this._sourceRoot != null) {
      source = util.relative(this._sourceRoot, source);
    }

    if (aSourceContent != null) {
      // Add the source content to the _sourcesContents map.
      // Create a new _sourcesContents map if the property is null.
      if (!this._sourcesContents) {
        this._sourcesContents = Object.create(null);
      }
      this._sourcesContents[util.toSetString(source)] = aSourceContent;
    } else if (this._sourcesContents) {
      // Remove the source file from the _sourcesContents map.
      // If the _sourcesContents map is empty, set the property to null.
      delete this._sourcesContents[util.toSetString(source)];
      if (Object.keys(this._sourcesContents).length === 0) {
        this._sourcesContents = null;
      }
    }
  }

  /**
   * Applies the mappings of a sub-source-map for a specific source file to the
   * source map being generated. Each mapping to the supplied source file is
   * rewritten using the supplied source map. Note: The resolution for the
   * resulting mappings is the minimium of this map and the supplied map.
   *
   * @param aSourceMapConsumer The source map to be applied.
   * @param aSourceFile Optional. The filename of the source file.
   *        If omitted, SourceMapConsumer's file property will be used.
   * @param aSourceMapPath Optional. The dirname of the path to the source map
   *        to be applied. If relative, it is relative to the SourceMapConsumer.
   *        This parameter is needed when the two source maps aren't in the same
   *        directory, and the source map to be applied contains relative source
   *        paths. If so, those relative source paths need to be rewritten
   *        relative to the SourceMapGenerator.
   */
  applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
    let sourceFile = aSourceFile;
    // If aSourceFile is omitted, we will use the file property of the SourceMap
    if (aSourceFile == null) {
      if (aSourceMapConsumer.file == null) {
        throw new Error(
          "SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, " +
          'or the source map\'s "file" property. Both were omitted.'
        );
      }
      sourceFile = aSourceMapConsumer.file;
    }
    const sourceRoot = this._sourceRoot;
    // Make "sourceFile" relative if an absolute Url is passed.
    if (sourceRoot != null) {
      sourceFile = util.relative(sourceRoot, sourceFile);
    }
    // Applying the SourceMap can add and remove items from the sources and
    // the names array.
    const newSources = this._mappings.toArray().length > 0
      ? new ArraySet()
      : this._sources;
    const newNames = new ArraySet();

    // Find mappings for the "sourceFile"
    this._mappings.unsortedForEach(function(mapping) {
      if (mapping.source === sourceFile && mapping.originalLine != null) {
        // Check if it can be mapped by the source map, then update the mapping.
        const original = aSourceMapConsumer.originalPositionFor({
          line: mapping.originalLine,
          column: mapping.originalColumn
        });
        if (original.source != null) {
          // Copy mapping
          mapping.source = original.source;
          if (aSourceMapPath != null) {
            mapping.source = util.join(aSourceMapPath, mapping.source);
          }
          if (sourceRoot != null) {
            mapping.source = util.relative(sourceRoot, mapping.source);
          }
          mapping.originalLine = original.line;
          mapping.originalColumn = original.column;
          if (original.name != null) {
            mapping.name = original.name;
          }
        }
      }

      const source = mapping.source;
      if (source != null && !newSources.has(source)) {
        newSources.add(source);
      }

      const name = mapping.name;
      if (name != null && !newNames.has(name)) {
        newNames.add(name);
      }

    }, this);
    this._sources = newSources;
    this._names = newNames;

    // Copy sourcesContents of applied map.
    aSourceMapConsumer.sources.forEach(function(srcFile) {
      const content = aSourceMapConsumer.sourceContentFor(srcFile);
      if (content != null) {
        if (aSourceMapPath != null) {
          srcFile = util.join(aSourceMapPath, srcFile);
        }
        if (sourceRoot != null) {
          srcFile = util.relative(sourceRoot, srcFile);
        }
        this.setSourceContent(srcFile, content);
      }
    }, this);
  }

  /**
   * A mapping can have one of the three levels of data:
   *
   *   1. Just the generated position.
   *   2. The Generated position, original position, and original source.
   *   3. Generated and original position, original source, as well as a name
   *      token.
   *
   * To maintain consistency, we validate that any new mapping being added falls
   * in to one of these categories.
   */
  _validateMapping(aGenerated, aOriginal, aSource, aName) {
    // When aOriginal is truthy but has empty values for .line and .column,
    // it is most likely a programmer error. In this case we throw a very
    // specific error message to try to guide them the right way.
    // For example: https://github.com/Polymer/polymer-bundler/pull/519
    if (aOriginal && typeof aOriginal.line !== "number" && typeof aOriginal.column !== "number") {
        throw new Error(
            "original.line and original.column are not numbers -- you probably meant to omit " +
            "the original mapping entirely and only map the generated position. If so, pass " +
            "null for the original mapping instead of an object with empty or null values."
        );
    }

    if (aGenerated && "line" in aGenerated && "column" in aGenerated
        && aGenerated.line > 0 && aGenerated.column >= 0
        && !aOriginal && !aSource && !aName) {
      // Case 1.

    } else if (aGenerated && "line" in aGenerated && "column" in aGenerated
             && aOriginal && "line" in aOriginal && "column" in aOriginal
             && aGenerated.line > 0 && aGenerated.column >= 0
             && aOriginal.line > 0 && aOriginal.column >= 0
             && aSource) {
      // Cases 2 and 3.

    } else {
      throw new Error("Invalid mapping: " + JSON.stringify({
        generated: aGenerated,
        source: aSource,
        original: aOriginal,
        name: aName
      }));
    }
  }

  /**
   * Serialize the accumulated mappings in to the stream of base 64 VLQs
   * specified by the source map format.
   */
  _serializeMappings() {
    let previousGeneratedColumn = 0;
    let previousGeneratedLine = 1;
    let previousOriginalColumn = 0;
    let previousOriginalLine = 0;
    let previousName = 0;
    let previousSource = 0;
    let result = "";
    let next;
    let mapping;
    let nameIdx;
    let sourceIdx;

    const mappings = this._mappings.toArray();
    for (let i = 0, len = mappings.length; i < len; i++) {
      mapping = mappings[i];
      next = "";

      if (mapping.generatedLine !== previousGeneratedLine) {
        previousGeneratedColumn = 0;
        while (mapping.generatedLine !== previousGeneratedLine) {
          next += ";";
          previousGeneratedLine++;
        }
      } else if (i > 0) {
        if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
          continue;
        }
        next += ",";
      }

      next += base64VLQ.encode(mapping.generatedColumn
                                 - previousGeneratedColumn);
      previousGeneratedColumn = mapping.generatedColumn;

      if (mapping.source != null) {
        sourceIdx = this._sources.indexOf(mapping.source);
        next += base64VLQ.encode(sourceIdx - previousSource);
        previousSource = sourceIdx;

        // lines are stored 0-based in SourceMap spec version 3
        next += base64VLQ.encode(mapping.originalLine - 1
                                   - previousOriginalLine);
        previousOriginalLine = mapping.originalLine - 1;

        next += base64VLQ.encode(mapping.originalColumn
                                   - previousOriginalColumn);
        previousOriginalColumn = mapping.originalColumn;

        if (mapping.name != null) {
          nameIdx = this._names.indexOf(mapping.name);
          next += base64VLQ.encode(nameIdx - previousName);
          previousName = nameIdx;
        }
      }

      result += next;
    }

    return result;
  }

  _generateSourcesContent(aSources, aSourceRoot) {
    return aSources.map(function(source) {
      if (!this._sourcesContents) {
        return null;
      }
      if (aSourceRoot != null) {
        source = util.relative(aSourceRoot, source);
      }
      const key = util.toSetString(source);
      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)
        ? this._sourcesContents[key]
        : null;
    }, this);
  }

  /**
   * Externalize the source map.
   */
  toJSON() {
    const map = {
      version: this._version,
      sources: this._sources.toArray(),
      names: this._names.toArray(),
      mappings: this._serializeMappings()
    };
    if (this._file != null) {
      map.file = this._file;
    }
    if (this._sourceRoot != null) {
      map.sourceRoot = this._sourceRoot;
    }
    if (this._sourcesContents) {
      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
    }

    return map;
  }

  /**
   * Render the source map being generated to a string.
   */
  toString() {
    return JSON.stringify(this.toJSON());
  }
}

SourceMapGenerator.prototype._version = 3;
exports.SourceMapGenerator = SourceMapGenerator;


/***/ }),

/***/ "../../node_modules/@datadog/pprof/node_modules/source-map/lib/source-node.js":
/*!*****************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/@datadog/pprof/node_modules/source-map/lib/source-node.js ***!
  \*****************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

const SourceMapGenerator = __webpack_require__(/*! ./source-map-generator */ "../../node_modules/@datadog/pprof/node_modules/source-map/lib/source-map-generator.js").SourceMapGenerator;
const util = __webpack_require__(/*! ./util */ "../../node_modules/@datadog/pprof/node_modules/source-map/lib/util.js");

// Matches a Windows-style `\r\n` newline or a `\n` newline used by all other
// operating systems these days (capturing the result).
const REGEX_NEWLINE = /(\r?\n)/;

// Newline character code for charCodeAt() comparisons
const NEWLINE_CODE = 10;

// Private symbol for identifying `SourceNode`s when multiple versions of
// the source-map library are loaded. This MUST NOT CHANGE across
// versions!
const isSourceNode = "$$$isSourceNode$$$";

/**
 * SourceNodes provide a way to abstract over interpolating/concatenating
 * snippets of generated JavaScript source code while maintaining the line and
 * column information associated with the original source code.
 *
 * @param aLine The original line number.
 * @param aColumn The original column number.
 * @param aSource The original source's filename.
 * @param aChunks Optional. An array of strings which are snippets of
 *        generated JS, or other SourceNodes.
 * @param aName The original identifier.
 */
class SourceNode {
  constructor(aLine, aColumn, aSource, aChunks, aName) {
    this.children = [];
    this.sourceContents = {};
    this.line = aLine == null ? null : aLine;
    this.column = aColumn == null ? null : aColumn;
    this.source = aSource == null ? null : aSource;
    this.name = aName == null ? null : aName;
    this[isSourceNode] = true;
    if (aChunks != null) this.add(aChunks);
  }

  /**
   * Creates a SourceNode from generated code and a SourceMapConsumer.
   *
   * @param aGeneratedCode The generated code
   * @param aSourceMapConsumer The SourceMap for the generated code
   * @param aRelativePath Optional. The path that relative sources in the
   *        SourceMapConsumer should be relative to.
   */
  static fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
    // The SourceNode we want to fill with the generated code
    // and the SourceMap
    const node = new SourceNode();

    // All even indices of this array are one line of the generated code,
    // while all odd indices are the newlines between two adjacent lines
    // (since `REGEX_NEWLINE` captures its match).
    // Processed fragments are accessed by calling `shiftNextLine`.
    const remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
    let remainingLinesIndex = 0;
    const shiftNextLine = function() {
      const lineContents = getNextLine();
      // The last line of a file might not have a newline.
      const newLine = getNextLine() || "";
      return lineContents + newLine;

      function getNextLine() {
        return remainingLinesIndex < remainingLines.length ?
            remainingLines[remainingLinesIndex++] : undefined;
      }
    };

    // We need to remember the position of "remainingLines"
    let lastGeneratedLine = 1, lastGeneratedColumn = 0;

    // The generate SourceNodes we need a code range.
    // To extract it current and last mapping is used.
    // Here we store the last mapping.
    let lastMapping = null;
    let nextLine;

    aSourceMapConsumer.eachMapping(function(mapping) {
      if (lastMapping !== null) {
        // We add the code from "lastMapping" to "mapping":
        // First check if there is a new line in between.
        if (lastGeneratedLine < mapping.generatedLine) {
          // Associate first line with "lastMapping"
          addMappingWithCode(lastMapping, shiftNextLine());
          lastGeneratedLine++;
          lastGeneratedColumn = 0;
          // The remaining code is added without mapping
        } else {
          // There is no new line in between.
          // Associate the code between "lastGeneratedColumn" and
          // "mapping.generatedColumn" with "lastMapping"
          nextLine = remainingLines[remainingLinesIndex] || "";
          const code = nextLine.substr(0, mapping.generatedColumn -
                                        lastGeneratedColumn);
          remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn -
                                              lastGeneratedColumn);
          lastGeneratedColumn = mapping.generatedColumn;
          addMappingWithCode(lastMapping, code);
          // No more remaining code, continue
          lastMapping = mapping;
          return;
        }
      }
      // We add the generated code until the first mapping
      // to the SourceNode without any mapping.
      // Each line is added as separate string.
      while (lastGeneratedLine < mapping.generatedLine) {
        node.add(shiftNextLine());
        lastGeneratedLine++;
      }
      if (lastGeneratedColumn < mapping.generatedColumn) {
        nextLine = remainingLines[remainingLinesIndex] || "";
        node.add(nextLine.substr(0, mapping.generatedColumn));
        remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
        lastGeneratedColumn = mapping.generatedColumn;
      }
      lastMapping = mapping;
    }, this);
    // We have processed all mappings.
    if (remainingLinesIndex < remainingLines.length) {
      if (lastMapping) {
        // Associate the remaining code in the current line with "lastMapping"
        addMappingWithCode(lastMapping, shiftNextLine());
      }
      // and add the remaining lines without any mapping
      node.add(remainingLines.splice(remainingLinesIndex).join(""));
    }

    // Copy sourcesContent into SourceNode
    aSourceMapConsumer.sources.forEach(function(sourceFile) {
      const content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        if (aRelativePath != null) {
          sourceFile = util.join(aRelativePath, sourceFile);
        }
        node.setSourceContent(sourceFile, content);
      }
    });

    return node;

    function addMappingWithCode(mapping, code) {
      if (mapping === null || mapping.source === undefined) {
        node.add(code);
      } else {
        const source = aRelativePath
          ? util.join(aRelativePath, mapping.source)
          : mapping.source;
        node.add(new SourceNode(mapping.originalLine,
                                mapping.originalColumn,
                                source,
                                code,
                                mapping.name));
      }
    }
  }

  /**
   * Add a chunk of generated JS to this source node.
   *
   * @param aChunk A string snippet of generated JS code, another instance of
   *        SourceNode, or an array where each member is one of those things.
   */
  add(aChunk) {
    if (Array.isArray(aChunk)) {
      aChunk.forEach(function(chunk) {
        this.add(chunk);
      }, this);
    } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
      if (aChunk) {
        this.children.push(aChunk);
      }
    } else {
      throw new TypeError(
        "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
      );
    }
    return this;
  }

  /**
   * Add a chunk of generated JS to the beginning of this source node.
   *
   * @param aChunk A string snippet of generated JS code, another instance of
   *        SourceNode, or an array where each member is one of those things.
   */
  prepend(aChunk) {
    if (Array.isArray(aChunk)) {
      for (let i = aChunk.length - 1; i >= 0; i--) {
        this.prepend(aChunk[i]);
      }
    } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
      this.children.unshift(aChunk);
    } else {
      throw new TypeError(
        "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
      );
    }
    return this;
  }

  /**
   * Walk over the tree of JS snippets in this node and its children. The
   * walking function is called once for each snippet of JS and is passed that
   * snippet and the its original associated source's line/column location.
   *
   * @param aFn The traversal function.
   */
  walk(aFn) {
    let chunk;
    for (let i = 0, len = this.children.length; i < len; i++) {
      chunk = this.children[i];
      if (chunk[isSourceNode]) {
        chunk.walk(aFn);
      } else if (chunk !== "") {
        aFn(chunk, { source: this.source,
                      line: this.line,
                      column: this.column,
                      name: this.name });
      }
    }
  }

  /**
   * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between
   * each of `this.children`.
   *
   * @param aSep The separator.
   */
  join(aSep) {
    let newChildren;
    let i;
    const len = this.children.length;
    if (len > 0) {
      newChildren = [];
      for (i = 0; i < len - 1; i++) {
        newChildren.push(this.children[i]);
        newChildren.push(aSep);
      }
      newChildren.push(this.children[i]);
      this.children = newChildren;
    }
    return this;
  }

  /**
   * Call String.prototype.replace on the very right-most source snippet. Useful
   * for trimming whitespace from the end of a source node, etc.
   *
   * @param aPattern The pattern to replace.
   * @param aReplacement The thing to replace the pattern with.
   */
  replaceRight(aPattern, aReplacement) {
    const lastChild = this.children[this.children.length - 1];
    if (lastChild[isSourceNode]) {
      lastChild.replaceRight(aPattern, aReplacement);
    } else if (typeof lastChild === "string") {
      this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
    } else {
      this.children.push("".replace(aPattern, aReplacement));
    }
    return this;
  }

  /**
   * Set the source content for a source file. This will be added to the SourceMapGenerator
   * in the sourcesContent field.
   *
   * @param aSourceFile The filename of the source file
   * @param aSourceContent The content of the source file
   */
  setSourceContent(aSourceFile, aSourceContent) {
    this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
  }

  /**
   * Walk over the tree of SourceNodes. The walking function is called for each
   * source file content and is passed the filename and source content.
   *
   * @param aFn The traversal function.
   */
  walkSourceContents(aFn) {
    for (let i = 0, len = this.children.length; i < len; i++) {
      if (this.children[i][isSourceNode]) {
        this.children[i].walkSourceContents(aFn);
      }
    }

    const sources = Object.keys(this.sourceContents);
    for (let i = 0, len = sources.length; i < len; i++) {
      aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
    }
  }

  /**
   * Return the string representation of this source node. Walks over the tree
   * and concatenates all the various snippets together to one string.
   */
  toString() {
    let str = "";
    this.walk(function(chunk) {
      str += chunk;
    });
    return str;
  }

  /**
   * Returns the string representation of this source node along with a source
   * map.
   */
  toStringWithSourceMap(aArgs) {
    const generated = {
      code: "",
      line: 1,
      column: 0
    };
    const map = new SourceMapGenerator(aArgs);
    let sourceMappingActive = false;
    let lastOriginalSource = null;
    let lastOriginalLine = null;
    let lastOriginalColumn = null;
    let lastOriginalName = null;
    this.walk(function(chunk, original) {
      generated.code += chunk;
      if (original.source !== null
          && original.line !== null
          && original.column !== null) {
        if (lastOriginalSource !== original.source
          || lastOriginalLine !== original.line
          || lastOriginalColumn !== original.column
          || lastOriginalName !== original.name) {
          map.addMapping({
            source: original.source,
            original: {
              line: original.line,
              column: original.column
            },
            generated: {
              line: generated.line,
              column: generated.column
            },
            name: original.name
          });
        }
        lastOriginalSource = original.source;
        lastOriginalLine = original.line;
        lastOriginalColumn = original.column;
        lastOriginalName = original.name;
        sourceMappingActive = true;
      } else if (sourceMappingActive) {
        map.addMapping({
          generated: {
            line: generated.line,
            column: generated.column
          }
        });
        lastOriginalSource = null;
        sourceMappingActive = false;
      }
      for (let idx = 0, length = chunk.length; idx < length; idx++) {
        if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
          generated.line++;
          generated.column = 0;
          // Mappings end at eol
          if (idx + 1 === length) {
            lastOriginalSource = null;
            sourceMappingActive = false;
          } else if (sourceMappingActive) {
            map.addMapping({
              source: original.source,
              original: {
                line: original.line,
                column: original.column
              },
              generated: {
                line: generated.line,
                column: generated.column
              },
              name: original.name
            });
          }
        } else {
          generated.column++;
        }
      }
    });
    this.walkSourceContents(function(sourceFile, sourceContent) {
      map.setSourceContent(sourceFile, sourceContent);
    });

    return { code: generated.code, map };
  }
}

exports.SourceNode = SourceNode;


/***/ }),

/***/ "../../node_modules/@datadog/pprof/node_modules/source-map/lib/util.js":
/*!**********************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/@datadog/pprof/node_modules/source-map/lib/util.js ***!
  \**********************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports) {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

/**
 * This is a helper function for getting values from parameter/options
 * objects.
 *
 * @param args The object we are extracting values from
 * @param name The name of the property we are getting.
 * @param defaultValue An optional value to return if the property is missing
 * from the object. If this is not specified and the property is missing, an
 * error will be thrown.
 */
function getArg(aArgs, aName, aDefaultValue) {
  if (aName in aArgs) {
    return aArgs[aName];
  } else if (arguments.length === 3) {
    return aDefaultValue;
  }
    throw new Error('"' + aName + '" is a required argument.');

}
exports.getArg = getArg;

const urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
const dataUrlRegexp = /^data:.+\,.+$/;

function urlParse(aUrl) {
  const match = aUrl.match(urlRegexp);
  if (!match) {
    return null;
  }
  return {
    scheme: match[1],
    auth: match[2],
    host: match[3],
    port: match[4],
    path: match[5]
  };
}
exports.urlParse = urlParse;

function urlGenerate(aParsedUrl) {
  let url = "";
  if (aParsedUrl.scheme) {
    url += aParsedUrl.scheme + ":";
  }
  url += "//";
  if (aParsedUrl.auth) {
    url += aParsedUrl.auth + "@";
  }
  if (aParsedUrl.host) {
    url += aParsedUrl.host;
  }
  if (aParsedUrl.port) {
    url += ":" + aParsedUrl.port;
  }
  if (aParsedUrl.path) {
    url += aParsedUrl.path;
  }
  return url;
}
exports.urlGenerate = urlGenerate;

const MAX_CACHED_INPUTS = 32;

/**
 * Takes some function `f(input) -> result` and returns a memoized version of
 * `f`.
 *
 * We keep at most `MAX_CACHED_INPUTS` memoized results of `f` alive. The
 * memoization is a dumb-simple, linear least-recently-used cache.
 */
function lruMemoize(f) {
  const cache = [];

  return function(input) {
    for (let i = 0; i < cache.length; i++) {
      if (cache[i].input === input) {
        const temp = cache[0];
        cache[0] = cache[i];
        cache[i] = temp;
        return cache[0].result;
      }
    }

    const result = f(input);

    cache.unshift({
      input,
      result,
    });

    if (cache.length > MAX_CACHED_INPUTS) {
      cache.pop();
    }

    return result;
  };
}

/**
 * Normalizes a path, or the path portion of a URL:
 *
 * - Replaces consecutive slashes with one slash.
 * - Removes unnecessary '.' parts.
 * - Removes unnecessary '<dir>/..' parts.
 *
 * Based on code in the Node.js 'path' core module.
 *
 * @param aPath The path or url to normalize.
 */
const normalize = lruMemoize(function normalize(aPath) {
  let path = aPath;
  const url = urlParse(aPath);
  if (url) {
    if (!url.path) {
      return aPath;
    }
    path = url.path;
  }
  const isAbsolute = exports.isAbsolute(path);

  // Split the path into parts between `/` characters. This is much faster than
  // using `.split(/\/+/g)`.
  const parts = [];
  let start = 0;
  let i = 0;
  while (true) {
    start = i;
    i = path.indexOf("/", start);
    if (i === -1) {
      parts.push(path.slice(start));
      break;
    } else {
      parts.push(path.slice(start, i));
      while (i < path.length && path[i] === "/") {
        i++;
      }
    }
  }

  let up = 0;
  for (i = parts.length - 1; i >= 0; i--) {
    const part = parts[i];
    if (part === ".") {
      parts.splice(i, 1);
    } else if (part === "..") {
      up++;
    } else if (up > 0) {
      if (part === "") {
        // The first part is blank if the path is absolute. Trying to go
        // above the root is a no-op. Therefore we can remove all '..' parts
        // directly after the root.
        parts.splice(i + 1, up);
        up = 0;
      } else {
        parts.splice(i, 2);
        up--;
      }
    }
  }
  path = parts.join("/");

  if (path === "") {
    path = isAbsolute ? "/" : ".";
  }

  if (url) {
    url.path = path;
    return urlGenerate(url);
  }
  return path;
});
exports.normalize = normalize;

/**
 * Joins two paths/URLs.
 *
 * @param aRoot The root path or URL.
 * @param aPath The path or URL to be joined with the root.
 *
 * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
 *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
 *   first.
 * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
 *   is updated with the result and aRoot is returned. Otherwise the result
 *   is returned.
 *   - If aPath is absolute, the result is aPath.
 *   - Otherwise the two paths are joined with a slash.
 * - Joining for example 'http://' and 'www.example.com' is also supported.
 */
function join(aRoot, aPath) {
  if (aRoot === "") {
    aRoot = ".";
  }
  if (aPath === "") {
    aPath = ".";
  }
  const aPathUrl = urlParse(aPath);
  const aRootUrl = urlParse(aRoot);
  if (aRootUrl) {
    aRoot = aRootUrl.path || "/";
  }

  // `join(foo, '//www.example.org')`
  if (aPathUrl && !aPathUrl.scheme) {
    if (aRootUrl) {
      aPathUrl.scheme = aRootUrl.scheme;
    }
    return urlGenerate(aPathUrl);
  }

  if (aPathUrl || aPath.match(dataUrlRegexp)) {
    return aPath;
  }

  // `join('http://', 'www.example.com')`
  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
    aRootUrl.host = aPath;
    return urlGenerate(aRootUrl);
  }

  const joined = aPath.charAt(0) === "/"
    ? aPath
    : normalize(aRoot.replace(/\/+$/, "") + "/" + aPath);

  if (aRootUrl) {
    aRootUrl.path = joined;
    return urlGenerate(aRootUrl);
  }
  return joined;
}
exports.join = join;

exports.isAbsolute = function(aPath) {
  return aPath.charAt(0) === "/" || urlRegexp.test(aPath);
};

/**
 * Make a path relative to a URL or another path.
 *
 * @param aRoot The root path or URL.
 * @param aPath The path or URL to be made relative to aRoot.
 */
function relative(aRoot, aPath) {
  if (aRoot === "") {
    aRoot = ".";
  }

  aRoot = aRoot.replace(/\/$/, "");

  // It is possible for the path to be above the root. In this case, simply
  // checking whether the root is a prefix of the path won't work. Instead, we
  // need to remove components from the root one by one, until either we find
  // a prefix that fits, or we run out of components to remove.
  let level = 0;
  while (aPath.indexOf(aRoot + "/") !== 0) {
    const index = aRoot.lastIndexOf("/");
    if (index < 0) {
      return aPath;
    }

    // If the only part of the root that is left is the scheme (i.e. http://,
    // file:///, etc.), one or more slashes (/), or simply nothing at all, we
    // have exhausted all components, so the path is not relative to the root.
    aRoot = aRoot.slice(0, index);
    if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
      return aPath;
    }

    ++level;
  }

  // Make sure we add a "../" for each component we removed from the root.
  return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
}
exports.relative = relative;

const supportsNullProto = (function() {
  const obj = Object.create(null);
  return !("__proto__" in obj);
}());

function identity(s) {
  return s;
}

/**
 * Because behavior goes wacky when you set `__proto__` on objects, we
 * have to prefix all the strings in our set with an arbitrary character.
 *
 * See https://github.com/mozilla/source-map/pull/31 and
 * https://github.com/mozilla/source-map/issues/30
 *
 * @param String aStr
 */
function toSetString(aStr) {
  if (isProtoString(aStr)) {
    return "$" + aStr;
  }

  return aStr;
}
exports.toSetString = supportsNullProto ? identity : toSetString;

function fromSetString(aStr) {
  if (isProtoString(aStr)) {
    return aStr.slice(1);
  }

  return aStr;
}
exports.fromSetString = supportsNullProto ? identity : fromSetString;

function isProtoString(s) {
  if (!s) {
    return false;
  }

  const length = s.length;

  if (length < 9 /* "__proto__".length */) {
    return false;
  }

  /* eslint-disable no-multi-spaces */
  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||
      s.charCodeAt(length - 2) !== 95  /* '_' */ ||
      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||
      s.charCodeAt(length - 4) !== 116 /* 't' */ ||
      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||
      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||
      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||
      s.charCodeAt(length - 8) !== 95  /* '_' */ ||
      s.charCodeAt(length - 9) !== 95  /* '_' */) {
    return false;
  }
  /* eslint-enable no-multi-spaces */

  for (let i = length - 10; i >= 0; i--) {
    if (s.charCodeAt(i) !== 36 /* '$' */) {
      return false;
    }
  }

  return true;
}

/**
 * Comparator between two mappings where the original positions are compared.
 *
 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
 * mappings with the same original source/line/column, but different generated
 * line and column the same. Useful when searching for a mapping with a
 * stubbed out mapping.
 */
function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
  let cmp = strcmp(mappingA.source, mappingB.source);
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;
  if (cmp !== 0 || onlyCompareOriginal) {
    return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.generatedLine - mappingB.generatedLine;
  if (cmp !== 0) {
    return cmp;
  }

  return strcmp(mappingA.name, mappingB.name);
}
exports.compareByOriginalPositions = compareByOriginalPositions;

/**
 * Comparator between two mappings with deflated source and name indices where
 * the generated positions are compared.
 *
 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
 * mappings with the same generated line and column, but different
 * source/name/original line and column the same. Useful when searching for a
 * mapping with a stubbed out mapping.
 */
function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
  let cmp = mappingA.generatedLine - mappingB.generatedLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
  if (cmp !== 0 || onlyCompareGenerated) {
    return cmp;
  }

  cmp = strcmp(mappingA.source, mappingB.source);
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;
  if (cmp !== 0) {
    return cmp;
  }

  return strcmp(mappingA.name, mappingB.name);
}
exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;

function strcmp(aStr1, aStr2) {
  if (aStr1 === aStr2) {
    return 0;
  }

  if (aStr1 === null) {
    return 1; // aStr2 !== null
  }

  if (aStr2 === null) {
    return -1; // aStr1 !== null
  }

  if (aStr1 > aStr2) {
    return 1;
  }

  return -1;
}

/**
 * Comparator between two mappings with inflated source and name strings where
 * the generated positions are compared.
 */
function compareByGeneratedPositionsInflated(mappingA, mappingB) {
  let cmp = mappingA.generatedLine - mappingB.generatedLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = strcmp(mappingA.source, mappingB.source);
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;
  if (cmp !== 0) {
    return cmp;
  }

  return strcmp(mappingA.name, mappingB.name);
}
exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;

/**
 * Strip any JSON XSSI avoidance prefix from the string (as documented
 * in the source maps specification), and then parse the string as
 * JSON.
 */
function parseSourceMapInput(str) {
  return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ""));
}
exports.parseSourceMapInput = parseSourceMapInput;

/**
 * Compute the URL of a source given the the source root, the source's
 * URL, and the source map's URL.
 */
function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
  sourceURL = sourceURL || "";

  if (sourceRoot) {
    // This follows what Chrome does.
    if (sourceRoot[sourceRoot.length - 1] !== "/" && sourceURL[0] !== "/") {
      sourceRoot += "/";
    }
    // The spec says:
    //   Line 4: An optional source root, useful for relocating source
    //   files on a server or removing repeated values in the
    //   “sources” entry.  This value is prepended to the individual
    //   entries in the “source” field.
    sourceURL = sourceRoot + sourceURL;
  }

  // Historically, SourceMapConsumer did not take the sourceMapURL as
  // a parameter.  This mode is still somewhat supported, which is why
  // this code block is conditional.  However, it's preferable to pass
  // the source map URL to SourceMapConsumer, so that this function
  // can implement the source URL resolution algorithm as outlined in
  // the spec.  This block is basically the equivalent of:
  //    new URL(sourceURL, sourceMapURL).toString()
  // ... except it avoids using URL, which wasn't available in the
  // older releases of node still supported by this library.
  //
  // The spec says:
  //   If the sources are not absolute URLs after prepending of the
  //   “sourceRoot”, the sources are resolved relative to the
  //   SourceMap (like resolving script src in a html document).
  if (sourceMapURL) {
    const parsed = urlParse(sourceMapURL);
    if (!parsed) {
      throw new Error("sourceMapURL could not be parsed");
    }
    if (parsed.path) {
      // Strip the last path component, but keep the "/".
      const index = parsed.path.lastIndexOf("/");
      if (index >= 0) {
        parsed.path = parsed.path.substring(0, index + 1);
      }
    }
    sourceURL = join(urlGenerate(parsed), sourceURL);
  }

  return normalize(sourceURL);
}
exports.computeSourceURL = computeSourceURL;


/***/ }),

/***/ "../../node_modules/@datadog/pprof/node_modules/source-map/lib/wasm.js":
/*!**********************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/@datadog/pprof/node_modules/source-map/lib/wasm.js ***!
  \**********************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

const readWasm = __webpack_require__(/*! ../lib/read-wasm */ "../../node_modules/@datadog/pprof/node_modules/source-map/lib/read-wasm.js");

/**
 * Provide the JIT with a nice shape / hidden class.
 */
function Mapping() {
  this.generatedLine = 0;
  this.generatedColumn = 0;
  this.lastGeneratedColumn = null;
  this.source = null;
  this.originalLine = null;
  this.originalColumn = null;
  this.name = null;
}

let cachedWasm = null;

module.exports = function wasm() {
  if (cachedWasm) {
    return cachedWasm;
  }

  const callbackStack = [];

  cachedWasm = readWasm().then(buffer => {
      return WebAssembly.instantiate(buffer, {
        env: {
          mapping_callback(
            generatedLine,
            generatedColumn,

            hasLastGeneratedColumn,
            lastGeneratedColumn,

            hasOriginal,
            source,
            originalLine,
            originalColumn,

            hasName,
            name
          ) {
            const mapping = new Mapping();
            // JS uses 1-based line numbers, wasm uses 0-based.
            mapping.generatedLine = generatedLine + 1;
            mapping.generatedColumn = generatedColumn;

            if (hasLastGeneratedColumn) {
              // JS uses inclusive last generated column, wasm uses exclusive.
              mapping.lastGeneratedColumn = lastGeneratedColumn - 1;
            }

            if (hasOriginal) {
              mapping.source = source;
              // JS uses 1-based line numbers, wasm uses 0-based.
              mapping.originalLine = originalLine + 1;
              mapping.originalColumn = originalColumn;

              if (hasName) {
                mapping.name = name;
              }
            }

            callbackStack[callbackStack.length - 1](mapping);
          },

          start_all_generated_locations_for() { console.time("all_generated_locations_for"); },
          end_all_generated_locations_for() { console.timeEnd("all_generated_locations_for"); },

          start_compute_column_spans() { console.time("compute_column_spans"); },
          end_compute_column_spans() { console.timeEnd("compute_column_spans"); },

          start_generated_location_for() { console.time("generated_location_for"); },
          end_generated_location_for() { console.timeEnd("generated_location_for"); },

          start_original_location_for() { console.time("original_location_for"); },
          end_original_location_for() { console.timeEnd("original_location_for"); },

          start_parse_mappings() { console.time("parse_mappings"); },
          end_parse_mappings() { console.timeEnd("parse_mappings"); },

          start_sort_by_generated_location() { console.time("sort_by_generated_location"); },
          end_sort_by_generated_location() { console.timeEnd("sort_by_generated_location"); },

          start_sort_by_original_location() { console.time("sort_by_original_location"); },
          end_sort_by_original_location() { console.timeEnd("sort_by_original_location"); },
        }
      });
  }).then(Wasm => {
    return {
      exports: Wasm.instance.exports,
      withMappingCallback: (mappingCallback, f) => {
        callbackStack.push(mappingCallback);
        try {
          f();
        } finally {
          callbackStack.pop();
        }
      }
    };
  }).then(null, e => {
    cachedWasm = null;
    throw e;
  });

  return cachedWasm;
};


/***/ }),

/***/ "../../node_modules/@datadog/pprof/node_modules/source-map/source-map.js":
/*!************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/@datadog/pprof/node_modules/source-map/source-map.js ***!
  \************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

/*
 * Copyright 2009-2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE.txt or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
exports.SourceMapGenerator = __webpack_require__(/*! ./lib/source-map-generator */ "../../node_modules/@datadog/pprof/node_modules/source-map/lib/source-map-generator.js").SourceMapGenerator;
exports.SourceMapConsumer = __webpack_require__(/*! ./lib/source-map-consumer */ "../../node_modules/@datadog/pprof/node_modules/source-map/lib/source-map-consumer.js").SourceMapConsumer;
exports.SourceNode = __webpack_require__(/*! ./lib/source-node */ "../../node_modules/@datadog/pprof/node_modules/source-map/lib/source-node.js").SourceNode;


/***/ }),

/***/ "../../node_modules/@datadog/pprof/out/src/heap-profiler-bindings.js":
/*!********************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/@datadog/pprof/out/src/heap-profiler-bindings.js ***!
  \********************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2018 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.getAllocationProfile = exports.stopSamplingHeapProfiler = exports.startSamplingHeapProfiler = void 0;
const path = __webpack_require__(/*! path */ "path");
const findBinding = __webpack_require__(/*! node-gyp-build */ "../../node_modules/node-gyp-build/index.js");
const profiler = findBinding(path.join(__dirname, '..', '..'));
// Wrappers around native heap profiler functions.
function startSamplingHeapProfiler(heapIntervalBytes, heapStackDepth) {
    profiler.heapProfiler.startSamplingHeapProfiler(heapIntervalBytes, heapStackDepth);
}
exports.startSamplingHeapProfiler = startSamplingHeapProfiler;
function stopSamplingHeapProfiler() {
    profiler.heapProfiler.stopSamplingHeapProfiler();
}
exports.stopSamplingHeapProfiler = stopSamplingHeapProfiler;
function getAllocationProfile() {
    return profiler.heapProfiler.getAllocationProfile();
}
exports.getAllocationProfile = getAllocationProfile;
//# sourceMappingURL=heap-profiler-bindings.js.map

/***/ }),

/***/ "../../node_modules/@datadog/pprof/out/src/heap-profiler.js":
/*!***********************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/@datadog/pprof/out/src/heap-profiler.js ***!
  \***********************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.stop = exports.start = exports.profile = exports.v8Profile = void 0;
const heap_profiler_bindings_1 = __webpack_require__(/*! ./heap-profiler-bindings */ "../../node_modules/@datadog/pprof/out/src/heap-profiler-bindings.js");
const profile_serializer_1 = __webpack_require__(/*! ./profile-serializer */ "../../node_modules/@datadog/pprof/out/src/profile-serializer.js");
let enabled = false;
let heapIntervalBytes = 0;
let heapStackDepth = 0;
/*
 * Collects a heap profile when heapProfiler is enabled. Otherwise throws
 * an error.
 *
 * Data is returned in V8 allocation profile format.
 */
function v8Profile() {
    if (!enabled) {
        throw new Error('Heap profiler is not enabled.');
    }
    return heap_profiler_bindings_1.getAllocationProfile();
}
exports.v8Profile = v8Profile;
/**
 * Collects a profile and returns it serialized in pprof format.
 * Throws if heap profiler is not enabled.
 *
 * @param ignoreSamplePath
 * @param sourceMapper
 */
function profile(ignoreSamplePath, sourceMapper) {
    const startTimeNanos = Date.now() * 1000 * 1000;
    const result = v8Profile();
    // Add node for external memory usage.
    // Current type definitions do not have external.
    // TODO: remove any once type definition is updated to include external.
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const { external } = process.memoryUsage();
    if (external > 0) {
        const externalNode = {
            name: '(external)',
            scriptName: '',
            children: [],
            allocations: [{ sizeBytes: external, count: 1 }],
        };
        result.children.push(externalNode);
    }
    return profile_serializer_1.serializeHeapProfile(result, startTimeNanos, heapIntervalBytes, ignoreSamplePath, sourceMapper);
}
exports.profile = profile;
/**
 * Starts heap profiling. If heap profiling has already been started with
 * the same parameters, this is a noop. If heap profiler has already been
 * started with different parameters, this throws an error.
 *
 * @param intervalBytes - average number of bytes between samples.
 * @param stackDepth - maximum stack depth for samples collected.
 */
function start(intervalBytes, stackDepth) {
    if (enabled) {
        throw new Error(`Heap profiler is already started  with intervalBytes ${heapIntervalBytes} and stackDepth ${stackDepth}`);
    }
    heapIntervalBytes = intervalBytes;
    heapStackDepth = stackDepth;
    heap_profiler_bindings_1.startSamplingHeapProfiler(heapIntervalBytes, heapStackDepth);
    enabled = true;
}
exports.start = start;
// Stops heap profiling. If heap profiling has not been started, does nothing.
function stop() {
    if (enabled) {
        enabled = false;
        heap_profiler_bindings_1.stopSamplingHeapProfiler();
    }
}
exports.stop = stop;
//# sourceMappingURL=heap-profiler.js.map

/***/ }),

/***/ "../../node_modules/@datadog/pprof/out/src/index.js":
/*!***************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/@datadog/pprof/out/src/index.js ***!
  \***************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.heap = exports.time = exports.SourceMapper = exports.encodeSync = exports.encode = void 0;
/**
 * Copyright 2019 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const fs_1 = __webpack_require__(/*! fs */ "fs");
const heapProfiler = __webpack_require__(/*! ./heap-profiler */ "../../node_modules/@datadog/pprof/out/src/heap-profiler.js");
const profile_encoder_1 = __webpack_require__(/*! ./profile-encoder */ "../../node_modules/@datadog/pprof/out/src/profile-encoder.js");
const timeProfiler = __webpack_require__(/*! ./time-profiler */ "../../node_modules/@datadog/pprof/out/src/time-profiler.js");
var profile_encoder_2 = __webpack_require__(/*! ./profile-encoder */ "../../node_modules/@datadog/pprof/out/src/profile-encoder.js");
Object.defineProperty(exports, "encode", { enumerable: true, get: function () { return profile_encoder_2.encode; } });
Object.defineProperty(exports, "encodeSync", { enumerable: true, get: function () { return profile_encoder_2.encodeSync; } });
var sourcemapper_1 = __webpack_require__(/*! ./sourcemapper/sourcemapper */ "../../node_modules/@datadog/pprof/out/src/sourcemapper/sourcemapper.js");
Object.defineProperty(exports, "SourceMapper", { enumerable: true, get: function () { return sourcemapper_1.SourceMapper; } });
exports.time = {
    profile: timeProfiler.profile,
    start: timeProfiler.start,
};
exports.heap = {
    start: heapProfiler.start,
    stop: heapProfiler.stop,
    profile: heapProfiler.profile,
    v8Profile: heapProfiler.v8Profile,
};
// If loaded with --require, start profiling.
if (module.parent && module.parent.id === 'internal/preload') {
    const stop = exports.time.start();
    process.on('exit', () => {
        // The process is going to terminate imminently. All work here needs to
        // be synchronous.
        const profile = stop();
        const buffer = profile_encoder_1.encodeSync(profile);
        fs_1.writeFileSync(`pprof-profile-${process.pid}.pb.gz`, buffer);
    });
}
//# sourceMappingURL=index.js.map
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/module.js */ "../../node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "../../node_modules/@datadog/pprof/out/src/profile-encoder.js":
/*!*************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/@datadog/pprof/out/src/profile-encoder.js ***!
  \*************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2019 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.encodeSync = exports.encode = void 0;
const pify = __webpack_require__(/*! pify */ "../../node_modules/@datadog/pprof/node_modules/pify/index.js");
const zlib_1 = __webpack_require__(/*! zlib */ "zlib");
const profile_1 = __webpack_require__(/*! ../../proto/profile */ "../../node_modules/@datadog/pprof/proto/profile.js");
const gzipPromise = pify(zlib_1.gzip);
function encode(profile) {
    return __awaiter(this, void 0, void 0, function* () {
        const buffer = profile_1.perftools.profiles.Profile.encode(profile).finish();
        return gzipPromise(buffer);
    });
}
exports.encode = encode;
function encodeSync(profile) {
    const buffer = profile_1.perftools.profiles.Profile.encode(profile).finish();
    return zlib_1.gzipSync(buffer);
}
exports.encodeSync = encodeSync;
//# sourceMappingURL=profile-encoder.js.map

/***/ }),

/***/ "../../node_modules/@datadog/pprof/out/src/profile-serializer.js":
/*!****************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/@datadog/pprof/out/src/profile-serializer.js ***!
  \****************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.serializeHeapProfile = exports.serializeTimeProfile = void 0;
const profile_1 = __webpack_require__(/*! ../../proto/profile */ "../../node_modules/@datadog/pprof/proto/profile.js");
function isGeneratedLocation(location) {
    return (location.column !== undefined &&
        location.line !== undefined &&
        location.line > 0);
}
/**
 * Used to build string table and access strings and their ids within the table
 * when serializing a profile.
 */
class StringTable {
    constructor() {
        this.strings = [];
        this.stringsMap = new Map();
        this.getIndexOrAdd('');
    }
    /**
     * @return index of str within the table. Also adds str to string table if
     * str is not in the table already.
     */
    getIndexOrAdd(str) {
        let idx = this.stringsMap.get(str);
        if (idx !== undefined) {
            return idx;
        }
        idx = this.strings.push(str) - 1;
        this.stringsMap.set(str, idx);
        return idx;
    }
}
/**
 * Takes v8 profile and populates sample, location, and function fields of
 * profile.proto.
 *
 * @param profile - profile.proto with empty sample, location, and function
 * fields.
 * @param root - root of v8 profile tree describing samples to be appended
 * to profile.
 * @param appendToSamples - function which converts entry to sample(s)  and
 * appends these to end of an array of samples.
 * @param stringTable - string table for the existing profile.
 */
function serialize(profile, root, appendToSamples, stringTable, ignoreSamplesPath, sourceMapper) {
    const samples = [];
    const locations = [];
    const functions = [];
    const functionIdMap = new Map();
    const locationIdMap = new Map();
    const entries = root.children.map((n) => ({
        node: n,
        stack: [],
    }));
    while (entries.length > 0) {
        const entry = entries.pop();
        const node = entry.node;
        if (ignoreSamplesPath && node.scriptName.indexOf(ignoreSamplesPath) > -1) {
            continue;
        }
        if (node.name === '(idle)' || node.name === '(program)')
            continue;
        const stack = entry.stack;
        const location = getLocation(node, sourceMapper);
        stack.unshift(location.id);
        appendToSamples(entry, samples);
        for (const child of node.children) {
            entries.push({ node: child, stack: stack.slice() });
        }
    }
    profile.sample = samples;
    profile.location = locations;
    profile.function = functions;
    profile.stringTable = stringTable.strings;
    function getLocation(node, sourceMapper) {
        let profLoc = {
            file: node.scriptName || '',
            line: node.lineNumber,
            column: node.columnNumber,
            name: node.name,
        };
        if (profLoc.line) {
            if (sourceMapper && isGeneratedLocation(profLoc)) {
                profLoc = sourceMapper.mappingInfo(profLoc);
            }
        }
        const keyStr = `${node.scriptId}:${profLoc.line}:${profLoc.column}:${profLoc.name}`;
        let id = locationIdMap.get(keyStr);
        if (id !== undefined) {
            // id is index+1, since 0 is not valid id.
            return locations[id - 1];
        }
        id = locations.length + 1;
        locationIdMap.set(keyStr, id);
        const line = getLine(node.scriptId, profLoc.file, profLoc.name, profLoc.line);
        const location = new profile_1.perftools.profiles.Location({ id, line: [line] });
        locations.push(location);
        return location;
    }
    function getLine(scriptId, scriptName, name, line) {
        return new profile_1.perftools.profiles.Line({
            functionId: getFunction(scriptId, scriptName, name).id,
            line,
        });
    }
    function getFunction(scriptId, scriptName, name) {
        const keyStr = `${scriptId}:${name}`;
        let id = functionIdMap.get(keyStr);
        if (id !== undefined) {
            // id is index+1, since 0 is not valid id.
            return functions[id - 1];
        }
        id = functions.length + 1;
        functionIdMap.set(keyStr, id);
        const nameId = stringTable.getIndexOrAdd(name || '(anonymous)');
        const f = new profile_1.perftools.profiles.Function({
            id,
            name: nameId,
            systemName: nameId,
            filename: stringTable.getIndexOrAdd(scriptName || ''),
        });
        functions.push(f);
        return f;
    }
}
/**
 * @return value type for sample counts (type:sample, units:count), and
 * adds strings used in this value type to the table.
 */
function createSampleCountValueType(table) {
    return new profile_1.perftools.profiles.ValueType({
        type: table.getIndexOrAdd('sample'),
        unit: table.getIndexOrAdd('count'),
    });
}
/**
 * @return value type for time samples (type:wall, units:nanoseconds), and
 * adds strings used in this value type to the table.
 */
function createTimeValueType(table) {
    return new profile_1.perftools.profiles.ValueType({
        type: table.getIndexOrAdd('wall'),
        unit: table.getIndexOrAdd('nanoseconds'),
    });
}
/**
 * @return value type for object counts (type:objects, units:count), and
 * adds strings used in this value type to the table.
 */
function createObjectCountValueType(table) {
    return new profile_1.perftools.profiles.ValueType({
        type: table.getIndexOrAdd('objects'),
        unit: table.getIndexOrAdd('count'),
    });
}
/**
 * @return value type for memory allocations (type:space, units:bytes), and
 * adds strings used in this value type to the table.
 */
function createAllocationValueType(table) {
    return new profile_1.perftools.profiles.ValueType({
        type: table.getIndexOrAdd('space'),
        unit: table.getIndexOrAdd('bytes'),
    });
}
/**
 * Converts v8 time profile into into a profile proto.
 * (https://github.com/google/pprof/blob/master/proto/profile.proto)
 *
 * @param prof - profile to be converted.
 * @param intervalMicros - average time (microseconds) between samples.
 */
function serializeTimeProfile(prof, intervalMicros, sourceMapper) {
    const intervalNanos = intervalMicros * 1000;
    const appendTimeEntryToSamples = (entry, samples) => {
        if (entry.node.hitCount > 0) {
            const sample = new profile_1.perftools.profiles.Sample({
                locationId: entry.stack,
                value: [entry.node.hitCount, entry.node.hitCount * intervalNanos],
            });
            samples.push(sample);
        }
    };
    const stringTable = new StringTable();
    const sampleValueType = createSampleCountValueType(stringTable);
    const timeValueType = createTimeValueType(stringTable);
    const profile = {
        sampleType: [sampleValueType, timeValueType],
        timeNanos: Date.now() * 1000 * 1000,
        durationNanos: (prof.endTime - prof.startTime) * 1000,
        periodType: timeValueType,
        period: intervalMicros,
    };
    serialize(profile, prof.topDownRoot, appendTimeEntryToSamples, stringTable, undefined, sourceMapper);
    return profile;
}
exports.serializeTimeProfile = serializeTimeProfile;
/**
 * Converts v8 heap profile into into a profile proto.
 * (https://github.com/google/pprof/blob/master/proto/profile.proto)
 *
 * @param prof - profile to be converted.
 * @param startTimeNanos - start time of profile, in nanoseconds (POSIX time).
 * @param durationsNanos - duration of the profile (wall clock time) in
 * nanoseconds.
 * @param intervalBytes - bytes allocated between samples.
 */
function serializeHeapProfile(prof, startTimeNanos, intervalBytes, ignoreSamplesPath, sourceMapper) {
    const appendHeapEntryToSamples = (entry, samples) => {
        if (entry.node.allocations.length > 0) {
            for (const alloc of entry.node.allocations) {
                const sample = new profile_1.perftools.profiles.Sample({
                    locationId: entry.stack,
                    value: [alloc.count, alloc.sizeBytes * alloc.count],
                    // TODO: add tag for allocation size
                });
                samples.push(sample);
            }
        }
    };
    const stringTable = new StringTable();
    const sampleValueType = createObjectCountValueType(stringTable);
    const allocationValueType = createAllocationValueType(stringTable);
    const profile = {
        sampleType: [sampleValueType, allocationValueType],
        timeNanos: startTimeNanos,
        periodType: allocationValueType,
        period: intervalBytes,
    };
    serialize(profile, prof, appendHeapEntryToSamples, stringTable, ignoreSamplesPath, sourceMapper);
    return profile;
}
exports.serializeHeapProfile = serializeHeapProfile;
//# sourceMappingURL=profile-serializer.js.map

/***/ }),

/***/ "../../node_modules/@datadog/pprof/out/src/sourcemapper/sourcemapper.js":
/*!***********************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/@datadog/pprof/out/src/sourcemapper/sourcemapper.js ***!
  \***********************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SourceMapper = void 0;
// Originally copied from cloud-debug-nodejs's sourcemapper.ts from
// https://github.com/googleapis/cloud-debug-nodejs/blob/7bdc2f1f62a3b45b7b53ea79f9444c8ed50e138b/src/agent/io/sourcemapper.ts
// Modified to map from generated code to source code, rather than from source
// code to generated code.
const fs = __webpack_require__(/*! fs */ "fs");
const path = __webpack_require__(/*! path */ "path");
const sourceMap = __webpack_require__(/*! source-map */ "../../node_modules/@datadog/pprof/node_modules/source-map/source-map.js");
const scanner = __webpack_require__(/*! ../../third_party/cloud-debug-nodejs/src/agent/io/scanner */ "../../node_modules/@datadog/pprof/out/third_party/cloud-debug-nodejs/src/agent/io/scanner.js");
const pify = __webpack_require__(/*! pify */ "../../node_modules/@datadog/pprof/node_modules/pify/index.js");
const pLimit = __webpack_require__(/*! p-limit */ "../../node_modules/p-limit/index.js");
const readFile = pify(fs.readFile);
const CONCURRENCY = 10;
const MAP_EXT = '.map';
/**
 * @param {!Map} infoMap The map that maps input source files to
 *  SourceMapConsumer objects that are used to calculate mapping information
 * @param {string} mapPath The path to the source map file to process.  The
 *  path should be relative to the process's current working directory
 * @private
 */
function processSourceMap(infoMap, mapPath) {
    return __awaiter(this, void 0, void 0, function* () {
        // this handles the case when the path is undefined, null, or
        // the empty string
        if (!mapPath || !mapPath.endsWith(MAP_EXT)) {
            throw new Error(`The path "${mapPath}" does not specify a source map file`);
        }
        mapPath = path.normalize(mapPath);
        let contents;
        try {
            contents = yield readFile(mapPath, 'utf8');
        }
        catch (e) {
            throw new Error('Could not read source map file ' + mapPath + ': ' + e);
        }
        let consumer;
        try {
            // TODO: Determine how to reconsile the type conflict where `consumer`
            //       is constructed as a SourceMapConsumer but is used as a
            //       RawSourceMap.
            // TODO: Resolve the cast of `contents as any` (This is needed because the
            //       type is expected to be of `RawSourceMap` but the existing
            //       working code uses a string.)
            consumer = (yield new sourceMap.SourceMapConsumer(contents));
        }
        catch (e) {
            throw new Error('An error occurred while reading the ' +
                'sourceMap file ' +
                mapPath +
                ': ' +
                e);
        }
        /*
         * If the source map file defines a "file" attribute, use it as
         * the output file where the path is relative to the directory
         * containing the map file.  Otherwise, use the name of the output
         * file (with the .map extension removed) as the output file.
         */
        const dir = path.dirname(mapPath);
        const generatedBase = consumer.file
            ? consumer.file
            : path.basename(mapPath, MAP_EXT);
        const generatedPath = path.resolve(dir, generatedBase);
        infoMap.set(generatedPath, { mapFileDir: dir, mapConsumer: consumer });
    });
}
class SourceMapper {
    /**
     * @param {Array.<string>} sourceMapPaths An array of paths to .map source map
     *  files that should be processed.  The paths should be relative to the
     *  current process's current working directory
     * @param {Logger} logger A logger that reports errors that occurred while
     *  processing the given source map files
     * @constructor
     */
    constructor() {
        this.infoMap = new Map();
    }
    static create(searchDirs) {
        return __awaiter(this, void 0, void 0, function* () {
            const mapFiles = [];
            for (const dir of searchDirs) {
                try {
                    const mf = yield getMapFiles(dir);
                    mf.forEach(mapFile => {
                        mapFiles.push(path.resolve(dir, mapFile));
                    });
                }
                catch (e) {
                    throw new Error(`failed to get source maps from ${dir}: ${e}`);
                }
            }
            return createFromMapFiles(mapFiles);
        });
    }
    /**
     * Used to get the information about the transpiled file from a given input
     * source file provided there isn't any ambiguity with associating the input
     * path to exactly one output transpiled file.
     *
     * @param inputPath The (possibly relative) path to the original source file.
     * @return The `MapInfoCompiled` object that describes the transpiled file
     *  associated with the specified input path.  `null` is returned if either
     *  zero files are associated with the input path or if more than one file
     *  could possibly be associated with the given input path.
     */
    getMappingInfo(inputPath) {
        if (this.infoMap.has(path.normalize(inputPath))) {
            return this.infoMap.get(inputPath);
        }
        return null;
    }
    /**
     * Used to determine if the source file specified by the given path has
     * a .map file and an output file associated with it.
     *
     * If there is no such mapping, it could be because the input file is not
     * the input to a transpilation process or it is the input to a transpilation
     * process but its corresponding .map file was not given to the constructor
     * of this mapper.
     *
     * @param {string} inputPath The path to an input file that could
     *  possibly be the input to a transpilation process.  The path should be
     *  relative to the process's current working directory.
     */
    hasMappingInfo(inputPath) {
        return this.getMappingInfo(inputPath) !== null;
    }
    /**
     * @param {string} inputPath The path to an input file that could possibly
     *  be the input to a transpilation process.  The path should be relative to
     *  the process's current working directory
     * @param {number} The line number in the input file where the line number is
     *   zero-based.
     * @param {number} (Optional) The column number in the line of the file
     *   specified where the column number is zero-based.
     * @return {Object} The object returned has a "file" attribute for the
     *   path of the output file associated with the given input file (where the
     *   path is relative to the process's current working directory),
     *   a "line" attribute of the line number in the output file associated with
     *   the given line number for the input file, and an optional "column" number
     *   of the column number of the output file associated with the given file
     *   and line information.
     *
     *   If the given input file does not have mapping information associated
     *   with it then the input location is returned.
     */
    mappingInfo(location) {
        const inputPath = path.normalize(location.file);
        const entry = this.getMappingInfo(inputPath);
        if (entry === null) {
            return location;
        }
        const generatedPos = { line: location.line, column: location.column };
        // TODO: Determine how to remove the explicit cast here.
        const consumer = entry.mapConsumer;
        const pos = consumer.originalPositionFor(generatedPos);
        if (pos.source === null) {
            return location;
        }
        return {
            file: path.resolve(entry.mapFileDir, pos.source),
            line: pos.line || undefined,
            name: pos.name || location.name,
            column: pos.column || undefined,
        };
    }
}
exports.SourceMapper = SourceMapper;
function createFromMapFiles(mapFiles) {
    return __awaiter(this, void 0, void 0, function* () {
        const limit = pLimit(CONCURRENCY);
        const mapper = new SourceMapper();
        const promises = mapFiles.map(mapPath => limit(() => processSourceMap(mapper.infoMap, mapPath)));
        try {
            yield Promise.all(promises);
        }
        catch (err) {
            throw new Error('An error occurred while processing the source map files' + err);
        }
        return mapper;
    });
}
function getMapFiles(baseDir) {
    return __awaiter(this, void 0, void 0, function* () {
        const fileStats = yield scanner.scan(false, baseDir, /.js.map$/);
        const mapFiles = fileStats.selectFiles(/.js.map$/, process.cwd());
        return mapFiles;
    });
}
//# sourceMappingURL=sourcemapper.js.map

/***/ }),

/***/ "../../node_modules/@datadog/pprof/out/src/time-profiler-bindings.js":
/*!********************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/@datadog/pprof/out/src/time-profiler-bindings.js ***!
  \********************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.TimeProfiler = void 0;
/**
 * Copyright 2018 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const path_1 = __webpack_require__(/*! path */ "path");
const findBinding = __webpack_require__(/*! node-gyp-build */ "../../node_modules/node-gyp-build/index.js");
const profiler = findBinding(path_1.join(__dirname, '..', '..'));
exports.TimeProfiler = profiler.TimeProfiler;
//# sourceMappingURL=time-profiler-bindings.js.map

/***/ }),

/***/ "../../node_modules/@datadog/pprof/out/src/time-profiler.js":
/*!***********************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/@datadog/pprof/out/src/time-profiler.js ***!
  \***********************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.start = exports.profile = void 0;
const delay_1 = __webpack_require__(/*! delay */ "../../node_modules/delay/index.js");
const profile_serializer_1 = __webpack_require__(/*! ./profile-serializer */ "../../node_modules/@datadog/pprof/out/src/profile-serializer.js");
const time_profiler_bindings_1 = __webpack_require__(/*! ./time-profiler-bindings */ "../../node_modules/@datadog/pprof/out/src/time-profiler-bindings.js");
const DEFAULT_INTERVAL_MICROS = 1000;
const majorVersion = process.version.slice(1).split('.').map(Number)[0];
function profile(options) {
    return __awaiter(this, void 0, void 0, function* () {
        const stop = start(options.intervalMicros || DEFAULT_INTERVAL_MICROS, options.name, options.sourceMapper, options.lineNumbers);
        yield delay_1.default(options.durationMillis);
        return stop();
    });
}
exports.profile = profile;
function ensureRunName(name) {
    return name || `pprof-${Date.now()}-${Math.random()}`;
}
// NOTE: refreshing doesn't work if giving a profile name.
function start(intervalMicros = DEFAULT_INTERVAL_MICROS, name, sourceMapper, lineNumbers = true) {
    const profiler = new time_profiler_bindings_1.TimeProfiler(intervalMicros);
    let runName = start();
    return majorVersion < 16 ? stopOld : stop;
    function start() {
        const runName = ensureRunName(name);
        profiler.start(runName, lineNumbers);
        return runName;
    }
    // Node.js versions prior to v16 leak memory if not disposed and recreated
    // between each profile. As disposing deletes current profile data too,
    // we must stop then dispose then start.
    function stopOld(restart = false) {
        const result = profiler.stop(runName, lineNumbers);
        profiler.dispose();
        if (restart) {
            runName = start();
        }
        return profile_serializer_1.serializeTimeProfile(result, intervalMicros, sourceMapper);
    }
    // For Node.js v16+, we want to start the next profile before we stop the
    // current one as otherwise the active profile count could reach zero which
    // means V8 might tear down the symbolizer thread and need to start it again.
    function stop(restart = false) {
        let nextRunName;
        if (restart) {
            nextRunName = start();
        }
        const result = profiler.stop(runName, lineNumbers);
        if (nextRunName) {
            runName = nextRunName;
        }
        if (!restart)
            profiler.dispose();
        return profile_serializer_1.serializeTimeProfile(result, intervalMicros, sourceMapper);
    }
}
exports.start = start;
//# sourceMappingURL=time-profiler.js.map

/***/ }),

/***/ "../../node_modules/@datadog/pprof/out/third_party/cloud-debug-nodejs/src/agent/io/scanner.js":
/*!*********************************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/@datadog/pprof/out/third_party/cloud-debug-nodejs/src/agent/io/scanner.js ***!
  \*********************************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.scan = void 0;
const crypto = __webpack_require__(/*! crypto */ "crypto");
const fs = __webpack_require__(/*! fs */ "fs");
const path = __webpack_require__(/*! path */ "path");
// TODO: Make this more precise.
const findit = __webpack_require__(/*! findit2 */ "../../node_modules/findit2/index.js");
// TODO: Make this more precise.
const split = __webpack_require__(/*! split */ "../../node_modules/split/index.js");
class ScanResultsImpl {
    /**
     * Encapsulates the results of a filesystem scan with methods
     * to easily select scan information or filenames for a
     * specific subset of the files listed in the scan results.
     *
     * @param stats An object that contains filenames
     *  as keys where each key maps to an object containing the
     *  hash and number of lines for the specified file.  This
     *  information is accessed via the `hash` and `lines`
     *  attributes respectively
     * @param hash A hashcode computed from the contents of all the files.
     */
    constructor(stats, errorMap, hash) {
        this.stats = stats;
        this.errorMap = errorMap;
        this.hash = hash;
    }
    errors() {
        return this.errorMap;
    }
    /**
     * Used to get all of the file scan results.
     */
    all() {
        return this.stats;
    }
    /**
     * Used to get the only the file paths in the scan results
     * where the filenames match the specified regex and are
     * returned with the each relative to the specified base
     * directory.
     *
     * @param {regex} regex The regex that tests a filename to
     *  determine if the scan results for that filename should
     *  be included in the returned results.
     * @param {string} baseDir The absolute path to the directory
     *  from which all of the returned paths should be relative
     *  to.
     */
    selectFiles(regex, baseDir) {
        // ensure the base directory has only a single trailing path separator
        baseDir = path.normalize(baseDir + path.sep);
        return Object.keys(this.stats)
            .filter(file => {
            return file && regex.test(file);
        })
            .map(file => {
            return path.normalize(file).replace(baseDir, '');
        });
    }
}
function scan(shouldHash, baseDir, regex) {
    return __awaiter(this, void 0, void 0, function* () {
        const fileList = yield findFiles(baseDir, regex);
        return computeStats(fileList, shouldHash);
    });
}
exports.scan = scan;
/**
 * This function accept an array of filenames and computes a unique hash-code
 * based on the contents.
 *
 * @param {!Array<string>} fileList array of filenames
 * @param {Boolean} shouldHash whether a hash should be computed
 * @param {!function(?Error, ?string, Object)} callback error-back style callback
 *    returning the hash-code and an object containing file statistics.
 */
// TODO: Typescript: Fix the docs associated with this function to match the
// call signature
function computeStats(fileList, shouldHash) {
    // eslint-disable-next-line no-async-promise-executor
    return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
        // return a valid, if fake, result when there are no js files to hash.
        if (fileList.length === 0) {
            resolve(new ScanResultsImpl({}, new Map(), 'EMPTY-no-js-files'));
            return;
        }
        // TODO: Address the case where the array contains `undefined`.
        const hashes = [];
        const statistics = {};
        const errors = new Map();
        for (const filename of fileList) {
            try {
                const fileStats = yield statsForFile(filename, shouldHash);
                if (shouldHash) {
                    hashes.push(fileStats.hash);
                }
                statistics[filename] = fileStats;
            }
            catch (err) {
                errors.set(filename, err);
            }
        }
        let hash;
        if (shouldHash) {
            // Sort the hashes to get a deterministic order as the files may
            // not be in the same order each time we scan the disk.
            const buffer = hashes.sort().join();
            const sha1 = crypto.createHash('sha1').update(buffer).digest('hex');
            hash = 'SHA1-' + sha1;
        }
        resolve(new ScanResultsImpl(statistics, errors, hash));
    }));
}
/**
 * Given a base-directory, this function scans the subtree and finds all the js
 * files. .git and node_module subdirectories are ignored.
 * @param {!string} baseDir top-level directory to scan
 * @param {!regex} regex the regular expression that specifies the types of
 *  files to find based on their filename
 * @param {!function(?Error, Array<string>)} callback error-back callback
 */
function findFiles(baseDir, regex) {
    return new Promise((resolve, reject) => {
        let error;
        if (!baseDir) {
            reject(new Error('hasher.findJSFiles requires a baseDir argument'));
            return;
        }
        const find = findit(baseDir);
        const fileList = [];
        find.on('error', (err) => {
            error = err;
            return;
        });
        find.on('directory', (dir, ignore, stop) => {
            const base = path.basename(dir);
            if (base === '.git' || base === 'node_modules') {
                stop(); // do not descend
            }
        });
        find.on('file', (file) => {
            if (regex.test(file)) {
                fileList.push(file);
            }
        });
        find.on('end', () => {
            // Note: the `end` event fires even after an error
            if (error) {
                reject(error);
            }
            else {
                resolve(fileList);
            }
        });
    });
}
/**
 * Compute a sha hash for the given file and record line counts along the way.
 * @param {string} filename
 * @param {Boolean} shouldHash whether a hash should be computed
 * @param {function} cb errorback style callback which returns the sha string
 * @private
 */
function statsForFile(filename, shouldHash) {
    return new Promise((resolve, reject) => {
        const reader = fs.createReadStream(filename);
        reader.on('error', err => {
            reject(err);
        });
        reader.on('open', () => {
            let shasum;
            if (shouldHash) {
                shasum = crypto.createHash('sha1');
            }
            let lines = 0;
            let error;
            const byLine = reader.pipe(split());
            byLine.on('error', (e) => {
                error = e;
            });
            byLine.on('data', (d) => {
                if (shouldHash) {
                    shasum.update(d);
                }
                lines++;
            });
            byLine.on('end', () => {
                if (error) {
                    reject(error);
                }
                else {
                    const hash = shouldHash ? shasum.digest('hex') : undefined;
                    resolve({ hash, lines });
                }
            });
        });
    });
}
//# sourceMappingURL=scanner.js.map

/***/ }),

/***/ "../../node_modules/@datadog/pprof/proto/profile.js":
/*!***************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/@datadog/pprof/proto/profile.js ***!
  \***************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*eslint-disable block-scoped-var, no-redeclare, no-control-regex, no-prototype-builtins*/


var $protobuf = __webpack_require__(/*! protobufjs/minimal */ "../../node_modules/protobufjs/minimal.js");

// Common aliases
var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;

// Exported root namespace
var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});

$root.perftools = (function() {

    /**
     * Namespace perftools.
     * @exports perftools
     * @namespace
     */
    var perftools = {};

    perftools.profiles = (function() {

        /**
         * Namespace profiles.
         * @memberof perftools
         * @namespace
         */
        var profiles = {};

        profiles.Profile = (function() {

            /**
             * Properties of a Profile.
             * @memberof perftools.profiles
             * @interface IProfile
             * @property {Array.<perftools.profiles.IValueType>} [sampleType] Profile sampleType
             * @property {Array.<perftools.profiles.ISample>} [sample] Profile sample
             * @property {Array.<perftools.profiles.IMapping>} [mapping] Profile mapping
             * @property {Array.<perftools.profiles.ILocation>} [location] Profile location
             * @property {Array.<perftools.profiles.IFunction>} ["function"] Profile function
             * @property {Array.<string>} [stringTable] Profile stringTable
             * @property {number|Long} [dropFrames] Profile dropFrames
             * @property {number|Long} [keepFrames] Profile keepFrames
             * @property {number|Long} [timeNanos] Profile timeNanos
             * @property {number|Long} [durationNanos] Profile durationNanos
             * @property {perftools.profiles.IValueType} [periodType] Profile periodType
             * @property {number|Long} [period] Profile period
             * @property {Array.<number|Long>} [comment] Profile comment
             * @property {number|Long} [defaultSampleType] Profile defaultSampleType
             */

            /**
             * Constructs a new Profile.
             * @memberof perftools.profiles
             * @classdesc Represents a Profile.
             * @constructor
             * @param {perftools.profiles.IProfile=} [properties] Properties to set
             */
            function Profile(properties) {
                this.sampleType = [];
                this.sample = [];
                this.mapping = [];
                this.location = [];
                this["function"] = [];
                this.stringTable = [];
                this.comment = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Profile sampleType.
             * @member {Array.<perftools.profiles.IValueType>}sampleType
             * @memberof perftools.profiles.Profile
             * @instance
             */
            Profile.prototype.sampleType = $util.emptyArray;

            /**
             * Profile sample.
             * @member {Array.<perftools.profiles.ISample>}sample
             * @memberof perftools.profiles.Profile
             * @instance
             */
            Profile.prototype.sample = $util.emptyArray;

            /**
             * Profile mapping.
             * @member {Array.<perftools.profiles.IMapping>}mapping
             * @memberof perftools.profiles.Profile
             * @instance
             */
            Profile.prototype.mapping = $util.emptyArray;

            /**
             * Profile location.
             * @member {Array.<perftools.profiles.ILocation>}location
             * @memberof perftools.profiles.Profile
             * @instance
             */
            Profile.prototype.location = $util.emptyArray;

            /**
             * Profile function.
             * @member {Array.<perftools.profiles.IFunction>}function_
             * @memberof perftools.profiles.Profile
             * @instance
             */
            Profile.prototype["function"] = $util.emptyArray;

            /**
             * Profile stringTable.
             * @member {Array.<string>}stringTable
             * @memberof perftools.profiles.Profile
             * @instance
             */
            Profile.prototype.stringTable = $util.emptyArray;

            /**
             * Profile dropFrames.
             * @member {number|Long}dropFrames
             * @memberof perftools.profiles.Profile
             * @instance
             */
            Profile.prototype.dropFrames = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Profile keepFrames.
             * @member {number|Long}keepFrames
             * @memberof perftools.profiles.Profile
             * @instance
             */
            Profile.prototype.keepFrames = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Profile timeNanos.
             * @member {number|Long}timeNanos
             * @memberof perftools.profiles.Profile
             * @instance
             */
            Profile.prototype.timeNanos = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Profile durationNanos.
             * @member {number|Long}durationNanos
             * @memberof perftools.profiles.Profile
             * @instance
             */
            Profile.prototype.durationNanos = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Profile periodType.
             * @member {(perftools.profiles.IValueType|null|undefined)}periodType
             * @memberof perftools.profiles.Profile
             * @instance
             */
            Profile.prototype.periodType = null;

            /**
             * Profile period.
             * @member {number|Long}period
             * @memberof perftools.profiles.Profile
             * @instance
             */
            Profile.prototype.period = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Profile comment.
             * @member {Array.<number|Long>}comment
             * @memberof perftools.profiles.Profile
             * @instance
             */
            Profile.prototype.comment = $util.emptyArray;

            /**
             * Profile defaultSampleType.
             * @member {number|Long}defaultSampleType
             * @memberof perftools.profiles.Profile
             * @instance
             */
            Profile.prototype.defaultSampleType = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new Profile instance using the specified properties.
             * @function create
             * @memberof perftools.profiles.Profile
             * @static
             * @param {perftools.profiles.IProfile=} [properties] Properties to set
             * @returns {perftools.profiles.Profile} Profile instance
             */
            Profile.create = function create(properties) {
                return new Profile(properties);
            };

            /**
             * Encodes the specified Profile message. Does not implicitly {@link perftools.profiles.Profile.verify|verify} messages.
             * @function encode
             * @memberof perftools.profiles.Profile
             * @static
             * @param {perftools.profiles.IProfile} message Profile message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Profile.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.sampleType != null && message.sampleType.length)
                    for (var i = 0; i < message.sampleType.length; ++i)
                        $root.perftools.profiles.ValueType.encode(message.sampleType[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.sample != null && message.sample.length)
                    for (var i = 0; i < message.sample.length; ++i)
                        $root.perftools.profiles.Sample.encode(message.sample[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.mapping != null && message.mapping.length)
                    for (var i = 0; i < message.mapping.length; ++i)
                        $root.perftools.profiles.Mapping.encode(message.mapping[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.location != null && message.location.length)
                    for (var i = 0; i < message.location.length; ++i)
                        $root.perftools.profiles.Location.encode(message.location[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message["function"] != null && message["function"].length)
                    for (var i = 0; i < message["function"].length; ++i)
                        $root.perftools.profiles.Function.encode(message["function"][i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.stringTable != null && message.stringTable.length)
                    for (var i = 0; i < message.stringTable.length; ++i)
                        writer.uint32(/* id 6, wireType 2 =*/50).string(message.stringTable[i]);
                if (message.dropFrames != null && message.hasOwnProperty("dropFrames"))
                    writer.uint32(/* id 7, wireType 0 =*/56).int64(message.dropFrames);
                if (message.keepFrames != null && message.hasOwnProperty("keepFrames"))
                    writer.uint32(/* id 8, wireType 0 =*/64).int64(message.keepFrames);
                if (message.timeNanos != null && message.hasOwnProperty("timeNanos"))
                    writer.uint32(/* id 9, wireType 0 =*/72).int64(message.timeNanos);
                if (message.durationNanos != null && message.hasOwnProperty("durationNanos"))
                    writer.uint32(/* id 10, wireType 0 =*/80).int64(message.durationNanos);
                if (message.periodType != null && message.hasOwnProperty("periodType"))
                    $root.perftools.profiles.ValueType.encode(message.periodType, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                if (message.period != null && message.hasOwnProperty("period"))
                    writer.uint32(/* id 12, wireType 0 =*/96).int64(message.period);
                if (message.comment != null && message.comment.length) {
                    writer.uint32(/* id 13, wireType 2 =*/106).fork();
                    for (var i = 0; i < message.comment.length; ++i)
                        writer.int64(message.comment[i]);
                    writer.ldelim();
                }
                if (message.defaultSampleType != null && message.hasOwnProperty("defaultSampleType"))
                    writer.uint32(/* id 14, wireType 0 =*/112).int64(message.defaultSampleType);
                return writer;
            };

            /**
             * Encodes the specified Profile message, length delimited. Does not implicitly {@link perftools.profiles.Profile.verify|verify} messages.
             * @function encodeDelimited
             * @memberof perftools.profiles.Profile
             * @static
             * @param {perftools.profiles.IProfile} message Profile message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Profile.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Profile message from the specified reader or buffer.
             * @function decode
             * @memberof perftools.profiles.Profile
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {perftools.profiles.Profile} Profile
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Profile.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.perftools.profiles.Profile();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.sampleType && message.sampleType.length))
                            message.sampleType = [];
                        message.sampleType.push($root.perftools.profiles.ValueType.decode(reader, reader.uint32()));
                        break;
                    case 2:
                        if (!(message.sample && message.sample.length))
                            message.sample = [];
                        message.sample.push($root.perftools.profiles.Sample.decode(reader, reader.uint32()));
                        break;
                    case 3:
                        if (!(message.mapping && message.mapping.length))
                            message.mapping = [];
                        message.mapping.push($root.perftools.profiles.Mapping.decode(reader, reader.uint32()));
                        break;
                    case 4:
                        if (!(message.location && message.location.length))
                            message.location = [];
                        message.location.push($root.perftools.profiles.Location.decode(reader, reader.uint32()));
                        break;
                    case 5:
                        if (!(message["function"] && message["function"].length))
                            message["function"] = [];
                        message["function"].push($root.perftools.profiles.Function.decode(reader, reader.uint32()));
                        break;
                    case 6:
                        if (!(message.stringTable && message.stringTable.length))
                            message.stringTable = [];
                        message.stringTable.push(reader.string());
                        break;
                    case 7:
                        message.dropFrames = reader.int64();
                        break;
                    case 8:
                        message.keepFrames = reader.int64();
                        break;
                    case 9:
                        message.timeNanos = reader.int64();
                        break;
                    case 10:
                        message.durationNanos = reader.int64();
                        break;
                    case 11:
                        message.periodType = $root.perftools.profiles.ValueType.decode(reader, reader.uint32());
                        break;
                    case 12:
                        message.period = reader.int64();
                        break;
                    case 13:
                        if (!(message.comment && message.comment.length))
                            message.comment = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.comment.push(reader.int64());
                        } else
                            message.comment.push(reader.int64());
                        break;
                    case 14:
                        message.defaultSampleType = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Profile message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof perftools.profiles.Profile
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {perftools.profiles.Profile} Profile
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Profile.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Profile message.
             * @function verify
             * @memberof perftools.profiles.Profile
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Profile.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.sampleType != null && message.hasOwnProperty("sampleType")) {
                    if (!Array.isArray(message.sampleType))
                        return "sampleType: array expected";
                    for (var i = 0; i < message.sampleType.length; ++i) {
                        var error = $root.perftools.profiles.ValueType.verify(message.sampleType[i]);
                        if (error)
                            return "sampleType." + error;
                    }
                }
                if (message.sample != null && message.hasOwnProperty("sample")) {
                    if (!Array.isArray(message.sample))
                        return "sample: array expected";
                    for (var i = 0; i < message.sample.length; ++i) {
                        error = $root.perftools.profiles.Sample.verify(message.sample[i]);
                        if (error)
                            return "sample." + error;
                    }
                }
                if (message.mapping != null && message.hasOwnProperty("mapping")) {
                    if (!Array.isArray(message.mapping))
                        return "mapping: array expected";
                    for (var i = 0; i < message.mapping.length; ++i) {
                        error = $root.perftools.profiles.Mapping.verify(message.mapping[i]);
                        if (error)
                            return "mapping." + error;
                    }
                }
                if (message.location != null && message.hasOwnProperty("location")) {
                    if (!Array.isArray(message.location))
                        return "location: array expected";
                    for (var i = 0; i < message.location.length; ++i) {
                        error = $root.perftools.profiles.Location.verify(message.location[i]);
                        if (error)
                            return "location." + error;
                    }
                }
                if (message["function"] != null && message.hasOwnProperty("function")) {
                    if (!Array.isArray(message["function"]))
                        return "function: array expected";
                    for (var i = 0; i < message["function"].length; ++i) {
                        error = $root.perftools.profiles.Function.verify(message["function"][i]);
                        if (error)
                            return "function." + error;
                    }
                }
                if (message.stringTable != null && message.hasOwnProperty("stringTable")) {
                    if (!Array.isArray(message.stringTable))
                        return "stringTable: array expected";
                    for (var i = 0; i < message.stringTable.length; ++i)
                        if (!$util.isString(message.stringTable[i]))
                            return "stringTable: string[] expected";
                }
                if (message.dropFrames != null && message.hasOwnProperty("dropFrames"))
                    if (!$util.isInteger(message.dropFrames) && !(message.dropFrames && $util.isInteger(message.dropFrames.low) && $util.isInteger(message.dropFrames.high)))
                        return "dropFrames: integer|Long expected";
                if (message.keepFrames != null && message.hasOwnProperty("keepFrames"))
                    if (!$util.isInteger(message.keepFrames) && !(message.keepFrames && $util.isInteger(message.keepFrames.low) && $util.isInteger(message.keepFrames.high)))
                        return "keepFrames: integer|Long expected";
                if (message.timeNanos != null && message.hasOwnProperty("timeNanos"))
                    if (!$util.isInteger(message.timeNanos) && !(message.timeNanos && $util.isInteger(message.timeNanos.low) && $util.isInteger(message.timeNanos.high)))
                        return "timeNanos: integer|Long expected";
                if (message.durationNanos != null && message.hasOwnProperty("durationNanos"))
                    if (!$util.isInteger(message.durationNanos) && !(message.durationNanos && $util.isInteger(message.durationNanos.low) && $util.isInteger(message.durationNanos.high)))
                        return "durationNanos: integer|Long expected";
                if (message.periodType != null && message.hasOwnProperty("periodType")) {
                    error = $root.perftools.profiles.ValueType.verify(message.periodType);
                    if (error)
                        return "periodType." + error;
                }
                if (message.period != null && message.hasOwnProperty("period"))
                    if (!$util.isInteger(message.period) && !(message.period && $util.isInteger(message.period.low) && $util.isInteger(message.period.high)))
                        return "period: integer|Long expected";
                if (message.comment != null && message.hasOwnProperty("comment")) {
                    if (!Array.isArray(message.comment))
                        return "comment: array expected";
                    for (var i = 0; i < message.comment.length; ++i)
                        if (!$util.isInteger(message.comment[i]) && !(message.comment[i] && $util.isInteger(message.comment[i].low) && $util.isInteger(message.comment[i].high)))
                            return "comment: integer|Long[] expected";
                }
                if (message.defaultSampleType != null && message.hasOwnProperty("defaultSampleType"))
                    if (!$util.isInteger(message.defaultSampleType) && !(message.defaultSampleType && $util.isInteger(message.defaultSampleType.low) && $util.isInteger(message.defaultSampleType.high)))
                        return "defaultSampleType: integer|Long expected";
                return null;
            };

            /**
             * Creates a Profile message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof perftools.profiles.Profile
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {perftools.profiles.Profile} Profile
             */
            Profile.fromObject = function fromObject(object) {
                if (object instanceof $root.perftools.profiles.Profile)
                    return object;
                var message = new $root.perftools.profiles.Profile();
                if (object.sampleType) {
                    if (!Array.isArray(object.sampleType))
                        throw TypeError(".perftools.profiles.Profile.sampleType: array expected");
                    message.sampleType = [];
                    for (var i = 0; i < object.sampleType.length; ++i) {
                        if (typeof object.sampleType[i] !== "object")
                            throw TypeError(".perftools.profiles.Profile.sampleType: object expected");
                        message.sampleType[i] = $root.perftools.profiles.ValueType.fromObject(object.sampleType[i]);
                    }
                }
                if (object.sample) {
                    if (!Array.isArray(object.sample))
                        throw TypeError(".perftools.profiles.Profile.sample: array expected");
                    message.sample = [];
                    for (var i = 0; i < object.sample.length; ++i) {
                        if (typeof object.sample[i] !== "object")
                            throw TypeError(".perftools.profiles.Profile.sample: object expected");
                        message.sample[i] = $root.perftools.profiles.Sample.fromObject(object.sample[i]);
                    }
                }
                if (object.mapping) {
                    if (!Array.isArray(object.mapping))
                        throw TypeError(".perftools.profiles.Profile.mapping: array expected");
                    message.mapping = [];
                    for (var i = 0; i < object.mapping.length; ++i) {
                        if (typeof object.mapping[i] !== "object")
                            throw TypeError(".perftools.profiles.Profile.mapping: object expected");
                        message.mapping[i] = $root.perftools.profiles.Mapping.fromObject(object.mapping[i]);
                    }
                }
                if (object.location) {
                    if (!Array.isArray(object.location))
                        throw TypeError(".perftools.profiles.Profile.location: array expected");
                    message.location = [];
                    for (var i = 0; i < object.location.length; ++i) {
                        if (typeof object.location[i] !== "object")
                            throw TypeError(".perftools.profiles.Profile.location: object expected");
                        message.location[i] = $root.perftools.profiles.Location.fromObject(object.location[i]);
                    }
                }
                if (object["function"]) {
                    if (!Array.isArray(object["function"]))
                        throw TypeError(".perftools.profiles.Profile.function: array expected");
                    message["function"] = [];
                    for (var i = 0; i < object["function"].length; ++i) {
                        if (typeof object["function"][i] !== "object")
                            throw TypeError(".perftools.profiles.Profile.function: object expected");
                        message["function"][i] = $root.perftools.profiles.Function.fromObject(object["function"][i]);
                    }
                }
                if (object.stringTable) {
                    if (!Array.isArray(object.stringTable))
                        throw TypeError(".perftools.profiles.Profile.stringTable: array expected");
                    message.stringTable = [];
                    for (var i = 0; i < object.stringTable.length; ++i)
                        message.stringTable[i] = String(object.stringTable[i]);
                }
                if (object.dropFrames != null)
                    if ($util.Long)
                        (message.dropFrames = $util.Long.fromValue(object.dropFrames)).unsigned = false;
                    else if (typeof object.dropFrames === "string")
                        message.dropFrames = parseInt(object.dropFrames, 10);
                    else if (typeof object.dropFrames === "number")
                        message.dropFrames = object.dropFrames;
                    else if (typeof object.dropFrames === "object")
                        message.dropFrames = new $util.LongBits(object.dropFrames.low >>> 0, object.dropFrames.high >>> 0).toNumber();
                if (object.keepFrames != null)
                    if ($util.Long)
                        (message.keepFrames = $util.Long.fromValue(object.keepFrames)).unsigned = false;
                    else if (typeof object.keepFrames === "string")
                        message.keepFrames = parseInt(object.keepFrames, 10);
                    else if (typeof object.keepFrames === "number")
                        message.keepFrames = object.keepFrames;
                    else if (typeof object.keepFrames === "object")
                        message.keepFrames = new $util.LongBits(object.keepFrames.low >>> 0, object.keepFrames.high >>> 0).toNumber();
                if (object.timeNanos != null)
                    if ($util.Long)
                        (message.timeNanos = $util.Long.fromValue(object.timeNanos)).unsigned = false;
                    else if (typeof object.timeNanos === "string")
                        message.timeNanos = parseInt(object.timeNanos, 10);
                    else if (typeof object.timeNanos === "number")
                        message.timeNanos = object.timeNanos;
                    else if (typeof object.timeNanos === "object")
                        message.timeNanos = new $util.LongBits(object.timeNanos.low >>> 0, object.timeNanos.high >>> 0).toNumber();
                if (object.durationNanos != null)
                    if ($util.Long)
                        (message.durationNanos = $util.Long.fromValue(object.durationNanos)).unsigned = false;
                    else if (typeof object.durationNanos === "string")
                        message.durationNanos = parseInt(object.durationNanos, 10);
                    else if (typeof object.durationNanos === "number")
                        message.durationNanos = object.durationNanos;
                    else if (typeof object.durationNanos === "object")
                        message.durationNanos = new $util.LongBits(object.durationNanos.low >>> 0, object.durationNanos.high >>> 0).toNumber();
                if (object.periodType != null) {
                    if (typeof object.periodType !== "object")
                        throw TypeError(".perftools.profiles.Profile.periodType: object expected");
                    message.periodType = $root.perftools.profiles.ValueType.fromObject(object.periodType);
                }
                if (object.period != null)
                    if ($util.Long)
                        (message.period = $util.Long.fromValue(object.period)).unsigned = false;
                    else if (typeof object.period === "string")
                        message.period = parseInt(object.period, 10);
                    else if (typeof object.period === "number")
                        message.period = object.period;
                    else if (typeof object.period === "object")
                        message.period = new $util.LongBits(object.period.low >>> 0, object.period.high >>> 0).toNumber();
                if (object.comment) {
                    if (!Array.isArray(object.comment))
                        throw TypeError(".perftools.profiles.Profile.comment: array expected");
                    message.comment = [];
                    for (var i = 0; i < object.comment.length; ++i)
                        if ($util.Long)
                            (message.comment[i] = $util.Long.fromValue(object.comment[i])).unsigned = false;
                        else if (typeof object.comment[i] === "string")
                            message.comment[i] = parseInt(object.comment[i], 10);
                        else if (typeof object.comment[i] === "number")
                            message.comment[i] = object.comment[i];
                        else if (typeof object.comment[i] === "object")
                            message.comment[i] = new $util.LongBits(object.comment[i].low >>> 0, object.comment[i].high >>> 0).toNumber();
                }
                if (object.defaultSampleType != null)
                    if ($util.Long)
                        (message.defaultSampleType = $util.Long.fromValue(object.defaultSampleType)).unsigned = false;
                    else if (typeof object.defaultSampleType === "string")
                        message.defaultSampleType = parseInt(object.defaultSampleType, 10);
                    else if (typeof object.defaultSampleType === "number")
                        message.defaultSampleType = object.defaultSampleType;
                    else if (typeof object.defaultSampleType === "object")
                        message.defaultSampleType = new $util.LongBits(object.defaultSampleType.low >>> 0, object.defaultSampleType.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a plain object from a Profile message. Also converts values to other types if specified.
             * @function toObject
             * @memberof perftools.profiles.Profile
             * @static
             * @param {perftools.profiles.Profile} message Profile
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Profile.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.sampleType = [];
                    object.sample = [];
                    object.mapping = [];
                    object.location = [];
                    object["function"] = [];
                    object.stringTable = [];
                    object.comment = [];
                }
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.dropFrames = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.dropFrames = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.keepFrames = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.keepFrames = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.timeNanos = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.timeNanos = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.durationNanos = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.durationNanos = options.longs === String ? "0" : 0;
                    object.periodType = null;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.period = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.period = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.defaultSampleType = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.defaultSampleType = options.longs === String ? "0" : 0;
                }
                if (message.sampleType && message.sampleType.length) {
                    object.sampleType = [];
                    for (var j = 0; j < message.sampleType.length; ++j)
                        object.sampleType[j] = $root.perftools.profiles.ValueType.toObject(message.sampleType[j], options);
                }
                if (message.sample && message.sample.length) {
                    object.sample = [];
                    for (var j = 0; j < message.sample.length; ++j)
                        object.sample[j] = $root.perftools.profiles.Sample.toObject(message.sample[j], options);
                }
                if (message.mapping && message.mapping.length) {
                    object.mapping = [];
                    for (var j = 0; j < message.mapping.length; ++j)
                        object.mapping[j] = $root.perftools.profiles.Mapping.toObject(message.mapping[j], options);
                }
                if (message.location && message.location.length) {
                    object.location = [];
                    for (var j = 0; j < message.location.length; ++j)
                        object.location[j] = $root.perftools.profiles.Location.toObject(message.location[j], options);
                }
                if (message["function"] && message["function"].length) {
                    object["function"] = [];
                    for (var j = 0; j < message["function"].length; ++j)
                        object["function"][j] = $root.perftools.profiles.Function.toObject(message["function"][j], options);
                }
                if (message.stringTable && message.stringTable.length) {
                    object.stringTable = [];
                    for (var j = 0; j < message.stringTable.length; ++j)
                        object.stringTable[j] = message.stringTable[j];
                }
                if (message.dropFrames != null && message.hasOwnProperty("dropFrames"))
                    if (typeof message.dropFrames === "number")
                        object.dropFrames = options.longs === String ? String(message.dropFrames) : message.dropFrames;
                    else
                        object.dropFrames = options.longs === String ? $util.Long.prototype.toString.call(message.dropFrames) : options.longs === Number ? new $util.LongBits(message.dropFrames.low >>> 0, message.dropFrames.high >>> 0).toNumber() : message.dropFrames;
                if (message.keepFrames != null && message.hasOwnProperty("keepFrames"))
                    if (typeof message.keepFrames === "number")
                        object.keepFrames = options.longs === String ? String(message.keepFrames) : message.keepFrames;
                    else
                        object.keepFrames = options.longs === String ? $util.Long.prototype.toString.call(message.keepFrames) : options.longs === Number ? new $util.LongBits(message.keepFrames.low >>> 0, message.keepFrames.high >>> 0).toNumber() : message.keepFrames;
                if (message.timeNanos != null && message.hasOwnProperty("timeNanos"))
                    if (typeof message.timeNanos === "number")
                        object.timeNanos = options.longs === String ? String(message.timeNanos) : message.timeNanos;
                    else
                        object.timeNanos = options.longs === String ? $util.Long.prototype.toString.call(message.timeNanos) : options.longs === Number ? new $util.LongBits(message.timeNanos.low >>> 0, message.timeNanos.high >>> 0).toNumber() : message.timeNanos;
                if (message.durationNanos != null && message.hasOwnProperty("durationNanos"))
                    if (typeof message.durationNanos === "number")
                        object.durationNanos = options.longs === String ? String(message.durationNanos) : message.durationNanos;
                    else
                        object.durationNanos = options.longs === String ? $util.Long.prototype.toString.call(message.durationNanos) : options.longs === Number ? new $util.LongBits(message.durationNanos.low >>> 0, message.durationNanos.high >>> 0).toNumber() : message.durationNanos;
                if (message.periodType != null && message.hasOwnProperty("periodType"))
                    object.periodType = $root.perftools.profiles.ValueType.toObject(message.periodType, options);
                if (message.period != null && message.hasOwnProperty("period"))
                    if (typeof message.period === "number")
                        object.period = options.longs === String ? String(message.period) : message.period;
                    else
                        object.period = options.longs === String ? $util.Long.prototype.toString.call(message.period) : options.longs === Number ? new $util.LongBits(message.period.low >>> 0, message.period.high >>> 0).toNumber() : message.period;
                if (message.comment && message.comment.length) {
                    object.comment = [];
                    for (var j = 0; j < message.comment.length; ++j)
                        if (typeof message.comment[j] === "number")
                            object.comment[j] = options.longs === String ? String(message.comment[j]) : message.comment[j];
                        else
                            object.comment[j] = options.longs === String ? $util.Long.prototype.toString.call(message.comment[j]) : options.longs === Number ? new $util.LongBits(message.comment[j].low >>> 0, message.comment[j].high >>> 0).toNumber() : message.comment[j];
                }
                if (message.defaultSampleType != null && message.hasOwnProperty("defaultSampleType"))
                    if (typeof message.defaultSampleType === "number")
                        object.defaultSampleType = options.longs === String ? String(message.defaultSampleType) : message.defaultSampleType;
                    else
                        object.defaultSampleType = options.longs === String ? $util.Long.prototype.toString.call(message.defaultSampleType) : options.longs === Number ? new $util.LongBits(message.defaultSampleType.low >>> 0, message.defaultSampleType.high >>> 0).toNumber() : message.defaultSampleType;
                return object;
            };

            /**
             * Converts this Profile to JSON.
             * @function toJSON
             * @memberof perftools.profiles.Profile
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Profile.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Profile;
        })();

        profiles.ValueType = (function() {

            /**
             * Properties of a ValueType.
             * @memberof perftools.profiles
             * @interface IValueType
             * @property {number|Long} [type] ValueType type
             * @property {number|Long} [unit] ValueType unit
             */

            /**
             * Constructs a new ValueType.
             * @memberof perftools.profiles
             * @classdesc Represents a ValueType.
             * @constructor
             * @param {perftools.profiles.IValueType=} [properties] Properties to set
             */
            function ValueType(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ValueType type.
             * @member {number|Long}type
             * @memberof perftools.profiles.ValueType
             * @instance
             */
            ValueType.prototype.type = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * ValueType unit.
             * @member {number|Long}unit
             * @memberof perftools.profiles.ValueType
             * @instance
             */
            ValueType.prototype.unit = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new ValueType instance using the specified properties.
             * @function create
             * @memberof perftools.profiles.ValueType
             * @static
             * @param {perftools.profiles.IValueType=} [properties] Properties to set
             * @returns {perftools.profiles.ValueType} ValueType instance
             */
            ValueType.create = function create(properties) {
                return new ValueType(properties);
            };

            /**
             * Encodes the specified ValueType message. Does not implicitly {@link perftools.profiles.ValueType.verify|verify} messages.
             * @function encode
             * @memberof perftools.profiles.ValueType
             * @static
             * @param {perftools.profiles.IValueType} message ValueType message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ValueType.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.type != null && message.hasOwnProperty("type"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.type);
                if (message.unit != null && message.hasOwnProperty("unit"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.unit);
                return writer;
            };

            /**
             * Encodes the specified ValueType message, length delimited. Does not implicitly {@link perftools.profiles.ValueType.verify|verify} messages.
             * @function encodeDelimited
             * @memberof perftools.profiles.ValueType
             * @static
             * @param {perftools.profiles.IValueType} message ValueType message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ValueType.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ValueType message from the specified reader or buffer.
             * @function decode
             * @memberof perftools.profiles.ValueType
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {perftools.profiles.ValueType} ValueType
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ValueType.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.perftools.profiles.ValueType();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.type = reader.int64();
                        break;
                    case 2:
                        message.unit = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ValueType message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof perftools.profiles.ValueType
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {perftools.profiles.ValueType} ValueType
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ValueType.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ValueType message.
             * @function verify
             * @memberof perftools.profiles.ValueType
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ValueType.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    if (!$util.isInteger(message.type) && !(message.type && $util.isInteger(message.type.low) && $util.isInteger(message.type.high)))
                        return "type: integer|Long expected";
                if (message.unit != null && message.hasOwnProperty("unit"))
                    if (!$util.isInteger(message.unit) && !(message.unit && $util.isInteger(message.unit.low) && $util.isInteger(message.unit.high)))
                        return "unit: integer|Long expected";
                return null;
            };

            /**
             * Creates a ValueType message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof perftools.profiles.ValueType
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {perftools.profiles.ValueType} ValueType
             */
            ValueType.fromObject = function fromObject(object) {
                if (object instanceof $root.perftools.profiles.ValueType)
                    return object;
                var message = new $root.perftools.profiles.ValueType();
                if (object.type != null)
                    if ($util.Long)
                        (message.type = $util.Long.fromValue(object.type)).unsigned = false;
                    else if (typeof object.type === "string")
                        message.type = parseInt(object.type, 10);
                    else if (typeof object.type === "number")
                        message.type = object.type;
                    else if (typeof object.type === "object")
                        message.type = new $util.LongBits(object.type.low >>> 0, object.type.high >>> 0).toNumber();
                if (object.unit != null)
                    if ($util.Long)
                        (message.unit = $util.Long.fromValue(object.unit)).unsigned = false;
                    else if (typeof object.unit === "string")
                        message.unit = parseInt(object.unit, 10);
                    else if (typeof object.unit === "number")
                        message.unit = object.unit;
                    else if (typeof object.unit === "object")
                        message.unit = new $util.LongBits(object.unit.low >>> 0, object.unit.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a plain object from a ValueType message. Also converts values to other types if specified.
             * @function toObject
             * @memberof perftools.profiles.ValueType
             * @static
             * @param {perftools.profiles.ValueType} message ValueType
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ValueType.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.type = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.type = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.unit = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.unit = options.longs === String ? "0" : 0;
                }
                if (message.type != null && message.hasOwnProperty("type"))
                    if (typeof message.type === "number")
                        object.type = options.longs === String ? String(message.type) : message.type;
                    else
                        object.type = options.longs === String ? $util.Long.prototype.toString.call(message.type) : options.longs === Number ? new $util.LongBits(message.type.low >>> 0, message.type.high >>> 0).toNumber() : message.type;
                if (message.unit != null && message.hasOwnProperty("unit"))
                    if (typeof message.unit === "number")
                        object.unit = options.longs === String ? String(message.unit) : message.unit;
                    else
                        object.unit = options.longs === String ? $util.Long.prototype.toString.call(message.unit) : options.longs === Number ? new $util.LongBits(message.unit.low >>> 0, message.unit.high >>> 0).toNumber() : message.unit;
                return object;
            };

            /**
             * Converts this ValueType to JSON.
             * @function toJSON
             * @memberof perftools.profiles.ValueType
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ValueType.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ValueType;
        })();

        profiles.Sample = (function() {

            /**
             * Properties of a Sample.
             * @memberof perftools.profiles
             * @interface ISample
             * @property {Array.<number|Long>} [locationId] Sample locationId
             * @property {Array.<number|Long>} [value] Sample value
             * @property {Array.<perftools.profiles.ILabel>} [label] Sample label
             */

            /**
             * Constructs a new Sample.
             * @memberof perftools.profiles
             * @classdesc Represents a Sample.
             * @constructor
             * @param {perftools.profiles.ISample=} [properties] Properties to set
             */
            function Sample(properties) {
                this.locationId = [];
                this.value = [];
                this.label = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Sample locationId.
             * @member {Array.<number|Long>}locationId
             * @memberof perftools.profiles.Sample
             * @instance
             */
            Sample.prototype.locationId = $util.emptyArray;

            /**
             * Sample value.
             * @member {Array.<number|Long>}value
             * @memberof perftools.profiles.Sample
             * @instance
             */
            Sample.prototype.value = $util.emptyArray;

            /**
             * Sample label.
             * @member {Array.<perftools.profiles.ILabel>}label
             * @memberof perftools.profiles.Sample
             * @instance
             */
            Sample.prototype.label = $util.emptyArray;

            /**
             * Creates a new Sample instance using the specified properties.
             * @function create
             * @memberof perftools.profiles.Sample
             * @static
             * @param {perftools.profiles.ISample=} [properties] Properties to set
             * @returns {perftools.profiles.Sample} Sample instance
             */
            Sample.create = function create(properties) {
                return new Sample(properties);
            };

            /**
             * Encodes the specified Sample message. Does not implicitly {@link perftools.profiles.Sample.verify|verify} messages.
             * @function encode
             * @memberof perftools.profiles.Sample
             * @static
             * @param {perftools.profiles.ISample} message Sample message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Sample.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.locationId != null && message.locationId.length) {
                    writer.uint32(/* id 1, wireType 2 =*/10).fork();
                    for (var i = 0; i < message.locationId.length; ++i)
                        writer.uint64(message.locationId[i]);
                    writer.ldelim();
                }
                if (message.value != null && message.value.length) {
                    writer.uint32(/* id 2, wireType 2 =*/18).fork();
                    for (var i = 0; i < message.value.length; ++i)
                        writer.int64(message.value[i]);
                    writer.ldelim();
                }
                if (message.label != null && message.label.length)
                    for (var i = 0; i < message.label.length; ++i)
                        $root.perftools.profiles.Label.encode(message.label[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Sample message, length delimited. Does not implicitly {@link perftools.profiles.Sample.verify|verify} messages.
             * @function encodeDelimited
             * @memberof perftools.profiles.Sample
             * @static
             * @param {perftools.profiles.ISample} message Sample message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Sample.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Sample message from the specified reader or buffer.
             * @function decode
             * @memberof perftools.profiles.Sample
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {perftools.profiles.Sample} Sample
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Sample.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.perftools.profiles.Sample();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.locationId && message.locationId.length))
                            message.locationId = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.locationId.push(reader.uint64());
                        } else
                            message.locationId.push(reader.uint64());
                        break;
                    case 2:
                        if (!(message.value && message.value.length))
                            message.value = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.value.push(reader.int64());
                        } else
                            message.value.push(reader.int64());
                        break;
                    case 3:
                        if (!(message.label && message.label.length))
                            message.label = [];
                        message.label.push($root.perftools.profiles.Label.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Sample message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof perftools.profiles.Sample
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {perftools.profiles.Sample} Sample
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Sample.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Sample message.
             * @function verify
             * @memberof perftools.profiles.Sample
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Sample.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.locationId != null && message.hasOwnProperty("locationId")) {
                    if (!Array.isArray(message.locationId))
                        return "locationId: array expected";
                    for (var i = 0; i < message.locationId.length; ++i)
                        if (!$util.isInteger(message.locationId[i]) && !(message.locationId[i] && $util.isInteger(message.locationId[i].low) && $util.isInteger(message.locationId[i].high)))
                            return "locationId: integer|Long[] expected";
                }
                if (message.value != null && message.hasOwnProperty("value")) {
                    if (!Array.isArray(message.value))
                        return "value: array expected";
                    for (var i = 0; i < message.value.length; ++i)
                        if (!$util.isInteger(message.value[i]) && !(message.value[i] && $util.isInteger(message.value[i].low) && $util.isInteger(message.value[i].high)))
                            return "value: integer|Long[] expected";
                }
                if (message.label != null && message.hasOwnProperty("label")) {
                    if (!Array.isArray(message.label))
                        return "label: array expected";
                    for (var i = 0; i < message.label.length; ++i) {
                        var error = $root.perftools.profiles.Label.verify(message.label[i]);
                        if (error)
                            return "label." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a Sample message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof perftools.profiles.Sample
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {perftools.profiles.Sample} Sample
             */
            Sample.fromObject = function fromObject(object) {
                if (object instanceof $root.perftools.profiles.Sample)
                    return object;
                var message = new $root.perftools.profiles.Sample();
                if (object.locationId) {
                    if (!Array.isArray(object.locationId))
                        throw TypeError(".perftools.profiles.Sample.locationId: array expected");
                    message.locationId = [];
                    for (var i = 0; i < object.locationId.length; ++i)
                        if ($util.Long)
                            (message.locationId[i] = $util.Long.fromValue(object.locationId[i])).unsigned = true;
                        else if (typeof object.locationId[i] === "string")
                            message.locationId[i] = parseInt(object.locationId[i], 10);
                        else if (typeof object.locationId[i] === "number")
                            message.locationId[i] = object.locationId[i];
                        else if (typeof object.locationId[i] === "object")
                            message.locationId[i] = new $util.LongBits(object.locationId[i].low >>> 0, object.locationId[i].high >>> 0).toNumber(true);
                }
                if (object.value) {
                    if (!Array.isArray(object.value))
                        throw TypeError(".perftools.profiles.Sample.value: array expected");
                    message.value = [];
                    for (var i = 0; i < object.value.length; ++i)
                        if ($util.Long)
                            (message.value[i] = $util.Long.fromValue(object.value[i])).unsigned = false;
                        else if (typeof object.value[i] === "string")
                            message.value[i] = parseInt(object.value[i], 10);
                        else if (typeof object.value[i] === "number")
                            message.value[i] = object.value[i];
                        else if (typeof object.value[i] === "object")
                            message.value[i] = new $util.LongBits(object.value[i].low >>> 0, object.value[i].high >>> 0).toNumber();
                }
                if (object.label) {
                    if (!Array.isArray(object.label))
                        throw TypeError(".perftools.profiles.Sample.label: array expected");
                    message.label = [];
                    for (var i = 0; i < object.label.length; ++i) {
                        if (typeof object.label[i] !== "object")
                            throw TypeError(".perftools.profiles.Sample.label: object expected");
                        message.label[i] = $root.perftools.profiles.Label.fromObject(object.label[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a Sample message. Also converts values to other types if specified.
             * @function toObject
             * @memberof perftools.profiles.Sample
             * @static
             * @param {perftools.profiles.Sample} message Sample
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Sample.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.locationId = [];
                    object.value = [];
                    object.label = [];
                }
                if (message.locationId && message.locationId.length) {
                    object.locationId = [];
                    for (var j = 0; j < message.locationId.length; ++j)
                        if (typeof message.locationId[j] === "number")
                            object.locationId[j] = options.longs === String ? String(message.locationId[j]) : message.locationId[j];
                        else
                            object.locationId[j] = options.longs === String ? $util.Long.prototype.toString.call(message.locationId[j]) : options.longs === Number ? new $util.LongBits(message.locationId[j].low >>> 0, message.locationId[j].high >>> 0).toNumber(true) : message.locationId[j];
                }
                if (message.value && message.value.length) {
                    object.value = [];
                    for (var j = 0; j < message.value.length; ++j)
                        if (typeof message.value[j] === "number")
                            object.value[j] = options.longs === String ? String(message.value[j]) : message.value[j];
                        else
                            object.value[j] = options.longs === String ? $util.Long.prototype.toString.call(message.value[j]) : options.longs === Number ? new $util.LongBits(message.value[j].low >>> 0, message.value[j].high >>> 0).toNumber() : message.value[j];
                }
                if (message.label && message.label.length) {
                    object.label = [];
                    for (var j = 0; j < message.label.length; ++j)
                        object.label[j] = $root.perftools.profiles.Label.toObject(message.label[j], options);
                }
                return object;
            };

            /**
             * Converts this Sample to JSON.
             * @function toJSON
             * @memberof perftools.profiles.Sample
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Sample.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Sample;
        })();

        profiles.Label = (function() {

            /**
             * Properties of a Label.
             * @memberof perftools.profiles
             * @interface ILabel
             * @property {number|Long} [key] Label key
             * @property {number|Long} [str] Label str
             * @property {number|Long} [num] Label num
             * @property {number|Long} [numUnit] Label numUnit
             */

            /**
             * Constructs a new Label.
             * @memberof perftools.profiles
             * @classdesc Represents a Label.
             * @constructor
             * @param {perftools.profiles.ILabel=} [properties] Properties to set
             */
            function Label(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Label key.
             * @member {number|Long}key
             * @memberof perftools.profiles.Label
             * @instance
             */
            Label.prototype.key = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Label str.
             * @member {number|Long}str
             * @memberof perftools.profiles.Label
             * @instance
             */
            Label.prototype.str = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Label num.
             * @member {number|Long}num
             * @memberof perftools.profiles.Label
             * @instance
             */
            Label.prototype.num = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Label numUnit.
             * @member {number|Long}numUnit
             * @memberof perftools.profiles.Label
             * @instance
             */
            Label.prototype.numUnit = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new Label instance using the specified properties.
             * @function create
             * @memberof perftools.profiles.Label
             * @static
             * @param {perftools.profiles.ILabel=} [properties] Properties to set
             * @returns {perftools.profiles.Label} Label instance
             */
            Label.create = function create(properties) {
                return new Label(properties);
            };

            /**
             * Encodes the specified Label message. Does not implicitly {@link perftools.profiles.Label.verify|verify} messages.
             * @function encode
             * @memberof perftools.profiles.Label
             * @static
             * @param {perftools.profiles.ILabel} message Label message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Label.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.key != null && message.hasOwnProperty("key"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.key);
                if (message.str != null && message.hasOwnProperty("str"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.str);
                if (message.num != null && message.hasOwnProperty("num"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int64(message.num);
                if (message.numUnit != null && message.hasOwnProperty("numUnit"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int64(message.numUnit);
                return writer;
            };

            /**
             * Encodes the specified Label message, length delimited. Does not implicitly {@link perftools.profiles.Label.verify|verify} messages.
             * @function encodeDelimited
             * @memberof perftools.profiles.Label
             * @static
             * @param {perftools.profiles.ILabel} message Label message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Label.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Label message from the specified reader or buffer.
             * @function decode
             * @memberof perftools.profiles.Label
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {perftools.profiles.Label} Label
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Label.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.perftools.profiles.Label();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.key = reader.int64();
                        break;
                    case 2:
                        message.str = reader.int64();
                        break;
                    case 3:
                        message.num = reader.int64();
                        break;
                    case 4:
                        message.numUnit = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Label message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof perftools.profiles.Label
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {perftools.profiles.Label} Label
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Label.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Label message.
             * @function verify
             * @memberof perftools.profiles.Label
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Label.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.key != null && message.hasOwnProperty("key"))
                    if (!$util.isInteger(message.key) && !(message.key && $util.isInteger(message.key.low) && $util.isInteger(message.key.high)))
                        return "key: integer|Long expected";
                if (message.str != null && message.hasOwnProperty("str"))
                    if (!$util.isInteger(message.str) && !(message.str && $util.isInteger(message.str.low) && $util.isInteger(message.str.high)))
                        return "str: integer|Long expected";
                if (message.num != null && message.hasOwnProperty("num"))
                    if (!$util.isInteger(message.num) && !(message.num && $util.isInteger(message.num.low) && $util.isInteger(message.num.high)))
                        return "num: integer|Long expected";
                if (message.numUnit != null && message.hasOwnProperty("numUnit"))
                    if (!$util.isInteger(message.numUnit) && !(message.numUnit && $util.isInteger(message.numUnit.low) && $util.isInteger(message.numUnit.high)))
                        return "numUnit: integer|Long expected";
                return null;
            };

            /**
             * Creates a Label message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof perftools.profiles.Label
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {perftools.profiles.Label} Label
             */
            Label.fromObject = function fromObject(object) {
                if (object instanceof $root.perftools.profiles.Label)
                    return object;
                var message = new $root.perftools.profiles.Label();
                if (object.key != null)
                    if ($util.Long)
                        (message.key = $util.Long.fromValue(object.key)).unsigned = false;
                    else if (typeof object.key === "string")
                        message.key = parseInt(object.key, 10);
                    else if (typeof object.key === "number")
                        message.key = object.key;
                    else if (typeof object.key === "object")
                        message.key = new $util.LongBits(object.key.low >>> 0, object.key.high >>> 0).toNumber();
                if (object.str != null)
                    if ($util.Long)
                        (message.str = $util.Long.fromValue(object.str)).unsigned = false;
                    else if (typeof object.str === "string")
                        message.str = parseInt(object.str, 10);
                    else if (typeof object.str === "number")
                        message.str = object.str;
                    else if (typeof object.str === "object")
                        message.str = new $util.LongBits(object.str.low >>> 0, object.str.high >>> 0).toNumber();
                if (object.num != null)
                    if ($util.Long)
                        (message.num = $util.Long.fromValue(object.num)).unsigned = false;
                    else if (typeof object.num === "string")
                        message.num = parseInt(object.num, 10);
                    else if (typeof object.num === "number")
                        message.num = object.num;
                    else if (typeof object.num === "object")
                        message.num = new $util.LongBits(object.num.low >>> 0, object.num.high >>> 0).toNumber();
                if (object.numUnit != null)
                    if ($util.Long)
                        (message.numUnit = $util.Long.fromValue(object.numUnit)).unsigned = false;
                    else if (typeof object.numUnit === "string")
                        message.numUnit = parseInt(object.numUnit, 10);
                    else if (typeof object.numUnit === "number")
                        message.numUnit = object.numUnit;
                    else if (typeof object.numUnit === "object")
                        message.numUnit = new $util.LongBits(object.numUnit.low >>> 0, object.numUnit.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a plain object from a Label message. Also converts values to other types if specified.
             * @function toObject
             * @memberof perftools.profiles.Label
             * @static
             * @param {perftools.profiles.Label} message Label
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Label.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.key = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.key = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.str = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.str = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.num = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.num = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.numUnit = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.numUnit = options.longs === String ? "0" : 0;
                }
                if (message.key != null && message.hasOwnProperty("key"))
                    if (typeof message.key === "number")
                        object.key = options.longs === String ? String(message.key) : message.key;
                    else
                        object.key = options.longs === String ? $util.Long.prototype.toString.call(message.key) : options.longs === Number ? new $util.LongBits(message.key.low >>> 0, message.key.high >>> 0).toNumber() : message.key;
                if (message.str != null && message.hasOwnProperty("str"))
                    if (typeof message.str === "number")
                        object.str = options.longs === String ? String(message.str) : message.str;
                    else
                        object.str = options.longs === String ? $util.Long.prototype.toString.call(message.str) : options.longs === Number ? new $util.LongBits(message.str.low >>> 0, message.str.high >>> 0).toNumber() : message.str;
                if (message.num != null && message.hasOwnProperty("num"))
                    if (typeof message.num === "number")
                        object.num = options.longs === String ? String(message.num) : message.num;
                    else
                        object.num = options.longs === String ? $util.Long.prototype.toString.call(message.num) : options.longs === Number ? new $util.LongBits(message.num.low >>> 0, message.num.high >>> 0).toNumber() : message.num;
                if (message.numUnit != null && message.hasOwnProperty("numUnit"))
                    if (typeof message.numUnit === "number")
                        object.numUnit = options.longs === String ? String(message.numUnit) : message.numUnit;
                    else
                        object.numUnit = options.longs === String ? $util.Long.prototype.toString.call(message.numUnit) : options.longs === Number ? new $util.LongBits(message.numUnit.low >>> 0, message.numUnit.high >>> 0).toNumber() : message.numUnit;
                return object;
            };

            /**
             * Converts this Label to JSON.
             * @function toJSON
             * @memberof perftools.profiles.Label
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Label.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Label;
        })();

        profiles.Mapping = (function() {

            /**
             * Properties of a Mapping.
             * @memberof perftools.profiles
             * @interface IMapping
             * @property {number|Long} [id] Mapping id
             * @property {number|Long} [memoryStart] Mapping memoryStart
             * @property {number|Long} [memoryLimit] Mapping memoryLimit
             * @property {number|Long} [fileOffset] Mapping fileOffset
             * @property {number|Long} [filename] Mapping filename
             * @property {number|Long} [buildId] Mapping buildId
             * @property {boolean} [hasFunctions] Mapping hasFunctions
             * @property {boolean} [hasFilenames] Mapping hasFilenames
             * @property {boolean} [hasLineNumbers] Mapping hasLineNumbers
             * @property {boolean} [hasInlineFrames] Mapping hasInlineFrames
             */

            /**
             * Constructs a new Mapping.
             * @memberof perftools.profiles
             * @classdesc Represents a Mapping.
             * @constructor
             * @param {perftools.profiles.IMapping=} [properties] Properties to set
             */
            function Mapping(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Mapping id.
             * @member {number|Long}id
             * @memberof perftools.profiles.Mapping
             * @instance
             */
            Mapping.prototype.id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Mapping memoryStart.
             * @member {number|Long}memoryStart
             * @memberof perftools.profiles.Mapping
             * @instance
             */
            Mapping.prototype.memoryStart = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Mapping memoryLimit.
             * @member {number|Long}memoryLimit
             * @memberof perftools.profiles.Mapping
             * @instance
             */
            Mapping.prototype.memoryLimit = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Mapping fileOffset.
             * @member {number|Long}fileOffset
             * @memberof perftools.profiles.Mapping
             * @instance
             */
            Mapping.prototype.fileOffset = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Mapping filename.
             * @member {number|Long}filename
             * @memberof perftools.profiles.Mapping
             * @instance
             */
            Mapping.prototype.filename = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Mapping buildId.
             * @member {number|Long}buildId
             * @memberof perftools.profiles.Mapping
             * @instance
             */
            Mapping.prototype.buildId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Mapping hasFunctions.
             * @member {boolean}hasFunctions
             * @memberof perftools.profiles.Mapping
             * @instance
             */
            Mapping.prototype.hasFunctions = false;

            /**
             * Mapping hasFilenames.
             * @member {boolean}hasFilenames
             * @memberof perftools.profiles.Mapping
             * @instance
             */
            Mapping.prototype.hasFilenames = false;

            /**
             * Mapping hasLineNumbers.
             * @member {boolean}hasLineNumbers
             * @memberof perftools.profiles.Mapping
             * @instance
             */
            Mapping.prototype.hasLineNumbers = false;

            /**
             * Mapping hasInlineFrames.
             * @member {boolean}hasInlineFrames
             * @memberof perftools.profiles.Mapping
             * @instance
             */
            Mapping.prototype.hasInlineFrames = false;

            /**
             * Creates a new Mapping instance using the specified properties.
             * @function create
             * @memberof perftools.profiles.Mapping
             * @static
             * @param {perftools.profiles.IMapping=} [properties] Properties to set
             * @returns {perftools.profiles.Mapping} Mapping instance
             */
            Mapping.create = function create(properties) {
                return new Mapping(properties);
            };

            /**
             * Encodes the specified Mapping message. Does not implicitly {@link perftools.profiles.Mapping.verify|verify} messages.
             * @function encode
             * @memberof perftools.profiles.Mapping
             * @static
             * @param {perftools.profiles.IMapping} message Mapping message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Mapping.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && message.hasOwnProperty("id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.id);
                if (message.memoryStart != null && message.hasOwnProperty("memoryStart"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.memoryStart);
                if (message.memoryLimit != null && message.hasOwnProperty("memoryLimit"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.memoryLimit);
                if (message.fileOffset != null && message.hasOwnProperty("fileOffset"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.fileOffset);
                if (message.filename != null && message.hasOwnProperty("filename"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int64(message.filename);
                if (message.buildId != null && message.hasOwnProperty("buildId"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int64(message.buildId);
                if (message.hasFunctions != null && message.hasOwnProperty("hasFunctions"))
                    writer.uint32(/* id 7, wireType 0 =*/56).bool(message.hasFunctions);
                if (message.hasFilenames != null && message.hasOwnProperty("hasFilenames"))
                    writer.uint32(/* id 8, wireType 0 =*/64).bool(message.hasFilenames);
                if (message.hasLineNumbers != null && message.hasOwnProperty("hasLineNumbers"))
                    writer.uint32(/* id 9, wireType 0 =*/72).bool(message.hasLineNumbers);
                if (message.hasInlineFrames != null && message.hasOwnProperty("hasInlineFrames"))
                    writer.uint32(/* id 10, wireType 0 =*/80).bool(message.hasInlineFrames);
                return writer;
            };

            /**
             * Encodes the specified Mapping message, length delimited. Does not implicitly {@link perftools.profiles.Mapping.verify|verify} messages.
             * @function encodeDelimited
             * @memberof perftools.profiles.Mapping
             * @static
             * @param {perftools.profiles.IMapping} message Mapping message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Mapping.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Mapping message from the specified reader or buffer.
             * @function decode
             * @memberof perftools.profiles.Mapping
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {perftools.profiles.Mapping} Mapping
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Mapping.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.perftools.profiles.Mapping();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = reader.uint64();
                        break;
                    case 2:
                        message.memoryStart = reader.uint64();
                        break;
                    case 3:
                        message.memoryLimit = reader.uint64();
                        break;
                    case 4:
                        message.fileOffset = reader.uint64();
                        break;
                    case 5:
                        message.filename = reader.int64();
                        break;
                    case 6:
                        message.buildId = reader.int64();
                        break;
                    case 7:
                        message.hasFunctions = reader.bool();
                        break;
                    case 8:
                        message.hasFilenames = reader.bool();
                        break;
                    case 9:
                        message.hasLineNumbers = reader.bool();
                        break;
                    case 10:
                        message.hasInlineFrames = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Mapping message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof perftools.profiles.Mapping
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {perftools.profiles.Mapping} Mapping
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Mapping.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Mapping message.
             * @function verify
             * @memberof perftools.profiles.Mapping
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Mapping.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                        return "id: integer|Long expected";
                if (message.memoryStart != null && message.hasOwnProperty("memoryStart"))
                    if (!$util.isInteger(message.memoryStart) && !(message.memoryStart && $util.isInteger(message.memoryStart.low) && $util.isInteger(message.memoryStart.high)))
                        return "memoryStart: integer|Long expected";
                if (message.memoryLimit != null && message.hasOwnProperty("memoryLimit"))
                    if (!$util.isInteger(message.memoryLimit) && !(message.memoryLimit && $util.isInteger(message.memoryLimit.low) && $util.isInteger(message.memoryLimit.high)))
                        return "memoryLimit: integer|Long expected";
                if (message.fileOffset != null && message.hasOwnProperty("fileOffset"))
                    if (!$util.isInteger(message.fileOffset) && !(message.fileOffset && $util.isInteger(message.fileOffset.low) && $util.isInteger(message.fileOffset.high)))
                        return "fileOffset: integer|Long expected";
                if (message.filename != null && message.hasOwnProperty("filename"))
                    if (!$util.isInteger(message.filename) && !(message.filename && $util.isInteger(message.filename.low) && $util.isInteger(message.filename.high)))
                        return "filename: integer|Long expected";
                if (message.buildId != null && message.hasOwnProperty("buildId"))
                    if (!$util.isInteger(message.buildId) && !(message.buildId && $util.isInteger(message.buildId.low) && $util.isInteger(message.buildId.high)))
                        return "buildId: integer|Long expected";
                if (message.hasFunctions != null && message.hasOwnProperty("hasFunctions"))
                    if (typeof message.hasFunctions !== "boolean")
                        return "hasFunctions: boolean expected";
                if (message.hasFilenames != null && message.hasOwnProperty("hasFilenames"))
                    if (typeof message.hasFilenames !== "boolean")
                        return "hasFilenames: boolean expected";
                if (message.hasLineNumbers != null && message.hasOwnProperty("hasLineNumbers"))
                    if (typeof message.hasLineNumbers !== "boolean")
                        return "hasLineNumbers: boolean expected";
                if (message.hasInlineFrames != null && message.hasOwnProperty("hasInlineFrames"))
                    if (typeof message.hasInlineFrames !== "boolean")
                        return "hasInlineFrames: boolean expected";
                return null;
            };

            /**
             * Creates a Mapping message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof perftools.profiles.Mapping
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {perftools.profiles.Mapping} Mapping
             */
            Mapping.fromObject = function fromObject(object) {
                if (object instanceof $root.perftools.profiles.Mapping)
                    return object;
                var message = new $root.perftools.profiles.Mapping();
                if (object.id != null)
                    if ($util.Long)
                        (message.id = $util.Long.fromValue(object.id)).unsigned = true;
                    else if (typeof object.id === "string")
                        message.id = parseInt(object.id, 10);
                    else if (typeof object.id === "number")
                        message.id = object.id;
                    else if (typeof object.id === "object")
                        message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);
                if (object.memoryStart != null)
                    if ($util.Long)
                        (message.memoryStart = $util.Long.fromValue(object.memoryStart)).unsigned = true;
                    else if (typeof object.memoryStart === "string")
                        message.memoryStart = parseInt(object.memoryStart, 10);
                    else if (typeof object.memoryStart === "number")
                        message.memoryStart = object.memoryStart;
                    else if (typeof object.memoryStart === "object")
                        message.memoryStart = new $util.LongBits(object.memoryStart.low >>> 0, object.memoryStart.high >>> 0).toNumber(true);
                if (object.memoryLimit != null)
                    if ($util.Long)
                        (message.memoryLimit = $util.Long.fromValue(object.memoryLimit)).unsigned = true;
                    else if (typeof object.memoryLimit === "string")
                        message.memoryLimit = parseInt(object.memoryLimit, 10);
                    else if (typeof object.memoryLimit === "number")
                        message.memoryLimit = object.memoryLimit;
                    else if (typeof object.memoryLimit === "object")
                        message.memoryLimit = new $util.LongBits(object.memoryLimit.low >>> 0, object.memoryLimit.high >>> 0).toNumber(true);
                if (object.fileOffset != null)
                    if ($util.Long)
                        (message.fileOffset = $util.Long.fromValue(object.fileOffset)).unsigned = true;
                    else if (typeof object.fileOffset === "string")
                        message.fileOffset = parseInt(object.fileOffset, 10);
                    else if (typeof object.fileOffset === "number")
                        message.fileOffset = object.fileOffset;
                    else if (typeof object.fileOffset === "object")
                        message.fileOffset = new $util.LongBits(object.fileOffset.low >>> 0, object.fileOffset.high >>> 0).toNumber(true);
                if (object.filename != null)
                    if ($util.Long)
                        (message.filename = $util.Long.fromValue(object.filename)).unsigned = false;
                    else if (typeof object.filename === "string")
                        message.filename = parseInt(object.filename, 10);
                    else if (typeof object.filename === "number")
                        message.filename = object.filename;
                    else if (typeof object.filename === "object")
                        message.filename = new $util.LongBits(object.filename.low >>> 0, object.filename.high >>> 0).toNumber();
                if (object.buildId != null)
                    if ($util.Long)
                        (message.buildId = $util.Long.fromValue(object.buildId)).unsigned = false;
                    else if (typeof object.buildId === "string")
                        message.buildId = parseInt(object.buildId, 10);
                    else if (typeof object.buildId === "number")
                        message.buildId = object.buildId;
                    else if (typeof object.buildId === "object")
                        message.buildId = new $util.LongBits(object.buildId.low >>> 0, object.buildId.high >>> 0).toNumber();
                if (object.hasFunctions != null)
                    message.hasFunctions = Boolean(object.hasFunctions);
                if (object.hasFilenames != null)
                    message.hasFilenames = Boolean(object.hasFilenames);
                if (object.hasLineNumbers != null)
                    message.hasLineNumbers = Boolean(object.hasLineNumbers);
                if (object.hasInlineFrames != null)
                    message.hasInlineFrames = Boolean(object.hasInlineFrames);
                return message;
            };

            /**
             * Creates a plain object from a Mapping message. Also converts values to other types if specified.
             * @function toObject
             * @memberof perftools.profiles.Mapping
             * @static
             * @param {perftools.profiles.Mapping} message Mapping
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Mapping.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.id = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.memoryStart = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.memoryStart = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.memoryLimit = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.memoryLimit = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.fileOffset = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.fileOffset = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.filename = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.filename = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.buildId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.buildId = options.longs === String ? "0" : 0;
                    object.hasFunctions = false;
                    object.hasFilenames = false;
                    object.hasLineNumbers = false;
                    object.hasInlineFrames = false;
                }
                if (message.id != null && message.hasOwnProperty("id"))
                    if (typeof message.id === "number")
                        object.id = options.longs === String ? String(message.id) : message.id;
                    else
                        object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true) : message.id;
                if (message.memoryStart != null && message.hasOwnProperty("memoryStart"))
                    if (typeof message.memoryStart === "number")
                        object.memoryStart = options.longs === String ? String(message.memoryStart) : message.memoryStart;
                    else
                        object.memoryStart = options.longs === String ? $util.Long.prototype.toString.call(message.memoryStart) : options.longs === Number ? new $util.LongBits(message.memoryStart.low >>> 0, message.memoryStart.high >>> 0).toNumber(true) : message.memoryStart;
                if (message.memoryLimit != null && message.hasOwnProperty("memoryLimit"))
                    if (typeof message.memoryLimit === "number")
                        object.memoryLimit = options.longs === String ? String(message.memoryLimit) : message.memoryLimit;
                    else
                        object.memoryLimit = options.longs === String ? $util.Long.prototype.toString.call(message.memoryLimit) : options.longs === Number ? new $util.LongBits(message.memoryLimit.low >>> 0, message.memoryLimit.high >>> 0).toNumber(true) : message.memoryLimit;
                if (message.fileOffset != null && message.hasOwnProperty("fileOffset"))
                    if (typeof message.fileOffset === "number")
                        object.fileOffset = options.longs === String ? String(message.fileOffset) : message.fileOffset;
                    else
                        object.fileOffset = options.longs === String ? $util.Long.prototype.toString.call(message.fileOffset) : options.longs === Number ? new $util.LongBits(message.fileOffset.low >>> 0, message.fileOffset.high >>> 0).toNumber(true) : message.fileOffset;
                if (message.filename != null && message.hasOwnProperty("filename"))
                    if (typeof message.filename === "number")
                        object.filename = options.longs === String ? String(message.filename) : message.filename;
                    else
                        object.filename = options.longs === String ? $util.Long.prototype.toString.call(message.filename) : options.longs === Number ? new $util.LongBits(message.filename.low >>> 0, message.filename.high >>> 0).toNumber() : message.filename;
                if (message.buildId != null && message.hasOwnProperty("buildId"))
                    if (typeof message.buildId === "number")
                        object.buildId = options.longs === String ? String(message.buildId) : message.buildId;
                    else
                        object.buildId = options.longs === String ? $util.Long.prototype.toString.call(message.buildId) : options.longs === Number ? new $util.LongBits(message.buildId.low >>> 0, message.buildId.high >>> 0).toNumber() : message.buildId;
                if (message.hasFunctions != null && message.hasOwnProperty("hasFunctions"))
                    object.hasFunctions = message.hasFunctions;
                if (message.hasFilenames != null && message.hasOwnProperty("hasFilenames"))
                    object.hasFilenames = message.hasFilenames;
                if (message.hasLineNumbers != null && message.hasOwnProperty("hasLineNumbers"))
                    object.hasLineNumbers = message.hasLineNumbers;
                if (message.hasInlineFrames != null && message.hasOwnProperty("hasInlineFrames"))
                    object.hasInlineFrames = message.hasInlineFrames;
                return object;
            };

            /**
             * Converts this Mapping to JSON.
             * @function toJSON
             * @memberof perftools.profiles.Mapping
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Mapping.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Mapping;
        })();

        profiles.Location = (function() {

            /**
             * Properties of a Location.
             * @memberof perftools.profiles
             * @interface ILocation
             * @property {number|Long} [id] Location id
             * @property {number|Long} [mappingId] Location mappingId
             * @property {number|Long} [address] Location address
             * @property {Array.<perftools.profiles.ILine>} [line] Location line
             */

            /**
             * Constructs a new Location.
             * @memberof perftools.profiles
             * @classdesc Represents a Location.
             * @constructor
             * @param {perftools.profiles.ILocation=} [properties] Properties to set
             */
            function Location(properties) {
                this.line = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Location id.
             * @member {number|Long}id
             * @memberof perftools.profiles.Location
             * @instance
             */
            Location.prototype.id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Location mappingId.
             * @member {number|Long}mappingId
             * @memberof perftools.profiles.Location
             * @instance
             */
            Location.prototype.mappingId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Location address.
             * @member {number|Long}address
             * @memberof perftools.profiles.Location
             * @instance
             */
            Location.prototype.address = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Location line.
             * @member {Array.<perftools.profiles.ILine>}line
             * @memberof perftools.profiles.Location
             * @instance
             */
            Location.prototype.line = $util.emptyArray;

            /**
             * Creates a new Location instance using the specified properties.
             * @function create
             * @memberof perftools.profiles.Location
             * @static
             * @param {perftools.profiles.ILocation=} [properties] Properties to set
             * @returns {perftools.profiles.Location} Location instance
             */
            Location.create = function create(properties) {
                return new Location(properties);
            };

            /**
             * Encodes the specified Location message. Does not implicitly {@link perftools.profiles.Location.verify|verify} messages.
             * @function encode
             * @memberof perftools.profiles.Location
             * @static
             * @param {perftools.profiles.ILocation} message Location message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Location.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && message.hasOwnProperty("id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.id);
                if (message.mappingId != null && message.hasOwnProperty("mappingId"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.mappingId);
                if (message.address != null && message.hasOwnProperty("address"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.address);
                if (message.line != null && message.line.length)
                    for (var i = 0; i < message.line.length; ++i)
                        $root.perftools.profiles.Line.encode(message.line[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Location message, length delimited. Does not implicitly {@link perftools.profiles.Location.verify|verify} messages.
             * @function encodeDelimited
             * @memberof perftools.profiles.Location
             * @static
             * @param {perftools.profiles.ILocation} message Location message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Location.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Location message from the specified reader or buffer.
             * @function decode
             * @memberof perftools.profiles.Location
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {perftools.profiles.Location} Location
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Location.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.perftools.profiles.Location();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = reader.uint64();
                        break;
                    case 2:
                        message.mappingId = reader.uint64();
                        break;
                    case 3:
                        message.address = reader.uint64();
                        break;
                    case 4:
                        if (!(message.line && message.line.length))
                            message.line = [];
                        message.line.push($root.perftools.profiles.Line.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Location message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof perftools.profiles.Location
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {perftools.profiles.Location} Location
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Location.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Location message.
             * @function verify
             * @memberof perftools.profiles.Location
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Location.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                        return "id: integer|Long expected";
                if (message.mappingId != null && message.hasOwnProperty("mappingId"))
                    if (!$util.isInteger(message.mappingId) && !(message.mappingId && $util.isInteger(message.mappingId.low) && $util.isInteger(message.mappingId.high)))
                        return "mappingId: integer|Long expected";
                if (message.address != null && message.hasOwnProperty("address"))
                    if (!$util.isInteger(message.address) && !(message.address && $util.isInteger(message.address.low) && $util.isInteger(message.address.high)))
                        return "address: integer|Long expected";
                if (message.line != null && message.hasOwnProperty("line")) {
                    if (!Array.isArray(message.line))
                        return "line: array expected";
                    for (var i = 0; i < message.line.length; ++i) {
                        var error = $root.perftools.profiles.Line.verify(message.line[i]);
                        if (error)
                            return "line." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a Location message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof perftools.profiles.Location
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {perftools.profiles.Location} Location
             */
            Location.fromObject = function fromObject(object) {
                if (object instanceof $root.perftools.profiles.Location)
                    return object;
                var message = new $root.perftools.profiles.Location();
                if (object.id != null)
                    if ($util.Long)
                        (message.id = $util.Long.fromValue(object.id)).unsigned = true;
                    else if (typeof object.id === "string")
                        message.id = parseInt(object.id, 10);
                    else if (typeof object.id === "number")
                        message.id = object.id;
                    else if (typeof object.id === "object")
                        message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);
                if (object.mappingId != null)
                    if ($util.Long)
                        (message.mappingId = $util.Long.fromValue(object.mappingId)).unsigned = true;
                    else if (typeof object.mappingId === "string")
                        message.mappingId = parseInt(object.mappingId, 10);
                    else if (typeof object.mappingId === "number")
                        message.mappingId = object.mappingId;
                    else if (typeof object.mappingId === "object")
                        message.mappingId = new $util.LongBits(object.mappingId.low >>> 0, object.mappingId.high >>> 0).toNumber(true);
                if (object.address != null)
                    if ($util.Long)
                        (message.address = $util.Long.fromValue(object.address)).unsigned = true;
                    else if (typeof object.address === "string")
                        message.address = parseInt(object.address, 10);
                    else if (typeof object.address === "number")
                        message.address = object.address;
                    else if (typeof object.address === "object")
                        message.address = new $util.LongBits(object.address.low >>> 0, object.address.high >>> 0).toNumber(true);
                if (object.line) {
                    if (!Array.isArray(object.line))
                        throw TypeError(".perftools.profiles.Location.line: array expected");
                    message.line = [];
                    for (var i = 0; i < object.line.length; ++i) {
                        if (typeof object.line[i] !== "object")
                            throw TypeError(".perftools.profiles.Location.line: object expected");
                        message.line[i] = $root.perftools.profiles.Line.fromObject(object.line[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a Location message. Also converts values to other types if specified.
             * @function toObject
             * @memberof perftools.profiles.Location
             * @static
             * @param {perftools.profiles.Location} message Location
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Location.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.line = [];
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.id = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.mappingId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.mappingId = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.address = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.address = options.longs === String ? "0" : 0;
                }
                if (message.id != null && message.hasOwnProperty("id"))
                    if (typeof message.id === "number")
                        object.id = options.longs === String ? String(message.id) : message.id;
                    else
                        object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true) : message.id;
                if (message.mappingId != null && message.hasOwnProperty("mappingId"))
                    if (typeof message.mappingId === "number")
                        object.mappingId = options.longs === String ? String(message.mappingId) : message.mappingId;
                    else
                        object.mappingId = options.longs === String ? $util.Long.prototype.toString.call(message.mappingId) : options.longs === Number ? new $util.LongBits(message.mappingId.low >>> 0, message.mappingId.high >>> 0).toNumber(true) : message.mappingId;
                if (message.address != null && message.hasOwnProperty("address"))
                    if (typeof message.address === "number")
                        object.address = options.longs === String ? String(message.address) : message.address;
                    else
                        object.address = options.longs === String ? $util.Long.prototype.toString.call(message.address) : options.longs === Number ? new $util.LongBits(message.address.low >>> 0, message.address.high >>> 0).toNumber(true) : message.address;
                if (message.line && message.line.length) {
                    object.line = [];
                    for (var j = 0; j < message.line.length; ++j)
                        object.line[j] = $root.perftools.profiles.Line.toObject(message.line[j], options);
                }
                return object;
            };

            /**
             * Converts this Location to JSON.
             * @function toJSON
             * @memberof perftools.profiles.Location
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Location.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Location;
        })();

        profiles.Line = (function() {

            /**
             * Properties of a Line.
             * @memberof perftools.profiles
             * @interface ILine
             * @property {number|Long} [functionId] Line functionId
             * @property {number|Long} [line] Line line
             */

            /**
             * Constructs a new Line.
             * @memberof perftools.profiles
             * @classdesc Represents a Line.
             * @constructor
             * @param {perftools.profiles.ILine=} [properties] Properties to set
             */
            function Line(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Line functionId.
             * @member {number|Long}functionId
             * @memberof perftools.profiles.Line
             * @instance
             */
            Line.prototype.functionId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Line line.
             * @member {number|Long}line
             * @memberof perftools.profiles.Line
             * @instance
             */
            Line.prototype.line = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new Line instance using the specified properties.
             * @function create
             * @memberof perftools.profiles.Line
             * @static
             * @param {perftools.profiles.ILine=} [properties] Properties to set
             * @returns {perftools.profiles.Line} Line instance
             */
            Line.create = function create(properties) {
                return new Line(properties);
            };

            /**
             * Encodes the specified Line message. Does not implicitly {@link perftools.profiles.Line.verify|verify} messages.
             * @function encode
             * @memberof perftools.profiles.Line
             * @static
             * @param {perftools.profiles.ILine} message Line message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Line.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.functionId != null && message.hasOwnProperty("functionId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.functionId);
                if (message.line != null && message.hasOwnProperty("line"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.line);
                return writer;
            };

            /**
             * Encodes the specified Line message, length delimited. Does not implicitly {@link perftools.profiles.Line.verify|verify} messages.
             * @function encodeDelimited
             * @memberof perftools.profiles.Line
             * @static
             * @param {perftools.profiles.ILine} message Line message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Line.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Line message from the specified reader or buffer.
             * @function decode
             * @memberof perftools.profiles.Line
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {perftools.profiles.Line} Line
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Line.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.perftools.profiles.Line();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.functionId = reader.uint64();
                        break;
                    case 2:
                        message.line = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Line message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof perftools.profiles.Line
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {perftools.profiles.Line} Line
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Line.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Line message.
             * @function verify
             * @memberof perftools.profiles.Line
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Line.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.functionId != null && message.hasOwnProperty("functionId"))
                    if (!$util.isInteger(message.functionId) && !(message.functionId && $util.isInteger(message.functionId.low) && $util.isInteger(message.functionId.high)))
                        return "functionId: integer|Long expected";
                if (message.line != null && message.hasOwnProperty("line"))
                    if (!$util.isInteger(message.line) && !(message.line && $util.isInteger(message.line.low) && $util.isInteger(message.line.high)))
                        return "line: integer|Long expected";
                return null;
            };

            /**
             * Creates a Line message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof perftools.profiles.Line
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {perftools.profiles.Line} Line
             */
            Line.fromObject = function fromObject(object) {
                if (object instanceof $root.perftools.profiles.Line)
                    return object;
                var message = new $root.perftools.profiles.Line();
                if (object.functionId != null)
                    if ($util.Long)
                        (message.functionId = $util.Long.fromValue(object.functionId)).unsigned = true;
                    else if (typeof object.functionId === "string")
                        message.functionId = parseInt(object.functionId, 10);
                    else if (typeof object.functionId === "number")
                        message.functionId = object.functionId;
                    else if (typeof object.functionId === "object")
                        message.functionId = new $util.LongBits(object.functionId.low >>> 0, object.functionId.high >>> 0).toNumber(true);
                if (object.line != null)
                    if ($util.Long)
                        (message.line = $util.Long.fromValue(object.line)).unsigned = false;
                    else if (typeof object.line === "string")
                        message.line = parseInt(object.line, 10);
                    else if (typeof object.line === "number")
                        message.line = object.line;
                    else if (typeof object.line === "object")
                        message.line = new $util.LongBits(object.line.low >>> 0, object.line.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a plain object from a Line message. Also converts values to other types if specified.
             * @function toObject
             * @memberof perftools.profiles.Line
             * @static
             * @param {perftools.profiles.Line} message Line
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Line.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.functionId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.functionId = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.line = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.line = options.longs === String ? "0" : 0;
                }
                if (message.functionId != null && message.hasOwnProperty("functionId"))
                    if (typeof message.functionId === "number")
                        object.functionId = options.longs === String ? String(message.functionId) : message.functionId;
                    else
                        object.functionId = options.longs === String ? $util.Long.prototype.toString.call(message.functionId) : options.longs === Number ? new $util.LongBits(message.functionId.low >>> 0, message.functionId.high >>> 0).toNumber(true) : message.functionId;
                if (message.line != null && message.hasOwnProperty("line"))
                    if (typeof message.line === "number")
                        object.line = options.longs === String ? String(message.line) : message.line;
                    else
                        object.line = options.longs === String ? $util.Long.prototype.toString.call(message.line) : options.longs === Number ? new $util.LongBits(message.line.low >>> 0, message.line.high >>> 0).toNumber() : message.line;
                return object;
            };

            /**
             * Converts this Line to JSON.
             * @function toJSON
             * @memberof perftools.profiles.Line
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Line.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Line;
        })();

        profiles.Function = (function() {

            /**
             * Properties of a Function.
             * @memberof perftools.profiles
             * @interface IFunction
             * @property {number|Long} [id] Function id
             * @property {number|Long} [name] Function name
             * @property {number|Long} [systemName] Function systemName
             * @property {number|Long} [filename] Function filename
             * @property {number|Long} [startLine] Function startLine
             */

            /**
             * Constructs a new Function.
             * @memberof perftools.profiles
             * @classdesc Represents a Function.
             * @constructor
             * @param {perftools.profiles.IFunction=} [properties] Properties to set
             */
            function Function(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Function id.
             * @member {number|Long}id
             * @memberof perftools.profiles.Function
             * @instance
             */
            Function.prototype.id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Function name.
             * @member {number|Long}name
             * @memberof perftools.profiles.Function
             * @instance
             */
            Function.prototype.name = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Function systemName.
             * @member {number|Long}systemName
             * @memberof perftools.profiles.Function
             * @instance
             */
            Function.prototype.systemName = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Function filename.
             * @member {number|Long}filename
             * @memberof perftools.profiles.Function
             * @instance
             */
            Function.prototype.filename = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Function startLine.
             * @member {number|Long}startLine
             * @memberof perftools.profiles.Function
             * @instance
             */
            Function.prototype.startLine = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new Function instance using the specified properties.
             * @function create
             * @memberof perftools.profiles.Function
             * @static
             * @param {perftools.profiles.IFunction=} [properties] Properties to set
             * @returns {perftools.profiles.Function} Function instance
             */
            Function.create = function create(properties) {
                return new Function(properties);
            };

            /**
             * Encodes the specified Function message. Does not implicitly {@link perftools.profiles.Function.verify|verify} messages.
             * @function encode
             * @memberof perftools.profiles.Function
             * @static
             * @param {perftools.profiles.IFunction} message Function message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Function.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && message.hasOwnProperty("id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.id);
                if (message.name != null && message.hasOwnProperty("name"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.name);
                if (message.systemName != null && message.hasOwnProperty("systemName"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int64(message.systemName);
                if (message.filename != null && message.hasOwnProperty("filename"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int64(message.filename);
                if (message.startLine != null && message.hasOwnProperty("startLine"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int64(message.startLine);
                return writer;
            };

            /**
             * Encodes the specified Function message, length delimited. Does not implicitly {@link perftools.profiles.Function.verify|verify} messages.
             * @function encodeDelimited
             * @memberof perftools.profiles.Function
             * @static
             * @param {perftools.profiles.IFunction} message Function message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Function.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Function message from the specified reader or buffer.
             * @function decode
             * @memberof perftools.profiles.Function
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {perftools.profiles.Function} Function
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Function.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.perftools.profiles.Function();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = reader.uint64();
                        break;
                    case 2:
                        message.name = reader.int64();
                        break;
                    case 3:
                        message.systemName = reader.int64();
                        break;
                    case 4:
                        message.filename = reader.int64();
                        break;
                    case 5:
                        message.startLine = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Function message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof perftools.profiles.Function
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {perftools.profiles.Function} Function
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Function.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Function message.
             * @function verify
             * @memberof perftools.profiles.Function
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Function.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                        return "id: integer|Long expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isInteger(message.name) && !(message.name && $util.isInteger(message.name.low) && $util.isInteger(message.name.high)))
                        return "name: integer|Long expected";
                if (message.systemName != null && message.hasOwnProperty("systemName"))
                    if (!$util.isInteger(message.systemName) && !(message.systemName && $util.isInteger(message.systemName.low) && $util.isInteger(message.systemName.high)))
                        return "systemName: integer|Long expected";
                if (message.filename != null && message.hasOwnProperty("filename"))
                    if (!$util.isInteger(message.filename) && !(message.filename && $util.isInteger(message.filename.low) && $util.isInteger(message.filename.high)))
                        return "filename: integer|Long expected";
                if (message.startLine != null && message.hasOwnProperty("startLine"))
                    if (!$util.isInteger(message.startLine) && !(message.startLine && $util.isInteger(message.startLine.low) && $util.isInteger(message.startLine.high)))
                        return "startLine: integer|Long expected";
                return null;
            };

            /**
             * Creates a Function message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof perftools.profiles.Function
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {perftools.profiles.Function} Function
             */
            Function.fromObject = function fromObject(object) {
                if (object instanceof $root.perftools.profiles.Function)
                    return object;
                var message = new $root.perftools.profiles.Function();
                if (object.id != null)
                    if ($util.Long)
                        (message.id = $util.Long.fromValue(object.id)).unsigned = true;
                    else if (typeof object.id === "string")
                        message.id = parseInt(object.id, 10);
                    else if (typeof object.id === "number")
                        message.id = object.id;
                    else if (typeof object.id === "object")
                        message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);
                if (object.name != null)
                    if ($util.Long)
                        (message.name = $util.Long.fromValue(object.name)).unsigned = false;
                    else if (typeof object.name === "string")
                        message.name = parseInt(object.name, 10);
                    else if (typeof object.name === "number")
                        message.name = object.name;
                    else if (typeof object.name === "object")
                        message.name = new $util.LongBits(object.name.low >>> 0, object.name.high >>> 0).toNumber();
                if (object.systemName != null)
                    if ($util.Long)
                        (message.systemName = $util.Long.fromValue(object.systemName)).unsigned = false;
                    else if (typeof object.systemName === "string")
                        message.systemName = parseInt(object.systemName, 10);
                    else if (typeof object.systemName === "number")
                        message.systemName = object.systemName;
                    else if (typeof object.systemName === "object")
                        message.systemName = new $util.LongBits(object.systemName.low >>> 0, object.systemName.high >>> 0).toNumber();
                if (object.filename != null)
                    if ($util.Long)
                        (message.filename = $util.Long.fromValue(object.filename)).unsigned = false;
                    else if (typeof object.filename === "string")
                        message.filename = parseInt(object.filename, 10);
                    else if (typeof object.filename === "number")
                        message.filename = object.filename;
                    else if (typeof object.filename === "object")
                        message.filename = new $util.LongBits(object.filename.low >>> 0, object.filename.high >>> 0).toNumber();
                if (object.startLine != null)
                    if ($util.Long)
                        (message.startLine = $util.Long.fromValue(object.startLine)).unsigned = false;
                    else if (typeof object.startLine === "string")
                        message.startLine = parseInt(object.startLine, 10);
                    else if (typeof object.startLine === "number")
                        message.startLine = object.startLine;
                    else if (typeof object.startLine === "object")
                        message.startLine = new $util.LongBits(object.startLine.low >>> 0, object.startLine.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a plain object from a Function message. Also converts values to other types if specified.
             * @function toObject
             * @memberof perftools.profiles.Function
             * @static
             * @param {perftools.profiles.Function} message Function
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Function.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.id = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.name = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.name = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.systemName = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.systemName = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.filename = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.filename = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.startLine = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.startLine = options.longs === String ? "0" : 0;
                }
                if (message.id != null && message.hasOwnProperty("id"))
                    if (typeof message.id === "number")
                        object.id = options.longs === String ? String(message.id) : message.id;
                    else
                        object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true) : message.id;
                if (message.name != null && message.hasOwnProperty("name"))
                    if (typeof message.name === "number")
                        object.name = options.longs === String ? String(message.name) : message.name;
                    else
                        object.name = options.longs === String ? $util.Long.prototype.toString.call(message.name) : options.longs === Number ? new $util.LongBits(message.name.low >>> 0, message.name.high >>> 0).toNumber() : message.name;
                if (message.systemName != null && message.hasOwnProperty("systemName"))
                    if (typeof message.systemName === "number")
                        object.systemName = options.longs === String ? String(message.systemName) : message.systemName;
                    else
                        object.systemName = options.longs === String ? $util.Long.prototype.toString.call(message.systemName) : options.longs === Number ? new $util.LongBits(message.systemName.low >>> 0, message.systemName.high >>> 0).toNumber() : message.systemName;
                if (message.filename != null && message.hasOwnProperty("filename"))
                    if (typeof message.filename === "number")
                        object.filename = options.longs === String ? String(message.filename) : message.filename;
                    else
                        object.filename = options.longs === String ? $util.Long.prototype.toString.call(message.filename) : options.longs === Number ? new $util.LongBits(message.filename.low >>> 0, message.filename.high >>> 0).toNumber() : message.filename;
                if (message.startLine != null && message.hasOwnProperty("startLine"))
                    if (typeof message.startLine === "number")
                        object.startLine = options.longs === String ? String(message.startLine) : message.startLine;
                    else
                        object.startLine = options.longs === String ? $util.Long.prototype.toString.call(message.startLine) : options.longs === Number ? new $util.LongBits(message.startLine.low >>> 0, message.startLine.high >>> 0).toNumber() : message.startLine;
                return object;
            };

            /**
             * Converts this Function to JSON.
             * @function toJSON
             * @memberof perftools.profiles.Function
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Function.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Function;
        })();

        return profiles;
    })();

    return perftools;
})();

module.exports = $root;


/***/ }),

/***/ "../../node_modules/@datadog/sketches-js/dist/ddsketch/DDSketch.js":
/*!******************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/@datadog/sketches-js/dist/ddsketch/DDSketch.js ***!
  \******************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Unless explicitly stated otherwise all files in this repository are licensed
 * under the Apache 2.0 license (see LICENSE).
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020 Datadog, Inc.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.DDSketch = void 0;
var store_1 = __webpack_require__(/*! ./store */ "../../node_modules/@datadog/sketches-js/dist/ddsketch/store/index.js");
var mapping_1 = __webpack_require__(/*! ./mapping */ "../../node_modules/@datadog/sketches-js/dist/ddsketch/mapping/index.js");
var compiled_1 = __webpack_require__(/*! ./proto/compiled */ "../../node_modules/@datadog/sketches-js/dist/ddsketch/proto/compiled.js");
var DEFAULT_RELATIVE_ACCURACY = 0.01;
/** Base class for DDSketch*/
var BaseDDSketch = /** @class */ (function () {
    function BaseDDSketch(_a) {
        var mapping = _a.mapping, store = _a.store, negativeStore = _a.negativeStore, zeroCount = _a.zeroCount;
        this.mapping = mapping;
        this.store = store;
        this.negativeStore = negativeStore;
        this.zeroCount = zeroCount;
        this.count =
            this.negativeStore.count + this.zeroCount + this.store.count;
        this.min = Infinity;
        this.max = -Infinity;
        this.sum = 0;
    }
    /**
     * Add a value to the sketch
     *
     * @param value The value to be added
     * @param weight The amount to weight the value (default 1.0)
     *
     * @throws Error if `weight` is 0 or negative
     */
    BaseDDSketch.prototype.accept = function (value, weight) {
        if (weight === void 0) { weight = 1; }
        if (weight <= 0) {
            throw Error('Weight must be a positive number');
        }
        if (value > this.mapping.minPossible) {
            var key = this.mapping.key(value);
            this.store.add(key, weight);
        }
        else if (value < -this.mapping.minPossible) {
            var key = this.mapping.key(-value);
            this.negativeStore.add(key, weight);
        }
        else {
            this.zeroCount += weight;
        }
        /* Keep track of summary stats */
        this.count += weight;
        this.sum += value * weight;
        if (value < this.min) {
            this.min = value;
        }
        if (value > this.max) {
            this.max = value;
        }
    };
    /**
     * Retrieve a value from the sketch at the quantile
     *
     * @param quantile A number between `0` and `1` (inclusive)
     */
    BaseDDSketch.prototype.getValueAtQuantile = function (quantile) {
        if (quantile < 0 || quantile > 1 || this.count === 0) {
            return NaN;
        }
        var rank = quantile * (this.count - 1);
        var quantileValue = 0;
        if (rank < this.negativeStore.count) {
            var reversedRank = this.negativeStore.count - rank - 1;
            var key = this.negativeStore.keyAtRank(reversedRank, false);
            quantileValue = -this.mapping.value(key);
        }
        else if (rank < this.zeroCount + this.negativeStore.count) {
            return 0;
        }
        else {
            var key = this.store.keyAtRank(rank - this.zeroCount - this.negativeStore.count);
            quantileValue = this.mapping.value(key);
        }
        return quantileValue;
    };
    /**
     * Merge the contents of the parameter `sketch` into this sketch
     *
     * @param sketch The sketch to merge into the caller sketch
     * @throws Error if the sketches were initialized with different `relativeAccuracy` values
     */
    BaseDDSketch.prototype.merge = function (sketch) {
        if (!this.mergeable(sketch)) {
            throw new Error('Cannot merge two DDSketches with different `relativeAccuracy` parameters');
        }
        if (sketch.count === 0) {
            return;
        }
        if (this.count === 0) {
            this._copy(sketch);
            return;
        }
        this.store.merge(sketch.store);
        /* Merge summary stats */
        this.count += sketch.count;
        this.sum += sketch.sum;
        if (sketch.min < this.min) {
            this.min = sketch.min;
        }
        if (sketch.max > this.max) {
            this.max = sketch.max;
        }
    };
    /**
     * Determine whether two sketches can be merged
     *
     * @param sketch The sketch to be merged into the caller sketch
     */
    BaseDDSketch.prototype.mergeable = function (sketch) {
        return this.mapping.gamma === sketch.mapping.gamma;
    };
    /**
     * Helper method to copy the contents of the parameter `store` into this store
     * @see DDSketch.merge to merge two sketches safely
     *
     * @param store The store to be copied into the caller store
     */
    BaseDDSketch.prototype._copy = function (sketch) {
        this.store.copy(sketch.store);
        this.negativeStore.copy(sketch.negativeStore);
        this.zeroCount = sketch.zeroCount;
        this.min = sketch.min;
        this.max = sketch.max;
        this.count = sketch.count;
        this.sum = sketch.sum;
    };
    /** Serialize a DDSketch to protobuf format */
    BaseDDSketch.prototype.toProto = function () {
        var message = compiled_1.DDSketch.create({
            mapping: this.mapping.toProto(),
            positiveValues: this.store.toProto(),
            negativeValues: this.negativeStore.toProto(),
            zeroCount: this.zeroCount
        });
        return compiled_1.DDSketch.encode(message).finish();
    };
    /**
     * Deserialize a DDSketch from protobuf data
     *
     * Note: `fromProto` currently loses summary statistics for the original
     * sketch (i.e. `min`, `max`)
     *
     * @param buffer Byte array containing DDSketch in protobuf format (from DDSketch.toProto)
     */
    BaseDDSketch.fromProto = function (buffer) {
        var decoded = compiled_1.DDSketch.decode(buffer);
        var mapping = mapping_1.KeyMapping.fromProto(decoded.mapping);
        var store = store_1.DenseStore.fromProto(decoded.positiveValues);
        var negativeStore = store_1.DenseStore.fromProto(decoded.negativeValues);
        var zeroCount = decoded.zeroCount;
        return new BaseDDSketch({ mapping: mapping, store: store, negativeStore: negativeStore, zeroCount: zeroCount });
    };
    return BaseDDSketch;
}());
var defaultConfig = {
    relativeAccuracy: DEFAULT_RELATIVE_ACCURACY
};
/** A quantile sketch with relative-error guarantees */
var DDSketch = /** @class */ (function (_super) {
    __extends(DDSketch, _super);
    /**
     * Initialize a new DDSketch
     *
     * @param relativeAccuracy The accuracy guarantee of the sketch (default 0.01)
     */
    function DDSketch(_a) {
        var _b = _a === void 0 ? defaultConfig : _a, _c = _b.relativeAccuracy, relativeAccuracy = _c === void 0 ? DEFAULT_RELATIVE_ACCURACY : _c;
        var _this = this;
        var mapping = new mapping_1.LogarithmicMapping(relativeAccuracy);
        var store = new store_1.DenseStore();
        var negativeStore = new store_1.DenseStore();
        _this = _super.call(this, { mapping: mapping, store: store, negativeStore: negativeStore, zeroCount: 0 }) || this;
        return _this;
    }
    return DDSketch;
}(BaseDDSketch));
exports.DDSketch = DDSketch;


/***/ }),

/***/ "../../node_modules/@datadog/sketches-js/dist/ddsketch/index.js":
/*!***************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/@datadog/sketches-js/dist/ddsketch/index.js ***!
  \***************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Unless explicitly stated otherwise all files in this repository are licensed
 * under the Apache 2.0 license (see LICENSE).
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020 Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.DDSketch = void 0;
var DDSketch_1 = __webpack_require__(/*! ./DDSketch */ "../../node_modules/@datadog/sketches-js/dist/ddsketch/DDSketch.js");
Object.defineProperty(exports, "DDSketch", { enumerable: true, get: function () { return DDSketch_1.DDSketch; } });


/***/ }),

/***/ "../../node_modules/@datadog/sketches-js/dist/ddsketch/mapping/CubicallyInterpolatedMapping.js":
/*!**********************************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/@datadog/sketches-js/dist/ddsketch/mapping/CubicallyInterpolatedMapping.js ***!
  \**********************************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Unless explicitly stated otherwise all files in this repository are licensed
 * under the Apache 2.0 license (see LICENSE).
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020 Datadog, Inc.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.CubicallyInterpolatedMapping = void 0;
var KeyMapping_1 = __webpack_require__(/*! ./KeyMapping */ "../../node_modules/@datadog/sketches-js/dist/ddsketch/mapping/KeyMapping.js");
var math_1 = __webpack_require__(/*! ../math */ "../../node_modules/@datadog/sketches-js/dist/ddsketch/math.js");
var compiled_1 = __webpack_require__(/*! ../proto/compiled */ "../../node_modules/@datadog/sketches-js/dist/ddsketch/proto/compiled.js");
/**
 * A fast KeyMapping that approximates the memory-optimal LogarithmicMapping by
 * extracting the floor value of the logarithm to the base 2 from the binary
 * representations of floating-point values and cubically interpolating the
 * logarithm in-between.
 *
 * More detailed documentation of this method can be found in:
 * <a href="https://github.com/DataDog/sketches-java/">sketches-java</a>
 */
var CubicallyInterpolatedMapping = /** @class */ (function (_super) {
    __extends(CubicallyInterpolatedMapping, _super);
    function CubicallyInterpolatedMapping(relativeAccuracy, offset) {
        if (offset === void 0) { offset = 0; }
        var _this = _super.call(this, relativeAccuracy, offset) || this;
        _this.A = 6 / 35;
        _this.B = -3 / 5;
        _this.C = 10 / 7;
        _this._multiplier /= _this.C;
        return _this;
    }
    /** Approximates log2 using a cubic polynomial */
    CubicallyInterpolatedMapping.prototype._cubicLog2Approx = function (value) {
        var _a = math_1.frexp(value), mantissa = _a[0], exponent = _a[1];
        var significand = 2 * mantissa - 1;
        return (((this.A * significand + this.B) * significand + this.C) *
            significand +
            (exponent - 1));
    };
    /** Derived from Cardano's formula */
    CubicallyInterpolatedMapping.prototype._cubicExp2Approx = function (value) {
        var exponent = Math.floor(value);
        var delta0 = this.B * this.B - 3 * this.A * this.C;
        var delta1 = 2 * this.B * this.B * this.B -
            9 * this.A * this.B * this.C -
            27 * this.A * this.A * (value - exponent);
        var cardano = Math.cbrt((delta1 -
            Math.sqrt(delta1 * delta1 - 4 * delta0 * delta0 * delta0)) /
            2);
        var significandPlusOne = -(this.B + cardano + delta0 / cardano) / (3 * this.A) + 1;
        var mantissa = significandPlusOne / 2;
        return math_1.ldexp(mantissa, exponent + 1);
    };
    CubicallyInterpolatedMapping.prototype._logGamma = function (value) {
        return this._cubicLog2Approx(value) * this._multiplier;
    };
    CubicallyInterpolatedMapping.prototype._powGamma = function (value) {
        return this._cubicExp2Approx(value / this._multiplier);
    };
    CubicallyInterpolatedMapping.prototype._protoInterpolation = function () {
        return compiled_1.IndexMapping.Interpolation.CUBIC;
    };
    return CubicallyInterpolatedMapping;
}(KeyMapping_1.KeyMapping));
exports.CubicallyInterpolatedMapping = CubicallyInterpolatedMapping;


/***/ }),

/***/ "../../node_modules/@datadog/sketches-js/dist/ddsketch/mapping/KeyMapping.js":
/*!****************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/@datadog/sketches-js/dist/ddsketch/mapping/KeyMapping.js ***!
  \****************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Unless explicitly stated otherwise all files in this repository are licensed
 * under the Apache 2.0 license (see LICENSE).
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020 Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.KeyMapping = void 0;
var index_1 = __webpack_require__(/*! ./index */ "../../node_modules/@datadog/sketches-js/dist/ddsketch/mapping/index.js");
var compiled_1 = __webpack_require__(/*! ../proto/compiled */ "../../node_modules/@datadog/sketches-js/dist/ddsketch/proto/compiled.js");
// 1.1125369292536007e-308
var MIN_SAFE_FLOAT = Math.pow(2, -1023);
var MAX_SAFE_FLOAT = Number.MAX_VALUE;
/**
 * A mapping between values and integer indices that imposes relative accuracy
 * guarantees. Specifically, for any value `minPossible() < value <
 * maxPossible` implementations of `KeyMapping` must be such that
 * `value(key(v))` is close to `v` with a relative error that is less than
 * `relativeAccuracy`.
 *
 * In implementations of KeyMapping, there is generally a trade-off between the
 * cost of computing the key and the number of keys that are required to cover a
 * given range of values (memory optimality). The most memory-optimal mapping is
 * the LogarithmicMapping, but it requires the costly evaluation of the logarithm
 * when computing the index. Other mappings can approximate the logarithmic
 * mapping, while being less computationally costly.
 */
var KeyMapping = /** @class */ (function () {
    function KeyMapping(relativeAccuracy, offset) {
        if (offset === void 0) { offset = 0; }
        if (relativeAccuracy <= 0 || relativeAccuracy >= 1) {
            throw Error('Relative accuracy must be between 0 and 1 when initializing a KeyMapping');
        }
        this.relativeAccuracy = relativeAccuracy;
        this._offset = offset;
        var gammaMantissa = (2 * relativeAccuracy) / (1 - relativeAccuracy);
        this.gamma = 1 + gammaMantissa;
        this._multiplier = 1 / Math.log1p(gammaMantissa);
        this.minPossible = MIN_SAFE_FLOAT * this.gamma;
        this.maxPossible = MAX_SAFE_FLOAT / this.gamma;
    }
    KeyMapping.fromGammaOffset = function (gamma, indexOffset) {
        var relativeAccuracy = (gamma - 1) / (gamma + 1);
        return new this(relativeAccuracy, indexOffset);
    };
    /** Retrieve the key specifying the bucket for a `value` */
    KeyMapping.prototype.key = function (value) {
        return Math.ceil(this._logGamma(value)) + this._offset;
    };
    /** Retrieve the value represented by the bucket at `key` */
    KeyMapping.prototype.value = function (key) {
        return this._powGamma(key - this._offset) * (2 / (1 + this.gamma));
    };
    KeyMapping.prototype.toProto = function () {
        return compiled_1.IndexMapping.create({
            gamma: this.gamma,
            indexOffset: this._offset,
            interpolation: this._protoInterpolation()
        });
    };
    KeyMapping.fromProto = function (protoMapping) {
        if (!protoMapping ||
            /* Double equals (==) is intentional here to check for
             * `null` | `undefined` without including `0` */
            protoMapping.gamma == null ||
            protoMapping.indexOffset == null) {
            throw Error('Failed to decode mapping from protobuf');
        }
        var interpolation = protoMapping.interpolation, gamma = protoMapping.gamma, indexOffset = protoMapping.indexOffset;
        switch (interpolation) {
            case compiled_1.IndexMapping.Interpolation.NONE:
                return index_1.LogarithmicMapping.fromGammaOffset(gamma, indexOffset);
            case compiled_1.IndexMapping.Interpolation.LINEAR:
                return index_1.LinearlyInterpolatedMapping.fromGammaOffset(gamma, indexOffset);
            case compiled_1.IndexMapping.Interpolation.CUBIC:
                return index_1.CubicallyInterpolatedMapping.fromGammaOffset(gamma, indexOffset);
            default:
                throw Error('Unrecognized mapping when decoding from protobuf');
        }
    };
    /** Return (an approximation of) the logarithm of the value base gamma */
    KeyMapping.prototype._logGamma = function (value) {
        return Math.log2(value) * this._multiplier;
    };
    /** Return (an approximation of) gamma to the power value */
    KeyMapping.prototype._powGamma = function (value) {
        return Math.pow(2, value / this._multiplier);
    };
    KeyMapping.prototype._protoInterpolation = function () {
        return compiled_1.IndexMapping.Interpolation.NONE;
    };
    return KeyMapping;
}());
exports.KeyMapping = KeyMapping;


/***/ }),

/***/ "../../node_modules/@datadog/sketches-js/dist/ddsketch/mapping/LinearlyInterpolatedMapping.js":
/*!*********************************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/@datadog/sketches-js/dist/ddsketch/mapping/LinearlyInterpolatedMapping.js ***!
  \*********************************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Unless explicitly stated otherwise all files in this repository are licensed
 * under the Apache 2.0 license (see LICENSE).
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020 Datadog, Inc.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.LinearlyInterpolatedMapping = void 0;
var KeyMapping_1 = __webpack_require__(/*! ./KeyMapping */ "../../node_modules/@datadog/sketches-js/dist/ddsketch/mapping/KeyMapping.js");
var math_1 = __webpack_require__(/*! ../math */ "../../node_modules/@datadog/sketches-js/dist/ddsketch/math.js");
var compiled_1 = __webpack_require__(/*! ../proto/compiled */ "../../node_modules/@datadog/sketches-js/dist/ddsketch/proto/compiled.js");
/**
 * A fast KeyMapping that approximates the memory-optimal one
 * (LogarithmicMapping) by extracting the floor value of the logarithm to the
 * base 2 from the binary representations of floating-point values and
 * linearly interpolating the logarithm in-between.
 */
var LinearlyInterpolatedMapping = /** @class */ (function (_super) {
    __extends(LinearlyInterpolatedMapping, _super);
    function LinearlyInterpolatedMapping(relativeAccuracy, offset) {
        if (offset === void 0) { offset = 0; }
        return _super.call(this, relativeAccuracy, offset) || this;
    }
    /**
     * Approximates log2 by s + f
     * where v = (s+1) * 2 ** f  for s in [0, 1)
     *
     * frexp(v) returns m and e s.t.
     * v = m * 2 ** e ; (m in [0.5, 1) or 0.0)
     * so we adjust m and e accordingly
     */
    LinearlyInterpolatedMapping.prototype._log2Approx = function (value) {
        var _a = math_1.frexp(value), mantissa = _a[0], exponent = _a[1];
        var significand = 2 * mantissa - 1;
        return significand + (exponent - 1);
    };
    /** Inverse of _log2Approx */
    LinearlyInterpolatedMapping.prototype._exp2Approx = function (value) {
        var exponent = Math.floor(value) + 1;
        var mantissa = (value - exponent + 2) / 2;
        return math_1.ldexp(mantissa, exponent);
    };
    LinearlyInterpolatedMapping.prototype._logGamma = function (value) {
        return Math.log2(value) * this._multiplier;
    };
    LinearlyInterpolatedMapping.prototype._powGamma = function (value) {
        return Math.pow(2, value / this._multiplier);
    };
    LinearlyInterpolatedMapping.prototype._protoInterpolation = function () {
        return compiled_1.IndexMapping.Interpolation.LINEAR;
    };
    return LinearlyInterpolatedMapping;
}(KeyMapping_1.KeyMapping));
exports.LinearlyInterpolatedMapping = LinearlyInterpolatedMapping;


/***/ }),

/***/ "../../node_modules/@datadog/sketches-js/dist/ddsketch/mapping/LogarithmicMapping.js":
/*!************************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/@datadog/sketches-js/dist/ddsketch/mapping/LogarithmicMapping.js ***!
  \************************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Unless explicitly stated otherwise all files in this repository are licensed
 * under the Apache 2.0 license (see LICENSE).
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020 Datadog, Inc.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.LogarithmicMapping = void 0;
var KeyMapping_1 = __webpack_require__(/*! ./KeyMapping */ "../../node_modules/@datadog/sketches-js/dist/ddsketch/mapping/KeyMapping.js");
var compiled_1 = __webpack_require__(/*! ../proto/compiled */ "../../node_modules/@datadog/sketches-js/dist/ddsketch/proto/compiled.js");
/**
 * A memory-optimal KeyMapping, i.e., given a targeted relative accuracy, it
 * requires the least number of keys to cover a given range of values. This is
 * done by logarithmically mapping floating-point values to integers.
 */
var LogarithmicMapping = /** @class */ (function (_super) {
    __extends(LogarithmicMapping, _super);
    function LogarithmicMapping(relativeAccuracy, offset) {
        if (offset === void 0) { offset = 0; }
        var _this = _super.call(this, relativeAccuracy, offset) || this;
        _this._multiplier *= Math.log(2);
        return _this;
    }
    LogarithmicMapping.prototype._logGamma = function (value) {
        return Math.log2(value) * this._multiplier;
    };
    LogarithmicMapping.prototype._powGamma = function (value) {
        return Math.pow(2, value / this._multiplier);
    };
    LogarithmicMapping.prototype._protoInterpolation = function () {
        return compiled_1.IndexMapping.Interpolation.NONE;
    };
    return LogarithmicMapping;
}(KeyMapping_1.KeyMapping));
exports.LogarithmicMapping = LogarithmicMapping;


/***/ }),

/***/ "../../node_modules/@datadog/sketches-js/dist/ddsketch/mapping/index.js":
/*!***********************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/@datadog/sketches-js/dist/ddsketch/mapping/index.js ***!
  \***********************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Unless explicitly stated otherwise all files in this repository are licensed
 * under the Apache 2.0 license (see LICENSE).
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020 Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.CubicallyInterpolatedMapping = exports.LinearlyInterpolatedMapping = exports.LogarithmicMapping = exports.KeyMapping = void 0;
var KeyMapping_1 = __webpack_require__(/*! ./KeyMapping */ "../../node_modules/@datadog/sketches-js/dist/ddsketch/mapping/KeyMapping.js");
Object.defineProperty(exports, "KeyMapping", { enumerable: true, get: function () { return KeyMapping_1.KeyMapping; } });
var LogarithmicMapping_1 = __webpack_require__(/*! ./LogarithmicMapping */ "../../node_modules/@datadog/sketches-js/dist/ddsketch/mapping/LogarithmicMapping.js");
Object.defineProperty(exports, "LogarithmicMapping", { enumerable: true, get: function () { return LogarithmicMapping_1.LogarithmicMapping; } });
var LinearlyInterpolatedMapping_1 = __webpack_require__(/*! ./LinearlyInterpolatedMapping */ "../../node_modules/@datadog/sketches-js/dist/ddsketch/mapping/LinearlyInterpolatedMapping.js");
Object.defineProperty(exports, "LinearlyInterpolatedMapping", { enumerable: true, get: function () { return LinearlyInterpolatedMapping_1.LinearlyInterpolatedMapping; } });
var CubicallyInterpolatedMapping_1 = __webpack_require__(/*! ./CubicallyInterpolatedMapping */ "../../node_modules/@datadog/sketches-js/dist/ddsketch/mapping/CubicallyInterpolatedMapping.js");
Object.defineProperty(exports, "CubicallyInterpolatedMapping", { enumerable: true, get: function () { return CubicallyInterpolatedMapping_1.CubicallyInterpolatedMapping; } });


/***/ }),

/***/ "../../node_modules/@datadog/sketches-js/dist/ddsketch/math.js":
/*!**************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/@datadog/sketches-js/dist/ddsketch/math.js ***!
  \**************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Unless explicitly stated otherwise all files in this repository are licensed
 * under the Apache 2.0 license (see LICENSE).
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020 Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ldexp = exports.frexp = void 0;
/**
 * Splits a double-precision floating-point number into a normalized fraction
 * and an integer power of two.
 */
function frexp(value) {
    if (value === 0 || !Number.isFinite(value))
        return [value, 0];
    var absValue = Math.abs(value);
    var exponent = Math.max(-1023, Math.floor(Math.log2(absValue)) + 1);
    var mantissa = absValue * Math.pow(2, -exponent);
    while (mantissa < 0.5) {
        mantissa *= 2;
        exponent--;
    }
    while (mantissa >= 1) {
        mantissa *= 0.5;
        exponent++;
    }
    if (value < 0) {
        mantissa = -mantissa;
    }
    return [mantissa, exponent];
}
exports.frexp = frexp;
/**
 * Multiplies a double-precision floating-point number by an integer power of
 * two; i.e., x = frac * 2^exp.
 */
function ldexp(mantissa, exponent) {
    var iterations = Math.min(3, Math.ceil(Math.abs(exponent) / 1023));
    var result = mantissa;
    for (var i = 0; i < iterations; i++) {
        result *= Math.pow(2, Math.floor((exponent + i) / iterations));
    }
    return result;
}
exports.ldexp = ldexp;


/***/ }),

/***/ "../../node_modules/@datadog/sketches-js/dist/ddsketch/proto/compiled.js":
/*!************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/@datadog/sketches-js/dist/ddsketch/proto/compiled.js ***!
  \************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/

var $protobuf = __webpack_require__(/*! protobufjs/minimal */ "../../node_modules/protobufjs/minimal.js");
// Common aliases
var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;
// Exported root namespace
var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});
$root.DDSketch = (function () {
    /**
     * Properties of a DDSketch.
     * @exports IDDSketch
     * @interface IDDSketch
     * @property {IIndexMapping|null} [mapping] DDSketch mapping
     * @property {IStore|null} [positiveValues] DDSketch positiveValues
     * @property {IStore|null} [negativeValues] DDSketch negativeValues
     * @property {number|null} [zeroCount] DDSketch zeroCount
     */
    /**
     * Constructs a new DDSketch.
     * @exports DDSketch
     * @classdesc Represents a DDSketch.
     * @implements IDDSketch
     * @constructor
     * @param {IDDSketch=} [properties] Properties to set
     */
    function DDSketch(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * DDSketch mapping.
     * @member {IIndexMapping|null|undefined} mapping
     * @memberof DDSketch
     * @instance
     */
    DDSketch.prototype.mapping = null;
    /**
     * DDSketch positiveValues.
     * @member {IStore|null|undefined} positiveValues
     * @memberof DDSketch
     * @instance
     */
    DDSketch.prototype.positiveValues = null;
    /**
     * DDSketch negativeValues.
     * @member {IStore|null|undefined} negativeValues
     * @memberof DDSketch
     * @instance
     */
    DDSketch.prototype.negativeValues = null;
    /**
     * DDSketch zeroCount.
     * @member {number} zeroCount
     * @memberof DDSketch
     * @instance
     */
    DDSketch.prototype.zeroCount = 0;
    /**
     * Creates a new DDSketch instance using the specified properties.
     * @function create
     * @memberof DDSketch
     * @static
     * @param {IDDSketch=} [properties] Properties to set
     * @returns {DDSketch} DDSketch instance
     */
    DDSketch.create = function create(properties) {
        return new DDSketch(properties);
    };
    /**
     * Encodes the specified DDSketch message. Does not implicitly {@link DDSketch.verify|verify} messages.
     * @function encode
     * @memberof DDSketch
     * @static
     * @param {IDDSketch} message DDSketch message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DDSketch.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.mapping != null && Object.hasOwnProperty.call(message, "mapping"))
            $root.IndexMapping.encode(message.mapping, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        if (message.positiveValues != null && Object.hasOwnProperty.call(message, "positiveValues"))
            $root.Store.encode(message.positiveValues, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
        if (message.negativeValues != null && Object.hasOwnProperty.call(message, "negativeValues"))
            $root.Store.encode(message.negativeValues, writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
        if (message.zeroCount != null && Object.hasOwnProperty.call(message, "zeroCount"))
            writer.uint32(/* id 4, wireType 1 =*/ 33).double(message.zeroCount);
        return writer;
    };
    /**
     * Encodes the specified DDSketch message, length delimited. Does not implicitly {@link DDSketch.verify|verify} messages.
     * @function encodeDelimited
     * @memberof DDSketch
     * @static
     * @param {IDDSketch} message DDSketch message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DDSketch.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };
    /**
     * Decodes a DDSketch message from the specified reader or buffer.
     * @function decode
     * @memberof DDSketch
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {DDSketch} DDSketch
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DDSketch.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.DDSketch();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.mapping = $root.IndexMapping.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.positiveValues = $root.Store.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.negativeValues = $root.Store.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.zeroCount = reader.double();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    /**
     * Decodes a DDSketch message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof DDSketch
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {DDSketch} DDSketch
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DDSketch.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };
    /**
     * Verifies a DDSketch message.
     * @function verify
     * @memberof DDSketch
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    DDSketch.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.mapping != null && message.hasOwnProperty("mapping")) {
            var error = $root.IndexMapping.verify(message.mapping);
            if (error)
                return "mapping." + error;
        }
        if (message.positiveValues != null && message.hasOwnProperty("positiveValues")) {
            var error = $root.Store.verify(message.positiveValues);
            if (error)
                return "positiveValues." + error;
        }
        if (message.negativeValues != null && message.hasOwnProperty("negativeValues")) {
            var error = $root.Store.verify(message.negativeValues);
            if (error)
                return "negativeValues." + error;
        }
        if (message.zeroCount != null && message.hasOwnProperty("zeroCount"))
            if (typeof message.zeroCount !== "number")
                return "zeroCount: number expected";
        return null;
    };
    /**
     * Creates a DDSketch message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof DDSketch
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {DDSketch} DDSketch
     */
    DDSketch.fromObject = function fromObject(object) {
        if (object instanceof $root.DDSketch)
            return object;
        var message = new $root.DDSketch();
        if (object.mapping != null) {
            if (typeof object.mapping !== "object")
                throw TypeError(".DDSketch.mapping: object expected");
            message.mapping = $root.IndexMapping.fromObject(object.mapping);
        }
        if (object.positiveValues != null) {
            if (typeof object.positiveValues !== "object")
                throw TypeError(".DDSketch.positiveValues: object expected");
            message.positiveValues = $root.Store.fromObject(object.positiveValues);
        }
        if (object.negativeValues != null) {
            if (typeof object.negativeValues !== "object")
                throw TypeError(".DDSketch.negativeValues: object expected");
            message.negativeValues = $root.Store.fromObject(object.negativeValues);
        }
        if (object.zeroCount != null)
            message.zeroCount = Number(object.zeroCount);
        return message;
    };
    /**
     * Creates a plain object from a DDSketch message. Also converts values to other types if specified.
     * @function toObject
     * @memberof DDSketch
     * @static
     * @param {DDSketch} message DDSketch
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    DDSketch.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.mapping = null;
            object.positiveValues = null;
            object.negativeValues = null;
            object.zeroCount = 0;
        }
        if (message.mapping != null && message.hasOwnProperty("mapping"))
            object.mapping = $root.IndexMapping.toObject(message.mapping, options);
        if (message.positiveValues != null && message.hasOwnProperty("positiveValues"))
            object.positiveValues = $root.Store.toObject(message.positiveValues, options);
        if (message.negativeValues != null && message.hasOwnProperty("negativeValues"))
            object.negativeValues = $root.Store.toObject(message.negativeValues, options);
        if (message.zeroCount != null && message.hasOwnProperty("zeroCount"))
            object.zeroCount = options.json && !isFinite(message.zeroCount) ? String(message.zeroCount) : message.zeroCount;
        return object;
    };
    /**
     * Converts this DDSketch to JSON.
     * @function toJSON
     * @memberof DDSketch
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    DDSketch.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };
    return DDSketch;
})();
$root.IndexMapping = (function () {
    /**
     * Properties of an IndexMapping.
     * @exports IIndexMapping
     * @interface IIndexMapping
     * @property {number|null} [gamma] IndexMapping gamma
     * @property {number|null} [indexOffset] IndexMapping indexOffset
     * @property {IndexMapping.Interpolation|null} [interpolation] IndexMapping interpolation
     */
    /**
     * Constructs a new IndexMapping.
     * @exports IndexMapping
     * @classdesc Represents an IndexMapping.
     * @implements IIndexMapping
     * @constructor
     * @param {IIndexMapping=} [properties] Properties to set
     */
    function IndexMapping(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * IndexMapping gamma.
     * @member {number} gamma
     * @memberof IndexMapping
     * @instance
     */
    IndexMapping.prototype.gamma = 0;
    /**
     * IndexMapping indexOffset.
     * @member {number} indexOffset
     * @memberof IndexMapping
     * @instance
     */
    IndexMapping.prototype.indexOffset = 0;
    /**
     * IndexMapping interpolation.
     * @member {IndexMapping.Interpolation} interpolation
     * @memberof IndexMapping
     * @instance
     */
    IndexMapping.prototype.interpolation = 0;
    /**
     * Creates a new IndexMapping instance using the specified properties.
     * @function create
     * @memberof IndexMapping
     * @static
     * @param {IIndexMapping=} [properties] Properties to set
     * @returns {IndexMapping} IndexMapping instance
     */
    IndexMapping.create = function create(properties) {
        return new IndexMapping(properties);
    };
    /**
     * Encodes the specified IndexMapping message. Does not implicitly {@link IndexMapping.verify|verify} messages.
     * @function encode
     * @memberof IndexMapping
     * @static
     * @param {IIndexMapping} message IndexMapping message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    IndexMapping.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.gamma != null && Object.hasOwnProperty.call(message, "gamma"))
            writer.uint32(/* id 1, wireType 1 =*/ 9).double(message.gamma);
        if (message.indexOffset != null && Object.hasOwnProperty.call(message, "indexOffset"))
            writer.uint32(/* id 2, wireType 1 =*/ 17).double(message.indexOffset);
        if (message.interpolation != null && Object.hasOwnProperty.call(message, "interpolation"))
            writer.uint32(/* id 3, wireType 0 =*/ 24).int32(message.interpolation);
        return writer;
    };
    /**
     * Encodes the specified IndexMapping message, length delimited. Does not implicitly {@link IndexMapping.verify|verify} messages.
     * @function encodeDelimited
     * @memberof IndexMapping
     * @static
     * @param {IIndexMapping} message IndexMapping message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    IndexMapping.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };
    /**
     * Decodes an IndexMapping message from the specified reader or buffer.
     * @function decode
     * @memberof IndexMapping
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {IndexMapping} IndexMapping
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    IndexMapping.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.IndexMapping();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.gamma = reader.double();
                    break;
                case 2:
                    message.indexOffset = reader.double();
                    break;
                case 3:
                    message.interpolation = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    /**
     * Decodes an IndexMapping message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof IndexMapping
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {IndexMapping} IndexMapping
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    IndexMapping.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };
    /**
     * Verifies an IndexMapping message.
     * @function verify
     * @memberof IndexMapping
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    IndexMapping.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.gamma != null && message.hasOwnProperty("gamma"))
            if (typeof message.gamma !== "number")
                return "gamma: number expected";
        if (message.indexOffset != null && message.hasOwnProperty("indexOffset"))
            if (typeof message.indexOffset !== "number")
                return "indexOffset: number expected";
        if (message.interpolation != null && message.hasOwnProperty("interpolation"))
            switch (message.interpolation) {
                default:
                    return "interpolation: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
            }
        return null;
    };
    /**
     * Creates an IndexMapping message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof IndexMapping
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {IndexMapping} IndexMapping
     */
    IndexMapping.fromObject = function fromObject(object) {
        if (object instanceof $root.IndexMapping)
            return object;
        var message = new $root.IndexMapping();
        if (object.gamma != null)
            message.gamma = Number(object.gamma);
        if (object.indexOffset != null)
            message.indexOffset = Number(object.indexOffset);
        switch (object.interpolation) {
            case "NONE":
            case 0:
                message.interpolation = 0;
                break;
            case "LINEAR":
            case 1:
                message.interpolation = 1;
                break;
            case "QUADRATIC":
            case 2:
                message.interpolation = 2;
                break;
            case "CUBIC":
            case 3:
                message.interpolation = 3;
                break;
        }
        return message;
    };
    /**
     * Creates a plain object from an IndexMapping message. Also converts values to other types if specified.
     * @function toObject
     * @memberof IndexMapping
     * @static
     * @param {IndexMapping} message IndexMapping
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    IndexMapping.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.gamma = 0;
            object.indexOffset = 0;
            object.interpolation = options.enums === String ? "NONE" : 0;
        }
        if (message.gamma != null && message.hasOwnProperty("gamma"))
            object.gamma = options.json && !isFinite(message.gamma) ? String(message.gamma) : message.gamma;
        if (message.indexOffset != null && message.hasOwnProperty("indexOffset"))
            object.indexOffset = options.json && !isFinite(message.indexOffset) ? String(message.indexOffset) : message.indexOffset;
        if (message.interpolation != null && message.hasOwnProperty("interpolation"))
            object.interpolation = options.enums === String ? $root.IndexMapping.Interpolation[message.interpolation] : message.interpolation;
        return object;
    };
    /**
     * Converts this IndexMapping to JSON.
     * @function toJSON
     * @memberof IndexMapping
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    IndexMapping.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };
    /**
     * Interpolation enum.
     * @name IndexMapping.Interpolation
     * @enum {number}
     * @property {number} NONE=0 NONE value
     * @property {number} LINEAR=1 LINEAR value
     * @property {number} QUADRATIC=2 QUADRATIC value
     * @property {number} CUBIC=3 CUBIC value
     */
    IndexMapping.Interpolation = (function () {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "NONE"] = 0;
        values[valuesById[1] = "LINEAR"] = 1;
        values[valuesById[2] = "QUADRATIC"] = 2;
        values[valuesById[3] = "CUBIC"] = 3;
        return values;
    })();
    return IndexMapping;
})();
$root.Store = (function () {
    /**
     * Properties of a Store.
     * @exports IStore
     * @interface IStore
     * @property {Object.<string,number>|null} [binCounts] Store binCounts
     * @property {Array.<number>|null} [contiguousBinCounts] Store contiguousBinCounts
     * @property {number|null} [contiguousBinIndexOffset] Store contiguousBinIndexOffset
     */
    /**
     * Constructs a new Store.
     * @exports Store
     * @classdesc Represents a Store.
     * @implements IStore
     * @constructor
     * @param {IStore=} [properties] Properties to set
     */
    function Store(properties) {
        this.binCounts = {};
        this.contiguousBinCounts = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * Store binCounts.
     * @member {Object.<string,number>} binCounts
     * @memberof Store
     * @instance
     */
    Store.prototype.binCounts = $util.emptyObject;
    /**
     * Store contiguousBinCounts.
     * @member {Array.<number>} contiguousBinCounts
     * @memberof Store
     * @instance
     */
    Store.prototype.contiguousBinCounts = $util.emptyArray;
    /**
     * Store contiguousBinIndexOffset.
     * @member {number} contiguousBinIndexOffset
     * @memberof Store
     * @instance
     */
    Store.prototype.contiguousBinIndexOffset = 0;
    /**
     * Creates a new Store instance using the specified properties.
     * @function create
     * @memberof Store
     * @static
     * @param {IStore=} [properties] Properties to set
     * @returns {Store} Store instance
     */
    Store.create = function create(properties) {
        return new Store(properties);
    };
    /**
     * Encodes the specified Store message. Does not implicitly {@link Store.verify|verify} messages.
     * @function encode
     * @memberof Store
     * @static
     * @param {IStore} message Store message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Store.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.binCounts != null && Object.hasOwnProperty.call(message, "binCounts"))
            for (var keys = Object.keys(message.binCounts), i = 0; i < keys.length; ++i)
                writer.uint32(/* id 1, wireType 2 =*/ 10).fork().uint32(/* id 1, wireType 0 =*/ 8).sint32(keys[i]).uint32(/* id 2, wireType 1 =*/ 17).double(message.binCounts[keys[i]]).ldelim();
        if (message.contiguousBinCounts != null && message.contiguousBinCounts.length) {
            writer.uint32(/* id 2, wireType 2 =*/ 18).fork();
            for (var i = 0; i < message.contiguousBinCounts.length; ++i)
                writer.double(message.contiguousBinCounts[i]);
            writer.ldelim();
        }
        if (message.contiguousBinIndexOffset != null && Object.hasOwnProperty.call(message, "contiguousBinIndexOffset"))
            writer.uint32(/* id 3, wireType 0 =*/ 24).sint32(message.contiguousBinIndexOffset);
        return writer;
    };
    /**
     * Encodes the specified Store message, length delimited. Does not implicitly {@link Store.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Store
     * @static
     * @param {IStore} message Store message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Store.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };
    /**
     * Decodes a Store message from the specified reader or buffer.
     * @function decode
     * @memberof Store
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Store} Store
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Store.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Store(), key, value;
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (message.binCounts === $util.emptyObject)
                        message.binCounts = {};
                    var end2 = reader.uint32() + reader.pos;
                    key = 0;
                    value = 0;
                    while (reader.pos < end2) {
                        var tag2 = reader.uint32();
                        switch (tag2 >>> 3) {
                            case 1:
                                key = reader.sint32();
                                break;
                            case 2:
                                value = reader.double();
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                        }
                    }
                    message.binCounts[key] = value;
                    break;
                case 2:
                    if (!(message.contiguousBinCounts && message.contiguousBinCounts.length))
                        message.contiguousBinCounts = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.contiguousBinCounts.push(reader.double());
                    }
                    else
                        message.contiguousBinCounts.push(reader.double());
                    break;
                case 3:
                    message.contiguousBinIndexOffset = reader.sint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    /**
     * Decodes a Store message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Store
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Store} Store
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Store.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };
    /**
     * Verifies a Store message.
     * @function verify
     * @memberof Store
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    Store.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.binCounts != null && message.hasOwnProperty("binCounts")) {
            if (!$util.isObject(message.binCounts))
                return "binCounts: object expected";
            var key = Object.keys(message.binCounts);
            for (var i = 0; i < key.length; ++i) {
                if (!$util.key32Re.test(key[i]))
                    return "binCounts: integer key{k:sint32} expected";
                if (typeof message.binCounts[key[i]] !== "number")
                    return "binCounts: number{k:sint32} expected";
            }
        }
        if (message.contiguousBinCounts != null && message.hasOwnProperty("contiguousBinCounts")) {
            if (!Array.isArray(message.contiguousBinCounts))
                return "contiguousBinCounts: array expected";
            for (var i = 0; i < message.contiguousBinCounts.length; ++i)
                if (typeof message.contiguousBinCounts[i] !== "number")
                    return "contiguousBinCounts: number[] expected";
        }
        if (message.contiguousBinIndexOffset != null && message.hasOwnProperty("contiguousBinIndexOffset"))
            if (!$util.isInteger(message.contiguousBinIndexOffset))
                return "contiguousBinIndexOffset: integer expected";
        return null;
    };
    /**
     * Creates a Store message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Store
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Store} Store
     */
    Store.fromObject = function fromObject(object) {
        if (object instanceof $root.Store)
            return object;
        var message = new $root.Store();
        if (object.binCounts) {
            if (typeof object.binCounts !== "object")
                throw TypeError(".Store.binCounts: object expected");
            message.binCounts = {};
            for (var keys = Object.keys(object.binCounts), i = 0; i < keys.length; ++i)
                message.binCounts[keys[i]] = Number(object.binCounts[keys[i]]);
        }
        if (object.contiguousBinCounts) {
            if (!Array.isArray(object.contiguousBinCounts))
                throw TypeError(".Store.contiguousBinCounts: array expected");
            message.contiguousBinCounts = [];
            for (var i = 0; i < object.contiguousBinCounts.length; ++i)
                message.contiguousBinCounts[i] = Number(object.contiguousBinCounts[i]);
        }
        if (object.contiguousBinIndexOffset != null)
            message.contiguousBinIndexOffset = object.contiguousBinIndexOffset | 0;
        return message;
    };
    /**
     * Creates a plain object from a Store message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Store
     * @static
     * @param {Store} message Store
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    Store.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults)
            object.contiguousBinCounts = [];
        if (options.objects || options.defaults)
            object.binCounts = {};
        if (options.defaults)
            object.contiguousBinIndexOffset = 0;
        var keys2;
        if (message.binCounts && (keys2 = Object.keys(message.binCounts)).length) {
            object.binCounts = {};
            for (var j = 0; j < keys2.length; ++j)
                object.binCounts[keys2[j]] = options.json && !isFinite(message.binCounts[keys2[j]]) ? String(message.binCounts[keys2[j]]) : message.binCounts[keys2[j]];
        }
        if (message.contiguousBinCounts && message.contiguousBinCounts.length) {
            object.contiguousBinCounts = [];
            for (var j = 0; j < message.contiguousBinCounts.length; ++j)
                object.contiguousBinCounts[j] = options.json && !isFinite(message.contiguousBinCounts[j]) ? String(message.contiguousBinCounts[j]) : message.contiguousBinCounts[j];
        }
        if (message.contiguousBinIndexOffset != null && message.hasOwnProperty("contiguousBinIndexOffset"))
            object.contiguousBinIndexOffset = message.contiguousBinIndexOffset;
        return object;
    };
    /**
     * Converts this Store to JSON.
     * @function toJSON
     * @memberof Store
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    Store.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };
    return Store;
})();
module.exports = $root;


/***/ }),

/***/ "../../node_modules/@datadog/sketches-js/dist/ddsketch/store/CollapsingHighestDenseStore.js":
/*!*******************************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/@datadog/sketches-js/dist/ddsketch/store/CollapsingHighestDenseStore.js ***!
  \*******************************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Unless explicitly stated otherwise all files in this repository are licensed
 * under the Apache 2.0 license (see LICENSE).
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020 Datadog, Inc.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.CollapsingHighestDenseStore = void 0;
var DenseStore_1 = __webpack_require__(/*! ./DenseStore */ "../../node_modules/@datadog/sketches-js/dist/ddsketch/store/DenseStore.js");
var util_1 = __webpack_require__(/*! ./util */ "../../node_modules/@datadog/sketches-js/dist/ddsketch/store/util.js");
/**
 * `CollapsingHighestDenseStore` is a dense store that keeps all the bins between
 * the bin for the `minKey` and the `maxKey`, but collapsing the left-most bins
 * if the number of bins exceeds `binLimit`
 */
var CollapsingHighestDenseStore = /** @class */ (function (_super) {
    __extends(CollapsingHighestDenseStore, _super);
    /**
     * Initialize a new CollapsingHighestDenseStore
     *
     * @param binLimit The maximum number of bins
     * @param chunkSize The number of bins to add each time the bins grow (default 128)
     */
    function CollapsingHighestDenseStore(binLimit, chunkSize) {
        var _this = _super.call(this, chunkSize) || this;
        _this.binLimit = binLimit;
        _this.isCollapsed = false;
        return _this;
    }
    /**
     * Merge the contents of the parameter `store` into this store
     *
     * @param store The store to merge into the caller store
     */
    CollapsingHighestDenseStore.prototype.merge = function (store) {
        if (store.count === 0) {
            return;
        }
        if (this.count === 0) {
            this.copy(store);
            return;
        }
        if (store.minKey < this.minKey || store.maxKey > this.maxKey) {
            this._extendRange(store.minKey, store.maxKey);
        }
        var collapseEndIndex = store.maxKey - store.offset + 1;
        var collapseStartIndex = Math.max(this.maxKey + 1, store.minKey) - store.offset;
        if (collapseEndIndex > collapseStartIndex) {
            var collapseCount = util_1.sumOfRange(store.bins, collapseStartIndex, collapseEndIndex);
            this.bins[this.length() - 1] += collapseCount;
        }
        else {
            collapseStartIndex = collapseEndIndex;
        }
        for (var key = store.minKey; key < collapseStartIndex + store.offset; key++) {
            this.bins[key - this.offset] += store.bins[key - store.offset];
        }
        this.count += store.count;
    };
    /**
     * Directly clone the contents of the parameter `store` into this store
     *
     * @param store The store to be copied into the caller store
     */
    CollapsingHighestDenseStore.prototype.copy = function (store) {
        _super.prototype.copy.call(this, store);
        this.isCollapsed = store.isCollapsed;
    };
    CollapsingHighestDenseStore.prototype._getNewLength = function (newMinKey, newMaxKey) {
        var desiredLength = newMaxKey - newMinKey + 1;
        return Math.min(this.chunkSize * Math.ceil(desiredLength / this.chunkSize), this.binLimit);
    };
    /**
     * Adjust the `bins`, the `offset`, the `minKey`, and the `maxKey`
     * without resizing the bins, in order to try to make it fit the specified range.
     * Collapse to the left if necessary
     */
    CollapsingHighestDenseStore.prototype._adjust = function (newMinKey, newMaxKey) {
        if (newMaxKey - newMinKey + 1 > this.length()) {
            // The range of keys is too wide, the lowest bins need to be collapsed
            newMaxKey = newMinKey + this.length() + 1;
            if (newMaxKey <= this.minKey) {
                // Put everything in the first bin
                this.offset = newMinKey;
                this.maxKey = newMaxKey;
                this.bins.fill(0);
                this.bins[this.length() - 1] = this.count;
            }
            else {
                var shift = this.offset - newMinKey;
                if (shift > 0) {
                    var collapseStartIndex = newMaxKey - this.offset + 1;
                    var collapseEndIndex = this.maxKey - this.offset + 1;
                    var collapsedCount = util_1.sumOfRange(this.bins, collapseStartIndex, collapseEndIndex);
                    this.bins.fill(0, collapseStartIndex, collapseEndIndex);
                    this.bins[collapseStartIndex - 1] += collapsedCount;
                    this.maxKey = newMaxKey;
                    this._shiftBins(shift);
                }
                else {
                    this.maxKey = newMaxKey;
                    // Shift the buckets to make room for newMinKey
                    this._shiftBins(shift);
                }
                this.minKey = newMinKey;
                this.isCollapsed = true;
            }
        }
        else {
            this._centerBins(newMinKey, newMaxKey);
            this.minKey = newMinKey;
            this.maxKey = newMaxKey;
        }
    };
    /** Calculate the bin index for the key, extending the range if necessary */
    CollapsingHighestDenseStore.prototype._getIndex = function (key) {
        if (key < this.minKey) {
            if (this.isCollapsed) {
                return this.length() - 1;
            }
            this._extendRange(key);
            if (this.isCollapsed) {
                return this.length() - 1;
            }
        }
        else if (key > this.maxKey) {
            this._extendRange(key);
        }
        return key - this.offset;
    };
    return CollapsingHighestDenseStore;
}(DenseStore_1.DenseStore));
exports.CollapsingHighestDenseStore = CollapsingHighestDenseStore;


/***/ }),

/***/ "../../node_modules/@datadog/sketches-js/dist/ddsketch/store/CollapsingLowestDenseStore.js":
/*!******************************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/@datadog/sketches-js/dist/ddsketch/store/CollapsingLowestDenseStore.js ***!
  \******************************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Unless explicitly stated otherwise all files in this repository are licensed
 * under the Apache 2.0 license (see LICENSE).
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020 Datadog, Inc.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.CollapsingLowestDenseStore = void 0;
var DenseStore_1 = __webpack_require__(/*! ./DenseStore */ "../../node_modules/@datadog/sketches-js/dist/ddsketch/store/DenseStore.js");
var util_1 = __webpack_require__(/*! ./util */ "../../node_modules/@datadog/sketches-js/dist/ddsketch/store/util.js");
/**
 * `CollapsingLowestDenseStore` is a dense store that keeps all the bins between
 * the bin for the `minKey` and the `maxKey`, but collapsing the left-most bins
 * if the number of bins exceeds `binLimit`
 */
var CollapsingLowestDenseStore = /** @class */ (function (_super) {
    __extends(CollapsingLowestDenseStore, _super);
    /**
     * Initialize a new CollapsingLowestDenseStore
     *
     * @param binLimit The maximum number of bins
     * @param chunkSize The number of bins to add each time the bins grow (default 128)
     */
    function CollapsingLowestDenseStore(binLimit, chunkSize) {
        var _this = _super.call(this, chunkSize) || this;
        _this.binLimit = binLimit;
        _this.isCollapsed = false;
        return _this;
    }
    /**
     * Merge the contents of the parameter `store` into this store
     *
     * @param store The store to merge into the caller store
     */
    CollapsingLowestDenseStore.prototype.merge = function (store) {
        if (store.count === 0) {
            return;
        }
        if (this.count === 0) {
            this.copy(store);
            return;
        }
        if (store.minKey < this.minKey || store.maxKey > this.maxKey) {
            this._extendRange(store.minKey, store.maxKey);
        }
        var collapseStartIndex = store.minKey - store.offset;
        var collapseEndIndex = Math.min(this.minKey, store.maxKey + 1) - store.offset;
        if (collapseEndIndex > collapseStartIndex) {
            var collapseCount = util_1.sumOfRange(store.bins, collapseStartIndex, collapseEndIndex);
            this.bins[0] += collapseCount;
        }
        else {
            collapseEndIndex = collapseStartIndex;
        }
        for (var key = collapseEndIndex + store.offset; key < store.maxKey + 1; key++) {
            this.bins[key - this.offset] += store.bins[key - store.offset];
        }
        this.count += store.count;
    };
    /**
     * Directly clone the contents of the parameter `store` into this store
     *
     * @param store The store to be copied into the caller store
     */
    CollapsingLowestDenseStore.prototype.copy = function (store) {
        _super.prototype.copy.call(this, store);
        this.isCollapsed = store.isCollapsed;
    };
    CollapsingLowestDenseStore.prototype._getNewLength = function (newMinKey, newMaxKey) {
        var desiredLength = newMaxKey - newMinKey + 1;
        return Math.min(this.chunkSize * Math.ceil(desiredLength / this.chunkSize), this.binLimit);
    };
    /**
     * Adjust the `bins`, the `offset`, the `minKey`, and the `maxKey`
     * without resizing the bins, in order to try to make it fit the specified range.
     * Collapse to the left if necessary
     */
    CollapsingLowestDenseStore.prototype._adjust = function (newMinKey, newMaxKey) {
        if (newMaxKey - newMinKey + 1 > this.length()) {
            // The range of keys is too wide, the lowest bins need to be collapsed
            newMinKey = newMaxKey - this.length() + 1;
            if (newMinKey >= this.maxKey) {
                // Put everything in the first bin
                this.offset = newMinKey;
                this.minKey = newMinKey;
                this.bins.fill(0);
                this.bins[0] = this.count;
            }
            else {
                var shift = this.offset - newMinKey;
                if (shift < 0) {
                    var collapseStartIndex = this.minKey - this.offset;
                    var collapseEndIndex = newMinKey - this.offset;
                    var collapsedCount = util_1.sumOfRange(this.bins, collapseStartIndex, collapseEndIndex);
                    this.bins.fill(0, collapseStartIndex, collapseEndIndex);
                    this.bins[collapseEndIndex] += collapsedCount;
                    this.minKey = newMinKey;
                    this._shiftBins(shift);
                }
                else {
                    this.minKey = newMinKey;
                    // Shift the buckets to make room for newMinKey
                    this._shiftBins(shift);
                }
            }
            this.maxKey = newMaxKey;
            this.isCollapsed = true;
        }
        else {
            this._centerBins(newMinKey, newMaxKey);
            this.minKey = newMinKey;
            this.maxKey = newMaxKey;
        }
    };
    /** Calculate the bin index for the key, extending the range if necessary */
    CollapsingLowestDenseStore.prototype._getIndex = function (key) {
        if (key < this.minKey) {
            if (this.isCollapsed) {
                return 0;
            }
            this._extendRange(key);
            if (this.isCollapsed) {
                return 0;
            }
        }
        else if (key > this.maxKey) {
            this._extendRange(key);
        }
        return key - this.offset;
    };
    return CollapsingLowestDenseStore;
}(DenseStore_1.DenseStore));
exports.CollapsingLowestDenseStore = CollapsingLowestDenseStore;


/***/ }),

/***/ "../../node_modules/@datadog/sketches-js/dist/ddsketch/store/DenseStore.js":
/*!**************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/@datadog/sketches-js/dist/ddsketch/store/DenseStore.js ***!
  \**************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Unless explicitly stated otherwise all files in this repository are licensed
 * under the Apache 2.0 license (see LICENSE).
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020 Datadog, Inc.
 */
var __spreadArray = (this && this.__spreadArray) || function (to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
    return to;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DenseStore = void 0;
var util_1 = __webpack_require__(/*! ./util */ "../../node_modules/@datadog/sketches-js/dist/ddsketch/store/util.js");
var compiled_1 = __webpack_require__(/*! ../proto/compiled */ "../../node_modules/@datadog/sketches-js/dist/ddsketch/proto/compiled.js");
/** The default number of bins to grow when necessary */
var CHUNK_SIZE = 128;
/**
 * `DenseStore` is a store that keeps all the bins between
 * the bin for the `minKey` and the `maxKey`.
 */
var DenseStore = /** @class */ (function () {
    /**
     * Initialize a new DenseStore
     *
     * @param chunkSize The number of bins to add each time the bins grow (default 128)
     */
    function DenseStore(chunkSize) {
        if (chunkSize === void 0) { chunkSize = CHUNK_SIZE; }
        this.chunkSize = chunkSize;
        this.bins = [];
        this.count = 0;
        this.minKey = Infinity;
        this.maxKey = -Infinity;
        this.offset = 0;
    }
    /**
     * Update the counter at the specified index key, growing the number of bins if necessary
     *
     * @param key The key of the index to update
     * @param weight The amount to weight the key (default 1.0)
     */
    DenseStore.prototype.add = function (key, weight) {
        if (weight === void 0) { weight = 1; }
        var index = this._getIndex(key);
        this.bins[index] += weight;
        this.count += weight;
    };
    /**
     * Return the key for the value at the given rank
     *
     * E.g., if the non-zero bins are [1, 1] for keys a, b with no offset
     *
     * if lower = True:
     *     keyAtRank(x) = a for x in [0, 1)
     *     keyAtRank(x) = b for x in [1, 2)
     * if lower = False:
     *     keyAtRank(x) = a for x in (-1, 0]
     *     keyAtRank(x) = b for x in (0, 1]
     *
     * @param rank The rank at which to retrieve the key
     */
    DenseStore.prototype.keyAtRank = function (rank, lower) {
        if (lower === void 0) { lower = true; }
        var runningCount = 0;
        for (var i = 0; i < this.length(); i++) {
            var bin = this.bins[i];
            runningCount += bin;
            if ((lower && runningCount > rank) ||
                (!lower && runningCount >= rank + 1)) {
                return i + this.offset;
            }
        }
        return this.maxKey;
    };
    /**
     * Merge the contents of the parameter `store` into this store
     *
     * @param store The store to merge into the caller store
     */
    DenseStore.prototype.merge = function (store) {
        if (store.count === 0) {
            return;
        }
        if (this.count === 0) {
            this.copy(store);
            return;
        }
        if (store.minKey < this.minKey || store.maxKey > this.maxKey) {
            this._extendRange(store.minKey, store.maxKey);
        }
        var collapseStartIndex = store.minKey - store.offset;
        var collapseEndIndex = Math.min(this.minKey, store.maxKey + 1) - store.offset;
        if (collapseEndIndex > collapseStartIndex) {
            var collapseCount = util_1.sumOfRange(store.bins, collapseStartIndex, collapseEndIndex);
            this.bins[0] += collapseCount;
        }
        else {
            collapseEndIndex = collapseStartIndex;
        }
        for (var key = collapseEndIndex + store.offset; key < store.maxKey + 1; key++) {
            this.bins[key - this.offset] += store.bins[key - store.offset];
        }
        this.count += store.count;
    };
    /**
     * Directly clone the contents of the parameter `store` into this store
     *
     * @param store The store to be copied into the caller store
     */
    DenseStore.prototype.copy = function (store) {
        this.bins = __spreadArray([], store.bins);
        this.count = store.count;
        this.minKey = store.minKey;
        this.maxKey = store.maxKey;
        this.offset = store.offset;
    };
    /**
     * Return the length of the underlying storage (`bins`)
     */
    DenseStore.prototype.length = function () {
        return this.bins.length;
    };
    DenseStore.prototype._getNewLength = function (newMinKey, newMaxKey) {
        var desiredLength = newMaxKey - newMinKey + 1;
        return this.chunkSize * Math.ceil(desiredLength / this.chunkSize);
    };
    /**
     * Adjust the `bins`, the `offset`, the `minKey`, and the `maxKey`
     * without resizing the bins, in order to try to make it fit the specified range.
     * Collapse to the left if necessary
     */
    DenseStore.prototype._adjust = function (newMinKey, newMaxKey) {
        this._centerBins(newMinKey, newMaxKey);
        this.minKey = newMinKey;
        this.maxKey = newMaxKey;
    };
    /** Shift the bins by `shift`. This changes the `offset` */
    DenseStore.prototype._shiftBins = function (shift) {
        var _a, _b;
        if (shift > 0) {
            this.bins = this.bins.slice(0, -shift);
            (_a = this.bins).unshift.apply(_a, new Array(shift).fill(0));
        }
        else {
            this.bins = this.bins.slice(Math.abs(shift));
            (_b = this.bins).push.apply(_b, new Array(Math.abs(shift)).fill(0));
        }
        this.offset -= shift;
    };
    /** Center the bins. This changes the `offset` */
    DenseStore.prototype._centerBins = function (newMinKey, newMaxKey) {
        var middleKey = newMinKey + Math.floor((newMaxKey - newMinKey + 1) / 2);
        this._shiftBins(Math.floor(this.offset + this.length() / 2) - middleKey);
    };
    /** Grow the bins as necessary, and call _adjust */
    DenseStore.prototype._extendRange = function (key, secondKey) {
        var _a;
        secondKey = secondKey || key;
        var newMinKey = Math.min(key, secondKey, this.minKey);
        var newMaxKey = Math.max(key, secondKey, this.maxKey);
        if (this.length() === 0) {
            this.bins = new Array(this._getNewLength(newMinKey, newMaxKey)).fill(0);
            this.offset = newMinKey;
            this._adjust(newMinKey, newMaxKey);
        }
        else if (newMinKey >= this.minKey &&
            newMaxKey < this.offset + this.length()) {
            // No need to change the range, just update the min and max keys
            this.minKey = newMinKey;
            this.maxKey = newMaxKey;
        }
        else {
            // Grow the bins
            var newLength = this._getNewLength(newMinKey, newMaxKey);
            if (newLength > this.length()) {
                (_a = this.bins).push.apply(_a, new Array(newLength - this.length()).fill(0));
            }
            this._adjust(newMinKey, newMaxKey);
        }
    };
    /** Calculate the bin index for the key, extending the range if necessary */
    DenseStore.prototype._getIndex = function (key) {
        if (key < this.minKey) {
            this._extendRange(key);
        }
        else if (key > this.maxKey) {
            this._extendRange(key);
        }
        return key - this.offset;
    };
    DenseStore.prototype.toProto = function () {
        return compiled_1.Store.create({
            contiguousBinCounts: this.bins,
            contiguousBinIndexOffset: this.offset
        });
    };
    DenseStore.fromProto = function (protoStore) {
        if (!protoStore ||
            /* Double equals (==) is intentional here to check for
             * `null` | `undefined` without including `0` */
            protoStore.contiguousBinCounts == null ||
            protoStore.contiguousBinIndexOffset == null) {
            throw Error('Failed to decode store from protobuf');
        }
        var store = new this();
        var index = protoStore.contiguousBinIndexOffset;
        store.offset = index;
        for (var _i = 0, _a = protoStore.contiguousBinCounts; _i < _a.length; _i++) {
            var count = _a[_i];
            store.add(index, count);
            index += 1;
        }
        return store;
    };
    return DenseStore;
}());
exports.DenseStore = DenseStore;


/***/ }),

/***/ "../../node_modules/@datadog/sketches-js/dist/ddsketch/store/index.js":
/*!*********************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/@datadog/sketches-js/dist/ddsketch/store/index.js ***!
  \*********************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Unless explicitly stated otherwise all files in this repository are licensed
 * under the Apache 2.0 license (see LICENSE).
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020 Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.CollapsingHighestDenseStore = exports.CollapsingLowestDenseStore = exports.DenseStore = void 0;
var DenseStore_1 = __webpack_require__(/*! ./DenseStore */ "../../node_modules/@datadog/sketches-js/dist/ddsketch/store/DenseStore.js");
Object.defineProperty(exports, "DenseStore", { enumerable: true, get: function () { return DenseStore_1.DenseStore; } });
var CollapsingLowestDenseStore_1 = __webpack_require__(/*! ./CollapsingLowestDenseStore */ "../../node_modules/@datadog/sketches-js/dist/ddsketch/store/CollapsingLowestDenseStore.js");
Object.defineProperty(exports, "CollapsingLowestDenseStore", { enumerable: true, get: function () { return CollapsingLowestDenseStore_1.CollapsingLowestDenseStore; } });
var CollapsingHighestDenseStore_1 = __webpack_require__(/*! ./CollapsingHighestDenseStore */ "../../node_modules/@datadog/sketches-js/dist/ddsketch/store/CollapsingHighestDenseStore.js");
Object.defineProperty(exports, "CollapsingHighestDenseStore", { enumerable: true, get: function () { return CollapsingHighestDenseStore_1.CollapsingHighestDenseStore; } });


/***/ }),

/***/ "../../node_modules/@datadog/sketches-js/dist/ddsketch/store/util.js":
/*!********************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/@datadog/sketches-js/dist/ddsketch/store/util.js ***!
  \********************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Unless explicitly stated otherwise all files in this repository are licensed
 * under the Apache 2.0 license (see LICENSE).
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020 Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.sumOfRange = void 0;
/**
 * Return the sum of the values from range `start` to `end` in `array`
 */
var sumOfRange = function (array, start, end) {
    var sum = 0;
    for (var i = start; i <= end; i++) {
        sum += array[i];
    }
    return sum;
};
exports.sumOfRange = sumOfRange;


/***/ }),

/***/ "../../node_modules/@datadog/sketches-js/dist/index.js":
/*!******************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/@datadog/sketches-js/dist/index.js ***!
  \******************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Unless explicitly stated otherwise all files in this repository are licensed
 * under the Apache 2.0 license (see LICENSE).
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020 Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.DDSketch = void 0;
var ddsketch_1 = __webpack_require__(/*! ./ddsketch */ "../../node_modules/@datadog/sketches-js/dist/ddsketch/index.js");
Object.defineProperty(exports, "DDSketch", { enumerable: true, get: function () { return ddsketch_1.DDSketch; } });


/***/ }),

/***/ "../../node_modules/@graphql-toolkit/common/node_modules/graphql-tools/index.esm.js":
/*!***********************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/@graphql-toolkit/common/node_modules/graphql-tools/index.esm.js ***!
  \***********************************************************************************************************************************/
/*! exports provided: AddArgumentsAsVariables, AddMergedTypeSelectionSets, AddReplacementFragments, AddReplacementSelectionSets, AddTypenameToAbstract, AwaitVariablesLink, CheckResultAndHandleErrors, ExpandAbstractTypes, ExtendSchema, ExtractField, FilterInterfaceFields, FilterObjectFields, FilterRootFields, FilterToSchema, FilterTypes, GraphQLUpload, HoistField, MapFields, MapperKind, MockList, RenameInterfaceFields, RenameObjectFields, RenameRootFields, RenameRootTypes, RenameTypes, ReplaceFieldWithFragment, SchemaDirectiveVisitor, SchemaError, SchemaVisitor, TransformCompositeFields, TransformInterfaceFields, TransformObjectFields, TransformQuery, TransformRootFields, VisitSchemaKind, WrapFields, WrapQuery, WrapType, addCatchUndefinedToSchema, addErrorLoggingToSchema, addMockFunctionsToSchema, addMocksToSchema, addResolveFunctionsToSchema, addResolversToSchema, addSchemaLevelResolveFunction, addSchemaLevelResolver, argumentMapToConfig, argumentToConfig, assertResolveFunctionsPresent, assertResolversPresent, attachConnectorsToContext, attachDirectiveResolvers, buildSchema, buildSchemaFromTypeDefinitions, chainResolvers, checkForResolveTypeResolver, cloneDirective, cloneSchema, cloneType, concatenateTypeDefs, createRequest, createRequestFromInfo, createServerHttpLink, decorateWithLogger, defaultCreateProxyingResolver, defaultCreateRemoteResolver, defaultCreateRemoteSubscriptionResolver, defaultMergedResolver, delegateRequest, delegateToSchema, directiveToConfig, enumTypeToConfig, extendResolversFromInterfaces, extendSchema, extractExtensionDefinitions, fieldMapToConfig, fieldToConfig, filterExtensionDefinitions, filterSchema, forEachDefaultValue, forEachField, getResolversFromSchema, graphqlVersion, healSchema, healTypes, inputFieldMapToConfig, inputFieldToConfig, inputObjectTypeToConfig, interfaceTypeToConfig, introspectSchema, isSpecifiedScalarType, isSubschemaConfig, makeExecutableSchema, makeRemoteExecutableSchema, mapSchema, mergeSchemas, mockServer, objectTypeToConfig, scalarTypeToConfig, schemaToConfig, toConfig, transformSchema, typeToConfig, unionTypeToConfig, visitSchema, wrapSchema */
/*! exports used: SchemaDirectiveVisitor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export AddArgumentsAsVariables */
/* unused harmony export AddMergedTypeSelectionSets */
/* unused harmony export AddReplacementFragments */
/* unused harmony export AddReplacementSelectionSets */
/* unused harmony export AddTypenameToAbstract */
/* unused harmony export AwaitVariablesLink */
/* unused harmony export CheckResultAndHandleErrors */
/* unused harmony export ExpandAbstractTypes */
/* unused harmony export ExtendSchema */
/* unused harmony export ExtractField */
/* unused harmony export FilterInterfaceFields */
/* unused harmony export FilterObjectFields */
/* unused harmony export FilterRootFields */
/* unused harmony export FilterToSchema */
/* unused harmony export FilterTypes */
/* unused harmony export GraphQLUpload */
/* unused harmony export HoistField */
/* unused harmony export MapFields */
/* unused harmony export MapperKind */
/* unused harmony export MockList */
/* unused harmony export RenameInterfaceFields */
/* unused harmony export RenameObjectFields */
/* unused harmony export RenameRootFields */
/* unused harmony export RenameRootTypes */
/* unused harmony export RenameTypes */
/* unused harmony export ReplaceFieldWithFragment */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return SchemaDirectiveVisitor; });
/* unused harmony export SchemaError */
/* unused harmony export SchemaVisitor */
/* unused harmony export TransformCompositeFields */
/* unused harmony export TransformInterfaceFields */
/* unused harmony export TransformObjectFields */
/* unused harmony export TransformQuery */
/* unused harmony export TransformRootFields */
/* unused harmony export VisitSchemaKind */
/* unused harmony export WrapFields */
/* unused harmony export WrapQuery */
/* unused harmony export WrapType */
/* unused harmony export addCatchUndefinedToSchema */
/* unused harmony export addErrorLoggingToSchema */
/* unused harmony export addMockFunctionsToSchema */
/* unused harmony export addMocksToSchema */
/* unused harmony export addResolveFunctionsToSchema */
/* unused harmony export addResolversToSchema */
/* unused harmony export addSchemaLevelResolveFunction */
/* unused harmony export addSchemaLevelResolver */
/* unused harmony export argumentMapToConfig */
/* unused harmony export argumentToConfig */
/* unused harmony export assertResolveFunctionsPresent */
/* unused harmony export assertResolversPresent */
/* unused harmony export attachConnectorsToContext */
/* unused harmony export attachDirectiveResolvers */
/* unused harmony export buildSchema */
/* unused harmony export buildSchemaFromTypeDefinitions */
/* unused harmony export chainResolvers */
/* unused harmony export checkForResolveTypeResolver */
/* unused harmony export cloneDirective */
/* unused harmony export cloneSchema */
/* unused harmony export cloneType */
/* unused harmony export concatenateTypeDefs */
/* unused harmony export createRequest */
/* unused harmony export createRequestFromInfo */
/* unused harmony export createServerHttpLink */
/* unused harmony export decorateWithLogger */
/* unused harmony export defaultCreateProxyingResolver */
/* unused harmony export defaultCreateRemoteResolver */
/* unused harmony export defaultCreateRemoteSubscriptionResolver */
/* unused harmony export defaultMergedResolver */
/* unused harmony export delegateRequest */
/* unused harmony export delegateToSchema */
/* unused harmony export directiveToConfig */
/* unused harmony export enumTypeToConfig */
/* unused harmony export extendResolversFromInterfaces */
/* unused harmony export extendSchema */
/* unused harmony export extractExtensionDefinitions */
/* unused harmony export fieldMapToConfig */
/* unused harmony export fieldToConfig */
/* unused harmony export filterExtensionDefinitions */
/* unused harmony export filterSchema */
/* unused harmony export forEachDefaultValue */
/* unused harmony export forEachField */
/* unused harmony export getResolversFromSchema */
/* unused harmony export graphqlVersion */
/* unused harmony export healSchema */
/* unused harmony export healTypes */
/* unused harmony export inputFieldMapToConfig */
/* unused harmony export inputFieldToConfig */
/* unused harmony export inputObjectTypeToConfig */
/* unused harmony export interfaceTypeToConfig */
/* unused harmony export introspectSchema */
/* unused harmony export isSpecifiedScalarType */
/* unused harmony export isSubschemaConfig */
/* unused harmony export makeExecutableSchema */
/* unused harmony export makeRemoteExecutableSchema */
/* unused harmony export mapSchema */
/* unused harmony export mergeSchemas */
/* unused harmony export mockServer */
/* unused harmony export objectTypeToConfig */
/* unused harmony export scalarTypeToConfig */
/* unused harmony export schemaToConfig */
/* unused harmony export toConfig */
/* unused harmony export transformSchema */
/* unused harmony export typeToConfig */
/* unused harmony export unionTypeToConfig */
/* unused harmony export visitSchema */
/* unused harmony export wrapSchema */
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "../../node_modules/@graphql-toolkit/common/node_modules/tslib/tslib.es6.js");
/* harmony import */ var iterall__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! iterall */ "../../node_modules/iterall/index.mjs");
/* harmony import */ var apollo_link__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! apollo-link */ "../../node_modules/apollo-link/lib/bundle.esm.js");
/* harmony import */ var graphql__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! graphql */ "../../node_modules/graphql/index.mjs");
/* harmony import */ var deprecated_decorator__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! deprecated-decorator */ "../../node_modules/deprecated-decorator/bld/index.js");
/* harmony import */ var deprecated_decorator__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(deprecated_decorator__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var apollo_upload_client__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! apollo-upload-client */ "../../node_modules/apollo-upload-client/lib/index.js");
/* harmony import */ var apollo_upload_client__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(apollo_upload_client__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var form_data__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! form-data */ "../../node_modules/form-data/lib/form_data.js");
/* harmony import */ var form_data__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(form_data__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var node_fetch__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! node-fetch */ "../../node_modules/node-fetch/lib/index.mjs");
/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! uuid */ "../../node_modules/@graphql-toolkit/common/node_modules/uuid/dist/esm-node/index.js");










function isSubschemaConfig(value) {
    return Boolean(value.schema);
}
var VisitSchemaKind;
(function (VisitSchemaKind) {
    VisitSchemaKind["TYPE"] = "VisitSchemaKind.TYPE";
    VisitSchemaKind["SCALAR_TYPE"] = "VisitSchemaKind.SCALAR_TYPE";
    VisitSchemaKind["ENUM_TYPE"] = "VisitSchemaKind.ENUM_TYPE";
    VisitSchemaKind["COMPOSITE_TYPE"] = "VisitSchemaKind.COMPOSITE_TYPE";
    VisitSchemaKind["OBJECT_TYPE"] = "VisitSchemaKind.OBJECT_TYPE";
    VisitSchemaKind["INPUT_OBJECT_TYPE"] = "VisitSchemaKind.INPUT_OBJECT_TYPE";
    VisitSchemaKind["ABSTRACT_TYPE"] = "VisitSchemaKind.ABSTRACT_TYPE";
    VisitSchemaKind["UNION_TYPE"] = "VisitSchemaKind.UNION_TYPE";
    VisitSchemaKind["INTERFACE_TYPE"] = "VisitSchemaKind.INTERFACE_TYPE";
    VisitSchemaKind["ROOT_OBJECT"] = "VisitSchemaKind.ROOT_OBJECT";
    VisitSchemaKind["QUERY"] = "VisitSchemaKind.QUERY";
    VisitSchemaKind["MUTATION"] = "VisitSchemaKind.MUTATION";
    VisitSchemaKind["SUBSCRIPTION"] = "VisitSchemaKind.SUBSCRIPTION";
})(VisitSchemaKind || (VisitSchemaKind = {}));
var MapperKind;
(function (MapperKind) {
    MapperKind["TYPE"] = "MapperKind.TYPE";
    MapperKind["SCALAR_TYPE"] = "MapperKind.SCALAR_TYPE";
    MapperKind["ENUM_TYPE"] = "MapperKind.ENUM_TYPE";
    MapperKind["COMPOSITE_TYPE"] = "MapperKind.COMPOSITE_TYPE";
    MapperKind["OBJECT_TYPE"] = "MapperKind.OBJECT_TYPE";
    MapperKind["INPUT_OBJECT_TYPE"] = "MapperKind.INPUT_OBJECT_TYPE";
    MapperKind["ABSTRACT_TYPE"] = "MapperKind.ABSTRACT_TYPE";
    MapperKind["UNION_TYPE"] = "MapperKind.UNION_TYPE";
    MapperKind["INTERFACE_TYPE"] = "MapperKind.INTERFACE_TYPE";
    MapperKind["ROOT_OBJECT"] = "MapperKind.ROOT_OBJECT";
    MapperKind["QUERY"] = "MapperKind.QUERY";
    MapperKind["MUTATION"] = "MapperKind.MUTATION";
    MapperKind["SUBSCRIPTION"] = "MapperKind.SUBSCRIPTION";
    MapperKind["DIRECTIVE"] = "MapperKind.DIRECTIVE";
})(MapperKind || (MapperKind = {}));

function implementsAbstractType(schema, typeA, typeB) {
    if (typeA === typeB) {
        return true;
    }
    else if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isCompositeType"])(typeA) && Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isCompositeType"])(typeB)) {
        return Object(graphql__WEBPACK_IMPORTED_MODULE_3__["doTypesOverlap"])(schema, typeA, typeB);
    }
    return false;
}

var ExpandAbstractTypes = /** @class */ (function () {
    function ExpandAbstractTypes(sourceSchema, targetSchema) {
        this.targetSchema = targetSchema;
        this.mapping = extractPossibleTypes(sourceSchema, targetSchema);
        this.reverseMapping = flipMapping(this.mapping);
    }
    ExpandAbstractTypes.prototype.transformRequest = function (originalRequest) {
        var document = expandAbstractTypes(this.targetSchema, this.mapping, this.reverseMapping, originalRequest.document);
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, originalRequest), { document: document });
    };
    return ExpandAbstractTypes;
}());
function extractPossibleTypes(sourceSchema, targetSchema) {
    var typeMap = sourceSchema.getTypeMap();
    var mapping = Object.create(null);
    Object.keys(typeMap).forEach(function (typeName) {
        var type = typeMap[typeName];
        if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isAbstractType"])(type)) {
            var targetType = targetSchema.getType(typeName);
            if (!Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isAbstractType"])(targetType)) {
                var implementations = sourceSchema.getPossibleTypes(type);
                mapping[typeName] = implementations
                    .filter(function (impl) { return targetSchema.getType(impl.name); })
                    .map(function (impl) { return impl.name; });
            }
        }
    });
    return mapping;
}
function flipMapping(mapping) {
    var result = Object.create(null);
    Object.keys(mapping).forEach(function (typeName) {
        var toTypeNames = mapping[typeName];
        toTypeNames.forEach(function (toTypeName) {
            if (!(toTypeName in result)) {
                result[toTypeName] = [];
            }
            result[toTypeName].push(typeName);
        });
    });
    return result;
}
function expandAbstractTypes(targetSchema, mapping, reverseMapping, document) {
    var _a;
    var operations = document.definitions.filter(function (def) { return def.kind === graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].OPERATION_DEFINITION; });
    var fragments = document.definitions.filter(function (def) { return def.kind === graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].FRAGMENT_DEFINITION; });
    var existingFragmentNames = fragments.map(function (fragment) { return fragment.name.value; });
    var fragmentCounter = 0;
    var generateFragmentName = function (typeName) {
        var fragmentName;
        do {
            fragmentName = "_" + typeName + "_Fragment" + fragmentCounter.toString();
            fragmentCounter++;
        } while (existingFragmentNames.indexOf(fragmentName) !== -1);
        return fragmentName;
    };
    var newFragments = [];
    var fragmentReplacements = Object.create(null);
    fragments.forEach(function (fragment) {
        newFragments.push(fragment);
        var possibleTypes = mapping[fragment.typeCondition.name.value];
        if (possibleTypes != null) {
            fragmentReplacements[fragment.name.value] = [];
            possibleTypes.forEach(function (possibleTypeName) {
                var name = generateFragmentName(possibleTypeName);
                existingFragmentNames.push(name);
                var newFragment = {
                    kind: graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].FRAGMENT_DEFINITION,
                    name: {
                        kind: graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].NAME,
                        value: name,
                    },
                    typeCondition: {
                        kind: graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].NAMED_TYPE,
                        name: {
                            kind: graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].NAME,
                            value: possibleTypeName,
                        },
                    },
                    selectionSet: fragment.selectionSet,
                };
                newFragments.push(newFragment);
                fragmentReplacements[fragment.name.value].push({
                    fragmentName: name,
                    typeName: possibleTypeName,
                });
            });
        }
    });
    var newDocument = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, document), { definitions: Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __spreadArrays */ "d"])(operations, newFragments) });
    var typeInfo = new graphql__WEBPACK_IMPORTED_MODULE_3__["TypeInfo"](targetSchema);
    return Object(graphql__WEBPACK_IMPORTED_MODULE_3__["visit"])(newDocument, Object(graphql__WEBPACK_IMPORTED_MODULE_3__["visitWithTypeInfo"])(typeInfo, (_a = {},
        _a[graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].SELECTION_SET] = function (node) {
            var newSelections = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __spreadArrays */ "d"])(node.selections);
            var maybeType = typeInfo.getParentType();
            if (maybeType != null) {
                var parentType_1 = Object(graphql__WEBPACK_IMPORTED_MODULE_3__["getNamedType"])(maybeType);
                node.selections.forEach(function (selection) {
                    if (selection.kind === graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].INLINE_FRAGMENT) {
                        if (selection.typeCondition != null) {
                            var possibleTypes = mapping[selection.typeCondition.name.value];
                            if (possibleTypes != null) {
                                possibleTypes.forEach(function (possibleType) {
                                    var maybePossibleType = targetSchema.getType(possibleType);
                                    if (maybePossibleType != null &&
                                        implementsAbstractType(targetSchema, parentType_1, maybePossibleType)) {
                                        newSelections.push({
                                            kind: graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].INLINE_FRAGMENT,
                                            typeCondition: {
                                                kind: graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].NAMED_TYPE,
                                                name: {
                                                    kind: graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].NAME,
                                                    value: possibleType,
                                                },
                                            },
                                            selectionSet: selection.selectionSet,
                                        });
                                    }
                                });
                            }
                        }
                    }
                    else if (selection.kind === graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].FRAGMENT_SPREAD) {
                        var fragmentName = selection.name.value;
                        if (fragmentName in fragmentReplacements) {
                            fragmentReplacements[fragmentName].forEach(function (replacement) {
                                var typeName = replacement.typeName;
                                var maybeReplacementType = targetSchema.getType(typeName);
                                if (maybeReplacementType != null &&
                                    implementsAbstractType(targetSchema, parentType_1, maybeType)) {
                                    newSelections.push({
                                        kind: graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].FRAGMENT_SPREAD,
                                        name: {
                                            kind: graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].NAME,
                                            value: replacement.fragmentName,
                                        },
                                    });
                                }
                            });
                        }
                    }
                });
                if (parentType_1.name in reverseMapping) {
                    newSelections.push({
                        kind: graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].FIELD,
                        name: {
                            kind: graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].NAME,
                            value: '__typename',
                        },
                    });
                }
            }
            if (newSelections.length !== node.selections.length) {
                return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, node), { selections: newSelections });
            }
        },
        _a)));
}

/**
 * Creates a keyed JS object from an array, given a function to produce the keys
 * and a function to produce the values from each item in the array.
 *
 *     const phoneBook = [
 *       { name: 'Jon', num: '555-1234' },
 *       { name: 'Jenny', num: '867-5309' }
 *     ]
 *
 *     // { Jon: '555-1234', Jenny: '867-5309' }
 *     const phonesByName = keyValMap(
 *       phoneBook,
 *       entry => entry.name,
 *       entry => entry.num
 *     )
 *
 */
function keyValMap(list, keyFn, valFn) {
    return list.reduce(function (map, item) {
        map[keyFn(item)] = valFn(item);
        return map;
    }, Object.create(null));
}

var FilterToSchema = /** @class */ (function () {
    function FilterToSchema(targetSchema) {
        this.targetSchema = targetSchema;
    }
    FilterToSchema.prototype.transformRequest = function (originalRequest) {
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, originalRequest), filterToSchema(this.targetSchema, originalRequest.document, originalRequest.variables));
    };
    return FilterToSchema;
}());
function filterToSchema(targetSchema, document, variables) {
    var operations = document.definitions.filter(function (def) { return def.kind === graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].OPERATION_DEFINITION; });
    var fragments = document.definitions.filter(function (def) { return def.kind === graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].FRAGMENT_DEFINITION; });
    var usedVariables = [];
    var usedFragments = [];
    var newOperations = [];
    var newFragments = [];
    var validFragments = fragments.filter(function (fragment) {
        var typeName = fragment.typeCondition.name.value;
        return Boolean(targetSchema.getType(typeName));
    });
    var validFragmentsWithType = keyValMap(validFragments, function (fragment) { return fragment.name.value; }, function (fragment) { return targetSchema.getType(fragment.typeCondition.name.value); });
    var fragmentSet = Object.create(null);
    operations.forEach(function (operation) {
        var type;
        if (operation.operation === 'subscription') {
            type = targetSchema.getSubscriptionType();
        }
        else if (operation.operation === 'mutation') {
            type = targetSchema.getMutationType();
        }
        else {
            type = targetSchema.getQueryType();
        }
        var _a = filterSelectionSet(targetSchema, type, validFragmentsWithType, operation.selectionSet), selectionSet = _a.selectionSet, operationUsedFragments = _a.usedFragments, operationUsedVariables = _a.usedVariables;
        usedFragments = union(usedFragments, operationUsedFragments);
        var _b = collectFragmentVariables(targetSchema, fragmentSet, validFragments, validFragmentsWithType, usedFragments), collectedUsedVariables = _b.usedVariables, collectedNewFragments = _b.newFragments, collectedFragmentSet = _b.fragmentSet;
        var operationOrFragmentVariables = union(operationUsedVariables, collectedUsedVariables);
        usedVariables = union(usedVariables, operationOrFragmentVariables);
        newFragments = collectedNewFragments;
        fragmentSet = collectedFragmentSet;
        var variableDefinitions = operation.variableDefinitions.filter(function (variable) {
            return operationOrFragmentVariables.indexOf(variable.variable.name.value) !==
                -1;
        });
        newOperations.push({
            kind: graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].OPERATION_DEFINITION,
            operation: operation.operation,
            name: operation.name,
            directives: operation.directives,
            variableDefinitions: variableDefinitions,
            selectionSet: selectionSet,
        });
    });
    var newVariables = usedVariables.reduce(function (acc, variableName) {
        acc[variableName] = variables[variableName];
        return acc;
    }, {});
    return {
        document: {
            kind: graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].DOCUMENT,
            definitions: Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __spreadArrays */ "d"])(newOperations, newFragments),
        },
        variables: newVariables,
    };
}
function collectFragmentVariables(targetSchema, fragmentSet, validFragments, validFragmentsWithType, usedFragments) {
    var remainingFragments = usedFragments.slice();
    var usedVariables = [];
    var newFragments = [];
    var _loop_1 = function () {
        var nextFragmentName = remainingFragments.pop();
        var fragment = validFragments.find(function (fr) { return fr.name.value === nextFragmentName; });
        if (fragment != null) {
            var name_1 = nextFragmentName;
            var typeName = fragment.typeCondition.name.value;
            var type = targetSchema.getType(typeName);
            var _a = filterSelectionSet(targetSchema, type, validFragmentsWithType, fragment.selectionSet), selectionSet = _a.selectionSet, fragmentUsedFragments = _a.usedFragments, fragmentUsedVariables = _a.usedVariables;
            remainingFragments = union(remainingFragments, fragmentUsedFragments);
            usedVariables = union(usedVariables, fragmentUsedVariables);
            if (!(name_1 in fragmentSet)) {
                fragmentSet[name_1] = true;
                newFragments.push({
                    kind: graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].FRAGMENT_DEFINITION,
                    name: {
                        kind: graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].NAME,
                        value: name_1,
                    },
                    typeCondition: fragment.typeCondition,
                    selectionSet: selectionSet,
                });
            }
        }
    };
    while (remainingFragments.length !== 0) {
        _loop_1();
    }
    return {
        usedVariables: usedVariables,
        newFragments: newFragments,
        fragmentSet: fragmentSet,
    };
}
function filterSelectionSet(schema, type, validFragments, selectionSet) {
    var _a;
    var usedFragments = [];
    var usedVariables = [];
    var typeInfo = new graphql__WEBPACK_IMPORTED_MODULE_3__["TypeInfo"](schema, undefined, type);
    var filteredSelectionSet = Object(graphql__WEBPACK_IMPORTED_MODULE_3__["visit"])(selectionSet, Object(graphql__WEBPACK_IMPORTED_MODULE_3__["visitWithTypeInfo"])(typeInfo, (_a = {},
        _a[graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].FIELD] = {
            enter: function (node) {
                var parentType = typeInfo.getParentType();
                if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isObjectType"])(parentType) || Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isInterfaceType"])(parentType)) {
                    var fields = parentType.getFields();
                    var field = node.name.value === '__typename'
                        ? graphql__WEBPACK_IMPORTED_MODULE_3__["TypeNameMetaFieldDef"]
                        : fields[node.name.value];
                    if (!field) {
                        return null;
                    }
                    var argNames_1 = (field.args != null ? field.args : []).map(function (arg) { return arg.name; });
                    if (node.arguments != null) {
                        var args = node.arguments.filter(function (arg) { return argNames_1.indexOf(arg.name.value) !== -1; });
                        if (args.length !== node.arguments.length) {
                            return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, node), { arguments: args });
                        }
                    }
                }
            },
            leave: function (node) {
                var _a;
                var resolvedType = Object(graphql__WEBPACK_IMPORTED_MODULE_3__["getNamedType"])(typeInfo.getType());
                if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isObjectType"])(resolvedType) || Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isInterfaceType"])(resolvedType)) {
                    var selections = node.selectionSet != null ? node.selectionSet.selections : null;
                    if (selections == null || selections.length === 0) {
                        // need to remove any added variables. Is there a better way to do this?
                        Object(graphql__WEBPACK_IMPORTED_MODULE_3__["visit"])(node, (_a = {},
                            _a[graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].VARIABLE] = function (variableNode) {
                                var index = usedVariables.indexOf(variableNode.name.value);
                                if (index !== -1) {
                                    usedVariables.splice(index, 1);
                                }
                            },
                            _a));
                        return null;
                    }
                }
            },
        },
        _a[graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].FRAGMENT_SPREAD] = function (node) {
            if (node.name.value in validFragments) {
                var parentType = typeInfo.getParentType();
                var innerType = validFragments[node.name.value];
                if (!implementsAbstractType(schema, parentType, innerType)) {
                    return null;
                }
                usedFragments.push(node.name.value);
                return;
            }
            return null;
        },
        _a[graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].INLINE_FRAGMENT] = {
            enter: function (node) {
                if (node.typeCondition != null) {
                    var parentType = typeInfo.getParentType();
                    var innerType = schema.getType(node.typeCondition.name.value);
                    if (!implementsAbstractType(schema, parentType, innerType)) {
                        return null;
                    }
                }
            },
        },
        _a[graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].VARIABLE] = function (node) {
            usedVariables.push(node.name.value);
        },
        _a)));
    return {
        selectionSet: filteredSelectionSet,
        usedFragments: usedFragments,
        usedVariables: usedVariables,
    };
}
function union() {
    var arrays = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        arrays[_i] = arguments[_i];
    }
    var cache = Object.create(null);
    var result = [];
    arrays.forEach(function (array) {
        array.forEach(function (item) {
            if (!(item in cache)) {
                cache[item] = true;
                result.push(item);
            }
        });
    });
    return result;
}

var AddReplacementSelectionSets = /** @class */ (function () {
    function AddReplacementSelectionSets(schema, mapping) {
        this.schema = schema;
        this.mapping = mapping;
    }
    AddReplacementSelectionSets.prototype.transformRequest = function (originalRequest) {
        var document = replaceFieldsWithSelectionSet(this.schema, originalRequest.document, this.mapping);
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, originalRequest), { document: document });
    };
    return AddReplacementSelectionSets;
}());
function replaceFieldsWithSelectionSet(schema, document, mapping) {
    var _a;
    var typeInfo = new graphql__WEBPACK_IMPORTED_MODULE_3__["TypeInfo"](schema);
    return Object(graphql__WEBPACK_IMPORTED_MODULE_3__["visit"])(document, Object(graphql__WEBPACK_IMPORTED_MODULE_3__["visitWithTypeInfo"])(typeInfo, (_a = {},
        _a[graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].SELECTION_SET] = function (node) {
            var parentType = typeInfo.getParentType();
            if (parentType != null) {
                var parentTypeName_1 = parentType.name;
                var selections_1 = node.selections;
                if (parentTypeName_1 in mapping) {
                    node.selections.forEach(function (selection) {
                        if (selection.kind === graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].FIELD) {
                            var name_1 = selection.name.value;
                            var selectionSet = mapping[parentTypeName_1][name_1];
                            if (selectionSet != null) {
                                selections_1 = selections_1.concat(selectionSet.selections);
                            }
                        }
                    });
                }
                if (selections_1 !== node.selections) {
                    return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, node), { selections: selections_1 });
                }
            }
        },
        _a)));
}

var AddReplacementFragments = /** @class */ (function () {
    function AddReplacementFragments(targetSchema, mapping) {
        this.targetSchema = targetSchema;
        this.mapping = mapping;
    }
    AddReplacementFragments.prototype.transformRequest = function (originalRequest) {
        var document = replaceFieldsWithFragments(this.targetSchema, originalRequest.document, this.mapping);
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, originalRequest), { document: document });
    };
    return AddReplacementFragments;
}());
function replaceFieldsWithFragments(targetSchema, document, mapping) {
    var _a;
    var typeInfo = new graphql__WEBPACK_IMPORTED_MODULE_3__["TypeInfo"](targetSchema);
    return Object(graphql__WEBPACK_IMPORTED_MODULE_3__["visit"])(document, Object(graphql__WEBPACK_IMPORTED_MODULE_3__["visitWithTypeInfo"])(typeInfo, (_a = {},
        _a[graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].SELECTION_SET] = function (node) {
            var parentType = typeInfo.getParentType();
            if (parentType != null) {
                var parentTypeName_1 = parentType.name;
                var selections_1 = node.selections;
                if (parentTypeName_1 in mapping) {
                    node.selections.forEach(function (selection) {
                        if (selection.kind === graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].FIELD) {
                            var name_1 = selection.name.value;
                            var fragment = mapping[parentTypeName_1][name_1];
                            if (fragment != null) {
                                selections_1 = selections_1.concat(fragment);
                            }
                        }
                    });
                }
                if (selections_1 !== node.selections) {
                    return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, node), { selections: selections_1 });
                }
            }
        },
        _a)));
}

var AddMergedTypeFragments = /** @class */ (function () {
    function AddMergedTypeFragments(targetSchema, mapping) {
        this.targetSchema = targetSchema;
        this.mapping = mapping;
    }
    AddMergedTypeFragments.prototype.transformRequest = function (originalRequest) {
        var document = addMergedTypeSelectionSets(this.targetSchema, originalRequest.document, this.mapping);
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, originalRequest), { document: document });
    };
    return AddMergedTypeFragments;
}());
function addMergedTypeSelectionSets(targetSchema, document, mapping) {
    var _a;
    var typeInfo = new graphql__WEBPACK_IMPORTED_MODULE_3__["TypeInfo"](targetSchema);
    return Object(graphql__WEBPACK_IMPORTED_MODULE_3__["visit"])(document, Object(graphql__WEBPACK_IMPORTED_MODULE_3__["visitWithTypeInfo"])(typeInfo, (_a = {},
        _a[graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].SELECTION_SET] = function (node) {
            var parentType = typeInfo.getParentType();
            if (parentType != null) {
                var parentTypeName = parentType.name;
                var selections = node.selections;
                if (parentTypeName in mapping) {
                    var selectionSet = mapping[parentTypeName].selectionSet;
                    if (selectionSet != null) {
                        selections = selections.concat(selectionSet.selections);
                    }
                }
                if (selections !== node.selections) {
                    return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, node), { selections: selections });
                }
            }
        },
        _a)));
}

function addTypenameToAbstract(targetSchema, document) {
    var _a;
    var typeInfo = new graphql__WEBPACK_IMPORTED_MODULE_3__["TypeInfo"](targetSchema);
    return Object(graphql__WEBPACK_IMPORTED_MODULE_3__["visit"])(document, Object(graphql__WEBPACK_IMPORTED_MODULE_3__["visitWithTypeInfo"])(typeInfo, (_a = {},
        _a[graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].SELECTION_SET] = function (node) {
            var parentType = typeInfo.getParentType();
            var selections = node.selections;
            if (parentType != null && Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isAbstractType"])(parentType)) {
                selections = selections.concat({
                    kind: graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].FIELD,
                    name: {
                        kind: graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].NAME,
                        value: '__typename',
                    },
                });
            }
            if (selections !== node.selections) {
                return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, node), { selections: selections });
            }
        },
        _a)));
}

var AddTypenameToAbstract = /** @class */ (function () {
    function AddTypenameToAbstract(targetSchema) {
        this.targetSchema = targetSchema;
    }
    AddTypenameToAbstract.prototype.transformRequest = function (originalRequest) {
        var document = addTypenameToAbstract(this.targetSchema, originalRequest.document);
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, originalRequest), { document: document });
    };
    return AddTypenameToAbstract;
}());

/**
 * Get the key under which the result of this resolver will be placed in the response JSON. Basically, just
 * resolves aliases.
 * @param info The info argument to the resolver.
 */
function getResponseKeyFromInfo(info) {
    return info.fieldNodes[0].alias != null
        ? info.fieldNodes[0].alias.value
        : info.fieldName;
}

var hasSymbol = (typeof global !== 'undefined' && 'Symbol' in global) ||
    // eslint-disable-next-line no-undef
    (typeof window !== 'undefined' && 'Symbol' in window);
var OBJECT_SUBSCHEMA_SYMBOL = hasSymbol
    ? Symbol('initialSubschema')
    : '@@__initialSubschema';
var FIELD_SUBSCHEMA_MAP_SYMBOL = hasSymbol
    ? Symbol('subschemaMap')
    : '@@__subschemaMap';
var ERROR_SYMBOL = hasSymbol
    ? Symbol('subschemaErrors')
    : '@@__subschemaErrors';

function relocatedError(originalError, nodes, path) {
    if (Array.isArray(originalError.path)) {
        return new graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLError"](originalError.message, originalError.nodes, originalError.source, originalError.positions, path != null ? path : originalError.path, originalError.originalError, originalError.extensions);
    }
    if (originalError == null) {
        return new graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLError"](undefined, nodes, undefined, undefined, path, originalError);
    }
    return new graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLError"](originalError.message, originalError.nodes != null
        ? originalError.nodes
        : nodes, originalError.source, originalError.positions, path, originalError);
}
function slicedError(originalError) {
    return relocatedError(originalError, originalError.nodes, originalError.path != null ? originalError.path.slice(1) : undefined);
}
function getErrorsByPathSegment(errors) {
    var record = Object.create(null);
    errors.forEach(function (error) {
        if (!error.path || error.path.length < 2) {
            return;
        }
        var pathSegment = error.path[1];
        var current = pathSegment in record ? record[pathSegment] : [];
        current.push(slicedError(error));
        record[pathSegment] = current;
    });
    return record;
}
var CombinedError = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __extends */ "b"])(CombinedError, _super);
    function CombinedError(message, errors) {
        var _this = _super.call(this, message) || this;
        _this.errors = errors;
        return _this;
    }
    return CombinedError;
}(Error));
function combineErrors(errors) {
    if (errors.length === 1) {
        return new graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLError"](errors[0].message, errors[0].nodes, errors[0].source, errors[0].positions, errors[0].path, errors[0].originalError, errors[0].extensions);
    }
    return new CombinedError(errors.map(function (error) { return error.message; }).join('\n'), errors);
}
function setErrors(result, errors) {
    result[ERROR_SYMBOL] = errors;
}
function getErrors(result, pathSegment) {
    var errors = result != null ? result[ERROR_SYMBOL] : result;
    if (!Array.isArray(errors)) {
        return null;
    }
    var fieldErrors = [];
    for (var _i = 0, errors_1 = errors; _i < errors_1.length; _i++) {
        var error = errors_1[_i];
        if (!error.path || error.path[0] === pathSegment) {
            fieldErrors.push(error);
        }
    }
    return fieldErrors;
}

function handleNull(fieldNodes, path, errors) {
    if (errors.length) {
        if (errors.some(function (error) { return !error.path || error.path.length < 2; })) {
            return relocatedError(combineErrors(errors), fieldNodes, path);
        }
        else if (errors.some(function (error) { return typeof error.path[1] === 'string'; })) {
            var childErrors_1 = getErrorsByPathSegment(errors);
            var result_1 = {};
            Object.keys(childErrors_1).forEach(function (pathSegment) {
                result_1[pathSegment] = handleNull(fieldNodes, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __spreadArrays */ "d"])(path, [pathSegment]), childErrors_1[pathSegment]);
            });
            return result_1;
        }
        var childErrors_2 = getErrorsByPathSegment(errors);
        var result_2 = [];
        Object.keys(childErrors_2).forEach(function (pathSegment) {
            result_2.push(handleNull(fieldNodes, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __spreadArrays */ "d"])(path, [parseInt(pathSegment, 10)]), childErrors_2[pathSegment]));
        });
        return result_2;
    }
    return null;
}

/**
 * Given a selectionSet, adds all of the fields in that selection to
 * the passed in map of fields, and returns it at the end.
 *
 * CollectFields requires the "runtime type" of an object. For a field which
 * returns an Interface or Union type, the "runtime type" will be the actual
 * Object type returned by that field.
 *
 * @internal
 */
function collectFields(exeContext, runtimeType, selectionSet, fields, visitedFragmentNames) {
    for (var _i = 0, _a = selectionSet.selections; _i < _a.length; _i++) {
        var selection = _a[_i];
        switch (selection.kind) {
            case graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].FIELD: {
                if (!shouldIncludeNode(exeContext, selection)) {
                    continue;
                }
                var name_1 = getFieldEntryKey(selection);
                if (!(name_1 in fields)) {
                    fields[name_1] = [];
                }
                fields[name_1].push(selection);
                break;
            }
            case graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].INLINE_FRAGMENT: {
                if (!shouldIncludeNode(exeContext, selection) ||
                    !doesFragmentConditionMatch(exeContext, selection, runtimeType)) {
                    continue;
                }
                collectFields(exeContext, runtimeType, selection.selectionSet, fields, visitedFragmentNames);
                break;
            }
            case graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].FRAGMENT_SPREAD: {
                var fragName = selection.name.value;
                if (visitedFragmentNames[fragName] ||
                    !shouldIncludeNode(exeContext, selection)) {
                    continue;
                }
                visitedFragmentNames[fragName] = true;
                var fragment = exeContext.fragments[fragName];
                if (!fragment ||
                    !doesFragmentConditionMatch(exeContext, fragment, runtimeType)) {
                    continue;
                }
                collectFields(exeContext, runtimeType, fragment.selectionSet, fields, visitedFragmentNames);
                break;
            }
        }
    }
    return fields;
}
/**
 * Determines if a field should be included based on the @include and @skip
 * directives, where @skip has higher precedence than @include.
 */
function shouldIncludeNode(exeContext, node) {
    var skip = Object(graphql__WEBPACK_IMPORTED_MODULE_3__["getDirectiveValues"])(graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLSkipDirective"], node, exeContext.variableValues);
    if ((skip === null || skip === void 0 ? void 0 : skip.if) === true) {
        return false;
    }
    var include = Object(graphql__WEBPACK_IMPORTED_MODULE_3__["getDirectiveValues"])(graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLIncludeDirective"], node, exeContext.variableValues);
    if ((include === null || include === void 0 ? void 0 : include.if) === false) {
        return false;
    }
    return true;
}
/**
 * Determines if a fragment is applicable to the given type.
 */
function doesFragmentConditionMatch(exeContext, fragment, type) {
    var typeConditionNode = fragment.typeCondition;
    if (!typeConditionNode) {
        return true;
    }
    var conditionalType = Object(graphql__WEBPACK_IMPORTED_MODULE_3__["typeFromAST"])(exeContext.schema, typeConditionNode);
    if (conditionalType === type) {
        return true;
    }
    if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isAbstractType"])(conditionalType)) {
        return exeContext.schema.isPossibleType(conditionalType, type);
    }
    return false;
}
/**
 * Implements the logic to compute the key of a given field's entry
 */
function getFieldEntryKey(node) {
    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
    return node.alias ? node.alias.value : node.name.value;
}

function getSubschema(result, responseKey) {
    var subschema = result[FIELD_SUBSCHEMA_MAP_SYMBOL] &&
        result[FIELD_SUBSCHEMA_MAP_SYMBOL][responseKey];
    return subschema ? subschema : result[OBJECT_SUBSCHEMA_SYMBOL];
}
function setObjectSubschema(result, subschema) {
    result[OBJECT_SUBSCHEMA_SYMBOL] = subschema;
}

function resolveFromParentTypename(parent) {
    var parentTypename = parent['__typename'];
    if (!parentTypename) {
        throw new Error('Did not fetch typename for object, unable to resolve interface.');
    }
    return parentTypename;
}

function mergeDeep(target) {
    var sources = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        sources[_i - 1] = arguments[_i];
    }
    var output = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, target);
    sources.forEach(function (source) {
        if (isObject(target) && isObject(source)) {
            Object.keys(source).forEach(function (key) {
                var _a, _b;
                if (isObject(source[key])) {
                    if (!(key in target)) {
                        Object.assign(output, (_a = {}, _a[key] = source[key], _a));
                    }
                    else {
                        output[key] = mergeDeep(target[key], source[key]);
                    }
                }
                else {
                    Object.assign(output, (_b = {}, _b[key] = source[key], _b));
                }
            });
        }
    });
    return output;
}
function isObject(item) {
    return item && typeof item === 'object' && !Array.isArray(item);
}

function unwrapResult(parent, info, path) {
    var newParent = parent;
    var pathLength = path.length;
    for (var i = 0; i < pathLength; i++) {
        var responseKey = path[i];
        var errors = getErrors(newParent, responseKey);
        var subschema = getSubschema(newParent, responseKey);
        var object = newParent[responseKey];
        if (object == null) {
            return handleNull(info.fieldNodes, Object(graphql__WEBPACK_IMPORTED_MODULE_3__["responsePathAsArray"])(info.path), errors);
        }
        setErrors(object, errors.map(function (error) {
            return relocatedError(error, error.nodes, error.path != null ? error.path.slice(1) : undefined);
        }));
        setObjectSubschema(object, subschema);
        newParent = object;
    }
    return newParent;
}
function dehoistResult(parent, delimeter) {
    if (delimeter === void 0) { delimeter = '__gqltf__'; }
    var result = Object.create(null);
    Object.keys(parent).forEach(function (alias) {
        var obj = result;
        var fieldNames = alias.split(delimeter);
        var fieldName = fieldNames.pop();
        fieldNames.forEach(function (key) {
            obj = obj[key] = obj[key] || Object.create(null);
        });
        obj[fieldName] = parent[alias];
    });
    result[ERROR_SYMBOL] = parent[ERROR_SYMBOL].map(function (error) {
        if (error.path != null) {
            var path = error.path.slice();
            var pathSegment = path.shift();
            var expandedPathSegment = pathSegment.split(delimeter);
            return relocatedError(error, error.nodes, expandedPathSegment.concat(path));
        }
        return error;
    });
    result[OBJECT_SUBSCHEMA_SYMBOL] = parent[OBJECT_SUBSCHEMA_SYMBOL];
    return result;
}
function mergeProxiedResults(target) {
    var sources = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        sources[_i - 1] = arguments[_i];
    }
    var errors = target[ERROR_SYMBOL].concat(sources.map(function (source) { return source[ERROR_SYMBOL]; }));
    var fieldSubschemaMap = sources.reduce(function (acc, source) {
        var subschema = source[OBJECT_SUBSCHEMA_SYMBOL];
        Object.keys(source).forEach(function (key) {
            acc[key] = subschema;
        });
        return acc;
    }, {});
    var result = mergeDeep.apply(void 0, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __spreadArrays */ "d"])([target], sources));
    result[ERROR_SYMBOL] = errors;
    result[FIELD_SUBSCHEMA_MAP_SYMBOL] = target[FIELD_SUBSCHEMA_MAP_SYMBOL]
        ? mergeDeep(target[FIELD_SUBSCHEMA_MAP_SYMBOL], fieldSubschemaMap)
        : fieldSubschemaMap;
    return result;
}

function buildDelegationPlan(mergedTypeInfo, originalSelections, sourceSubschemas, targetSubschemas) {
    // 1.  calculate if possible to delegate to given subschema
    //    TODO: change logic so that required selection set can be spread across multiple subschemas?
    var proxiableSubschemas = [];
    var nonProxiableSubschemas = [];
    targetSubschemas.forEach(function (t) {
        if (sourceSubschemas.some(function (s) {
            var selectionSet = mergedTypeInfo.selectionSets.get(t);
            return mergedTypeInfo.containsSelectionSet.get(s).get(selectionSet);
        })) {
            proxiableSubschemas.push(t);
        }
        else {
            nonProxiableSubschemas.push(t);
        }
    });
    var uniqueFields = mergedTypeInfo.uniqueFields, nonUniqueFields = mergedTypeInfo.nonUniqueFields;
    var unproxiableSelections = [];
    // 2. for each selection:
    var delegationMap = new Map();
    originalSelections.forEach(function (selection) {
        // 2a. use uniqueFields map to assign fields to subschema if one of possible subschemas
        var uniqueSubschema = uniqueFields[selection.name.value];
        if (uniqueSubschema != null) {
            if (proxiableSubschemas.includes(uniqueSubschema)) {
                var existingSubschema = delegationMap.get(uniqueSubschema);
                if (existingSubschema != null) {
                    existingSubschema.push(selection);
                }
                else {
                    delegationMap.set(uniqueSubschema, [selection]);
                }
            }
            else {
                unproxiableSelections.push(selection);
            }
        }
        else {
            // 2b. use nonUniqueFields to assign to a possible subschema,
            //     preferring one of the subschemas already targets of delegation
            var nonUniqueSubschemas = nonUniqueFields[selection.name.value];
            nonUniqueSubschemas = nonUniqueSubschemas.filter(function (s) {
                return proxiableSubschemas.includes(s);
            });
            if (nonUniqueSubschemas != null) {
                var subschemas_1 = Array.from(delegationMap.keys());
                var existingSubschema = nonUniqueSubschemas.find(function (s) {
                    return subschemas_1.includes(s);
                });
                if (existingSubschema != null) {
                    delegationMap.get(existingSubschema).push(selection);
                }
                else {
                    delegationMap.set(nonUniqueSubschemas[0], [selection]);
                }
            }
            else {
                unproxiableSelections.push(selection);
            }
        }
    });
    return {
        delegationMap: delegationMap,
        unproxiableSelections: unproxiableSelections,
        proxiableSubschemas: proxiableSubschemas,
        nonProxiableSubschemas: nonProxiableSubschemas,
    };
}
function mergeFields(mergedTypeInfo, typeName, object, originalSelections, sourceSubschemas, targetSubschemas, context, info) {
    if (!originalSelections.length) {
        return object;
    }
    var _a = buildDelegationPlan(mergedTypeInfo, originalSelections, sourceSubschemas, targetSubschemas), delegationMap = _a.delegationMap, unproxiableSelections = _a.unproxiableSelections, proxiableSubschemas = _a.proxiableSubschemas, nonProxiableSubschemas = _a.nonProxiableSubschemas;
    if (!delegationMap.size) {
        return object;
    }
    var maybePromises = [];
    delegationMap.forEach(function (selections, s) {
        var maybePromise = s.merge[typeName].resolve(object, context, info, s, {
            kind: graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].SELECTION_SET,
            selections: selections,
        });
        maybePromises.push(maybePromise);
    });
    var containsPromises = false;
    for (var _i = 0, maybePromises_1 = maybePromises; _i < maybePromises_1.length; _i++) {
        var maybePromise = maybePromises_1[_i];
        if (maybePromise instanceof Promise) {
            containsPromises = true;
            break;
        }
    }
    return containsPromises
        ? Promise.all(maybePromises).then(function (results) {
            return mergeFields(mergedTypeInfo, typeName, mergeProxiedResults.apply(void 0, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __spreadArrays */ "d"])([object], results)), unproxiableSelections, sourceSubschemas.concat(proxiableSubschemas), nonProxiableSubschemas, context, info);
        })
        : mergeFields(mergedTypeInfo, typeName, mergeProxiedResults.apply(void 0, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __spreadArrays */ "d"])([object], maybePromises)), unproxiableSelections, sourceSubschemas.concat(proxiableSubschemas), nonProxiableSubschemas, context, info);
}

function handleObject(type, object, errors, subschema, context, info, skipTypeMerging) {
    setErrors(object, errors.map(function (error) {
        return relocatedError(error, error.nodes, error.path != null ? error.path.slice(1) : undefined);
    }));
    setObjectSubschema(object, subschema);
    if (skipTypeMerging || !info.mergeInfo) {
        return object;
    }
    var typeName = Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isAbstractType"])(type)
        ? info.schema.getTypeMap()[resolveFromParentTypename(object)].name
        : type.name;
    var mergedTypeInfo = info.mergeInfo.mergedTypes[typeName];
    var targetSubschemas;
    if (mergedTypeInfo != null) {
        targetSubschemas = mergedTypeInfo.subschemas;
    }
    if (!targetSubschemas) {
        return object;
    }
    targetSubschemas = targetSubschemas.filter(function (s) { return s !== subschema; });
    if (!targetSubschemas.length) {
        return object;
    }
    var subFields = collectSubFields(info, object.__typename);
    var selections = getFieldsNotInSubschema(subFields, subschema, mergedTypeInfo, object.__typename);
    return mergeFields(mergedTypeInfo, typeName, object, selections, [subschema], targetSubschemas, context, info);
}
function collectSubFields(info, typeName) {
    var subFieldNodes = Object.create(null);
    var visitedFragmentNames = Object.create(null);
    info.fieldNodes.forEach(function (fieldNode) {
        subFieldNodes = collectFields({
            schema: info.schema,
            variableValues: info.variableValues,
            fragments: info.fragments,
        }, info.schema.getType(typeName), fieldNode.selectionSet, subFieldNodes, visitedFragmentNames);
    });
    return subFieldNodes;
}
function getFieldsNotInSubschema(subFieldNodes, subschema, mergedTypeInfo, typeName) {
    var typeMap = isSubschemaConfig(subschema)
        ? mergedTypeInfo.typeMaps.get(subschema)
        : subschema.getTypeMap();
    var fields = typeMap[typeName].getFields();
    var fieldsNotInSchema = [];
    Object.keys(subFieldNodes).forEach(function (responseName) {
        subFieldNodes[responseName].forEach(function (subFieldNode) {
            if (!(subFieldNode.name.value in fields)) {
                fieldsNotInSchema.push(subFieldNode);
            }
        });
    });
    return fieldsNotInSchema;
}

function handleList(type, list, errors, subschema, context, info, skipTypeMerging) {
    var childErrors = getErrorsByPathSegment(errors);
    return list.map(function (listMember, index) {
        return handleListMember(Object(graphql__WEBPACK_IMPORTED_MODULE_3__["getNullableType"])(type.ofType), listMember, index, index in childErrors ? childErrors[index] : [], subschema, context, info, skipTypeMerging);
    });
}
function handleListMember(type, listMember, index, errors, subschema, context, info, skipTypeMerging) {
    if (listMember == null) {
        return handleNull(info.fieldNodes, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __spreadArrays */ "d"])(Object(graphql__WEBPACK_IMPORTED_MODULE_3__["responsePathAsArray"])(info.path), [index]), errors);
    }
    if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isLeafType"])(type)) {
        return type.parseValue(listMember);
    }
    else if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isCompositeType"])(type)) {
        return handleObject(type, listMember, errors, subschema, context, info, skipTypeMerging);
    }
    else if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isListType"])(type)) {
        return handleList(type, listMember, errors, subschema, context, info, skipTypeMerging);
    }
}

function checkResultAndHandleErrors(result, context, info, responseKey, subschema, returnType, skipTypeMerging) {
    if (responseKey === void 0) { responseKey = getResponseKeyFromInfo(info); }
    if (returnType === void 0) { returnType = info.returnType; }
    var errors = result.errors != null ? result.errors : [];
    var data = result.data != null ? result.data[responseKey] : undefined;
    return handleResult(data, errors, subschema, context, info, returnType, skipTypeMerging);
}
function handleResult(result, errors, subschema, context, info, returnType, skipTypeMerging) {
    if (returnType === void 0) { returnType = info.returnType; }
    var type = Object(graphql__WEBPACK_IMPORTED_MODULE_3__["getNullableType"])(returnType);
    if (result == null) {
        return handleNull(info.fieldNodes, Object(graphql__WEBPACK_IMPORTED_MODULE_3__["responsePathAsArray"])(info.path), errors);
    }
    if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isLeafType"])(type)) {
        return type.parseValue(result);
    }
    else if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isCompositeType"])(type)) {
        return handleObject(type, result, errors, subschema, context, info, skipTypeMerging);
    }
    else if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isListType"])(type)) {
        return handleList(type, result, errors, subschema, context, info, skipTypeMerging);
    }
}

var CheckResultAndHandleErrors = /** @class */ (function () {
    function CheckResultAndHandleErrors(info, fieldName, subschema, context, returnType, typeMerge) {
        if (returnType === void 0) { returnType = info.returnType; }
        this.context = context;
        this.info = info;
        this.fieldName = fieldName;
        this.subschema = subschema;
        this.returnType = returnType;
        this.typeMerge = typeMerge;
    }
    CheckResultAndHandleErrors.prototype.transformResult = function (result) {
        return checkResultAndHandleErrors(result, this.context != null ? this.context : {}, this.info, this.fieldName, this.subschema, this.returnType, this.typeMerge);
    };
    return CheckResultAndHandleErrors;
}());

function transformInputValue(type, value, transformer) {
    if (value == null) {
        return value;
    }
    var nullableType = Object(graphql__WEBPACK_IMPORTED_MODULE_3__["getNullableType"])(type);
    if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isLeafType"])(nullableType)) {
        return transformer(nullableType, value);
    }
    else if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isListType"])(nullableType)) {
        return value.map(function (listMember) {
            return transformInputValue(nullableType.ofType, listMember, transformer);
        });
    }
    else if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isInputObjectType"])(nullableType)) {
        var fields_1 = nullableType.getFields();
        return keyValMap(Object.keys(value), function (key) { return key; }, function (key) { return transformInputValue(fields_1[key].type, value[key], transformer); });
    }
    // unreachable, no other possible return value
}
function serializeInputValue(type, value) {
    return transformInputValue(type, value, function (t, v) { return t.serialize(v); });
}
function parseInputValue(type, value) {
    return transformInputValue(type, value, function (t, v) { return t.parseValue(v); });
}

function astFromType(type) {
    if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isNonNullType"])(type)) {
        var innerType = astFromType(type.ofType);
        if (innerType.kind === graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].NON_NULL_TYPE) {
            throw new Error("Invalid type node " + JSON.stringify(type) + ". Inner type of non-null type cannot be a non-null type.");
        }
        return {
            kind: graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].NON_NULL_TYPE,
            type: innerType,
        };
    }
    else if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isListType"])(type)) {
        return {
            kind: graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].LIST_TYPE,
            type: astFromType(type.ofType),
        };
    }
    return {
        kind: graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].NAMED_TYPE,
        name: {
            kind: graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].NAME,
            value: type.name,
        },
    };
}

function updateArgument(argName, argType, argumentNodes, variableDefinitionsMap, variableValues, newArg) {
    var varName;
    var numGeneratedVariables = 0;
    do {
        varName = "_v" + (numGeneratedVariables++).toString() + "_" + argName;
    } while (varName in variableDefinitionsMap);
    argumentNodes[argName] = {
        kind: graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].ARGUMENT,
        name: {
            kind: graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].NAME,
            value: argName,
        },
        value: {
            kind: graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].VARIABLE,
            name: {
                kind: graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].NAME,
                value: varName,
            },
        },
    };
    variableDefinitionsMap[varName] = {
        kind: graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].VARIABLE_DEFINITION,
        variable: {
            kind: graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].VARIABLE,
            name: {
                kind: graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].NAME,
                value: varName,
            },
        },
        type: astFromType(argType),
    };
    variableValues[varName] = newArg;
}

function toObjMap(obj) {
    if (Object.getPrototypeOf(obj) === null) {
        return obj;
    }
    return Object.entries(obj).reduce(function (map, _a) {
        var key = _a[0], value = _a[1];
        map[key] = value;
        return map;
    }, Object.create(null));
}

var AddArgumentsAsVariables = /** @class */ (function () {
    function AddArgumentsAsVariables(targetSchema, args) {
        this.targetSchema = targetSchema;
        this.args = toObjMap(args);
    }
    AddArgumentsAsVariables.prototype.transformRequest = function (originalRequest) {
        var _a = addVariablesToRootField(this.targetSchema, originalRequest, this.args), document = _a.document, newVariables = _a.newVariables;
        return {
            document: document,
            variables: newVariables,
        };
    };
    return AddArgumentsAsVariables;
}());
function addVariablesToRootField(targetSchema, originalRequest, args) {
    var document = originalRequest.document;
    var variableValues = originalRequest.variables;
    var operations = document.definitions.filter(function (def) { return def.kind === graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].OPERATION_DEFINITION; });
    var fragments = document.definitions.filter(function (def) { return def.kind === graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].FRAGMENT_DEFINITION; });
    var newOperations = operations.map(function (operation) {
        var variableDefinitionMap = keyValMap(operation.variableDefinitions, function (def) { return def.variable.name.value; }, function (def) { return def; });
        var type;
        if (operation.operation === 'subscription') {
            type = targetSchema.getSubscriptionType();
        }
        else if (operation.operation === 'mutation') {
            type = targetSchema.getMutationType();
        }
        else {
            type = targetSchema.getQueryType();
        }
        var newSelectionSet = [];
        operation.selectionSet.selections.forEach(function (selection) {
            if (selection.kind === graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].FIELD) {
                var argumentNodes = selection.arguments;
                var argumentNodeMap_1 = keyValMap(argumentNodes, function (argument) { return argument.name.value; }, function (argument) { return argument; });
                var targetField = type.getFields()[selection.name.value];
                // excludes __typename
                if (targetField != null) {
                    updateArguments(targetField, argumentNodeMap_1, variableDefinitionMap, variableValues, args);
                }
                newSelectionSet.push(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, selection), { arguments: Object.keys(argumentNodeMap_1).map(function (argName) { return argumentNodeMap_1[argName]; }) }));
            }
            else {
                newSelectionSet.push(selection);
            }
        });
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, operation), { variableDefinitions: Object.keys(variableDefinitionMap).map(function (varName) { return variableDefinitionMap[varName]; }), selectionSet: {
                kind: graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].SELECTION_SET,
                selections: newSelectionSet,
            } });
    });
    return {
        document: Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, document), { definitions: Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __spreadArrays */ "d"])(newOperations, fragments) }),
        newVariables: variableValues,
    };
}
function updateArguments(targetField, argumentNodeMap, variableDefinitionMap, variableValues, newArgs) {
    targetField.args.forEach(function (argument) {
        var argName = argument.name;
        var argType = argument.type;
        if (argName in newArgs) {
            updateArgument(argName, argType, argumentNodeMap, variableDefinitionMap, variableValues, serializeInputValue(argType, newArgs[argName]));
        }
    });
}

var version;
if (graphql__WEBPACK_IMPORTED_MODULE_3__["versionInfo"] != null && graphql__WEBPACK_IMPORTED_MODULE_3__["versionInfo"].major >= 15) {
    version = 15;
}
else if (graphql__WEBPACK_IMPORTED_MODULE_3__["getOperationRootType"] != null) {
    version = 14;
}
else if (graphql__WEBPACK_IMPORTED_MODULE_3__["lexicographicSortSchema"] != null) {
    version = 13;
}
else if (graphql__WEBPACK_IMPORTED_MODULE_3__["printError"] != null) {
    version = 12;
}
else {
    version = 11;
}
function graphqlVersion() {
    return version;
}

var hasOwn = Object.prototype.hasOwnProperty;
function hasOwnProperty(object, propertyName) {
    return hasOwn.call(object, propertyName);
}

// graphql <v14.2 does not support toConfig
function schemaToConfig(schema) {
    if (schema.toConfig != null) {
        return schema.toConfig();
    }
    var newTypes = [];
    var types = schema.getTypeMap();
    Object.keys(types).forEach(function (typeName) {
        newTypes.push(types[typeName]);
    });
    var schemaConfig = {
        query: schema.getQueryType(),
        mutation: schema.getMutationType(),
        subscription: schema.getSubscriptionType(),
        types: newTypes,
        directives: schema.getDirectives().slice(),
        extensions: schema.extensions,
        astNode: schema.astNode,
        extensionASTNodes: schema.extensionASTNodes != null ? schema.extensionASTNodes : [],
        assumeValid: schema.__validationErrors !==
            undefined,
    };
    if (graphqlVersion() >= 15) {
        schemaConfig.description = schema.description;
    }
    return schemaConfig;
}
function toConfig(graphqlObject) {
    if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isSchema"])(graphqlObject)) {
        return schemaToConfig(graphqlObject);
    }
    else if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isDirective"])(graphqlObject)) {
        return directiveToConfig(graphqlObject);
    }
    else if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isNamedType"])(graphqlObject)) {
        return typeToConfig(graphqlObject);
    }
    // Input and output fields do not have predicates defined, but using duck typing,
    // type is defined for input and output fields
    if (graphqlObject.type != null) {
        if (graphqlObject.args != null ||
            graphqlObject.resolve != null ||
            graphqlObject.subscribe != null) {
            return fieldToConfig(graphqlObject);
        }
        else if (graphqlObject.defaultValue !== undefined) {
            return inputFieldToConfig(graphqlObject);
        }
        // Not all input and output fields can be checked by above in older versions
        // of graphql, but almost all properties on the field and config are identical.
        // In particular, just name and isDeprecated should be removed.
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        var name_1 = graphqlObject.name, isDeprecated = graphqlObject.isDeprecated, rest = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __rest */ "c"])(graphqlObject, ["name", "isDeprecated"]);
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, rest);
    }
    throw new Error("Unknown graphql object " + graphqlObject);
}
function typeToConfig(type) {
    if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isObjectType"])(type)) {
        return objectTypeToConfig(type);
    }
    else if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isInterfaceType"])(type)) {
        return interfaceTypeToConfig(type);
    }
    else if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isUnionType"])(type)) {
        return unionTypeToConfig(type);
    }
    else if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isEnumType"])(type)) {
        return enumTypeToConfig(type);
    }
    else if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isScalarType"])(type)) {
        return scalarTypeToConfig(type);
    }
    else if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isInputObjectType"])(type)) {
        return inputObjectTypeToConfig(type);
    }
    throw new Error("Unknown type " + type);
}
function objectTypeToConfig(type) {
    if (type.toConfig != null) {
        return type.toConfig();
    }
    var typeConfig = {
        name: type.name,
        description: type.description,
        interfaces: type.getInterfaces(),
        fields: fieldMapToConfig(type.getFields()),
        isTypeOf: type.isTypeOf,
        extensions: type.extensions,
        astNode: type.astNode,
        extensionASTNodes: type.extensionASTNodes != null ? type.extensionASTNodes : [],
    };
    return typeConfig;
}
function interfaceTypeToConfig(type) {
    if (type.toConfig != null) {
        return type.toConfig();
    }
    var typeConfig = {
        name: type.name,
        description: type.description,
        fields: fieldMapToConfig(type.getFields()),
        resolveType: type.resolveType,
        extensions: type.extensions,
        astNode: type.astNode,
        extensionASTNodes: type.extensionASTNodes != null ? type.extensionASTNodes : [],
    };
    if (graphqlVersion() >= 15) {
        typeConfig.interfaces = type.getInterfaces();
    }
    return typeConfig;
}
function unionTypeToConfig(type) {
    if (type.toConfig != null) {
        return type.toConfig();
    }
    var typeConfig = {
        name: type.name,
        description: type.description,
        types: type.getTypes(),
        resolveType: type.resolveType,
        extensions: type.extensions,
        astNode: type.astNode,
        extensionASTNodes: type.extensionASTNodes != null ? type.extensionASTNodes : [],
    };
    return typeConfig;
}
function enumTypeToConfig(type) {
    if (type.toConfig != null) {
        return type.toConfig();
    }
    var newValues = keyValMap(type.getValues(), function (value) { return value.name; }, function (value) { return ({
        description: value.description,
        value: value.value,
        deprecationReason: value.deprecationReason,
        extensions: value.extensions,
        astNode: value.astNode,
    }); });
    var typeConfig = {
        name: type.name,
        description: type.description,
        values: newValues,
        extensions: type.extensions,
        astNode: type.astNode,
        extensionASTNodes: type.extensionASTNodes != null ? type.extensionASTNodes : [],
    };
    return typeConfig;
}
function scalarTypeToConfig(type) {
    if (type.toConfig != null) {
        return type.toConfig();
    }
    var typeConfig = {
        name: type.name,
        description: type.description,
        serialize: graphqlVersion() >= 14 || hasOwnProperty(type, 'serialize')
            ? type.serialize
            : type._scalarConfig.serialize,
        parseValue: graphqlVersion() >= 14 || hasOwnProperty(type, 'parseValue')
            ? type.parseValue
            : type._scalarConfig.parseValue,
        parseLiteral: graphqlVersion() >= 14 || hasOwnProperty(type, 'parseLiteral')
            ? type.parseLiteral
            : type._scalarConfig.parseLiteral,
        extensions: type.extensions,
        astNode: type.astNode,
        extensionASTNodes: type.extensionASTNodes != null ? type.extensionASTNodes : [],
    };
    return typeConfig;
}
function inputObjectTypeToConfig(type) {
    if (type.toConfig != null) {
        return type.toConfig();
    }
    var typeConfig = {
        name: type.name,
        description: type.description,
        fields: inputFieldMapToConfig(type.getFields()),
        extensions: type.extensions,
        astNode: type.astNode,
        extensionASTNodes: type.extensionASTNodes != null ? type.extensionASTNodes : [],
    };
    return typeConfig;
}
function inputFieldMapToConfig(fields) {
    return keyValMap(Object.keys(fields), function (fieldName) { return fieldName; }, function (fieldName) { return toConfig(fields[fieldName]); });
}
function inputFieldToConfig(field) {
    return {
        description: field.description,
        type: field.type,
        defaultValue: field.defaultValue,
        extensions: field.extensions,
        astNode: field.astNode,
    };
}
function directiveToConfig(directive) {
    if (directive.toConfig != null) {
        return directive.toConfig();
    }
    var directiveConfig = {
        name: directive.name,
        description: directive.description,
        locations: directive.locations,
        args: argumentMapToConfig(directive.args),
        isRepeatable: directive.isRepeatable,
        extensions: directive.extensions,
        astNode: directive.astNode,
    };
    return directiveConfig;
}
function fieldMapToConfig(fields) {
    return keyValMap(Object.keys(fields), function (fieldName) { return fieldName; }, function (fieldName) { return toConfig(fields[fieldName]); });
}
function fieldToConfig(field) {
    return {
        description: field.description,
        type: field.type,
        args: argumentMapToConfig(field.args),
        resolve: field.resolve,
        subscribe: field.subscribe,
        deprecationReason: field.deprecationReason,
        extensions: field.extensions,
        astNode: field.astNode,
    };
}
function argumentMapToConfig(args) {
    var newArguments = {};
    args.forEach(function (arg) {
        newArguments[arg.name] = argumentToConfig(arg);
    });
    return newArguments;
}
function argumentToConfig(arg) {
    return {
        description: arg.description,
        type: arg.type,
        defaultValue: arg.defaultValue,
        extensions: arg.extensions,
        astNode: arg.astNode,
    };
}

function isSpecifiedScalarType(type) {
    return (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isNamedType"])(type) &&
        // Would prefer to use specifiedScalarTypes.some(), however %checks needs
        // a simple expression.
        (type.name === graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLString"].name ||
            type.name === graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLInt"].name ||
            type.name === graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLFloat"].name ||
            type.name === graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLBoolean"].name ||
            type.name === graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLID"].name));
}

function mapSchema(schema, schemaMapper) {
    if (schemaMapper === void 0) { schemaMapper = {}; }
    var originalTypeMap = schema.getTypeMap();
    var newTypeMap = Object.create(null);
    Object.keys(originalTypeMap).forEach(function (typeName) {
        if (!typeName.startsWith('__')) {
            var typeMapper = getMapper(schema, schemaMapper, originalTypeMap[typeName]);
            if (typeMapper != null) {
                var newType = typeMapper(originalTypeMap[typeName], schema);
                newTypeMap[typeName] =
                    newType !== undefined ? newType : originalTypeMap[typeName];
            }
            else {
                newTypeMap[typeName] = originalTypeMap[typeName];
            }
        }
    });
    var queryType = schema.getQueryType();
    var mutationType = schema.getMutationType();
    var subscriptionType = schema.getSubscriptionType();
    var newQueryTypeName = queryType != null
        ? newTypeMap[queryType.name] != null
            ? newTypeMap[queryType.name].name
            : undefined
        : undefined;
    var newMutationTypeName = mutationType != null
        ? newTypeMap[mutationType.name] != null
            ? newTypeMap[mutationType.name].name
            : undefined
        : undefined;
    var newSubscriptionTypeName = subscriptionType != null
        ? newTypeMap[subscriptionType.name] != null
            ? newTypeMap[subscriptionType.name].name
            : undefined
        : undefined;
    var originalDirectives = schema.getDirectives();
    var newDirectives = [];
    originalDirectives.forEach(function (directive) {
        var directiveMapper = getMapper(schema, schemaMapper, directive);
        if (directiveMapper != null) {
            var newDirective = directiveMapper(directive, schema);
            if (newDirective != null) {
                newDirectives.push(newDirective);
            }
        }
        else {
            newDirectives.push(directive);
        }
    });
    var _a = rewireTypes(newTypeMap, newDirectives), typeMap = _a.typeMap, directives = _a.directives;
    return new graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLSchema"](Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, toConfig(schema)), { query: newQueryTypeName
            ? typeMap[newQueryTypeName]
            : undefined, mutation: newMutationTypeName
            ? typeMap[newMutationTypeName]
            : undefined, subscription: newSubscriptionTypeName != null
            ? typeMap[newSubscriptionTypeName]
            : undefined, types: Object.keys(typeMap).map(function (typeName) { return typeMap[typeName]; }), directives: directives }));
}
function getTypeSpecifiers(type, schema) {
    var specifiers = [MapperKind.TYPE];
    if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isObjectType"])(type)) {
        specifiers.push(MapperKind.COMPOSITE_TYPE, MapperKind.OBJECT_TYPE);
        var query = schema.getQueryType();
        var mutation = schema.getMutationType();
        var subscription = schema.getSubscriptionType();
        if (type === query) {
            specifiers.push(MapperKind.ROOT_OBJECT, MapperKind.QUERY);
        }
        else if (type === mutation) {
            specifiers.push(MapperKind.ROOT_OBJECT, MapperKind.MUTATION);
        }
        else if (type === subscription) {
            specifiers.push(MapperKind.ROOT_OBJECT, MapperKind.SUBSCRIPTION);
        }
    }
    else if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isInputType"])(type)) {
        specifiers.push(MapperKind.INPUT_OBJECT_TYPE);
    }
    else if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isInterfaceType"])(type)) {
        specifiers.push(MapperKind.COMPOSITE_TYPE, MapperKind.ABSTRACT_TYPE, MapperKind.INTERFACE_TYPE);
    }
    else if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isUnionType"])(type)) {
        specifiers.push(MapperKind.COMPOSITE_TYPE, MapperKind.ABSTRACT_TYPE, MapperKind.UNION_TYPE);
    }
    else if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isEnumType"])(type)) {
        specifiers.push(MapperKind.ENUM_TYPE);
    }
    else if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isScalarType"])(type)) {
        specifiers.push(MapperKind.SCALAR_TYPE);
    }
    return specifiers;
}
function getMapper(schema, schemaMapper, typeOrDirective) {
    if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isNamedType"])(typeOrDirective)) {
        var specifiers = getTypeSpecifiers(typeOrDirective, schema);
        var typeMapper = void 0;
        var stack = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __spreadArrays */ "d"])(specifiers);
        while (!typeMapper && stack.length > 0) {
            var next = stack.pop();
            typeMapper = schemaMapper[next];
        }
        return typeMapper != null ? typeMapper : null;
    }
    else if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isDirective"])(typeOrDirective)) {
        var directiveMapper = schemaMapper[MapperKind.DIRECTIVE];
        return directiveMapper != null ? directiveMapper : null;
    }
}
function rewireTypes(originalTypeMap, directives) {
    var newTypeMap = Object.create(null);
    Object.keys(originalTypeMap).forEach(function (typeName) {
        var namedType = originalTypeMap[typeName];
        if (namedType == null || typeName.startsWith('__')) {
            return;
        }
        var newName = namedType.name;
        if (newName.startsWith('__')) {
            return;
        }
        if (newTypeMap[newName] != null) {
            throw new Error("Duplicate schema type name " + newName);
        }
        newTypeMap[newName] = namedType;
    });
    Object.keys(newTypeMap).forEach(function (typeName) {
        newTypeMap[typeName] = rewireNamedType(newTypeMap[typeName]);
    });
    var newDirectives = directives.map(function (directive) {
        return rewireDirective(directive);
    });
    return pruneTypes(newTypeMap, newDirectives);
    function rewireDirective(directive) {
        var directiveConfig = toConfig(directive);
        directiveConfig.args = rewireArgs(directiveConfig.args);
        return new graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLDirective"](directiveConfig);
    }
    function rewireArgs(args) {
        var rewiredArgs = {};
        Object.keys(args).forEach(function (argName) {
            var arg = args[argName];
            var rewiredArgType = rewireType(arg.type);
            if (rewiredArgType != null) {
                arg.type = rewiredArgType;
                rewiredArgs[argName] = arg;
            }
        });
        return rewiredArgs;
    }
    function rewireNamedType(type) {
        if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isObjectType"])(type)) {
            var config_1 = toConfig(type);
            var newConfig = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, config_1), { fields: function () { return rewireFields(config_1.fields); }, interfaces: function () { return rewireNamedTypes(config_1.interfaces); } });
            return new graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLObjectType"](newConfig);
        }
        else if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isInterfaceType"])(type)) {
            var config_2 = toConfig(type);
            var newConfig = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, config_2), { fields: function () { return rewireFields(config_2.fields); } });
            if (graphqlVersion() >= 15) {
                newConfig.interfaces = function () { return rewireNamedTypes(config_2.interfaces); };
            }
            return new graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLInterfaceType"](newConfig);
        }
        else if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isUnionType"])(type)) {
            var config_3 = toConfig(type);
            var newConfig = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, config_3), { types: function () { return rewireNamedTypes(config_3.types); } });
            return new graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLUnionType"](newConfig);
        }
        else if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isInputObjectType"])(type)) {
            var config_4 = toConfig(type);
            var newConfig = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, config_4), { fields: function () { return rewireInputFields(config_4.fields); } });
            return new graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLInputObjectType"](newConfig);
        }
        else if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isEnumType"])(type)) {
            var enumConfig = toConfig(type);
            return new graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLEnumType"](enumConfig);
        }
        else if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isScalarType"])(type)) {
            if (isSpecifiedScalarType(type)) {
                return type;
            }
            var scalarConfig = toConfig(type);
            return new graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLScalarType"](scalarConfig);
        }
        throw new Error("Unexpected schema type: " + type);
    }
    function rewireFields(fields) {
        var rewiredFields = {};
        Object.keys(fields).forEach(function (fieldName) {
            var field = fields[fieldName];
            var rewiredFieldType = rewireType(field.type);
            if (rewiredFieldType != null) {
                field.type = rewiredFieldType;
                field.args = rewireArgs(field.args);
                rewiredFields[fieldName] = field;
            }
        });
        return rewiredFields;
    }
    function rewireInputFields(fields) {
        var rewiredFields = {};
        Object.keys(fields).forEach(function (fieldName) {
            var field = fields[fieldName];
            var rewiredFieldType = rewireType(field.type);
            if (rewiredFieldType != null) {
                field.type = rewiredFieldType;
                rewiredFields[fieldName] = field;
            }
        });
        return rewiredFields;
    }
    function rewireNamedTypes(namedTypes) {
        var rewiredTypes = [];
        namedTypes.forEach(function (namedType) {
            var rewiredType = rewireType(namedType);
            if (rewiredType != null) {
                rewiredTypes.push(rewiredType);
            }
        });
        return rewiredTypes;
    }
    function rewireType(type) {
        if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isListType"])(type)) {
            var rewiredType = rewireType(type.ofType);
            return rewiredType != null ? new graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLList"](rewiredType) : null;
        }
        else if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isNonNullType"])(type)) {
            var rewiredType = rewireType(type.ofType);
            return rewiredType != null
                ? new graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLNonNull"](rewiredType)
                : null;
        }
        else if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isNamedType"])(type)) {
            var originalType = originalTypeMap[type.name];
            return originalType != null ? newTypeMap[originalType.name] : null;
        }
        return null;
    }
}
function pruneTypes(typeMap, directives) {
    var newTypeMap = {};
    var implementedInterfaces = {};
    Object.keys(typeMap).forEach(function (typeName) {
        var namedType = typeMap[typeName];
        if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isObjectType"])(namedType) ||
            (graphqlVersion() >= 15 && Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isInterfaceType"])(namedType))) {
            namedType.getInterfaces().forEach(function (iface) {
                implementedInterfaces[iface.name] = true;
            });
        }
    });
    var prunedTypeMap = false;
    var typeNames = Object.keys(typeMap);
    for (var i = 0; i < typeNames.length; i++) {
        var typeName = typeNames[i];
        var type = typeMap[typeName];
        if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isObjectType"])(type) || Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isInputObjectType"])(type)) {
            // prune types with no fields
            if (Object.keys(type.getFields()).length) {
                newTypeMap[typeName] = type;
            }
            else {
                prunedTypeMap = true;
            }
        }
        else if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isUnionType"])(type)) {
            // prune unions without underlying types
            if (type.getTypes().length) {
                newTypeMap[typeName] = type;
            }
            else {
                prunedTypeMap = true;
            }
        }
        else if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isInterfaceType"])(type)) {
            // prune interfaces without fields or without implementations
            if (Object.keys(type.getFields()).length &&
                implementedInterfaces[type.name]) {
                newTypeMap[typeName] = type;
            }
            else {
                prunedTypeMap = true;
            }
        }
        else {
            newTypeMap[typeName] = type;
        }
    }
    // every prune requires another round of healing
    return prunedTypeMap
        ? rewireTypes(newTypeMap, directives)
        : { typeMap: typeMap, directives: directives };
}

function filterSchema(_a) {
    var _b;
    var schema = _a.schema, _c = _a.rootFieldFilter, rootFieldFilter = _c === void 0 ? function () { return true; } : _c, _d = _a.typeFilter, typeFilter = _d === void 0 ? function () { return true; } : _d, _e = _a.fieldFilter, fieldFilter = _e === void 0 ? function () { return true; } : _e;
    var filteredSchema = mapSchema(schema, (_b = {},
        _b[MapperKind.QUERY] = function (type) {
            return filterRootFields(type, 'Query', rootFieldFilter);
        },
        _b[MapperKind.MUTATION] = function (type) {
            return filterRootFields(type, 'Mutation', rootFieldFilter);
        },
        _b[MapperKind.SUBSCRIPTION] = function (type) {
            return filterRootFields(type, 'Subscription', rootFieldFilter);
        },
        _b[MapperKind.OBJECT_TYPE] = function (type) {
            return typeFilter(type.name, type)
                ? filterObjectFields(type, fieldFilter)
                : null;
        },
        _b[MapperKind.INTERFACE_TYPE] = function (type) {
            return typeFilter(type.name, type) ? undefined : null;
        },
        _b[MapperKind.UNION_TYPE] = function (type) {
            return typeFilter(type.name, type) ? undefined : null;
        },
        _b[MapperKind.INPUT_OBJECT_TYPE] = function (type) {
            return typeFilter(type.name, type) ? undefined : null;
        },
        _b[MapperKind.ENUM_TYPE] = function (type) {
            return typeFilter(type.name, type) ? undefined : null;
        },
        _b[MapperKind.SCALAR_TYPE] = function (type) {
            return typeFilter(type.name, type) ? undefined : null;
        },
        _b));
    filteredSchema.transforms = schema.transforms;
    return filteredSchema;
}
function filterRootFields(type, operation, rootFieldFilter) {
    var config = toConfig(type);
    Object.keys(config.fields).forEach(function (fieldName) {
        if (!rootFieldFilter(operation, fieldName, config.fields[fieldName])) {
            delete config.fields[fieldName];
        }
    });
    return new graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLObjectType"](config);
}
function filterObjectFields(type, fieldFilter) {
    var config = toConfig(type);
    Object.keys(config.fields).forEach(function (fieldName) {
        if (!fieldFilter(type.name, fieldName, config.fields[fieldName])) {
            delete config.fields[fieldName];
        }
    });
    return new graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLObjectType"](config);
}

function cloneDirective(directive) {
    return new graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLDirective"](toConfig(directive));
}
function cloneType(type) {
    if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isObjectType"])(type)) {
        var config = toConfig(type);
        return new graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLObjectType"](Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, config), { interfaces: typeof config.interfaces === 'function'
                ? config.interfaces
                : config.interfaces.slice() }));
    }
    else if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isInterfaceType"])(type)) {
        var config = toConfig(type);
        var newConfig = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, config), { interfaces: graphqlVersion() >= 15
                ? typeof config.interfaces === 'function'
                    ? config.interfaces
                    : config.interfaces.slice()
                : undefined });
        return new graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLInterfaceType"](newConfig);
    }
    else if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isUnionType"])(type)) {
        var config = toConfig(type);
        return new graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLUnionType"](Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, config), { types: config.types.slice() }));
    }
    else if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isInputObjectType"])(type)) {
        return new graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLInputObjectType"](toConfig(type));
    }
    else if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isEnumType"])(type)) {
        return new graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLEnumType"](toConfig(type));
    }
    else if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isScalarType"])(type)) {
        return isSpecifiedScalarType(type)
            ? type
            : new graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLScalarType"](toConfig(type));
    }
    throw new Error("Invalid type " + type);
}
function cloneSchema(schema) {
    return mapSchema(schema);
}

// polyfill for graphql prior to v13 which do not pass options to buildASTSchema
function buildSchema(ast, buildSchemaOptions) {
    return Object(graphql__WEBPACK_IMPORTED_MODULE_3__["buildASTSchema"])(Object(graphql__WEBPACK_IMPORTED_MODULE_3__["parse"])(ast), buildSchemaOptions);
}

function getResolversFromSchema(schema) {
    var resolvers = Object.create({});
    var typeMap = schema.getTypeMap();
    Object.keys(typeMap).forEach(function (typeName) {
        var type = typeMap[typeName];
        if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isScalarType"])(type)) {
            if (!isSpecifiedScalarType(type)) {
                resolvers[typeName] = cloneType(type);
            }
        }
        else if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isEnumType"])(type)) {
            resolvers[typeName] = {};
            var values = type.getValues();
            values.forEach(function (value) {
                resolvers[typeName][value.name] = value.value;
            });
        }
        else if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isInterfaceType"])(type)) {
            if (type.resolveType != null) {
                resolvers[typeName] = {
                    __resolveType: type.resolveType,
                };
            }
        }
        else if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isUnionType"])(type)) {
            if (type.resolveType != null) {
                resolvers[typeName] = {
                    __resolveType: type.resolveType,
                };
            }
        }
        else if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isObjectType"])(type)) {
            resolvers[typeName] = {};
            if (type.isTypeOf != null) {
                resolvers[typeName].__isTypeOf = type.isTypeOf;
            }
            var fields_1 = type.getFields();
            Object.keys(fields_1).forEach(function (fieldName) {
                var field = fields_1[fieldName];
                resolvers[typeName][fieldName] = {
                    resolve: field.resolve,
                    subscribe: field.subscribe,
                };
            });
        }
    });
    return resolvers;
}

// polyfill for graphql < v14.2 which does not support subscriptions
function extendSchema(schema, extension, options) {
    var subscriptionType = schema.getSubscriptionType();
    if (subscriptionType == null) {
        return Object(graphql__WEBPACK_IMPORTED_MODULE_3__["extendSchema"])(schema, extension, options);
    }
    var resolvers = getResolversFromSchema(schema);
    var subscriptionTypeName = subscriptionType.name;
    var subscriptionResolvers = resolvers[subscriptionTypeName];
    var extendedSchema = Object(graphql__WEBPACK_IMPORTED_MODULE_3__["extendSchema"])(schema, extension, options);
    var fields = extendedSchema.getSubscriptionType().getFields();
    Object.keys(subscriptionResolvers).forEach(function (fieldName) {
        fields[fieldName].subscribe = subscriptionResolvers[fieldName].subscribe;
    });
    return extendedSchema;
}

// A generic updater function for arrays or objects.
function updateEachKey(arrayOrObject, 
// The callback can return nothing or undefined to leave the key untouched, null to remove
// the key from the array or object, or a non-null V to replace the value.
updater) {
    var deletedCount = 0;
    Object.keys(arrayOrObject).forEach(function (key) {
        var result = updater(arrayOrObject[key], key);
        if (typeof result === 'undefined') {
            return;
        }
        if (result === null) {
            delete arrayOrObject[key];
            deletedCount++;
            return;
        }
        arrayOrObject[key] = result;
    });
    if (deletedCount > 0 && Array.isArray(arrayOrObject)) {
        // Remove any holes from the array due to deleted elements.
        arrayOrObject.splice(0).forEach(function (elem) {
            arrayOrObject.push(elem);
        });
    }
}

function createNamedStub(name, type) {
    var constructor;
    if (type === 'object') {
        constructor = graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLObjectType"];
    }
    else if (type === 'interface') {
        constructor = graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLInterfaceType"];
    }
    else {
        constructor = graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLInputObjectType"];
    }
    return new constructor({
        name: name,
        fields: {
            __fake: {
                type: graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLString"],
            },
        },
    });
}
function createStub(node, type) {
    switch (node.kind) {
        case graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].LIST_TYPE:
            return new graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLList"](createStub(node.type, type));
        case graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].NON_NULL_TYPE:
            return new graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLNonNull"](createStub(node.type, type));
        default:
            if (type === 'output') {
                return createNamedStub(node.name.value, 'object');
            }
            return createNamedStub(node.name.value, 'input');
    }
}
function isNamedStub(type) {
    if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isObjectType"])(type) || Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isInterfaceType"])(type) || Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isInputObjectType"])(type)) {
        var fields = type.getFields();
        var fieldNames = Object.keys(fields);
        return fieldNames.length === 1 && fields[fieldNames[0]].name === '__fake';
    }
    return false;
}
function getBuiltInForStub(type) {
    switch (type.name) {
        case graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLInt"].name:
            return graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLInt"];
        case graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLFloat"].name:
            return graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLFloat"];
        case graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLString"].name:
            return graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLString"];
        case graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLBoolean"].name:
            return graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLBoolean"];
        case graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLID"].name:
            return graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLID"];
        default:
            return type;
    }
}

// Update any references to named schema types that disagree with the named
// types found in schema.getTypeMap().
function healSchema(schema) {
    var typeMap = schema.getTypeMap();
    var directives = schema.getDirectives();
    var queryType = schema.getQueryType();
    var mutationType = schema.getMutationType();
    var subscriptionType = schema.getSubscriptionType();
    var newQueryTypeName = queryType != null
        ? typeMap[queryType.name] != null
            ? typeMap[queryType.name].name
            : undefined
        : undefined;
    var newMutationTypeName = mutationType != null
        ? typeMap[mutationType.name] != null
            ? typeMap[mutationType.name].name
            : undefined
        : undefined;
    var newSubscriptionTypeName = subscriptionType != null
        ? typeMap[subscriptionType.name] != null
            ? typeMap[subscriptionType.name].name
            : undefined
        : undefined;
    healTypes(typeMap, directives);
    var filteredTypeMap = {};
    Object.keys(typeMap).forEach(function (typeName) {
        if (!typeName.startsWith('__')) {
            filteredTypeMap[typeName] = typeMap[typeName];
        }
    });
    var healedSchema = new graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLSchema"](Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, toConfig(schema)), { query: newQueryTypeName ? filteredTypeMap[newQueryTypeName] : undefined, mutation: newMutationTypeName
            ? filteredTypeMap[newMutationTypeName]
            : undefined, subscription: newSubscriptionTypeName
            ? filteredTypeMap[newSubscriptionTypeName]
            : undefined, types: Object.keys(filteredTypeMap).map(function (typeName) { return filteredTypeMap[typeName]; }), directives: directives.slice() }));
    // Reconstruct the schema to reinitialize private variables
    // e.g. the stored implementation map and the proper root types.
    Object.assign(schema, healedSchema);
    return schema;
}
function healTypes(originalTypeMap, directives, config) {
    if (config === void 0) { config = {
        skipPruning: false,
    }; }
    var actualNamedTypeMap = Object.create(null);
    // If any of the .name properties of the GraphQLNamedType objects in
    // schema.getTypeMap() have changed, the keys of the type map need to
    // be updated accordingly.
    Object.entries(originalTypeMap).forEach(function (_a) {
        var typeName = _a[0], namedType = _a[1];
        if (namedType == null || typeName.startsWith('__')) {
            return;
        }
        var actualName = namedType.name;
        if (actualName.startsWith('__')) {
            return;
        }
        if (actualName in actualNamedTypeMap) {
            throw new Error("Duplicate schema type name " + actualName);
        }
        actualNamedTypeMap[actualName] = namedType;
        // Note: we are deliberately leaving namedType in the schema by its
        // original name (which might be different from actualName), so that
        // references by that name can be healed.
    });
    // Now add back every named type by its actual name.
    Object.entries(actualNamedTypeMap).forEach(function (_a) {
        var typeName = _a[0], namedType = _a[1];
        originalTypeMap[typeName] = namedType;
    });
    // Directive declaration argument types can refer to named types.
    directives.forEach(function (decl) {
        updateEachKey(decl.args, function (arg) {
            arg.type = healType(arg.type);
            return arg.type === null ? null : arg;
        });
    });
    Object.entries(originalTypeMap).forEach(function (_a) {
        var typeName = _a[0], namedType = _a[1];
        // Heal all named types, except for dangling references, kept only to redirect.
        if (!typeName.startsWith('__') && typeName in actualNamedTypeMap) {
            if (namedType != null) {
                healNamedType(namedType);
            }
        }
    });
    updateEachKey(originalTypeMap, function (_namedType, typeName) {
        // Dangling references to renamed types should remain in the schema
        // during healing, but must be removed now, so that the following
        // invariant holds for all names: schema.getType(name).name === name
        if (!typeName.startsWith('__') && !(typeName in actualNamedTypeMap)) {
            return null;
        }
    });
    if (!config.skipPruning) {
        pruneTypes$1(originalTypeMap, directives);
    }
    function healNamedType(type) {
        if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isObjectType"])(type)) {
            healFields(type);
            healInterfaces(type);
            return;
        }
        else if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isInterfaceType"])(type)) {
            healFields(type);
            if (graphqlVersion() >= 15) {
                healInterfaces(type);
            }
            return;
        }
        else if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isUnionType"])(type)) {
            healUnderlyingTypes(type);
            return;
        }
        else if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isInputObjectType"])(type)) {
            healInputFields(type);
            return;
        }
        else if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isLeafType"])(type)) {
            return;
        }
        throw new Error("Unexpected schema type: " + type);
    }
    function healFields(type) {
        updateEachKey(type.getFields(), function (field) {
            updateEachKey(field.args, function (arg) {
                arg.type = healType(arg.type);
                return arg.type === null ? null : arg;
            });
            field.type = healType(field.type);
            return field.type === null ? null : field;
        });
    }
    function healInterfaces(type) {
        updateEachKey(type.getInterfaces(), function (iface) {
            var healedType = healType(iface);
            return healedType;
        });
    }
    function healInputFields(type) {
        updateEachKey(type.getFields(), function (field) {
            field.type = healType(field.type);
            return field.type === null ? null : field;
        });
    }
    function healUnderlyingTypes(type) {
        updateEachKey(type.getTypes(), function (t) {
            var healedType = healType(t);
            return healedType;
        });
    }
    function healType(type) {
        // Unwrap the two known wrapper types
        if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isListType"])(type)) {
            var healedType = healType(type.ofType);
            return healedType != null ? new graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLList"](healedType) : null;
        }
        else if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isNonNullType"])(type)) {
            var healedType = healType(type.ofType);
            return healedType != null ? new graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLNonNull"](healedType) : null;
        }
        else if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isNamedType"])(type)) {
            // If a type annotation on a field or an argument or a union member is
            // any `GraphQLNamedType` with a `name`, then it must end up identical
            // to `schema.getType(name)`, since `schema.getTypeMap()` is the source
            // of truth for all named schema types.
            // Note that new types can still be simply added by adding a field, as
            // the official type will be undefined, not null.
            var officialType = originalTypeMap[type.name];
            if (officialType === undefined) {
                if (isNamedStub(type)) {
                    officialType = getBuiltInForStub(type);
                }
                else {
                    officialType = type;
                }
                originalTypeMap[type.name] = officialType;
            }
            return officialType;
        }
        return null;
    }
}
function pruneTypes$1(typeMap, directives) {
    var implementedInterfaces = {};
    Object.values(typeMap).forEach(function (namedType) {
        if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isObjectType"])(namedType) ||
            (graphqlVersion() >= 15 && Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isInterfaceType"])(namedType))) {
            namedType.getInterfaces().forEach(function (iface) {
                implementedInterfaces[iface.name] = true;
            });
        }
    });
    var prunedTypeMap = false;
    var typeNames = Object.keys(typeMap);
    for (var i = 0; i < typeNames.length; i++) {
        var typeName = typeNames[i];
        var type = typeMap[typeName];
        if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isObjectType"])(type) || Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isInputObjectType"])(type)) {
            // prune types with no fields
            if (!Object.keys(type.getFields()).length) {
                typeMap[typeName] = null;
                prunedTypeMap = true;
            }
        }
        else if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isUnionType"])(type)) {
            // prune unions without underlying types
            if (!type.getTypes().length) {
                typeMap[typeName] = null;
                prunedTypeMap = true;
            }
        }
        else if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isInterfaceType"])(type)) {
            // prune interfaces without fields or without implementations
            if (!Object.keys(type.getFields()).length ||
                !(type.name in implementedInterfaces)) {
                typeMap[typeName] = null;
                prunedTypeMap = true;
            }
        }
    }
    // every prune requires another round of healing
    if (prunedTypeMap) {
        healTypes(typeMap, directives);
    }
}

// Abstract base class of any visitor implementation, defining the available
// visitor methods along with their parameter types, and providing a static
// helper function for determining whether a subclass implements a given
// visitor method, as opposed to inheriting one of the stubs defined here.
var SchemaVisitor = /** @class */ (function () {
    function SchemaVisitor() {
    }
    // Determine if this SchemaVisitor (sub)class implements a particular
    // visitor method.
    SchemaVisitor.implementsVisitorMethod = function (methodName) {
        if (!methodName.startsWith('visit')) {
            return false;
        }
        var method = this.prototype[methodName];
        if (typeof method !== 'function') {
            return false;
        }
        if (this === SchemaVisitor) {
            // The SchemaVisitor class implements every visitor method.
            return true;
        }
        var stub = SchemaVisitor.prototype[methodName];
        if (method === stub) {
            // If this.prototype[methodName] was just inherited from SchemaVisitor,
            // then this class does not really implement the method.
            return false;
        }
        return true;
    };
    // Concrete subclasses of SchemaVisitor should override one or more of these
    // visitor methods, in order to express their interest in handling certain
    // schema types/locations. Each method may return null to remove the given
    // type from the schema, a non-null value of the same type to update the
    // type in the schema, or nothing to leave the type as it was.
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    SchemaVisitor.prototype.visitSchema = function (_schema) { };
    SchemaVisitor.prototype.visitScalar = function (_scalar) { };
    SchemaVisitor.prototype.visitObject = function (_object) { };
    SchemaVisitor.prototype.visitFieldDefinition = function (_field, _details) { };
    SchemaVisitor.prototype.visitArgumentDefinition = function (_argument, _details) { };
    SchemaVisitor.prototype.visitInterface = function (_iface) { };
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    SchemaVisitor.prototype.visitUnion = function (_union) { };
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    SchemaVisitor.prototype.visitEnum = function (_type) { };
    SchemaVisitor.prototype.visitEnumValue = function (_value, _details) { };
    SchemaVisitor.prototype.visitInputObject = function (_object) { };
    SchemaVisitor.prototype.visitInputFieldDefinition = function (_field, _details) { };
    return SchemaVisitor;
}());

/**
 * Creates a keyed JS object from an array, given a function to produce the keys
 * for each value in the array.
 *
 * This provides a convenient lookup for the array items if the key function
 * produces unique results.
 *
 *     const phoneBook = [
 *       { name: 'Jon', num: '555-1234' },
 *       { name: 'Jenny', num: '867-5309' }
 *     ]
 *
 *     // { Jon: { name: 'Jon', num: '555-1234' },
 *     //   Jenny: { name: 'Jenny', num: '867-5309' } }
 *     const entriesByName = keyMap(
 *       phoneBook,
 *       entry => entry.name
 *     )
 *
 *     // { name: 'Jenny', num: '857-6309' }
 *     const jennyEntry = entriesByName['Jenny']
 *
 */
function keyMap(list, keyFn) {
    return list.reduce(function (map, item) {
        map[keyFn(item)] = item;
        return map;
    }, Object.create(null));
}

// Similar to the graphql-js function of the same name, slightly simplified:
// https://github.com/graphql/graphql-js/blob/master/src/utilities/valueFromASTUntyped.js
function valueFromASTUntyped(valueNode) {
    switch (valueNode.kind) {
        case graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].NULL:
            return null;
        case graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].INT:
            return parseInt(valueNode.value, 10);
        case graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].FLOAT:
            return parseFloat(valueNode.value);
        case graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].STRING:
        case graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].ENUM:
        case graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].BOOLEAN:
            return valueNode.value;
        case graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].LIST:
            return valueNode.values.map(valueFromASTUntyped);
        case graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].OBJECT: {
            return keyValMap(valueNode.fields, function (field) { return field.name.value; }, function (field) { return valueFromASTUntyped(field.value); });
        }
        /* istanbul ignore next */
        default:
            throw new Error('Unexpected value kind: ' + valueNode.kind);
    }
}

// Generic function for visiting GraphQLSchema objects.
function visitSchema(schema, 
// To accommodate as many different visitor patterns as possible, the
// visitSchema function does not simply accept a single instance of the
// SchemaVisitor class, but instead accepts a function that takes the
// current VisitableSchemaType object and the name of a visitor method and
// returns an array of SchemaVisitor instances that implement the visitor
// method and have an interest in handling the given VisitableSchemaType
// object. In the simplest case, this function can always return an array
// containing a single visitor object, without even looking at the type or
// methodName parameters. In other cases, this function might sometimes
// return an empty array to indicate there are no visitors that should be
// applied to the given VisitableSchemaType object. For an example of a
// visitor pattern that benefits from this abstraction, see the
// SchemaDirectiveVisitor class below.
visitorOrVisitorSelector) {
    var visitorSelector = typeof visitorOrVisitorSelector === 'function'
        ? visitorOrVisitorSelector
        : function () { return visitorOrVisitorSelector; };
    // Helper function that calls visitorSelector and applies the resulting
    // visitors to the given type, with arguments [type, ...args].
    function callMethod(methodName, type) {
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            args[_i - 2] = arguments[_i];
        }
        var visitors = visitorSelector(type, methodName);
        visitors = Array.isArray(visitors) ? visitors : [visitors];
        var finalType = type;
        visitors.every(function (visitorOrVisitorDef) {
            var newType;
            if (visitorOrVisitorDef instanceof SchemaVisitor) {
                newType = visitorOrVisitorDef[methodName].apply(visitorOrVisitorDef, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __spreadArrays */ "d"])([finalType], args));
            }
            else if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isNamedType"])(finalType) &&
                (methodName === 'visitScalar' ||
                    methodName === 'visitEnum' ||
                    methodName === 'visitObject' ||
                    methodName === 'visitInputObject' ||
                    methodName === 'visitUnion' ||
                    methodName === 'visitInterface')) {
                var specifiers = getTypeSpecifiers$1(finalType, schema);
                var typeVisitor = getVisitor(visitorOrVisitorDef, specifiers);
                newType =
                    typeVisitor != null ? typeVisitor(finalType, schema) : undefined;
            }
            if (typeof newType === 'undefined') {
                // Keep going without modifying type.
                return true;
            }
            if (methodName === 'visitSchema' || Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isSchema"])(finalType)) {
                throw new Error("Method " + methodName + " cannot replace schema with " + newType);
            }
            if (newType === null) {
                // Stop the loop and return null form callMethod, which will cause
                // the type to be removed from the schema.
                finalType = null;
                return false;
            }
            // Update type to the new type returned by the visitor method, so that
            // later directives will see the new type, and callMethod will return
            // the final type.
            finalType = newType;
            return true;
        });
        // If there were no directives for this type object, or if all visitor
        // methods returned nothing, type will be returned unmodified.
        return finalType;
    }
    // Recursive helper function that calls any appropriate visitor methods for
    // each object in the schema, then traverses the object's children (if any).
    function visit(type) {
        if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isSchema"])(type)) {
            // Unlike the other types, the root GraphQLSchema object cannot be
            // replaced by visitor methods, because that would make life very hard
            // for SchemaVisitor subclasses that rely on the original schema object.
            callMethod('visitSchema', type);
            var typeMap_1 = type.getTypeMap();
            Object.entries(typeMap_1).forEach(function (_a) {
                var typeName = _a[0], namedType = _a[1];
                if (!typeName.startsWith('__') && namedType != null) {
                    // Call visit recursively to let it determine which concrete
                    // subclass of GraphQLNamedType we found in the type map.
                    // We do not use updateEachKey because we want to preserve
                    // deleted types in the typeMap so that other types that reference
                    // the deleted types can be healed.
                    typeMap_1[typeName] = visit(namedType);
                }
            });
            return type;
        }
        if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isObjectType"])(type)) {
            // Note that callMethod('visitObject', type) may not actually call any
            // methods, if there are no @directive annotations associated with this
            // type, or if this SchemaDirectiveVisitor subclass does not override
            // the visitObject method.
            var newObject = callMethod('visitObject', type);
            if (newObject != null) {
                visitFields(newObject);
            }
            return newObject;
        }
        if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isInterfaceType"])(type)) {
            var newInterface = callMethod('visitInterface', type);
            if (newInterface != null) {
                visitFields(newInterface);
            }
            return newInterface;
        }
        if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isInputObjectType"])(type)) {
            var newInputObject_1 = callMethod('visitInputObject', type);
            if (newInputObject_1 != null) {
                var fieldMap = newInputObject_1.getFields();
                updateEachKey(fieldMap, function (field) {
                    return callMethod('visitInputFieldDefinition', field, {
                        // Since we call a different method for input object fields, we
                        // can't reuse the visitFields function here.
                        objectType: newInputObject_1,
                    });
                });
            }
            return newInputObject_1;
        }
        if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isScalarType"])(type)) {
            return callMethod('visitScalar', type);
        }
        if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isUnionType"])(type)) {
            return callMethod('visitUnion', type);
        }
        if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isEnumType"])(type)) {
            var newEnum_1 = callMethod('visitEnum', type);
            if (newEnum_1 != null) {
                updateEachKey(newEnum_1.getValues(), function (value) {
                    return callMethod('visitEnumValue', value, {
                        enumType: newEnum_1,
                    });
                });
            }
            return newEnum_1;
        }
        throw new Error("Unexpected schema type: " + type);
    }
    function visitFields(type) {
        updateEachKey(type.getFields(), function (field) {
            // It would be nice if we could call visit(field) recursively here, but
            // GraphQLField is merely a type, not a value that can be detected using
            // an instanceof check, so we have to visit the fields in this lexical
            // context, so that TypeScript can validate the call to
            // visitFieldDefinition.
            var newField = callMethod('visitFieldDefinition', field, {
                // While any field visitor needs a reference to the field object, some
                // field visitors may also need to know the enclosing (parent) type,
                // perhaps to determine if the parent is a GraphQLObjectType or a
                // GraphQLInterfaceType. To obtain a reference to the parent, a
                // visitor method can have a second parameter, which will be an object
                // with an .objectType property referring to the parent.
                objectType: type,
            });
            if (newField.args != null) {
                updateEachKey(newField.args, function (arg) {
                    return callMethod('visitArgumentDefinition', arg, {
                        // Like visitFieldDefinition, visitArgumentDefinition takes a
                        // second parameter that provides additional context, namely the
                        // parent .field and grandparent .objectType. Remember that the
                        // current GraphQLSchema is always available via this.schema.
                        field: newField,
                        objectType: type,
                    });
                });
            }
            return newField;
        });
    }
    visit(schema);
    // Automatically update any references to named schema types replaced
    // during the traversal, so implementors don't have to worry about that.
    healSchema(schema);
    // Return schema for convenience, even though schema parameter has all updated types.
    return schema;
}
function getTypeSpecifiers$1(type, schema) {
    var specifiers = [VisitSchemaKind.TYPE];
    if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isObjectType"])(type)) {
        specifiers.push(VisitSchemaKind.COMPOSITE_TYPE, VisitSchemaKind.OBJECT_TYPE);
        var query = schema.getQueryType();
        var mutation = schema.getMutationType();
        var subscription = schema.getSubscriptionType();
        if (type === query) {
            specifiers.push(VisitSchemaKind.ROOT_OBJECT, VisitSchemaKind.QUERY);
        }
        else if (type === mutation) {
            specifiers.push(VisitSchemaKind.ROOT_OBJECT, VisitSchemaKind.MUTATION);
        }
        else if (type === subscription) {
            specifiers.push(VisitSchemaKind.ROOT_OBJECT, VisitSchemaKind.SUBSCRIPTION);
        }
    }
    else if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isInputType"])(type)) {
        specifiers.push(VisitSchemaKind.INPUT_OBJECT_TYPE);
    }
    else if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isInterfaceType"])(type)) {
        specifiers.push(VisitSchemaKind.COMPOSITE_TYPE, VisitSchemaKind.ABSTRACT_TYPE, VisitSchemaKind.INTERFACE_TYPE);
    }
    else if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isUnionType"])(type)) {
        specifiers.push(VisitSchemaKind.COMPOSITE_TYPE, VisitSchemaKind.ABSTRACT_TYPE, VisitSchemaKind.UNION_TYPE);
    }
    else if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isEnumType"])(type)) {
        specifiers.push(VisitSchemaKind.ENUM_TYPE);
    }
    else if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isScalarType"])(type)) {
        specifiers.push(VisitSchemaKind.SCALAR_TYPE);
    }
    return specifiers;
}
function getVisitor(visitorDef, specifiers) {
    var typeVisitor;
    var stack = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __spreadArrays */ "d"])(specifiers);
    while (!typeVisitor && stack.length > 0) {
        var next = stack.pop();
        typeVisitor = visitorDef[next];
    }
    return typeVisitor != null ? typeVisitor : null;
}

var MAX_ARRAY_LENGTH = 10;
var MAX_RECURSIVE_DEPTH = 2;
/**
 * Used to print values in error messages.
 */
function inspect(value) {
    return formatValue(value, []);
}
function formatValue(value, seenValues) {
    switch (typeof value) {
        case 'string':
            return JSON.stringify(value);
        case 'function':
            return value.name
                ? "[function " + value.name + "]"
                : '[function]';
        case 'object':
            if (value === null) {
                return 'null';
            }
            return formatObjectValue(value, seenValues);
        default:
            return String(value);
    }
}
function formatObjectValue(value, previouslySeenValues) {
    if (previouslySeenValues.indexOf(value) !== -1) {
        return '[Circular]';
    }
    var seenValues = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __spreadArrays */ "d"])(previouslySeenValues, [value]);
    var customInspectFn = getCustomFn(value);
    if (customInspectFn !== undefined) {
        var customValue = customInspectFn.call(value);
        // check for infinite recursion
        if (customValue !== value) {
            return typeof customValue === 'string'
                ? customValue
                : formatValue(customValue, seenValues);
        }
    }
    else if (Array.isArray(value)) {
        return formatArray(value, seenValues);
    }
    return formatObject(value, seenValues);
}
function formatObject(object, seenValues) {
    var keys = Object.keys(object);
    if (keys.length === 0) {
        return '{}';
    }
    if (seenValues.length > MAX_RECURSIVE_DEPTH) {
        return '[' + getObjectTag(object) + ']';
    }
    var properties = keys.map(function (key) {
        var value = formatValue(object[key], seenValues);
        return key + ': ' + value;
    });
    return '{ ' + properties.join(', ') + ' }';
}
function formatArray(array, seenValues) {
    if (array.length === 0) {
        return '[]';
    }
    if (seenValues.length > MAX_RECURSIVE_DEPTH) {
        return '[Array]';
    }
    var len = Math.min(MAX_ARRAY_LENGTH, array.length);
    var remaining = array.length - len;
    var items = [];
    for (var i = 0; i < len; ++i) {
        items.push(formatValue(array[i], seenValues));
    }
    if (remaining === 1) {
        items.push('... 1 more item');
    }
    else if (remaining > 1) {
        items.push("... " + remaining.toString(10) + " more items");
    }
    return '[' + items.join(', ') + ']';
}
function getCustomFn(obj) {
    if (typeof obj.inspect === 'function') {
        return obj.inspect;
    }
}
function getObjectTag(obj) {
    var tag = Object.prototype.toString
        .call(obj)
        .replace(/^\[object /, '')
        .replace(/]$/, '');
    if (tag === 'Object' && typeof obj.constructor === 'function') {
        var name_1 = obj.constructor.name;
        if (typeof name_1 === 'string' && name_1 !== '') {
            return name_1;
        }
    }
    return tag;
}

/**
 * Prepares an object map of argument values given a list of argument
 * definitions and list of argument AST nodes.
 *
 * Note: The returned value is a plain Object with a prototype, since it is
 * exposed to user code. Care should be taken to not pull values from the
 * Object prototype.
 */
function getArgumentValues(def, node, variableValues) {
    if (variableValues === void 0) { variableValues = {}; }
    var _a;
    var variableMap = toObjMap(variableValues);
    var coercedValues = {};
    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
    var argumentNodes = (_a = node.arguments) !== null && _a !== void 0 ? _a : [];
    var argNodeMap = keyMap(argumentNodes, function (arg) { return arg.name.value; });
    for (var _i = 0, _b = def.args; _i < _b.length; _i++) {
        var argDef = _b[_i];
        var name_1 = argDef.name;
        var argType = argDef.type;
        var argumentNode = argNodeMap[name_1];
        if (!argumentNode) {
            if (argDef.defaultValue !== undefined) {
                coercedValues[name_1] = argDef.defaultValue;
            }
            else if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isNonNullType"])(argType)) {
                throw new graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLError"]("Argument \"" + name_1 + "\" of required type \"" + inspect(argType) + "\" " +
                    'was not provided.', node);
            }
            continue;
        }
        var valueNode = argumentNode.value;
        var isNull = valueNode.kind === graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].NULL;
        if (valueNode.kind === graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].VARIABLE) {
            var variableName = valueNode.name.value;
            if (variableValues == null || !(variableName in variableMap)) {
                if (argDef.defaultValue !== undefined) {
                    coercedValues[name_1] = argDef.defaultValue;
                }
                else if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isNonNullType"])(argType)) {
                    throw new graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLError"]("Argument \"" + name_1 + "\" of required type \"" + inspect(argType) + "\" " +
                        ("was provided the variable \"$" + variableName + "\" which was not provided a runtime value."), valueNode);
                }
                continue;
            }
            isNull = variableValues[variableName] == null;
        }
        if (isNull && Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isNonNullType"])(argType)) {
            throw new graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLError"]("Argument \"" + name_1 + "\" of non-null type \"" + inspect(argType) + "\" " +
                'must not be null.', valueNode);
        }
        var coercedValue = Object(graphql__WEBPACK_IMPORTED_MODULE_3__["valueFromAST"])(valueNode, argType, variableValues);
        if (coercedValue === undefined) {
            // Note: ValuesOfCorrectTypeRule validation should catch this before
            // execution. This is a runtime check to ensure execution does not
            // continue with an invalid argument value.
            throw new graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLError"]("Argument \"" + name_1 + "\" has invalid value " + Object(graphql__WEBPACK_IMPORTED_MODULE_3__["print"])(valueNode) + ".", valueNode);
        }
        coercedValues[name_1] = coercedValue;
    }
    return coercedValues;
}

// This class represents a reusable implementation of a @directive that may
// appear in a GraphQL schema written in Schema Definition Language.
//
// By overriding one or more visit{Object,Union,...} methods, a subclass
// registers interest in certain schema types, such as GraphQLObjectType,
// GraphQLUnionType, etc. When SchemaDirectiveVisitor.visitSchemaDirectives is
// called with a GraphQLSchema object and a map of visitor subclasses, the
// overidden methods of those subclasses allow the visitors to obtain
// references to any type objects that have @directives attached to them,
// enabling visitors to inspect or modify the schema as appropriate.
//
// For example, if a directive called @rest(url: "...") appears after a field
// definition, a SchemaDirectiveVisitor subclass could provide meaning to that
// directive by overriding the visitFieldDefinition method (which receives a
// GraphQLField parameter), and then the body of that visitor method could
// manipulate the field's resolver function to fetch data from a REST endpoint
// described by the url argument passed to the @rest directive:
//
//   const typeDefs = `
//   type Query {
//     people: [Person] @rest(url: "/api/v1/people")
//   }`;
//
//   const schema = makeExecutableSchema({ typeDefs });
//
//   SchemaDirectiveVisitor.visitSchemaDirectives(schema, {
//     rest: class extends SchemaDirectiveVisitor {
//       public visitFieldDefinition(field: GraphQLField<any, any>) {
//         const { url } = this.args;
//         field.resolve = () => fetch(url);
//       }
//     }
//   });
//
// The subclass in this example is defined as an anonymous class expression,
// for brevity. A truly reusable SchemaDirectiveVisitor would most likely be
// defined in a library using a named class declaration, and then exported for
// consumption by other modules and packages.
//
// See below for a complete list of overridable visitor methods, their
// parameter types, and more details about the properties exposed by instances
// of the SchemaDirectiveVisitor class.
var SchemaDirectiveVisitor = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __extends */ "b"])(SchemaDirectiveVisitor, _super);
    // Mark the constructor protected to enforce passing SchemaDirectiveVisitor
    // subclasses (not instances) to visitSchemaDirectives.
    function SchemaDirectiveVisitor(config) {
        var _this = _super.call(this) || this;
        _this.name = config.name;
        _this.args = config.args;
        _this.visitedType = config.visitedType;
        _this.schema = config.schema;
        _this.context = config.context;
        return _this;
    }
    // Override this method to return a custom GraphQLDirective (or modify one
    // already present in the schema) to enforce argument types, provide default
    // argument values, or specify schema locations where this @directive may
    // appear. By default, any declaration found in the schema will be returned.
    SchemaDirectiveVisitor.getDirectiveDeclaration = function (directiveName, schema) {
        return schema.getDirective(directiveName);
    };
    // Call SchemaDirectiveVisitor.visitSchemaDirectives to visit every
    // @directive in the schema and create an appropriate SchemaDirectiveVisitor
    // instance to visit the object decorated by the @directive.
    SchemaDirectiveVisitor.visitSchemaDirectives = function (schema, 
    // The keys of this object correspond to directive names as they appear
    // in the schema, and the values should be subclasses (not instances!)
    // of the SchemaDirectiveVisitor class. This distinction is important
    // because a new SchemaDirectiveVisitor instance will be created each
    // time a matching directive is found in the schema AST, with arguments
    // and other metadata specific to that occurrence. To help prevent the
    // mistake of passing instances, the SchemaDirectiveVisitor constructor
    // method is marked as protected.
    directiveVisitors, 
    // Optional context object that will be available to all visitor instances
    // via this.context. Defaults to an empty null-prototype object.
    context) {
        if (context === void 0) { context = Object.create(null); }
        // If the schema declares any directives for public consumption, record
        // them here so that we can properly coerce arguments when/if we encounter
        // an occurrence of the directive while walking the schema below.
        var declaredDirectives = this.getDeclaredDirectives(schema, directiveVisitors);
        // Map from directive names to lists of SchemaDirectiveVisitor instances
        // created while visiting the schema.
        var createdVisitors = keyValMap(Object.keys(directiveVisitors), function (item) { return item; }, function () { return []; });
        var directiveVisitorMap = toObjMap(directiveVisitors);
        function visitorSelector(type, methodName) {
            var directiveNodes = type.astNode != null ? type.astNode.directives : [];
            var extensionASTNodes = type.extensionASTNodes;
            if (extensionASTNodes != null) {
                extensionASTNodes.forEach(function (extensionASTNode) {
                    directiveNodes = directiveNodes.concat(extensionASTNode.directives);
                });
            }
            var visitors = [];
            directiveNodes.forEach(function (directiveNode) {
                var directiveName = directiveNode.name.value;
                if (!(directiveName in directiveVisitorMap)) {
                    return;
                }
                var visitorClass = directiveVisitorMap[directiveName];
                // Avoid creating visitor objects if visitorClass does not override
                // the visitor method named by methodName.
                if (!visitorClass.implementsVisitorMethod(methodName)) {
                    return;
                }
                var decl = declaredDirectives[directiveName];
                var args;
                if (decl != null) {
                    // If this directive was explicitly declared, use the declared
                    // argument types (and any default values) to check, coerce, and/or
                    // supply default values for the given arguments.
                    args = getArgumentValues(decl, directiveNode);
                }
                else {
                    // If this directive was not explicitly declared, just convert the
                    // argument nodes to their corresponding JavaScript values.
                    args = Object.create(null);
                    if (directiveNode.arguments != null) {
                        directiveNode.arguments.forEach(function (arg) {
                            args[arg.name.value] = valueFromASTUntyped(arg.value);
                        });
                    }
                }
                // As foretold in comments near the top of the visitSchemaDirectives
                // method, this is where instances of the SchemaDirectiveVisitor class
                // get created and assigned names. While subclasses could override the
                // constructor method, the constructor is marked as protected, so
                // these are the only arguments that will ever be passed.
                visitors.push(new visitorClass({
                    name: directiveName,
                    args: args,
                    visitedType: type,
                    schema: schema,
                    context: context,
                }));
            });
            if (visitors.length > 0) {
                visitors.forEach(function (visitor) {
                    createdVisitors[visitor.name].push(visitor);
                });
            }
            return visitors;
        }
        visitSchema(schema, visitorSelector);
        return createdVisitors;
    };
    SchemaDirectiveVisitor.getDeclaredDirectives = function (schema, directiveVisitors) {
        var directiveVisitorMap = toObjMap(directiveVisitors);
        var declaredDirectives = keyMap(schema.getDirectives(), function (d) { return d.name; });
        // If the visitor subclass overrides getDirectiveDeclaration, and it
        // returns a non-null GraphQLDirective, use that instead of any directive
        // declared in the schema itself. Reasoning: if a SchemaDirectiveVisitor
        // goes to the trouble of implementing getDirectiveDeclaration, it should
        // be able to rely on that implementation.
        Object.entries(directiveVisitors).forEach(function (_a) {
            var directiveName = _a[0], visitorClass = _a[1];
            var decl = visitorClass.getDirectiveDeclaration(directiveName, schema);
            if (decl != null) {
                declaredDirectives[directiveName] = decl;
            }
        });
        Object.entries(declaredDirectives).forEach(function (_a) {
            var name = _a[0], decl = _a[1];
            if (!(name in directiveVisitorMap)) {
                // SchemaDirectiveVisitors.visitSchemaDirectives might be called
                // multiple times with partial directiveVisitors maps, so it's not
                // necessarily an error for directiveVisitors to be missing an
                // implementation of a directive that was declared in the schema.
                return;
            }
            var visitorClass = directiveVisitorMap[name];
            decl.locations.forEach(function (loc) {
                var visitorMethodName = directiveLocationToVisitorMethodName(loc);
                if (SchemaVisitor.implementsVisitorMethod(visitorMethodName) &&
                    !visitorClass.implementsVisitorMethod(visitorMethodName)) {
                    // While visitor subclasses may implement extra visitor methods,
                    // it's definitely a mistake if the GraphQLDirective declares itself
                    // applicable to certain schema locations, and the visitor subclass
                    // does not implement all the corresponding methods.
                    throw new Error("SchemaDirectiveVisitor for @" + name + " must implement " + visitorMethodName + " method");
                }
            });
        });
        return declaredDirectives;
    };
    return SchemaDirectiveVisitor;
}(SchemaVisitor));
// Convert a string like "FIELD_DEFINITION" to "visitFieldDefinition".
function directiveLocationToVisitorMethodName(loc) {
    return ('visit' +
        loc.replace(/([^_]*)_?/g, function (_wholeMatch, part) {
            return part.charAt(0).toUpperCase() + part.slice(1).toLowerCase();
        }));
}

function forEachField(schema, fn) {
    var typeMap = schema.getTypeMap();
    Object.keys(typeMap).forEach(function (typeName) {
        var type = typeMap[typeName];
        // TODO: maybe have an option to include these?
        if (!Object(graphql__WEBPACK_IMPORTED_MODULE_3__["getNamedType"])(type).name.startsWith('__') && Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isObjectType"])(type)) {
            var fields_1 = type.getFields();
            Object.keys(fields_1).forEach(function (fieldName) {
                var field = fields_1[fieldName];
                fn(field, typeName, fieldName);
            });
        }
    });
}

function forEachDefaultValue(schema, fn) {
    var typeMap = schema.getTypeMap();
    Object.keys(typeMap).forEach(function (typeName) {
        var type = typeMap[typeName];
        if (!Object(graphql__WEBPACK_IMPORTED_MODULE_3__["getNamedType"])(type).name.startsWith('__')) {
            if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isObjectType"])(type)) {
                var fields_1 = type.getFields();
                Object.keys(fields_1).forEach(function (fieldName) {
                    var field = fields_1[fieldName];
                    field.args.forEach(function (arg) {
                        arg.defaultValue = fn(arg.type, arg.defaultValue);
                    });
                });
            }
            else if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isInputObjectType"])(type)) {
                var fields_2 = type.getFields();
                Object.keys(fields_2).forEach(function (fieldName) {
                    var field = fields_2[fieldName];
                    field.defaultValue = fn(field.type, field.defaultValue);
                });
            }
        }
    });
}

function applySchemaTransforms(originalSchema, transforms) {
    return transforms.reduce(function (schema, transform) {
        return transform.transformSchema != null
            ? transform.transformSchema(cloneSchema(schema))
            : schema;
    }, originalSchema);
}
function applyRequestTransforms(originalRequest, transforms) {
    return transforms.reduce(function (request, transform) {
        return transform.transformRequest != null
            ? transform.transformRequest(request)
            : request;
    }, originalRequest);
}
function applyResultTransforms(originalResult, transforms) {
    return transforms.reduceRight(function (result, transform) {
        return transform.transformResult != null
            ? transform.transformResult(result)
            : result;
    }, originalResult);
}

function linkToFetcher(link) {
    return function (fetcherOperation) {
        return Object(apollo_link__WEBPACK_IMPORTED_MODULE_2__["toPromise"])(Object(apollo_link__WEBPACK_IMPORTED_MODULE_2__["execute"])(link, fetcherOperation));
    };
}

function observableToAsyncIterable(observable) {
    var _a;
    var pullQueue = [];
    var pushQueue = [];
    var listening = true;
    var pushValue = function (value) {
        if (pullQueue.length !== 0) {
            pullQueue.shift()({ value: value, done: false });
        }
        else {
            pushQueue.push({ value: value });
        }
    };
    var pushError = function (error) {
        if (pullQueue.length !== 0) {
            pullQueue.shift()({ value: { errors: [error] }, done: false });
        }
        else {
            pushQueue.push({ value: { errors: [error] } });
        }
    };
    var pullValue = function () {
        return new Promise(function (resolve) {
            if (pushQueue.length !== 0) {
                var element = pushQueue.shift();
                // either {value: {errors: [...]}} or {value: ...}
                resolve(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, element), { done: false }));
            }
            else {
                pullQueue.push(resolve);
            }
        });
    };
    var subscription = observable.subscribe({
        next: function (value) {
            pushValue(value);
        },
        error: function (err) {
            pushError(err);
        },
    });
    var emptyQueue = function () {
        if (listening) {
            listening = false;
            subscription.unsubscribe();
            pullQueue.forEach(function (resolve) { return resolve({ value: undefined, done: true }); });
            pullQueue.length = 0;
            pushQueue.length = 0;
        }
    };
    return _a = {
            next: function () {
                return listening ? pullValue() : this.return();
            },
            return: function () {
                emptyQueue();
                return Promise.resolve({ value: undefined, done: true });
            },
            throw: function (error) {
                emptyQueue();
                return Promise.reject(error);
            }
        },
        _a[iterall__WEBPACK_IMPORTED_MODULE_1__["$$asyncIterator"]] = function () {
            return this;
        },
        _a;
}

/**
 * Given an AsyncIterable and a callback function, return an AsyncIterator
 * which produces values mapped via calling the callback function.
 */
function mapAsyncIterator(iterator, callback, rejectCallback) {
    var _a;
    var $return;
    var abruptClose;
    if (typeof iterator.return === 'function') {
        $return = iterator.return;
        abruptClose = function (error) {
            var rethrow = function () { return Promise.reject(error); };
            return $return.call(iterator).then(rethrow, rethrow);
        };
    }
    function mapResult(result) {
        return result.done
            ? result
            : asyncMapValue(result.value, callback).then(iteratorResult, abruptClose);
    }
    var mapReject;
    if (rejectCallback) {
        // Capture rejectCallback to ensure it cannot be null.
        var reject_1 = rejectCallback;
        mapReject = function (error) {
            return asyncMapValue(error, reject_1).then(iteratorResult, abruptClose);
        };
    }
    return _a = {
            next: function () {
                return iterator.next().then(mapResult, mapReject);
            },
            return: function () {
                return $return
                    ? $return.call(iterator).then(mapResult, mapReject)
                    : Promise.resolve({ value: undefined, done: true });
            },
            throw: function (error) {
                if (typeof iterator.throw === 'function') {
                    return iterator.throw(error).then(mapResult, mapReject);
                }
                return Promise.reject(error).catch(abruptClose);
            }
        },
        _a[iterall__WEBPACK_IMPORTED_MODULE_1__["$$asyncIterator"]] = function () {
            return this;
        },
        _a;
}
function asyncMapValue(value, callback) {
    return new Promise(function (resolve) { return resolve(callback(value)); });
}
function iteratorResult(value) {
    return { value: value, done: false };
}

function getDelegatingOperation(parentType, schema) {
    if (parentType === schema.getMutationType()) {
        return 'mutation';
    }
    else if (parentType === schema.getSubscriptionType()) {
        return 'subscription';
    }
    return 'query';
}
function createRequestFromInfo(_a) {
    var info = _a.info, _b = _a.operation, operation = _b === void 0 ? getDelegatingOperation(info.parentType, info.schema) : _b, _c = _a.fieldName, fieldName = _c === void 0 ? info.fieldName : _c, selectionSet = _a.selectionSet, fieldNodes = _a.fieldNodes;
    return createRequest({
        sourceSchema: info.schema,
        sourceParentType: info.parentType,
        sourceFieldName: info.fieldName,
        fragments: info.fragments,
        variableDefinitions: info.operation.variableDefinitions,
        variableValues: info.variableValues,
        targetOperation: operation,
        targetFieldName: fieldName,
        selectionSet: selectionSet,
        fieldNodes: selectionSet != null
            ? undefined
            : fieldNodes != null
                ? fieldNodes
                : info.fieldNodes,
    });
}
function createRequest(_a) {
    var sourceSchema = _a.sourceSchema, sourceParentType = _a.sourceParentType, sourceFieldName = _a.sourceFieldName, fragments = _a.fragments, variableDefinitions = _a.variableDefinitions, variableValues = _a.variableValues, targetOperation = _a.targetOperation, targetFieldName = _a.targetFieldName, selectionSet = _a.selectionSet, fieldNodes = _a.fieldNodes;
    var argumentNodes;
    var newSelectionSet = selectionSet;
    if (!selectionSet && fieldNodes != null) {
        var selections = fieldNodes.reduce(function (acc, fieldNode) {
            return fieldNode.selectionSet != null
                ? acc.concat(fieldNode.selectionSet.selections)
                : acc;
        }, []);
        newSelectionSet = selections.length
            ? {
                kind: graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].SELECTION_SET,
                selections: selections,
            }
            : undefined;
        argumentNodes = fieldNodes[0].arguments;
    }
    else {
        argumentNodes = [];
    }
    var newVariables = Object.create(null);
    var variableDefinitionMap = Object.create(null);
    variableDefinitions.forEach(function (def) {
        var varName = def.variable.name.value;
        variableDefinitionMap[varName] = def;
        var varType = Object(graphql__WEBPACK_IMPORTED_MODULE_3__["typeFromAST"])(sourceSchema, def.type);
        newVariables[varName] = serializeInputValue(varType, variableValues[varName]);
    });
    var argumentNodeMap = keyMap(argumentNodes, function (arg) { return arg.name.value; });
    updateArgumentsWithDefaults(sourceParentType, sourceFieldName, argumentNodeMap, variableDefinitionMap, newVariables);
    var rootfieldNode = {
        kind: graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].FIELD,
        alias: null,
        arguments: Object.keys(argumentNodeMap).map(function (argName) { return argumentNodeMap[argName]; }),
        selectionSet: newSelectionSet,
        name: {
            kind: graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].NAME,
            value: targetFieldName || fieldNodes[0].name.value,
        },
    };
    var operationDefinition = {
        kind: graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].OPERATION_DEFINITION,
        operation: targetOperation,
        variableDefinitions: Object.keys(variableDefinitionMap).map(function (varName) { return variableDefinitionMap[varName]; }),
        selectionSet: {
            kind: graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].SELECTION_SET,
            selections: [rootfieldNode],
        },
    };
    var fragmentDefinitions = Object.keys(fragments).map(function (fragmentName) { return fragments[fragmentName]; });
    var document = {
        kind: graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].DOCUMENT,
        definitions: Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __spreadArrays */ "d"])([operationDefinition], fragmentDefinitions),
    };
    return {
        document: document,
        variables: newVariables,
    };
}
function updateArgumentsWithDefaults(sourceParentType, sourceFieldName, argumentNodeMap, variableDefinitionMap, variableValues) {
    var sourceField = sourceParentType.getFields()[sourceFieldName];
    sourceField.args.forEach(function (argument) {
        var argName = argument.name;
        var sourceArgType = argument.type;
        if (argumentNodeMap[argName] === undefined) {
            var defaultValue = argument.defaultValue;
            if (defaultValue !== undefined) {
                updateArgument(argName, sourceArgType, argumentNodeMap, variableDefinitionMap, variableValues, serializeInputValue(sourceArgType, defaultValue));
            }
        }
    });
}

function delegateToSchema(options) {
    if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isSchema"])(options)) {
        throw new Error('Passing positional arguments to delegateToSchema is deprecated. ' +
            'Please pass named parameters instead.');
    }
    var info = options.info, _a = options.operation, operation = _a === void 0 ? getDelegatingOperation(info.parentType, info.schema) : _a, _b = options.fieldName, fieldName = _b === void 0 ? info.fieldName : _b, _c = options.returnType, returnType = _c === void 0 ? info.returnType : _c, selectionSet = options.selectionSet, fieldNodes = options.fieldNodes;
    var request = createRequestFromInfo({
        info: info,
        operation: operation,
        fieldName: fieldName,
        selectionSet: selectionSet,
        fieldNodes: fieldNodes,
    });
    return delegateRequest(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, options), { request: request,
        operation: operation,
        fieldName: fieldName,
        returnType: returnType }));
}
function buildDelegationTransforms(subschemaOrSubschemaConfig, info, context, targetSchema, fieldName, args, returnType, transforms, skipTypeMerging) {
    var delegationTransforms = [
        new CheckResultAndHandleErrors(info, fieldName, subschemaOrSubschemaConfig, context, returnType, skipTypeMerging),
    ];
    if (info.mergeInfo != null) {
        delegationTransforms.push(new AddReplacementSelectionSets(info.schema, info.mergeInfo.replacementSelectionSets), new AddMergedTypeFragments(info.schema, info.mergeInfo.mergedTypes));
    }
    delegationTransforms = delegationTransforms.concat(transforms);
    delegationTransforms.push(new ExpandAbstractTypes(info.schema, targetSchema));
    if (info.mergeInfo != null) {
        delegationTransforms.push(new AddReplacementFragments(targetSchema, info.mergeInfo.replacementFragments));
    }
    if (args != null) {
        delegationTransforms.push(new AddArgumentsAsVariables(targetSchema, args));
    }
    delegationTransforms.push(new FilterToSchema(targetSchema), new AddTypenameToAbstract(targetSchema));
    return delegationTransforms;
}
function delegateRequest(_a) {
    var request = _a.request, subschemaOrSubschemaConfig = _a.schema, rootValue = _a.rootValue, info = _a.info, _b = _a.operation, operation = _b === void 0 ? getDelegatingOperation(info.parentType, info.schema) : _b, _c = _a.fieldName, fieldName = _c === void 0 ? info.fieldName : _c, args = _a.args, _d = _a.returnType, returnType = _d === void 0 ? info.returnType : _d, context = _a.context, _e = _a.transforms, transforms = _e === void 0 ? [] : _e, skipValidation = _a.skipValidation, skipTypeMerging = _a.skipTypeMerging;
    var targetSchema;
    var targetRootValue;
    var requestTransforms = transforms.slice();
    var subschemaConfig;
    if (isSubschemaConfig(subschemaOrSubschemaConfig)) {
        subschemaConfig = subschemaOrSubschemaConfig;
        targetSchema = subschemaConfig.schema;
        targetRootValue =
            rootValue != null
                ? rootValue
                : subschemaConfig.rootValue != null
                    ? subschemaConfig.rootValue
                    : info.rootValue;
        if (subschemaConfig.transforms != null) {
            requestTransforms = requestTransforms.concat(subschemaConfig.transforms);
        }
    }
    else {
        targetSchema = subschemaOrSubschemaConfig;
        targetRootValue = rootValue != null ? rootValue : info.rootValue;
    }
    var delegationTransforms = buildDelegationTransforms(subschemaOrSubschemaConfig, info, context, targetSchema, fieldName, args, returnType, requestTransforms.reverse(), skipTypeMerging);
    var processedRequest = applyRequestTransforms(request, delegationTransforms);
    if (!skipValidation) {
        var errors = Object(graphql__WEBPACK_IMPORTED_MODULE_3__["validate"])(targetSchema, processedRequest.document);
        if (errors.length > 0) {
            var combinedError = combineErrors(errors);
            throw combinedError;
        }
    }
    if (operation === 'query' || operation === 'mutation') {
        var executor = createExecutor(targetSchema, targetRootValue, context, subschemaConfig);
        var executionResult = executor({
            document: processedRequest.document,
            context: context,
            variables: processedRequest.variables,
        });
        if (executionResult instanceof Promise) {
            return executionResult.then(function (originalResult) {
                return applyResultTransforms(originalResult, delegationTransforms);
            });
        }
        return applyResultTransforms(executionResult, delegationTransforms);
    }
    var subscriber = createSubscriber(targetSchema, targetRootValue, context, subschemaConfig);
    return subscriber({
        document: processedRequest.document,
        context: context,
        variables: processedRequest.variables,
    }).then(function (subscriptionResult) {
        if (Object(iterall__WEBPACK_IMPORTED_MODULE_1__["isAsyncIterable"])(subscriptionResult)) {
            // "subscribe" to the subscription result and map the result through the transforms
            return mapAsyncIterator(subscriptionResult, function (result) {
                var _a;
                var transformedResult = applyResultTransforms(result, delegationTransforms);
                // wrap with fieldName to return for an additional round of resolutioon
                // with payload as rootValue
                return _a = {},
                    _a[info.fieldName] = transformedResult,
                    _a;
            });
        }
        return applyResultTransforms(subscriptionResult, delegationTransforms);
    });
}
function createExecutor(schema, rootValue, context, subschemaConfig) {
    var fetcher;
    var targetRootValue = rootValue;
    if (subschemaConfig != null) {
        if (subschemaConfig.dispatcher != null) {
            var dynamicLinkOrFetcher = subschemaConfig.dispatcher(context);
            fetcher =
                typeof dynamicLinkOrFetcher === 'function'
                    ? dynamicLinkOrFetcher
                    : linkToFetcher(dynamicLinkOrFetcher);
        }
        else if (subschemaConfig.link != null) {
            fetcher = linkToFetcher(subschemaConfig.link);
        }
        else if (subschemaConfig.fetcher != null) {
            fetcher = subschemaConfig.fetcher;
        }
        if (!fetcher && !rootValue && subschemaConfig.rootValue != null) {
            targetRootValue = subschemaConfig.rootValue;
        }
    }
    if (fetcher != null) {
        return function (_a) {
            var document = _a.document, graphqlContext = _a.context, variables = _a.variables;
            return fetcher({
                query: document,
                variables: variables,
                context: { graphqlContext: graphqlContext },
            });
        };
    }
    return function (_a) {
        var document = _a.document, graphqlContext = _a.context, variables = _a.variables;
        return Object(graphql__WEBPACK_IMPORTED_MODULE_3__["execute"])({
            schema: schema,
            document: document,
            rootValue: targetRootValue,
            contextValue: graphqlContext,
            variableValues: variables,
        });
    };
}
function createSubscriber(schema, rootValue, context, subschemaConfig) {
    var link;
    var targetRootValue = rootValue;
    if (subschemaConfig != null) {
        if (subschemaConfig.dispatcher != null) {
            link = subschemaConfig.dispatcher(context);
        }
        else if (subschemaConfig.link != null) {
            link = subschemaConfig.link;
        }
        if (!link && !rootValue && subschemaConfig.rootValue != null) {
            targetRootValue = subschemaConfig.rootValue;
        }
    }
    if (link != null) {
        return function (_a) {
            var document = _a.document, graphqlContext = _a.context, variables = _a.variables;
            var operation = {
                query: document,
                variables: variables,
                context: { graphqlContext: graphqlContext },
            };
            var observable = Object(apollo_link__WEBPACK_IMPORTED_MODULE_2__["execute"])(link, operation);
            return Promise.resolve(observableToAsyncIterable(observable));
        };
    }
    return function (_a) {
        var document = _a.document, graphqlContext = _a.context, variables = _a.variables;
        return Object(graphql__WEBPACK_IMPORTED_MODULE_3__["subscribe"])({
            schema: schema,
            document: document,
            rootValue: targetRootValue,
            contextValue: graphqlContext,
            variableValues: variables,
        });
    };
}

// @schemaDefinition: A GraphQL type schema in shorthand
// @resolvers: Definitions for resolvers to be merged with schema
var SchemaError = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __extends */ "b"])(SchemaError, _super);
    function SchemaError(message) {
        var _this = _super.call(this, message) || this;
        _this.message = message;
        Error.captureStackTrace(_this, _this.constructor);
        return _this;
    }
    return SchemaError;
}(Error));

// If we have any union or interface types throw if no there is no resolveType or isTypeOf resolvers
function checkForResolveTypeResolver(schema, requireResolversForResolveType) {
    Object.keys(schema.getTypeMap())
        .map(function (typeName) { return schema.getType(typeName); })
        .forEach(function (type) {
        if (!Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isAbstractType"])(type)) {
            return;
        }
        if (!type.resolveType) {
            if (!requireResolversForResolveType) {
                return;
            }
            throw new SchemaError("Type \"" + type.name + "\" is missing a \"__resolveType\" resolver. Pass false into " +
                '"resolverValidationOptions.requireResolversForResolveType" to disable this error.');
        }
    });
}

function extendResolversFromInterfaces(schema, resolvers) {
    var typeNames = Object.keys(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, schema.getTypeMap()), resolvers));
    var extendedResolvers = {};
    typeNames.forEach(function (typeName) {
        var typeResolvers = resolvers[typeName];
        var type = schema.getType(typeName);
        if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isObjectType"])(type) ||
            (graphqlVersion() >= 15 && Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isInterfaceType"])(type))) {
            var interfaceResolvers = type
                .getInterfaces()
                .map(function (iFace) { return resolvers[iFace.name]; });
            extendedResolvers[typeName] = Object.assign.apply(Object, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __spreadArrays */ "d"])([{}], interfaceResolvers, [typeResolvers]));
        }
        else if (typeResolvers != null) {
            extendedResolvers[typeName] = typeResolvers;
        }
    });
    return extendedResolvers;
}

function addResolversToSchema(schemaOrOptions, legacyInputResolvers, legacyInputValidationOptions) {
    var options = Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isSchema"])(schemaOrOptions)
        ? {
            schema: schemaOrOptions,
            resolvers: legacyInputResolvers,
            resolverValidationOptions: legacyInputValidationOptions,
        }
        : schemaOrOptions;
    var schema = options.schema, inputResolvers = options.resolvers, defaultFieldResolver = options.defaultFieldResolver, _a = options.resolverValidationOptions, resolverValidationOptions = _a === void 0 ? {} : _a, _b = options.inheritResolversFromInterfaces, inheritResolversFromInterfaces = _b === void 0 ? false : _b;
    var _c = resolverValidationOptions.allowResolversNotInSchema, allowResolversNotInSchema = _c === void 0 ? false : _c, requireResolversForResolveType = resolverValidationOptions.requireResolversForResolveType;
    var resolvers = inheritResolversFromInterfaces
        ? extendResolversFromInterfaces(schema, inputResolvers)
        : inputResolvers;
    var typeMap = schema.getTypeMap();
    Object.keys(resolvers).forEach(function (typeName) {
        var resolverValue = resolvers[typeName];
        var resolverType = typeof resolverValue;
        if (resolverType !== 'object' && resolverType !== 'function') {
            throw new SchemaError("\"" + typeName + "\" defined in resolvers, but has invalid value \"" + resolverValue + "\". A resolver's value must be of type object or function.");
        }
        var type = schema.getType(typeName);
        if (!type && typeName !== '__schema') {
            if (allowResolversNotInSchema) {
                return;
            }
            throw new SchemaError("\"" + typeName + "\" defined in resolvers, but not in schema");
        }
        if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isScalarType"])(type)) {
            // Support -- without recommending -- overriding default scalar types
            Object.keys(resolverValue).forEach(function (fieldName) {
                if (fieldName.startsWith('__')) {
                    type[fieldName.substring(2)] = resolverValue[fieldName];
                }
                else {
                    type[fieldName] = resolverValue[fieldName];
                }
            });
        }
        else if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isEnumType"])(type)) {
            // We've encountered an enum resolver that is being used to provide an
            // internal enum value.
            // Reference: https://www.apollographql.com/docs/graphql-tools/scalars.html#internal-values
            Object.keys(resolverValue).forEach(function (fieldName) {
                if (!type.getValue(fieldName)) {
                    if (allowResolversNotInSchema) {
                        return;
                    }
                    throw new SchemaError(typeName + "." + fieldName + " was defined in resolvers, but enum is not in schema");
                }
            });
            var config = toConfig(type);
            var values = type.getValues();
            var newValues = keyValMap(values, function (value) { return value.name; }, function (value) {
                var newValue = Object.keys(resolverValue).includes(value.name)
                    ? resolverValue[value.name]
                    : value.name;
                return {
                    value: newValue,
                    deprecationReason: value.deprecationReason,
                    description: value.description,
                    astNode: value.astNode,
                };
            });
            // healSchema called later to update all fields to new type
            typeMap[typeName] = new graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLEnumType"](Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, config), { values: newValues }));
        }
        else if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isUnionType"])(type)) {
            Object.keys(resolverValue).forEach(function (fieldName) {
                if (fieldName.startsWith('__')) {
                    // this is for isTypeOf and resolveType and all the other stuff.
                    type[fieldName.substring(2)] = resolverValue[fieldName];
                    return;
                }
                if (allowResolversNotInSchema) {
                    return;
                }
                throw new SchemaError(typeName + " was defined in resolvers, but it's not an object");
            });
        }
        else if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isObjectType"])(type) || Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isInterfaceType"])(type)) {
            Object.keys(resolverValue).forEach(function (fieldName) {
                if (fieldName.startsWith('__')) {
                    // this is for isTypeOf and resolveType and all the other stuff.
                    type[fieldName.substring(2)] = resolverValue[fieldName];
                    return;
                }
                var fields = type.getFields();
                var field = fields[fieldName];
                if (field == null) {
                    if (allowResolversNotInSchema) {
                        return;
                    }
                    throw new SchemaError(typeName + "." + fieldName + " defined in resolvers, but not in schema");
                }
                var fieldResolve = resolverValue[fieldName];
                if (typeof fieldResolve === 'function') {
                    // for convenience. Allows shorter syntax in resolver definition file
                    field.resolve = fieldResolve;
                }
                else {
                    if (typeof fieldResolve !== 'object') {
                        throw new SchemaError("Resolver " + typeName + "." + fieldName + " must be object or function");
                    }
                    setFieldProperties(field, fieldResolve);
                }
            });
        }
    });
    checkForResolveTypeResolver(schema, requireResolversForResolveType);
    // serialize all default values prior to healing fields with new scalar/enum types.
    forEachDefaultValue(schema, serializeInputValue);
    // schema may have new scalar/enum types that require healing
    healSchema(schema);
    // reparse all default values with new parsing functions.
    forEachDefaultValue(schema, parseInputValue);
    if (defaultFieldResolver != null) {
        forEachField(schema, function (field) {
            if (!field.resolve) {
                field.resolve = defaultFieldResolver;
            }
        });
    }
    return schema;
}
function setFieldProperties(field, propertiesObj) {
    Object.keys(propertiesObj).forEach(function (propertyName) {
        field[propertyName] = propertiesObj[propertyName];
    });
}

// wraps all resolvers of query, mutation or subscription fields
// with the provided function to simulate a root schema level resolver
function addSchemaLevelResolver(schema, fn) {
    // TODO test that schema is a schema, fn is a function
    var rootTypes = [
        schema.getQueryType(),
        schema.getMutationType(),
        schema.getSubscriptionType(),
    ].filter(function (x) { return Boolean(x); });
    rootTypes.forEach(function (type) {
        if (type != null) {
            // XXX this should run at most once per request to simulate a true root resolver
            // for graphql-js this is an approximation that works with queries but not mutations
            var rootResolveFn_1 = runAtMostOncePerRequest(fn);
            var fields_1 = type.getFields();
            Object.keys(fields_1).forEach(function (fieldName) {
                // XXX if the type is a subscription, a same query AST will be ran multiple times so we
                // deactivate here the runOnce if it's a subscription. This may not be optimal though...
                if (type === schema.getSubscriptionType()) {
                    fields_1[fieldName].resolve = wrapResolver(fields_1[fieldName].resolve, fn);
                }
                else {
                    fields_1[fieldName].resolve = wrapResolver(fields_1[fieldName].resolve, rootResolveFn_1);
                }
            });
        }
    });
}
// XXX badly named function. this doesn't really wrap, it just chains resolvers...
function wrapResolver(innerResolver, outerResolver) {
    return function (obj, args, ctx, info) {
        return Promise.resolve(outerResolver(obj, args, ctx, info)).then(function (root) {
            if (innerResolver != null) {
                return innerResolver(root, args, ctx, info);
            }
            return Object(graphql__WEBPACK_IMPORTED_MODULE_3__["defaultFieldResolver"])(root, args, ctx, info);
        });
    };
}
// XXX this function only works for resolvers
// XXX very hacky way to remember if the function
// already ran for this request. This will only work
// if people don't actually cache the operation.
// if they do cache the operation, they will have to
// manually remove the __runAtMostOnce before every request.
function runAtMostOncePerRequest(fn) {
    var value;
    var randomNumber = Math.random();
    return function (root, args, ctx, info) {
        if (!info.operation['__runAtMostOnce']) {
            info.operation['__runAtMostOnce'] = {};
        }
        if (!info.operation['__runAtMostOnce'][randomNumber]) {
            info.operation['__runAtMostOnce'][randomNumber] = true;
            value = fn(root, args, ctx, info);
        }
        return value;
    };
}

function assertResolversPresent(schema, resolverValidationOptions) {
    if (resolverValidationOptions === void 0) { resolverValidationOptions = {}; }
    var _a = resolverValidationOptions.requireResolversForArgs, requireResolversForArgs = _a === void 0 ? false : _a, _b = resolverValidationOptions.requireResolversForNonScalar, requireResolversForNonScalar = _b === void 0 ? false : _b, _c = resolverValidationOptions.requireResolversForAllFields, requireResolversForAllFields = _c === void 0 ? false : _c;
    if (requireResolversForAllFields &&
        (requireResolversForArgs || requireResolversForNonScalar)) {
        throw new TypeError('requireResolversForAllFields takes precedence over the more specific assertions. ' +
            'Please configure either requireResolversForAllFields or requireResolversForArgs / ' +
            'requireResolversForNonScalar, but not a combination of them.');
    }
    forEachField(schema, function (field, typeName, fieldName) {
        // requires a resolver for *every* field.
        if (requireResolversForAllFields) {
            expectResolver(field, typeName, fieldName);
        }
        // requires a resolver on every field that has arguments
        if (requireResolversForArgs && field.args.length > 0) {
            expectResolver(field, typeName, fieldName);
        }
        // requires a resolver on every field that returns a non-scalar type
        if (requireResolversForNonScalar &&
            !Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isScalarType"])(Object(graphql__WEBPACK_IMPORTED_MODULE_3__["getNamedType"])(field.type))) {
            expectResolver(field, typeName, fieldName);
        }
    });
}
function expectResolver(field, typeName, fieldName) {
    if (!field.resolve) {
        // eslint-disable-next-line no-console
        console.warn("Resolver missing for \"" + typeName + "." + fieldName + "\". To disable this warning check https://github.com/apollostack/graphql-tools/issues/131");
        return;
    }
    if (typeof field.resolve !== 'function') {
        throw new SchemaError("Resolver \"" + typeName + "." + fieldName + "\" must be a function");
    }
}

function attachDirectiveResolvers(schema, directiveResolvers) {
    if (typeof directiveResolvers !== 'object') {
        throw new Error("Expected directiveResolvers to be of type object, got " + typeof directiveResolvers);
    }
    if (Array.isArray(directiveResolvers)) {
        throw new Error('Expected directiveResolvers to be of type object, got Array');
    }
    var schemaDirectives = Object.create(null);
    Object.keys(directiveResolvers).forEach(function (directiveName) {
        schemaDirectives[directiveName] = /** @class */ (function (_super) {
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __extends */ "b"])(class_1, _super);
            function class_1() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            class_1.prototype.visitFieldDefinition = function (field) {
                var resolver = directiveResolvers[directiveName];
                var originalResolver = field.resolve != null ? field.resolve : graphql__WEBPACK_IMPORTED_MODULE_3__["defaultFieldResolver"];
                var directiveArgs = this.args;
                field.resolve = function () {
                    var args = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        args[_i] = arguments[_i];
                    }
                    var source = args[0] /* original args */, context = args[2], info = args[3];
                    return resolver(function () {
                        return new Promise(function (resolve, reject) {
                            var result = originalResolver.apply(field, args);
                            if (result instanceof Error) {
                                reject(result);
                            }
                            resolve(result);
                        });
                    }, source, directiveArgs, context, info);
                };
            };
            return class_1;
        }(SchemaDirectiveVisitor));
    });
    SchemaDirectiveVisitor.visitSchemaDirectives(schema, schemaDirectives);
}

// takes a GraphQL-JS schema and an object of connectors, then attaches
// the connectors to the context by wrapping each query or mutation resolve
// function with a function that attaches connectors if they don't exist.
// attaches connectors only once to make sure they are singletons
var attachConnectorsToContext = Object(deprecated_decorator__WEBPACK_IMPORTED_MODULE_4__["deprecated"])({
    version: '0.7.0',
    url: 'https://github.com/apollostack/graphql-tools/issues/140',
}, function (schema, connectors) {
    if (!schema || !Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isSchema"])(schema)) {
        throw new Error('schema must be an instance of GraphQLSchema. ' +
            'This error could be caused by installing more than one version of GraphQL-JS');
    }
    if (typeof connectors !== 'object') {
        var connectorType = typeof connectors;
        throw new Error("Expected connectors to be of type object, got " + connectorType);
    }
    if (Object.keys(connectors).length === 0) {
        throw new Error('Expected connectors to not be an empty object');
    }
    if (Array.isArray(connectors)) {
        throw new Error('Expected connectors to be of type object, got Array');
    }
    if (schema['_apolloConnectorsAttached']) {
        throw new Error('Connectors already attached to context, cannot attach more than once');
    }
    schema['_apolloConnectorsAttached'] = true;
    var attachconnectorFn = function (root, _args, ctx) {
        if (typeof ctx !== 'object') {
            // if in any way possible, we should throw an error when the attachconnectors
            // function is called, not when a query is executed.
            var contextType = typeof ctx;
            throw new Error("Cannot attach connector because context is not an object: " + contextType);
        }
        if (typeof ctx.connectors === 'undefined') {
            ctx.connectors = {};
        }
        Object.keys(connectors).forEach(function (connectorName) {
            var connector = connectors[connectorName];
            if (connector.prototype != null) {
                ctx.connectors[connectorName] = new connector(ctx);
            }
            else {
                throw new Error('Connector must be a function or an class');
            }
        });
        return root;
    };
    addSchemaLevelResolver(schema, attachconnectorFn);
});

function extractExtensionDefinitions(ast) {
    var extensionDefs = ast.definitions.filter(function (def) {
        return def.kind === graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].OBJECT_TYPE_EXTENSION ||
            (graphqlVersion() >= 13 && def.kind === graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].INTERFACE_TYPE_EXTENSION) ||
            def.kind === graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].INPUT_OBJECT_TYPE_EXTENSION ||
            def.kind === graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].UNION_TYPE_EXTENSION ||
            def.kind === graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].ENUM_TYPE_EXTENSION ||
            def.kind === graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].SCALAR_TYPE_EXTENSION ||
            def.kind === graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].SCHEMA_EXTENSION;
    });
    return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, ast), { definitions: extensionDefs });
}
function filterExtensionDefinitions(ast) {
    var extensionDefs = ast.definitions.filter(function (def) {
        return def.kind !== graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].OBJECT_TYPE_EXTENSION &&
            def.kind !== graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].INTERFACE_TYPE_EXTENSION &&
            def.kind !== graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].INPUT_OBJECT_TYPE_EXTENSION &&
            def.kind !== graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].UNION_TYPE_EXTENSION &&
            def.kind !== graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].ENUM_TYPE_EXTENSION &&
            def.kind !== graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].SCALAR_TYPE_EXTENSION &&
            def.kind !== graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].SCHEMA_EXTENSION;
    });
    return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, ast), { definitions: extensionDefs });
}

function concatenateTypeDefs(typeDefinitionsAry, calledFunctionRefs) {
    if (calledFunctionRefs === void 0) { calledFunctionRefs = []; }
    var resolvedTypeDefinitions = [];
    typeDefinitionsAry.forEach(function (typeDef) {
        if (typeof typeDef === 'function') {
            if (calledFunctionRefs.indexOf(typeDef) === -1) {
                calledFunctionRefs.push(typeDef);
                resolvedTypeDefinitions = resolvedTypeDefinitions.concat(concatenateTypeDefs(typeDef(), calledFunctionRefs));
            }
        }
        else if (typeof typeDef === 'string') {
            resolvedTypeDefinitions.push(typeDef.trim());
        }
        else if (typeDef.kind !== undefined) {
            resolvedTypeDefinitions.push(Object(graphql__WEBPACK_IMPORTED_MODULE_3__["print"])(typeDef).trim());
        }
        else {
            var type = typeof typeDef;
            throw new SchemaError("typeDef array must contain only strings and functions, got " + type);
        }
    });
    return uniq(resolvedTypeDefinitions.map(function (x) { return x.trim(); })).join('\n');
}
function uniq(array) {
    return array.reduce(function (accumulator, currentValue) {
        return accumulator.indexOf(currentValue) === -1
            ? Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __spreadArrays */ "d"])(accumulator, [currentValue]) : accumulator;
    }, []);
}

function buildSchemaFromTypeDefinitions(typeDefinitions, parseOptions) {
    // TODO: accept only array here, otherwise interfaces get confusing.
    var myDefinitions = typeDefinitions;
    var astDocument;
    if (isDocumentNode(typeDefinitions)) {
        astDocument = typeDefinitions;
    }
    else if (typeof myDefinitions !== 'string') {
        if (!Array.isArray(myDefinitions)) {
            var type = typeof myDefinitions;
            throw new SchemaError("typeDefs must be a string, array or schema AST, got " + type);
        }
        myDefinitions = concatenateTypeDefs(myDefinitions);
    }
    if (typeof myDefinitions === 'string') {
        astDocument = Object(graphql__WEBPACK_IMPORTED_MODULE_3__["parse"])(myDefinitions, parseOptions);
    }
    var typesAst = filterExtensionDefinitions(astDocument);
    var backcompatOptions = { commentDescriptions: true };
    var schema = Object(graphql__WEBPACK_IMPORTED_MODULE_3__["buildASTSchema"])(typesAst, backcompatOptions);
    var extensionsAst = extractExtensionDefinitions(astDocument);
    if (extensionsAst.definitions.length > 0) {
        schema = Object(graphql__WEBPACK_IMPORTED_MODULE_3__["extendSchema"])(schema, extensionsAst, backcompatOptions);
    }
    return schema;
}
function isDocumentNode(typeDefinitions) {
    return typeDefinitions.kind !== undefined;
}

function chainResolvers(resolvers) {
    return function (root, args, ctx, info) {
        return resolvers.reduce(function (prev, curResolver) {
            if (curResolver != null) {
                return curResolver(prev, args, ctx, info);
            }
            return Object(graphql__WEBPACK_IMPORTED_MODULE_3__["defaultFieldResolver"])(prev, args, ctx, info);
        }, root);
    };
}

/*
 * fn: The function to decorate with the logger
 * logger: an object instance of type Logger
 * hint: an optional hint to add to the error's message
 */
function decorateWithLogger(fn, logger, hint) {
    var resolver = fn != null ? fn : graphql__WEBPACK_IMPORTED_MODULE_3__["defaultFieldResolver"];
    var logError = function (e) {
        // TODO: clone the error properly
        var newE = new Error();
        newE.stack = e.stack;
        /* istanbul ignore else: always get the hint from addErrorLoggingToSchema */
        if (hint) {
            newE['originalMessage'] = e.message;
            newE['message'] = "Error in resolver " + hint + "\n" + e.message;
        }
        logger.log(newE);
    };
    return function (root, args, ctx, info) {
        try {
            var result = resolver(root, args, ctx, info);
            // If the resolver returns a Promise log any Promise rejects.
            if (result &&
                typeof result.then === 'function' &&
                typeof result.catch === 'function') {
                result.catch(function (reason) {
                    // make sure that it's an error we're logging.
                    var error = reason instanceof Error ? reason : new Error(reason);
                    logError(error);
                    // We don't want to leave an unhandled exception so pass on error.
                    return reason;
                });
            }
            return result;
        }
        catch (e) {
            logError(e);
            // we want to pass on the error, just in case.
            throw e;
        }
    };
}

function makeExecutableSchema(_a) {
    var typeDefs = _a.typeDefs, _b = _a.resolvers, resolvers = _b === void 0 ? {} : _b, connectors = _a.connectors, logger = _a.logger, _c = _a.allowUndefinedInResolve, allowUndefinedInResolve = _c === void 0 ? true : _c, _d = _a.resolverValidationOptions, resolverValidationOptions = _d === void 0 ? {} : _d, directiveResolvers = _a.directiveResolvers, schemaDirectives = _a.schemaDirectives, _e = _a.parseOptions, parseOptions = _e === void 0 ? {} : _e, _f = _a.inheritResolversFromInterfaces, inheritResolversFromInterfaces = _f === void 0 ? false : _f;
    // Validate and clean up arguments
    if (typeof resolverValidationOptions !== 'object') {
        throw new SchemaError('Expected `resolverValidationOptions` to be an object');
    }
    if (!typeDefs) {
        throw new SchemaError('Must provide typeDefs');
    }
    // We allow passing in an array of resolver maps, in which case we merge them
    var resolverMap = Array.isArray(resolvers)
        ? resolvers
            .filter(function (resolverObj) { return typeof resolverObj === 'object'; })
            .reduce(mergeDeep, {})
        : resolvers;
    // Arguments are now validated and cleaned up
    var schema = buildSchemaFromTypeDefinitions(typeDefs, parseOptions);
    addResolversToSchema({
        schema: schema,
        resolvers: resolverMap,
        resolverValidationOptions: resolverValidationOptions,
        inheritResolversFromInterfaces: inheritResolversFromInterfaces,
    });
    assertResolversPresent(schema, resolverValidationOptions);
    if (!allowUndefinedInResolve) {
        addCatchUndefinedToSchema(schema);
    }
    if (logger != null) {
        addErrorLoggingToSchema(schema, logger);
    }
    if (typeof resolvers['__schema'] === 'function') {
        // TODO a bit of a hack now, better rewrite generateSchema to attach it there.
        // not doing that now, because I'd have to rewrite a lot of tests.
        addSchemaLevelResolver(schema, resolvers['__schema']);
    }
    if (connectors != null) {
        // connectors are optional, at least for now. That means you can just import them in the resolve
        // function if you want.
        attachConnectorsToContext(schema, connectors);
    }
    if (directiveResolvers != null) {
        attachDirectiveResolvers(schema, directiveResolvers);
    }
    if (schemaDirectives != null) {
        SchemaDirectiveVisitor.visitSchemaDirectives(schema, schemaDirectives);
    }
    return schema;
}
function decorateToCatchUndefined(fn, hint) {
    var resolve = fn == null ? graphql__WEBPACK_IMPORTED_MODULE_3__["defaultFieldResolver"] : fn;
    return function (root, args, ctx, info) {
        var result = resolve(root, args, ctx, info);
        if (typeof result === 'undefined') {
            throw new Error("Resolver for \"" + hint + "\" returned undefined");
        }
        return result;
    };
}
function addCatchUndefinedToSchema(schema) {
    forEachField(schema, function (field, typeName, fieldName) {
        var errorHint = typeName + "." + fieldName;
        field.resolve = decorateToCatchUndefined(field.resolve, errorHint);
    });
}
function addErrorLoggingToSchema(schema, logger) {
    if (!logger) {
        throw new Error('Must provide a logger');
    }
    if (typeof logger.log !== 'function') {
        throw new Error('Logger.log must be a function');
    }
    forEachField(schema, function (field, typeName, fieldName) {
        var errorHint = typeName + "." + fieldName;
        field.resolve = decorateWithLogger(field.resolve, logger, errorHint);
    });
}

// These functions are preserved for backwards compatibility.
// They are not simply rexported with new (old) names so as to allow
// typedoc to annotate them.
function addResolveFunctionsToSchema(schemaOrOptions, legacyInputResolvers, legacyInputValidationOptions) {
    return addResolversToSchema(schemaOrOptions, legacyInputResolvers, legacyInputValidationOptions);
}
function addSchemaLevelResolveFunction(schema, fn) {
    addSchemaLevelResolver(schema, fn);
}
function assertResolveFunctionsPresent(schema, resolverValidationOptions) {
    if (resolverValidationOptions === void 0) { resolverValidationOptions = {}; }
    assertResolversPresent(schema, resolverValidationOptions);
}

function getFinalPromise(object) {
    return Promise.resolve(object).then(function (resolvedObject) {
        if (resolvedObject == null) {
            return resolvedObject;
        }
        if (Array.isArray(resolvedObject)) {
            return Promise.all(resolvedObject.map(function (o) { return getFinalPromise(o); }));
        }
        else if (typeof resolvedObject === 'object') {
            var keys_1 = Object.keys(resolvedObject);
            return Promise.all(keys_1.map(function (key) { return getFinalPromise(resolvedObject[key]); })).then(function (awaitedValues) {
                for (var i = 0; i < keys_1.length; i++) {
                    resolvedObject[keys_1[i]] = awaitedValues[i];
                }
                return resolvedObject;
            });
        }
        return resolvedObject;
    });
}
var AwaitVariablesLink = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __extends */ "b"])(AwaitVariablesLink, _super);
    function AwaitVariablesLink() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    AwaitVariablesLink.prototype.request = function (operation, forward) {
        return new apollo_link__WEBPACK_IMPORTED_MODULE_2__["Observable"](function (observer) {
            var subscription;
            getFinalPromise(operation.variables)
                .then(function (resolvedVariables) {
                operation.variables = resolvedVariables;
                subscription = forward(operation).subscribe({
                    next: observer.next.bind(observer),
                    error: observer.error.bind(observer),
                    complete: observer.complete.bind(observer),
                });
            })
                .catch(observer.error.bind(observer));
            return function () {
                if (subscription != null) {
                    subscription.unsubscribe();
                }
            };
        });
    };
    return AwaitVariablesLink;
}(apollo_link__WEBPACK_IMPORTED_MODULE_2__["ApolloLink"]));

/* eslint-disable import/no-nodejs-modules */
var FormDataWithStreamSupport = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __extends */ "b"])(FormDataWithStreamSupport, _super);
    function FormDataWithStreamSupport(options) {
        var _this = _super.call(this, options) || this;
        _this.hasUnknowableLength = false;
        return _this;
    }
    FormDataWithStreamSupport.prototype.append = function (key, value, optionsOrFilename) {
        if (optionsOrFilename === void 0) { optionsOrFilename = {}; }
        // allow filename as single option
        var options = typeof optionsOrFilename === 'string'
            ? { filename: optionsOrFilename }
            : optionsOrFilename;
        // empty or either doesn't have path or not an http response
        if (!options.knownLength &&
            !Buffer.isBuffer(value) &&
            typeof value !== 'string' &&
            !value.path &&
            !(value.readable && hasOwnProperty(value, 'httpVersion'))) {
            this.hasUnknowableLength = true;
        }
        _super.prototype.append.call(this, key, value, options);
    };
    FormDataWithStreamSupport.prototype.getLength = function (callback) {
        if (this.hasUnknowableLength) {
            return null;
        }
        return _super.prototype.getLength.call(this, callback);
    };
    FormDataWithStreamSupport.prototype.getLengthSync = function () {
        if (this.hasUnknowableLength) {
            return null;
        }
        // eslint-disable-next-line no-sync
        return _super.prototype.getLengthSync.call(this);
    };
    return FormDataWithStreamSupport;
}(form_data__WEBPACK_IMPORTED_MODULE_6___default.a));
var createServerHttpLink = function (options) {
    return Object(apollo_link__WEBPACK_IMPORTED_MODULE_2__["concat"])(new AwaitVariablesLink(), Object(apollo_upload_client__WEBPACK_IMPORTED_MODULE_5__["createUploadLink"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, options), { fetch: node_fetch__WEBPACK_IMPORTED_MODULE_7__["default"], FormData: FormDataWithStreamSupport, isExtractableFile: function (value) {
            return Object(apollo_upload_client__WEBPACK_IMPORTED_MODULE_5__["isExtractableFile"])(value) || (value === null || value === void 0 ? void 0 : value.createReadStream);
        }, formDataAppendFile: function (form, index, file) {
            if (file.createReadStream != null) {
                form.append(index, file.createReadStream(), {
                    filename: file.filename,
                    contentType: file.mimetype,
                });
            }
            else {
                Object(apollo_upload_client__WEBPACK_IMPORTED_MODULE_5__["formDataAppendFile"])(form, index, file);
            }
        } })));
};

/**
 * This function wraps addMocksToSchema for more convenience
 */
function mockServer(schema, mocks, preserveResolvers) {
    if (preserveResolvers === void 0) { preserveResolvers = false; }
    var mySchema;
    if (!Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isSchema"])(schema)) {
        // TODO: provide useful error messages here if this fails
        mySchema = buildSchemaFromTypeDefinitions(schema);
    }
    else {
        mySchema = schema;
    }
    addMocksToSchema({ schema: mySchema, mocks: mocks, preserveResolvers: preserveResolvers });
    return { query: function (query, vars) { return Object(graphql__WEBPACK_IMPORTED_MODULE_3__["graphql"])(mySchema, query, {}, {}, vars); } };
}
var defaultMockMap = new Map();
defaultMockMap.set('Int', function () { return Math.round(Math.random() * 200) - 100; });
defaultMockMap.set('Float', function () { return Math.random() * 200 - 100; });
defaultMockMap.set('String', function () { return 'Hello World'; });
defaultMockMap.set('Boolean', function () { return Math.random() > 0.5; });
defaultMockMap.set('ID', function () { return Object(uuid__WEBPACK_IMPORTED_MODULE_8__[/* v4 */ "a"])(); });
// TODO allow providing a seed such that lengths of list could be deterministic
// this could be done by using casual to get a random list length if the casual
// object is global.
function addMocksToSchema(_a) {
    var schema = _a.schema, _b = _a.mocks, mocks = _b === void 0 ? {} : _b, _c = _a.preserveResolvers, preserveResolvers = _c === void 0 ? false : _c;
    if (!schema) {
        throw new Error('Must provide schema to mock');
    }
    if (!Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isSchema"])(schema)) {
        throw new Error('Value at "schema" must be of type GraphQLSchema');
    }
    if (!isObject$1(mocks)) {
        throw new Error('mocks must be of type Object');
    }
    // use Map internally, because that API is nicer.
    var mockFunctionMap = new Map();
    Object.keys(mocks).forEach(function (typeName) {
        mockFunctionMap.set(typeName, mocks[typeName]);
    });
    mockFunctionMap.forEach(function (mockFunction, mockTypeName) {
        if (typeof mockFunction !== 'function') {
            throw new Error("mockFunctionMap[" + mockTypeName + "] must be a function");
        }
    });
    var mockType = function (type, _typeName, fieldName) {
        // order of precendence for mocking:
        // 1. if the object passed in already has fieldName, just use that
        // --> if it's a function, that becomes your resolver
        // --> if it's a value, the mock resolver will return that
        // 2. if the nullableType is a list, recurse
        // 2. if there's a mock defined for this typeName, that will be used
        // 3. if there's no mock defined, use the default mocks for this type
        return function (root, args, context, info) {
            // nullability doesn't matter for the purpose of mocking.
            var fieldType = Object(graphql__WEBPACK_IMPORTED_MODULE_3__["getNullableType"])(type);
            var namedFieldType = Object(graphql__WEBPACK_IMPORTED_MODULE_3__["getNamedType"])(fieldType);
            if (fieldName && root && typeof root[fieldName] !== 'undefined') {
                var result = void 0;
                // if we're here, the field is already defined
                if (typeof root[fieldName] === 'function') {
                    result = root[fieldName](root, args, context, info);
                    if (result instanceof MockList) {
                        result = result.mock(root, args, context, info, fieldType, mockType);
                    }
                }
                else {
                    result = root[fieldName];
                }
                // Now we merge the result with the default mock for this type.
                // This allows overriding defaults while writing very little code.
                if (mockFunctionMap.has(namedFieldType.name)) {
                    var mock = mockFunctionMap.get(namedFieldType.name);
                    result = mergeMocks(mock.bind(null, root, args, context, info), result);
                }
                return result;
            }
            if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isListType"])(fieldType)) {
                return [
                    mockType(fieldType.ofType)(root, args, context, info),
                    mockType(fieldType.ofType)(root, args, context, info),
                ];
            }
            if (mockFunctionMap.has(fieldType.name) && !Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isAbstractType"])(fieldType)) {
                // the object passed doesn't have this field, so we apply the default mock
                var mock = mockFunctionMap.get(fieldType.name);
                return mock(root, args, context, info);
            }
            if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isObjectType"])(fieldType)) {
                // objects don't return actual data, we only need to mock scalars!
                return {};
            }
            // if a mock function is provided for unionType or interfaceType, execute it to resolve the concrete type
            // otherwise randomly pick a type from all implementation types
            if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isAbstractType"])(fieldType)) {
                var implementationType = void 0;
                if (mockFunctionMap.has(fieldType.name)) {
                    var mock = mockFunctionMap.get(fieldType.name);
                    var interfaceMockObj = mock(root, args, context, info);
                    if (!interfaceMockObj || !interfaceMockObj.__typename) {
                        return Error("Please return a __typename in \"" + fieldType.name + "\"");
                    }
                    implementationType = schema.getType(interfaceMockObj.__typename);
                }
                else {
                    var possibleTypes = schema.getPossibleTypes(fieldType);
                    implementationType = getRandomElement(possibleTypes);
                }
                return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({ __typename: implementationType }, mockType(implementationType)(root, args, context, info));
            }
            if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isEnumType"])(fieldType)) {
                return getRandomElement(fieldType.getValues()).value;
            }
            if (defaultMockMap.has(fieldType.name)) {
                var defaultMock = defaultMockMap.get(fieldType.name);
                return defaultMock(root, args, context, info);
            }
            // if we get to here, we don't have a value, and we don't have a mock for this type,
            // we could return undefined, but that would be hard to debug, so we throw instead.
            // however, we returning it instead of throwing it, so preserveResolvers can handle the failures.
            return Error("No mock defined for type \"" + fieldType.name + "\"");
        };
    };
    forEachField(schema, function (field, typeName, fieldName) {
        assignResolveType(field.type, preserveResolvers);
        var mockResolver = mockType(field.type, typeName, fieldName);
        // we have to handle the root mutation and root query types differently,
        // because no resolver is called at the root.
        var queryType = schema.getQueryType();
        var isOnQueryType = queryType != null && queryType.name === typeName;
        var mutationType = schema.getMutationType();
        var isOnMutationType = mutationType != null && mutationType.name === typeName;
        if (isOnQueryType || isOnMutationType) {
            if (mockFunctionMap.has(typeName)) {
                var rootMock_1 = mockFunctionMap.get(typeName);
                // XXX: BUG in here, need to provide proper signature for rootMock.
                if (typeof rootMock_1(undefined, {}, {}, {})[fieldName] ===
                    'function') {
                    mockResolver = function (root, args, context, info) {
                        var updatedRoot = root !== null && root !== void 0 ? root : {}; // TODO: should we clone instead?
                        updatedRoot[fieldName] = rootMock_1(root, args, context, info)[fieldName];
                        // XXX this is a bit of a hack to still use mockType, which
                        // lets you mock lists etc. as well
                        // otherwise we could just set field.resolve to rootMock()[fieldName]
                        // it's like pretending there was a resolver that ran before
                        // the root resolver.
                        return mockType(field.type, typeName, fieldName)(updatedRoot, args, context, info);
                    };
                }
            }
        }
        if (!preserveResolvers || !field.resolve) {
            field.resolve = mockResolver;
        }
        else {
            var oldResolver_1 = field.resolve;
            field.resolve = function (rootObject, args, context, info) {
                return Promise.all([
                    mockResolver(rootObject, args, context, info),
                    oldResolver_1(rootObject, args, context, info),
                ]).then(function (values) {
                    var mockedValue = values[0], resolvedValue = values[1];
                    // In case we couldn't mock
                    if (mockedValue instanceof Error) {
                        // only if value was not resolved, populate the error.
                        if (undefined === resolvedValue) {
                            throw mockedValue;
                        }
                        return resolvedValue;
                    }
                    if (resolvedValue instanceof Date && mockedValue instanceof Date) {
                        return undefined !== resolvedValue ? resolvedValue : mockedValue;
                    }
                    if (isObject$1(mockedValue) && isObject$1(resolvedValue)) {
                        // Object.assign() won't do here, as we need to all properties, including
                        // the non-enumerable ones and defined using Object.defineProperty
                        var emptyObject = Object.create(Object.getPrototypeOf(resolvedValue));
                        return copyOwnProps(emptyObject, resolvedValue, mockedValue);
                    }
                    return undefined !== resolvedValue ? resolvedValue : mockedValue;
                });
            };
        }
    });
}
function isObject$1(thing) {
    return thing === Object(thing) && !Array.isArray(thing);
}
// returns a random element from that ary
function getRandomElement(ary) {
    var sample = Math.floor(Math.random() * ary.length);
    return ary[sample];
}
function mergeObjects(a, b) {
    return Object.assign(a, b);
}
function copyOwnPropsIfNotPresent(target, source) {
    Object.getOwnPropertyNames(source).forEach(function (prop) {
        if (!Object.getOwnPropertyDescriptor(target, prop)) {
            var propertyDescriptor = Object.getOwnPropertyDescriptor(source, prop);
            Object.defineProperty(target, prop, propertyDescriptor == null ? {} : propertyDescriptor);
        }
    });
}
function copyOwnProps(target) {
    var sources = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        sources[_i - 1] = arguments[_i];
    }
    sources.forEach(function (source) {
        var chain = source;
        while (chain != null) {
            copyOwnPropsIfNotPresent(target, chain);
            chain = Object.getPrototypeOf(chain);
        }
    });
    return target;
}
// takes either an object or a (possibly nested) array
// and completes the customMock object with any fields
// defined on genericMock
// only merges objects or arrays. Scalars are returned as is
function mergeMocks(genericMockFunction, customMock) {
    if (Array.isArray(customMock)) {
        return customMock.map(function (el) { return mergeMocks(genericMockFunction, el); });
    }
    if (isObject$1(customMock)) {
        return mergeObjects(genericMockFunction(), customMock);
    }
    return customMock;
}
function getResolveType(namedFieldType) {
    if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isAbstractType"])(namedFieldType)) {
        return namedFieldType.resolveType;
    }
}
function assignResolveType(type, preserveResolvers) {
    var fieldType = Object(graphql__WEBPACK_IMPORTED_MODULE_3__["getNullableType"])(type);
    var namedFieldType = Object(graphql__WEBPACK_IMPORTED_MODULE_3__["getNamedType"])(fieldType);
    var oldResolveType = getResolveType(namedFieldType);
    if (preserveResolvers && oldResolveType != null && oldResolveType.length) {
        return;
    }
    if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isInterfaceType"])(namedFieldType) || Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isUnionType"])(namedFieldType)) {
        // the default `resolveType` always returns null. We add a fallback
        // resolution that works with how unions and interface are mocked
        namedFieldType.resolveType = function (data, _context, info) { return info.schema.getType(data.__typename); };
    }
}
var MockList = /** @class */ (function () {
    // wrappedFunction can return another MockList or a value
    function MockList(len, wrappedFunction) {
        this.len = len;
        if (typeof wrappedFunction !== 'undefined') {
            if (typeof wrappedFunction !== 'function') {
                throw new Error('Second argument to MockList must be a function or undefined');
            }
            this.wrappedFunction = wrappedFunction;
        }
    }
    MockList.prototype.mock = function (root, args, context, info, fieldType, mockTypeFunc) {
        var arr;
        if (Array.isArray(this.len)) {
            arr = new Array(this.randint(this.len[0], this.len[1]));
        }
        else {
            arr = new Array(this.len);
        }
        for (var i = 0; i < arr.length; i++) {
            if (typeof this.wrappedFunction === 'function') {
                var res = this.wrappedFunction(root, args, context, info);
                if (res instanceof MockList) {
                    var nullableType = Object(graphql__WEBPACK_IMPORTED_MODULE_3__["getNullableType"])(fieldType.ofType);
                    arr[i] = res.mock(root, args, context, info, nullableType, mockTypeFunc);
                }
                else {
                    arr[i] = res;
                }
            }
            else {
                arr[i] = mockTypeFunc(fieldType.ofType)(root, args, context, info);
            }
        }
        return arr;
    };
    MockList.prototype.randint = function (low, high) {
        return Math.floor(Math.random() * (high - low + 1) + low);
    };
    return MockList;
}());
// retain addMockFunctionsToSchema for backwards compatibility
function addMockFunctionsToSchema(_a) {
    var schema = _a.schema, _b = _a.mocks, mocks = _b === void 0 ? {} : _b, _c = _a.preserveResolvers, preserveResolvers = _c === void 0 ? false : _c;
    addMocksToSchema({ schema: schema, mocks: mocks, preserveResolvers: preserveResolvers });
}

var GraphQLUpload = new graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLScalarType"]({
    name: 'Upload',
    description: 'The `Upload` scalar type represents a file upload.',
    parseValue: function (value) {
        if (value != null && value.promise instanceof Promise) {
            // graphql-upload v10
            return value.promise;
        }
        else if (value instanceof Promise) {
            // graphql-upload v9
            return value;
        }
        throw new graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLError"]('Upload value invalid.');
    },
    // serialization requires to support schema stitching
    serialize: function (value) { return value; },
    parseLiteral: function (ast) {
        throw new graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLError"]('Upload literal unsupported.', ast);
    },
});

var parsedIntrospectionQuery = Object(graphql__WEBPACK_IMPORTED_MODULE_3__["parse"])(Object(graphql__WEBPACK_IMPORTED_MODULE_3__["getIntrospectionQuery"])());
function introspectSchema(linkOrFetcher, linkContext) {
    var fetcher = typeof linkOrFetcher === 'function'
        ? linkOrFetcher
        : linkToFetcher(linkOrFetcher);
    return fetcher({
        query: parsedIntrospectionQuery,
        context: linkContext,
    }).then(function (introspectionResult) {
        if ((Array.isArray(introspectionResult.errors) &&
            introspectionResult.errors.length) ||
            !introspectionResult.data.__schema) {
            if (Array.isArray(introspectionResult.errors)) {
                var combinedError = combineErrors(introspectionResult.errors);
                throw combinedError;
            }
            else {
                throw new Error('Could not obtain introspection result, received: ' +
                    JSON.stringify(introspectionResult));
            }
        }
        else {
            var schema = Object(graphql__WEBPACK_IMPORTED_MODULE_3__["buildClientSchema"])(introspectionResult.data);
            return schema;
        }
    });
}

/**
 * Resolver that knows how to:
 * a) handle aliases for proxied schemas
 * b) handle errors from proxied schemas
 * c) handle external to internal enum coversion
 */
function defaultMergedResolver(parent, args, context, info) {
    if (!parent) {
        return null;
    }
    var responseKey = getResponseKeyFromInfo(info);
    var errors = getErrors(parent, responseKey);
    // check to see if parent is not a proxied result, i.e. if parent resolver was manually overwritten
    // See https://github.com/apollographql/graphql-tools/issues/967
    if (!errors) {
        return Object(graphql__WEBPACK_IMPORTED_MODULE_3__["defaultFieldResolver"])(parent, args, context, info);
    }
    var result = parent[responseKey];
    var subschema = getSubschema(parent, responseKey);
    return handleResult(result, errors, subschema, context, info);
}

function makeMergedType(type) {
    if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isObjectType"])(type)) {
        type.isTypeOf = undefined;
        var fieldMap_1 = type.getFields();
        Object.keys(fieldMap_1).forEach(function (fieldName) {
            fieldMap_1[fieldName].resolve = defaultMergedResolver;
            fieldMap_1[fieldName].subscribe = null;
        });
    }
    else if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isAbstractType"])(type)) {
        type.resolveType = function (parent) { return resolveFromParentTypename(parent); };
    }
}

function generateProxyingResolvers(_a) {
    var subschemaConfig = _a.subschemaConfig, transforms = _a.transforms;
    var targetSchema = subschemaConfig.schema;
    var operationTypes = {
        query: targetSchema.getQueryType(),
        mutation: targetSchema.getMutationType(),
        subscription: targetSchema.getSubscriptionType(),
    };
    var createProxyingResolver = subschemaConfig.createProxyingResolver != null
        ? subschemaConfig.createProxyingResolver
        : defaultCreateProxyingResolver;
    var resolvers = {};
    Object.keys(operationTypes).forEach(function (operation) {
        var resolveField = operation === 'subscription' ? 'subscribe' : 'resolve';
        var rootType = operationTypes[operation];
        if (rootType != null) {
            var typeName_1 = rootType.name;
            var fields = rootType.getFields();
            resolvers[typeName_1] = {};
            Object.keys(fields).forEach(function (fieldName) {
                var _a;
                var proxyingResolver = createProxyingResolver(subschemaConfig, transforms, operation, fieldName);
                var finalResolver = createPossiblyNestedProxyingResolver(subschemaConfig, proxyingResolver);
                resolvers[typeName_1][fieldName] = (_a = {},
                    _a[resolveField] = finalResolver,
                    _a);
            });
        }
    });
    return resolvers;
}
function createPossiblyNestedProxyingResolver(subschemaConfig, proxyingResolver) {
    return function (parent, args, context, info) {
        if (parent != null) {
            var responseKey = getResponseKeyFromInfo(info);
            var errors = getErrors(parent, responseKey);
            // Check to see if the parent contains a proxied result
            if (errors != null) {
                var subschema = getSubschema(parent, responseKey);
                // If there is a proxied result from this subschema, return it
                // This can happen even for a root field when the root type ia
                // also nested as a field within a different type.
                if (subschemaConfig === subschema) {
                    return handleResult(parent[responseKey], errors, subschema, context, info);
                }
            }
        }
        return proxyingResolver(parent, args, context, info);
    };
}
function defaultCreateProxyingResolver(schema, transforms) {
    return function (_parent, _args, context, info) {
        return delegateToSchema({
            schema: schema,
            context: context,
            info: info,
            transforms: transforms,
        });
    };
}
function stripResolvers(schema) {
    var typeMap = schema.getTypeMap();
    Object.keys(typeMap).forEach(function (typeName) {
        if (!typeName.startsWith('__')) {
            makeMergedType(typeMap[typeName]);
        }
    });
}

function wrapSchema(subschemaOrSubschemaConfig, transforms) {
    var subschemaConfig = isSubschemaConfig(subschemaOrSubschemaConfig)
        ? subschemaOrSubschemaConfig
        : { schema: subschemaOrSubschemaConfig };
    var schema = cloneSchema(subschemaConfig.schema);
    stripResolvers(schema);
    var resolvers = generateProxyingResolvers({
        subschemaConfig: subschemaConfig,
        transforms: transforms,
    });
    addResolversToSchema({ schema: schema, resolvers: resolvers });
    var schemaTransforms = [];
    if (subschemaConfig.transforms != null) {
        schemaTransforms = schemaTransforms.concat(subschemaConfig.transforms);
    }
    if (transforms != null) {
        schemaTransforms = schemaTransforms.concat(transforms);
    }
    return applySchemaTransforms(schema, schemaTransforms);
}

var backcompatOptions = { commentDescriptions: true };
function typeFromAST(node) {
    switch (node.kind) {
        case graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].OBJECT_TYPE_DEFINITION:
            return makeObjectType(node);
        case graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].INTERFACE_TYPE_DEFINITION:
            return makeInterfaceType(node);
        case graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].ENUM_TYPE_DEFINITION:
            return makeEnumType(node);
        case graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].UNION_TYPE_DEFINITION:
            return makeUnionType(node);
        case graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].SCALAR_TYPE_DEFINITION:
            return makeScalarType(node);
        case graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].INPUT_OBJECT_TYPE_DEFINITION:
            return makeInputObjectType(node);
        case graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].DIRECTIVE_DEFINITION:
            return makeDirective(node);
        default:
            return null;
    }
}
function makeObjectType(node) {
    var config = {
        name: node.name.value,
        fields: function () { return makeFields(node.fields); },
        interfaces: function () {
            return node.interfaces.map(function (iface) {
                return createNamedStub(iface.name.value, 'interface');
            });
        },
        description: getDescription(node, backcompatOptions),
    };
    return new graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLObjectType"](config);
}
function makeInterfaceType(node) {
    var config = {
        name: node.name.value,
        fields: function () { return makeFields(node.fields); },
        interfaces: graphqlVersion() >= 15
            ? function () {
                return node.interfaces.map(function (iface) {
                    return createNamedStub(iface.name.value, 'interface');
                });
            }
            : undefined,
        description: getDescription(node, backcompatOptions),
        resolveType: function (parent) { return resolveFromParentTypename(parent); },
    };
    return new graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLInterfaceType"](config);
}
function makeEnumType(node) {
    var values = keyValMap(node.values, function (value) { return value.name.value; }, function (value) { return ({
        description: getDescription(value, backcompatOptions),
    }); });
    return new graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLEnumType"]({
        name: node.name.value,
        values: values,
        description: getDescription(node, backcompatOptions),
    });
}
function makeUnionType(node) {
    return new graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLUnionType"]({
        name: node.name.value,
        types: function () {
            return node.types.map(function (type) { return createNamedStub(type.name.value, 'object'); });
        },
        description: getDescription(node, backcompatOptions),
        resolveType: function (parent) { return resolveFromParentTypename(parent); },
    });
}
function makeScalarType(node) {
    return new graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLScalarType"]({
        name: node.name.value,
        description: getDescription(node, backcompatOptions),
        serialize: function () { return null; },
        // Note: validation calls the parse functions to determine if a
        // literal value is correct. Returning null would cause use of custom
        // scalars to always fail validation. Returning false causes them to
        // always pass validation.
        parseValue: function () { return false; },
        parseLiteral: function () { return false; },
    });
}
function makeInputObjectType(node) {
    return new graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLInputObjectType"]({
        name: node.name.value,
        fields: function () { return makeValues(node.fields); },
        description: getDescription(node, backcompatOptions),
    });
}
function makeFields(nodes) {
    return keyValMap(nodes, function (node) { return node.name.value; }, function (node) {
        var deprecatedDirective = node.directives.find(function (directive) { return directive.name.value === 'deprecated'; });
        var deprecationReason;
        if (deprecatedDirective != null) {
            var deprecatedArgument = deprecatedDirective.arguments.find(function (arg) { return arg.name.value === 'reason'; });
            deprecationReason = deprecatedArgument.value.value;
        }
        return {
            type: createStub(node.type, 'output'),
            args: makeValues(node.arguments),
            description: getDescription(node, backcompatOptions),
            deprecationReason: deprecationReason,
        };
    });
}
function makeValues(nodes) {
    return keyValMap(nodes, function (node) { return node.name.value; }, function (node) {
        var type = createStub(node.type, 'input');
        return {
            type: type,
            defaultValue: node.defaultValue,
            description: getDescription(node, backcompatOptions),
        };
    });
}
function makeDirective(node) {
    var locations = [];
    node.locations.forEach(function (location) {
        if (location.value in graphql__WEBPACK_IMPORTED_MODULE_3__["DirectiveLocation"]) {
            locations.push(location.value);
        }
    });
    return new graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLDirective"]({
        name: node.name.value,
        description: node.description != null ? node.description.value : null,
        args: makeValues(node.arguments),
        locations: locations,
    });
}
// graphql < v13 does not export getDescription
function getDescription(node, options) {
    if (node.description != null) {
        return node.description.value;
    }
    if (options.commentDescriptions) {
        var rawValue = getLeadingCommentBlock(node);
        if (rawValue !== undefined) {
            return dedentBlockStringValue("\n" + rawValue);
        }
    }
}
function getLeadingCommentBlock(node) {
    var loc = node.loc;
    if (!loc) {
        return;
    }
    var comments = [];
    var token = loc.startToken.prev;
    while (token != null &&
        token.kind === graphql__WEBPACK_IMPORTED_MODULE_3__["TokenKind"].COMMENT &&
        token.next != null &&
        token.prev != null &&
        token.line + 1 === token.next.line &&
        token.line !== token.prev.line) {
        var value = String(token.value);
        comments.push(value);
        token = token.prev;
    }
    return comments.length > 0 ? comments.reverse().join('\n') : undefined;
}
function dedentBlockStringValue(rawString) {
    // Expand a block string's raw value into independent lines.
    var lines = rawString.split(/\r\n|[\n\r]/g);
    // Remove common indentation from all lines but first.
    var commonIndent = getBlockStringIndentation(lines);
    if (commonIndent !== 0) {
        for (var i = 1; i < lines.length; i++) {
            lines[i] = lines[i].slice(commonIndent);
        }
    }
    // Remove leading and trailing blank lines.
    while (lines.length > 0 && isBlank(lines[0])) {
        lines.shift();
    }
    while (lines.length > 0 && isBlank(lines[lines.length - 1])) {
        lines.pop();
    }
    // Return a string of the lines joined with U+000A.
    return lines.join('\n');
}
/**
 * @internal
 */
function getBlockStringIndentation(lines) {
    var commonIndent = null;
    for (var i = 1; i < lines.length; i++) {
        var line = lines[i];
        var indent = leadingWhitespace(line);
        if (indent === line.length) {
            continue; // skip empty lines
        }
        if (commonIndent === null || indent < commonIndent) {
            commonIndent = indent;
            if (commonIndent === 0) {
                break;
            }
        }
    }
    return commonIndent === null ? 0 : commonIndent;
}
function leadingWhitespace(str) {
    var i = 0;
    while (i < str.length && (str[i] === ' ' || str[i] === '\t')) {
        i++;
    }
    return i;
}
function isBlank(str) {
    return leadingWhitespace(str) === str.length;
}

function concatInlineFragments(type, fragments) {
    var fragmentSelections = fragments.reduce(function (selections, fragment) {
        return selections.concat(fragment.selectionSet.selections);
    }, []);
    var deduplicatedFragmentSelection = deduplicateSelection(fragmentSelections);
    return {
        kind: graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].INLINE_FRAGMENT,
        typeCondition: {
            kind: graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].NAMED_TYPE,
            name: {
                kind: graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].NAME,
                value: type,
            },
        },
        selectionSet: {
            kind: graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].SELECTION_SET,
            selections: deduplicatedFragmentSelection,
        },
    };
}
function deduplicateSelection(nodes) {
    var selectionMap = nodes.reduce(function (map, node) {
        var _a, _b, _c;
        switch (node.kind) {
            case 'Field': {
                if (node.alias != null) {
                    if (node.alias.value in map) {
                        return map;
                    }
                    return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, map), (_a = {}, _a[node.alias.value] = node, _a));
                }
                if (node.name.value in map) {
                    return map;
                }
                return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, map), (_b = {}, _b[node.name.value] = node, _b));
            }
            case 'FragmentSpread': {
                if (node.name.value in map) {
                    return map;
                }
                return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, map), (_c = {}, _c[node.name.value] = node, _c));
            }
            case 'InlineFragment': {
                if (map.__fragment != null) {
                    var fragment = map.__fragment;
                    return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, map), { __fragment: concatInlineFragments(fragment.typeCondition.name.value, [fragment, node]) });
                }
                return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, map), { __fragment: node });
            }
            default: {
                return map;
            }
        }
    }, Object.create(null));
    var selection = Object.keys(selectionMap).reduce(function (selectionList, node) { return selectionList.concat(selectionMap[node]); }, []);
    return selection;
}
function parseFragmentToInlineFragment(definitions) {
    if (definitions.trim().startsWith('fragment')) {
        var document_1 = Object(graphql__WEBPACK_IMPORTED_MODULE_3__["parse"])(definitions);
        for (var _i = 0, _a = document_1.definitions; _i < _a.length; _i++) {
            var definition = _a[_i];
            if (definition.kind === graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].FRAGMENT_DEFINITION) {
                return {
                    kind: graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].INLINE_FRAGMENT,
                    typeCondition: definition.typeCondition,
                    selectionSet: definition.selectionSet,
                };
            }
        }
    }
    var query = Object(graphql__WEBPACK_IMPORTED_MODULE_3__["parse"])("{" + definitions + "}")
        .definitions[0];
    for (var _b = 0, _c = query.selectionSet.selections; _b < _c.length; _b++) {
        var selection = _c[_b];
        if (selection.kind === graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].INLINE_FRAGMENT) {
            return selection;
        }
    }
    throw new Error('Could not parse fragment');
}

function parseSelectionSet(selectionSet) {
    var query = Object(graphql__WEBPACK_IMPORTED_MODULE_3__["parse"])(selectionSet).definitions[0];
    return query.selectionSet;
}
function typeContainsSelectionSet(type, selectionSet) {
    var fields = type.getFields();
    for (var _i = 0, _a = selectionSet.selections; _i < _a.length; _i++) {
        var selection = _a[_i];
        if (selection.kind === graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].FIELD) {
            var field = fields[selection.name.value];
            if (field == null) {
                return false;
            }
            if (selection.selectionSet != null) {
                return typeContainsSelectionSet(Object(graphql__WEBPACK_IMPORTED_MODULE_3__["getNamedType"])(field.type), selection.selectionSet);
            }
        }
        else if (selection.kind === graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].INLINE_FRAGMENT) {
            var containsSelectionSet = typeContainsSelectionSet(type, selection.selectionSet);
            if (!containsSelectionSet) {
                return false;
            }
        }
    }
    return true;
}

function createMergeInfo(allSchemas, typeCandidates, mergeTypes) {
    return {
        delegate: function (operation, fieldName, args, context, info, transforms) {
            if (transforms === void 0) { transforms = []; }
            var schema = guessSchemaByRootField(allSchemas, operation, fieldName);
            var expandTransforms = new ExpandAbstractTypes(info.schema, schema);
            var fragmentTransform = new AddReplacementFragments(schema, info.mergeInfo.replacementFragments);
            return delegateToSchema({
                schema: schema,
                operation: operation,
                fieldName: fieldName,
                args: args,
                context: context,
                info: info,
                transforms: Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __spreadArrays */ "d"])(transforms, [expandTransforms, fragmentTransform]),
            });
        },
        delegateToSchema: function (options) {
            return delegateToSchema(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, options), { transforms: options.transforms }));
        },
        fragments: [],
        replacementSelectionSets: undefined,
        replacementFragments: undefined,
        mergedTypes: createMergedTypes(typeCandidates, mergeTypes),
    };
}
function createMergedTypes(typeCandidates, mergeTypes) {
    var mergedTypes = Object.create(null);
    Object.keys(typeCandidates).forEach(function (typeName) {
        if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isObjectType"])(typeCandidates[typeName][0].type)) {
            var mergedTypeCandidates = typeCandidates[typeName].filter(function (typeCandidate) {
                return typeCandidate.subschema != null &&
                    isSubschemaConfig(typeCandidate.subschema) &&
                    typeCandidate.subschema.merge != null &&
                    hasOwnProperty(typeCandidate.subschema.merge, typeName);
            });
            if (mergeTypes === true ||
                (typeof mergeTypes === 'function' &&
                    mergeTypes(typeName, typeCandidates[typeName])) ||
                (Array.isArray(mergeTypes) && mergeTypes.includes(typeName)) ||
                mergedTypeCandidates.length) {
                var subschemas_1 = [];
                var requiredSelections_1 = [
                    parseSelectionSet('{ __typename }').selections[0],
                ];
                var fields_1 = Object.create({});
                var typeMaps_1 = new Map();
                var selectionSets_1 = new Map();
                mergedTypeCandidates.forEach(function (typeCandidate) {
                    var subschemaConfig = typeCandidate.subschema;
                    var transformedSubschema = typeCandidate.transformedSubschema;
                    typeMaps_1.set(subschemaConfig, transformedSubschema.getTypeMap());
                    var type = transformedSubschema.getType(typeName);
                    var fieldMap = type.getFields();
                    Object.keys(fieldMap).forEach(function (fieldName) {
                        if (!(fieldName in fields_1)) {
                            fields_1[fieldName] = [];
                        }
                        fields_1[fieldName].push(subschemaConfig);
                    });
                    var mergedTypeConfig = subschemaConfig.merge[typeName];
                    if (mergedTypeConfig.selectionSet) {
                        var selectionSet = parseSelectionSet(mergedTypeConfig.selectionSet);
                        requiredSelections_1 = requiredSelections_1.concat(selectionSet.selections);
                        selectionSets_1.set(subschemaConfig, selectionSet);
                    }
                    if (!mergedTypeConfig.resolve) {
                        mergedTypeConfig.resolve = function (originalResult, context, info, subschema, selectionSet) {
                            return delegateToSchema({
                                schema: subschema,
                                operation: 'query',
                                fieldName: mergedTypeConfig.fieldName,
                                args: mergedTypeConfig.args(originalResult),
                                selectionSet: selectionSet,
                                context: context,
                                info: info,
                                skipTypeMerging: true,
                            });
                        };
                    }
                    subschemas_1.push(subschemaConfig);
                });
                mergedTypes[typeName] = {
                    subschemas: subschemas_1,
                    typeMaps: typeMaps_1,
                    selectionSets: selectionSets_1,
                    containsSelectionSet: new Map(),
                    uniqueFields: Object.create({}),
                    nonUniqueFields: Object.create({}),
                };
                subschemas_1.forEach(function (subschema) {
                    var type = typeMaps_1.get(subschema)[typeName];
                    var subschemaMap = new Map();
                    subschemas_1
                        .filter(function (s) { return s !== subschema; })
                        .forEach(function (s) {
                        var selectionSet = selectionSets_1.get(s);
                        if (selectionSet != null &&
                            typeContainsSelectionSet(type, selectionSet)) {
                            subschemaMap.set(selectionSet, true);
                        }
                    });
                    mergedTypes[typeName].containsSelectionSet.set(subschema, subschemaMap);
                });
                Object.keys(fields_1).forEach(function (fieldName) {
                    var supportedBySubschemas = fields_1[fieldName];
                    if (supportedBySubschemas.length === 1) {
                        mergedTypes[typeName].uniqueFields[fieldName] =
                            supportedBySubschemas[0];
                    }
                    else {
                        mergedTypes[typeName].nonUniqueFields[fieldName] = supportedBySubschemas;
                    }
                });
                mergedTypes[typeName].selectionSet = {
                    kind: graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].SELECTION_SET,
                    selections: requiredSelections_1,
                };
            }
        }
    });
    return mergedTypes;
}
function completeMergeInfo(mergeInfo, resolvers) {
    var replacementSelectionSets = Object.create(null);
    Object.keys(resolvers).forEach(function (typeName) {
        var type = resolvers[typeName];
        if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isScalarType"])(type)) {
            return;
        }
        Object.keys(type).forEach(function (fieldName) {
            var field = type[fieldName];
            if (field.selectionSet) {
                var selectionSet = parseSelectionSet(field.selectionSet);
                if (!(typeName in replacementSelectionSets)) {
                    replacementSelectionSets[typeName] = Object.create(null);
                }
                var typeReplacementSelectionSets = replacementSelectionSets[typeName];
                if (!(fieldName in typeReplacementSelectionSets)) {
                    typeReplacementSelectionSets[fieldName] = {
                        kind: graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].SELECTION_SET,
                        selections: [],
                    };
                }
                typeReplacementSelectionSets[fieldName].selections = typeReplacementSelectionSets[fieldName].selections.concat(selectionSet.selections);
            }
            if (field.fragment) {
                mergeInfo.fragments.push({
                    field: fieldName,
                    fragment: field.fragment,
                });
            }
        });
    });
    var mapping = Object.create(null);
    mergeInfo.fragments.forEach(function (_a) {
        var field = _a.field, fragment = _a.fragment;
        var parsedFragment = parseFragmentToInlineFragment(fragment);
        var actualTypeName = parsedFragment.typeCondition.name.value;
        if (!(actualTypeName in mapping)) {
            mapping[actualTypeName] = Object.create(null);
        }
        var typeMapping = mapping[actualTypeName];
        if (!(field in typeMapping)) {
            typeMapping[field] = [];
        }
        typeMapping[field].push(parsedFragment);
    });
    var replacementFragments = Object.create(null);
    Object.keys(mapping).forEach(function (typeName) {
        Object.keys(mapping[typeName]).forEach(function (field) {
            if (!(typeName in replacementFragments)) {
                replacementFragments[typeName] = Object.create(null);
            }
            var typeReplacementFragments = replacementFragments[typeName];
            typeReplacementFragments[field] = concatInlineFragments(typeName, mapping[typeName][field]);
        });
    });
    mergeInfo.replacementSelectionSets = replacementSelectionSets;
    mergeInfo.replacementFragments = replacementFragments;
    return mergeInfo;
}
function operationToRootType(operation, schema) {
    if (operation === 'subscription') {
        return schema.getSubscriptionType();
    }
    else if (operation === 'mutation') {
        return schema.getMutationType();
    }
    return schema.getQueryType();
}
function guessSchemaByRootField(schemas, operation, fieldName) {
    for (var _i = 0, schemas_1 = schemas; _i < schemas_1.length; _i++) {
        var schema = schemas_1[_i];
        var rootObject = operationToRootType(operation, schema);
        if (rootObject != null) {
            var fields = rootObject.getFields();
            if (fieldName in fields) {
                return schema;
            }
        }
    }
    throw new Error("Could not find subschema with field `" + operation + "." + fieldName + "`");
}

function mergeSchemas(_a) {
    var _b = _a.subschemas, subschemas = _b === void 0 ? [] : _b, _c = _a.types, types = _c === void 0 ? [] : _c, typeDefs = _a.typeDefs, _d = _a.schemas, schemaLikeObjects = _d === void 0 ? [] : _d, onTypeConflict = _a.onTypeConflict, _e = _a.resolvers, resolvers = _e === void 0 ? {} : _e, schemaDirectives = _a.schemaDirectives, inheritResolversFromInterfaces = _a.inheritResolversFromInterfaces, _f = _a.mergeTypes, mergeTypes = _f === void 0 ? false : _f, mergeDirectives = _a.mergeDirectives, _g = _a.queryTypeName, queryTypeName = _g === void 0 ? 'Query' : _g, _h = _a.mutationTypeName, mutationTypeName = _h === void 0 ? 'Mutation' : _h, _j = _a.subscriptionTypeName, subscriptionTypeName = _j === void 0 ? 'Subscription' : _j;
    var allSchemas = [];
    var typeCandidates = Object.create(null);
    var typeMap = Object.create(null);
    var extensions = [];
    var directives = [];
    var schemas = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __spreadArrays */ "d"])(subschemas);
    if (typeDefs) {
        schemas.push(typeDefs);
    }
    if (types != null) {
        schemas.push(types);
    }
    schemas = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __spreadArrays */ "d"])(schemas, schemaLikeObjects);
    schemas.forEach(function (schemaLikeObject) {
        var _a;
        if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isSchema"])(schemaLikeObject) || isSubschemaConfig(schemaLikeObject)) {
            var schema_1 = wrapSchema(schemaLikeObject);
            allSchemas.push(schema_1);
            var operationTypes_1 = (_a = {},
                _a[queryTypeName] = schema_1.getQueryType(),
                _a[mutationTypeName] = schema_1.getMutationType(),
                _a[subscriptionTypeName] = schema_1.getSubscriptionType(),
                _a);
            Object.keys(operationTypes_1).forEach(function (typeName) {
                if (operationTypes_1[typeName] != null) {
                    addTypeCandidate(typeCandidates, typeName, {
                        schema: schema_1,
                        type: operationTypes_1[typeName],
                        subschema: schemaLikeObject,
                        transformedSubschema: schema_1,
                    });
                }
            });
            if (mergeDirectives) {
                var directiveInstances = schema_1.getDirectives();
                directiveInstances.forEach(function (directive) {
                    directives.push(directive);
                });
            }
            var originalTypeMap_1 = schema_1.getTypeMap();
            Object.keys(originalTypeMap_1).forEach(function (typeName) {
                var type = originalTypeMap_1[typeName];
                if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isNamedType"])(type) &&
                    Object(graphql__WEBPACK_IMPORTED_MODULE_3__["getNamedType"])(type).name.slice(0, 2) !== '__' &&
                    type !== operationTypes_1.Query &&
                    type !== operationTypes_1.Mutation &&
                    type !== operationTypes_1.Subscription) {
                    addTypeCandidate(typeCandidates, type.name, {
                        schema: schema_1,
                        type: type,
                        subschema: schemaLikeObject,
                        transformedSubschema: schema_1,
                    });
                }
            });
        }
        else if (typeof schemaLikeObject === 'string' ||
            (schemaLikeObject != null &&
                schemaLikeObject.kind === graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].DOCUMENT)) {
            var parsedSchemaDocument = typeof schemaLikeObject === 'string'
                ? Object(graphql__WEBPACK_IMPORTED_MODULE_3__["parse"])(schemaLikeObject)
                : schemaLikeObject;
            parsedSchemaDocument.definitions.forEach(function (def) {
                var type = typeFromAST(def);
                if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isDirective"])(type) && mergeDirectives) {
                    directives.push(type);
                }
                else if (type != null && !Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isDirective"])(type)) {
                    addTypeCandidate(typeCandidates, type.name, {
                        type: type,
                    });
                }
            });
            var extensionsDocument = extractExtensionDefinitions(parsedSchemaDocument);
            if (extensionsDocument.definitions.length > 0) {
                extensions.push(extensionsDocument);
            }
        }
        else if (Array.isArray(schemaLikeObject)) {
            schemaLikeObject.forEach(function (type) {
                addTypeCandidate(typeCandidates, type.name, {
                    type: type,
                });
            });
        }
        else {
            throw new Error('Invalid schema passed');
        }
    });
    var mergeInfo = createMergeInfo(allSchemas, typeCandidates, mergeTypes);
    var finalResolvers;
    if (typeof resolvers === 'function') {
        finalResolvers = resolvers(mergeInfo);
    }
    else if (Array.isArray(resolvers)) {
        finalResolvers = resolvers.reduce(function (left, right) {
            return mergeDeep(left, typeof right === 'function' ? right(mergeInfo) : right);
        }, {});
        if (Array.isArray(resolvers)) {
            finalResolvers = resolvers.reduce(mergeDeep, {});
        }
    }
    else {
        finalResolvers = resolvers;
    }
    if (finalResolvers == null) {
        finalResolvers = {};
    }
    mergeInfo = completeMergeInfo(mergeInfo, finalResolvers);
    Object.keys(typeCandidates).forEach(function (typeName) {
        if (typeName === queryTypeName ||
            typeName === mutationTypeName ||
            typeName === subscriptionTypeName ||
            (mergeTypes === true &&
                !Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isScalarType"])(typeCandidates[typeName][0].type)) ||
            (typeof mergeTypes === 'function' &&
                mergeTypes(typeName, typeCandidates[typeName])) ||
            (Array.isArray(mergeTypes) && mergeTypes.includes(typeName)) ||
            typeName in mergeInfo.mergedTypes) {
            typeMap[typeName] = merge(typeName, typeCandidates[typeName]);
        }
        else {
            var candidateSelector = onTypeConflict != null
                ? onTypeConflictToCandidateSelector(onTypeConflict)
                : function (cands) { return cands[cands.length - 1]; };
            typeMap[typeName] = candidateSelector(typeCandidates[typeName]).type;
        }
    });
    healTypes(typeMap, directives, { skipPruning: true });
    var mergedSchema = new graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLSchema"]({
        query: typeMap[queryTypeName],
        mutation: typeMap[mutationTypeName],
        subscription: typeMap[subscriptionTypeName],
        types: Object.keys(typeMap).map(function (key) { return typeMap[key]; }),
        directives: directives.length
            ? directives.map(function (directive) { return cloneDirective(directive); })
            : undefined,
    });
    extensions.forEach(function (extension) {
        mergedSchema = extendSchema(mergedSchema, extension, {
            commentDescriptions: true,
        });
    });
    addResolversToSchema({
        schema: mergedSchema,
        resolvers: finalResolvers,
        inheritResolversFromInterfaces: inheritResolversFromInterfaces,
    });
    forEachField(mergedSchema, function (field) {
        if (field.resolve != null) {
            var fieldResolver_1 = field.resolve;
            field.resolve = function (parent, args, context, info) {
                var newInfo = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, info), { mergeInfo: mergeInfo });
                return fieldResolver_1(parent, args, context, newInfo);
            };
        }
        if (field.subscribe != null) {
            var fieldResolver_2 = field.subscribe;
            field.subscribe = function (parent, args, context, info) {
                var newInfo = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, info), { mergeInfo: mergeInfo });
                return fieldResolver_2(parent, args, context, newInfo);
            };
        }
    });
    if (schemaDirectives != null) {
        SchemaDirectiveVisitor.visitSchemaDirectives(mergedSchema, schemaDirectives);
    }
    return mergedSchema;
}
function addTypeCandidate(typeCandidates, name, typeCandidate) {
    if (!(name in typeCandidates)) {
        typeCandidates[name] = [];
    }
    typeCandidates[name].push(typeCandidate);
}
function onTypeConflictToCandidateSelector(onTypeConflict) {
    return function (cands) {
        return cands.reduce(function (prev, next) {
            var type = onTypeConflict(prev.type, next.type, {
                left: {
                    schema: prev.schema,
                },
                right: {
                    schema: next.schema,
                },
            });
            if (prev.type === type) {
                return prev;
            }
            else if (next.type === type) {
                return next;
            }
            return {
                schemaName: 'unknown',
                type: type,
            };
        });
    };
}
function merge(typeName, candidates) {
    var initialCandidateType = candidates[0].type;
    if (candidates.some(function (candidate) {
        return candidate.type.constructor !== initialCandidateType.constructor;
    })) {
        throw new Error("Cannot merge different type categories into common type " + typeName + ".");
    }
    if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isObjectType"])(initialCandidateType)) {
        return new graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLObjectType"]({
            name: typeName,
            fields: candidates.reduce(function (acc, candidate) { return (Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, acc), toConfig(candidate.type).fields)); }, {}),
            interfaces: candidates.reduce(function (acc, candidate) {
                var interfaces = toConfig(candidate.type).interfaces;
                return interfaces != null ? acc.concat(interfaces) : acc;
            }, []),
        });
    }
    else if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isInterfaceType"])(initialCandidateType)) {
        var config = {
            name: typeName,
            fields: candidates.reduce(function (acc, candidate) { return (Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, acc), toConfig(candidate.type).fields)); }, {}),
            interfaces: graphqlVersion() >= 15
                ? candidates.reduce(function (acc, candidate) {
                    var interfaces = toConfig(candidate.type).interfaces;
                    return interfaces != null ? acc.concat(interfaces) : acc;
                }, [])
                : undefined,
        };
        return new graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLInterfaceType"](config);
    }
    else if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isUnionType"])(initialCandidateType)) {
        return new graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLUnionType"]({
            name: typeName,
            types: candidates.reduce(function (acc, candidate) { return acc.concat(toConfig(candidate.type).types); }, []),
        });
    }
    else if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isEnumType"])(initialCandidateType)) {
        return new graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLEnumType"]({
            name: typeName,
            values: candidates.reduce(function (acc, candidate) { return (Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, acc), toConfig(candidate.type).values)); }, {}),
        });
    }
    else if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isScalarType"])(initialCandidateType)) {
        throw new Error("Cannot merge type " + typeName + ". Merging not supported for GraphQLScalarType.");
    }
    else {
        // not reachable.
        throw new Error("Type " + typeName + " has unknown GraphQL type.");
    }
}

// This function is deprecated in favor of wrapSchema as the name is misleading.
// transformSchema does not just "transform" a schema, it wraps a schema with transforms
// using a round of delegation.
// The applySchemaTransforms function actually "transforms" the schema and is used during wrapping.
function transformSchema(subschemaOrSubschemaConfig, transforms) {
    var schema = wrapSchema(subschemaOrSubschemaConfig, transforms);
    schema.transforms = transforms.slice().reverse();
    return schema;
}

var RenameTypes = /** @class */ (function () {
    function RenameTypes(renamer, options) {
        this.renamer = renamer;
        this.map = Object.create(null);
        this.reverseMap = Object.create(null);
        var _a = options != null ? options : {}, _b = _a.renameBuiltins, renameBuiltins = _b === void 0 ? false : _b, _c = _a.renameScalars, renameScalars = _c === void 0 ? true : _c;
        this.renameBuiltins = renameBuiltins;
        this.renameScalars = renameScalars;
    }
    RenameTypes.prototype.transformSchema = function (originalSchema) {
        var _a;
        var _this = this;
        return mapSchema(originalSchema, (_a = {},
            _a[MapperKind.TYPE] = function (type) {
                if (isSpecifiedScalarType(type) && !_this.renameBuiltins) {
                    return undefined;
                }
                if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isScalarType"])(type) && !_this.renameScalars) {
                    return undefined;
                }
                var oldName = type.name;
                var newName = _this.renamer(oldName);
                if (newName !== undefined && newName !== oldName) {
                    _this.map[oldName] = newName;
                    _this.reverseMap[newName] = oldName;
                    var newConfig = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, toConfig(type)), { name: newName });
                    if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isObjectType"])(type)) {
                        return new graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLObjectType"](newConfig);
                    }
                    else if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isInterfaceType"])(type)) {
                        return new graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLInterfaceType"](newConfig);
                    }
                    else if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isUnionType"])(type)) {
                        return new graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLUnionType"](newConfig);
                    }
                    else if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isInputObjectType"])(type)) {
                        return new graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLInputObjectType"](newConfig);
                    }
                    else if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isEnumType"])(type)) {
                        return new graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLEnumType"](newConfig);
                    }
                    else if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isScalarType"])(type)) {
                        return new graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLScalarType"](newConfig);
                    }
                    throw new Error("Unknown type " + type + ".");
                }
            },
            _a[MapperKind.ROOT_OBJECT] = function () {
                return undefined;
            },
            _a));
    };
    RenameTypes.prototype.transformRequest = function (originalRequest) {
        var _a;
        var _this = this;
        var newDocument = Object(graphql__WEBPACK_IMPORTED_MODULE_3__["visit"])(originalRequest.document, (_a = {},
            _a[graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].NAMED_TYPE] = function (node) {
                var name = node.name.value;
                if (name in _this.reverseMap) {
                    return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, node), { name: {
                            kind: graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].NAME,
                            value: _this.reverseMap[name],
                        } });
                }
            },
            _a));
        return {
            document: newDocument,
            variables: originalRequest.variables,
        };
    };
    RenameTypes.prototype.transformResult = function (result) {
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, result), { data: this.transformData(result.data) });
    };
    RenameTypes.prototype.transformData = function (data) {
        var _this = this;
        if (data == null) {
            return data;
        }
        else if (Array.isArray(data)) {
            return data.map(function (value) { return _this.transformData(value); });
        }
        else if (typeof data === 'object') {
            return this.transformObject(data);
        }
        return data;
    };
    RenameTypes.prototype.transformObject = function (object) {
        var _this = this;
        Object.keys(object).forEach(function (key) {
            var value = object[key];
            if (key === '__typename') {
                if (value in _this.map) {
                    object[key] = _this.map[value];
                }
            }
            else {
                object[key] = _this.transformData(value);
            }
        });
        return object;
    };
    return RenameTypes;
}());

var FilterTypes = /** @class */ (function () {
    function FilterTypes(filter) {
        this.filter = filter;
    }
    FilterTypes.prototype.transformSchema = function (schema) {
        var _a;
        var _this = this;
        return mapSchema(schema, (_a = {},
            _a[MapperKind.TYPE] = function (type) {
                if (_this.filter(type)) {
                    return undefined;
                }
                return null;
            },
            _a));
    };
    return FilterTypes;
}());

var RenameRootTypes = /** @class */ (function () {
    function RenameRootTypes(renamer) {
        this.renamer = renamer;
        this.map = Object.create(null);
        this.reverseMap = Object.create(null);
    }
    RenameRootTypes.prototype.transformSchema = function (originalSchema) {
        var _a;
        var _this = this;
        return mapSchema(originalSchema, (_a = {},
            _a[MapperKind.ROOT_OBJECT] = function (type) {
                var oldName = type.name;
                var newName = _this.renamer(oldName);
                if (newName !== undefined && newName !== oldName) {
                    _this.map[oldName] = newName;
                    _this.reverseMap[newName] = oldName;
                    return new graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLObjectType"](Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, toConfig(type)), { name: newName }));
                }
            },
            _a));
    };
    RenameRootTypes.prototype.transformRequest = function (originalRequest) {
        var _a;
        var _this = this;
        var newDocument = Object(graphql__WEBPACK_IMPORTED_MODULE_3__["visit"])(originalRequest.document, (_a = {},
            _a[graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].NAMED_TYPE] = function (node) {
                var name = node.name.value;
                if (name in _this.reverseMap) {
                    return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, node), { name: {
                            kind: graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].NAME,
                            value: _this.reverseMap[name],
                        } });
                }
            },
            _a));
        return {
            document: newDocument,
            variables: originalRequest.variables,
        };
    };
    RenameRootTypes.prototype.transformResult = function (result) {
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, result), { data: this.transformData(result.data) });
    };
    RenameRootTypes.prototype.transformData = function (data) {
        var _this = this;
        if (data == null) {
            return data;
        }
        else if (Array.isArray(data)) {
            return data.map(function (value) { return _this.transformData(value); });
        }
        else if (typeof data === 'object') {
            return this.transformObject(data);
        }
        return data;
    };
    RenameRootTypes.prototype.transformObject = function (object) {
        var _this = this;
        Object.keys(object).forEach(function (key) {
            var value = object[key];
            if (key === '__typename') {
                if (value in _this.map) {
                    object[key] = _this.map[value];
                }
            }
            else {
                object[key] = _this.transformData(value);
            }
        });
        return object;
    };
    return RenameRootTypes;
}());

function isEmptyObject(obj) {
    if (obj == null) {
        return true;
    }
    return Object.keys(obj).length === 0;
}

var TransformCompositeFields = /** @class */ (function () {
    function TransformCompositeFields(fieldTransformer, fieldNodeTransformer) {
        this.fieldTransformer = fieldTransformer;
        this.fieldNodeTransformer = fieldNodeTransformer;
        this.mapping = {};
    }
    TransformCompositeFields.prototype.transformSchema = function (originalSchema) {
        var _a;
        var _this = this;
        this.transformedSchema = mapSchema(originalSchema, (_a = {},
            _a[MapperKind.OBJECT_TYPE] = function (type) {
                return _this.transformFields(type, _this.fieldTransformer);
            },
            _a[MapperKind.INTERFACE_TYPE] = function (type) {
                return _this.transformFields(type, _this.fieldTransformer);
            },
            _a));
        return this.transformedSchema;
    };
    TransformCompositeFields.prototype.transformRequest = function (originalRequest) {
        var fragments = Object.create(null);
        originalRequest.document.definitions
            .filter(function (def) { return def.kind === graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].FRAGMENT_DEFINITION; })
            .forEach(function (def) {
            fragments[def.name.value] = def;
        });
        var document = this.transformDocument(originalRequest.document, this.mapping, this.fieldNodeTransformer, fragments);
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, originalRequest), { document: document });
    };
    TransformCompositeFields.prototype.transformFields = function (type, fieldTransformer) {
        var _this = this;
        var typeConfig = toConfig(type);
        var fields = type.getFields();
        var newFields = {};
        Object.keys(fields).forEach(function (fieldName) {
            var field = fields[fieldName];
            var transformedField = fieldTransformer(type.name, fieldName, field);
            if (typeof transformedField === 'undefined') {
                newFields[fieldName] = typeConfig.fields[fieldName];
            }
            else if (transformedField !== null) {
                var newName = transformedField.name;
                if (newName) {
                    newFields[newName] =
                        transformedField.field != null
                            ? transformedField.field
                            : typeConfig.fields[fieldName];
                    if (newName !== fieldName) {
                        var typeName = type.name;
                        if (!(typeName in _this.mapping)) {
                            _this.mapping[typeName] = {};
                        }
                        _this.mapping[typeName][newName] = fieldName;
                    }
                }
                else {
                    newFields[fieldName] = transformedField;
                }
            }
        });
        if (isEmptyObject(newFields)) {
            return null;
        }
        if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isObjectType"])(type)) {
            return new graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLObjectType"](Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, toConfig(type)), { fields: newFields }));
        }
        else if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isInterfaceType"])(type)) {
            return new graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLInterfaceType"](Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, toConfig(type)), { fields: newFields }));
        }
    };
    TransformCompositeFields.prototype.transformDocument = function (document, mapping, fieldNodeTransformer, fragments) {
        var _a;
        if (fragments === void 0) { fragments = {}; }
        var typeInfo = new graphql__WEBPACK_IMPORTED_MODULE_3__["TypeInfo"](this.transformedSchema);
        var newDocument = Object(graphql__WEBPACK_IMPORTED_MODULE_3__["visit"])(document, Object(graphql__WEBPACK_IMPORTED_MODULE_3__["visitWithTypeInfo"])(typeInfo, {
            leave: (_a = {},
                _a[graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].SELECTION_SET] = function (node) {
                    var parentType = typeInfo.getParentType();
                    if (parentType != null) {
                        var parentTypeName_1 = parentType.name;
                        var newSelections_1 = [];
                        node.selections.forEach(function (selection) {
                            if (selection.kind !== graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].FIELD) {
                                newSelections_1.push(selection);
                                return;
                            }
                            var newName = selection.name.value;
                            var transformedSelection = fieldNodeTransformer != null
                                ? fieldNodeTransformer(parentTypeName_1, newName, selection, fragments)
                                : selection;
                            if (Array.isArray(transformedSelection)) {
                                newSelections_1 = newSelections_1.concat(transformedSelection);
                                return;
                            }
                            if (transformedSelection.kind !== graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].FIELD) {
                                newSelections_1.push(transformedSelection);
                                return;
                            }
                            var typeMapping = mapping[parentTypeName_1];
                            if (typeMapping == null) {
                                newSelections_1.push(transformedSelection);
                                return;
                            }
                            var oldName = mapping[parentTypeName_1][newName];
                            if (oldName == null) {
                                newSelections_1.push(transformedSelection);
                                return;
                            }
                            newSelections_1.push(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, transformedSelection), { name: {
                                    kind: graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].NAME,
                                    value: oldName,
                                }, alias: {
                                    kind: graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].NAME,
                                    value: newName,
                                } }));
                        });
                        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, node), { selections: newSelections_1 });
                    }
                },
                _a),
        }));
        return newDocument;
    };
    return TransformCompositeFields;
}());

var TransformObjectFields = /** @class */ (function () {
    function TransformObjectFields(objectFieldTransformer, fieldNodeTransformer) {
        this.objectFieldTransformer = objectFieldTransformer;
        this.fieldNodeTransformer = fieldNodeTransformer;
    }
    TransformObjectFields.prototype.transformSchema = function (originalSchema) {
        var _this = this;
        var compositeToObjectFieldTransformer = function (typeName, fieldName, field) {
            if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isObjectType"])(originalSchema.getType(typeName))) {
                return _this.objectFieldTransformer(typeName, fieldName, field);
            }
            return undefined;
        };
        this.transformer = new TransformCompositeFields(compositeToObjectFieldTransformer, this.fieldNodeTransformer);
        return this.transformer.transformSchema(originalSchema);
    };
    TransformObjectFields.prototype.transformRequest = function (originalRequest) {
        return this.transformer.transformRequest(originalRequest);
    };
    return TransformObjectFields;
}());

var TransformRootFields = /** @class */ (function () {
    function TransformRootFields(rootFieldTransformer, fieldNodeTransformer) {
        var rootToObjectFieldTransformer = function (typeName, fieldName, field) {
            if (typeName === 'Query' ||
                typeName === 'Mutation' ||
                typeName === 'Subscription') {
                return rootFieldTransformer(typeName, fieldName, field);
            }
            return undefined;
        };
        this.transformer = new TransformObjectFields(rootToObjectFieldTransformer, fieldNodeTransformer);
    }
    TransformRootFields.prototype.transformSchema = function (originalSchema) {
        return this.transformer.transformSchema(originalSchema);
    };
    TransformRootFields.prototype.transformRequest = function (originalRequest) {
        return this.transformer.transformRequest(originalRequest);
    };
    return TransformRootFields;
}());

var RenameRootFields = /** @class */ (function () {
    function RenameRootFields(renamer) {
        this.transformer = new TransformRootFields(function (operation, fieldName, field) { return ({
            name: renamer(operation, fieldName, field),
        }); });
    }
    RenameRootFields.prototype.transformSchema = function (originalSchema) {
        return this.transformer.transformSchema(originalSchema);
    };
    RenameRootFields.prototype.transformRequest = function (originalRequest) {
        return this.transformer.transformRequest(originalRequest);
    };
    return RenameRootFields;
}());

var FilterRootFields = /** @class */ (function () {
    function FilterRootFields(filter) {
        this.transformer = new TransformRootFields(function (operation, fieldName, field) {
            if (filter(operation, fieldName, field)) {
                return undefined;
            }
            return null;
        });
    }
    FilterRootFields.prototype.transformSchema = function (originalSchema) {
        return this.transformer.transformSchema(originalSchema);
    };
    return FilterRootFields;
}());

var RenameObjectFields = /** @class */ (function () {
    function RenameObjectFields(renamer) {
        this.transformer = new TransformObjectFields(function (typeName, fieldName, field) { return ({
            name: renamer(typeName, fieldName, field),
        }); });
    }
    RenameObjectFields.prototype.transformSchema = function (originalSchema) {
        return this.transformer.transformSchema(originalSchema);
    };
    RenameObjectFields.prototype.transformRequest = function (originalRequest) {
        return this.transformer.transformRequest(originalRequest);
    };
    return RenameObjectFields;
}());

var FilterObjectFields = /** @class */ (function () {
    function FilterObjectFields(filter) {
        this.transformer = new TransformObjectFields(function (typeName, fieldName, field) {
            return filter(typeName, fieldName, field) ? undefined : null;
        });
    }
    FilterObjectFields.prototype.transformSchema = function (originalSchema) {
        return this.transformer.transformSchema(originalSchema);
    };
    return FilterObjectFields;
}());

var TransformInterfaceFields = /** @class */ (function () {
    function TransformInterfaceFields(interfaceFieldTransformer, fieldNodeTransformer) {
        this.interfaceFieldTransformer = interfaceFieldTransformer;
        this.fieldNodeTransformer = fieldNodeTransformer;
    }
    TransformInterfaceFields.prototype.transformSchema = function (originalSchema) {
        var _this = this;
        var compositeToObjectFieldTransformer = function (typeName, fieldName, field) {
            if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isInterfaceType"])(originalSchema.getType(typeName))) {
                return _this.interfaceFieldTransformer(typeName, fieldName, field);
            }
            return undefined;
        };
        this.transformer = new TransformCompositeFields(compositeToObjectFieldTransformer, this.fieldNodeTransformer);
        return this.transformer.transformSchema(originalSchema);
    };
    TransformInterfaceFields.prototype.transformRequest = function (originalRequest) {
        return this.transformer.transformRequest(originalRequest);
    };
    return TransformInterfaceFields;
}());

var RenameInterfaceFields = /** @class */ (function () {
    function RenameInterfaceFields(renamer) {
        this.transformer = new TransformInterfaceFields(function (typeName, fieldName, field) { return ({
            name: renamer(typeName, fieldName, field),
        }); });
    }
    RenameInterfaceFields.prototype.transformSchema = function (originalSchema) {
        return this.transformer.transformSchema(originalSchema);
    };
    RenameInterfaceFields.prototype.transformRequest = function (originalRequest) {
        return this.transformer.transformRequest(originalRequest);
    };
    return RenameInterfaceFields;
}());

var FilterInterfaceFields = /** @class */ (function () {
    function FilterInterfaceFields(filter) {
        this.transformer = new TransformInterfaceFields(function (typeName, fieldName, field) {
            return filter(typeName, fieldName, field) ? undefined : null;
        });
    }
    FilterInterfaceFields.prototype.transformSchema = function (originalSchema) {
        return this.transformer.transformSchema(originalSchema);
    };
    return FilterInterfaceFields;
}());

var TransformQuery = /** @class */ (function () {
    function TransformQuery(_a) {
        var path = _a.path, queryTransformer = _a.queryTransformer, _b = _a.resultTransformer, resultTransformer = _b === void 0 ? function (result) { return result; } : _b, _c = _a.errorPathTransformer, errorPathTransformer = _c === void 0 ? function (errorPath) { return [].concat(errorPath); } : _c, _d = _a.fragments, fragments = _d === void 0 ? {} : _d;
        this.path = path;
        this.queryTransformer = queryTransformer;
        this.resultTransformer = resultTransformer;
        this.errorPathTransformer = errorPathTransformer;
        this.fragments = fragments;
    }
    TransformQuery.prototype.transformRequest = function (originalRequest) {
        var _a;
        var _this = this;
        var document = originalRequest.document;
        var pathLength = this.path.length;
        var index = 0;
        var newDocument = Object(graphql__WEBPACK_IMPORTED_MODULE_3__["visit"])(document, (_a = {},
            _a[graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].FIELD] = {
                enter: function (node) {
                    if (index === pathLength || node.name.value !== _this.path[index]) {
                        return false;
                    }
                    index++;
                    if (index === pathLength) {
                        var selectionSet = _this.queryTransformer(node.selectionSet, _this.fragments);
                        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, node), { selectionSet: selectionSet });
                    }
                },
                leave: function () {
                    index--;
                },
            },
            _a));
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, originalRequest), { document: newDocument });
    };
    TransformQuery.prototype.transformResult = function (originalResult) {
        var data = this.transformData(originalResult.data);
        var errors = originalResult.errors;
        return {
            data: data,
            errors: errors != null ? this.transformErrors(errors) : undefined,
        };
    };
    TransformQuery.prototype.transformData = function (data) {
        var leafIndex = this.path.length - 1;
        var index = 0;
        var newData = data;
        if (newData) {
            var next = this.path[index];
            while (index < leafIndex) {
                if (data[next]) {
                    newData = newData[next];
                }
                else {
                    break;
                }
                index++;
                next = this.path[index];
            }
            newData[next] = this.resultTransformer(newData[next]);
        }
        return newData;
    };
    TransformQuery.prototype.transformErrors = function (errors) {
        var _this = this;
        return errors.map(function (error) {
            var path = error.path;
            var match = true;
            var index = 0;
            while (index < _this.path.length) {
                if (path[index] !== _this.path[index]) {
                    match = false;
                    break;
                }
                index++;
            }
            var newPath = match
                ? path
                    .slice(0, index)
                    .concat(_this.errorPathTransformer(path.slice(index)))
                : path;
            return new graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLError"](error.message, error.nodes, error.source, error.positions, newPath, error.originalError, error.extensions);
        });
    };
    return TransformQuery;
}());

var MapFields = /** @class */ (function () {
    function MapFields(fieldNodeTransformerMap) {
        this.transformer = new TransformObjectFields(function (_typeName, _fieldName, field) { return toConfig(field); }, function (typeName, fieldName, fieldNode, fragments) {
            var typeTransformers = fieldNodeTransformerMap[typeName];
            if (typeTransformers == null) {
                return fieldNode;
            }
            var fieldNodeTransformer = typeTransformers[fieldName];
            if (fieldNodeTransformer == null) {
                return fieldNode;
            }
            return fieldNodeTransformer(fieldNode, fragments);
        });
    }
    MapFields.prototype.transformSchema = function (schema) {
        return this.transformer.transformSchema(schema);
    };
    MapFields.prototype.transformRequest = function (request) {
        return this.transformer.transformRequest(request);
    };
    return MapFields;
}());

var ExtendSchema = /** @class */ (function () {
    function ExtendSchema(_a) {
        var typeDefs = _a.typeDefs, _b = _a.resolvers, resolvers = _b === void 0 ? {} : _b, defaultFieldResolver = _a.defaultFieldResolver, fieldNodeTransformerMap = _a.fieldNodeTransformerMap;
        this.typeDefs = typeDefs;
        this.resolvers = resolvers;
        this.defaultFieldResolver =
            defaultFieldResolver != null
                ? defaultFieldResolver
                : defaultMergedResolver;
        this.transformer = new MapFields(fieldNodeTransformerMap != null ? fieldNodeTransformerMap : {});
    }
    ExtendSchema.prototype.transformSchema = function (schema) {
        this.transformer.transformSchema(schema);
        return addResolversToSchema({
            schema: this.typeDefs
                ? Object(graphql__WEBPACK_IMPORTED_MODULE_3__["extendSchema"])(schema, Object(graphql__WEBPACK_IMPORTED_MODULE_3__["parse"])(this.typeDefs))
                : schema,
            resolvers: this.resolvers != null ? this.resolvers : {},
            defaultFieldResolver: this.defaultFieldResolver,
        });
    };
    ExtendSchema.prototype.transformRequest = function (originalRequest) {
        return this.transformer.transformRequest(originalRequest);
    };
    return ExtendSchema;
}());

function renameFieldNode(fieldNode, name) {
    return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, fieldNode), { alias: {
            kind: graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].NAME,
            value: fieldNode.alias != null ? fieldNode.alias.value : fieldNode.name.value,
        }, name: {
            kind: graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].NAME,
            value: name,
        } });
}
function preAliasFieldNode(fieldNode, str) {
    return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, fieldNode), { alias: {
            kind: graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].NAME,
            value: "" + str + (fieldNode.alias != null ? fieldNode.alias.value : fieldNode.name.value),
        } });
}
function wrapFieldNode(fieldNode, path) {
    var newFieldNode = fieldNode;
    path.forEach(function (fieldName) {
        newFieldNode = {
            kind: graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].FIELD,
            name: {
                kind: graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].NAME,
                value: fieldName,
            },
            selectionSet: {
                kind: graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].SELECTION_SET,
                selections: [fieldNode],
            },
        };
    });
    return newFieldNode;
}
function collectFields$1(selectionSet, fragments, fields, visitedFragmentNames) {
    if (fields === void 0) { fields = []; }
    if (visitedFragmentNames === void 0) { visitedFragmentNames = {}; }
    if (selectionSet != null) {
        selectionSet.selections.forEach(function (selection) {
            switch (selection.kind) {
                case graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].FIELD:
                    fields.push(selection);
                    break;
                case graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].INLINE_FRAGMENT:
                    collectFields$1(selection.selectionSet, fragments, fields, visitedFragmentNames);
                    break;
                case graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].FRAGMENT_SPREAD: {
                    var fragmentName = selection.name.value;
                    if (!visitedFragmentNames[fragmentName]) {
                        visitedFragmentNames[fragmentName] = true;
                        collectFields$1(fragments[fragmentName].selectionSet, fragments, fields, visitedFragmentNames);
                    }
                    break;
                }
            }
        });
    }
    return fields;
}
function hoistFieldNodes(_a) {
    var fieldNode = _a.fieldNode, fieldNames = _a.fieldNames, _b = _a.path, path = _b === void 0 ? [] : _b, _c = _a.delimeter, delimeter = _c === void 0 ? '__gqltf__' : _c, fragments = _a.fragments;
    var alias = fieldNode.alias != null ? fieldNode.alias.value : fieldNode.name.value;
    var newFieldNodes = [];
    if (path.length) {
        var remainingPathSegments_1 = path.slice();
        var initialPathSegment_1 = remainingPathSegments_1.shift();
        collectFields$1(fieldNode.selectionSet, fragments).forEach(function (possibleFieldNode) {
            if (possibleFieldNode.name.value === initialPathSegment_1) {
                newFieldNodes = newFieldNodes.concat(hoistFieldNodes({
                    fieldNode: preAliasFieldNode(possibleFieldNode, "" + alias + delimeter),
                    fieldNames: fieldNames,
                    path: remainingPathSegments_1,
                    delimeter: delimeter,
                    fragments: fragments,
                }));
            }
        });
    }
    else {
        collectFields$1(fieldNode.selectionSet, fragments).forEach(function (possibleFieldNode) {
            if (!fieldNames || fieldNames.includes(possibleFieldNode.name.value)) {
                newFieldNodes.push(preAliasFieldNode(possibleFieldNode, "" + alias + delimeter));
            }
        });
    }
    return newFieldNodes;
}

function appendFields(typeMap, typeName, fields) {
    var type = typeMap[typeName];
    if (type != null) {
        var typeConfig = toConfig(type);
        var newFields_1 = toObjMap(typeConfig.fields);
        Object.keys(fields).forEach(function (fieldName) {
            newFields_1[fieldName] = fields[fieldName];
        });
        type = new graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLObjectType"](Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, typeConfig), { fields: newFields_1 }));
    }
    else {
        type = new graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLObjectType"]({
            name: typeName,
            fields: fields,
        });
    }
    typeMap[typeName] = type;
}
function removeFields(typeMap, typeName, testFn) {
    var type = typeMap[typeName];
    var typeConfig = toConfig(type);
    var originalFields = typeConfig.fields;
    var newFields = {};
    var removedFields = {};
    Object.keys(originalFields).forEach(function (fieldName) {
        if (testFn(fieldName, originalFields[fieldName])) {
            removedFields[fieldName] = originalFields[fieldName];
        }
        else {
            newFields[fieldName] = originalFields[fieldName];
        }
    });
    type = new graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLObjectType"](Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, typeConfig), { fields: newFields }));
    typeMap[typeName] = type;
    return removedFields;
}

function createMergedResolver(_a) {
    var fromPath = _a.fromPath, dehoist = _a.dehoist, _b = _a.delimeter, delimeter = _b === void 0 ? '__gqltf__' : _b;
    var parentErrorResolver = function (parent, args, context, info) {
        return parent instanceof Error
            ? parent
            : defaultMergedResolver(parent, args, context, info);
    };
    var unwrappingResolver = fromPath != null
        ? function (parent, args, context, info) {
            return parentErrorResolver(unwrapResult(parent, info, fromPath), args, context, info);
        }
        : parentErrorResolver;
    var dehoistingResolver = dehoist
        ? function (parent, args, context, info) {
            return unwrappingResolver(dehoistResult(parent, delimeter), args, context, info);
        }
        : unwrappingResolver;
    var noParentResolver = function (parent, args, context, info) { return (parent ? dehoistingResolver(parent, args, context, info) : {}); };
    return noParentResolver;
}

var WrapFields = /** @class */ (function () {
    function WrapFields(outerTypeName, wrappingFieldNames, wrappingTypeNames, fieldNames) {
        var _a, _b;
        var _this = this;
        this.outerTypeName = outerTypeName;
        this.wrappingFieldNames = wrappingFieldNames;
        this.wrappingTypeNames = wrappingTypeNames;
        this.numWraps = wrappingFieldNames.length;
        this.fieldNames = fieldNames;
        var remainingWrappingFieldNames = this.wrappingFieldNames.slice();
        var outerMostWrappingFieldName = remainingWrappingFieldNames.shift();
        this.transformer = new MapFields((_a = {},
            _a[outerTypeName] = (_b = {},
                _b[outerMostWrappingFieldName] = function (fieldNode, fragments) {
                    return hoistFieldNodes({
                        fieldNode: fieldNode,
                        path: remainingWrappingFieldNames,
                        fieldNames: _this.fieldNames,
                        fragments: fragments,
                    });
                },
                _b),
            _a));
    }
    WrapFields.prototype.transformSchema = function (schema) {
        var _a, _b;
        var _this = this;
        var typeMap = schema.getTypeMap();
        var targetFields = removeFields(typeMap, this.outerTypeName, !this.fieldNames
            ? function () { return true; }
            : function (fieldName) { return _this.fieldNames.includes(fieldName); });
        var wrapIndex = this.numWraps - 1;
        var innerMostWrappingTypeName = this.wrappingTypeNames[wrapIndex];
        appendFields(typeMap, innerMostWrappingTypeName, targetFields);
        for (wrapIndex--; wrapIndex > -1; wrapIndex--) {
            appendFields(typeMap, this.wrappingTypeNames[wrapIndex], (_a = {},
                _a[this.wrappingFieldNames[wrapIndex + 1]] = {
                    type: typeMap[this.wrappingTypeNames[wrapIndex + 1]],
                    resolve: defaultMergedResolver,
                },
                _a));
        }
        appendFields(typeMap, this.outerTypeName, (_b = {},
            _b[this.wrappingFieldNames[0]] = {
                type: typeMap[this.wrappingTypeNames[0]],
                resolve: createMergedResolver({ dehoist: true }),
            },
            _b));
        healSchema(schema);
        return this.transformer.transformSchema(schema);
    };
    WrapFields.prototype.transformRequest = function (originalRequest) {
        return this.transformer.transformRequest(originalRequest);
    };
    return WrapFields;
}());

var WrapType = /** @class */ (function () {
    function WrapType(outerTypeName, innerTypeName, fieldName) {
        this.transformer = new WrapFields(outerTypeName, [fieldName], [innerTypeName], undefined);
    }
    WrapType.prototype.transformSchema = function (schema) {
        return this.transformer.transformSchema(schema);
    };
    WrapType.prototype.transformRequest = function (originalRequest) {
        return this.transformer.transformRequest(originalRequest);
    };
    return WrapType;
}());

var HoistField = /** @class */ (function () {
    function HoistField(typeName, path, newFieldName) {
        var _a, _b;
        var _this = this;
        this.typeName = typeName;
        this.path = path;
        this.newFieldName = newFieldName;
        this.pathToField = this.path.slice();
        this.oldFieldName = this.pathToField.pop();
        this.transformer = new MapFields((_a = {},
            _a[typeName] = (_b = {},
                _b[newFieldName] = function (fieldNode) {
                    return wrapFieldNode(renameFieldNode(fieldNode, _this.oldFieldName), _this.pathToField);
                },
                _b),
            _a));
    }
    HoistField.prototype.transformSchema = function (schema) {
        var _a;
        var _this = this;
        var typeMap = schema.getTypeMap();
        var innerType = this.pathToField.reduce(function (acc, pathSegment) {
            return Object(graphql__WEBPACK_IMPORTED_MODULE_3__["getNullableType"])(acc.getFields()[pathSegment].type);
        }, typeMap[this.typeName]);
        var targetField = removeFields(typeMap, innerType.name, function (fieldName) { return fieldName === _this.oldFieldName; })[this.oldFieldName];
        var targetType = targetField.type;
        appendFields(typeMap, this.typeName, (_a = {},
            _a[this.newFieldName] = {
                type: targetType,
                resolve: createMergedResolver({ fromPath: this.pathToField }),
            },
            _a));
        healSchema(schema);
        return this.transformer.transformSchema(schema);
    };
    HoistField.prototype.transformRequest = function (originalRequest) {
        return this.transformer.transformRequest(originalRequest);
    };
    return HoistField;
}());

var ReplaceFieldWithFragment = /** @class */ (function () {
    function ReplaceFieldWithFragment(targetSchema, fragments) {
        this.targetSchema = targetSchema;
        this.mapping = {};
        for (var _i = 0, fragments_1 = fragments; _i < fragments_1.length; _i++) {
            var _a = fragments_1[_i], field = _a.field, fragment = _a.fragment;
            var parsedFragment = parseFragmentToInlineFragment$1(fragment);
            var actualTypeName = parsedFragment.typeCondition.name.value;
            if (!(actualTypeName in this.mapping)) {
                this.mapping[actualTypeName] = Object.create(null);
            }
            var typeMapping = this.mapping[actualTypeName];
            if (!(field in typeMapping)) {
                typeMapping[field] = [parsedFragment];
            }
            else {
                typeMapping[field].push(parsedFragment);
            }
        }
    }
    ReplaceFieldWithFragment.prototype.transformRequest = function (originalRequest) {
        var document = replaceFieldsWithFragments$1(this.targetSchema, originalRequest.document, this.mapping);
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, originalRequest), { document: document });
    };
    return ReplaceFieldWithFragment;
}());
function replaceFieldsWithFragments$1(targetSchema, document, mapping) {
    var _a;
    var typeInfo = new graphql__WEBPACK_IMPORTED_MODULE_3__["TypeInfo"](targetSchema);
    return Object(graphql__WEBPACK_IMPORTED_MODULE_3__["visit"])(document, Object(graphql__WEBPACK_IMPORTED_MODULE_3__["visitWithTypeInfo"])(typeInfo, (_a = {},
        _a[graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].SELECTION_SET] = function (node) {
            var parentType = typeInfo.getParentType();
            if (parentType != null) {
                var parentTypeName_1 = parentType.name;
                var selections_1 = node.selections;
                if (parentTypeName_1 in mapping) {
                    node.selections.forEach(function (selection) {
                        if (selection.kind === graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].FIELD) {
                            var name_1 = selection.name.value;
                            var fragments = mapping[parentTypeName_1][name_1];
                            if (fragments != null && fragments.length > 0) {
                                var fragment = concatInlineFragments(parentTypeName_1, fragments);
                                selections_1 = selections_1.concat(fragment);
                            }
                        }
                    });
                }
                if (selections_1 !== node.selections) {
                    return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, node), { selections: selections_1 });
                }
            }
        },
        _a)));
}
function parseFragmentToInlineFragment$1(definitions) {
    if (definitions.trim().startsWith('fragment')) {
        var document_1 = Object(graphql__WEBPACK_IMPORTED_MODULE_3__["parse"])(definitions);
        for (var _i = 0, _a = document_1.definitions; _i < _a.length; _i++) {
            var definition = _a[_i];
            if (definition.kind === graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].FRAGMENT_DEFINITION) {
                return {
                    kind: graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].INLINE_FRAGMENT,
                    typeCondition: definition.typeCondition,
                    selectionSet: definition.selectionSet,
                };
            }
        }
    }
    var query = Object(graphql__WEBPACK_IMPORTED_MODULE_3__["parse"])("{" + definitions + "}")
        .definitions[0];
    for (var _b = 0, _c = query.selectionSet.selections; _b < _c.length; _b++) {
        var selection = _c[_b];
        if (selection.kind === graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].INLINE_FRAGMENT) {
            return selection;
        }
    }
    throw new Error('Could not parse fragment');
}

var WrapQuery = /** @class */ (function () {
    function WrapQuery(path, wrapper, extractor) {
        this.path = path;
        this.wrapper = wrapper;
        this.extractor = extractor;
    }
    WrapQuery.prototype.transformRequest = function (originalRequest) {
        var _a;
        var _this = this;
        var document = originalRequest.document;
        var fieldPath = [];
        var ourPath = JSON.stringify(this.path);
        var newDocument = Object(graphql__WEBPACK_IMPORTED_MODULE_3__["visit"])(document, (_a = {},
            _a[graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].FIELD] = {
                enter: function (node) {
                    fieldPath.push(node.name.value);
                    if (ourPath === JSON.stringify(fieldPath)) {
                        var wrapResult = _this.wrapper(node.selectionSet);
                        // Selection can be either a single selection or a selection set. If it's just one selection,
                        // let's wrap it in a selection set. Otherwise, keep it as is.
                        var selectionSet = wrapResult != null && wrapResult.kind === graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].SELECTION_SET
                            ? wrapResult
                            : {
                                kind: graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].SELECTION_SET,
                                selections: [wrapResult],
                            };
                        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, node), { selectionSet: selectionSet });
                    }
                },
                leave: function () {
                    fieldPath.pop();
                },
            },
            _a));
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, originalRequest), { document: newDocument });
    };
    WrapQuery.prototype.transformResult = function (originalResult) {
        var rootData = originalResult.data;
        if (rootData != null) {
            var data = rootData;
            var path = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __spreadArrays */ "d"])(this.path);
            while (path.length > 1) {
                var next = path.shift();
                if (data[next]) {
                    data = data[next];
                }
            }
            data[path[0]] = this.extractor(data[path[0]]);
        }
        return {
            data: rootData,
            errors: originalResult.errors,
        };
    };
    return WrapQuery;
}());

var ExtractField = /** @class */ (function () {
    function ExtractField(_a) {
        var from = _a.from, to = _a.to;
        this.from = from;
        this.to = to;
    }
    ExtractField.prototype.transformRequest = function (originalRequest) {
        var _a, _b;
        var fromSelection;
        var ourPathFrom = JSON.stringify(this.from);
        var ourPathTo = JSON.stringify(this.to);
        var fieldPath = [];
        Object(graphql__WEBPACK_IMPORTED_MODULE_3__["visit"])(originalRequest.document, (_a = {},
            _a[graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].FIELD] = {
                enter: function (node) {
                    fieldPath.push(node.name.value);
                    if (ourPathFrom === JSON.stringify(fieldPath)) {
                        fromSelection = node.selectionSet;
                        return graphql__WEBPACK_IMPORTED_MODULE_3__["BREAK"];
                    }
                },
                leave: function () {
                    fieldPath.pop();
                },
            },
            _a));
        fieldPath = [];
        var newDocument = Object(graphql__WEBPACK_IMPORTED_MODULE_3__["visit"])(originalRequest.document, (_b = {},
            _b[graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].FIELD] = {
                enter: function (node) {
                    fieldPath.push(node.name.value);
                    if (ourPathTo === JSON.stringify(fieldPath) &&
                        fromSelection != null) {
                        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, node), { selectionSet: fromSelection });
                    }
                },
                leave: function () {
                    fieldPath.pop();
                },
            },
            _b));
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, originalRequest), { document: newDocument });
    };
    return ExtractField;
}());

function makeRemoteExecutableSchema(_a) {
    var schemaOrTypeDefs = _a.schema, link = _a.link, fetcher = _a.fetcher, _b = _a.createResolver, createResolver = _b === void 0 ? defaultCreateRemoteResolver : _b, _c = _a.createSubscriptionResolver, createSubscriptionResolver = _c === void 0 ? defaultCreateRemoteSubscriptionResolver : _c, buildSchemaOptions = _a.buildSchemaOptions;
    var finalFetcher = fetcher;
    if (finalFetcher == null && link != null) {
        finalFetcher = linkToFetcher(link);
    }
    var targetSchema = typeof schemaOrTypeDefs === 'string'
        ? buildSchema(schemaOrTypeDefs, buildSchemaOptions)
        : schemaOrTypeDefs;
    return wrapSchema({
        schema: targetSchema,
        createProxyingResolver: function (_schema, _transforms, operation) {
            if (operation === 'query' || operation === 'mutation') {
                return createResolver(finalFetcher);
            }
            return createSubscriptionResolver(link);
        },
    });
}
function defaultCreateRemoteResolver(fetcher) {
    return function (_parent, _args, context, info) {
        return delegateToSchema({
            schema: { schema: info.schema, fetcher: fetcher },
            context: context,
            info: info,
        });
    };
}
function defaultCreateRemoteSubscriptionResolver(link) {
    return function (_parent, _args, context, info) {
        return delegateToSchema({
            schema: { schema: info.schema, link: link },
            context: context,
            info: info,
        });
    };
}


//# sourceMappingURL=index.esm.js.map


/***/ }),

/***/ "../../node_modules/@graphql-toolkit/schema-merging/node_modules/graphql-tools/index.esm.js":
/*!*******************************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/@graphql-toolkit/schema-merging/node_modules/graphql-tools/index.esm.js ***!
  \*******************************************************************************************************************************************/
/*! exports provided: AddArgumentsAsVariables, AddMergedTypeSelectionSets, AddReplacementFragments, AddReplacementSelectionSets, AddTypenameToAbstract, AwaitVariablesLink, CheckResultAndHandleErrors, ExpandAbstractTypes, ExtendSchema, ExtractField, FilterInterfaceFields, FilterObjectFields, FilterRootFields, FilterToSchema, FilterTypes, GraphQLUpload, HoistField, MapFields, MapperKind, MockList, RenameInterfaceFields, RenameObjectFields, RenameRootFields, RenameRootTypes, RenameTypes, ReplaceFieldWithFragment, SchemaDirectiveVisitor, SchemaError, SchemaVisitor, TransformCompositeFields, TransformInterfaceFields, TransformObjectFields, TransformQuery, TransformRootFields, VisitSchemaKind, WrapFields, WrapQuery, WrapType, addCatchUndefinedToSchema, addErrorLoggingToSchema, addMockFunctionsToSchema, addMocksToSchema, addResolveFunctionsToSchema, addResolversToSchema, addSchemaLevelResolveFunction, addSchemaLevelResolver, argumentMapToConfig, argumentToConfig, assertResolveFunctionsPresent, assertResolversPresent, attachConnectorsToContext, attachDirectiveResolvers, buildSchema, buildSchemaFromTypeDefinitions, chainResolvers, checkForResolveTypeResolver, cloneDirective, cloneSchema, cloneType, concatenateTypeDefs, createRequest, createRequestFromInfo, createServerHttpLink, decorateWithLogger, defaultCreateProxyingResolver, defaultCreateRemoteResolver, defaultCreateRemoteSubscriptionResolver, defaultMergedResolver, delegateRequest, delegateToSchema, directiveToConfig, enumTypeToConfig, extendResolversFromInterfaces, extendSchema, extractExtensionDefinitions, fieldMapToConfig, fieldToConfig, filterExtensionDefinitions, filterSchema, forEachDefaultValue, forEachField, getResolversFromSchema, graphqlVersion, healSchema, healTypes, inputFieldMapToConfig, inputFieldToConfig, inputObjectTypeToConfig, interfaceTypeToConfig, introspectSchema, isSpecifiedScalarType, isSubschemaConfig, makeExecutableSchema, makeRemoteExecutableSchema, mapSchema, mergeSchemas, mockServer, objectTypeToConfig, scalarTypeToConfig, schemaToConfig, toConfig, transformSchema, typeToConfig, unionTypeToConfig, visitSchema, wrapSchema */
/*! exports used: SchemaDirectiveVisitor, addErrorLoggingToSchema, addResolveFunctionsToSchema */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export AddArgumentsAsVariables */
/* unused harmony export AddMergedTypeSelectionSets */
/* unused harmony export AddReplacementFragments */
/* unused harmony export AddReplacementSelectionSets */
/* unused harmony export AddTypenameToAbstract */
/* unused harmony export AwaitVariablesLink */
/* unused harmony export CheckResultAndHandleErrors */
/* unused harmony export ExpandAbstractTypes */
/* unused harmony export ExtendSchema */
/* unused harmony export ExtractField */
/* unused harmony export FilterInterfaceFields */
/* unused harmony export FilterObjectFields */
/* unused harmony export FilterRootFields */
/* unused harmony export FilterToSchema */
/* unused harmony export FilterTypes */
/* unused harmony export GraphQLUpload */
/* unused harmony export HoistField */
/* unused harmony export MapFields */
/* unused harmony export MapperKind */
/* unused harmony export MockList */
/* unused harmony export RenameInterfaceFields */
/* unused harmony export RenameObjectFields */
/* unused harmony export RenameRootFields */
/* unused harmony export RenameRootTypes */
/* unused harmony export RenameTypes */
/* unused harmony export ReplaceFieldWithFragment */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return SchemaDirectiveVisitor; });
/* unused harmony export SchemaError */
/* unused harmony export SchemaVisitor */
/* unused harmony export TransformCompositeFields */
/* unused harmony export TransformInterfaceFields */
/* unused harmony export TransformObjectFields */
/* unused harmony export TransformQuery */
/* unused harmony export TransformRootFields */
/* unused harmony export VisitSchemaKind */
/* unused harmony export WrapFields */
/* unused harmony export WrapQuery */
/* unused harmony export WrapType */
/* unused harmony export addCatchUndefinedToSchema */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return addErrorLoggingToSchema; });
/* unused harmony export addMockFunctionsToSchema */
/* unused harmony export addMocksToSchema */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return addResolveFunctionsToSchema; });
/* unused harmony export addResolversToSchema */
/* unused harmony export addSchemaLevelResolveFunction */
/* unused harmony export addSchemaLevelResolver */
/* unused harmony export argumentMapToConfig */
/* unused harmony export argumentToConfig */
/* unused harmony export assertResolveFunctionsPresent */
/* unused harmony export assertResolversPresent */
/* unused harmony export attachConnectorsToContext */
/* unused harmony export attachDirectiveResolvers */
/* unused harmony export buildSchema */
/* unused harmony export buildSchemaFromTypeDefinitions */
/* unused harmony export chainResolvers */
/* unused harmony export checkForResolveTypeResolver */
/* unused harmony export cloneDirective */
/* unused harmony export cloneSchema */
/* unused harmony export cloneType */
/* unused harmony export concatenateTypeDefs */
/* unused harmony export createRequest */
/* unused harmony export createRequestFromInfo */
/* unused harmony export createServerHttpLink */
/* unused harmony export decorateWithLogger */
/* unused harmony export defaultCreateProxyingResolver */
/* unused harmony export defaultCreateRemoteResolver */
/* unused harmony export defaultCreateRemoteSubscriptionResolver */
/* unused harmony export defaultMergedResolver */
/* unused harmony export delegateRequest */
/* unused harmony export delegateToSchema */
/* unused harmony export directiveToConfig */
/* unused harmony export enumTypeToConfig */
/* unused harmony export extendResolversFromInterfaces */
/* unused harmony export extendSchema */
/* unused harmony export extractExtensionDefinitions */
/* unused harmony export fieldMapToConfig */
/* unused harmony export fieldToConfig */
/* unused harmony export filterExtensionDefinitions */
/* unused harmony export filterSchema */
/* unused harmony export forEachDefaultValue */
/* unused harmony export forEachField */
/* unused harmony export getResolversFromSchema */
/* unused harmony export graphqlVersion */
/* unused harmony export healSchema */
/* unused harmony export healTypes */
/* unused harmony export inputFieldMapToConfig */
/* unused harmony export inputFieldToConfig */
/* unused harmony export inputObjectTypeToConfig */
/* unused harmony export interfaceTypeToConfig */
/* unused harmony export introspectSchema */
/* unused harmony export isSpecifiedScalarType */
/* unused harmony export isSubschemaConfig */
/* unused harmony export makeExecutableSchema */
/* unused harmony export makeRemoteExecutableSchema */
/* unused harmony export mapSchema */
/* unused harmony export mergeSchemas */
/* unused harmony export mockServer */
/* unused harmony export objectTypeToConfig */
/* unused harmony export scalarTypeToConfig */
/* unused harmony export schemaToConfig */
/* unused harmony export toConfig */
/* unused harmony export transformSchema */
/* unused harmony export typeToConfig */
/* unused harmony export unionTypeToConfig */
/* unused harmony export visitSchema */
/* unused harmony export wrapSchema */
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "../../node_modules/@graphql-toolkit/schema-merging/node_modules/graphql-tools/node_modules/tslib/tslib.es6.js");
/* harmony import */ var iterall__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! iterall */ "../../node_modules/iterall/index.mjs");
/* harmony import */ var apollo_link__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! apollo-link */ "../../node_modules/apollo-link/lib/bundle.esm.js");
/* harmony import */ var graphql__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! graphql */ "../../node_modules/graphql/index.mjs");
/* harmony import */ var deprecated_decorator__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! deprecated-decorator */ "../../node_modules/deprecated-decorator/bld/index.js");
/* harmony import */ var deprecated_decorator__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(deprecated_decorator__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var apollo_upload_client__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! apollo-upload-client */ "../../node_modules/apollo-upload-client/lib/index.js");
/* harmony import */ var apollo_upload_client__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(apollo_upload_client__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var form_data__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! form-data */ "../../node_modules/form-data/lib/form_data.js");
/* harmony import */ var form_data__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(form_data__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var node_fetch__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! node-fetch */ "../../node_modules/node-fetch/lib/index.mjs");
/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! uuid */ "../../node_modules/@graphql-toolkit/schema-merging/node_modules/uuid/dist/esm-node/index.js");










function isSubschemaConfig(value) {
    return Boolean(value.schema);
}
var VisitSchemaKind;
(function (VisitSchemaKind) {
    VisitSchemaKind["TYPE"] = "VisitSchemaKind.TYPE";
    VisitSchemaKind["SCALAR_TYPE"] = "VisitSchemaKind.SCALAR_TYPE";
    VisitSchemaKind["ENUM_TYPE"] = "VisitSchemaKind.ENUM_TYPE";
    VisitSchemaKind["COMPOSITE_TYPE"] = "VisitSchemaKind.COMPOSITE_TYPE";
    VisitSchemaKind["OBJECT_TYPE"] = "VisitSchemaKind.OBJECT_TYPE";
    VisitSchemaKind["INPUT_OBJECT_TYPE"] = "VisitSchemaKind.INPUT_OBJECT_TYPE";
    VisitSchemaKind["ABSTRACT_TYPE"] = "VisitSchemaKind.ABSTRACT_TYPE";
    VisitSchemaKind["UNION_TYPE"] = "VisitSchemaKind.UNION_TYPE";
    VisitSchemaKind["INTERFACE_TYPE"] = "VisitSchemaKind.INTERFACE_TYPE";
    VisitSchemaKind["ROOT_OBJECT"] = "VisitSchemaKind.ROOT_OBJECT";
    VisitSchemaKind["QUERY"] = "VisitSchemaKind.QUERY";
    VisitSchemaKind["MUTATION"] = "VisitSchemaKind.MUTATION";
    VisitSchemaKind["SUBSCRIPTION"] = "VisitSchemaKind.SUBSCRIPTION";
})(VisitSchemaKind || (VisitSchemaKind = {}));
var MapperKind;
(function (MapperKind) {
    MapperKind["TYPE"] = "MapperKind.TYPE";
    MapperKind["SCALAR_TYPE"] = "MapperKind.SCALAR_TYPE";
    MapperKind["ENUM_TYPE"] = "MapperKind.ENUM_TYPE";
    MapperKind["COMPOSITE_TYPE"] = "MapperKind.COMPOSITE_TYPE";
    MapperKind["OBJECT_TYPE"] = "MapperKind.OBJECT_TYPE";
    MapperKind["INPUT_OBJECT_TYPE"] = "MapperKind.INPUT_OBJECT_TYPE";
    MapperKind["ABSTRACT_TYPE"] = "MapperKind.ABSTRACT_TYPE";
    MapperKind["UNION_TYPE"] = "MapperKind.UNION_TYPE";
    MapperKind["INTERFACE_TYPE"] = "MapperKind.INTERFACE_TYPE";
    MapperKind["ROOT_OBJECT"] = "MapperKind.ROOT_OBJECT";
    MapperKind["QUERY"] = "MapperKind.QUERY";
    MapperKind["MUTATION"] = "MapperKind.MUTATION";
    MapperKind["SUBSCRIPTION"] = "MapperKind.SUBSCRIPTION";
    MapperKind["DIRECTIVE"] = "MapperKind.DIRECTIVE";
})(MapperKind || (MapperKind = {}));

function implementsAbstractType(schema, typeA, typeB) {
    if (typeA === typeB) {
        return true;
    }
    else if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isCompositeType"])(typeA) && Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isCompositeType"])(typeB)) {
        return Object(graphql__WEBPACK_IMPORTED_MODULE_3__["doTypesOverlap"])(schema, typeA, typeB);
    }
    return false;
}

var ExpandAbstractTypes = /** @class */ (function () {
    function ExpandAbstractTypes(sourceSchema, targetSchema) {
        this.targetSchema = targetSchema;
        this.mapping = extractPossibleTypes(sourceSchema, targetSchema);
        this.reverseMapping = flipMapping(this.mapping);
    }
    ExpandAbstractTypes.prototype.transformRequest = function (originalRequest) {
        var document = expandAbstractTypes(this.targetSchema, this.mapping, this.reverseMapping, originalRequest.document);
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, originalRequest), { document: document });
    };
    return ExpandAbstractTypes;
}());
function extractPossibleTypes(sourceSchema, targetSchema) {
    var typeMap = sourceSchema.getTypeMap();
    var mapping = Object.create(null);
    Object.keys(typeMap).forEach(function (typeName) {
        var type = typeMap[typeName];
        if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isAbstractType"])(type)) {
            var targetType = targetSchema.getType(typeName);
            if (!Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isAbstractType"])(targetType)) {
                var implementations = sourceSchema.getPossibleTypes(type);
                mapping[typeName] = implementations
                    .filter(function (impl) { return targetSchema.getType(impl.name); })
                    .map(function (impl) { return impl.name; });
            }
        }
    });
    return mapping;
}
function flipMapping(mapping) {
    var result = Object.create(null);
    Object.keys(mapping).forEach(function (typeName) {
        var toTypeNames = mapping[typeName];
        toTypeNames.forEach(function (toTypeName) {
            if (!(toTypeName in result)) {
                result[toTypeName] = [];
            }
            result[toTypeName].push(typeName);
        });
    });
    return result;
}
function expandAbstractTypes(targetSchema, mapping, reverseMapping, document) {
    var _a;
    var operations = document.definitions.filter(function (def) { return def.kind === graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].OPERATION_DEFINITION; });
    var fragments = document.definitions.filter(function (def) { return def.kind === graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].FRAGMENT_DEFINITION; });
    var existingFragmentNames = fragments.map(function (fragment) { return fragment.name.value; });
    var fragmentCounter = 0;
    var generateFragmentName = function (typeName) {
        var fragmentName;
        do {
            fragmentName = "_" + typeName + "_Fragment" + fragmentCounter.toString();
            fragmentCounter++;
        } while (existingFragmentNames.indexOf(fragmentName) !== -1);
        return fragmentName;
    };
    var newFragments = [];
    var fragmentReplacements = Object.create(null);
    fragments.forEach(function (fragment) {
        newFragments.push(fragment);
        var possibleTypes = mapping[fragment.typeCondition.name.value];
        if (possibleTypes != null) {
            fragmentReplacements[fragment.name.value] = [];
            possibleTypes.forEach(function (possibleTypeName) {
                var name = generateFragmentName(possibleTypeName);
                existingFragmentNames.push(name);
                var newFragment = {
                    kind: graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].FRAGMENT_DEFINITION,
                    name: {
                        kind: graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].NAME,
                        value: name,
                    },
                    typeCondition: {
                        kind: graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].NAMED_TYPE,
                        name: {
                            kind: graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].NAME,
                            value: possibleTypeName,
                        },
                    },
                    selectionSet: fragment.selectionSet,
                };
                newFragments.push(newFragment);
                fragmentReplacements[fragment.name.value].push({
                    fragmentName: name,
                    typeName: possibleTypeName,
                });
            });
        }
    });
    var newDocument = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, document), { definitions: Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __spreadArrays */ "d"])(operations, newFragments) });
    var typeInfo = new graphql__WEBPACK_IMPORTED_MODULE_3__["TypeInfo"](targetSchema);
    return Object(graphql__WEBPACK_IMPORTED_MODULE_3__["visit"])(newDocument, Object(graphql__WEBPACK_IMPORTED_MODULE_3__["visitWithTypeInfo"])(typeInfo, (_a = {},
        _a[graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].SELECTION_SET] = function (node) {
            var newSelections = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __spreadArrays */ "d"])(node.selections);
            var maybeType = typeInfo.getParentType();
            if (maybeType != null) {
                var parentType_1 = Object(graphql__WEBPACK_IMPORTED_MODULE_3__["getNamedType"])(maybeType);
                node.selections.forEach(function (selection) {
                    if (selection.kind === graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].INLINE_FRAGMENT) {
                        if (selection.typeCondition != null) {
                            var possibleTypes = mapping[selection.typeCondition.name.value];
                            if (possibleTypes != null) {
                                possibleTypes.forEach(function (possibleType) {
                                    var maybePossibleType = targetSchema.getType(possibleType);
                                    if (maybePossibleType != null &&
                                        implementsAbstractType(targetSchema, parentType_1, maybePossibleType)) {
                                        newSelections.push({
                                            kind: graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].INLINE_FRAGMENT,
                                            typeCondition: {
                                                kind: graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].NAMED_TYPE,
                                                name: {
                                                    kind: graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].NAME,
                                                    value: possibleType,
                                                },
                                            },
                                            selectionSet: selection.selectionSet,
                                        });
                                    }
                                });
                            }
                        }
                    }
                    else if (selection.kind === graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].FRAGMENT_SPREAD) {
                        var fragmentName = selection.name.value;
                        if (fragmentName in fragmentReplacements) {
                            fragmentReplacements[fragmentName].forEach(function (replacement) {
                                var typeName = replacement.typeName;
                                var maybeReplacementType = targetSchema.getType(typeName);
                                if (maybeReplacementType != null &&
                                    implementsAbstractType(targetSchema, parentType_1, maybeType)) {
                                    newSelections.push({
                                        kind: graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].FRAGMENT_SPREAD,
                                        name: {
                                            kind: graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].NAME,
                                            value: replacement.fragmentName,
                                        },
                                    });
                                }
                            });
                        }
                    }
                });
                if (parentType_1.name in reverseMapping) {
                    newSelections.push({
                        kind: graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].FIELD,
                        name: {
                            kind: graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].NAME,
                            value: '__typename',
                        },
                    });
                }
            }
            if (newSelections.length !== node.selections.length) {
                return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, node), { selections: newSelections });
            }
        },
        _a)));
}

/**
 * Creates a keyed JS object from an array, given a function to produce the keys
 * and a function to produce the values from each item in the array.
 *
 *     const phoneBook = [
 *       { name: 'Jon', num: '555-1234' },
 *       { name: 'Jenny', num: '867-5309' }
 *     ]
 *
 *     // { Jon: '555-1234', Jenny: '867-5309' }
 *     const phonesByName = keyValMap(
 *       phoneBook,
 *       entry => entry.name,
 *       entry => entry.num
 *     )
 *
 */
function keyValMap(list, keyFn, valFn) {
    return list.reduce(function (map, item) {
        map[keyFn(item)] = valFn(item);
        return map;
    }, Object.create(null));
}

var FilterToSchema = /** @class */ (function () {
    function FilterToSchema(targetSchema) {
        this.targetSchema = targetSchema;
    }
    FilterToSchema.prototype.transformRequest = function (originalRequest) {
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, originalRequest), filterToSchema(this.targetSchema, originalRequest.document, originalRequest.variables));
    };
    return FilterToSchema;
}());
function filterToSchema(targetSchema, document, variables) {
    var operations = document.definitions.filter(function (def) { return def.kind === graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].OPERATION_DEFINITION; });
    var fragments = document.definitions.filter(function (def) { return def.kind === graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].FRAGMENT_DEFINITION; });
    var usedVariables = [];
    var usedFragments = [];
    var newOperations = [];
    var newFragments = [];
    var validFragments = fragments.filter(function (fragment) {
        var typeName = fragment.typeCondition.name.value;
        return Boolean(targetSchema.getType(typeName));
    });
    var validFragmentsWithType = keyValMap(validFragments, function (fragment) { return fragment.name.value; }, function (fragment) { return targetSchema.getType(fragment.typeCondition.name.value); });
    var fragmentSet = Object.create(null);
    operations.forEach(function (operation) {
        var type;
        if (operation.operation === 'subscription') {
            type = targetSchema.getSubscriptionType();
        }
        else if (operation.operation === 'mutation') {
            type = targetSchema.getMutationType();
        }
        else {
            type = targetSchema.getQueryType();
        }
        var _a = filterSelectionSet(targetSchema, type, validFragmentsWithType, operation.selectionSet), selectionSet = _a.selectionSet, operationUsedFragments = _a.usedFragments, operationUsedVariables = _a.usedVariables;
        usedFragments = union(usedFragments, operationUsedFragments);
        var _b = collectFragmentVariables(targetSchema, fragmentSet, validFragments, validFragmentsWithType, usedFragments), collectedUsedVariables = _b.usedVariables, collectedNewFragments = _b.newFragments, collectedFragmentSet = _b.fragmentSet;
        var operationOrFragmentVariables = union(operationUsedVariables, collectedUsedVariables);
        usedVariables = union(usedVariables, operationOrFragmentVariables);
        newFragments = collectedNewFragments;
        fragmentSet = collectedFragmentSet;
        var variableDefinitions = operation.variableDefinitions.filter(function (variable) {
            return operationOrFragmentVariables.indexOf(variable.variable.name.value) !==
                -1;
        });
        newOperations.push({
            kind: graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].OPERATION_DEFINITION,
            operation: operation.operation,
            name: operation.name,
            directives: operation.directives,
            variableDefinitions: variableDefinitions,
            selectionSet: selectionSet,
        });
    });
    var newVariables = usedVariables.reduce(function (acc, variableName) {
        acc[variableName] = variables[variableName];
        return acc;
    }, {});
    return {
        document: {
            kind: graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].DOCUMENT,
            definitions: Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __spreadArrays */ "d"])(newOperations, newFragments),
        },
        variables: newVariables,
    };
}
function collectFragmentVariables(targetSchema, fragmentSet, validFragments, validFragmentsWithType, usedFragments) {
    var remainingFragments = usedFragments.slice();
    var usedVariables = [];
    var newFragments = [];
    var _loop_1 = function () {
        var nextFragmentName = remainingFragments.pop();
        var fragment = validFragments.find(function (fr) { return fr.name.value === nextFragmentName; });
        if (fragment != null) {
            var name_1 = nextFragmentName;
            var typeName = fragment.typeCondition.name.value;
            var type = targetSchema.getType(typeName);
            var _a = filterSelectionSet(targetSchema, type, validFragmentsWithType, fragment.selectionSet), selectionSet = _a.selectionSet, fragmentUsedFragments = _a.usedFragments, fragmentUsedVariables = _a.usedVariables;
            remainingFragments = union(remainingFragments, fragmentUsedFragments);
            usedVariables = union(usedVariables, fragmentUsedVariables);
            if (!(name_1 in fragmentSet)) {
                fragmentSet[name_1] = true;
                newFragments.push({
                    kind: graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].FRAGMENT_DEFINITION,
                    name: {
                        kind: graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].NAME,
                        value: name_1,
                    },
                    typeCondition: fragment.typeCondition,
                    selectionSet: selectionSet,
                });
            }
        }
    };
    while (remainingFragments.length !== 0) {
        _loop_1();
    }
    return {
        usedVariables: usedVariables,
        newFragments: newFragments,
        fragmentSet: fragmentSet,
    };
}
function filterSelectionSet(schema, type, validFragments, selectionSet) {
    var _a;
    var usedFragments = [];
    var usedVariables = [];
    var typeInfo = new graphql__WEBPACK_IMPORTED_MODULE_3__["TypeInfo"](schema, undefined, type);
    var filteredSelectionSet = Object(graphql__WEBPACK_IMPORTED_MODULE_3__["visit"])(selectionSet, Object(graphql__WEBPACK_IMPORTED_MODULE_3__["visitWithTypeInfo"])(typeInfo, (_a = {},
        _a[graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].FIELD] = {
            enter: function (node) {
                var parentType = typeInfo.getParentType();
                if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isObjectType"])(parentType) || Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isInterfaceType"])(parentType)) {
                    var fields = parentType.getFields();
                    var field = node.name.value === '__typename'
                        ? graphql__WEBPACK_IMPORTED_MODULE_3__["TypeNameMetaFieldDef"]
                        : fields[node.name.value];
                    if (!field) {
                        return null;
                    }
                    var argNames_1 = (field.args != null ? field.args : []).map(function (arg) { return arg.name; });
                    if (node.arguments != null) {
                        var args = node.arguments.filter(function (arg) { return argNames_1.indexOf(arg.name.value) !== -1; });
                        if (args.length !== node.arguments.length) {
                            return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, node), { arguments: args });
                        }
                    }
                }
            },
            leave: function (node) {
                var _a;
                var resolvedType = Object(graphql__WEBPACK_IMPORTED_MODULE_3__["getNamedType"])(typeInfo.getType());
                if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isObjectType"])(resolvedType) || Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isInterfaceType"])(resolvedType)) {
                    var selections = node.selectionSet != null ? node.selectionSet.selections : null;
                    if (selections == null || selections.length === 0) {
                        // need to remove any added variables. Is there a better way to do this?
                        Object(graphql__WEBPACK_IMPORTED_MODULE_3__["visit"])(node, (_a = {},
                            _a[graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].VARIABLE] = function (variableNode) {
                                var index = usedVariables.indexOf(variableNode.name.value);
                                if (index !== -1) {
                                    usedVariables.splice(index, 1);
                                }
                            },
                            _a));
                        return null;
                    }
                }
            },
        },
        _a[graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].FRAGMENT_SPREAD] = function (node) {
            if (node.name.value in validFragments) {
                var parentType = typeInfo.getParentType();
                var innerType = validFragments[node.name.value];
                if (!implementsAbstractType(schema, parentType, innerType)) {
                    return null;
                }
                usedFragments.push(node.name.value);
                return;
            }
            return null;
        },
        _a[graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].INLINE_FRAGMENT] = {
            enter: function (node) {
                if (node.typeCondition != null) {
                    var parentType = typeInfo.getParentType();
                    var innerType = schema.getType(node.typeCondition.name.value);
                    if (!implementsAbstractType(schema, parentType, innerType)) {
                        return null;
                    }
                }
            },
        },
        _a[graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].VARIABLE] = function (node) {
            usedVariables.push(node.name.value);
        },
        _a)));
    return {
        selectionSet: filteredSelectionSet,
        usedFragments: usedFragments,
        usedVariables: usedVariables,
    };
}
function union() {
    var arrays = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        arrays[_i] = arguments[_i];
    }
    var cache = Object.create(null);
    var result = [];
    arrays.forEach(function (array) {
        array.forEach(function (item) {
            if (!(item in cache)) {
                cache[item] = true;
                result.push(item);
            }
        });
    });
    return result;
}

var AddReplacementSelectionSets = /** @class */ (function () {
    function AddReplacementSelectionSets(schema, mapping) {
        this.schema = schema;
        this.mapping = mapping;
    }
    AddReplacementSelectionSets.prototype.transformRequest = function (originalRequest) {
        var document = replaceFieldsWithSelectionSet(this.schema, originalRequest.document, this.mapping);
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, originalRequest), { document: document });
    };
    return AddReplacementSelectionSets;
}());
function replaceFieldsWithSelectionSet(schema, document, mapping) {
    var _a;
    var typeInfo = new graphql__WEBPACK_IMPORTED_MODULE_3__["TypeInfo"](schema);
    return Object(graphql__WEBPACK_IMPORTED_MODULE_3__["visit"])(document, Object(graphql__WEBPACK_IMPORTED_MODULE_3__["visitWithTypeInfo"])(typeInfo, (_a = {},
        _a[graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].SELECTION_SET] = function (node) {
            var parentType = typeInfo.getParentType();
            if (parentType != null) {
                var parentTypeName_1 = parentType.name;
                var selections_1 = node.selections;
                if (parentTypeName_1 in mapping) {
                    node.selections.forEach(function (selection) {
                        if (selection.kind === graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].FIELD) {
                            var name_1 = selection.name.value;
                            var selectionSet = mapping[parentTypeName_1][name_1];
                            if (selectionSet != null) {
                                selections_1 = selections_1.concat(selectionSet.selections);
                            }
                        }
                    });
                }
                if (selections_1 !== node.selections) {
                    return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, node), { selections: selections_1 });
                }
            }
        },
        _a)));
}

var AddReplacementFragments = /** @class */ (function () {
    function AddReplacementFragments(targetSchema, mapping) {
        this.targetSchema = targetSchema;
        this.mapping = mapping;
    }
    AddReplacementFragments.prototype.transformRequest = function (originalRequest) {
        var document = replaceFieldsWithFragments(this.targetSchema, originalRequest.document, this.mapping);
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, originalRequest), { document: document });
    };
    return AddReplacementFragments;
}());
function replaceFieldsWithFragments(targetSchema, document, mapping) {
    var _a;
    var typeInfo = new graphql__WEBPACK_IMPORTED_MODULE_3__["TypeInfo"](targetSchema);
    return Object(graphql__WEBPACK_IMPORTED_MODULE_3__["visit"])(document, Object(graphql__WEBPACK_IMPORTED_MODULE_3__["visitWithTypeInfo"])(typeInfo, (_a = {},
        _a[graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].SELECTION_SET] = function (node) {
            var parentType = typeInfo.getParentType();
            if (parentType != null) {
                var parentTypeName_1 = parentType.name;
                var selections_1 = node.selections;
                if (parentTypeName_1 in mapping) {
                    node.selections.forEach(function (selection) {
                        if (selection.kind === graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].FIELD) {
                            var name_1 = selection.name.value;
                            var fragment = mapping[parentTypeName_1][name_1];
                            if (fragment != null) {
                                selections_1 = selections_1.concat(fragment);
                            }
                        }
                    });
                }
                if (selections_1 !== node.selections) {
                    return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, node), { selections: selections_1 });
                }
            }
        },
        _a)));
}

var AddMergedTypeFragments = /** @class */ (function () {
    function AddMergedTypeFragments(targetSchema, mapping) {
        this.targetSchema = targetSchema;
        this.mapping = mapping;
    }
    AddMergedTypeFragments.prototype.transformRequest = function (originalRequest) {
        var document = addMergedTypeSelectionSets(this.targetSchema, originalRequest.document, this.mapping);
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, originalRequest), { document: document });
    };
    return AddMergedTypeFragments;
}());
function addMergedTypeSelectionSets(targetSchema, document, mapping) {
    var _a;
    var typeInfo = new graphql__WEBPACK_IMPORTED_MODULE_3__["TypeInfo"](targetSchema);
    return Object(graphql__WEBPACK_IMPORTED_MODULE_3__["visit"])(document, Object(graphql__WEBPACK_IMPORTED_MODULE_3__["visitWithTypeInfo"])(typeInfo, (_a = {},
        _a[graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].SELECTION_SET] = function (node) {
            var parentType = typeInfo.getParentType();
            if (parentType != null) {
                var parentTypeName = parentType.name;
                var selections = node.selections;
                if (parentTypeName in mapping) {
                    var selectionSet = mapping[parentTypeName].selectionSet;
                    if (selectionSet != null) {
                        selections = selections.concat(selectionSet.selections);
                    }
                }
                if (selections !== node.selections) {
                    return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, node), { selections: selections });
                }
            }
        },
        _a)));
}

function addTypenameToAbstract(targetSchema, document) {
    var _a;
    var typeInfo = new graphql__WEBPACK_IMPORTED_MODULE_3__["TypeInfo"](targetSchema);
    return Object(graphql__WEBPACK_IMPORTED_MODULE_3__["visit"])(document, Object(graphql__WEBPACK_IMPORTED_MODULE_3__["visitWithTypeInfo"])(typeInfo, (_a = {},
        _a[graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].SELECTION_SET] = function (node) {
            var parentType = typeInfo.getParentType();
            var selections = node.selections;
            if (parentType != null && Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isAbstractType"])(parentType)) {
                selections = selections.concat({
                    kind: graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].FIELD,
                    name: {
                        kind: graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].NAME,
                        value: '__typename',
                    },
                });
            }
            if (selections !== node.selections) {
                return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, node), { selections: selections });
            }
        },
        _a)));
}

var AddTypenameToAbstract = /** @class */ (function () {
    function AddTypenameToAbstract(targetSchema) {
        this.targetSchema = targetSchema;
    }
    AddTypenameToAbstract.prototype.transformRequest = function (originalRequest) {
        var document = addTypenameToAbstract(this.targetSchema, originalRequest.document);
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, originalRequest), { document: document });
    };
    return AddTypenameToAbstract;
}());

/**
 * Get the key under which the result of this resolver will be placed in the response JSON. Basically, just
 * resolves aliases.
 * @param info The info argument to the resolver.
 */
function getResponseKeyFromInfo(info) {
    return info.fieldNodes[0].alias != null
        ? info.fieldNodes[0].alias.value
        : info.fieldName;
}

var hasSymbol = (typeof global !== 'undefined' && 'Symbol' in global) ||
    // eslint-disable-next-line no-undef
    (typeof window !== 'undefined' && 'Symbol' in window);
var OBJECT_SUBSCHEMA_SYMBOL = hasSymbol
    ? Symbol('initialSubschema')
    : '@@__initialSubschema';
var FIELD_SUBSCHEMA_MAP_SYMBOL = hasSymbol
    ? Symbol('subschemaMap')
    : '@@__subschemaMap';
var ERROR_SYMBOL = hasSymbol
    ? Symbol('subschemaErrors')
    : '@@__subschemaErrors';

function relocatedError(originalError, nodes, path) {
    if (Array.isArray(originalError.path)) {
        return new graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLError"](originalError.message, originalError.nodes, originalError.source, originalError.positions, path != null ? path : originalError.path, originalError.originalError, originalError.extensions);
    }
    if (originalError == null) {
        return new graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLError"](undefined, nodes, undefined, undefined, path, originalError);
    }
    return new graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLError"](originalError.message, originalError.nodes != null
        ? originalError.nodes
        : nodes, originalError.source, originalError.positions, path, originalError);
}
function slicedError(originalError) {
    return relocatedError(originalError, originalError.nodes, originalError.path != null ? originalError.path.slice(1) : undefined);
}
function getErrorsByPathSegment(errors) {
    var record = Object.create(null);
    errors.forEach(function (error) {
        if (!error.path || error.path.length < 2) {
            return;
        }
        var pathSegment = error.path[1];
        var current = pathSegment in record ? record[pathSegment] : [];
        current.push(slicedError(error));
        record[pathSegment] = current;
    });
    return record;
}
var CombinedError = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __extends */ "b"])(CombinedError, _super);
    function CombinedError(message, errors) {
        var _this = _super.call(this, message) || this;
        _this.errors = errors;
        return _this;
    }
    return CombinedError;
}(Error));
function combineErrors(errors) {
    if (errors.length === 1) {
        return new graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLError"](errors[0].message, errors[0].nodes, errors[0].source, errors[0].positions, errors[0].path, errors[0].originalError, errors[0].extensions);
    }
    return new CombinedError(errors.map(function (error) { return error.message; }).join('\n'), errors);
}
function setErrors(result, errors) {
    result[ERROR_SYMBOL] = errors;
}
function getErrors(result, pathSegment) {
    var errors = result != null ? result[ERROR_SYMBOL] : result;
    if (!Array.isArray(errors)) {
        return null;
    }
    var fieldErrors = [];
    for (var _i = 0, errors_1 = errors; _i < errors_1.length; _i++) {
        var error = errors_1[_i];
        if (!error.path || error.path[0] === pathSegment) {
            fieldErrors.push(error);
        }
    }
    return fieldErrors;
}

function handleNull(fieldNodes, path, errors) {
    if (errors.length) {
        if (errors.some(function (error) { return !error.path || error.path.length < 2; })) {
            return relocatedError(combineErrors(errors), fieldNodes, path);
        }
        else if (errors.some(function (error) { return typeof error.path[1] === 'string'; })) {
            var childErrors_1 = getErrorsByPathSegment(errors);
            var result_1 = {};
            Object.keys(childErrors_1).forEach(function (pathSegment) {
                result_1[pathSegment] = handleNull(fieldNodes, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __spreadArrays */ "d"])(path, [pathSegment]), childErrors_1[pathSegment]);
            });
            return result_1;
        }
        var childErrors_2 = getErrorsByPathSegment(errors);
        var result_2 = [];
        Object.keys(childErrors_2).forEach(function (pathSegment) {
            result_2.push(handleNull(fieldNodes, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __spreadArrays */ "d"])(path, [parseInt(pathSegment, 10)]), childErrors_2[pathSegment]));
        });
        return result_2;
    }
    return null;
}

/**
 * Given a selectionSet, adds all of the fields in that selection to
 * the passed in map of fields, and returns it at the end.
 *
 * CollectFields requires the "runtime type" of an object. For a field which
 * returns an Interface or Union type, the "runtime type" will be the actual
 * Object type returned by that field.
 *
 * @internal
 */
function collectFields(exeContext, runtimeType, selectionSet, fields, visitedFragmentNames) {
    for (var _i = 0, _a = selectionSet.selections; _i < _a.length; _i++) {
        var selection = _a[_i];
        switch (selection.kind) {
            case graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].FIELD: {
                if (!shouldIncludeNode(exeContext, selection)) {
                    continue;
                }
                var name_1 = getFieldEntryKey(selection);
                if (!(name_1 in fields)) {
                    fields[name_1] = [];
                }
                fields[name_1].push(selection);
                break;
            }
            case graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].INLINE_FRAGMENT: {
                if (!shouldIncludeNode(exeContext, selection) ||
                    !doesFragmentConditionMatch(exeContext, selection, runtimeType)) {
                    continue;
                }
                collectFields(exeContext, runtimeType, selection.selectionSet, fields, visitedFragmentNames);
                break;
            }
            case graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].FRAGMENT_SPREAD: {
                var fragName = selection.name.value;
                if (visitedFragmentNames[fragName] ||
                    !shouldIncludeNode(exeContext, selection)) {
                    continue;
                }
                visitedFragmentNames[fragName] = true;
                var fragment = exeContext.fragments[fragName];
                if (!fragment ||
                    !doesFragmentConditionMatch(exeContext, fragment, runtimeType)) {
                    continue;
                }
                collectFields(exeContext, runtimeType, fragment.selectionSet, fields, visitedFragmentNames);
                break;
            }
        }
    }
    return fields;
}
/**
 * Determines if a field should be included based on the @include and @skip
 * directives, where @skip has higher precedence than @include.
 */
function shouldIncludeNode(exeContext, node) {
    var skip = Object(graphql__WEBPACK_IMPORTED_MODULE_3__["getDirectiveValues"])(graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLSkipDirective"], node, exeContext.variableValues);
    if ((skip === null || skip === void 0 ? void 0 : skip.if) === true) {
        return false;
    }
    var include = Object(graphql__WEBPACK_IMPORTED_MODULE_3__["getDirectiveValues"])(graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLIncludeDirective"], node, exeContext.variableValues);
    if ((include === null || include === void 0 ? void 0 : include.if) === false) {
        return false;
    }
    return true;
}
/**
 * Determines if a fragment is applicable to the given type.
 */
function doesFragmentConditionMatch(exeContext, fragment, type) {
    var typeConditionNode = fragment.typeCondition;
    if (!typeConditionNode) {
        return true;
    }
    var conditionalType = Object(graphql__WEBPACK_IMPORTED_MODULE_3__["typeFromAST"])(exeContext.schema, typeConditionNode);
    if (conditionalType === type) {
        return true;
    }
    if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isAbstractType"])(conditionalType)) {
        return exeContext.schema.isPossibleType(conditionalType, type);
    }
    return false;
}
/**
 * Implements the logic to compute the key of a given field's entry
 */
function getFieldEntryKey(node) {
    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
    return node.alias ? node.alias.value : node.name.value;
}

function getSubschema(result, responseKey) {
    var subschema = result[FIELD_SUBSCHEMA_MAP_SYMBOL] &&
        result[FIELD_SUBSCHEMA_MAP_SYMBOL][responseKey];
    return subschema ? subschema : result[OBJECT_SUBSCHEMA_SYMBOL];
}
function setObjectSubschema(result, subschema) {
    result[OBJECT_SUBSCHEMA_SYMBOL] = subschema;
}

function resolveFromParentTypename(parent) {
    var parentTypename = parent['__typename'];
    if (!parentTypename) {
        throw new Error('Did not fetch typename for object, unable to resolve interface.');
    }
    return parentTypename;
}

function mergeDeep(target) {
    var sources = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        sources[_i - 1] = arguments[_i];
    }
    var output = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, target);
    sources.forEach(function (source) {
        if (isObject(target) && isObject(source)) {
            Object.keys(source).forEach(function (key) {
                var _a, _b;
                if (isObject(source[key])) {
                    if (!(key in target)) {
                        Object.assign(output, (_a = {}, _a[key] = source[key], _a));
                    }
                    else {
                        output[key] = mergeDeep(target[key], source[key]);
                    }
                }
                else {
                    Object.assign(output, (_b = {}, _b[key] = source[key], _b));
                }
            });
        }
    });
    return output;
}
function isObject(item) {
    return item && typeof item === 'object' && !Array.isArray(item);
}

function unwrapResult(parent, info, path) {
    var newParent = parent;
    var pathLength = path.length;
    for (var i = 0; i < pathLength; i++) {
        var responseKey = path[i];
        var errors = getErrors(newParent, responseKey);
        var subschema = getSubschema(newParent, responseKey);
        var object = newParent[responseKey];
        if (object == null) {
            return handleNull(info.fieldNodes, Object(graphql__WEBPACK_IMPORTED_MODULE_3__["responsePathAsArray"])(info.path), errors);
        }
        setErrors(object, errors.map(function (error) {
            return relocatedError(error, error.nodes, error.path != null ? error.path.slice(1) : undefined);
        }));
        setObjectSubschema(object, subschema);
        newParent = object;
    }
    return newParent;
}
function dehoistResult(parent, delimeter) {
    if (delimeter === void 0) { delimeter = '__gqltf__'; }
    var result = Object.create(null);
    Object.keys(parent).forEach(function (alias) {
        var obj = result;
        var fieldNames = alias.split(delimeter);
        var fieldName = fieldNames.pop();
        fieldNames.forEach(function (key) {
            obj = obj[key] = obj[key] || Object.create(null);
        });
        obj[fieldName] = parent[alias];
    });
    result[ERROR_SYMBOL] = parent[ERROR_SYMBOL].map(function (error) {
        if (error.path != null) {
            var path = error.path.slice();
            var pathSegment = path.shift();
            var expandedPathSegment = pathSegment.split(delimeter);
            return relocatedError(error, error.nodes, expandedPathSegment.concat(path));
        }
        return error;
    });
    result[OBJECT_SUBSCHEMA_SYMBOL] = parent[OBJECT_SUBSCHEMA_SYMBOL];
    return result;
}
function mergeProxiedResults(target) {
    var sources = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        sources[_i - 1] = arguments[_i];
    }
    var errors = target[ERROR_SYMBOL].concat(sources.map(function (source) { return source[ERROR_SYMBOL]; }));
    var fieldSubschemaMap = sources.reduce(function (acc, source) {
        var subschema = source[OBJECT_SUBSCHEMA_SYMBOL];
        Object.keys(source).forEach(function (key) {
            acc[key] = subschema;
        });
        return acc;
    }, {});
    var result = mergeDeep.apply(void 0, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __spreadArrays */ "d"])([target], sources));
    result[ERROR_SYMBOL] = errors;
    result[FIELD_SUBSCHEMA_MAP_SYMBOL] = target[FIELD_SUBSCHEMA_MAP_SYMBOL]
        ? mergeDeep(target[FIELD_SUBSCHEMA_MAP_SYMBOL], fieldSubschemaMap)
        : fieldSubschemaMap;
    return result;
}

function buildDelegationPlan(mergedTypeInfo, originalSelections, sourceSubschemas, targetSubschemas) {
    // 1.  calculate if possible to delegate to given subschema
    //    TODO: change logic so that required selection set can be spread across multiple subschemas?
    var proxiableSubschemas = [];
    var nonProxiableSubschemas = [];
    targetSubschemas.forEach(function (t) {
        if (sourceSubschemas.some(function (s) {
            var selectionSet = mergedTypeInfo.selectionSets.get(t);
            return mergedTypeInfo.containsSelectionSet.get(s).get(selectionSet);
        })) {
            proxiableSubschemas.push(t);
        }
        else {
            nonProxiableSubschemas.push(t);
        }
    });
    var uniqueFields = mergedTypeInfo.uniqueFields, nonUniqueFields = mergedTypeInfo.nonUniqueFields;
    var unproxiableSelections = [];
    // 2. for each selection:
    var delegationMap = new Map();
    originalSelections.forEach(function (selection) {
        // 2a. use uniqueFields map to assign fields to subschema if one of possible subschemas
        var uniqueSubschema = uniqueFields[selection.name.value];
        if (uniqueSubschema != null) {
            if (proxiableSubschemas.includes(uniqueSubschema)) {
                var existingSubschema = delegationMap.get(uniqueSubschema);
                if (existingSubschema != null) {
                    existingSubschema.push(selection);
                }
                else {
                    delegationMap.set(uniqueSubschema, [selection]);
                }
            }
            else {
                unproxiableSelections.push(selection);
            }
        }
        else {
            // 2b. use nonUniqueFields to assign to a possible subschema,
            //     preferring one of the subschemas already targets of delegation
            var nonUniqueSubschemas = nonUniqueFields[selection.name.value];
            nonUniqueSubschemas = nonUniqueSubschemas.filter(function (s) {
                return proxiableSubschemas.includes(s);
            });
            if (nonUniqueSubschemas != null) {
                var subschemas_1 = Array.from(delegationMap.keys());
                var existingSubschema = nonUniqueSubschemas.find(function (s) {
                    return subschemas_1.includes(s);
                });
                if (existingSubschema != null) {
                    delegationMap.get(existingSubschema).push(selection);
                }
                else {
                    delegationMap.set(nonUniqueSubschemas[0], [selection]);
                }
            }
            else {
                unproxiableSelections.push(selection);
            }
        }
    });
    return {
        delegationMap: delegationMap,
        unproxiableSelections: unproxiableSelections,
        proxiableSubschemas: proxiableSubschemas,
        nonProxiableSubschemas: nonProxiableSubschemas,
    };
}
function mergeFields(mergedTypeInfo, typeName, object, originalSelections, sourceSubschemas, targetSubschemas, context, info) {
    if (!originalSelections.length) {
        return object;
    }
    var _a = buildDelegationPlan(mergedTypeInfo, originalSelections, sourceSubschemas, targetSubschemas), delegationMap = _a.delegationMap, unproxiableSelections = _a.unproxiableSelections, proxiableSubschemas = _a.proxiableSubschemas, nonProxiableSubschemas = _a.nonProxiableSubschemas;
    if (!delegationMap.size) {
        return object;
    }
    var maybePromises = [];
    delegationMap.forEach(function (selections, s) {
        var maybePromise = s.merge[typeName].resolve(object, context, info, s, {
            kind: graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].SELECTION_SET,
            selections: selections,
        });
        maybePromises.push(maybePromise);
    });
    var containsPromises = false;
    for (var _i = 0, maybePromises_1 = maybePromises; _i < maybePromises_1.length; _i++) {
        var maybePromise = maybePromises_1[_i];
        if (maybePromise instanceof Promise) {
            containsPromises = true;
            break;
        }
    }
    return containsPromises
        ? Promise.all(maybePromises).then(function (results) {
            return mergeFields(mergedTypeInfo, typeName, mergeProxiedResults.apply(void 0, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __spreadArrays */ "d"])([object], results)), unproxiableSelections, sourceSubschemas.concat(proxiableSubschemas), nonProxiableSubschemas, context, info);
        })
        : mergeFields(mergedTypeInfo, typeName, mergeProxiedResults.apply(void 0, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __spreadArrays */ "d"])([object], maybePromises)), unproxiableSelections, sourceSubschemas.concat(proxiableSubschemas), nonProxiableSubschemas, context, info);
}

function handleObject(type, object, errors, subschema, context, info, skipTypeMerging) {
    setErrors(object, errors.map(function (error) {
        return relocatedError(error, error.nodes, error.path != null ? error.path.slice(1) : undefined);
    }));
    setObjectSubschema(object, subschema);
    if (skipTypeMerging || !info.mergeInfo) {
        return object;
    }
    var typeName = Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isAbstractType"])(type)
        ? info.schema.getTypeMap()[resolveFromParentTypename(object)].name
        : type.name;
    var mergedTypeInfo = info.mergeInfo.mergedTypes[typeName];
    var targetSubschemas;
    if (mergedTypeInfo != null) {
        targetSubschemas = mergedTypeInfo.subschemas;
    }
    if (!targetSubschemas) {
        return object;
    }
    targetSubschemas = targetSubschemas.filter(function (s) { return s !== subschema; });
    if (!targetSubschemas.length) {
        return object;
    }
    var subFields = collectSubFields(info, object.__typename);
    var selections = getFieldsNotInSubschema(subFields, subschema, mergedTypeInfo, object.__typename);
    return mergeFields(mergedTypeInfo, typeName, object, selections, [subschema], targetSubschemas, context, info);
}
function collectSubFields(info, typeName) {
    var subFieldNodes = Object.create(null);
    var visitedFragmentNames = Object.create(null);
    info.fieldNodes.forEach(function (fieldNode) {
        subFieldNodes = collectFields({
            schema: info.schema,
            variableValues: info.variableValues,
            fragments: info.fragments,
        }, info.schema.getType(typeName), fieldNode.selectionSet, subFieldNodes, visitedFragmentNames);
    });
    return subFieldNodes;
}
function getFieldsNotInSubschema(subFieldNodes, subschema, mergedTypeInfo, typeName) {
    var typeMap = isSubschemaConfig(subschema)
        ? mergedTypeInfo.typeMaps.get(subschema)
        : subschema.getTypeMap();
    var fields = typeMap[typeName].getFields();
    var fieldsNotInSchema = [];
    Object.keys(subFieldNodes).forEach(function (responseName) {
        subFieldNodes[responseName].forEach(function (subFieldNode) {
            if (!(subFieldNode.name.value in fields)) {
                fieldsNotInSchema.push(subFieldNode);
            }
        });
    });
    return fieldsNotInSchema;
}

function handleList(type, list, errors, subschema, context, info, skipTypeMerging) {
    var childErrors = getErrorsByPathSegment(errors);
    return list.map(function (listMember, index) {
        return handleListMember(Object(graphql__WEBPACK_IMPORTED_MODULE_3__["getNullableType"])(type.ofType), listMember, index, index in childErrors ? childErrors[index] : [], subschema, context, info, skipTypeMerging);
    });
}
function handleListMember(type, listMember, index, errors, subschema, context, info, skipTypeMerging) {
    if (listMember == null) {
        return handleNull(info.fieldNodes, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __spreadArrays */ "d"])(Object(graphql__WEBPACK_IMPORTED_MODULE_3__["responsePathAsArray"])(info.path), [index]), errors);
    }
    if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isLeafType"])(type)) {
        return type.parseValue(listMember);
    }
    else if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isCompositeType"])(type)) {
        return handleObject(type, listMember, errors, subschema, context, info, skipTypeMerging);
    }
    else if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isListType"])(type)) {
        return handleList(type, listMember, errors, subschema, context, info, skipTypeMerging);
    }
}

function checkResultAndHandleErrors(result, context, info, responseKey, subschema, returnType, skipTypeMerging) {
    if (responseKey === void 0) { responseKey = getResponseKeyFromInfo(info); }
    if (returnType === void 0) { returnType = info.returnType; }
    var errors = result.errors != null ? result.errors : [];
    var data = result.data != null ? result.data[responseKey] : undefined;
    return handleResult(data, errors, subschema, context, info, returnType, skipTypeMerging);
}
function handleResult(result, errors, subschema, context, info, returnType, skipTypeMerging) {
    if (returnType === void 0) { returnType = info.returnType; }
    var type = Object(graphql__WEBPACK_IMPORTED_MODULE_3__["getNullableType"])(returnType);
    if (result == null) {
        return handleNull(info.fieldNodes, Object(graphql__WEBPACK_IMPORTED_MODULE_3__["responsePathAsArray"])(info.path), errors);
    }
    if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isLeafType"])(type)) {
        return type.parseValue(result);
    }
    else if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isCompositeType"])(type)) {
        return handleObject(type, result, errors, subschema, context, info, skipTypeMerging);
    }
    else if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isListType"])(type)) {
        return handleList(type, result, errors, subschema, context, info, skipTypeMerging);
    }
}

var CheckResultAndHandleErrors = /** @class */ (function () {
    function CheckResultAndHandleErrors(info, fieldName, subschema, context, returnType, typeMerge) {
        if (returnType === void 0) { returnType = info.returnType; }
        this.context = context;
        this.info = info;
        this.fieldName = fieldName;
        this.subschema = subschema;
        this.returnType = returnType;
        this.typeMerge = typeMerge;
    }
    CheckResultAndHandleErrors.prototype.transformResult = function (result) {
        return checkResultAndHandleErrors(result, this.context != null ? this.context : {}, this.info, this.fieldName, this.subschema, this.returnType, this.typeMerge);
    };
    return CheckResultAndHandleErrors;
}());

function transformInputValue(type, value, transformer) {
    if (value == null) {
        return value;
    }
    var nullableType = Object(graphql__WEBPACK_IMPORTED_MODULE_3__["getNullableType"])(type);
    if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isLeafType"])(nullableType)) {
        return transformer(nullableType, value);
    }
    else if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isListType"])(nullableType)) {
        return value.map(function (listMember) {
            return transformInputValue(nullableType.ofType, listMember, transformer);
        });
    }
    else if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isInputObjectType"])(nullableType)) {
        var fields_1 = nullableType.getFields();
        return keyValMap(Object.keys(value), function (key) { return key; }, function (key) { return transformInputValue(fields_1[key].type, value[key], transformer); });
    }
    // unreachable, no other possible return value
}
function serializeInputValue(type, value) {
    return transformInputValue(type, value, function (t, v) { return t.serialize(v); });
}
function parseInputValue(type, value) {
    return transformInputValue(type, value, function (t, v) { return t.parseValue(v); });
}

function astFromType(type) {
    if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isNonNullType"])(type)) {
        var innerType = astFromType(type.ofType);
        if (innerType.kind === graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].NON_NULL_TYPE) {
            throw new Error("Invalid type node " + JSON.stringify(type) + ". Inner type of non-null type cannot be a non-null type.");
        }
        return {
            kind: graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].NON_NULL_TYPE,
            type: innerType,
        };
    }
    else if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isListType"])(type)) {
        return {
            kind: graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].LIST_TYPE,
            type: astFromType(type.ofType),
        };
    }
    return {
        kind: graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].NAMED_TYPE,
        name: {
            kind: graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].NAME,
            value: type.name,
        },
    };
}

function updateArgument(argName, argType, argumentNodes, variableDefinitionsMap, variableValues, newArg) {
    var varName;
    var numGeneratedVariables = 0;
    do {
        varName = "_v" + (numGeneratedVariables++).toString() + "_" + argName;
    } while (varName in variableDefinitionsMap);
    argumentNodes[argName] = {
        kind: graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].ARGUMENT,
        name: {
            kind: graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].NAME,
            value: argName,
        },
        value: {
            kind: graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].VARIABLE,
            name: {
                kind: graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].NAME,
                value: varName,
            },
        },
    };
    variableDefinitionsMap[varName] = {
        kind: graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].VARIABLE_DEFINITION,
        variable: {
            kind: graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].VARIABLE,
            name: {
                kind: graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].NAME,
                value: varName,
            },
        },
        type: astFromType(argType),
    };
    variableValues[varName] = newArg;
}

function toObjMap(obj) {
    if (Object.getPrototypeOf(obj) === null) {
        return obj;
    }
    return Object.entries(obj).reduce(function (map, _a) {
        var key = _a[0], value = _a[1];
        map[key] = value;
        return map;
    }, Object.create(null));
}

var AddArgumentsAsVariables = /** @class */ (function () {
    function AddArgumentsAsVariables(targetSchema, args) {
        this.targetSchema = targetSchema;
        this.args = toObjMap(args);
    }
    AddArgumentsAsVariables.prototype.transformRequest = function (originalRequest) {
        var _a = addVariablesToRootField(this.targetSchema, originalRequest, this.args), document = _a.document, newVariables = _a.newVariables;
        return {
            document: document,
            variables: newVariables,
        };
    };
    return AddArgumentsAsVariables;
}());
function addVariablesToRootField(targetSchema, originalRequest, args) {
    var document = originalRequest.document;
    var variableValues = originalRequest.variables;
    var operations = document.definitions.filter(function (def) { return def.kind === graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].OPERATION_DEFINITION; });
    var fragments = document.definitions.filter(function (def) { return def.kind === graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].FRAGMENT_DEFINITION; });
    var newOperations = operations.map(function (operation) {
        var variableDefinitionMap = keyValMap(operation.variableDefinitions, function (def) { return def.variable.name.value; }, function (def) { return def; });
        var type;
        if (operation.operation === 'subscription') {
            type = targetSchema.getSubscriptionType();
        }
        else if (operation.operation === 'mutation') {
            type = targetSchema.getMutationType();
        }
        else {
            type = targetSchema.getQueryType();
        }
        var newSelectionSet = [];
        operation.selectionSet.selections.forEach(function (selection) {
            if (selection.kind === graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].FIELD) {
                var argumentNodes = selection.arguments;
                var argumentNodeMap_1 = keyValMap(argumentNodes, function (argument) { return argument.name.value; }, function (argument) { return argument; });
                var targetField = type.getFields()[selection.name.value];
                // excludes __typename
                if (targetField != null) {
                    updateArguments(targetField, argumentNodeMap_1, variableDefinitionMap, variableValues, args);
                }
                newSelectionSet.push(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, selection), { arguments: Object.keys(argumentNodeMap_1).map(function (argName) { return argumentNodeMap_1[argName]; }) }));
            }
            else {
                newSelectionSet.push(selection);
            }
        });
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, operation), { variableDefinitions: Object.keys(variableDefinitionMap).map(function (varName) { return variableDefinitionMap[varName]; }), selectionSet: {
                kind: graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].SELECTION_SET,
                selections: newSelectionSet,
            } });
    });
    return {
        document: Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, document), { definitions: Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __spreadArrays */ "d"])(newOperations, fragments) }),
        newVariables: variableValues,
    };
}
function updateArguments(targetField, argumentNodeMap, variableDefinitionMap, variableValues, newArgs) {
    targetField.args.forEach(function (argument) {
        var argName = argument.name;
        var argType = argument.type;
        if (argName in newArgs) {
            updateArgument(argName, argType, argumentNodeMap, variableDefinitionMap, variableValues, serializeInputValue(argType, newArgs[argName]));
        }
    });
}

var version;
if (graphql__WEBPACK_IMPORTED_MODULE_3__["versionInfo"] != null && graphql__WEBPACK_IMPORTED_MODULE_3__["versionInfo"].major >= 15) {
    version = 15;
}
else if (graphql__WEBPACK_IMPORTED_MODULE_3__["getOperationRootType"] != null) {
    version = 14;
}
else if (graphql__WEBPACK_IMPORTED_MODULE_3__["lexicographicSortSchema"] != null) {
    version = 13;
}
else if (graphql__WEBPACK_IMPORTED_MODULE_3__["printError"] != null) {
    version = 12;
}
else {
    version = 11;
}
function graphqlVersion() {
    return version;
}

var hasOwn = Object.prototype.hasOwnProperty;
function hasOwnProperty(object, propertyName) {
    return hasOwn.call(object, propertyName);
}

// graphql <v14.2 does not support toConfig
function schemaToConfig(schema) {
    if (schema.toConfig != null) {
        return schema.toConfig();
    }
    var newTypes = [];
    var types = schema.getTypeMap();
    Object.keys(types).forEach(function (typeName) {
        newTypes.push(types[typeName]);
    });
    var schemaConfig = {
        query: schema.getQueryType(),
        mutation: schema.getMutationType(),
        subscription: schema.getSubscriptionType(),
        types: newTypes,
        directives: schema.getDirectives().slice(),
        extensions: schema.extensions,
        astNode: schema.astNode,
        extensionASTNodes: schema.extensionASTNodes != null ? schema.extensionASTNodes : [],
        assumeValid: schema.__validationErrors !==
            undefined,
    };
    if (graphqlVersion() >= 15) {
        schemaConfig.description = schema.description;
    }
    return schemaConfig;
}
function toConfig(graphqlObject) {
    if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isSchema"])(graphqlObject)) {
        return schemaToConfig(graphqlObject);
    }
    else if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isDirective"])(graphqlObject)) {
        return directiveToConfig(graphqlObject);
    }
    else if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isNamedType"])(graphqlObject)) {
        return typeToConfig(graphqlObject);
    }
    // Input and output fields do not have predicates defined, but using duck typing,
    // type is defined for input and output fields
    if (graphqlObject.type != null) {
        if (graphqlObject.args != null ||
            graphqlObject.resolve != null ||
            graphqlObject.subscribe != null) {
            return fieldToConfig(graphqlObject);
        }
        else if (graphqlObject.defaultValue !== undefined) {
            return inputFieldToConfig(graphqlObject);
        }
        // Not all input and output fields can be checked by above in older versions
        // of graphql, but almost all properties on the field and config are identical.
        // In particular, just name and isDeprecated should be removed.
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        var name_1 = graphqlObject.name, isDeprecated = graphqlObject.isDeprecated, rest = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __rest */ "c"])(graphqlObject, ["name", "isDeprecated"]);
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, rest);
    }
    throw new Error("Unknown graphql object " + graphqlObject);
}
function typeToConfig(type) {
    if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isObjectType"])(type)) {
        return objectTypeToConfig(type);
    }
    else if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isInterfaceType"])(type)) {
        return interfaceTypeToConfig(type);
    }
    else if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isUnionType"])(type)) {
        return unionTypeToConfig(type);
    }
    else if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isEnumType"])(type)) {
        return enumTypeToConfig(type);
    }
    else if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isScalarType"])(type)) {
        return scalarTypeToConfig(type);
    }
    else if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isInputObjectType"])(type)) {
        return inputObjectTypeToConfig(type);
    }
    throw new Error("Unknown type " + type);
}
function objectTypeToConfig(type) {
    if (type.toConfig != null) {
        return type.toConfig();
    }
    var typeConfig = {
        name: type.name,
        description: type.description,
        interfaces: type.getInterfaces(),
        fields: fieldMapToConfig(type.getFields()),
        isTypeOf: type.isTypeOf,
        extensions: type.extensions,
        astNode: type.astNode,
        extensionASTNodes: type.extensionASTNodes != null ? type.extensionASTNodes : [],
    };
    return typeConfig;
}
function interfaceTypeToConfig(type) {
    if (type.toConfig != null) {
        return type.toConfig();
    }
    var typeConfig = {
        name: type.name,
        description: type.description,
        fields: fieldMapToConfig(type.getFields()),
        resolveType: type.resolveType,
        extensions: type.extensions,
        astNode: type.astNode,
        extensionASTNodes: type.extensionASTNodes != null ? type.extensionASTNodes : [],
    };
    if (graphqlVersion() >= 15) {
        typeConfig.interfaces = type.getInterfaces();
    }
    return typeConfig;
}
function unionTypeToConfig(type) {
    if (type.toConfig != null) {
        return type.toConfig();
    }
    var typeConfig = {
        name: type.name,
        description: type.description,
        types: type.getTypes(),
        resolveType: type.resolveType,
        extensions: type.extensions,
        astNode: type.astNode,
        extensionASTNodes: type.extensionASTNodes != null ? type.extensionASTNodes : [],
    };
    return typeConfig;
}
function enumTypeToConfig(type) {
    if (type.toConfig != null) {
        return type.toConfig();
    }
    var newValues = keyValMap(type.getValues(), function (value) { return value.name; }, function (value) { return ({
        description: value.description,
        value: value.value,
        deprecationReason: value.deprecationReason,
        extensions: value.extensions,
        astNode: value.astNode,
    }); });
    var typeConfig = {
        name: type.name,
        description: type.description,
        values: newValues,
        extensions: type.extensions,
        astNode: type.astNode,
        extensionASTNodes: type.extensionASTNodes != null ? type.extensionASTNodes : [],
    };
    return typeConfig;
}
function scalarTypeToConfig(type) {
    if (type.toConfig != null) {
        return type.toConfig();
    }
    var typeConfig = {
        name: type.name,
        description: type.description,
        serialize: graphqlVersion() >= 14 || hasOwnProperty(type, 'serialize')
            ? type.serialize
            : type._scalarConfig.serialize,
        parseValue: graphqlVersion() >= 14 || hasOwnProperty(type, 'parseValue')
            ? type.parseValue
            : type._scalarConfig.parseValue,
        parseLiteral: graphqlVersion() >= 14 || hasOwnProperty(type, 'parseLiteral')
            ? type.parseLiteral
            : type._scalarConfig.parseLiteral,
        extensions: type.extensions,
        astNode: type.astNode,
        extensionASTNodes: type.extensionASTNodes != null ? type.extensionASTNodes : [],
    };
    return typeConfig;
}
function inputObjectTypeToConfig(type) {
    if (type.toConfig != null) {
        return type.toConfig();
    }
    var typeConfig = {
        name: type.name,
        description: type.description,
        fields: inputFieldMapToConfig(type.getFields()),
        extensions: type.extensions,
        astNode: type.astNode,
        extensionASTNodes: type.extensionASTNodes != null ? type.extensionASTNodes : [],
    };
    return typeConfig;
}
function inputFieldMapToConfig(fields) {
    return keyValMap(Object.keys(fields), function (fieldName) { return fieldName; }, function (fieldName) { return toConfig(fields[fieldName]); });
}
function inputFieldToConfig(field) {
    return {
        description: field.description,
        type: field.type,
        defaultValue: field.defaultValue,
        extensions: field.extensions,
        astNode: field.astNode,
    };
}
function directiveToConfig(directive) {
    if (directive.toConfig != null) {
        return directive.toConfig();
    }
    var directiveConfig = {
        name: directive.name,
        description: directive.description,
        locations: directive.locations,
        args: argumentMapToConfig(directive.args),
        isRepeatable: directive.isRepeatable,
        extensions: directive.extensions,
        astNode: directive.astNode,
    };
    return directiveConfig;
}
function fieldMapToConfig(fields) {
    return keyValMap(Object.keys(fields), function (fieldName) { return fieldName; }, function (fieldName) { return toConfig(fields[fieldName]); });
}
function fieldToConfig(field) {
    return {
        description: field.description,
        type: field.type,
        args: argumentMapToConfig(field.args),
        resolve: field.resolve,
        subscribe: field.subscribe,
        deprecationReason: field.deprecationReason,
        extensions: field.extensions,
        astNode: field.astNode,
    };
}
function argumentMapToConfig(args) {
    var newArguments = {};
    args.forEach(function (arg) {
        newArguments[arg.name] = argumentToConfig(arg);
    });
    return newArguments;
}
function argumentToConfig(arg) {
    return {
        description: arg.description,
        type: arg.type,
        defaultValue: arg.defaultValue,
        extensions: arg.extensions,
        astNode: arg.astNode,
    };
}

function isSpecifiedScalarType(type) {
    return (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isNamedType"])(type) &&
        // Would prefer to use specifiedScalarTypes.some(), however %checks needs
        // a simple expression.
        (type.name === graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLString"].name ||
            type.name === graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLInt"].name ||
            type.name === graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLFloat"].name ||
            type.name === graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLBoolean"].name ||
            type.name === graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLID"].name));
}

function mapSchema(schema, schemaMapper) {
    if (schemaMapper === void 0) { schemaMapper = {}; }
    var originalTypeMap = schema.getTypeMap();
    var newTypeMap = Object.create(null);
    Object.keys(originalTypeMap).forEach(function (typeName) {
        if (!typeName.startsWith('__')) {
            var typeMapper = getMapper(schema, schemaMapper, originalTypeMap[typeName]);
            if (typeMapper != null) {
                var newType = typeMapper(originalTypeMap[typeName], schema);
                newTypeMap[typeName] =
                    newType !== undefined ? newType : originalTypeMap[typeName];
            }
            else {
                newTypeMap[typeName] = originalTypeMap[typeName];
            }
        }
    });
    var queryType = schema.getQueryType();
    var mutationType = schema.getMutationType();
    var subscriptionType = schema.getSubscriptionType();
    var newQueryTypeName = queryType != null
        ? newTypeMap[queryType.name] != null
            ? newTypeMap[queryType.name].name
            : undefined
        : undefined;
    var newMutationTypeName = mutationType != null
        ? newTypeMap[mutationType.name] != null
            ? newTypeMap[mutationType.name].name
            : undefined
        : undefined;
    var newSubscriptionTypeName = subscriptionType != null
        ? newTypeMap[subscriptionType.name] != null
            ? newTypeMap[subscriptionType.name].name
            : undefined
        : undefined;
    var originalDirectives = schema.getDirectives();
    var newDirectives = [];
    originalDirectives.forEach(function (directive) {
        var directiveMapper = getMapper(schema, schemaMapper, directive);
        if (directiveMapper != null) {
            var newDirective = directiveMapper(directive, schema);
            if (newDirective != null) {
                newDirectives.push(newDirective);
            }
        }
        else {
            newDirectives.push(directive);
        }
    });
    var _a = rewireTypes(newTypeMap, newDirectives), typeMap = _a.typeMap, directives = _a.directives;
    return new graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLSchema"](Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, toConfig(schema)), { query: newQueryTypeName
            ? typeMap[newQueryTypeName]
            : undefined, mutation: newMutationTypeName
            ? typeMap[newMutationTypeName]
            : undefined, subscription: newSubscriptionTypeName != null
            ? typeMap[newSubscriptionTypeName]
            : undefined, types: Object.keys(typeMap).map(function (typeName) { return typeMap[typeName]; }), directives: directives }));
}
function getTypeSpecifiers(type, schema) {
    var specifiers = [MapperKind.TYPE];
    if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isObjectType"])(type)) {
        specifiers.push(MapperKind.COMPOSITE_TYPE, MapperKind.OBJECT_TYPE);
        var query = schema.getQueryType();
        var mutation = schema.getMutationType();
        var subscription = schema.getSubscriptionType();
        if (type === query) {
            specifiers.push(MapperKind.ROOT_OBJECT, MapperKind.QUERY);
        }
        else if (type === mutation) {
            specifiers.push(MapperKind.ROOT_OBJECT, MapperKind.MUTATION);
        }
        else if (type === subscription) {
            specifiers.push(MapperKind.ROOT_OBJECT, MapperKind.SUBSCRIPTION);
        }
    }
    else if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isInputType"])(type)) {
        specifiers.push(MapperKind.INPUT_OBJECT_TYPE);
    }
    else if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isInterfaceType"])(type)) {
        specifiers.push(MapperKind.COMPOSITE_TYPE, MapperKind.ABSTRACT_TYPE, MapperKind.INTERFACE_TYPE);
    }
    else if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isUnionType"])(type)) {
        specifiers.push(MapperKind.COMPOSITE_TYPE, MapperKind.ABSTRACT_TYPE, MapperKind.UNION_TYPE);
    }
    else if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isEnumType"])(type)) {
        specifiers.push(MapperKind.ENUM_TYPE);
    }
    else if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isScalarType"])(type)) {
        specifiers.push(MapperKind.SCALAR_TYPE);
    }
    return specifiers;
}
function getMapper(schema, schemaMapper, typeOrDirective) {
    if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isNamedType"])(typeOrDirective)) {
        var specifiers = getTypeSpecifiers(typeOrDirective, schema);
        var typeMapper = void 0;
        var stack = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __spreadArrays */ "d"])(specifiers);
        while (!typeMapper && stack.length > 0) {
            var next = stack.pop();
            typeMapper = schemaMapper[next];
        }
        return typeMapper != null ? typeMapper : null;
    }
    else if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isDirective"])(typeOrDirective)) {
        var directiveMapper = schemaMapper[MapperKind.DIRECTIVE];
        return directiveMapper != null ? directiveMapper : null;
    }
}
function rewireTypes(originalTypeMap, directives) {
    var newTypeMap = Object.create(null);
    Object.keys(originalTypeMap).forEach(function (typeName) {
        var namedType = originalTypeMap[typeName];
        if (namedType == null || typeName.startsWith('__')) {
            return;
        }
        var newName = namedType.name;
        if (newName.startsWith('__')) {
            return;
        }
        if (newTypeMap[newName] != null) {
            throw new Error("Duplicate schema type name " + newName);
        }
        newTypeMap[newName] = namedType;
    });
    Object.keys(newTypeMap).forEach(function (typeName) {
        newTypeMap[typeName] = rewireNamedType(newTypeMap[typeName]);
    });
    var newDirectives = directives.map(function (directive) {
        return rewireDirective(directive);
    });
    return pruneTypes(newTypeMap, newDirectives);
    function rewireDirective(directive) {
        var directiveConfig = toConfig(directive);
        directiveConfig.args = rewireArgs(directiveConfig.args);
        return new graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLDirective"](directiveConfig);
    }
    function rewireArgs(args) {
        var rewiredArgs = {};
        Object.keys(args).forEach(function (argName) {
            var arg = args[argName];
            var rewiredArgType = rewireType(arg.type);
            if (rewiredArgType != null) {
                arg.type = rewiredArgType;
                rewiredArgs[argName] = arg;
            }
        });
        return rewiredArgs;
    }
    function rewireNamedType(type) {
        if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isObjectType"])(type)) {
            var config_1 = toConfig(type);
            var newConfig = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, config_1), { fields: function () { return rewireFields(config_1.fields); }, interfaces: function () { return rewireNamedTypes(config_1.interfaces); } });
            return new graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLObjectType"](newConfig);
        }
        else if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isInterfaceType"])(type)) {
            var config_2 = toConfig(type);
            var newConfig = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, config_2), { fields: function () { return rewireFields(config_2.fields); } });
            if (graphqlVersion() >= 15) {
                newConfig.interfaces = function () { return rewireNamedTypes(config_2.interfaces); };
            }
            return new graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLInterfaceType"](newConfig);
        }
        else if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isUnionType"])(type)) {
            var config_3 = toConfig(type);
            var newConfig = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, config_3), { types: function () { return rewireNamedTypes(config_3.types); } });
            return new graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLUnionType"](newConfig);
        }
        else if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isInputObjectType"])(type)) {
            var config_4 = toConfig(type);
            var newConfig = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, config_4), { fields: function () { return rewireInputFields(config_4.fields); } });
            return new graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLInputObjectType"](newConfig);
        }
        else if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isEnumType"])(type)) {
            var enumConfig = toConfig(type);
            return new graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLEnumType"](enumConfig);
        }
        else if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isScalarType"])(type)) {
            if (isSpecifiedScalarType(type)) {
                return type;
            }
            var scalarConfig = toConfig(type);
            return new graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLScalarType"](scalarConfig);
        }
        throw new Error("Unexpected schema type: " + type);
    }
    function rewireFields(fields) {
        var rewiredFields = {};
        Object.keys(fields).forEach(function (fieldName) {
            var field = fields[fieldName];
            var rewiredFieldType = rewireType(field.type);
            if (rewiredFieldType != null) {
                field.type = rewiredFieldType;
                field.args = rewireArgs(field.args);
                rewiredFields[fieldName] = field;
            }
        });
        return rewiredFields;
    }
    function rewireInputFields(fields) {
        var rewiredFields = {};
        Object.keys(fields).forEach(function (fieldName) {
            var field = fields[fieldName];
            var rewiredFieldType = rewireType(field.type);
            if (rewiredFieldType != null) {
                field.type = rewiredFieldType;
                rewiredFields[fieldName] = field;
            }
        });
        return rewiredFields;
    }
    function rewireNamedTypes(namedTypes) {
        var rewiredTypes = [];
        namedTypes.forEach(function (namedType) {
            var rewiredType = rewireType(namedType);
            if (rewiredType != null) {
                rewiredTypes.push(rewiredType);
            }
        });
        return rewiredTypes;
    }
    function rewireType(type) {
        if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isListType"])(type)) {
            var rewiredType = rewireType(type.ofType);
            return rewiredType != null ? new graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLList"](rewiredType) : null;
        }
        else if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isNonNullType"])(type)) {
            var rewiredType = rewireType(type.ofType);
            return rewiredType != null
                ? new graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLNonNull"](rewiredType)
                : null;
        }
        else if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isNamedType"])(type)) {
            var originalType = originalTypeMap[type.name];
            return originalType != null ? newTypeMap[originalType.name] : null;
        }
        return null;
    }
}
function pruneTypes(typeMap, directives) {
    var newTypeMap = {};
    var implementedInterfaces = {};
    Object.keys(typeMap).forEach(function (typeName) {
        var namedType = typeMap[typeName];
        if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isObjectType"])(namedType) ||
            (graphqlVersion() >= 15 && Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isInterfaceType"])(namedType))) {
            namedType.getInterfaces().forEach(function (iface) {
                implementedInterfaces[iface.name] = true;
            });
        }
    });
    var prunedTypeMap = false;
    var typeNames = Object.keys(typeMap);
    for (var i = 0; i < typeNames.length; i++) {
        var typeName = typeNames[i];
        var type = typeMap[typeName];
        if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isObjectType"])(type) || Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isInputObjectType"])(type)) {
            // prune types with no fields
            if (Object.keys(type.getFields()).length) {
                newTypeMap[typeName] = type;
            }
            else {
                prunedTypeMap = true;
            }
        }
        else if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isUnionType"])(type)) {
            // prune unions without underlying types
            if (type.getTypes().length) {
                newTypeMap[typeName] = type;
            }
            else {
                prunedTypeMap = true;
            }
        }
        else if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isInterfaceType"])(type)) {
            // prune interfaces without fields or without implementations
            if (Object.keys(type.getFields()).length &&
                implementedInterfaces[type.name]) {
                newTypeMap[typeName] = type;
            }
            else {
                prunedTypeMap = true;
            }
        }
        else {
            newTypeMap[typeName] = type;
        }
    }
    // every prune requires another round of healing
    return prunedTypeMap
        ? rewireTypes(newTypeMap, directives)
        : { typeMap: typeMap, directives: directives };
}

function filterSchema(_a) {
    var _b;
    var schema = _a.schema, _c = _a.rootFieldFilter, rootFieldFilter = _c === void 0 ? function () { return true; } : _c, _d = _a.typeFilter, typeFilter = _d === void 0 ? function () { return true; } : _d, _e = _a.fieldFilter, fieldFilter = _e === void 0 ? function () { return true; } : _e;
    var filteredSchema = mapSchema(schema, (_b = {},
        _b[MapperKind.QUERY] = function (type) {
            return filterRootFields(type, 'Query', rootFieldFilter);
        },
        _b[MapperKind.MUTATION] = function (type) {
            return filterRootFields(type, 'Mutation', rootFieldFilter);
        },
        _b[MapperKind.SUBSCRIPTION] = function (type) {
            return filterRootFields(type, 'Subscription', rootFieldFilter);
        },
        _b[MapperKind.OBJECT_TYPE] = function (type) {
            return typeFilter(type.name, type)
                ? filterObjectFields(type, fieldFilter)
                : null;
        },
        _b[MapperKind.INTERFACE_TYPE] = function (type) {
            return typeFilter(type.name, type) ? undefined : null;
        },
        _b[MapperKind.UNION_TYPE] = function (type) {
            return typeFilter(type.name, type) ? undefined : null;
        },
        _b[MapperKind.INPUT_OBJECT_TYPE] = function (type) {
            return typeFilter(type.name, type) ? undefined : null;
        },
        _b[MapperKind.ENUM_TYPE] = function (type) {
            return typeFilter(type.name, type) ? undefined : null;
        },
        _b[MapperKind.SCALAR_TYPE] = function (type) {
            return typeFilter(type.name, type) ? undefined : null;
        },
        _b));
    filteredSchema.transforms = schema.transforms;
    return filteredSchema;
}
function filterRootFields(type, operation, rootFieldFilter) {
    var config = toConfig(type);
    Object.keys(config.fields).forEach(function (fieldName) {
        if (!rootFieldFilter(operation, fieldName, config.fields[fieldName])) {
            delete config.fields[fieldName];
        }
    });
    return new graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLObjectType"](config);
}
function filterObjectFields(type, fieldFilter) {
    var config = toConfig(type);
    Object.keys(config.fields).forEach(function (fieldName) {
        if (!fieldFilter(type.name, fieldName, config.fields[fieldName])) {
            delete config.fields[fieldName];
        }
    });
    return new graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLObjectType"](config);
}

function cloneDirective(directive) {
    return new graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLDirective"](toConfig(directive));
}
function cloneType(type) {
    if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isObjectType"])(type)) {
        var config = toConfig(type);
        return new graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLObjectType"](Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, config), { interfaces: typeof config.interfaces === 'function'
                ? config.interfaces
                : config.interfaces.slice() }));
    }
    else if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isInterfaceType"])(type)) {
        var config = toConfig(type);
        var newConfig = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, config), { interfaces: graphqlVersion() >= 15
                ? typeof config.interfaces === 'function'
                    ? config.interfaces
                    : config.interfaces.slice()
                : undefined });
        return new graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLInterfaceType"](newConfig);
    }
    else if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isUnionType"])(type)) {
        var config = toConfig(type);
        return new graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLUnionType"](Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, config), { types: config.types.slice() }));
    }
    else if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isInputObjectType"])(type)) {
        return new graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLInputObjectType"](toConfig(type));
    }
    else if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isEnumType"])(type)) {
        return new graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLEnumType"](toConfig(type));
    }
    else if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isScalarType"])(type)) {
        return isSpecifiedScalarType(type)
            ? type
            : new graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLScalarType"](toConfig(type));
    }
    throw new Error("Invalid type " + type);
}
function cloneSchema(schema) {
    return mapSchema(schema);
}

// polyfill for graphql prior to v13 which do not pass options to buildASTSchema
function buildSchema(ast, buildSchemaOptions) {
    return Object(graphql__WEBPACK_IMPORTED_MODULE_3__["buildASTSchema"])(Object(graphql__WEBPACK_IMPORTED_MODULE_3__["parse"])(ast), buildSchemaOptions);
}

function getResolversFromSchema(schema) {
    var resolvers = Object.create({});
    var typeMap = schema.getTypeMap();
    Object.keys(typeMap).forEach(function (typeName) {
        var type = typeMap[typeName];
        if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isScalarType"])(type)) {
            if (!isSpecifiedScalarType(type)) {
                resolvers[typeName] = cloneType(type);
            }
        }
        else if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isEnumType"])(type)) {
            resolvers[typeName] = {};
            var values = type.getValues();
            values.forEach(function (value) {
                resolvers[typeName][value.name] = value.value;
            });
        }
        else if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isInterfaceType"])(type)) {
            if (type.resolveType != null) {
                resolvers[typeName] = {
                    __resolveType: type.resolveType,
                };
            }
        }
        else if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isUnionType"])(type)) {
            if (type.resolveType != null) {
                resolvers[typeName] = {
                    __resolveType: type.resolveType,
                };
            }
        }
        else if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isObjectType"])(type)) {
            resolvers[typeName] = {};
            if (type.isTypeOf != null) {
                resolvers[typeName].__isTypeOf = type.isTypeOf;
            }
            var fields_1 = type.getFields();
            Object.keys(fields_1).forEach(function (fieldName) {
                var field = fields_1[fieldName];
                resolvers[typeName][fieldName] = {
                    resolve: field.resolve,
                    subscribe: field.subscribe,
                };
            });
        }
    });
    return resolvers;
}

// polyfill for graphql < v14.2 which does not support subscriptions
function extendSchema(schema, extension, options) {
    var subscriptionType = schema.getSubscriptionType();
    if (subscriptionType == null) {
        return Object(graphql__WEBPACK_IMPORTED_MODULE_3__["extendSchema"])(schema, extension, options);
    }
    var resolvers = getResolversFromSchema(schema);
    var subscriptionTypeName = subscriptionType.name;
    var subscriptionResolvers = resolvers[subscriptionTypeName];
    var extendedSchema = Object(graphql__WEBPACK_IMPORTED_MODULE_3__["extendSchema"])(schema, extension, options);
    var fields = extendedSchema.getSubscriptionType().getFields();
    Object.keys(subscriptionResolvers).forEach(function (fieldName) {
        fields[fieldName].subscribe = subscriptionResolvers[fieldName].subscribe;
    });
    return extendedSchema;
}

// A generic updater function for arrays or objects.
function updateEachKey(arrayOrObject, 
// The callback can return nothing or undefined to leave the key untouched, null to remove
// the key from the array or object, or a non-null V to replace the value.
updater) {
    var deletedCount = 0;
    Object.keys(arrayOrObject).forEach(function (key) {
        var result = updater(arrayOrObject[key], key);
        if (typeof result === 'undefined') {
            return;
        }
        if (result === null) {
            delete arrayOrObject[key];
            deletedCount++;
            return;
        }
        arrayOrObject[key] = result;
    });
    if (deletedCount > 0 && Array.isArray(arrayOrObject)) {
        // Remove any holes from the array due to deleted elements.
        arrayOrObject.splice(0).forEach(function (elem) {
            arrayOrObject.push(elem);
        });
    }
}

function createNamedStub(name, type) {
    var constructor;
    if (type === 'object') {
        constructor = graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLObjectType"];
    }
    else if (type === 'interface') {
        constructor = graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLInterfaceType"];
    }
    else {
        constructor = graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLInputObjectType"];
    }
    return new constructor({
        name: name,
        fields: {
            __fake: {
                type: graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLString"],
            },
        },
    });
}
function createStub(node, type) {
    switch (node.kind) {
        case graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].LIST_TYPE:
            return new graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLList"](createStub(node.type, type));
        case graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].NON_NULL_TYPE:
            return new graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLNonNull"](createStub(node.type, type));
        default:
            if (type === 'output') {
                return createNamedStub(node.name.value, 'object');
            }
            return createNamedStub(node.name.value, 'input');
    }
}
function isNamedStub(type) {
    if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isObjectType"])(type) || Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isInterfaceType"])(type) || Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isInputObjectType"])(type)) {
        var fields = type.getFields();
        var fieldNames = Object.keys(fields);
        return fieldNames.length === 1 && fields[fieldNames[0]].name === '__fake';
    }
    return false;
}
function getBuiltInForStub(type) {
    switch (type.name) {
        case graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLInt"].name:
            return graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLInt"];
        case graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLFloat"].name:
            return graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLFloat"];
        case graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLString"].name:
            return graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLString"];
        case graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLBoolean"].name:
            return graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLBoolean"];
        case graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLID"].name:
            return graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLID"];
        default:
            return type;
    }
}

// Update any references to named schema types that disagree with the named
// types found in schema.getTypeMap().
function healSchema(schema) {
    var typeMap = schema.getTypeMap();
    var directives = schema.getDirectives();
    var queryType = schema.getQueryType();
    var mutationType = schema.getMutationType();
    var subscriptionType = schema.getSubscriptionType();
    var newQueryTypeName = queryType != null
        ? typeMap[queryType.name] != null
            ? typeMap[queryType.name].name
            : undefined
        : undefined;
    var newMutationTypeName = mutationType != null
        ? typeMap[mutationType.name] != null
            ? typeMap[mutationType.name].name
            : undefined
        : undefined;
    var newSubscriptionTypeName = subscriptionType != null
        ? typeMap[subscriptionType.name] != null
            ? typeMap[subscriptionType.name].name
            : undefined
        : undefined;
    healTypes(typeMap, directives);
    var filteredTypeMap = {};
    Object.keys(typeMap).forEach(function (typeName) {
        if (!typeName.startsWith('__')) {
            filteredTypeMap[typeName] = typeMap[typeName];
        }
    });
    var healedSchema = new graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLSchema"](Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, toConfig(schema)), { query: newQueryTypeName ? filteredTypeMap[newQueryTypeName] : undefined, mutation: newMutationTypeName
            ? filteredTypeMap[newMutationTypeName]
            : undefined, subscription: newSubscriptionTypeName
            ? filteredTypeMap[newSubscriptionTypeName]
            : undefined, types: Object.keys(filteredTypeMap).map(function (typeName) { return filteredTypeMap[typeName]; }), directives: directives.slice() }));
    // Reconstruct the schema to reinitialize private variables
    // e.g. the stored implementation map and the proper root types.
    Object.assign(schema, healedSchema);
    return schema;
}
function healTypes(originalTypeMap, directives, config) {
    if (config === void 0) { config = {
        skipPruning: false,
    }; }
    var actualNamedTypeMap = Object.create(null);
    // If any of the .name properties of the GraphQLNamedType objects in
    // schema.getTypeMap() have changed, the keys of the type map need to
    // be updated accordingly.
    Object.entries(originalTypeMap).forEach(function (_a) {
        var typeName = _a[0], namedType = _a[1];
        if (namedType == null || typeName.startsWith('__')) {
            return;
        }
        var actualName = namedType.name;
        if (actualName.startsWith('__')) {
            return;
        }
        if (actualName in actualNamedTypeMap) {
            throw new Error("Duplicate schema type name " + actualName);
        }
        actualNamedTypeMap[actualName] = namedType;
        // Note: we are deliberately leaving namedType in the schema by its
        // original name (which might be different from actualName), so that
        // references by that name can be healed.
    });
    // Now add back every named type by its actual name.
    Object.entries(actualNamedTypeMap).forEach(function (_a) {
        var typeName = _a[0], namedType = _a[1];
        originalTypeMap[typeName] = namedType;
    });
    // Directive declaration argument types can refer to named types.
    directives.forEach(function (decl) {
        updateEachKey(decl.args, function (arg) {
            arg.type = healType(arg.type);
            return arg.type === null ? null : arg;
        });
    });
    Object.entries(originalTypeMap).forEach(function (_a) {
        var typeName = _a[0], namedType = _a[1];
        // Heal all named types, except for dangling references, kept only to redirect.
        if (!typeName.startsWith('__') && typeName in actualNamedTypeMap) {
            if (namedType != null) {
                healNamedType(namedType);
            }
        }
    });
    updateEachKey(originalTypeMap, function (_namedType, typeName) {
        // Dangling references to renamed types should remain in the schema
        // during healing, but must be removed now, so that the following
        // invariant holds for all names: schema.getType(name).name === name
        if (!typeName.startsWith('__') && !(typeName in actualNamedTypeMap)) {
            return null;
        }
    });
    if (!config.skipPruning) {
        pruneTypes$1(originalTypeMap, directives);
    }
    function healNamedType(type) {
        if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isObjectType"])(type)) {
            healFields(type);
            healInterfaces(type);
            return;
        }
        else if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isInterfaceType"])(type)) {
            healFields(type);
            if (graphqlVersion() >= 15) {
                healInterfaces(type);
            }
            return;
        }
        else if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isUnionType"])(type)) {
            healUnderlyingTypes(type);
            return;
        }
        else if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isInputObjectType"])(type)) {
            healInputFields(type);
            return;
        }
        else if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isLeafType"])(type)) {
            return;
        }
        throw new Error("Unexpected schema type: " + type);
    }
    function healFields(type) {
        updateEachKey(type.getFields(), function (field) {
            updateEachKey(field.args, function (arg) {
                arg.type = healType(arg.type);
                return arg.type === null ? null : arg;
            });
            field.type = healType(field.type);
            return field.type === null ? null : field;
        });
    }
    function healInterfaces(type) {
        updateEachKey(type.getInterfaces(), function (iface) {
            var healedType = healType(iface);
            return healedType;
        });
    }
    function healInputFields(type) {
        updateEachKey(type.getFields(), function (field) {
            field.type = healType(field.type);
            return field.type === null ? null : field;
        });
    }
    function healUnderlyingTypes(type) {
        updateEachKey(type.getTypes(), function (t) {
            var healedType = healType(t);
            return healedType;
        });
    }
    function healType(type) {
        // Unwrap the two known wrapper types
        if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isListType"])(type)) {
            var healedType = healType(type.ofType);
            return healedType != null ? new graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLList"](healedType) : null;
        }
        else if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isNonNullType"])(type)) {
            var healedType = healType(type.ofType);
            return healedType != null ? new graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLNonNull"](healedType) : null;
        }
        else if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isNamedType"])(type)) {
            // If a type annotation on a field or an argument or a union member is
            // any `GraphQLNamedType` with a `name`, then it must end up identical
            // to `schema.getType(name)`, since `schema.getTypeMap()` is the source
            // of truth for all named schema types.
            // Note that new types can still be simply added by adding a field, as
            // the official type will be undefined, not null.
            var officialType = originalTypeMap[type.name];
            if (officialType === undefined) {
                if (isNamedStub(type)) {
                    officialType = getBuiltInForStub(type);
                }
                else {
                    officialType = type;
                }
                originalTypeMap[type.name] = officialType;
            }
            return officialType;
        }
        return null;
    }
}
function pruneTypes$1(typeMap, directives) {
    var implementedInterfaces = {};
    Object.values(typeMap).forEach(function (namedType) {
        if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isObjectType"])(namedType) ||
            (graphqlVersion() >= 15 && Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isInterfaceType"])(namedType))) {
            namedType.getInterfaces().forEach(function (iface) {
                implementedInterfaces[iface.name] = true;
            });
        }
    });
    var prunedTypeMap = false;
    var typeNames = Object.keys(typeMap);
    for (var i = 0; i < typeNames.length; i++) {
        var typeName = typeNames[i];
        var type = typeMap[typeName];
        if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isObjectType"])(type) || Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isInputObjectType"])(type)) {
            // prune types with no fields
            if (!Object.keys(type.getFields()).length) {
                typeMap[typeName] = null;
                prunedTypeMap = true;
            }
        }
        else if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isUnionType"])(type)) {
            // prune unions without underlying types
            if (!type.getTypes().length) {
                typeMap[typeName] = null;
                prunedTypeMap = true;
            }
        }
        else if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isInterfaceType"])(type)) {
            // prune interfaces without fields or without implementations
            if (!Object.keys(type.getFields()).length ||
                !(type.name in implementedInterfaces)) {
                typeMap[typeName] = null;
                prunedTypeMap = true;
            }
        }
    }
    // every prune requires another round of healing
    if (prunedTypeMap) {
        healTypes(typeMap, directives);
    }
}

// Abstract base class of any visitor implementation, defining the available
// visitor methods along with their parameter types, and providing a static
// helper function for determining whether a subclass implements a given
// visitor method, as opposed to inheriting one of the stubs defined here.
var SchemaVisitor = /** @class */ (function () {
    function SchemaVisitor() {
    }
    // Determine if this SchemaVisitor (sub)class implements a particular
    // visitor method.
    SchemaVisitor.implementsVisitorMethod = function (methodName) {
        if (!methodName.startsWith('visit')) {
            return false;
        }
        var method = this.prototype[methodName];
        if (typeof method !== 'function') {
            return false;
        }
        if (this === SchemaVisitor) {
            // The SchemaVisitor class implements every visitor method.
            return true;
        }
        var stub = SchemaVisitor.prototype[methodName];
        if (method === stub) {
            // If this.prototype[methodName] was just inherited from SchemaVisitor,
            // then this class does not really implement the method.
            return false;
        }
        return true;
    };
    // Concrete subclasses of SchemaVisitor should override one or more of these
    // visitor methods, in order to express their interest in handling certain
    // schema types/locations. Each method may return null to remove the given
    // type from the schema, a non-null value of the same type to update the
    // type in the schema, or nothing to leave the type as it was.
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    SchemaVisitor.prototype.visitSchema = function (_schema) { };
    SchemaVisitor.prototype.visitScalar = function (_scalar) { };
    SchemaVisitor.prototype.visitObject = function (_object) { };
    SchemaVisitor.prototype.visitFieldDefinition = function (_field, _details) { };
    SchemaVisitor.prototype.visitArgumentDefinition = function (_argument, _details) { };
    SchemaVisitor.prototype.visitInterface = function (_iface) { };
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    SchemaVisitor.prototype.visitUnion = function (_union) { };
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    SchemaVisitor.prototype.visitEnum = function (_type) { };
    SchemaVisitor.prototype.visitEnumValue = function (_value, _details) { };
    SchemaVisitor.prototype.visitInputObject = function (_object) { };
    SchemaVisitor.prototype.visitInputFieldDefinition = function (_field, _details) { };
    return SchemaVisitor;
}());

/**
 * Creates a keyed JS object from an array, given a function to produce the keys
 * for each value in the array.
 *
 * This provides a convenient lookup for the array items if the key function
 * produces unique results.
 *
 *     const phoneBook = [
 *       { name: 'Jon', num: '555-1234' },
 *       { name: 'Jenny', num: '867-5309' }
 *     ]
 *
 *     // { Jon: { name: 'Jon', num: '555-1234' },
 *     //   Jenny: { name: 'Jenny', num: '867-5309' } }
 *     const entriesByName = keyMap(
 *       phoneBook,
 *       entry => entry.name
 *     )
 *
 *     // { name: 'Jenny', num: '857-6309' }
 *     const jennyEntry = entriesByName['Jenny']
 *
 */
function keyMap(list, keyFn) {
    return list.reduce(function (map, item) {
        map[keyFn(item)] = item;
        return map;
    }, Object.create(null));
}

// Similar to the graphql-js function of the same name, slightly simplified:
// https://github.com/graphql/graphql-js/blob/master/src/utilities/valueFromASTUntyped.js
function valueFromASTUntyped(valueNode) {
    switch (valueNode.kind) {
        case graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].NULL:
            return null;
        case graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].INT:
            return parseInt(valueNode.value, 10);
        case graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].FLOAT:
            return parseFloat(valueNode.value);
        case graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].STRING:
        case graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].ENUM:
        case graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].BOOLEAN:
            return valueNode.value;
        case graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].LIST:
            return valueNode.values.map(valueFromASTUntyped);
        case graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].OBJECT: {
            return keyValMap(valueNode.fields, function (field) { return field.name.value; }, function (field) { return valueFromASTUntyped(field.value); });
        }
        /* istanbul ignore next */
        default:
            throw new Error('Unexpected value kind: ' + valueNode.kind);
    }
}

// Generic function for visiting GraphQLSchema objects.
function visitSchema(schema, 
// To accommodate as many different visitor patterns as possible, the
// visitSchema function does not simply accept a single instance of the
// SchemaVisitor class, but instead accepts a function that takes the
// current VisitableSchemaType object and the name of a visitor method and
// returns an array of SchemaVisitor instances that implement the visitor
// method and have an interest in handling the given VisitableSchemaType
// object. In the simplest case, this function can always return an array
// containing a single visitor object, without even looking at the type or
// methodName parameters. In other cases, this function might sometimes
// return an empty array to indicate there are no visitors that should be
// applied to the given VisitableSchemaType object. For an example of a
// visitor pattern that benefits from this abstraction, see the
// SchemaDirectiveVisitor class below.
visitorOrVisitorSelector) {
    var visitorSelector = typeof visitorOrVisitorSelector === 'function'
        ? visitorOrVisitorSelector
        : function () { return visitorOrVisitorSelector; };
    // Helper function that calls visitorSelector and applies the resulting
    // visitors to the given type, with arguments [type, ...args].
    function callMethod(methodName, type) {
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            args[_i - 2] = arguments[_i];
        }
        var visitors = visitorSelector(type, methodName);
        visitors = Array.isArray(visitors) ? visitors : [visitors];
        var finalType = type;
        visitors.every(function (visitorOrVisitorDef) {
            var newType;
            if (visitorOrVisitorDef instanceof SchemaVisitor) {
                newType = visitorOrVisitorDef[methodName].apply(visitorOrVisitorDef, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __spreadArrays */ "d"])([finalType], args));
            }
            else if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isNamedType"])(finalType) &&
                (methodName === 'visitScalar' ||
                    methodName === 'visitEnum' ||
                    methodName === 'visitObject' ||
                    methodName === 'visitInputObject' ||
                    methodName === 'visitUnion' ||
                    methodName === 'visitInterface')) {
                var specifiers = getTypeSpecifiers$1(finalType, schema);
                var typeVisitor = getVisitor(visitorOrVisitorDef, specifiers);
                newType =
                    typeVisitor != null ? typeVisitor(finalType, schema) : undefined;
            }
            if (typeof newType === 'undefined') {
                // Keep going without modifying type.
                return true;
            }
            if (methodName === 'visitSchema' || Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isSchema"])(finalType)) {
                throw new Error("Method " + methodName + " cannot replace schema with " + newType);
            }
            if (newType === null) {
                // Stop the loop and return null form callMethod, which will cause
                // the type to be removed from the schema.
                finalType = null;
                return false;
            }
            // Update type to the new type returned by the visitor method, so that
            // later directives will see the new type, and callMethod will return
            // the final type.
            finalType = newType;
            return true;
        });
        // If there were no directives for this type object, or if all visitor
        // methods returned nothing, type will be returned unmodified.
        return finalType;
    }
    // Recursive helper function that calls any appropriate visitor methods for
    // each object in the schema, then traverses the object's children (if any).
    function visit(type) {
        if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isSchema"])(type)) {
            // Unlike the other types, the root GraphQLSchema object cannot be
            // replaced by visitor methods, because that would make life very hard
            // for SchemaVisitor subclasses that rely on the original schema object.
            callMethod('visitSchema', type);
            var typeMap_1 = type.getTypeMap();
            Object.entries(typeMap_1).forEach(function (_a) {
                var typeName = _a[0], namedType = _a[1];
                if (!typeName.startsWith('__') && namedType != null) {
                    // Call visit recursively to let it determine which concrete
                    // subclass of GraphQLNamedType we found in the type map.
                    // We do not use updateEachKey because we want to preserve
                    // deleted types in the typeMap so that other types that reference
                    // the deleted types can be healed.
                    typeMap_1[typeName] = visit(namedType);
                }
            });
            return type;
        }
        if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isObjectType"])(type)) {
            // Note that callMethod('visitObject', type) may not actually call any
            // methods, if there are no @directive annotations associated with this
            // type, or if this SchemaDirectiveVisitor subclass does not override
            // the visitObject method.
            var newObject = callMethod('visitObject', type);
            if (newObject != null) {
                visitFields(newObject);
            }
            return newObject;
        }
        if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isInterfaceType"])(type)) {
            var newInterface = callMethod('visitInterface', type);
            if (newInterface != null) {
                visitFields(newInterface);
            }
            return newInterface;
        }
        if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isInputObjectType"])(type)) {
            var newInputObject_1 = callMethod('visitInputObject', type);
            if (newInputObject_1 != null) {
                var fieldMap = newInputObject_1.getFields();
                updateEachKey(fieldMap, function (field) {
                    return callMethod('visitInputFieldDefinition', field, {
                        // Since we call a different method for input object fields, we
                        // can't reuse the visitFields function here.
                        objectType: newInputObject_1,
                    });
                });
            }
            return newInputObject_1;
        }
        if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isScalarType"])(type)) {
            return callMethod('visitScalar', type);
        }
        if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isUnionType"])(type)) {
            return callMethod('visitUnion', type);
        }
        if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isEnumType"])(type)) {
            var newEnum_1 = callMethod('visitEnum', type);
            if (newEnum_1 != null) {
                updateEachKey(newEnum_1.getValues(), function (value) {
                    return callMethod('visitEnumValue', value, {
                        enumType: newEnum_1,
                    });
                });
            }
            return newEnum_1;
        }
        throw new Error("Unexpected schema type: " + type);
    }
    function visitFields(type) {
        updateEachKey(type.getFields(), function (field) {
            // It would be nice if we could call visit(field) recursively here, but
            // GraphQLField is merely a type, not a value that can be detected using
            // an instanceof check, so we have to visit the fields in this lexical
            // context, so that TypeScript can validate the call to
            // visitFieldDefinition.
            var newField = callMethod('visitFieldDefinition', field, {
                // While any field visitor needs a reference to the field object, some
                // field visitors may also need to know the enclosing (parent) type,
                // perhaps to determine if the parent is a GraphQLObjectType or a
                // GraphQLInterfaceType. To obtain a reference to the parent, a
                // visitor method can have a second parameter, which will be an object
                // with an .objectType property referring to the parent.
                objectType: type,
            });
            if (newField.args != null) {
                updateEachKey(newField.args, function (arg) {
                    return callMethod('visitArgumentDefinition', arg, {
                        // Like visitFieldDefinition, visitArgumentDefinition takes a
                        // second parameter that provides additional context, namely the
                        // parent .field and grandparent .objectType. Remember that the
                        // current GraphQLSchema is always available via this.schema.
                        field: newField,
                        objectType: type,
                    });
                });
            }
            return newField;
        });
    }
    visit(schema);
    // Automatically update any references to named schema types replaced
    // during the traversal, so implementors don't have to worry about that.
    healSchema(schema);
    // Return schema for convenience, even though schema parameter has all updated types.
    return schema;
}
function getTypeSpecifiers$1(type, schema) {
    var specifiers = [VisitSchemaKind.TYPE];
    if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isObjectType"])(type)) {
        specifiers.push(VisitSchemaKind.COMPOSITE_TYPE, VisitSchemaKind.OBJECT_TYPE);
        var query = schema.getQueryType();
        var mutation = schema.getMutationType();
        var subscription = schema.getSubscriptionType();
        if (type === query) {
            specifiers.push(VisitSchemaKind.ROOT_OBJECT, VisitSchemaKind.QUERY);
        }
        else if (type === mutation) {
            specifiers.push(VisitSchemaKind.ROOT_OBJECT, VisitSchemaKind.MUTATION);
        }
        else if (type === subscription) {
            specifiers.push(VisitSchemaKind.ROOT_OBJECT, VisitSchemaKind.SUBSCRIPTION);
        }
    }
    else if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isInputType"])(type)) {
        specifiers.push(VisitSchemaKind.INPUT_OBJECT_TYPE);
    }
    else if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isInterfaceType"])(type)) {
        specifiers.push(VisitSchemaKind.COMPOSITE_TYPE, VisitSchemaKind.ABSTRACT_TYPE, VisitSchemaKind.INTERFACE_TYPE);
    }
    else if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isUnionType"])(type)) {
        specifiers.push(VisitSchemaKind.COMPOSITE_TYPE, VisitSchemaKind.ABSTRACT_TYPE, VisitSchemaKind.UNION_TYPE);
    }
    else if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isEnumType"])(type)) {
        specifiers.push(VisitSchemaKind.ENUM_TYPE);
    }
    else if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isScalarType"])(type)) {
        specifiers.push(VisitSchemaKind.SCALAR_TYPE);
    }
    return specifiers;
}
function getVisitor(visitorDef, specifiers) {
    var typeVisitor;
    var stack = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __spreadArrays */ "d"])(specifiers);
    while (!typeVisitor && stack.length > 0) {
        var next = stack.pop();
        typeVisitor = visitorDef[next];
    }
    return typeVisitor != null ? typeVisitor : null;
}

var MAX_ARRAY_LENGTH = 10;
var MAX_RECURSIVE_DEPTH = 2;
/**
 * Used to print values in error messages.
 */
function inspect(value) {
    return formatValue(value, []);
}
function formatValue(value, seenValues) {
    switch (typeof value) {
        case 'string':
            return JSON.stringify(value);
        case 'function':
            return value.name
                ? "[function " + value.name + "]"
                : '[function]';
        case 'object':
            if (value === null) {
                return 'null';
            }
            return formatObjectValue(value, seenValues);
        default:
            return String(value);
    }
}
function formatObjectValue(value, previouslySeenValues) {
    if (previouslySeenValues.indexOf(value) !== -1) {
        return '[Circular]';
    }
    var seenValues = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __spreadArrays */ "d"])(previouslySeenValues, [value]);
    var customInspectFn = getCustomFn(value);
    if (customInspectFn !== undefined) {
        var customValue = customInspectFn.call(value);
        // check for infinite recursion
        if (customValue !== value) {
            return typeof customValue === 'string'
                ? customValue
                : formatValue(customValue, seenValues);
        }
    }
    else if (Array.isArray(value)) {
        return formatArray(value, seenValues);
    }
    return formatObject(value, seenValues);
}
function formatObject(object, seenValues) {
    var keys = Object.keys(object);
    if (keys.length === 0) {
        return '{}';
    }
    if (seenValues.length > MAX_RECURSIVE_DEPTH) {
        return '[' + getObjectTag(object) + ']';
    }
    var properties = keys.map(function (key) {
        var value = formatValue(object[key], seenValues);
        return key + ': ' + value;
    });
    return '{ ' + properties.join(', ') + ' }';
}
function formatArray(array, seenValues) {
    if (array.length === 0) {
        return '[]';
    }
    if (seenValues.length > MAX_RECURSIVE_DEPTH) {
        return '[Array]';
    }
    var len = Math.min(MAX_ARRAY_LENGTH, array.length);
    var remaining = array.length - len;
    var items = [];
    for (var i = 0; i < len; ++i) {
        items.push(formatValue(array[i], seenValues));
    }
    if (remaining === 1) {
        items.push('... 1 more item');
    }
    else if (remaining > 1) {
        items.push("... " + remaining.toString(10) + " more items");
    }
    return '[' + items.join(', ') + ']';
}
function getCustomFn(obj) {
    if (typeof obj.inspect === 'function') {
        return obj.inspect;
    }
}
function getObjectTag(obj) {
    var tag = Object.prototype.toString
        .call(obj)
        .replace(/^\[object /, '')
        .replace(/]$/, '');
    if (tag === 'Object' && typeof obj.constructor === 'function') {
        var name_1 = obj.constructor.name;
        if (typeof name_1 === 'string' && name_1 !== '') {
            return name_1;
        }
    }
    return tag;
}

/**
 * Prepares an object map of argument values given a list of argument
 * definitions and list of argument AST nodes.
 *
 * Note: The returned value is a plain Object with a prototype, since it is
 * exposed to user code. Care should be taken to not pull values from the
 * Object prototype.
 */
function getArgumentValues(def, node, variableValues) {
    if (variableValues === void 0) { variableValues = {}; }
    var _a;
    var variableMap = toObjMap(variableValues);
    var coercedValues = {};
    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
    var argumentNodes = (_a = node.arguments) !== null && _a !== void 0 ? _a : [];
    var argNodeMap = keyMap(argumentNodes, function (arg) { return arg.name.value; });
    for (var _i = 0, _b = def.args; _i < _b.length; _i++) {
        var argDef = _b[_i];
        var name_1 = argDef.name;
        var argType = argDef.type;
        var argumentNode = argNodeMap[name_1];
        if (!argumentNode) {
            if (argDef.defaultValue !== undefined) {
                coercedValues[name_1] = argDef.defaultValue;
            }
            else if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isNonNullType"])(argType)) {
                throw new graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLError"]("Argument \"" + name_1 + "\" of required type \"" + inspect(argType) + "\" " +
                    'was not provided.', node);
            }
            continue;
        }
        var valueNode = argumentNode.value;
        var isNull = valueNode.kind === graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].NULL;
        if (valueNode.kind === graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].VARIABLE) {
            var variableName = valueNode.name.value;
            if (variableValues == null || !(variableName in variableMap)) {
                if (argDef.defaultValue !== undefined) {
                    coercedValues[name_1] = argDef.defaultValue;
                }
                else if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isNonNullType"])(argType)) {
                    throw new graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLError"]("Argument \"" + name_1 + "\" of required type \"" + inspect(argType) + "\" " +
                        ("was provided the variable \"$" + variableName + "\" which was not provided a runtime value."), valueNode);
                }
                continue;
            }
            isNull = variableValues[variableName] == null;
        }
        if (isNull && Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isNonNullType"])(argType)) {
            throw new graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLError"]("Argument \"" + name_1 + "\" of non-null type \"" + inspect(argType) + "\" " +
                'must not be null.', valueNode);
        }
        var coercedValue = Object(graphql__WEBPACK_IMPORTED_MODULE_3__["valueFromAST"])(valueNode, argType, variableValues);
        if (coercedValue === undefined) {
            // Note: ValuesOfCorrectTypeRule validation should catch this before
            // execution. This is a runtime check to ensure execution does not
            // continue with an invalid argument value.
            throw new graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLError"]("Argument \"" + name_1 + "\" has invalid value " + Object(graphql__WEBPACK_IMPORTED_MODULE_3__["print"])(valueNode) + ".", valueNode);
        }
        coercedValues[name_1] = coercedValue;
    }
    return coercedValues;
}

// This class represents a reusable implementation of a @directive that may
// appear in a GraphQL schema written in Schema Definition Language.
//
// By overriding one or more visit{Object,Union,...} methods, a subclass
// registers interest in certain schema types, such as GraphQLObjectType,
// GraphQLUnionType, etc. When SchemaDirectiveVisitor.visitSchemaDirectives is
// called with a GraphQLSchema object and a map of visitor subclasses, the
// overidden methods of those subclasses allow the visitors to obtain
// references to any type objects that have @directives attached to them,
// enabling visitors to inspect or modify the schema as appropriate.
//
// For example, if a directive called @rest(url: "...") appears after a field
// definition, a SchemaDirectiveVisitor subclass could provide meaning to that
// directive by overriding the visitFieldDefinition method (which receives a
// GraphQLField parameter), and then the body of that visitor method could
// manipulate the field's resolver function to fetch data from a REST endpoint
// described by the url argument passed to the @rest directive:
//
//   const typeDefs = `
//   type Query {
//     people: [Person] @rest(url: "/api/v1/people")
//   }`;
//
//   const schema = makeExecutableSchema({ typeDefs });
//
//   SchemaDirectiveVisitor.visitSchemaDirectives(schema, {
//     rest: class extends SchemaDirectiveVisitor {
//       public visitFieldDefinition(field: GraphQLField<any, any>) {
//         const { url } = this.args;
//         field.resolve = () => fetch(url);
//       }
//     }
//   });
//
// The subclass in this example is defined as an anonymous class expression,
// for brevity. A truly reusable SchemaDirectiveVisitor would most likely be
// defined in a library using a named class declaration, and then exported for
// consumption by other modules and packages.
//
// See below for a complete list of overridable visitor methods, their
// parameter types, and more details about the properties exposed by instances
// of the SchemaDirectiveVisitor class.
var SchemaDirectiveVisitor = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __extends */ "b"])(SchemaDirectiveVisitor, _super);
    // Mark the constructor protected to enforce passing SchemaDirectiveVisitor
    // subclasses (not instances) to visitSchemaDirectives.
    function SchemaDirectiveVisitor(config) {
        var _this = _super.call(this) || this;
        _this.name = config.name;
        _this.args = config.args;
        _this.visitedType = config.visitedType;
        _this.schema = config.schema;
        _this.context = config.context;
        return _this;
    }
    // Override this method to return a custom GraphQLDirective (or modify one
    // already present in the schema) to enforce argument types, provide default
    // argument values, or specify schema locations where this @directive may
    // appear. By default, any declaration found in the schema will be returned.
    SchemaDirectiveVisitor.getDirectiveDeclaration = function (directiveName, schema) {
        return schema.getDirective(directiveName);
    };
    // Call SchemaDirectiveVisitor.visitSchemaDirectives to visit every
    // @directive in the schema and create an appropriate SchemaDirectiveVisitor
    // instance to visit the object decorated by the @directive.
    SchemaDirectiveVisitor.visitSchemaDirectives = function (schema, 
    // The keys of this object correspond to directive names as they appear
    // in the schema, and the values should be subclasses (not instances!)
    // of the SchemaDirectiveVisitor class. This distinction is important
    // because a new SchemaDirectiveVisitor instance will be created each
    // time a matching directive is found in the schema AST, with arguments
    // and other metadata specific to that occurrence. To help prevent the
    // mistake of passing instances, the SchemaDirectiveVisitor constructor
    // method is marked as protected.
    directiveVisitors, 
    // Optional context object that will be available to all visitor instances
    // via this.context. Defaults to an empty null-prototype object.
    context) {
        if (context === void 0) { context = Object.create(null); }
        // If the schema declares any directives for public consumption, record
        // them here so that we can properly coerce arguments when/if we encounter
        // an occurrence of the directive while walking the schema below.
        var declaredDirectives = this.getDeclaredDirectives(schema, directiveVisitors);
        // Map from directive names to lists of SchemaDirectiveVisitor instances
        // created while visiting the schema.
        var createdVisitors = keyValMap(Object.keys(directiveVisitors), function (item) { return item; }, function () { return []; });
        var directiveVisitorMap = toObjMap(directiveVisitors);
        function visitorSelector(type, methodName) {
            var directiveNodes = type.astNode != null ? type.astNode.directives : [];
            var extensionASTNodes = type.extensionASTNodes;
            if (extensionASTNodes != null) {
                extensionASTNodes.forEach(function (extensionASTNode) {
                    directiveNodes = directiveNodes.concat(extensionASTNode.directives);
                });
            }
            var visitors = [];
            directiveNodes.forEach(function (directiveNode) {
                var directiveName = directiveNode.name.value;
                if (!(directiveName in directiveVisitorMap)) {
                    return;
                }
                var visitorClass = directiveVisitorMap[directiveName];
                // Avoid creating visitor objects if visitorClass does not override
                // the visitor method named by methodName.
                if (!visitorClass.implementsVisitorMethod(methodName)) {
                    return;
                }
                var decl = declaredDirectives[directiveName];
                var args;
                if (decl != null) {
                    // If this directive was explicitly declared, use the declared
                    // argument types (and any default values) to check, coerce, and/or
                    // supply default values for the given arguments.
                    args = getArgumentValues(decl, directiveNode);
                }
                else {
                    // If this directive was not explicitly declared, just convert the
                    // argument nodes to their corresponding JavaScript values.
                    args = Object.create(null);
                    if (directiveNode.arguments != null) {
                        directiveNode.arguments.forEach(function (arg) {
                            args[arg.name.value] = valueFromASTUntyped(arg.value);
                        });
                    }
                }
                // As foretold in comments near the top of the visitSchemaDirectives
                // method, this is where instances of the SchemaDirectiveVisitor class
                // get created and assigned names. While subclasses could override the
                // constructor method, the constructor is marked as protected, so
                // these are the only arguments that will ever be passed.
                visitors.push(new visitorClass({
                    name: directiveName,
                    args: args,
                    visitedType: type,
                    schema: schema,
                    context: context,
                }));
            });
            if (visitors.length > 0) {
                visitors.forEach(function (visitor) {
                    createdVisitors[visitor.name].push(visitor);
                });
            }
            return visitors;
        }
        visitSchema(schema, visitorSelector);
        return createdVisitors;
    };
    SchemaDirectiveVisitor.getDeclaredDirectives = function (schema, directiveVisitors) {
        var directiveVisitorMap = toObjMap(directiveVisitors);
        var declaredDirectives = keyMap(schema.getDirectives(), function (d) { return d.name; });
        // If the visitor subclass overrides getDirectiveDeclaration, and it
        // returns a non-null GraphQLDirective, use that instead of any directive
        // declared in the schema itself. Reasoning: if a SchemaDirectiveVisitor
        // goes to the trouble of implementing getDirectiveDeclaration, it should
        // be able to rely on that implementation.
        Object.entries(directiveVisitors).forEach(function (_a) {
            var directiveName = _a[0], visitorClass = _a[1];
            var decl = visitorClass.getDirectiveDeclaration(directiveName, schema);
            if (decl != null) {
                declaredDirectives[directiveName] = decl;
            }
        });
        Object.entries(declaredDirectives).forEach(function (_a) {
            var name = _a[0], decl = _a[1];
            if (!(name in directiveVisitorMap)) {
                // SchemaDirectiveVisitors.visitSchemaDirectives might be called
                // multiple times with partial directiveVisitors maps, so it's not
                // necessarily an error for directiveVisitors to be missing an
                // implementation of a directive that was declared in the schema.
                return;
            }
            var visitorClass = directiveVisitorMap[name];
            decl.locations.forEach(function (loc) {
                var visitorMethodName = directiveLocationToVisitorMethodName(loc);
                if (SchemaVisitor.implementsVisitorMethod(visitorMethodName) &&
                    !visitorClass.implementsVisitorMethod(visitorMethodName)) {
                    // While visitor subclasses may implement extra visitor methods,
                    // it's definitely a mistake if the GraphQLDirective declares itself
                    // applicable to certain schema locations, and the visitor subclass
                    // does not implement all the corresponding methods.
                    throw new Error("SchemaDirectiveVisitor for @" + name + " must implement " + visitorMethodName + " method");
                }
            });
        });
        return declaredDirectives;
    };
    return SchemaDirectiveVisitor;
}(SchemaVisitor));
// Convert a string like "FIELD_DEFINITION" to "visitFieldDefinition".
function directiveLocationToVisitorMethodName(loc) {
    return ('visit' +
        loc.replace(/([^_]*)_?/g, function (_wholeMatch, part) {
            return part.charAt(0).toUpperCase() + part.slice(1).toLowerCase();
        }));
}

function forEachField(schema, fn) {
    var typeMap = schema.getTypeMap();
    Object.keys(typeMap).forEach(function (typeName) {
        var type = typeMap[typeName];
        // TODO: maybe have an option to include these?
        if (!Object(graphql__WEBPACK_IMPORTED_MODULE_3__["getNamedType"])(type).name.startsWith('__') && Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isObjectType"])(type)) {
            var fields_1 = type.getFields();
            Object.keys(fields_1).forEach(function (fieldName) {
                var field = fields_1[fieldName];
                fn(field, typeName, fieldName);
            });
        }
    });
}

function forEachDefaultValue(schema, fn) {
    var typeMap = schema.getTypeMap();
    Object.keys(typeMap).forEach(function (typeName) {
        var type = typeMap[typeName];
        if (!Object(graphql__WEBPACK_IMPORTED_MODULE_3__["getNamedType"])(type).name.startsWith('__')) {
            if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isObjectType"])(type)) {
                var fields_1 = type.getFields();
                Object.keys(fields_1).forEach(function (fieldName) {
                    var field = fields_1[fieldName];
                    field.args.forEach(function (arg) {
                        arg.defaultValue = fn(arg.type, arg.defaultValue);
                    });
                });
            }
            else if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isInputObjectType"])(type)) {
                var fields_2 = type.getFields();
                Object.keys(fields_2).forEach(function (fieldName) {
                    var field = fields_2[fieldName];
                    field.defaultValue = fn(field.type, field.defaultValue);
                });
            }
        }
    });
}

function applySchemaTransforms(originalSchema, transforms) {
    return transforms.reduce(function (schema, transform) {
        return transform.transformSchema != null
            ? transform.transformSchema(cloneSchema(schema))
            : schema;
    }, originalSchema);
}
function applyRequestTransforms(originalRequest, transforms) {
    return transforms.reduce(function (request, transform) {
        return transform.transformRequest != null
            ? transform.transformRequest(request)
            : request;
    }, originalRequest);
}
function applyResultTransforms(originalResult, transforms) {
    return transforms.reduceRight(function (result, transform) {
        return transform.transformResult != null
            ? transform.transformResult(result)
            : result;
    }, originalResult);
}

function linkToFetcher(link) {
    return function (fetcherOperation) {
        return Object(apollo_link__WEBPACK_IMPORTED_MODULE_2__["toPromise"])(Object(apollo_link__WEBPACK_IMPORTED_MODULE_2__["execute"])(link, fetcherOperation));
    };
}

function observableToAsyncIterable(observable) {
    var _a;
    var pullQueue = [];
    var pushQueue = [];
    var listening = true;
    var pushValue = function (value) {
        if (pullQueue.length !== 0) {
            pullQueue.shift()({ value: value, done: false });
        }
        else {
            pushQueue.push({ value: value });
        }
    };
    var pushError = function (error) {
        if (pullQueue.length !== 0) {
            pullQueue.shift()({ value: { errors: [error] }, done: false });
        }
        else {
            pushQueue.push({ value: { errors: [error] } });
        }
    };
    var pullValue = function () {
        return new Promise(function (resolve) {
            if (pushQueue.length !== 0) {
                var element = pushQueue.shift();
                // either {value: {errors: [...]}} or {value: ...}
                resolve(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, element), { done: false }));
            }
            else {
                pullQueue.push(resolve);
            }
        });
    };
    var subscription = observable.subscribe({
        next: function (value) {
            pushValue(value);
        },
        error: function (err) {
            pushError(err);
        },
    });
    var emptyQueue = function () {
        if (listening) {
            listening = false;
            subscription.unsubscribe();
            pullQueue.forEach(function (resolve) { return resolve({ value: undefined, done: true }); });
            pullQueue.length = 0;
            pushQueue.length = 0;
        }
    };
    return _a = {
            next: function () {
                return listening ? pullValue() : this.return();
            },
            return: function () {
                emptyQueue();
                return Promise.resolve({ value: undefined, done: true });
            },
            throw: function (error) {
                emptyQueue();
                return Promise.reject(error);
            }
        },
        _a[iterall__WEBPACK_IMPORTED_MODULE_1__["$$asyncIterator"]] = function () {
            return this;
        },
        _a;
}

/**
 * Given an AsyncIterable and a callback function, return an AsyncIterator
 * which produces values mapped via calling the callback function.
 */
function mapAsyncIterator(iterator, callback, rejectCallback) {
    var _a;
    var $return;
    var abruptClose;
    if (typeof iterator.return === 'function') {
        $return = iterator.return;
        abruptClose = function (error) {
            var rethrow = function () { return Promise.reject(error); };
            return $return.call(iterator).then(rethrow, rethrow);
        };
    }
    function mapResult(result) {
        return result.done
            ? result
            : asyncMapValue(result.value, callback).then(iteratorResult, abruptClose);
    }
    var mapReject;
    if (rejectCallback) {
        // Capture rejectCallback to ensure it cannot be null.
        var reject_1 = rejectCallback;
        mapReject = function (error) {
            return asyncMapValue(error, reject_1).then(iteratorResult, abruptClose);
        };
    }
    return _a = {
            next: function () {
                return iterator.next().then(mapResult, mapReject);
            },
            return: function () {
                return $return
                    ? $return.call(iterator).then(mapResult, mapReject)
                    : Promise.resolve({ value: undefined, done: true });
            },
            throw: function (error) {
                if (typeof iterator.throw === 'function') {
                    return iterator.throw(error).then(mapResult, mapReject);
                }
                return Promise.reject(error).catch(abruptClose);
            }
        },
        _a[iterall__WEBPACK_IMPORTED_MODULE_1__["$$asyncIterator"]] = function () {
            return this;
        },
        _a;
}
function asyncMapValue(value, callback) {
    return new Promise(function (resolve) { return resolve(callback(value)); });
}
function iteratorResult(value) {
    return { value: value, done: false };
}

function getDelegatingOperation(parentType, schema) {
    if (parentType === schema.getMutationType()) {
        return 'mutation';
    }
    else if (parentType === schema.getSubscriptionType()) {
        return 'subscription';
    }
    return 'query';
}
function createRequestFromInfo(_a) {
    var info = _a.info, _b = _a.operation, operation = _b === void 0 ? getDelegatingOperation(info.parentType, info.schema) : _b, _c = _a.fieldName, fieldName = _c === void 0 ? info.fieldName : _c, selectionSet = _a.selectionSet, fieldNodes = _a.fieldNodes;
    return createRequest({
        sourceSchema: info.schema,
        sourceParentType: info.parentType,
        sourceFieldName: info.fieldName,
        fragments: info.fragments,
        variableDefinitions: info.operation.variableDefinitions,
        variableValues: info.variableValues,
        targetOperation: operation,
        targetFieldName: fieldName,
        selectionSet: selectionSet,
        fieldNodes: selectionSet != null
            ? undefined
            : fieldNodes != null
                ? fieldNodes
                : info.fieldNodes,
    });
}
function createRequest(_a) {
    var sourceSchema = _a.sourceSchema, sourceParentType = _a.sourceParentType, sourceFieldName = _a.sourceFieldName, fragments = _a.fragments, variableDefinitions = _a.variableDefinitions, variableValues = _a.variableValues, targetOperation = _a.targetOperation, targetFieldName = _a.targetFieldName, selectionSet = _a.selectionSet, fieldNodes = _a.fieldNodes;
    var argumentNodes;
    var newSelectionSet = selectionSet;
    if (!selectionSet && fieldNodes != null) {
        var selections = fieldNodes.reduce(function (acc, fieldNode) {
            return fieldNode.selectionSet != null
                ? acc.concat(fieldNode.selectionSet.selections)
                : acc;
        }, []);
        newSelectionSet = selections.length
            ? {
                kind: graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].SELECTION_SET,
                selections: selections,
            }
            : undefined;
        argumentNodes = fieldNodes[0].arguments;
    }
    else {
        argumentNodes = [];
    }
    var newVariables = Object.create(null);
    var variableDefinitionMap = Object.create(null);
    variableDefinitions.forEach(function (def) {
        var varName = def.variable.name.value;
        variableDefinitionMap[varName] = def;
        var varType = Object(graphql__WEBPACK_IMPORTED_MODULE_3__["typeFromAST"])(sourceSchema, def.type);
        newVariables[varName] = serializeInputValue(varType, variableValues[varName]);
    });
    var argumentNodeMap = keyMap(argumentNodes, function (arg) { return arg.name.value; });
    updateArgumentsWithDefaults(sourceParentType, sourceFieldName, argumentNodeMap, variableDefinitionMap, newVariables);
    var rootfieldNode = {
        kind: graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].FIELD,
        alias: null,
        arguments: Object.keys(argumentNodeMap).map(function (argName) { return argumentNodeMap[argName]; }),
        selectionSet: newSelectionSet,
        name: {
            kind: graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].NAME,
            value: targetFieldName || fieldNodes[0].name.value,
        },
    };
    var operationDefinition = {
        kind: graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].OPERATION_DEFINITION,
        operation: targetOperation,
        variableDefinitions: Object.keys(variableDefinitionMap).map(function (varName) { return variableDefinitionMap[varName]; }),
        selectionSet: {
            kind: graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].SELECTION_SET,
            selections: [rootfieldNode],
        },
    };
    var fragmentDefinitions = Object.keys(fragments).map(function (fragmentName) { return fragments[fragmentName]; });
    var document = {
        kind: graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].DOCUMENT,
        definitions: Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __spreadArrays */ "d"])([operationDefinition], fragmentDefinitions),
    };
    return {
        document: document,
        variables: newVariables,
    };
}
function updateArgumentsWithDefaults(sourceParentType, sourceFieldName, argumentNodeMap, variableDefinitionMap, variableValues) {
    var sourceField = sourceParentType.getFields()[sourceFieldName];
    sourceField.args.forEach(function (argument) {
        var argName = argument.name;
        var sourceArgType = argument.type;
        if (argumentNodeMap[argName] === undefined) {
            var defaultValue = argument.defaultValue;
            if (defaultValue !== undefined) {
                updateArgument(argName, sourceArgType, argumentNodeMap, variableDefinitionMap, variableValues, serializeInputValue(sourceArgType, defaultValue));
            }
        }
    });
}

function delegateToSchema(options) {
    if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isSchema"])(options)) {
        throw new Error('Passing positional arguments to delegateToSchema is deprecated. ' +
            'Please pass named parameters instead.');
    }
    var info = options.info, _a = options.operation, operation = _a === void 0 ? getDelegatingOperation(info.parentType, info.schema) : _a, _b = options.fieldName, fieldName = _b === void 0 ? info.fieldName : _b, _c = options.returnType, returnType = _c === void 0 ? info.returnType : _c, selectionSet = options.selectionSet, fieldNodes = options.fieldNodes;
    var request = createRequestFromInfo({
        info: info,
        operation: operation,
        fieldName: fieldName,
        selectionSet: selectionSet,
        fieldNodes: fieldNodes,
    });
    return delegateRequest(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, options), { request: request,
        operation: operation,
        fieldName: fieldName,
        returnType: returnType }));
}
function buildDelegationTransforms(subschemaOrSubschemaConfig, info, context, targetSchema, fieldName, args, returnType, transforms, skipTypeMerging) {
    var delegationTransforms = [
        new CheckResultAndHandleErrors(info, fieldName, subschemaOrSubschemaConfig, context, returnType, skipTypeMerging),
    ];
    if (info.mergeInfo != null) {
        delegationTransforms.push(new AddReplacementSelectionSets(info.schema, info.mergeInfo.replacementSelectionSets), new AddMergedTypeFragments(info.schema, info.mergeInfo.mergedTypes));
    }
    delegationTransforms = delegationTransforms.concat(transforms);
    delegationTransforms.push(new ExpandAbstractTypes(info.schema, targetSchema));
    if (info.mergeInfo != null) {
        delegationTransforms.push(new AddReplacementFragments(targetSchema, info.mergeInfo.replacementFragments));
    }
    if (args != null) {
        delegationTransforms.push(new AddArgumentsAsVariables(targetSchema, args));
    }
    delegationTransforms.push(new FilterToSchema(targetSchema), new AddTypenameToAbstract(targetSchema));
    return delegationTransforms;
}
function delegateRequest(_a) {
    var request = _a.request, subschemaOrSubschemaConfig = _a.schema, rootValue = _a.rootValue, info = _a.info, _b = _a.operation, operation = _b === void 0 ? getDelegatingOperation(info.parentType, info.schema) : _b, _c = _a.fieldName, fieldName = _c === void 0 ? info.fieldName : _c, args = _a.args, _d = _a.returnType, returnType = _d === void 0 ? info.returnType : _d, context = _a.context, _e = _a.transforms, transforms = _e === void 0 ? [] : _e, skipValidation = _a.skipValidation, skipTypeMerging = _a.skipTypeMerging;
    var targetSchema;
    var targetRootValue;
    var requestTransforms = transforms.slice();
    var subschemaConfig;
    if (isSubschemaConfig(subschemaOrSubschemaConfig)) {
        subschemaConfig = subschemaOrSubschemaConfig;
        targetSchema = subschemaConfig.schema;
        targetRootValue =
            rootValue != null
                ? rootValue
                : subschemaConfig.rootValue != null
                    ? subschemaConfig.rootValue
                    : info.rootValue;
        if (subschemaConfig.transforms != null) {
            requestTransforms = requestTransforms.concat(subschemaConfig.transforms);
        }
    }
    else {
        targetSchema = subschemaOrSubschemaConfig;
        targetRootValue = rootValue != null ? rootValue : info.rootValue;
    }
    var delegationTransforms = buildDelegationTransforms(subschemaOrSubschemaConfig, info, context, targetSchema, fieldName, args, returnType, requestTransforms.reverse(), skipTypeMerging);
    var processedRequest = applyRequestTransforms(request, delegationTransforms);
    if (!skipValidation) {
        var errors = Object(graphql__WEBPACK_IMPORTED_MODULE_3__["validate"])(targetSchema, processedRequest.document);
        if (errors.length > 0) {
            var combinedError = combineErrors(errors);
            throw combinedError;
        }
    }
    if (operation === 'query' || operation === 'mutation') {
        var executor = createExecutor(targetSchema, targetRootValue, context, subschemaConfig);
        var executionResult = executor({
            document: processedRequest.document,
            context: context,
            variables: processedRequest.variables,
        });
        if (executionResult instanceof Promise) {
            return executionResult.then(function (originalResult) {
                return applyResultTransforms(originalResult, delegationTransforms);
            });
        }
        return applyResultTransforms(executionResult, delegationTransforms);
    }
    var subscriber = createSubscriber(targetSchema, targetRootValue, context, subschemaConfig);
    return subscriber({
        document: processedRequest.document,
        context: context,
        variables: processedRequest.variables,
    }).then(function (subscriptionResult) {
        if (Object(iterall__WEBPACK_IMPORTED_MODULE_1__["isAsyncIterable"])(subscriptionResult)) {
            // "subscribe" to the subscription result and map the result through the transforms
            return mapAsyncIterator(subscriptionResult, function (result) {
                var _a;
                var transformedResult = applyResultTransforms(result, delegationTransforms);
                // wrap with fieldName to return for an additional round of resolutioon
                // with payload as rootValue
                return _a = {},
                    _a[info.fieldName] = transformedResult,
                    _a;
            });
        }
        return applyResultTransforms(subscriptionResult, delegationTransforms);
    });
}
function createExecutor(schema, rootValue, context, subschemaConfig) {
    var fetcher;
    var targetRootValue = rootValue;
    if (subschemaConfig != null) {
        if (subschemaConfig.dispatcher != null) {
            var dynamicLinkOrFetcher = subschemaConfig.dispatcher(context);
            fetcher =
                typeof dynamicLinkOrFetcher === 'function'
                    ? dynamicLinkOrFetcher
                    : linkToFetcher(dynamicLinkOrFetcher);
        }
        else if (subschemaConfig.link != null) {
            fetcher = linkToFetcher(subschemaConfig.link);
        }
        else if (subschemaConfig.fetcher != null) {
            fetcher = subschemaConfig.fetcher;
        }
        if (!fetcher && !rootValue && subschemaConfig.rootValue != null) {
            targetRootValue = subschemaConfig.rootValue;
        }
    }
    if (fetcher != null) {
        return function (_a) {
            var document = _a.document, graphqlContext = _a.context, variables = _a.variables;
            return fetcher({
                query: document,
                variables: variables,
                context: { graphqlContext: graphqlContext },
            });
        };
    }
    return function (_a) {
        var document = _a.document, graphqlContext = _a.context, variables = _a.variables;
        return Object(graphql__WEBPACK_IMPORTED_MODULE_3__["execute"])({
            schema: schema,
            document: document,
            rootValue: targetRootValue,
            contextValue: graphqlContext,
            variableValues: variables,
        });
    };
}
function createSubscriber(schema, rootValue, context, subschemaConfig) {
    var link;
    var targetRootValue = rootValue;
    if (subschemaConfig != null) {
        if (subschemaConfig.dispatcher != null) {
            link = subschemaConfig.dispatcher(context);
        }
        else if (subschemaConfig.link != null) {
            link = subschemaConfig.link;
        }
        if (!link && !rootValue && subschemaConfig.rootValue != null) {
            targetRootValue = subschemaConfig.rootValue;
        }
    }
    if (link != null) {
        return function (_a) {
            var document = _a.document, graphqlContext = _a.context, variables = _a.variables;
            var operation = {
                query: document,
                variables: variables,
                context: { graphqlContext: graphqlContext },
            };
            var observable = Object(apollo_link__WEBPACK_IMPORTED_MODULE_2__["execute"])(link, operation);
            return Promise.resolve(observableToAsyncIterable(observable));
        };
    }
    return function (_a) {
        var document = _a.document, graphqlContext = _a.context, variables = _a.variables;
        return Object(graphql__WEBPACK_IMPORTED_MODULE_3__["subscribe"])({
            schema: schema,
            document: document,
            rootValue: targetRootValue,
            contextValue: graphqlContext,
            variableValues: variables,
        });
    };
}

// @schemaDefinition: A GraphQL type schema in shorthand
// @resolvers: Definitions for resolvers to be merged with schema
var SchemaError = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __extends */ "b"])(SchemaError, _super);
    function SchemaError(message) {
        var _this = _super.call(this, message) || this;
        _this.message = message;
        Error.captureStackTrace(_this, _this.constructor);
        return _this;
    }
    return SchemaError;
}(Error));

// If we have any union or interface types throw if no there is no resolveType or isTypeOf resolvers
function checkForResolveTypeResolver(schema, requireResolversForResolveType) {
    Object.keys(schema.getTypeMap())
        .map(function (typeName) { return schema.getType(typeName); })
        .forEach(function (type) {
        if (!Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isAbstractType"])(type)) {
            return;
        }
        if (!type.resolveType) {
            if (!requireResolversForResolveType) {
                return;
            }
            throw new SchemaError("Type \"" + type.name + "\" is missing a \"__resolveType\" resolver. Pass false into " +
                '"resolverValidationOptions.requireResolversForResolveType" to disable this error.');
        }
    });
}

function extendResolversFromInterfaces(schema, resolvers) {
    var typeNames = Object.keys(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, schema.getTypeMap()), resolvers));
    var extendedResolvers = {};
    typeNames.forEach(function (typeName) {
        var typeResolvers = resolvers[typeName];
        var type = schema.getType(typeName);
        if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isObjectType"])(type) ||
            (graphqlVersion() >= 15 && Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isInterfaceType"])(type))) {
            var interfaceResolvers = type
                .getInterfaces()
                .map(function (iFace) { return resolvers[iFace.name]; });
            extendedResolvers[typeName] = Object.assign.apply(Object, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __spreadArrays */ "d"])([{}], interfaceResolvers, [typeResolvers]));
        }
        else if (typeResolvers != null) {
            extendedResolvers[typeName] = typeResolvers;
        }
    });
    return extendedResolvers;
}

function addResolversToSchema(schemaOrOptions, legacyInputResolvers, legacyInputValidationOptions) {
    var options = Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isSchema"])(schemaOrOptions)
        ? {
            schema: schemaOrOptions,
            resolvers: legacyInputResolvers,
            resolverValidationOptions: legacyInputValidationOptions,
        }
        : schemaOrOptions;
    var schema = options.schema, inputResolvers = options.resolvers, defaultFieldResolver = options.defaultFieldResolver, _a = options.resolverValidationOptions, resolverValidationOptions = _a === void 0 ? {} : _a, _b = options.inheritResolversFromInterfaces, inheritResolversFromInterfaces = _b === void 0 ? false : _b;
    var _c = resolverValidationOptions.allowResolversNotInSchema, allowResolversNotInSchema = _c === void 0 ? false : _c, requireResolversForResolveType = resolverValidationOptions.requireResolversForResolveType;
    var resolvers = inheritResolversFromInterfaces
        ? extendResolversFromInterfaces(schema, inputResolvers)
        : inputResolvers;
    var typeMap = schema.getTypeMap();
    Object.keys(resolvers).forEach(function (typeName) {
        var resolverValue = resolvers[typeName];
        var resolverType = typeof resolverValue;
        if (resolverType !== 'object' && resolverType !== 'function') {
            throw new SchemaError("\"" + typeName + "\" defined in resolvers, but has invalid value \"" + resolverValue + "\". A resolver's value must be of type object or function.");
        }
        var type = schema.getType(typeName);
        if (!type && typeName !== '__schema') {
            if (allowResolversNotInSchema) {
                return;
            }
            throw new SchemaError("\"" + typeName + "\" defined in resolvers, but not in schema");
        }
        if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isScalarType"])(type)) {
            // Support -- without recommending -- overriding default scalar types
            Object.keys(resolverValue).forEach(function (fieldName) {
                if (fieldName.startsWith('__')) {
                    type[fieldName.substring(2)] = resolverValue[fieldName];
                }
                else {
                    type[fieldName] = resolverValue[fieldName];
                }
            });
        }
        else if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isEnumType"])(type)) {
            // We've encountered an enum resolver that is being used to provide an
            // internal enum value.
            // Reference: https://www.apollographql.com/docs/graphql-tools/scalars.html#internal-values
            Object.keys(resolverValue).forEach(function (fieldName) {
                if (!type.getValue(fieldName)) {
                    if (allowResolversNotInSchema) {
                        return;
                    }
                    throw new SchemaError(typeName + "." + fieldName + " was defined in resolvers, but enum is not in schema");
                }
            });
            var config = toConfig(type);
            var values = type.getValues();
            var newValues = keyValMap(values, function (value) { return value.name; }, function (value) {
                var newValue = Object.keys(resolverValue).includes(value.name)
                    ? resolverValue[value.name]
                    : value.name;
                return {
                    value: newValue,
                    deprecationReason: value.deprecationReason,
                    description: value.description,
                    astNode: value.astNode,
                };
            });
            // healSchema called later to update all fields to new type
            typeMap[typeName] = new graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLEnumType"](Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, config), { values: newValues }));
        }
        else if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isUnionType"])(type)) {
            Object.keys(resolverValue).forEach(function (fieldName) {
                if (fieldName.startsWith('__')) {
                    // this is for isTypeOf and resolveType and all the other stuff.
                    type[fieldName.substring(2)] = resolverValue[fieldName];
                    return;
                }
                if (allowResolversNotInSchema) {
                    return;
                }
                throw new SchemaError(typeName + " was defined in resolvers, but it's not an object");
            });
        }
        else if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isObjectType"])(type) || Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isInterfaceType"])(type)) {
            Object.keys(resolverValue).forEach(function (fieldName) {
                if (fieldName.startsWith('__')) {
                    // this is for isTypeOf and resolveType and all the other stuff.
                    type[fieldName.substring(2)] = resolverValue[fieldName];
                    return;
                }
                var fields = type.getFields();
                var field = fields[fieldName];
                if (field == null) {
                    if (allowResolversNotInSchema) {
                        return;
                    }
                    throw new SchemaError(typeName + "." + fieldName + " defined in resolvers, but not in schema");
                }
                var fieldResolve = resolverValue[fieldName];
                if (typeof fieldResolve === 'function') {
                    // for convenience. Allows shorter syntax in resolver definition file
                    field.resolve = fieldResolve;
                }
                else {
                    if (typeof fieldResolve !== 'object') {
                        throw new SchemaError("Resolver " + typeName + "." + fieldName + " must be object or function");
                    }
                    setFieldProperties(field, fieldResolve);
                }
            });
        }
    });
    checkForResolveTypeResolver(schema, requireResolversForResolveType);
    // serialize all default values prior to healing fields with new scalar/enum types.
    forEachDefaultValue(schema, serializeInputValue);
    // schema may have new scalar/enum types that require healing
    healSchema(schema);
    // reparse all default values with new parsing functions.
    forEachDefaultValue(schema, parseInputValue);
    if (defaultFieldResolver != null) {
        forEachField(schema, function (field) {
            if (!field.resolve) {
                field.resolve = defaultFieldResolver;
            }
        });
    }
    return schema;
}
function setFieldProperties(field, propertiesObj) {
    Object.keys(propertiesObj).forEach(function (propertyName) {
        field[propertyName] = propertiesObj[propertyName];
    });
}

// wraps all resolvers of query, mutation or subscription fields
// with the provided function to simulate a root schema level resolver
function addSchemaLevelResolver(schema, fn) {
    // TODO test that schema is a schema, fn is a function
    var rootTypes = [
        schema.getQueryType(),
        schema.getMutationType(),
        schema.getSubscriptionType(),
    ].filter(function (x) { return Boolean(x); });
    rootTypes.forEach(function (type) {
        if (type != null) {
            // XXX this should run at most once per request to simulate a true root resolver
            // for graphql-js this is an approximation that works with queries but not mutations
            var rootResolveFn_1 = runAtMostOncePerRequest(fn);
            var fields_1 = type.getFields();
            Object.keys(fields_1).forEach(function (fieldName) {
                // XXX if the type is a subscription, a same query AST will be ran multiple times so we
                // deactivate here the runOnce if it's a subscription. This may not be optimal though...
                if (type === schema.getSubscriptionType()) {
                    fields_1[fieldName].resolve = wrapResolver(fields_1[fieldName].resolve, fn);
                }
                else {
                    fields_1[fieldName].resolve = wrapResolver(fields_1[fieldName].resolve, rootResolveFn_1);
                }
            });
        }
    });
}
// XXX badly named function. this doesn't really wrap, it just chains resolvers...
function wrapResolver(innerResolver, outerResolver) {
    return function (obj, args, ctx, info) {
        return Promise.resolve(outerResolver(obj, args, ctx, info)).then(function (root) {
            if (innerResolver != null) {
                return innerResolver(root, args, ctx, info);
            }
            return Object(graphql__WEBPACK_IMPORTED_MODULE_3__["defaultFieldResolver"])(root, args, ctx, info);
        });
    };
}
// XXX this function only works for resolvers
// XXX very hacky way to remember if the function
// already ran for this request. This will only work
// if people don't actually cache the operation.
// if they do cache the operation, they will have to
// manually remove the __runAtMostOnce before every request.
function runAtMostOncePerRequest(fn) {
    var value;
    var randomNumber = Math.random();
    return function (root, args, ctx, info) {
        if (!info.operation['__runAtMostOnce']) {
            info.operation['__runAtMostOnce'] = {};
        }
        if (!info.operation['__runAtMostOnce'][randomNumber]) {
            info.operation['__runAtMostOnce'][randomNumber] = true;
            value = fn(root, args, ctx, info);
        }
        return value;
    };
}

function assertResolversPresent(schema, resolverValidationOptions) {
    if (resolverValidationOptions === void 0) { resolverValidationOptions = {}; }
    var _a = resolverValidationOptions.requireResolversForArgs, requireResolversForArgs = _a === void 0 ? false : _a, _b = resolverValidationOptions.requireResolversForNonScalar, requireResolversForNonScalar = _b === void 0 ? false : _b, _c = resolverValidationOptions.requireResolversForAllFields, requireResolversForAllFields = _c === void 0 ? false : _c;
    if (requireResolversForAllFields &&
        (requireResolversForArgs || requireResolversForNonScalar)) {
        throw new TypeError('requireResolversForAllFields takes precedence over the more specific assertions. ' +
            'Please configure either requireResolversForAllFields or requireResolversForArgs / ' +
            'requireResolversForNonScalar, but not a combination of them.');
    }
    forEachField(schema, function (field, typeName, fieldName) {
        // requires a resolver for *every* field.
        if (requireResolversForAllFields) {
            expectResolver(field, typeName, fieldName);
        }
        // requires a resolver on every field that has arguments
        if (requireResolversForArgs && field.args.length > 0) {
            expectResolver(field, typeName, fieldName);
        }
        // requires a resolver on every field that returns a non-scalar type
        if (requireResolversForNonScalar &&
            !Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isScalarType"])(Object(graphql__WEBPACK_IMPORTED_MODULE_3__["getNamedType"])(field.type))) {
            expectResolver(field, typeName, fieldName);
        }
    });
}
function expectResolver(field, typeName, fieldName) {
    if (!field.resolve) {
        // eslint-disable-next-line no-console
        console.warn("Resolver missing for \"" + typeName + "." + fieldName + "\". To disable this warning check https://github.com/apollostack/graphql-tools/issues/131");
        return;
    }
    if (typeof field.resolve !== 'function') {
        throw new SchemaError("Resolver \"" + typeName + "." + fieldName + "\" must be a function");
    }
}

function attachDirectiveResolvers(schema, directiveResolvers) {
    if (typeof directiveResolvers !== 'object') {
        throw new Error("Expected directiveResolvers to be of type object, got " + typeof directiveResolvers);
    }
    if (Array.isArray(directiveResolvers)) {
        throw new Error('Expected directiveResolvers to be of type object, got Array');
    }
    var schemaDirectives = Object.create(null);
    Object.keys(directiveResolvers).forEach(function (directiveName) {
        schemaDirectives[directiveName] = /** @class */ (function (_super) {
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __extends */ "b"])(class_1, _super);
            function class_1() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            class_1.prototype.visitFieldDefinition = function (field) {
                var resolver = directiveResolvers[directiveName];
                var originalResolver = field.resolve != null ? field.resolve : graphql__WEBPACK_IMPORTED_MODULE_3__["defaultFieldResolver"];
                var directiveArgs = this.args;
                field.resolve = function () {
                    var args = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        args[_i] = arguments[_i];
                    }
                    var source = args[0] /* original args */, context = args[2], info = args[3];
                    return resolver(function () {
                        return new Promise(function (resolve, reject) {
                            var result = originalResolver.apply(field, args);
                            if (result instanceof Error) {
                                reject(result);
                            }
                            resolve(result);
                        });
                    }, source, directiveArgs, context, info);
                };
            };
            return class_1;
        }(SchemaDirectiveVisitor));
    });
    SchemaDirectiveVisitor.visitSchemaDirectives(schema, schemaDirectives);
}

// takes a GraphQL-JS schema and an object of connectors, then attaches
// the connectors to the context by wrapping each query or mutation resolve
// function with a function that attaches connectors if they don't exist.
// attaches connectors only once to make sure they are singletons
var attachConnectorsToContext = Object(deprecated_decorator__WEBPACK_IMPORTED_MODULE_4__["deprecated"])({
    version: '0.7.0',
    url: 'https://github.com/apollostack/graphql-tools/issues/140',
}, function (schema, connectors) {
    if (!schema || !Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isSchema"])(schema)) {
        throw new Error('schema must be an instance of GraphQLSchema. ' +
            'This error could be caused by installing more than one version of GraphQL-JS');
    }
    if (typeof connectors !== 'object') {
        var connectorType = typeof connectors;
        throw new Error("Expected connectors to be of type object, got " + connectorType);
    }
    if (Object.keys(connectors).length === 0) {
        throw new Error('Expected connectors to not be an empty object');
    }
    if (Array.isArray(connectors)) {
        throw new Error('Expected connectors to be of type object, got Array');
    }
    if (schema['_apolloConnectorsAttached']) {
        throw new Error('Connectors already attached to context, cannot attach more than once');
    }
    schema['_apolloConnectorsAttached'] = true;
    var attachconnectorFn = function (root, _args, ctx) {
        if (typeof ctx !== 'object') {
            // if in any way possible, we should throw an error when the attachconnectors
            // function is called, not when a query is executed.
            var contextType = typeof ctx;
            throw new Error("Cannot attach connector because context is not an object: " + contextType);
        }
        if (typeof ctx.connectors === 'undefined') {
            ctx.connectors = {};
        }
        Object.keys(connectors).forEach(function (connectorName) {
            var connector = connectors[connectorName];
            if (connector.prototype != null) {
                ctx.connectors[connectorName] = new connector(ctx);
            }
            else {
                throw new Error('Connector must be a function or an class');
            }
        });
        return root;
    };
    addSchemaLevelResolver(schema, attachconnectorFn);
});

function extractExtensionDefinitions(ast) {
    var extensionDefs = ast.definitions.filter(function (def) {
        return def.kind === graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].OBJECT_TYPE_EXTENSION ||
            (graphqlVersion() >= 13 && def.kind === graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].INTERFACE_TYPE_EXTENSION) ||
            def.kind === graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].INPUT_OBJECT_TYPE_EXTENSION ||
            def.kind === graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].UNION_TYPE_EXTENSION ||
            def.kind === graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].ENUM_TYPE_EXTENSION ||
            def.kind === graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].SCALAR_TYPE_EXTENSION ||
            def.kind === graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].SCHEMA_EXTENSION;
    });
    return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, ast), { definitions: extensionDefs });
}
function filterExtensionDefinitions(ast) {
    var extensionDefs = ast.definitions.filter(function (def) {
        return def.kind !== graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].OBJECT_TYPE_EXTENSION &&
            def.kind !== graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].INTERFACE_TYPE_EXTENSION &&
            def.kind !== graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].INPUT_OBJECT_TYPE_EXTENSION &&
            def.kind !== graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].UNION_TYPE_EXTENSION &&
            def.kind !== graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].ENUM_TYPE_EXTENSION &&
            def.kind !== graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].SCALAR_TYPE_EXTENSION &&
            def.kind !== graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].SCHEMA_EXTENSION;
    });
    return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, ast), { definitions: extensionDefs });
}

function concatenateTypeDefs(typeDefinitionsAry, calledFunctionRefs) {
    if (calledFunctionRefs === void 0) { calledFunctionRefs = []; }
    var resolvedTypeDefinitions = [];
    typeDefinitionsAry.forEach(function (typeDef) {
        if (typeof typeDef === 'function') {
            if (calledFunctionRefs.indexOf(typeDef) === -1) {
                calledFunctionRefs.push(typeDef);
                resolvedTypeDefinitions = resolvedTypeDefinitions.concat(concatenateTypeDefs(typeDef(), calledFunctionRefs));
            }
        }
        else if (typeof typeDef === 'string') {
            resolvedTypeDefinitions.push(typeDef.trim());
        }
        else if (typeDef.kind !== undefined) {
            resolvedTypeDefinitions.push(Object(graphql__WEBPACK_IMPORTED_MODULE_3__["print"])(typeDef).trim());
        }
        else {
            var type = typeof typeDef;
            throw new SchemaError("typeDef array must contain only strings and functions, got " + type);
        }
    });
    return uniq(resolvedTypeDefinitions.map(function (x) { return x.trim(); })).join('\n');
}
function uniq(array) {
    return array.reduce(function (accumulator, currentValue) {
        return accumulator.indexOf(currentValue) === -1
            ? Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __spreadArrays */ "d"])(accumulator, [currentValue]) : accumulator;
    }, []);
}

function buildSchemaFromTypeDefinitions(typeDefinitions, parseOptions) {
    // TODO: accept only array here, otherwise interfaces get confusing.
    var myDefinitions = typeDefinitions;
    var astDocument;
    if (isDocumentNode(typeDefinitions)) {
        astDocument = typeDefinitions;
    }
    else if (typeof myDefinitions !== 'string') {
        if (!Array.isArray(myDefinitions)) {
            var type = typeof myDefinitions;
            throw new SchemaError("typeDefs must be a string, array or schema AST, got " + type);
        }
        myDefinitions = concatenateTypeDefs(myDefinitions);
    }
    if (typeof myDefinitions === 'string') {
        astDocument = Object(graphql__WEBPACK_IMPORTED_MODULE_3__["parse"])(myDefinitions, parseOptions);
    }
    var typesAst = filterExtensionDefinitions(astDocument);
    var backcompatOptions = { commentDescriptions: true };
    var schema = Object(graphql__WEBPACK_IMPORTED_MODULE_3__["buildASTSchema"])(typesAst, backcompatOptions);
    var extensionsAst = extractExtensionDefinitions(astDocument);
    if (extensionsAst.definitions.length > 0) {
        schema = Object(graphql__WEBPACK_IMPORTED_MODULE_3__["extendSchema"])(schema, extensionsAst, backcompatOptions);
    }
    return schema;
}
function isDocumentNode(typeDefinitions) {
    return typeDefinitions.kind !== undefined;
}

function chainResolvers(resolvers) {
    return function (root, args, ctx, info) {
        return resolvers.reduce(function (prev, curResolver) {
            if (curResolver != null) {
                return curResolver(prev, args, ctx, info);
            }
            return Object(graphql__WEBPACK_IMPORTED_MODULE_3__["defaultFieldResolver"])(prev, args, ctx, info);
        }, root);
    };
}

/*
 * fn: The function to decorate with the logger
 * logger: an object instance of type Logger
 * hint: an optional hint to add to the error's message
 */
function decorateWithLogger(fn, logger, hint) {
    var resolver = fn != null ? fn : graphql__WEBPACK_IMPORTED_MODULE_3__["defaultFieldResolver"];
    var logError = function (e) {
        // TODO: clone the error properly
        var newE = new Error();
        newE.stack = e.stack;
        /* istanbul ignore else: always get the hint from addErrorLoggingToSchema */
        if (hint) {
            newE['originalMessage'] = e.message;
            newE['message'] = "Error in resolver " + hint + "\n" + e.message;
        }
        logger.log(newE);
    };
    return function (root, args, ctx, info) {
        try {
            var result = resolver(root, args, ctx, info);
            // If the resolver returns a Promise log any Promise rejects.
            if (result &&
                typeof result.then === 'function' &&
                typeof result.catch === 'function') {
                result.catch(function (reason) {
                    // make sure that it's an error we're logging.
                    var error = reason instanceof Error ? reason : new Error(reason);
                    logError(error);
                    // We don't want to leave an unhandled exception so pass on error.
                    return reason;
                });
            }
            return result;
        }
        catch (e) {
            logError(e);
            // we want to pass on the error, just in case.
            throw e;
        }
    };
}

function makeExecutableSchema(_a) {
    var typeDefs = _a.typeDefs, _b = _a.resolvers, resolvers = _b === void 0 ? {} : _b, connectors = _a.connectors, logger = _a.logger, _c = _a.allowUndefinedInResolve, allowUndefinedInResolve = _c === void 0 ? true : _c, _d = _a.resolverValidationOptions, resolverValidationOptions = _d === void 0 ? {} : _d, directiveResolvers = _a.directiveResolvers, schemaDirectives = _a.schemaDirectives, _e = _a.parseOptions, parseOptions = _e === void 0 ? {} : _e, _f = _a.inheritResolversFromInterfaces, inheritResolversFromInterfaces = _f === void 0 ? false : _f;
    // Validate and clean up arguments
    if (typeof resolverValidationOptions !== 'object') {
        throw new SchemaError('Expected `resolverValidationOptions` to be an object');
    }
    if (!typeDefs) {
        throw new SchemaError('Must provide typeDefs');
    }
    // We allow passing in an array of resolver maps, in which case we merge them
    var resolverMap = Array.isArray(resolvers)
        ? resolvers
            .filter(function (resolverObj) { return typeof resolverObj === 'object'; })
            .reduce(mergeDeep, {})
        : resolvers;
    // Arguments are now validated and cleaned up
    var schema = buildSchemaFromTypeDefinitions(typeDefs, parseOptions);
    addResolversToSchema({
        schema: schema,
        resolvers: resolverMap,
        resolverValidationOptions: resolverValidationOptions,
        inheritResolversFromInterfaces: inheritResolversFromInterfaces,
    });
    assertResolversPresent(schema, resolverValidationOptions);
    if (!allowUndefinedInResolve) {
        addCatchUndefinedToSchema(schema);
    }
    if (logger != null) {
        addErrorLoggingToSchema(schema, logger);
    }
    if (typeof resolvers['__schema'] === 'function') {
        // TODO a bit of a hack now, better rewrite generateSchema to attach it there.
        // not doing that now, because I'd have to rewrite a lot of tests.
        addSchemaLevelResolver(schema, resolvers['__schema']);
    }
    if (connectors != null) {
        // connectors are optional, at least for now. That means you can just import them in the resolve
        // function if you want.
        attachConnectorsToContext(schema, connectors);
    }
    if (directiveResolvers != null) {
        attachDirectiveResolvers(schema, directiveResolvers);
    }
    if (schemaDirectives != null) {
        SchemaDirectiveVisitor.visitSchemaDirectives(schema, schemaDirectives);
    }
    return schema;
}
function decorateToCatchUndefined(fn, hint) {
    var resolve = fn == null ? graphql__WEBPACK_IMPORTED_MODULE_3__["defaultFieldResolver"] : fn;
    return function (root, args, ctx, info) {
        var result = resolve(root, args, ctx, info);
        if (typeof result === 'undefined') {
            throw new Error("Resolver for \"" + hint + "\" returned undefined");
        }
        return result;
    };
}
function addCatchUndefinedToSchema(schema) {
    forEachField(schema, function (field, typeName, fieldName) {
        var errorHint = typeName + "." + fieldName;
        field.resolve = decorateToCatchUndefined(field.resolve, errorHint);
    });
}
function addErrorLoggingToSchema(schema, logger) {
    if (!logger) {
        throw new Error('Must provide a logger');
    }
    if (typeof logger.log !== 'function') {
        throw new Error('Logger.log must be a function');
    }
    forEachField(schema, function (field, typeName, fieldName) {
        var errorHint = typeName + "." + fieldName;
        field.resolve = decorateWithLogger(field.resolve, logger, errorHint);
    });
}

// These functions are preserved for backwards compatibility.
// They are not simply rexported with new (old) names so as to allow
// typedoc to annotate them.
function addResolveFunctionsToSchema(schemaOrOptions, legacyInputResolvers, legacyInputValidationOptions) {
    return addResolversToSchema(schemaOrOptions, legacyInputResolvers, legacyInputValidationOptions);
}
function addSchemaLevelResolveFunction(schema, fn) {
    addSchemaLevelResolver(schema, fn);
}
function assertResolveFunctionsPresent(schema, resolverValidationOptions) {
    if (resolverValidationOptions === void 0) { resolverValidationOptions = {}; }
    assertResolversPresent(schema, resolverValidationOptions);
}

function getFinalPromise(object) {
    return Promise.resolve(object).then(function (resolvedObject) {
        if (resolvedObject == null) {
            return resolvedObject;
        }
        if (Array.isArray(resolvedObject)) {
            return Promise.all(resolvedObject.map(function (o) { return getFinalPromise(o); }));
        }
        else if (typeof resolvedObject === 'object') {
            var keys_1 = Object.keys(resolvedObject);
            return Promise.all(keys_1.map(function (key) { return getFinalPromise(resolvedObject[key]); })).then(function (awaitedValues) {
                for (var i = 0; i < keys_1.length; i++) {
                    resolvedObject[keys_1[i]] = awaitedValues[i];
                }
                return resolvedObject;
            });
        }
        return resolvedObject;
    });
}
var AwaitVariablesLink = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __extends */ "b"])(AwaitVariablesLink, _super);
    function AwaitVariablesLink() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    AwaitVariablesLink.prototype.request = function (operation, forward) {
        return new apollo_link__WEBPACK_IMPORTED_MODULE_2__["Observable"](function (observer) {
            var subscription;
            getFinalPromise(operation.variables)
                .then(function (resolvedVariables) {
                operation.variables = resolvedVariables;
                subscription = forward(operation).subscribe({
                    next: observer.next.bind(observer),
                    error: observer.error.bind(observer),
                    complete: observer.complete.bind(observer),
                });
            })
                .catch(observer.error.bind(observer));
            return function () {
                if (subscription != null) {
                    subscription.unsubscribe();
                }
            };
        });
    };
    return AwaitVariablesLink;
}(apollo_link__WEBPACK_IMPORTED_MODULE_2__["ApolloLink"]));

/* eslint-disable import/no-nodejs-modules */
var FormDataWithStreamSupport = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __extends */ "b"])(FormDataWithStreamSupport, _super);
    function FormDataWithStreamSupport(options) {
        var _this = _super.call(this, options) || this;
        _this.hasUnknowableLength = false;
        return _this;
    }
    FormDataWithStreamSupport.prototype.append = function (key, value, optionsOrFilename) {
        if (optionsOrFilename === void 0) { optionsOrFilename = {}; }
        // allow filename as single option
        var options = typeof optionsOrFilename === 'string'
            ? { filename: optionsOrFilename }
            : optionsOrFilename;
        // empty or either doesn't have path or not an http response
        if (!options.knownLength &&
            !Buffer.isBuffer(value) &&
            typeof value !== 'string' &&
            !value.path &&
            !(value.readable && hasOwnProperty(value, 'httpVersion'))) {
            this.hasUnknowableLength = true;
        }
        _super.prototype.append.call(this, key, value, options);
    };
    FormDataWithStreamSupport.prototype.getLength = function (callback) {
        if (this.hasUnknowableLength) {
            return null;
        }
        return _super.prototype.getLength.call(this, callback);
    };
    FormDataWithStreamSupport.prototype.getLengthSync = function () {
        if (this.hasUnknowableLength) {
            return null;
        }
        // eslint-disable-next-line no-sync
        return _super.prototype.getLengthSync.call(this);
    };
    return FormDataWithStreamSupport;
}(form_data__WEBPACK_IMPORTED_MODULE_6___default.a));
var createServerHttpLink = function (options) {
    return Object(apollo_link__WEBPACK_IMPORTED_MODULE_2__["concat"])(new AwaitVariablesLink(), Object(apollo_upload_client__WEBPACK_IMPORTED_MODULE_5__["createUploadLink"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, options), { fetch: node_fetch__WEBPACK_IMPORTED_MODULE_7__["default"], FormData: FormDataWithStreamSupport, isExtractableFile: function (value) {
            return Object(apollo_upload_client__WEBPACK_IMPORTED_MODULE_5__["isExtractableFile"])(value) || (value === null || value === void 0 ? void 0 : value.createReadStream);
        }, formDataAppendFile: function (form, index, file) {
            if (file.createReadStream != null) {
                form.append(index, file.createReadStream(), {
                    filename: file.filename,
                    contentType: file.mimetype,
                });
            }
            else {
                Object(apollo_upload_client__WEBPACK_IMPORTED_MODULE_5__["formDataAppendFile"])(form, index, file);
            }
        } })));
};

/**
 * This function wraps addMocksToSchema for more convenience
 */
function mockServer(schema, mocks, preserveResolvers) {
    if (preserveResolvers === void 0) { preserveResolvers = false; }
    var mySchema;
    if (!Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isSchema"])(schema)) {
        // TODO: provide useful error messages here if this fails
        mySchema = buildSchemaFromTypeDefinitions(schema);
    }
    else {
        mySchema = schema;
    }
    addMocksToSchema({ schema: mySchema, mocks: mocks, preserveResolvers: preserveResolvers });
    return { query: function (query, vars) { return Object(graphql__WEBPACK_IMPORTED_MODULE_3__["graphql"])(mySchema, query, {}, {}, vars); } };
}
var defaultMockMap = new Map();
defaultMockMap.set('Int', function () { return Math.round(Math.random() * 200) - 100; });
defaultMockMap.set('Float', function () { return Math.random() * 200 - 100; });
defaultMockMap.set('String', function () { return 'Hello World'; });
defaultMockMap.set('Boolean', function () { return Math.random() > 0.5; });
defaultMockMap.set('ID', function () { return Object(uuid__WEBPACK_IMPORTED_MODULE_8__[/* v4 */ "a"])(); });
// TODO allow providing a seed such that lengths of list could be deterministic
// this could be done by using casual to get a random list length if the casual
// object is global.
function addMocksToSchema(_a) {
    var schema = _a.schema, _b = _a.mocks, mocks = _b === void 0 ? {} : _b, _c = _a.preserveResolvers, preserveResolvers = _c === void 0 ? false : _c;
    if (!schema) {
        throw new Error('Must provide schema to mock');
    }
    if (!Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isSchema"])(schema)) {
        throw new Error('Value at "schema" must be of type GraphQLSchema');
    }
    if (!isObject$1(mocks)) {
        throw new Error('mocks must be of type Object');
    }
    // use Map internally, because that API is nicer.
    var mockFunctionMap = new Map();
    Object.keys(mocks).forEach(function (typeName) {
        mockFunctionMap.set(typeName, mocks[typeName]);
    });
    mockFunctionMap.forEach(function (mockFunction, mockTypeName) {
        if (typeof mockFunction !== 'function') {
            throw new Error("mockFunctionMap[" + mockTypeName + "] must be a function");
        }
    });
    var mockType = function (type, _typeName, fieldName) {
        // order of precendence for mocking:
        // 1. if the object passed in already has fieldName, just use that
        // --> if it's a function, that becomes your resolver
        // --> if it's a value, the mock resolver will return that
        // 2. if the nullableType is a list, recurse
        // 2. if there's a mock defined for this typeName, that will be used
        // 3. if there's no mock defined, use the default mocks for this type
        return function (root, args, context, info) {
            // nullability doesn't matter for the purpose of mocking.
            var fieldType = Object(graphql__WEBPACK_IMPORTED_MODULE_3__["getNullableType"])(type);
            var namedFieldType = Object(graphql__WEBPACK_IMPORTED_MODULE_3__["getNamedType"])(fieldType);
            if (fieldName && root && typeof root[fieldName] !== 'undefined') {
                var result = void 0;
                // if we're here, the field is already defined
                if (typeof root[fieldName] === 'function') {
                    result = root[fieldName](root, args, context, info);
                    if (result instanceof MockList) {
                        result = result.mock(root, args, context, info, fieldType, mockType);
                    }
                }
                else {
                    result = root[fieldName];
                }
                // Now we merge the result with the default mock for this type.
                // This allows overriding defaults while writing very little code.
                if (mockFunctionMap.has(namedFieldType.name)) {
                    var mock = mockFunctionMap.get(namedFieldType.name);
                    result = mergeMocks(mock.bind(null, root, args, context, info), result);
                }
                return result;
            }
            if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isListType"])(fieldType)) {
                return [
                    mockType(fieldType.ofType)(root, args, context, info),
                    mockType(fieldType.ofType)(root, args, context, info),
                ];
            }
            if (mockFunctionMap.has(fieldType.name) && !Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isAbstractType"])(fieldType)) {
                // the object passed doesn't have this field, so we apply the default mock
                var mock = mockFunctionMap.get(fieldType.name);
                return mock(root, args, context, info);
            }
            if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isObjectType"])(fieldType)) {
                // objects don't return actual data, we only need to mock scalars!
                return {};
            }
            // if a mock function is provided for unionType or interfaceType, execute it to resolve the concrete type
            // otherwise randomly pick a type from all implementation types
            if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isAbstractType"])(fieldType)) {
                var implementationType = void 0;
                if (mockFunctionMap.has(fieldType.name)) {
                    var mock = mockFunctionMap.get(fieldType.name);
                    var interfaceMockObj = mock(root, args, context, info);
                    if (!interfaceMockObj || !interfaceMockObj.__typename) {
                        return Error("Please return a __typename in \"" + fieldType.name + "\"");
                    }
                    implementationType = schema.getType(interfaceMockObj.__typename);
                }
                else {
                    var possibleTypes = schema.getPossibleTypes(fieldType);
                    implementationType = getRandomElement(possibleTypes);
                }
                return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({ __typename: implementationType }, mockType(implementationType)(root, args, context, info));
            }
            if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isEnumType"])(fieldType)) {
                return getRandomElement(fieldType.getValues()).value;
            }
            if (defaultMockMap.has(fieldType.name)) {
                var defaultMock = defaultMockMap.get(fieldType.name);
                return defaultMock(root, args, context, info);
            }
            // if we get to here, we don't have a value, and we don't have a mock for this type,
            // we could return undefined, but that would be hard to debug, so we throw instead.
            // however, we returning it instead of throwing it, so preserveResolvers can handle the failures.
            return Error("No mock defined for type \"" + fieldType.name + "\"");
        };
    };
    forEachField(schema, function (field, typeName, fieldName) {
        assignResolveType(field.type, preserveResolvers);
        var mockResolver = mockType(field.type, typeName, fieldName);
        // we have to handle the root mutation and root query types differently,
        // because no resolver is called at the root.
        var queryType = schema.getQueryType();
        var isOnQueryType = queryType != null && queryType.name === typeName;
        var mutationType = schema.getMutationType();
        var isOnMutationType = mutationType != null && mutationType.name === typeName;
        if (isOnQueryType || isOnMutationType) {
            if (mockFunctionMap.has(typeName)) {
                var rootMock_1 = mockFunctionMap.get(typeName);
                // XXX: BUG in here, need to provide proper signature for rootMock.
                if (typeof rootMock_1(undefined, {}, {}, {})[fieldName] ===
                    'function') {
                    mockResolver = function (root, args, context, info) {
                        var updatedRoot = root !== null && root !== void 0 ? root : {}; // TODO: should we clone instead?
                        updatedRoot[fieldName] = rootMock_1(root, args, context, info)[fieldName];
                        // XXX this is a bit of a hack to still use mockType, which
                        // lets you mock lists etc. as well
                        // otherwise we could just set field.resolve to rootMock()[fieldName]
                        // it's like pretending there was a resolver that ran before
                        // the root resolver.
                        return mockType(field.type, typeName, fieldName)(updatedRoot, args, context, info);
                    };
                }
            }
        }
        if (!preserveResolvers || !field.resolve) {
            field.resolve = mockResolver;
        }
        else {
            var oldResolver_1 = field.resolve;
            field.resolve = function (rootObject, args, context, info) {
                return Promise.all([
                    mockResolver(rootObject, args, context, info),
                    oldResolver_1(rootObject, args, context, info),
                ]).then(function (values) {
                    var mockedValue = values[0], resolvedValue = values[1];
                    // In case we couldn't mock
                    if (mockedValue instanceof Error) {
                        // only if value was not resolved, populate the error.
                        if (undefined === resolvedValue) {
                            throw mockedValue;
                        }
                        return resolvedValue;
                    }
                    if (resolvedValue instanceof Date && mockedValue instanceof Date) {
                        return undefined !== resolvedValue ? resolvedValue : mockedValue;
                    }
                    if (isObject$1(mockedValue) && isObject$1(resolvedValue)) {
                        // Object.assign() won't do here, as we need to all properties, including
                        // the non-enumerable ones and defined using Object.defineProperty
                        var emptyObject = Object.create(Object.getPrototypeOf(resolvedValue));
                        return copyOwnProps(emptyObject, resolvedValue, mockedValue);
                    }
                    return undefined !== resolvedValue ? resolvedValue : mockedValue;
                });
            };
        }
    });
}
function isObject$1(thing) {
    return thing === Object(thing) && !Array.isArray(thing);
}
// returns a random element from that ary
function getRandomElement(ary) {
    var sample = Math.floor(Math.random() * ary.length);
    return ary[sample];
}
function mergeObjects(a, b) {
    return Object.assign(a, b);
}
function copyOwnPropsIfNotPresent(target, source) {
    Object.getOwnPropertyNames(source).forEach(function (prop) {
        if (!Object.getOwnPropertyDescriptor(target, prop)) {
            var propertyDescriptor = Object.getOwnPropertyDescriptor(source, prop);
            Object.defineProperty(target, prop, propertyDescriptor == null ? {} : propertyDescriptor);
        }
    });
}
function copyOwnProps(target) {
    var sources = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        sources[_i - 1] = arguments[_i];
    }
    sources.forEach(function (source) {
        var chain = source;
        while (chain != null) {
            copyOwnPropsIfNotPresent(target, chain);
            chain = Object.getPrototypeOf(chain);
        }
    });
    return target;
}
// takes either an object or a (possibly nested) array
// and completes the customMock object with any fields
// defined on genericMock
// only merges objects or arrays. Scalars are returned as is
function mergeMocks(genericMockFunction, customMock) {
    if (Array.isArray(customMock)) {
        return customMock.map(function (el) { return mergeMocks(genericMockFunction, el); });
    }
    if (isObject$1(customMock)) {
        return mergeObjects(genericMockFunction(), customMock);
    }
    return customMock;
}
function getResolveType(namedFieldType) {
    if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isAbstractType"])(namedFieldType)) {
        return namedFieldType.resolveType;
    }
}
function assignResolveType(type, preserveResolvers) {
    var fieldType = Object(graphql__WEBPACK_IMPORTED_MODULE_3__["getNullableType"])(type);
    var namedFieldType = Object(graphql__WEBPACK_IMPORTED_MODULE_3__["getNamedType"])(fieldType);
    var oldResolveType = getResolveType(namedFieldType);
    if (preserveResolvers && oldResolveType != null && oldResolveType.length) {
        return;
    }
    if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isInterfaceType"])(namedFieldType) || Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isUnionType"])(namedFieldType)) {
        // the default `resolveType` always returns null. We add a fallback
        // resolution that works with how unions and interface are mocked
        namedFieldType.resolveType = function (data, _context, info) { return info.schema.getType(data.__typename); };
    }
}
var MockList = /** @class */ (function () {
    // wrappedFunction can return another MockList or a value
    function MockList(len, wrappedFunction) {
        this.len = len;
        if (typeof wrappedFunction !== 'undefined') {
            if (typeof wrappedFunction !== 'function') {
                throw new Error('Second argument to MockList must be a function or undefined');
            }
            this.wrappedFunction = wrappedFunction;
        }
    }
    MockList.prototype.mock = function (root, args, context, info, fieldType, mockTypeFunc) {
        var arr;
        if (Array.isArray(this.len)) {
            arr = new Array(this.randint(this.len[0], this.len[1]));
        }
        else {
            arr = new Array(this.len);
        }
        for (var i = 0; i < arr.length; i++) {
            if (typeof this.wrappedFunction === 'function') {
                var res = this.wrappedFunction(root, args, context, info);
                if (res instanceof MockList) {
                    var nullableType = Object(graphql__WEBPACK_IMPORTED_MODULE_3__["getNullableType"])(fieldType.ofType);
                    arr[i] = res.mock(root, args, context, info, nullableType, mockTypeFunc);
                }
                else {
                    arr[i] = res;
                }
            }
            else {
                arr[i] = mockTypeFunc(fieldType.ofType)(root, args, context, info);
            }
        }
        return arr;
    };
    MockList.prototype.randint = function (low, high) {
        return Math.floor(Math.random() * (high - low + 1) + low);
    };
    return MockList;
}());
// retain addMockFunctionsToSchema for backwards compatibility
function addMockFunctionsToSchema(_a) {
    var schema = _a.schema, _b = _a.mocks, mocks = _b === void 0 ? {} : _b, _c = _a.preserveResolvers, preserveResolvers = _c === void 0 ? false : _c;
    addMocksToSchema({ schema: schema, mocks: mocks, preserveResolvers: preserveResolvers });
}

var GraphQLUpload = new graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLScalarType"]({
    name: 'Upload',
    description: 'The `Upload` scalar type represents a file upload.',
    parseValue: function (value) {
        if (value != null && value.promise instanceof Promise) {
            // graphql-upload v10
            return value.promise;
        }
        else if (value instanceof Promise) {
            // graphql-upload v9
            return value;
        }
        throw new graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLError"]('Upload value invalid.');
    },
    // serialization requires to support schema stitching
    serialize: function (value) { return value; },
    parseLiteral: function (ast) {
        throw new graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLError"]('Upload literal unsupported.', ast);
    },
});

var parsedIntrospectionQuery = Object(graphql__WEBPACK_IMPORTED_MODULE_3__["parse"])(Object(graphql__WEBPACK_IMPORTED_MODULE_3__["getIntrospectionQuery"])());
function introspectSchema(linkOrFetcher, linkContext) {
    var fetcher = typeof linkOrFetcher === 'function'
        ? linkOrFetcher
        : linkToFetcher(linkOrFetcher);
    return fetcher({
        query: parsedIntrospectionQuery,
        context: linkContext,
    }).then(function (introspectionResult) {
        if ((Array.isArray(introspectionResult.errors) &&
            introspectionResult.errors.length) ||
            !introspectionResult.data.__schema) {
            if (Array.isArray(introspectionResult.errors)) {
                var combinedError = combineErrors(introspectionResult.errors);
                throw combinedError;
            }
            else {
                throw new Error('Could not obtain introspection result, received: ' +
                    JSON.stringify(introspectionResult));
            }
        }
        else {
            var schema = Object(graphql__WEBPACK_IMPORTED_MODULE_3__["buildClientSchema"])(introspectionResult.data);
            return schema;
        }
    });
}

/**
 * Resolver that knows how to:
 * a) handle aliases for proxied schemas
 * b) handle errors from proxied schemas
 * c) handle external to internal enum coversion
 */
function defaultMergedResolver(parent, args, context, info) {
    if (!parent) {
        return null;
    }
    var responseKey = getResponseKeyFromInfo(info);
    var errors = getErrors(parent, responseKey);
    // check to see if parent is not a proxied result, i.e. if parent resolver was manually overwritten
    // See https://github.com/apollographql/graphql-tools/issues/967
    if (!errors) {
        return Object(graphql__WEBPACK_IMPORTED_MODULE_3__["defaultFieldResolver"])(parent, args, context, info);
    }
    var result = parent[responseKey];
    var subschema = getSubschema(parent, responseKey);
    return handleResult(result, errors, subschema, context, info);
}

function makeMergedType(type) {
    if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isObjectType"])(type)) {
        type.isTypeOf = undefined;
        var fieldMap_1 = type.getFields();
        Object.keys(fieldMap_1).forEach(function (fieldName) {
            fieldMap_1[fieldName].resolve = defaultMergedResolver;
            fieldMap_1[fieldName].subscribe = null;
        });
    }
    else if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isAbstractType"])(type)) {
        type.resolveType = function (parent) { return resolveFromParentTypename(parent); };
    }
}

function generateProxyingResolvers(_a) {
    var subschemaConfig = _a.subschemaConfig, transforms = _a.transforms;
    var targetSchema = subschemaConfig.schema;
    var operationTypes = {
        query: targetSchema.getQueryType(),
        mutation: targetSchema.getMutationType(),
        subscription: targetSchema.getSubscriptionType(),
    };
    var createProxyingResolver = subschemaConfig.createProxyingResolver != null
        ? subschemaConfig.createProxyingResolver
        : defaultCreateProxyingResolver;
    var resolvers = {};
    Object.keys(operationTypes).forEach(function (operation) {
        var resolveField = operation === 'subscription' ? 'subscribe' : 'resolve';
        var rootType = operationTypes[operation];
        if (rootType != null) {
            var typeName_1 = rootType.name;
            var fields = rootType.getFields();
            resolvers[typeName_1] = {};
            Object.keys(fields).forEach(function (fieldName) {
                var _a;
                var proxyingResolver = createProxyingResolver(subschemaConfig, transforms, operation, fieldName);
                var finalResolver = createPossiblyNestedProxyingResolver(subschemaConfig, proxyingResolver);
                resolvers[typeName_1][fieldName] = (_a = {},
                    _a[resolveField] = finalResolver,
                    _a);
            });
        }
    });
    return resolvers;
}
function createPossiblyNestedProxyingResolver(subschemaConfig, proxyingResolver) {
    return function (parent, args, context, info) {
        if (parent != null) {
            var responseKey = getResponseKeyFromInfo(info);
            var errors = getErrors(parent, responseKey);
            // Check to see if the parent contains a proxied result
            if (errors != null) {
                var subschema = getSubschema(parent, responseKey);
                // If there is a proxied result from this subschema, return it
                // This can happen even for a root field when the root type ia
                // also nested as a field within a different type.
                if (subschemaConfig === subschema) {
                    return handleResult(parent[responseKey], errors, subschema, context, info);
                }
            }
        }
        return proxyingResolver(parent, args, context, info);
    };
}
function defaultCreateProxyingResolver(schema, transforms) {
    return function (_parent, _args, context, info) {
        return delegateToSchema({
            schema: schema,
            context: context,
            info: info,
            transforms: transforms,
        });
    };
}
function stripResolvers(schema) {
    var typeMap = schema.getTypeMap();
    Object.keys(typeMap).forEach(function (typeName) {
        if (!typeName.startsWith('__')) {
            makeMergedType(typeMap[typeName]);
        }
    });
}

function wrapSchema(subschemaOrSubschemaConfig, transforms) {
    var subschemaConfig = isSubschemaConfig(subschemaOrSubschemaConfig)
        ? subschemaOrSubschemaConfig
        : { schema: subschemaOrSubschemaConfig };
    var schema = cloneSchema(subschemaConfig.schema);
    stripResolvers(schema);
    var resolvers = generateProxyingResolvers({
        subschemaConfig: subschemaConfig,
        transforms: transforms,
    });
    addResolversToSchema({ schema: schema, resolvers: resolvers });
    var schemaTransforms = [];
    if (subschemaConfig.transforms != null) {
        schemaTransforms = schemaTransforms.concat(subschemaConfig.transforms);
    }
    if (transforms != null) {
        schemaTransforms = schemaTransforms.concat(transforms);
    }
    return applySchemaTransforms(schema, schemaTransforms);
}

var backcompatOptions = { commentDescriptions: true };
function typeFromAST(node) {
    switch (node.kind) {
        case graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].OBJECT_TYPE_DEFINITION:
            return makeObjectType(node);
        case graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].INTERFACE_TYPE_DEFINITION:
            return makeInterfaceType(node);
        case graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].ENUM_TYPE_DEFINITION:
            return makeEnumType(node);
        case graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].UNION_TYPE_DEFINITION:
            return makeUnionType(node);
        case graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].SCALAR_TYPE_DEFINITION:
            return makeScalarType(node);
        case graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].INPUT_OBJECT_TYPE_DEFINITION:
            return makeInputObjectType(node);
        case graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].DIRECTIVE_DEFINITION:
            return makeDirective(node);
        default:
            return null;
    }
}
function makeObjectType(node) {
    var config = {
        name: node.name.value,
        fields: function () { return makeFields(node.fields); },
        interfaces: function () {
            return node.interfaces.map(function (iface) {
                return createNamedStub(iface.name.value, 'interface');
            });
        },
        description: getDescription(node, backcompatOptions),
    };
    return new graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLObjectType"](config);
}
function makeInterfaceType(node) {
    var config = {
        name: node.name.value,
        fields: function () { return makeFields(node.fields); },
        interfaces: graphqlVersion() >= 15
            ? function () {
                return node.interfaces.map(function (iface) {
                    return createNamedStub(iface.name.value, 'interface');
                });
            }
            : undefined,
        description: getDescription(node, backcompatOptions),
        resolveType: function (parent) { return resolveFromParentTypename(parent); },
    };
    return new graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLInterfaceType"](config);
}
function makeEnumType(node) {
    var values = keyValMap(node.values, function (value) { return value.name.value; }, function (value) { return ({
        description: getDescription(value, backcompatOptions),
    }); });
    return new graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLEnumType"]({
        name: node.name.value,
        values: values,
        description: getDescription(node, backcompatOptions),
    });
}
function makeUnionType(node) {
    return new graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLUnionType"]({
        name: node.name.value,
        types: function () {
            return node.types.map(function (type) { return createNamedStub(type.name.value, 'object'); });
        },
        description: getDescription(node, backcompatOptions),
        resolveType: function (parent) { return resolveFromParentTypename(parent); },
    });
}
function makeScalarType(node) {
    return new graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLScalarType"]({
        name: node.name.value,
        description: getDescription(node, backcompatOptions),
        serialize: function () { return null; },
        // Note: validation calls the parse functions to determine if a
        // literal value is correct. Returning null would cause use of custom
        // scalars to always fail validation. Returning false causes them to
        // always pass validation.
        parseValue: function () { return false; },
        parseLiteral: function () { return false; },
    });
}
function makeInputObjectType(node) {
    return new graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLInputObjectType"]({
        name: node.name.value,
        fields: function () { return makeValues(node.fields); },
        description: getDescription(node, backcompatOptions),
    });
}
function makeFields(nodes) {
    return keyValMap(nodes, function (node) { return node.name.value; }, function (node) {
        var deprecatedDirective = node.directives.find(function (directive) { return directive.name.value === 'deprecated'; });
        var deprecationReason;
        if (deprecatedDirective != null) {
            var deprecatedArgument = deprecatedDirective.arguments.find(function (arg) { return arg.name.value === 'reason'; });
            deprecationReason = deprecatedArgument.value.value;
        }
        return {
            type: createStub(node.type, 'output'),
            args: makeValues(node.arguments),
            description: getDescription(node, backcompatOptions),
            deprecationReason: deprecationReason,
        };
    });
}
function makeValues(nodes) {
    return keyValMap(nodes, function (node) { return node.name.value; }, function (node) {
        var type = createStub(node.type, 'input');
        return {
            type: type,
            defaultValue: node.defaultValue,
            description: getDescription(node, backcompatOptions),
        };
    });
}
function makeDirective(node) {
    var locations = [];
    node.locations.forEach(function (location) {
        if (location.value in graphql__WEBPACK_IMPORTED_MODULE_3__["DirectiveLocation"]) {
            locations.push(location.value);
        }
    });
    return new graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLDirective"]({
        name: node.name.value,
        description: node.description != null ? node.description.value : null,
        args: makeValues(node.arguments),
        locations: locations,
    });
}
// graphql < v13 does not export getDescription
function getDescription(node, options) {
    if (node.description != null) {
        return node.description.value;
    }
    if (options.commentDescriptions) {
        var rawValue = getLeadingCommentBlock(node);
        if (rawValue !== undefined) {
            return dedentBlockStringValue("\n" + rawValue);
        }
    }
}
function getLeadingCommentBlock(node) {
    var loc = node.loc;
    if (!loc) {
        return;
    }
    var comments = [];
    var token = loc.startToken.prev;
    while (token != null &&
        token.kind === graphql__WEBPACK_IMPORTED_MODULE_3__["TokenKind"].COMMENT &&
        token.next != null &&
        token.prev != null &&
        token.line + 1 === token.next.line &&
        token.line !== token.prev.line) {
        var value = String(token.value);
        comments.push(value);
        token = token.prev;
    }
    return comments.length > 0 ? comments.reverse().join('\n') : undefined;
}
function dedentBlockStringValue(rawString) {
    // Expand a block string's raw value into independent lines.
    var lines = rawString.split(/\r\n|[\n\r]/g);
    // Remove common indentation from all lines but first.
    var commonIndent = getBlockStringIndentation(lines);
    if (commonIndent !== 0) {
        for (var i = 1; i < lines.length; i++) {
            lines[i] = lines[i].slice(commonIndent);
        }
    }
    // Remove leading and trailing blank lines.
    while (lines.length > 0 && isBlank(lines[0])) {
        lines.shift();
    }
    while (lines.length > 0 && isBlank(lines[lines.length - 1])) {
        lines.pop();
    }
    // Return a string of the lines joined with U+000A.
    return lines.join('\n');
}
/**
 * @internal
 */
function getBlockStringIndentation(lines) {
    var commonIndent = null;
    for (var i = 1; i < lines.length; i++) {
        var line = lines[i];
        var indent = leadingWhitespace(line);
        if (indent === line.length) {
            continue; // skip empty lines
        }
        if (commonIndent === null || indent < commonIndent) {
            commonIndent = indent;
            if (commonIndent === 0) {
                break;
            }
        }
    }
    return commonIndent === null ? 0 : commonIndent;
}
function leadingWhitespace(str) {
    var i = 0;
    while (i < str.length && (str[i] === ' ' || str[i] === '\t')) {
        i++;
    }
    return i;
}
function isBlank(str) {
    return leadingWhitespace(str) === str.length;
}

function concatInlineFragments(type, fragments) {
    var fragmentSelections = fragments.reduce(function (selections, fragment) {
        return selections.concat(fragment.selectionSet.selections);
    }, []);
    var deduplicatedFragmentSelection = deduplicateSelection(fragmentSelections);
    return {
        kind: graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].INLINE_FRAGMENT,
        typeCondition: {
            kind: graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].NAMED_TYPE,
            name: {
                kind: graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].NAME,
                value: type,
            },
        },
        selectionSet: {
            kind: graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].SELECTION_SET,
            selections: deduplicatedFragmentSelection,
        },
    };
}
function deduplicateSelection(nodes) {
    var selectionMap = nodes.reduce(function (map, node) {
        var _a, _b, _c;
        switch (node.kind) {
            case 'Field': {
                if (node.alias != null) {
                    if (node.alias.value in map) {
                        return map;
                    }
                    return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, map), (_a = {}, _a[node.alias.value] = node, _a));
                }
                if (node.name.value in map) {
                    return map;
                }
                return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, map), (_b = {}, _b[node.name.value] = node, _b));
            }
            case 'FragmentSpread': {
                if (node.name.value in map) {
                    return map;
                }
                return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, map), (_c = {}, _c[node.name.value] = node, _c));
            }
            case 'InlineFragment': {
                if (map.__fragment != null) {
                    var fragment = map.__fragment;
                    return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, map), { __fragment: concatInlineFragments(fragment.typeCondition.name.value, [fragment, node]) });
                }
                return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, map), { __fragment: node });
            }
            default: {
                return map;
            }
        }
    }, Object.create(null));
    var selection = Object.keys(selectionMap).reduce(function (selectionList, node) { return selectionList.concat(selectionMap[node]); }, []);
    return selection;
}
function parseFragmentToInlineFragment(definitions) {
    if (definitions.trim().startsWith('fragment')) {
        var document_1 = Object(graphql__WEBPACK_IMPORTED_MODULE_3__["parse"])(definitions);
        for (var _i = 0, _a = document_1.definitions; _i < _a.length; _i++) {
            var definition = _a[_i];
            if (definition.kind === graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].FRAGMENT_DEFINITION) {
                return {
                    kind: graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].INLINE_FRAGMENT,
                    typeCondition: definition.typeCondition,
                    selectionSet: definition.selectionSet,
                };
            }
        }
    }
    var query = Object(graphql__WEBPACK_IMPORTED_MODULE_3__["parse"])("{" + definitions + "}")
        .definitions[0];
    for (var _b = 0, _c = query.selectionSet.selections; _b < _c.length; _b++) {
        var selection = _c[_b];
        if (selection.kind === graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].INLINE_FRAGMENT) {
            return selection;
        }
    }
    throw new Error('Could not parse fragment');
}

function parseSelectionSet(selectionSet) {
    var query = Object(graphql__WEBPACK_IMPORTED_MODULE_3__["parse"])(selectionSet).definitions[0];
    return query.selectionSet;
}
function typeContainsSelectionSet(type, selectionSet) {
    var fields = type.getFields();
    for (var _i = 0, _a = selectionSet.selections; _i < _a.length; _i++) {
        var selection = _a[_i];
        if (selection.kind === graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].FIELD) {
            var field = fields[selection.name.value];
            if (field == null) {
                return false;
            }
            if (selection.selectionSet != null) {
                return typeContainsSelectionSet(Object(graphql__WEBPACK_IMPORTED_MODULE_3__["getNamedType"])(field.type), selection.selectionSet);
            }
        }
        else if (selection.kind === graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].INLINE_FRAGMENT) {
            var containsSelectionSet = typeContainsSelectionSet(type, selection.selectionSet);
            if (!containsSelectionSet) {
                return false;
            }
        }
    }
    return true;
}

function createMergeInfo(allSchemas, typeCandidates, mergeTypes) {
    return {
        delegate: function (operation, fieldName, args, context, info, transforms) {
            if (transforms === void 0) { transforms = []; }
            var schema = guessSchemaByRootField(allSchemas, operation, fieldName);
            var expandTransforms = new ExpandAbstractTypes(info.schema, schema);
            var fragmentTransform = new AddReplacementFragments(schema, info.mergeInfo.replacementFragments);
            return delegateToSchema({
                schema: schema,
                operation: operation,
                fieldName: fieldName,
                args: args,
                context: context,
                info: info,
                transforms: Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __spreadArrays */ "d"])(transforms, [expandTransforms, fragmentTransform]),
            });
        },
        delegateToSchema: function (options) {
            return delegateToSchema(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, options), { transforms: options.transforms }));
        },
        fragments: [],
        replacementSelectionSets: undefined,
        replacementFragments: undefined,
        mergedTypes: createMergedTypes(typeCandidates, mergeTypes),
    };
}
function createMergedTypes(typeCandidates, mergeTypes) {
    var mergedTypes = Object.create(null);
    Object.keys(typeCandidates).forEach(function (typeName) {
        if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isObjectType"])(typeCandidates[typeName][0].type)) {
            var mergedTypeCandidates = typeCandidates[typeName].filter(function (typeCandidate) {
                return typeCandidate.subschema != null &&
                    isSubschemaConfig(typeCandidate.subschema) &&
                    typeCandidate.subschema.merge != null &&
                    hasOwnProperty(typeCandidate.subschema.merge, typeName);
            });
            if (mergeTypes === true ||
                (typeof mergeTypes === 'function' &&
                    mergeTypes(typeName, typeCandidates[typeName])) ||
                (Array.isArray(mergeTypes) && mergeTypes.includes(typeName)) ||
                mergedTypeCandidates.length) {
                var subschemas_1 = [];
                var requiredSelections_1 = [
                    parseSelectionSet('{ __typename }').selections[0],
                ];
                var fields_1 = Object.create({});
                var typeMaps_1 = new Map();
                var selectionSets_1 = new Map();
                mergedTypeCandidates.forEach(function (typeCandidate) {
                    var subschemaConfig = typeCandidate.subschema;
                    var transformedSubschema = typeCandidate.transformedSubschema;
                    typeMaps_1.set(subschemaConfig, transformedSubschema.getTypeMap());
                    var type = transformedSubschema.getType(typeName);
                    var fieldMap = type.getFields();
                    Object.keys(fieldMap).forEach(function (fieldName) {
                        if (!(fieldName in fields_1)) {
                            fields_1[fieldName] = [];
                        }
                        fields_1[fieldName].push(subschemaConfig);
                    });
                    var mergedTypeConfig = subschemaConfig.merge[typeName];
                    if (mergedTypeConfig.selectionSet) {
                        var selectionSet = parseSelectionSet(mergedTypeConfig.selectionSet);
                        requiredSelections_1 = requiredSelections_1.concat(selectionSet.selections);
                        selectionSets_1.set(subschemaConfig, selectionSet);
                    }
                    if (!mergedTypeConfig.resolve) {
                        mergedTypeConfig.resolve = function (originalResult, context, info, subschema, selectionSet) {
                            return delegateToSchema({
                                schema: subschema,
                                operation: 'query',
                                fieldName: mergedTypeConfig.fieldName,
                                args: mergedTypeConfig.args(originalResult),
                                selectionSet: selectionSet,
                                context: context,
                                info: info,
                                skipTypeMerging: true,
                            });
                        };
                    }
                    subschemas_1.push(subschemaConfig);
                });
                mergedTypes[typeName] = {
                    subschemas: subschemas_1,
                    typeMaps: typeMaps_1,
                    selectionSets: selectionSets_1,
                    containsSelectionSet: new Map(),
                    uniqueFields: Object.create({}),
                    nonUniqueFields: Object.create({}),
                };
                subschemas_1.forEach(function (subschema) {
                    var type = typeMaps_1.get(subschema)[typeName];
                    var subschemaMap = new Map();
                    subschemas_1
                        .filter(function (s) { return s !== subschema; })
                        .forEach(function (s) {
                        var selectionSet = selectionSets_1.get(s);
                        if (selectionSet != null &&
                            typeContainsSelectionSet(type, selectionSet)) {
                            subschemaMap.set(selectionSet, true);
                        }
                    });
                    mergedTypes[typeName].containsSelectionSet.set(subschema, subschemaMap);
                });
                Object.keys(fields_1).forEach(function (fieldName) {
                    var supportedBySubschemas = fields_1[fieldName];
                    if (supportedBySubschemas.length === 1) {
                        mergedTypes[typeName].uniqueFields[fieldName] =
                            supportedBySubschemas[0];
                    }
                    else {
                        mergedTypes[typeName].nonUniqueFields[fieldName] = supportedBySubschemas;
                    }
                });
                mergedTypes[typeName].selectionSet = {
                    kind: graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].SELECTION_SET,
                    selections: requiredSelections_1,
                };
            }
        }
    });
    return mergedTypes;
}
function completeMergeInfo(mergeInfo, resolvers) {
    var replacementSelectionSets = Object.create(null);
    Object.keys(resolvers).forEach(function (typeName) {
        var type = resolvers[typeName];
        if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isScalarType"])(type)) {
            return;
        }
        Object.keys(type).forEach(function (fieldName) {
            var field = type[fieldName];
            if (field.selectionSet) {
                var selectionSet = parseSelectionSet(field.selectionSet);
                if (!(typeName in replacementSelectionSets)) {
                    replacementSelectionSets[typeName] = Object.create(null);
                }
                var typeReplacementSelectionSets = replacementSelectionSets[typeName];
                if (!(fieldName in typeReplacementSelectionSets)) {
                    typeReplacementSelectionSets[fieldName] = {
                        kind: graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].SELECTION_SET,
                        selections: [],
                    };
                }
                typeReplacementSelectionSets[fieldName].selections = typeReplacementSelectionSets[fieldName].selections.concat(selectionSet.selections);
            }
            if (field.fragment) {
                mergeInfo.fragments.push({
                    field: fieldName,
                    fragment: field.fragment,
                });
            }
        });
    });
    var mapping = Object.create(null);
    mergeInfo.fragments.forEach(function (_a) {
        var field = _a.field, fragment = _a.fragment;
        var parsedFragment = parseFragmentToInlineFragment(fragment);
        var actualTypeName = parsedFragment.typeCondition.name.value;
        if (!(actualTypeName in mapping)) {
            mapping[actualTypeName] = Object.create(null);
        }
        var typeMapping = mapping[actualTypeName];
        if (!(field in typeMapping)) {
            typeMapping[field] = [];
        }
        typeMapping[field].push(parsedFragment);
    });
    var replacementFragments = Object.create(null);
    Object.keys(mapping).forEach(function (typeName) {
        Object.keys(mapping[typeName]).forEach(function (field) {
            if (!(typeName in replacementFragments)) {
                replacementFragments[typeName] = Object.create(null);
            }
            var typeReplacementFragments = replacementFragments[typeName];
            typeReplacementFragments[field] = concatInlineFragments(typeName, mapping[typeName][field]);
        });
    });
    mergeInfo.replacementSelectionSets = replacementSelectionSets;
    mergeInfo.replacementFragments = replacementFragments;
    return mergeInfo;
}
function operationToRootType(operation, schema) {
    if (operation === 'subscription') {
        return schema.getSubscriptionType();
    }
    else if (operation === 'mutation') {
        return schema.getMutationType();
    }
    return schema.getQueryType();
}
function guessSchemaByRootField(schemas, operation, fieldName) {
    for (var _i = 0, schemas_1 = schemas; _i < schemas_1.length; _i++) {
        var schema = schemas_1[_i];
        var rootObject = operationToRootType(operation, schema);
        if (rootObject != null) {
            var fields = rootObject.getFields();
            if (fieldName in fields) {
                return schema;
            }
        }
    }
    throw new Error("Could not find subschema with field `" + operation + "." + fieldName + "`");
}

function mergeSchemas(_a) {
    var _b = _a.subschemas, subschemas = _b === void 0 ? [] : _b, _c = _a.types, types = _c === void 0 ? [] : _c, typeDefs = _a.typeDefs, _d = _a.schemas, schemaLikeObjects = _d === void 0 ? [] : _d, onTypeConflict = _a.onTypeConflict, _e = _a.resolvers, resolvers = _e === void 0 ? {} : _e, schemaDirectives = _a.schemaDirectives, inheritResolversFromInterfaces = _a.inheritResolversFromInterfaces, _f = _a.mergeTypes, mergeTypes = _f === void 0 ? false : _f, mergeDirectives = _a.mergeDirectives, _g = _a.queryTypeName, queryTypeName = _g === void 0 ? 'Query' : _g, _h = _a.mutationTypeName, mutationTypeName = _h === void 0 ? 'Mutation' : _h, _j = _a.subscriptionTypeName, subscriptionTypeName = _j === void 0 ? 'Subscription' : _j;
    var allSchemas = [];
    var typeCandidates = Object.create(null);
    var typeMap = Object.create(null);
    var extensions = [];
    var directives = [];
    var schemas = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __spreadArrays */ "d"])(subschemas);
    if (typeDefs) {
        schemas.push(typeDefs);
    }
    if (types != null) {
        schemas.push(types);
    }
    schemas = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __spreadArrays */ "d"])(schemas, schemaLikeObjects);
    schemas.forEach(function (schemaLikeObject) {
        var _a;
        if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isSchema"])(schemaLikeObject) || isSubschemaConfig(schemaLikeObject)) {
            var schema_1 = wrapSchema(schemaLikeObject);
            allSchemas.push(schema_1);
            var operationTypes_1 = (_a = {},
                _a[queryTypeName] = schema_1.getQueryType(),
                _a[mutationTypeName] = schema_1.getMutationType(),
                _a[subscriptionTypeName] = schema_1.getSubscriptionType(),
                _a);
            Object.keys(operationTypes_1).forEach(function (typeName) {
                if (operationTypes_1[typeName] != null) {
                    addTypeCandidate(typeCandidates, typeName, {
                        schema: schema_1,
                        type: operationTypes_1[typeName],
                        subschema: schemaLikeObject,
                        transformedSubschema: schema_1,
                    });
                }
            });
            if (mergeDirectives) {
                var directiveInstances = schema_1.getDirectives();
                directiveInstances.forEach(function (directive) {
                    directives.push(directive);
                });
            }
            var originalTypeMap_1 = schema_1.getTypeMap();
            Object.keys(originalTypeMap_1).forEach(function (typeName) {
                var type = originalTypeMap_1[typeName];
                if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isNamedType"])(type) &&
                    Object(graphql__WEBPACK_IMPORTED_MODULE_3__["getNamedType"])(type).name.slice(0, 2) !== '__' &&
                    type !== operationTypes_1.Query &&
                    type !== operationTypes_1.Mutation &&
                    type !== operationTypes_1.Subscription) {
                    addTypeCandidate(typeCandidates, type.name, {
                        schema: schema_1,
                        type: type,
                        subschema: schemaLikeObject,
                        transformedSubschema: schema_1,
                    });
                }
            });
        }
        else if (typeof schemaLikeObject === 'string' ||
            (schemaLikeObject != null &&
                schemaLikeObject.kind === graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].DOCUMENT)) {
            var parsedSchemaDocument = typeof schemaLikeObject === 'string'
                ? Object(graphql__WEBPACK_IMPORTED_MODULE_3__["parse"])(schemaLikeObject)
                : schemaLikeObject;
            parsedSchemaDocument.definitions.forEach(function (def) {
                var type = typeFromAST(def);
                if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isDirective"])(type) && mergeDirectives) {
                    directives.push(type);
                }
                else if (type != null && !Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isDirective"])(type)) {
                    addTypeCandidate(typeCandidates, type.name, {
                        type: type,
                    });
                }
            });
            var extensionsDocument = extractExtensionDefinitions(parsedSchemaDocument);
            if (extensionsDocument.definitions.length > 0) {
                extensions.push(extensionsDocument);
            }
        }
        else if (Array.isArray(schemaLikeObject)) {
            schemaLikeObject.forEach(function (type) {
                addTypeCandidate(typeCandidates, type.name, {
                    type: type,
                });
            });
        }
        else {
            throw new Error('Invalid schema passed');
        }
    });
    var mergeInfo = createMergeInfo(allSchemas, typeCandidates, mergeTypes);
    var finalResolvers;
    if (typeof resolvers === 'function') {
        finalResolvers = resolvers(mergeInfo);
    }
    else if (Array.isArray(resolvers)) {
        finalResolvers = resolvers.reduce(function (left, right) {
            return mergeDeep(left, typeof right === 'function' ? right(mergeInfo) : right);
        }, {});
        if (Array.isArray(resolvers)) {
            finalResolvers = resolvers.reduce(mergeDeep, {});
        }
    }
    else {
        finalResolvers = resolvers;
    }
    if (finalResolvers == null) {
        finalResolvers = {};
    }
    mergeInfo = completeMergeInfo(mergeInfo, finalResolvers);
    Object.keys(typeCandidates).forEach(function (typeName) {
        if (typeName === queryTypeName ||
            typeName === mutationTypeName ||
            typeName === subscriptionTypeName ||
            (mergeTypes === true &&
                !Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isScalarType"])(typeCandidates[typeName][0].type)) ||
            (typeof mergeTypes === 'function' &&
                mergeTypes(typeName, typeCandidates[typeName])) ||
            (Array.isArray(mergeTypes) && mergeTypes.includes(typeName)) ||
            typeName in mergeInfo.mergedTypes) {
            typeMap[typeName] = merge(typeName, typeCandidates[typeName]);
        }
        else {
            var candidateSelector = onTypeConflict != null
                ? onTypeConflictToCandidateSelector(onTypeConflict)
                : function (cands) { return cands[cands.length - 1]; };
            typeMap[typeName] = candidateSelector(typeCandidates[typeName]).type;
        }
    });
    healTypes(typeMap, directives, { skipPruning: true });
    var mergedSchema = new graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLSchema"]({
        query: typeMap[queryTypeName],
        mutation: typeMap[mutationTypeName],
        subscription: typeMap[subscriptionTypeName],
        types: Object.keys(typeMap).map(function (key) { return typeMap[key]; }),
        directives: directives.length
            ? directives.map(function (directive) { return cloneDirective(directive); })
            : undefined,
    });
    extensions.forEach(function (extension) {
        mergedSchema = extendSchema(mergedSchema, extension, {
            commentDescriptions: true,
        });
    });
    addResolversToSchema({
        schema: mergedSchema,
        resolvers: finalResolvers,
        inheritResolversFromInterfaces: inheritResolversFromInterfaces,
    });
    forEachField(mergedSchema, function (field) {
        if (field.resolve != null) {
            var fieldResolver_1 = field.resolve;
            field.resolve = function (parent, args, context, info) {
                var newInfo = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, info), { mergeInfo: mergeInfo });
                return fieldResolver_1(parent, args, context, newInfo);
            };
        }
        if (field.subscribe != null) {
            var fieldResolver_2 = field.subscribe;
            field.subscribe = function (parent, args, context, info) {
                var newInfo = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, info), { mergeInfo: mergeInfo });
                return fieldResolver_2(parent, args, context, newInfo);
            };
        }
    });
    if (schemaDirectives != null) {
        SchemaDirectiveVisitor.visitSchemaDirectives(mergedSchema, schemaDirectives);
    }
    return mergedSchema;
}
function addTypeCandidate(typeCandidates, name, typeCandidate) {
    if (!(name in typeCandidates)) {
        typeCandidates[name] = [];
    }
    typeCandidates[name].push(typeCandidate);
}
function onTypeConflictToCandidateSelector(onTypeConflict) {
    return function (cands) {
        return cands.reduce(function (prev, next) {
            var type = onTypeConflict(prev.type, next.type, {
                left: {
                    schema: prev.schema,
                },
                right: {
                    schema: next.schema,
                },
            });
            if (prev.type === type) {
                return prev;
            }
            else if (next.type === type) {
                return next;
            }
            return {
                schemaName: 'unknown',
                type: type,
            };
        });
    };
}
function merge(typeName, candidates) {
    var initialCandidateType = candidates[0].type;
    if (candidates.some(function (candidate) {
        return candidate.type.constructor !== initialCandidateType.constructor;
    })) {
        throw new Error("Cannot merge different type categories into common type " + typeName + ".");
    }
    if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isObjectType"])(initialCandidateType)) {
        return new graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLObjectType"]({
            name: typeName,
            fields: candidates.reduce(function (acc, candidate) { return (Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, acc), toConfig(candidate.type).fields)); }, {}),
            interfaces: candidates.reduce(function (acc, candidate) {
                var interfaces = toConfig(candidate.type).interfaces;
                return interfaces != null ? acc.concat(interfaces) : acc;
            }, []),
        });
    }
    else if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isInterfaceType"])(initialCandidateType)) {
        var config = {
            name: typeName,
            fields: candidates.reduce(function (acc, candidate) { return (Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, acc), toConfig(candidate.type).fields)); }, {}),
            interfaces: graphqlVersion() >= 15
                ? candidates.reduce(function (acc, candidate) {
                    var interfaces = toConfig(candidate.type).interfaces;
                    return interfaces != null ? acc.concat(interfaces) : acc;
                }, [])
                : undefined,
        };
        return new graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLInterfaceType"](config);
    }
    else if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isUnionType"])(initialCandidateType)) {
        return new graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLUnionType"]({
            name: typeName,
            types: candidates.reduce(function (acc, candidate) { return acc.concat(toConfig(candidate.type).types); }, []),
        });
    }
    else if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isEnumType"])(initialCandidateType)) {
        return new graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLEnumType"]({
            name: typeName,
            values: candidates.reduce(function (acc, candidate) { return (Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, acc), toConfig(candidate.type).values)); }, {}),
        });
    }
    else if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isScalarType"])(initialCandidateType)) {
        throw new Error("Cannot merge type " + typeName + ". Merging not supported for GraphQLScalarType.");
    }
    else {
        // not reachable.
        throw new Error("Type " + typeName + " has unknown GraphQL type.");
    }
}

// This function is deprecated in favor of wrapSchema as the name is misleading.
// transformSchema does not just "transform" a schema, it wraps a schema with transforms
// using a round of delegation.
// The applySchemaTransforms function actually "transforms" the schema and is used during wrapping.
function transformSchema(subschemaOrSubschemaConfig, transforms) {
    var schema = wrapSchema(subschemaOrSubschemaConfig, transforms);
    schema.transforms = transforms.slice().reverse();
    return schema;
}

var RenameTypes = /** @class */ (function () {
    function RenameTypes(renamer, options) {
        this.renamer = renamer;
        this.map = Object.create(null);
        this.reverseMap = Object.create(null);
        var _a = options != null ? options : {}, _b = _a.renameBuiltins, renameBuiltins = _b === void 0 ? false : _b, _c = _a.renameScalars, renameScalars = _c === void 0 ? true : _c;
        this.renameBuiltins = renameBuiltins;
        this.renameScalars = renameScalars;
    }
    RenameTypes.prototype.transformSchema = function (originalSchema) {
        var _a;
        var _this = this;
        return mapSchema(originalSchema, (_a = {},
            _a[MapperKind.TYPE] = function (type) {
                if (isSpecifiedScalarType(type) && !_this.renameBuiltins) {
                    return undefined;
                }
                if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isScalarType"])(type) && !_this.renameScalars) {
                    return undefined;
                }
                var oldName = type.name;
                var newName = _this.renamer(oldName);
                if (newName !== undefined && newName !== oldName) {
                    _this.map[oldName] = newName;
                    _this.reverseMap[newName] = oldName;
                    var newConfig = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, toConfig(type)), { name: newName });
                    if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isObjectType"])(type)) {
                        return new graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLObjectType"](newConfig);
                    }
                    else if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isInterfaceType"])(type)) {
                        return new graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLInterfaceType"](newConfig);
                    }
                    else if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isUnionType"])(type)) {
                        return new graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLUnionType"](newConfig);
                    }
                    else if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isInputObjectType"])(type)) {
                        return new graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLInputObjectType"](newConfig);
                    }
                    else if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isEnumType"])(type)) {
                        return new graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLEnumType"](newConfig);
                    }
                    else if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isScalarType"])(type)) {
                        return new graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLScalarType"](newConfig);
                    }
                    throw new Error("Unknown type " + type + ".");
                }
            },
            _a[MapperKind.ROOT_OBJECT] = function () {
                return undefined;
            },
            _a));
    };
    RenameTypes.prototype.transformRequest = function (originalRequest) {
        var _a;
        var _this = this;
        var newDocument = Object(graphql__WEBPACK_IMPORTED_MODULE_3__["visit"])(originalRequest.document, (_a = {},
            _a[graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].NAMED_TYPE] = function (node) {
                var name = node.name.value;
                if (name in _this.reverseMap) {
                    return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, node), { name: {
                            kind: graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].NAME,
                            value: _this.reverseMap[name],
                        } });
                }
            },
            _a));
        return {
            document: newDocument,
            variables: originalRequest.variables,
        };
    };
    RenameTypes.prototype.transformResult = function (result) {
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, result), { data: this.transformData(result.data) });
    };
    RenameTypes.prototype.transformData = function (data) {
        var _this = this;
        if (data == null) {
            return data;
        }
        else if (Array.isArray(data)) {
            return data.map(function (value) { return _this.transformData(value); });
        }
        else if (typeof data === 'object') {
            return this.transformObject(data);
        }
        return data;
    };
    RenameTypes.prototype.transformObject = function (object) {
        var _this = this;
        Object.keys(object).forEach(function (key) {
            var value = object[key];
            if (key === '__typename') {
                if (value in _this.map) {
                    object[key] = _this.map[value];
                }
            }
            else {
                object[key] = _this.transformData(value);
            }
        });
        return object;
    };
    return RenameTypes;
}());

var FilterTypes = /** @class */ (function () {
    function FilterTypes(filter) {
        this.filter = filter;
    }
    FilterTypes.prototype.transformSchema = function (schema) {
        var _a;
        var _this = this;
        return mapSchema(schema, (_a = {},
            _a[MapperKind.TYPE] = function (type) {
                if (_this.filter(type)) {
                    return undefined;
                }
                return null;
            },
            _a));
    };
    return FilterTypes;
}());

var RenameRootTypes = /** @class */ (function () {
    function RenameRootTypes(renamer) {
        this.renamer = renamer;
        this.map = Object.create(null);
        this.reverseMap = Object.create(null);
    }
    RenameRootTypes.prototype.transformSchema = function (originalSchema) {
        var _a;
        var _this = this;
        return mapSchema(originalSchema, (_a = {},
            _a[MapperKind.ROOT_OBJECT] = function (type) {
                var oldName = type.name;
                var newName = _this.renamer(oldName);
                if (newName !== undefined && newName !== oldName) {
                    _this.map[oldName] = newName;
                    _this.reverseMap[newName] = oldName;
                    return new graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLObjectType"](Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, toConfig(type)), { name: newName }));
                }
            },
            _a));
    };
    RenameRootTypes.prototype.transformRequest = function (originalRequest) {
        var _a;
        var _this = this;
        var newDocument = Object(graphql__WEBPACK_IMPORTED_MODULE_3__["visit"])(originalRequest.document, (_a = {},
            _a[graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].NAMED_TYPE] = function (node) {
                var name = node.name.value;
                if (name in _this.reverseMap) {
                    return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, node), { name: {
                            kind: graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].NAME,
                            value: _this.reverseMap[name],
                        } });
                }
            },
            _a));
        return {
            document: newDocument,
            variables: originalRequest.variables,
        };
    };
    RenameRootTypes.prototype.transformResult = function (result) {
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, result), { data: this.transformData(result.data) });
    };
    RenameRootTypes.prototype.transformData = function (data) {
        var _this = this;
        if (data == null) {
            return data;
        }
        else if (Array.isArray(data)) {
            return data.map(function (value) { return _this.transformData(value); });
        }
        else if (typeof data === 'object') {
            return this.transformObject(data);
        }
        return data;
    };
    RenameRootTypes.prototype.transformObject = function (object) {
        var _this = this;
        Object.keys(object).forEach(function (key) {
            var value = object[key];
            if (key === '__typename') {
                if (value in _this.map) {
                    object[key] = _this.map[value];
                }
            }
            else {
                object[key] = _this.transformData(value);
            }
        });
        return object;
    };
    return RenameRootTypes;
}());

function isEmptyObject(obj) {
    if (obj == null) {
        return true;
    }
    return Object.keys(obj).length === 0;
}

var TransformCompositeFields = /** @class */ (function () {
    function TransformCompositeFields(fieldTransformer, fieldNodeTransformer) {
        this.fieldTransformer = fieldTransformer;
        this.fieldNodeTransformer = fieldNodeTransformer;
        this.mapping = {};
    }
    TransformCompositeFields.prototype.transformSchema = function (originalSchema) {
        var _a;
        var _this = this;
        this.transformedSchema = mapSchema(originalSchema, (_a = {},
            _a[MapperKind.OBJECT_TYPE] = function (type) {
                return _this.transformFields(type, _this.fieldTransformer);
            },
            _a[MapperKind.INTERFACE_TYPE] = function (type) {
                return _this.transformFields(type, _this.fieldTransformer);
            },
            _a));
        return this.transformedSchema;
    };
    TransformCompositeFields.prototype.transformRequest = function (originalRequest) {
        var fragments = Object.create(null);
        originalRequest.document.definitions
            .filter(function (def) { return def.kind === graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].FRAGMENT_DEFINITION; })
            .forEach(function (def) {
            fragments[def.name.value] = def;
        });
        var document = this.transformDocument(originalRequest.document, this.mapping, this.fieldNodeTransformer, fragments);
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, originalRequest), { document: document });
    };
    TransformCompositeFields.prototype.transformFields = function (type, fieldTransformer) {
        var _this = this;
        var typeConfig = toConfig(type);
        var fields = type.getFields();
        var newFields = {};
        Object.keys(fields).forEach(function (fieldName) {
            var field = fields[fieldName];
            var transformedField = fieldTransformer(type.name, fieldName, field);
            if (typeof transformedField === 'undefined') {
                newFields[fieldName] = typeConfig.fields[fieldName];
            }
            else if (transformedField !== null) {
                var newName = transformedField.name;
                if (newName) {
                    newFields[newName] =
                        transformedField.field != null
                            ? transformedField.field
                            : typeConfig.fields[fieldName];
                    if (newName !== fieldName) {
                        var typeName = type.name;
                        if (!(typeName in _this.mapping)) {
                            _this.mapping[typeName] = {};
                        }
                        _this.mapping[typeName][newName] = fieldName;
                    }
                }
                else {
                    newFields[fieldName] = transformedField;
                }
            }
        });
        if (isEmptyObject(newFields)) {
            return null;
        }
        if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isObjectType"])(type)) {
            return new graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLObjectType"](Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, toConfig(type)), { fields: newFields }));
        }
        else if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isInterfaceType"])(type)) {
            return new graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLInterfaceType"](Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, toConfig(type)), { fields: newFields }));
        }
    };
    TransformCompositeFields.prototype.transformDocument = function (document, mapping, fieldNodeTransformer, fragments) {
        var _a;
        if (fragments === void 0) { fragments = {}; }
        var typeInfo = new graphql__WEBPACK_IMPORTED_MODULE_3__["TypeInfo"](this.transformedSchema);
        var newDocument = Object(graphql__WEBPACK_IMPORTED_MODULE_3__["visit"])(document, Object(graphql__WEBPACK_IMPORTED_MODULE_3__["visitWithTypeInfo"])(typeInfo, {
            leave: (_a = {},
                _a[graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].SELECTION_SET] = function (node) {
                    var parentType = typeInfo.getParentType();
                    if (parentType != null) {
                        var parentTypeName_1 = parentType.name;
                        var newSelections_1 = [];
                        node.selections.forEach(function (selection) {
                            if (selection.kind !== graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].FIELD) {
                                newSelections_1.push(selection);
                                return;
                            }
                            var newName = selection.name.value;
                            var transformedSelection = fieldNodeTransformer != null
                                ? fieldNodeTransformer(parentTypeName_1, newName, selection, fragments)
                                : selection;
                            if (Array.isArray(transformedSelection)) {
                                newSelections_1 = newSelections_1.concat(transformedSelection);
                                return;
                            }
                            if (transformedSelection.kind !== graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].FIELD) {
                                newSelections_1.push(transformedSelection);
                                return;
                            }
                            var typeMapping = mapping[parentTypeName_1];
                            if (typeMapping == null) {
                                newSelections_1.push(transformedSelection);
                                return;
                            }
                            var oldName = mapping[parentTypeName_1][newName];
                            if (oldName == null) {
                                newSelections_1.push(transformedSelection);
                                return;
                            }
                            newSelections_1.push(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, transformedSelection), { name: {
                                    kind: graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].NAME,
                                    value: oldName,
                                }, alias: {
                                    kind: graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].NAME,
                                    value: newName,
                                } }));
                        });
                        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, node), { selections: newSelections_1 });
                    }
                },
                _a),
        }));
        return newDocument;
    };
    return TransformCompositeFields;
}());

var TransformObjectFields = /** @class */ (function () {
    function TransformObjectFields(objectFieldTransformer, fieldNodeTransformer) {
        this.objectFieldTransformer = objectFieldTransformer;
        this.fieldNodeTransformer = fieldNodeTransformer;
    }
    TransformObjectFields.prototype.transformSchema = function (originalSchema) {
        var _this = this;
        var compositeToObjectFieldTransformer = function (typeName, fieldName, field) {
            if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isObjectType"])(originalSchema.getType(typeName))) {
                return _this.objectFieldTransformer(typeName, fieldName, field);
            }
            return undefined;
        };
        this.transformer = new TransformCompositeFields(compositeToObjectFieldTransformer, this.fieldNodeTransformer);
        return this.transformer.transformSchema(originalSchema);
    };
    TransformObjectFields.prototype.transformRequest = function (originalRequest) {
        return this.transformer.transformRequest(originalRequest);
    };
    return TransformObjectFields;
}());

var TransformRootFields = /** @class */ (function () {
    function TransformRootFields(rootFieldTransformer, fieldNodeTransformer) {
        var rootToObjectFieldTransformer = function (typeName, fieldName, field) {
            if (typeName === 'Query' ||
                typeName === 'Mutation' ||
                typeName === 'Subscription') {
                return rootFieldTransformer(typeName, fieldName, field);
            }
            return undefined;
        };
        this.transformer = new TransformObjectFields(rootToObjectFieldTransformer, fieldNodeTransformer);
    }
    TransformRootFields.prototype.transformSchema = function (originalSchema) {
        return this.transformer.transformSchema(originalSchema);
    };
    TransformRootFields.prototype.transformRequest = function (originalRequest) {
        return this.transformer.transformRequest(originalRequest);
    };
    return TransformRootFields;
}());

var RenameRootFields = /** @class */ (function () {
    function RenameRootFields(renamer) {
        this.transformer = new TransformRootFields(function (operation, fieldName, field) { return ({
            name: renamer(operation, fieldName, field),
        }); });
    }
    RenameRootFields.prototype.transformSchema = function (originalSchema) {
        return this.transformer.transformSchema(originalSchema);
    };
    RenameRootFields.prototype.transformRequest = function (originalRequest) {
        return this.transformer.transformRequest(originalRequest);
    };
    return RenameRootFields;
}());

var FilterRootFields = /** @class */ (function () {
    function FilterRootFields(filter) {
        this.transformer = new TransformRootFields(function (operation, fieldName, field) {
            if (filter(operation, fieldName, field)) {
                return undefined;
            }
            return null;
        });
    }
    FilterRootFields.prototype.transformSchema = function (originalSchema) {
        return this.transformer.transformSchema(originalSchema);
    };
    return FilterRootFields;
}());

var RenameObjectFields = /** @class */ (function () {
    function RenameObjectFields(renamer) {
        this.transformer = new TransformObjectFields(function (typeName, fieldName, field) { return ({
            name: renamer(typeName, fieldName, field),
        }); });
    }
    RenameObjectFields.prototype.transformSchema = function (originalSchema) {
        return this.transformer.transformSchema(originalSchema);
    };
    RenameObjectFields.prototype.transformRequest = function (originalRequest) {
        return this.transformer.transformRequest(originalRequest);
    };
    return RenameObjectFields;
}());

var FilterObjectFields = /** @class */ (function () {
    function FilterObjectFields(filter) {
        this.transformer = new TransformObjectFields(function (typeName, fieldName, field) {
            return filter(typeName, fieldName, field) ? undefined : null;
        });
    }
    FilterObjectFields.prototype.transformSchema = function (originalSchema) {
        return this.transformer.transformSchema(originalSchema);
    };
    return FilterObjectFields;
}());

var TransformInterfaceFields = /** @class */ (function () {
    function TransformInterfaceFields(interfaceFieldTransformer, fieldNodeTransformer) {
        this.interfaceFieldTransformer = interfaceFieldTransformer;
        this.fieldNodeTransformer = fieldNodeTransformer;
    }
    TransformInterfaceFields.prototype.transformSchema = function (originalSchema) {
        var _this = this;
        var compositeToObjectFieldTransformer = function (typeName, fieldName, field) {
            if (Object(graphql__WEBPACK_IMPORTED_MODULE_3__["isInterfaceType"])(originalSchema.getType(typeName))) {
                return _this.interfaceFieldTransformer(typeName, fieldName, field);
            }
            return undefined;
        };
        this.transformer = new TransformCompositeFields(compositeToObjectFieldTransformer, this.fieldNodeTransformer);
        return this.transformer.transformSchema(originalSchema);
    };
    TransformInterfaceFields.prototype.transformRequest = function (originalRequest) {
        return this.transformer.transformRequest(originalRequest);
    };
    return TransformInterfaceFields;
}());

var RenameInterfaceFields = /** @class */ (function () {
    function RenameInterfaceFields(renamer) {
        this.transformer = new TransformInterfaceFields(function (typeName, fieldName, field) { return ({
            name: renamer(typeName, fieldName, field),
        }); });
    }
    RenameInterfaceFields.prototype.transformSchema = function (originalSchema) {
        return this.transformer.transformSchema(originalSchema);
    };
    RenameInterfaceFields.prototype.transformRequest = function (originalRequest) {
        return this.transformer.transformRequest(originalRequest);
    };
    return RenameInterfaceFields;
}());

var FilterInterfaceFields = /** @class */ (function () {
    function FilterInterfaceFields(filter) {
        this.transformer = new TransformInterfaceFields(function (typeName, fieldName, field) {
            return filter(typeName, fieldName, field) ? undefined : null;
        });
    }
    FilterInterfaceFields.prototype.transformSchema = function (originalSchema) {
        return this.transformer.transformSchema(originalSchema);
    };
    return FilterInterfaceFields;
}());

var TransformQuery = /** @class */ (function () {
    function TransformQuery(_a) {
        var path = _a.path, queryTransformer = _a.queryTransformer, _b = _a.resultTransformer, resultTransformer = _b === void 0 ? function (result) { return result; } : _b, _c = _a.errorPathTransformer, errorPathTransformer = _c === void 0 ? function (errorPath) { return [].concat(errorPath); } : _c, _d = _a.fragments, fragments = _d === void 0 ? {} : _d;
        this.path = path;
        this.queryTransformer = queryTransformer;
        this.resultTransformer = resultTransformer;
        this.errorPathTransformer = errorPathTransformer;
        this.fragments = fragments;
    }
    TransformQuery.prototype.transformRequest = function (originalRequest) {
        var _a;
        var _this = this;
        var document = originalRequest.document;
        var pathLength = this.path.length;
        var index = 0;
        var newDocument = Object(graphql__WEBPACK_IMPORTED_MODULE_3__["visit"])(document, (_a = {},
            _a[graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].FIELD] = {
                enter: function (node) {
                    if (index === pathLength || node.name.value !== _this.path[index]) {
                        return false;
                    }
                    index++;
                    if (index === pathLength) {
                        var selectionSet = _this.queryTransformer(node.selectionSet, _this.fragments);
                        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, node), { selectionSet: selectionSet });
                    }
                },
                leave: function () {
                    index--;
                },
            },
            _a));
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, originalRequest), { document: newDocument });
    };
    TransformQuery.prototype.transformResult = function (originalResult) {
        var data = this.transformData(originalResult.data);
        var errors = originalResult.errors;
        return {
            data: data,
            errors: errors != null ? this.transformErrors(errors) : undefined,
        };
    };
    TransformQuery.prototype.transformData = function (data) {
        var leafIndex = this.path.length - 1;
        var index = 0;
        var newData = data;
        if (newData) {
            var next = this.path[index];
            while (index < leafIndex) {
                if (data[next]) {
                    newData = newData[next];
                }
                else {
                    break;
                }
                index++;
                next = this.path[index];
            }
            newData[next] = this.resultTransformer(newData[next]);
        }
        return newData;
    };
    TransformQuery.prototype.transformErrors = function (errors) {
        var _this = this;
        return errors.map(function (error) {
            var path = error.path;
            var match = true;
            var index = 0;
            while (index < _this.path.length) {
                if (path[index] !== _this.path[index]) {
                    match = false;
                    break;
                }
                index++;
            }
            var newPath = match
                ? path
                    .slice(0, index)
                    .concat(_this.errorPathTransformer(path.slice(index)))
                : path;
            return new graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLError"](error.message, error.nodes, error.source, error.positions, newPath, error.originalError, error.extensions);
        });
    };
    return TransformQuery;
}());

var MapFields = /** @class */ (function () {
    function MapFields(fieldNodeTransformerMap) {
        this.transformer = new TransformObjectFields(function (_typeName, _fieldName, field) { return toConfig(field); }, function (typeName, fieldName, fieldNode, fragments) {
            var typeTransformers = fieldNodeTransformerMap[typeName];
            if (typeTransformers == null) {
                return fieldNode;
            }
            var fieldNodeTransformer = typeTransformers[fieldName];
            if (fieldNodeTransformer == null) {
                return fieldNode;
            }
            return fieldNodeTransformer(fieldNode, fragments);
        });
    }
    MapFields.prototype.transformSchema = function (schema) {
        return this.transformer.transformSchema(schema);
    };
    MapFields.prototype.transformRequest = function (request) {
        return this.transformer.transformRequest(request);
    };
    return MapFields;
}());

var ExtendSchema = /** @class */ (function () {
    function ExtendSchema(_a) {
        var typeDefs = _a.typeDefs, _b = _a.resolvers, resolvers = _b === void 0 ? {} : _b, defaultFieldResolver = _a.defaultFieldResolver, fieldNodeTransformerMap = _a.fieldNodeTransformerMap;
        this.typeDefs = typeDefs;
        this.resolvers = resolvers;
        this.defaultFieldResolver =
            defaultFieldResolver != null
                ? defaultFieldResolver
                : defaultMergedResolver;
        this.transformer = new MapFields(fieldNodeTransformerMap != null ? fieldNodeTransformerMap : {});
    }
    ExtendSchema.prototype.transformSchema = function (schema) {
        this.transformer.transformSchema(schema);
        return addResolversToSchema({
            schema: this.typeDefs
                ? Object(graphql__WEBPACK_IMPORTED_MODULE_3__["extendSchema"])(schema, Object(graphql__WEBPACK_IMPORTED_MODULE_3__["parse"])(this.typeDefs))
                : schema,
            resolvers: this.resolvers != null ? this.resolvers : {},
            defaultFieldResolver: this.defaultFieldResolver,
        });
    };
    ExtendSchema.prototype.transformRequest = function (originalRequest) {
        return this.transformer.transformRequest(originalRequest);
    };
    return ExtendSchema;
}());

function renameFieldNode(fieldNode, name) {
    return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, fieldNode), { alias: {
            kind: graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].NAME,
            value: fieldNode.alias != null ? fieldNode.alias.value : fieldNode.name.value,
        }, name: {
            kind: graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].NAME,
            value: name,
        } });
}
function preAliasFieldNode(fieldNode, str) {
    return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, fieldNode), { alias: {
            kind: graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].NAME,
            value: "" + str + (fieldNode.alias != null ? fieldNode.alias.value : fieldNode.name.value),
        } });
}
function wrapFieldNode(fieldNode, path) {
    var newFieldNode = fieldNode;
    path.forEach(function (fieldName) {
        newFieldNode = {
            kind: graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].FIELD,
            name: {
                kind: graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].NAME,
                value: fieldName,
            },
            selectionSet: {
                kind: graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].SELECTION_SET,
                selections: [fieldNode],
            },
        };
    });
    return newFieldNode;
}
function collectFields$1(selectionSet, fragments, fields, visitedFragmentNames) {
    if (fields === void 0) { fields = []; }
    if (visitedFragmentNames === void 0) { visitedFragmentNames = {}; }
    if (selectionSet != null) {
        selectionSet.selections.forEach(function (selection) {
            switch (selection.kind) {
                case graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].FIELD:
                    fields.push(selection);
                    break;
                case graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].INLINE_FRAGMENT:
                    collectFields$1(selection.selectionSet, fragments, fields, visitedFragmentNames);
                    break;
                case graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].FRAGMENT_SPREAD: {
                    var fragmentName = selection.name.value;
                    if (!visitedFragmentNames[fragmentName]) {
                        visitedFragmentNames[fragmentName] = true;
                        collectFields$1(fragments[fragmentName].selectionSet, fragments, fields, visitedFragmentNames);
                    }
                    break;
                }
            }
        });
    }
    return fields;
}
function hoistFieldNodes(_a) {
    var fieldNode = _a.fieldNode, fieldNames = _a.fieldNames, _b = _a.path, path = _b === void 0 ? [] : _b, _c = _a.delimeter, delimeter = _c === void 0 ? '__gqltf__' : _c, fragments = _a.fragments;
    var alias = fieldNode.alias != null ? fieldNode.alias.value : fieldNode.name.value;
    var newFieldNodes = [];
    if (path.length) {
        var remainingPathSegments_1 = path.slice();
        var initialPathSegment_1 = remainingPathSegments_1.shift();
        collectFields$1(fieldNode.selectionSet, fragments).forEach(function (possibleFieldNode) {
            if (possibleFieldNode.name.value === initialPathSegment_1) {
                newFieldNodes = newFieldNodes.concat(hoistFieldNodes({
                    fieldNode: preAliasFieldNode(possibleFieldNode, "" + alias + delimeter),
                    fieldNames: fieldNames,
                    path: remainingPathSegments_1,
                    delimeter: delimeter,
                    fragments: fragments,
                }));
            }
        });
    }
    else {
        collectFields$1(fieldNode.selectionSet, fragments).forEach(function (possibleFieldNode) {
            if (!fieldNames || fieldNames.includes(possibleFieldNode.name.value)) {
                newFieldNodes.push(preAliasFieldNode(possibleFieldNode, "" + alias + delimeter));
            }
        });
    }
    return newFieldNodes;
}

function appendFields(typeMap, typeName, fields) {
    var type = typeMap[typeName];
    if (type != null) {
        var typeConfig = toConfig(type);
        var newFields_1 = toObjMap(typeConfig.fields);
        Object.keys(fields).forEach(function (fieldName) {
            newFields_1[fieldName] = fields[fieldName];
        });
        type = new graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLObjectType"](Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, typeConfig), { fields: newFields_1 }));
    }
    else {
        type = new graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLObjectType"]({
            name: typeName,
            fields: fields,
        });
    }
    typeMap[typeName] = type;
}
function removeFields(typeMap, typeName, testFn) {
    var type = typeMap[typeName];
    var typeConfig = toConfig(type);
    var originalFields = typeConfig.fields;
    var newFields = {};
    var removedFields = {};
    Object.keys(originalFields).forEach(function (fieldName) {
        if (testFn(fieldName, originalFields[fieldName])) {
            removedFields[fieldName] = originalFields[fieldName];
        }
        else {
            newFields[fieldName] = originalFields[fieldName];
        }
    });
    type = new graphql__WEBPACK_IMPORTED_MODULE_3__["GraphQLObjectType"](Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, typeConfig), { fields: newFields }));
    typeMap[typeName] = type;
    return removedFields;
}

function createMergedResolver(_a) {
    var fromPath = _a.fromPath, dehoist = _a.dehoist, _b = _a.delimeter, delimeter = _b === void 0 ? '__gqltf__' : _b;
    var parentErrorResolver = function (parent, args, context, info) {
        return parent instanceof Error
            ? parent
            : defaultMergedResolver(parent, args, context, info);
    };
    var unwrappingResolver = fromPath != null
        ? function (parent, args, context, info) {
            return parentErrorResolver(unwrapResult(parent, info, fromPath), args, context, info);
        }
        : parentErrorResolver;
    var dehoistingResolver = dehoist
        ? function (parent, args, context, info) {
            return unwrappingResolver(dehoistResult(parent, delimeter), args, context, info);
        }
        : unwrappingResolver;
    var noParentResolver = function (parent, args, context, info) { return (parent ? dehoistingResolver(parent, args, context, info) : {}); };
    return noParentResolver;
}

var WrapFields = /** @class */ (function () {
    function WrapFields(outerTypeName, wrappingFieldNames, wrappingTypeNames, fieldNames) {
        var _a, _b;
        var _this = this;
        this.outerTypeName = outerTypeName;
        this.wrappingFieldNames = wrappingFieldNames;
        this.wrappingTypeNames = wrappingTypeNames;
        this.numWraps = wrappingFieldNames.length;
        this.fieldNames = fieldNames;
        var remainingWrappingFieldNames = this.wrappingFieldNames.slice();
        var outerMostWrappingFieldName = remainingWrappingFieldNames.shift();
        this.transformer = new MapFields((_a = {},
            _a[outerTypeName] = (_b = {},
                _b[outerMostWrappingFieldName] = function (fieldNode, fragments) {
                    return hoistFieldNodes({
                        fieldNode: fieldNode,
                        path: remainingWrappingFieldNames,
                        fieldNames: _this.fieldNames,
                        fragments: fragments,
                    });
                },
                _b),
            _a));
    }
    WrapFields.prototype.transformSchema = function (schema) {
        var _a, _b;
        var _this = this;
        var typeMap = schema.getTypeMap();
        var targetFields = removeFields(typeMap, this.outerTypeName, !this.fieldNames
            ? function () { return true; }
            : function (fieldName) { return _this.fieldNames.includes(fieldName); });
        var wrapIndex = this.numWraps - 1;
        var innerMostWrappingTypeName = this.wrappingTypeNames[wrapIndex];
        appendFields(typeMap, innerMostWrappingTypeName, targetFields);
        for (wrapIndex--; wrapIndex > -1; wrapIndex--) {
            appendFields(typeMap, this.wrappingTypeNames[wrapIndex], (_a = {},
                _a[this.wrappingFieldNames[wrapIndex + 1]] = {
                    type: typeMap[this.wrappingTypeNames[wrapIndex + 1]],
                    resolve: defaultMergedResolver,
                },
                _a));
        }
        appendFields(typeMap, this.outerTypeName, (_b = {},
            _b[this.wrappingFieldNames[0]] = {
                type: typeMap[this.wrappingTypeNames[0]],
                resolve: createMergedResolver({ dehoist: true }),
            },
            _b));
        healSchema(schema);
        return this.transformer.transformSchema(schema);
    };
    WrapFields.prototype.transformRequest = function (originalRequest) {
        return this.transformer.transformRequest(originalRequest);
    };
    return WrapFields;
}());

var WrapType = /** @class */ (function () {
    function WrapType(outerTypeName, innerTypeName, fieldName) {
        this.transformer = new WrapFields(outerTypeName, [fieldName], [innerTypeName], undefined);
    }
    WrapType.prototype.transformSchema = function (schema) {
        return this.transformer.transformSchema(schema);
    };
    WrapType.prototype.transformRequest = function (originalRequest) {
        return this.transformer.transformRequest(originalRequest);
    };
    return WrapType;
}());

var HoistField = /** @class */ (function () {
    function HoistField(typeName, path, newFieldName) {
        var _a, _b;
        var _this = this;
        this.typeName = typeName;
        this.path = path;
        this.newFieldName = newFieldName;
        this.pathToField = this.path.slice();
        this.oldFieldName = this.pathToField.pop();
        this.transformer = new MapFields((_a = {},
            _a[typeName] = (_b = {},
                _b[newFieldName] = function (fieldNode) {
                    return wrapFieldNode(renameFieldNode(fieldNode, _this.oldFieldName), _this.pathToField);
                },
                _b),
            _a));
    }
    HoistField.prototype.transformSchema = function (schema) {
        var _a;
        var _this = this;
        var typeMap = schema.getTypeMap();
        var innerType = this.pathToField.reduce(function (acc, pathSegment) {
            return Object(graphql__WEBPACK_IMPORTED_MODULE_3__["getNullableType"])(acc.getFields()[pathSegment].type);
        }, typeMap[this.typeName]);
        var targetField = removeFields(typeMap, innerType.name, function (fieldName) { return fieldName === _this.oldFieldName; })[this.oldFieldName];
        var targetType = targetField.type;
        appendFields(typeMap, this.typeName, (_a = {},
            _a[this.newFieldName] = {
                type: targetType,
                resolve: createMergedResolver({ fromPath: this.pathToField }),
            },
            _a));
        healSchema(schema);
        return this.transformer.transformSchema(schema);
    };
    HoistField.prototype.transformRequest = function (originalRequest) {
        return this.transformer.transformRequest(originalRequest);
    };
    return HoistField;
}());

var ReplaceFieldWithFragment = /** @class */ (function () {
    function ReplaceFieldWithFragment(targetSchema, fragments) {
        this.targetSchema = targetSchema;
        this.mapping = {};
        for (var _i = 0, fragments_1 = fragments; _i < fragments_1.length; _i++) {
            var _a = fragments_1[_i], field = _a.field, fragment = _a.fragment;
            var parsedFragment = parseFragmentToInlineFragment$1(fragment);
            var actualTypeName = parsedFragment.typeCondition.name.value;
            if (!(actualTypeName in this.mapping)) {
                this.mapping[actualTypeName] = Object.create(null);
            }
            var typeMapping = this.mapping[actualTypeName];
            if (!(field in typeMapping)) {
                typeMapping[field] = [parsedFragment];
            }
            else {
                typeMapping[field].push(parsedFragment);
            }
        }
    }
    ReplaceFieldWithFragment.prototype.transformRequest = function (originalRequest) {
        var document = replaceFieldsWithFragments$1(this.targetSchema, originalRequest.document, this.mapping);
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, originalRequest), { document: document });
    };
    return ReplaceFieldWithFragment;
}());
function replaceFieldsWithFragments$1(targetSchema, document, mapping) {
    var _a;
    var typeInfo = new graphql__WEBPACK_IMPORTED_MODULE_3__["TypeInfo"](targetSchema);
    return Object(graphql__WEBPACK_IMPORTED_MODULE_3__["visit"])(document, Object(graphql__WEBPACK_IMPORTED_MODULE_3__["visitWithTypeInfo"])(typeInfo, (_a = {},
        _a[graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].SELECTION_SET] = function (node) {
            var parentType = typeInfo.getParentType();
            if (parentType != null) {
                var parentTypeName_1 = parentType.name;
                var selections_1 = node.selections;
                if (parentTypeName_1 in mapping) {
                    node.selections.forEach(function (selection) {
                        if (selection.kind === graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].FIELD) {
                            var name_1 = selection.name.value;
                            var fragments = mapping[parentTypeName_1][name_1];
                            if (fragments != null && fragments.length > 0) {
                                var fragment = concatInlineFragments(parentTypeName_1, fragments);
                                selections_1 = selections_1.concat(fragment);
                            }
                        }
                    });
                }
                if (selections_1 !== node.selections) {
                    return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, node), { selections: selections_1 });
                }
            }
        },
        _a)));
}
function parseFragmentToInlineFragment$1(definitions) {
    if (definitions.trim().startsWith('fragment')) {
        var document_1 = Object(graphql__WEBPACK_IMPORTED_MODULE_3__["parse"])(definitions);
        for (var _i = 0, _a = document_1.definitions; _i < _a.length; _i++) {
            var definition = _a[_i];
            if (definition.kind === graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].FRAGMENT_DEFINITION) {
                return {
                    kind: graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].INLINE_FRAGMENT,
                    typeCondition: definition.typeCondition,
                    selectionSet: definition.selectionSet,
                };
            }
        }
    }
    var query = Object(graphql__WEBPACK_IMPORTED_MODULE_3__["parse"])("{" + definitions + "}")
        .definitions[0];
    for (var _b = 0, _c = query.selectionSet.selections; _b < _c.length; _b++) {
        var selection = _c[_b];
        if (selection.kind === graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].INLINE_FRAGMENT) {
            return selection;
        }
    }
    throw new Error('Could not parse fragment');
}

var WrapQuery = /** @class */ (function () {
    function WrapQuery(path, wrapper, extractor) {
        this.path = path;
        this.wrapper = wrapper;
        this.extractor = extractor;
    }
    WrapQuery.prototype.transformRequest = function (originalRequest) {
        var _a;
        var _this = this;
        var document = originalRequest.document;
        var fieldPath = [];
        var ourPath = JSON.stringify(this.path);
        var newDocument = Object(graphql__WEBPACK_IMPORTED_MODULE_3__["visit"])(document, (_a = {},
            _a[graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].FIELD] = {
                enter: function (node) {
                    fieldPath.push(node.name.value);
                    if (ourPath === JSON.stringify(fieldPath)) {
                        var wrapResult = _this.wrapper(node.selectionSet);
                        // Selection can be either a single selection or a selection set. If it's just one selection,
                        // let's wrap it in a selection set. Otherwise, keep it as is.
                        var selectionSet = wrapResult != null && wrapResult.kind === graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].SELECTION_SET
                            ? wrapResult
                            : {
                                kind: graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].SELECTION_SET,
                                selections: [wrapResult],
                            };
                        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, node), { selectionSet: selectionSet });
                    }
                },
                leave: function () {
                    fieldPath.pop();
                },
            },
            _a));
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, originalRequest), { document: newDocument });
    };
    WrapQuery.prototype.transformResult = function (originalResult) {
        var rootData = originalResult.data;
        if (rootData != null) {
            var data = rootData;
            var path = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __spreadArrays */ "d"])(this.path);
            while (path.length > 1) {
                var next = path.shift();
                if (data[next]) {
                    data = data[next];
                }
            }
            data[path[0]] = this.extractor(data[path[0]]);
        }
        return {
            data: rootData,
            errors: originalResult.errors,
        };
    };
    return WrapQuery;
}());

var ExtractField = /** @class */ (function () {
    function ExtractField(_a) {
        var from = _a.from, to = _a.to;
        this.from = from;
        this.to = to;
    }
    ExtractField.prototype.transformRequest = function (originalRequest) {
        var _a, _b;
        var fromSelection;
        var ourPathFrom = JSON.stringify(this.from);
        var ourPathTo = JSON.stringify(this.to);
        var fieldPath = [];
        Object(graphql__WEBPACK_IMPORTED_MODULE_3__["visit"])(originalRequest.document, (_a = {},
            _a[graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].FIELD] = {
                enter: function (node) {
                    fieldPath.push(node.name.value);
                    if (ourPathFrom === JSON.stringify(fieldPath)) {
                        fromSelection = node.selectionSet;
                        return graphql__WEBPACK_IMPORTED_MODULE_3__["BREAK"];
                    }
                },
                leave: function () {
                    fieldPath.pop();
                },
            },
            _a));
        fieldPath = [];
        var newDocument = Object(graphql__WEBPACK_IMPORTED_MODULE_3__["visit"])(originalRequest.document, (_b = {},
            _b[graphql__WEBPACK_IMPORTED_MODULE_3__["Kind"].FIELD] = {
                enter: function (node) {
                    fieldPath.push(node.name.value);
                    if (ourPathTo === JSON.stringify(fieldPath) &&
                        fromSelection != null) {
                        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, node), { selectionSet: fromSelection });
                    }
                },
                leave: function () {
                    fieldPath.pop();
                },
            },
            _b));
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, originalRequest), { document: newDocument });
    };
    return ExtractField;
}());

function makeRemoteExecutableSchema(_a) {
    var schemaOrTypeDefs = _a.schema, link = _a.link, fetcher = _a.fetcher, _b = _a.createResolver, createResolver = _b === void 0 ? defaultCreateRemoteResolver : _b, _c = _a.createSubscriptionResolver, createSubscriptionResolver = _c === void 0 ? defaultCreateRemoteSubscriptionResolver : _c, buildSchemaOptions = _a.buildSchemaOptions;
    var finalFetcher = fetcher;
    if (finalFetcher == null && link != null) {
        finalFetcher = linkToFetcher(link);
    }
    var targetSchema = typeof schemaOrTypeDefs === 'string'
        ? buildSchema(schemaOrTypeDefs, buildSchemaOptions)
        : schemaOrTypeDefs;
    return wrapSchema({
        schema: targetSchema,
        createProxyingResolver: function (_schema, _transforms, operation) {
            if (operation === 'query' || operation === 'mutation') {
                return createResolver(finalFetcher);
            }
            return createSubscriptionResolver(link);
        },
    });
}
function defaultCreateRemoteResolver(fetcher) {
    return function (_parent, _args, context, info) {
        return delegateToSchema({
            schema: { schema: info.schema, fetcher: fetcher },
            context: context,
            info: info,
        });
    };
}
function defaultCreateRemoteSubscriptionResolver(link) {
    return function (_parent, _args, context, info) {
        return delegateToSchema({
            schema: { schema: info.schema, link: link },
            context: context,
            info: info,
        });
    };
}


//# sourceMappingURL=index.esm.js.map


/***/ }),

/***/ "../../node_modules/crypto-randomuuid/index.js":
/*!**********************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/crypto-randomuuid/index.js ***!
  \**********************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const crypto = __webpack_require__(/*! crypto */ "crypto");

module.exports = typeof crypto.randomUUID === 'function'
  ? crypto.randomUUID
  : __webpack_require__(/*! ./polyfill */ "../../node_modules/crypto-randomuuid/polyfill.js");


/***/ }),

/***/ "../../node_modules/crypto-randomuuid/polyfill.js":
/*!*************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/crypto-randomuuid/polyfill.js ***!
  \*************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const crypto = __webpack_require__(/*! crypto */ "crypto");

const {
  validateBoolean,
  validateObject,
  codes: {
    ERR_OPERATION_FAILED
  }
} = __webpack_require__(/*! ./validators */ "../../node_modules/crypto-randomuuid/validators.js");

const { randomFillSync } = crypto;

// This is a non-cryptographically secure replacement for the native version
// of the `secureBuffer` function used in Node.js core. This means `randomUUID`
// should not be used where cryptographically secure uuids are important.
//
// Node.js core uses a native version which uses `OPENSSL_secure_malloc`
// rather than `randomFillSync`.
function secureBuffer (size) {
  const buf = Buffer.alloc(size);
  return randomFillSync(buf);
}

// Implements an RFC 4122 version 4 random UUID.
// To improve performance, random data is generated in batches
// large enough to cover kBatchSize UUID's at a time. The uuidData
// buffer is reused. Each call to randomUUID() consumes 16 bytes
// from the buffer.

const kBatchSize = 128;
let uuidData;
let uuidNotBuffered;
let uuidBatch = 0;

let hexBytesCache;
function getHexBytes () {
  if (hexBytesCache === undefined) {
    hexBytesCache = new Array(256);
    for (let i = 0; i < hexBytesCache.length; i++) {
      const hex = i.toString(16);
      hexBytesCache[i] = hex.padStart(2, '0');
    }
  }
  return hexBytesCache;
}

function serializeUUID (buf, offset = 0) {
  const kHexBytes = getHexBytes();
  // xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx
  return kHexBytes[buf[offset]] +
    kHexBytes[buf[offset + 1]] +
    kHexBytes[buf[offset + 2]] +
    kHexBytes[buf[offset + 3]] +
    '-' +
    kHexBytes[buf[offset + 4]] +
    kHexBytes[buf[offset + 5]] +
    '-' +
    kHexBytes[(buf[offset + 6] & 0x0f) | 0x40] +
    kHexBytes[buf[offset + 7]] +
    '-' +
    kHexBytes[(buf[offset + 8] & 0x3f) | 0x80] +
    kHexBytes[buf[offset + 9]] +
    '-' +
    kHexBytes[buf[offset + 10]] +
    kHexBytes[buf[offset + 11]] +
    kHexBytes[buf[offset + 12]] +
    kHexBytes[buf[offset + 13]] +
    kHexBytes[buf[offset + 14]] +
    kHexBytes[buf[offset + 15]];
}

function getBufferedUUID () {
  if (!uuidData) uuidData = secureBuffer(16 * kBatchSize);
  if (uuidData === undefined)
    throw new ERR_OPERATION_FAILED('Out of memory');

  if (uuidBatch === 0) randomFillSync(uuidData);
  uuidBatch = (uuidBatch + 1) % kBatchSize;
  return serializeUUID(uuidData, uuidBatch * 16);
}

function getUnbufferedUUID () {
  if (!uuidNotBuffered) uuidNotBuffered = secureBuffer(16 * kBatchSize);
  if (uuidNotBuffered === undefined)
    throw new ERR_OPERATION_FAILED('Out of memory');
  randomFillSync(uuidNotBuffered);
  return serializeUUID(uuidNotBuffered);
}

function randomUUID (options) {
  if (options !== undefined)
    validateObject(options, 'options');
  const {
    disableEntropyCache = false,
  } = options || {};

  validateBoolean(disableEntropyCache, 'options.disableEntropyCache');

  return disableEntropyCache ? getUnbufferedUUID() : getBufferedUUID();
}

module.exports = randomUUID;


/***/ }),

/***/ "../../node_modules/crypto-randomuuid/validators.js":
/*!***************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/crypto-randomuuid/validators.js ***!
  \***************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// Polyfill relevant Node.js core validators and error types

const assert = __webpack_require__(/*! assert */ "assert");
const util = __webpack_require__(/*! util */ "util");

// Sorted by a rough estimate on most frequently used entries.
const kTypes = [
  'string',
  'function',
  'number',
  'object',
  // Accept 'Function' and 'Object' as alternative to the lower cased version.
  'Function',
  'Object',
  'boolean',
  'bigint',
  'symbol',
];

class ERR_OPERATION_FAILED extends TypeError {
  constructor(message) {
    super(`Operation failed: ${message}`);
    this.code = this.constructor.name;

    Object.defineProperties(this, {
      toString: {
        value () {
          return `${this.name} [${this.code}]: ${this.message}`;
        },
        enumerable: false,
        writable: true,
        configurable: true,
      },
    });
  }
}

class ERR_INVALID_ARG_TYPE extends TypeError {
  constructor(name, expected, actual) {
    super();

    assert(typeof name === 'string', "'name' must be a string");
    if (!Array.isArray(expected)) {
      expected = [expected];
    }

    let msg = 'The ';
    if (name.endsWith(' argument')) {
      // For cases like 'first argument'
      msg += `${name} `;
    } else {
      const type = name.includes('.') ? 'property' : 'argument';
      msg += `"${name}" ${type} `;
    }
    msg += 'must be ';

    const types = [];
    const instances = [];
    const other = [];

    for (const value of expected) {
      assert(typeof value === 'string',
        'All expected entries have to be of type string');
      if (kTypes.includes(value)) {
        types.push(value.toLowerCase());
      } else if (classRegExp.test(value)) {
        instances.push(value);
      } else {
        assert(value !== 'object',
          'The value "object" should be written as "Object"');
        other.push(value);
      }
    }

    // Special handle `object` in case other instances are allowed to outline
    // the differences between each other.
    if (instances.length > 0) {
      const pos = types.indexOf('object');
      if (pos !== -1) {
        types.splice(pos, 1);
        instances.push('Object');
      }
    }

    if (types.length > 0) {
      if (types.length > 2) {
        const last = types.pop();
        msg += `one of type ${types.join(', ')}, or ${last}`;
      } else if (types.length === 2) {
        msg += `one of type ${types[0]} or ${types[1]}`;
      } else {
        msg += `of type ${types[0]}`;
      }
      if (instances.length > 0 || other.length > 0)
        msg += ' or ';
    }

    if (instances.length > 0) {
      if (instances.length > 2) {
        const last = instances.pop();
        msg +=
          `an instance of ${instances.join(', ')}, or ${last}`;
      } else {
        msg += `an instance of ${instances[0]}`;
        if (instances.length === 2) {
          msg += ` or ${instances[1]}`;
        }
      }
      if (other.length > 0)
        msg += ' or ';
    }

    if (other.length > 0) {
      if (other.length > 2) {
        const last = other.pop();
        msg += `one of ${other.join(', ')}, or ${last}`;
      } else if (other.length === 2) {
        msg += `one of ${other[0]} or ${other[1]}`;
      } else {
        if (other[0].toLowerCase() !== other[0])
          msg += 'an ';
        msg += `${other[0]}`;
      }
    }

    if (actual == null) {
      msg += `. Received ${actual}`;
    } else if (typeof actual === 'function' && actual.name) {
      msg += `. Received function ${actual.name}`;
    } else if (typeof actual === 'object') {
      if (actual.constructor && actual.constructor.name) {
        msg += `. Received an instance of ${actual.constructor.name}`;
      } else {
        const inspected = util.inspect(actual, { depth: -1 });
        msg += `. Received ${inspected}`;
      }
    } else {
      let inspected = util.inspect(actual, { colors: false });
      if (inspected.length > 25) {
        inspected = `${inspected.slice(0, 25)}...`;
      }
      msg += `. Received type ${typeof actual} (${inspected})`;
    }

    this.code = this.constructor.name;

    Object.defineProperties(this, {
      message: {
        value: msg,
        enumerable: false,
        writable: true,
        configurable: true,
      },
      toString: {
        value() {
          return `${this.name} [${this.code}]: ${this.message}`;
        },
        enumerable: false,
        writable: true,
        configurable: true,
      },
    });
  }
}

function validateBoolean(value, name) {
  if (typeof value !== 'boolean')
    throw new ERR_INVALID_ARG_TYPE(name, 'boolean', value);
}

function validateObject(value, name, {
  nullable = false,
  allowArray = false,
  allowFunction = false,
} = {}) {
  if ((!nullable && value === null) ||
    (!allowArray && Array.isArray(value)) ||
    (typeof value !== 'object' && (
      !allowFunction || typeof value !== 'function'
    ))) {
    throw new ERR_INVALID_ARG_TYPE(name, 'Object', value);
  }
};

module.exports = {
  validateBoolean,
  validateObject,
  codes: {
    ERR_OPERATION_FAILED
  }
};


/***/ }),

/***/ "../../node_modules/dd-trace/ext/exporters.js":
/*!*********************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/ext/exporters.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = {
  LOG: 'log',
  AGENT: 'agent',
  DATADOG: 'datadog'
}


/***/ }),

/***/ "../../node_modules/dd-trace/ext/formats.js":
/*!*******************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/ext/formats.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const opentracing = __webpack_require__(/*! opentracing */ "../../node_modules/opentracing/lib/index.js")

module.exports = {
  TEXT_MAP: opentracing.FORMAT_TEXT_MAP,
  HTTP_HEADERS: opentracing.FORMAT_HTTP_HEADERS,
  BINARY: opentracing.FORMAT_BINARY,
  LOG: 'log'
}


/***/ }),

/***/ "../../node_modules/dd-trace/ext/index.js":
/*!*****************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/ext/index.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const formats = __webpack_require__(/*! ./formats */ "../../node_modules/dd-trace/ext/formats.js")
const kinds = __webpack_require__(/*! ./kinds */ "../../node_modules/dd-trace/ext/kinds.js")
const priority = __webpack_require__(/*! ./priority */ "../../node_modules/dd-trace/ext/priority.js")
const tags = __webpack_require__(/*! ./tags */ "../../node_modules/dd-trace/ext/tags.js")
const types = __webpack_require__(/*! ./types */ "../../node_modules/dd-trace/ext/types.js")
const exporters = __webpack_require__(/*! ./exporters */ "../../node_modules/dd-trace/ext/exporters.js")

module.exports = {
  formats,
  kinds,
  priority,
  tags,
  types,
  exporters
}


/***/ }),

/***/ "../../node_modules/dd-trace/ext/kinds.js":
/*!*****************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/ext/kinds.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = {
  SERVER: 'server',
  CLIENT: 'client',
  PRODUCER: 'producer',
  CONSUMER: 'consumer'
}


/***/ }),

/***/ "../../node_modules/dd-trace/ext/priority.js":
/*!********************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/ext/priority.js ***!
  \********************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = {
  USER_REJECT: -1,
  AUTO_REJECT: 0,
  AUTO_KEEP: 1,
  USER_KEEP: 2
}


/***/ }),

/***/ "../../node_modules/dd-trace/ext/tags.js":
/*!****************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/ext/tags.js ***!
  \****************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const tags = {
  // Common
  SERVICE_NAME: 'service.name',
  RESOURCE_NAME: 'resource.name',
  SPAN_TYPE: 'span.type',
  SPAN_KIND: 'span.kind',
  SAMPLING_PRIORITY: 'sampling.priority',
  ANALYTICS: '_dd1.sr.eausr',
  ERROR: 'error',
  MANUAL_KEEP: 'manual.keep',
  MANUAL_DROP: 'manual.drop',
  MEASURED: '_dd.measured',

  // HTTP
  HTTP_URL: 'http.url',
  HTTP_METHOD: 'http.method',
  HTTP_STATUS_CODE: 'http.status_code',
  HTTP_ROUTE: 'http.route',
  HTTP_REQUEST_HEADERS: 'http.request.headers',
  HTTP_RESPONSE_HEADERS: 'http.response.headers'
}

// Deprecated
tags.ANALYTICS_SAMPLE_RATE = tags.ANALYTICS

module.exports = tags


/***/ }),

/***/ "../../node_modules/dd-trace/ext/types.js":
/*!*****************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/ext/types.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = {
  HTTP: 'http',
  WEB: 'web'
}


/***/ }),

/***/ "../../node_modules/dd-trace/index.js":
/*!*************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/index.js ***!
  \*************************************************************************************/
/*! no static exports found */
/*! exports used: default */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(/*! ./packages/dd-trace */ "../../node_modules/dd-trace/packages/dd-trace/index.js")


/***/ }),

/***/ "../../node_modules/dd-trace/node_modules/ignore/index.js":
/*!*********************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/node_modules/ignore/index.js ***!
  \*********************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports) {

// A simple implementation of make-array
function makeArray (subject) {
  return Array.isArray(subject)
    ? subject
    : [subject]
}

const EMPTY = ''
const SPACE = ' '
const ESCAPE = '\\'
const REGEX_TEST_BLANK_LINE = /^\s+$/
const REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION = /^\\!/
const REGEX_REPLACE_LEADING_EXCAPED_HASH = /^\\#/
const REGEX_SPLITALL_CRLF = /\r?\n/g
// /foo,
// ./foo,
// ../foo,
// .
// ..
const REGEX_TEST_INVALID_PATH = /^\.*\/|^\.+$/

const SLASH = '/'
const KEY_IGNORE = typeof Symbol !== 'undefined'
  ? Symbol.for('node-ignore')
  /* istanbul ignore next */
  : 'node-ignore'

const define = (object, key, value) =>
  Object.defineProperty(object, key, {value})

const REGEX_REGEXP_RANGE = /([0-z])-([0-z])/g

const RETURN_FALSE = () => false

// Sanitize the range of a regular expression
// The cases are complicated, see test cases for details
const sanitizeRange = range => range.replace(
  REGEX_REGEXP_RANGE,
  (match, from, to) => from.charCodeAt(0) <= to.charCodeAt(0)
    ? match
    // Invalid range (out of order) which is ok for gitignore rules but
    //   fatal for JavaScript regular expression, so eliminate it.
    : EMPTY
)

// See fixtures #59
const cleanRangeBackSlash = slashes => {
  const {length} = slashes
  return slashes.slice(0, length - length % 2)
}

// > If the pattern ends with a slash,
// > it is removed for the purpose of the following description,
// > but it would only find a match with a directory.
// > In other words, foo/ will match a directory foo and paths underneath it,
// > but will not match a regular file or a symbolic link foo
// >  (this is consistent with the way how pathspec works in general in Git).
// '`foo/`' will not match regular file '`foo`' or symbolic link '`foo`'
// -> ignore-rules will not deal with it, because it costs extra `fs.stat` call
//      you could use option `mark: true` with `glob`

// '`foo/`' should not continue with the '`..`'
const REPLACERS = [

  // > Trailing spaces are ignored unless they are quoted with backslash ("\")
  [
    // (a\ ) -> (a )
    // (a  ) -> (a)
    // (a \ ) -> (a  )
    /\\?\s+$/,
    match => match.indexOf('\\') === 0
      ? SPACE
      : EMPTY
  ],

  // replace (\ ) with ' '
  [
    /\\\s/g,
    () => SPACE
  ],

  // Escape metacharacters
  // which is written down by users but means special for regular expressions.

  // > There are 12 characters with special meanings:
  // > - the backslash \,
  // > - the caret ^,
  // > - the dollar sign $,
  // > - the period or dot .,
  // > - the vertical bar or pipe symbol |,
  // > - the question mark ?,
  // > - the asterisk or star *,
  // > - the plus sign +,
  // > - the opening parenthesis (,
  // > - the closing parenthesis ),
  // > - and the opening square bracket [,
  // > - the opening curly brace {,
  // > These special characters are often called "metacharacters".
  [
    /[\\$.|*+(){^]/g,
    match => `\\${match}`
  ],

  [
    // > a question mark (?) matches a single character
    /(?!\\)\?/g,
    () => '[^/]'
  ],

  // leading slash
  [

    // > A leading slash matches the beginning of the pathname.
    // > For example, "/*.c" matches "cat-file.c" but not "mozilla-sha1/sha1.c".
    // A leading slash matches the beginning of the pathname
    /^\//,
    () => '^'
  ],

  // replace special metacharacter slash after the leading slash
  [
    /\//g,
    () => '\\/'
  ],

  [
    // > A leading "**" followed by a slash means match in all directories.
    // > For example, "**/foo" matches file or directory "foo" anywhere,
    // > the same as pattern "foo".
    // > "**/foo/bar" matches file or directory "bar" anywhere that is directly
    // >   under directory "foo".
    // Notice that the '*'s have been replaced as '\\*'
    /^\^*\\\*\\\*\\\//,

    // '**/foo' <-> 'foo'
    () => '^(?:.*\\/)?'
  ],

  // starting
  [
    // there will be no leading '/'
    //   (which has been replaced by section "leading slash")
    // If starts with '**', adding a '^' to the regular expression also works
    /^(?=[^^])/,
    function startingReplacer () {
      // If has a slash `/` at the beginning or middle
      return !/\/(?!$)/.test(this)
        // > Prior to 2.22.1
        // > If the pattern does not contain a slash /,
        // >   Git treats it as a shell glob pattern
        // Actually, if there is only a trailing slash,
        //   git also treats it as a shell glob pattern

        // After 2.22.1 (compatible but clearer)
        // > If there is a separator at the beginning or middle (or both)
        // > of the pattern, then the pattern is relative to the directory
        // > level of the particular .gitignore file itself.
        // > Otherwise the pattern may also match at any level below
        // > the .gitignore level.
        ? '(?:^|\\/)'

        // > Otherwise, Git treats the pattern as a shell glob suitable for
        // >   consumption by fnmatch(3)
        : '^'
    }
  ],

  // two globstars
  [
    // Use lookahead assertions so that we could match more than one `'/**'`
    /\\\/\\\*\\\*(?=\\\/|$)/g,

    // Zero, one or several directories
    // should not use '*', or it will be replaced by the next replacer

    // Check if it is not the last `'/**'`
    (_, index, str) => index + 6 < str.length

      // case: /**/
      // > A slash followed by two consecutive asterisks then a slash matches
      // >   zero or more directories.
      // > For example, "a/**/b" matches "a/b", "a/x/b", "a/x/y/b" and so on.
      // '/**/'
      ? '(?:\\/[^\\/]+)*'

      // case: /**
      // > A trailing `"/**"` matches everything inside.

      // #21: everything inside but it should not include the current folder
      : '\\/.+'
  ],

  // intermediate wildcards
  [
    // Never replace escaped '*'
    // ignore rule '\*' will match the path '*'

    // 'abc.*/' -> go
    // 'abc.*'  -> skip this rule
    /(^|[^\\]+)\\\*(?=.+)/g,

    // '*.js' matches '.js'
    // '*.js' doesn't match 'abc'
    (_, p1) => `${p1}[^\\/]*`
  ],

  [
    // unescape, revert step 3 except for back slash
    // For example, if a user escape a '\\*',
    // after step 3, the result will be '\\\\\\*'
    /\\\\\\(?=[$.|*+(){^])/g,
    () => ESCAPE
  ],

  [
    // '\\\\' -> '\\'
    /\\\\/g,
    () => ESCAPE
  ],

  [
    // > The range notation, e.g. [a-zA-Z],
    // > can be used to match one of the characters in a range.

    // `\` is escaped by step 3
    /(\\)?\[([^\]/]*?)(\\*)($|\])/g,
    (match, leadEscape, range, endEscape, close) => leadEscape === ESCAPE
      // '\\[bar]' -> '\\\\[bar\\]'
      ? `\\[${range}${cleanRangeBackSlash(endEscape)}${close}`
      : close === ']'
        ? endEscape.length % 2 === 0
          // A normal case, and it is a range notation
          // '[bar]'
          // '[bar\\\\]'
          ? `[${sanitizeRange(range)}${endEscape}]`
          // Invalid range notaton
          // '[bar\\]' -> '[bar\\\\]'
          : '[]'
        : '[]'
  ],

  // ending
  [
    // 'js' will not match 'js.'
    // 'ab' will not match 'abc'
    /(?:[^*])$/,

    // WTF!
    // https://git-scm.com/docs/gitignore
    // changes in [2.22.1](https://git-scm.com/docs/gitignore/2.22.1)
    // which re-fixes #24, #38

    // > If there is a separator at the end of the pattern then the pattern
    // > will only match directories, otherwise the pattern can match both
    // > files and directories.

    // 'js*' will not match 'a.js'
    // 'js/' will not match 'a.js'
    // 'js' will match 'a.js' and 'a.js/'
    match => /\/$/.test(match)
      // foo/ will not match 'foo'
      ? `${match}$`
      // foo matches 'foo' and 'foo/'
      : `${match}(?=$|\\/$)`
  ],

  // trailing wildcard
  [
    /(\^|\\\/)?\\\*$/,
    (_, p1) => {
      const prefix = p1
        // '\^':
        // '/*' does not match EMPTY
        // '/*' does not match everything

        // '\\\/':
        // 'abc/*' does not match 'abc/'
        ? `${p1}[^/]+`

        // 'a*' matches 'a'
        // 'a*' matches 'aa'
        : '[^/]*'

      return `${prefix}(?=$|\\/$)`
    }
  ],
]

// A simple cache, because an ignore rule only has only one certain meaning
const regexCache = Object.create(null)

// @param {pattern}
const makeRegex = (pattern, ignoreCase) => {
  let source = regexCache[pattern]

  if (!source) {
    source = REPLACERS.reduce(
      (prev, current) => prev.replace(current[0], current[1].bind(pattern)),
      pattern
    )
    regexCache[pattern] = source
  }

  return ignoreCase
    ? new RegExp(source, 'i')
    : new RegExp(source)
}

const isString = subject => typeof subject === 'string'

// > A blank line matches no files, so it can serve as a separator for readability.
const checkPattern = pattern => pattern
  && isString(pattern)
  && !REGEX_TEST_BLANK_LINE.test(pattern)

  // > A line starting with # serves as a comment.
  && pattern.indexOf('#') !== 0

const splitPattern = pattern => pattern.split(REGEX_SPLITALL_CRLF)

class IgnoreRule {
  constructor (
    origin,
    pattern,
    negative,
    regex
  ) {
    this.origin = origin
    this.pattern = pattern
    this.negative = negative
    this.regex = regex
  }
}

const createRule = (pattern, ignoreCase) => {
  const origin = pattern
  let negative = false

  // > An optional prefix "!" which negates the pattern;
  if (pattern.indexOf('!') === 0) {
    negative = true
    pattern = pattern.substr(1)
  }

  pattern = pattern
  // > Put a backslash ("\") in front of the first "!" for patterns that
  // >   begin with a literal "!", for example, `"\!important!.txt"`.
  .replace(REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION, '!')
  // > Put a backslash ("\") in front of the first hash for patterns that
  // >   begin with a hash.
  .replace(REGEX_REPLACE_LEADING_EXCAPED_HASH, '#')

  const regex = makeRegex(pattern, ignoreCase)

  return new IgnoreRule(
    origin,
    pattern,
    negative,
    regex
  )
}

const throwError = (message, Ctor) => {
  throw new Ctor(message)
}

const checkPath = (path, originalPath, doThrow) => {
  if (!isString(path)) {
    return doThrow(
      `path must be a string, but got \`${originalPath}\``,
      TypeError
    )
  }

  // We don't know if we should ignore EMPTY, so throw
  if (!path) {
    return doThrow(`path must not be empty`, TypeError)
  }

  // Check if it is a relative path
  if (checkPath.isNotRelative(path)) {
    const r = '`path.relative()`d'
    return doThrow(
      `path should be a ${r} string, but got "${originalPath}"`,
      RangeError
    )
  }

  return true
}

const isNotRelative = path => REGEX_TEST_INVALID_PATH.test(path)

checkPath.isNotRelative = isNotRelative
checkPath.convert = p => p

class Ignore {
  constructor ({
    ignorecase = true,
    ignoreCase = ignorecase,
    allowRelativePaths = false
  } = {}) {
    define(this, KEY_IGNORE, true)

    this._rules = []
    this._ignoreCase = ignoreCase
    this._allowRelativePaths = allowRelativePaths
    this._initCache()
  }

  _initCache () {
    this._ignoreCache = Object.create(null)
    this._testCache = Object.create(null)
  }

  _addPattern (pattern) {
    // #32
    if (pattern && pattern[KEY_IGNORE]) {
      this._rules = this._rules.concat(pattern._rules)
      this._added = true
      return
    }

    if (checkPattern(pattern)) {
      const rule = createRule(pattern, this._ignoreCase)
      this._added = true
      this._rules.push(rule)
    }
  }

  // @param {Array<string> | string | Ignore} pattern
  add (pattern) {
    this._added = false

    makeArray(
      isString(pattern)
        ? splitPattern(pattern)
        : pattern
    ).forEach(this._addPattern, this)

    // Some rules have just added to the ignore,
    // making the behavior changed.
    if (this._added) {
      this._initCache()
    }

    return this
  }

  // legacy
  addPattern (pattern) {
    return this.add(pattern)
  }

  //          |           ignored : unignored
  // negative |   0:0   |   0:1   |   1:0   |   1:1
  // -------- | ------- | ------- | ------- | --------
  //     0    |  TEST   |  TEST   |  SKIP   |    X
  //     1    |  TESTIF |  SKIP   |  TEST   |    X

  // - SKIP: always skip
  // - TEST: always test
  // - TESTIF: only test if checkUnignored
  // - X: that never happen

  // @param {boolean} whether should check if the path is unignored,
  //   setting `checkUnignored` to `false` could reduce additional
  //   path matching.

  // @returns {TestResult} true if a file is ignored
  _testOne (path, checkUnignored) {
    let ignored = false
    let unignored = false

    this._rules.forEach(rule => {
      const {negative} = rule
      if (
        unignored === negative && ignored !== unignored
        || negative && !ignored && !unignored && !checkUnignored
      ) {
        return
      }

      const matched = rule.regex.test(path)

      if (matched) {
        ignored = !negative
        unignored = negative
      }
    })

    return {
      ignored,
      unignored
    }
  }

  // @returns {TestResult}
  _test (originalPath, cache, checkUnignored, slices) {
    const path = originalPath
      // Supports nullable path
      && checkPath.convert(originalPath)

    checkPath(
      path,
      originalPath,
      this._allowRelativePaths
        ? RETURN_FALSE
        : throwError
    )

    return this._t(path, cache, checkUnignored, slices)
  }

  _t (path, cache, checkUnignored, slices) {
    if (path in cache) {
      return cache[path]
    }

    if (!slices) {
      // path/to/a.js
      // ['path', 'to', 'a.js']
      slices = path.split(SLASH)
    }

    slices.pop()

    // If the path has no parent directory, just test it
    if (!slices.length) {
      return cache[path] = this._testOne(path, checkUnignored)
    }

    const parent = this._t(
      slices.join(SLASH) + SLASH,
      cache,
      checkUnignored,
      slices
    )

    // If the path contains a parent directory, check the parent first
    return cache[path] = parent.ignored
      // > It is not possible to re-include a file if a parent directory of
      // >   that file is excluded.
      ? parent
      : this._testOne(path, checkUnignored)
  }

  ignores (path) {
    return this._test(path, this._ignoreCache, false).ignored
  }

  createFilter () {
    return path => !this.ignores(path)
  }

  filter (paths) {
    return makeArray(paths).filter(this.createFilter())
  }

  // @returns {TestResult}
  test (path) {
    return this._test(path, this._testCache, true)
  }
}

const factory = options => new Ignore(options)

const isPathValid = path =>
  checkPath(path && checkPath.convert(path), path, RETURN_FALSE)

factory.isPathValid = isPathValid

// Fixes typescript
factory.default = factory

module.exports = factory

// Windows
// --------------------------------------------------------------
/* istanbul ignore if  */
if (
  // Detect `process` so that it can run in browsers.
  typeof process !== 'undefined'
  && (
    process.env && process.env.IGNORE_TEST_WIN32
    || process.platform === 'win32'
  )
) {
  /* eslint no-control-regex: "off" */
  const makePosix = str => /^\\\\\?\\/.test(str)
  || /["<>|\u0000-\u001F]+/u.test(str)
    ? str
    : str.replace(/\\/g, '/')

  checkPath.convert = makePosix

  // 'C:\\foo'     <- 'C:\\foo' has been converted to 'C:/'
  // 'd:\\foo'
  const REGIX_IS_WINDOWS_PATH_ABSOLUTE = /^[a-z]:\//i
  checkPath.isNotRelative = path =>
    REGIX_IS_WINDOWS_PATH_ABSOLUTE.test(path)
    || isNotRelative(path)
}


/***/ }),

/***/ "../../node_modules/dd-trace/node_modules/retry/index.js":
/*!********************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/node_modules/retry/index.js ***!
  \********************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./lib/retry */ "../../node_modules/dd-trace/node_modules/retry/lib/retry.js");

/***/ }),

/***/ "../../node_modules/dd-trace/node_modules/retry/lib/retry.js":
/*!************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/node_modules/retry/lib/retry.js ***!
  \************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var RetryOperation = __webpack_require__(/*! ./retry_operation */ "../../node_modules/dd-trace/node_modules/retry/lib/retry_operation.js");

exports.operation = function(options) {
  var timeouts = exports.timeouts(options);
  return new RetryOperation(timeouts, {
      forever: options && options.forever,
      unref: options && options.unref
  });
};

exports.timeouts = function(options) {
  if (options instanceof Array) {
    return [].concat(options);
  }

  var opts = {
    retries: 10,
    factor: 2,
    minTimeout: 1 * 1000,
    maxTimeout: Infinity,
    randomize: false
  };
  for (var key in options) {
    opts[key] = options[key];
  }

  if (opts.minTimeout > opts.maxTimeout) {
    throw new Error('minTimeout is greater than maxTimeout');
  }

  var timeouts = [];
  for (var i = 0; i < opts.retries; i++) {
    timeouts.push(this.createTimeout(i, opts));
  }

  if (options && options.forever && !timeouts.length) {
    timeouts.push(this.createTimeout(i, opts));
  }

  // sort the array numerically ascending
  timeouts.sort(function(a,b) {
    return a - b;
  });

  return timeouts;
};

exports.createTimeout = function(attempt, opts) {
  var random = (opts.randomize)
    ? (Math.random() + 1)
    : 1;

  var timeout = Math.round(random * opts.minTimeout * Math.pow(opts.factor, attempt));
  timeout = Math.min(timeout, opts.maxTimeout);

  return timeout;
};

exports.wrap = function(obj, options, methods) {
  if (options instanceof Array) {
    methods = options;
    options = null;
  }

  if (!methods) {
    methods = [];
    for (var key in obj) {
      if (typeof obj[key] === 'function') {
        methods.push(key);
      }
    }
  }

  for (var i = 0; i < methods.length; i++) {
    var method   = methods[i];
    var original = obj[method];

    obj[method] = function retryWrapper() {
      var op       = exports.operation(options);
      var args     = Array.prototype.slice.call(arguments);
      var callback = args.pop();

      args.push(function(err) {
        if (op.retry(err)) {
          return;
        }
        if (err) {
          arguments[0] = op.mainError();
        }
        callback.apply(this, arguments);
      });

      op.attempt(function() {
        original.apply(obj, args);
      });
    };
    obj[method].options = options;
  }
};


/***/ }),

/***/ "../../node_modules/dd-trace/node_modules/retry/lib/retry_operation.js":
/*!**********************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/node_modules/retry/lib/retry_operation.js ***!
  \**********************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports) {

function RetryOperation(timeouts, options) {
  // Compatibility for the old (timeouts, retryForever) signature
  if (typeof options === 'boolean') {
    options = { forever: options };
  }

  this._timeouts = timeouts;
  this._options = options || {};
  this._fn = null;
  this._errors = [];
  this._attempts = 1;
  this._operationTimeout = null;
  this._operationTimeoutCb = null;
  this._timeout = null;

  if (this._options.forever) {
    this._cachedTimeouts = this._timeouts.slice(0);
  }
}
module.exports = RetryOperation;

RetryOperation.prototype.stop = function() {
  if (this._timeout) {
    clearTimeout(this._timeout);
  }

  this._timeouts       = [];
  this._cachedTimeouts = null;
};

RetryOperation.prototype.retry = function(err) {
  if (this._timeout) {
    clearTimeout(this._timeout);
  }

  if (!err) {
    return false;
  }

  this._errors.push(err);

  var timeout = this._timeouts.shift();
  if (timeout === undefined) {
    if (this._cachedTimeouts) {
      // retry forever, only keep last error
      this._errors.splice(this._errors.length - 1, this._errors.length);
      this._timeouts = this._cachedTimeouts.slice(0);
      timeout = this._timeouts.shift();
    } else {
      return false;
    }
  }

  var self = this;
  var timer = setTimeout(function() {
    self._attempts++;

    if (self._operationTimeoutCb) {
      self._timeout = setTimeout(function() {
        self._operationTimeoutCb(self._attempts);
      }, self._operationTimeout);

      if (this._options.unref) {
          self._timeout.unref();
      }
    }

    self._fn(self._attempts);
  }, timeout);

  if (this._options.unref) {
      timer.unref();
  }

  return true;
};

RetryOperation.prototype.attempt = function(fn, timeoutOps) {
  this._fn = fn;

  if (timeoutOps) {
    if (timeoutOps.timeout) {
      this._operationTimeout = timeoutOps.timeout;
    }
    if (timeoutOps.cb) {
      this._operationTimeoutCb = timeoutOps.cb;
    }
  }

  var self = this;
  if (this._operationTimeoutCb) {
    this._timeout = setTimeout(function() {
      self._operationTimeoutCb();
    }, self._operationTimeout);
  }

  this._fn(this._attempts);
};

RetryOperation.prototype.try = function(fn) {
  console.log('Using RetryOperation.try() is deprecated');
  this.attempt(fn);
};

RetryOperation.prototype.start = function(fn) {
  console.log('Using RetryOperation.start() is deprecated');
  this.attempt(fn);
};

RetryOperation.prototype.start = RetryOperation.prototype.try;

RetryOperation.prototype.errors = function() {
  return this._errors;
};

RetryOperation.prototype.attempts = function() {
  return this._attempts;
};

RetryOperation.prototype.mainError = function() {
  if (this._errors.length === 0) {
    return null;
  }

  var counts = {};
  var mainError = null;
  var mainErrorCount = 0;

  for (var i = 0; i < this._errors.length; i++) {
    var error = this._errors[i];
    var message = error.message;
    var count = (counts[message] || 0) + 1;

    counts[message] = count;

    if (count >= mainErrorCount) {
      mainError = error;
      mainErrorCount = count;
    }
  }

  return mainError;
};


/***/ }),

/***/ "../../node_modules/dd-trace/node_modules/semver/semver.js":
/*!**********************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/node_modules/semver/semver.js ***!
  \**********************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports) {

exports = module.exports = SemVer

var debug
/* istanbul ignore next */
if (typeof process === 'object' &&
    process.env &&
    process.env.NODE_DEBUG &&
    /\bsemver\b/i.test(process.env.NODE_DEBUG)) {
  debug = function () {
    var args = Array.prototype.slice.call(arguments, 0)
    args.unshift('SEMVER')
    console.log.apply(console, args)
  }
} else {
  debug = function () {}
}

// Note: this is the semver.org version of the spec that it implements
// Not necessarily the package version of this code.
exports.SEMVER_SPEC_VERSION = '2.0.0'

var MAX_LENGTH = 256
var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER ||
  /* istanbul ignore next */ 9007199254740991

// Max safe segment length for coercion.
var MAX_SAFE_COMPONENT_LENGTH = 16

// The actual regexps go on exports.re
var re = exports.re = []
var src = exports.src = []
var R = 0

// The following Regular Expressions can be used for tokenizing,
// validating, and parsing SemVer version strings.

// ## Numeric Identifier
// A single `0`, or a non-zero digit followed by zero or more digits.

var NUMERICIDENTIFIER = R++
src[NUMERICIDENTIFIER] = '0|[1-9]\\d*'
var NUMERICIDENTIFIERLOOSE = R++
src[NUMERICIDENTIFIERLOOSE] = '[0-9]+'

// ## Non-numeric Identifier
// Zero or more digits, followed by a letter or hyphen, and then zero or
// more letters, digits, or hyphens.

var NONNUMERICIDENTIFIER = R++
src[NONNUMERICIDENTIFIER] = '\\d*[a-zA-Z-][a-zA-Z0-9-]*'

// ## Main Version
// Three dot-separated numeric identifiers.

var MAINVERSION = R++
src[MAINVERSION] = '(' + src[NUMERICIDENTIFIER] + ')\\.' +
                   '(' + src[NUMERICIDENTIFIER] + ')\\.' +
                   '(' + src[NUMERICIDENTIFIER] + ')'

var MAINVERSIONLOOSE = R++
src[MAINVERSIONLOOSE] = '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\.' +
                        '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\.' +
                        '(' + src[NUMERICIDENTIFIERLOOSE] + ')'

// ## Pre-release Version Identifier
// A numeric identifier, or a non-numeric identifier.

var PRERELEASEIDENTIFIER = R++
src[PRERELEASEIDENTIFIER] = '(?:' + src[NUMERICIDENTIFIER] +
                            '|' + src[NONNUMERICIDENTIFIER] + ')'

var PRERELEASEIDENTIFIERLOOSE = R++
src[PRERELEASEIDENTIFIERLOOSE] = '(?:' + src[NUMERICIDENTIFIERLOOSE] +
                                 '|' + src[NONNUMERICIDENTIFIER] + ')'

// ## Pre-release Version
// Hyphen, followed by one or more dot-separated pre-release version
// identifiers.

var PRERELEASE = R++
src[PRERELEASE] = '(?:-(' + src[PRERELEASEIDENTIFIER] +
                  '(?:\\.' + src[PRERELEASEIDENTIFIER] + ')*))'

var PRERELEASELOOSE = R++
src[PRERELEASELOOSE] = '(?:-?(' + src[PRERELEASEIDENTIFIERLOOSE] +
                       '(?:\\.' + src[PRERELEASEIDENTIFIERLOOSE] + ')*))'

// ## Build Metadata Identifier
// Any combination of digits, letters, or hyphens.

var BUILDIDENTIFIER = R++
src[BUILDIDENTIFIER] = '[0-9A-Za-z-]+'

// ## Build Metadata
// Plus sign, followed by one or more period-separated build metadata
// identifiers.

var BUILD = R++
src[BUILD] = '(?:\\+(' + src[BUILDIDENTIFIER] +
             '(?:\\.' + src[BUILDIDENTIFIER] + ')*))'

// ## Full Version String
// A main version, followed optionally by a pre-release version and
// build metadata.

// Note that the only major, minor, patch, and pre-release sections of
// the version string are capturing groups.  The build metadata is not a
// capturing group, because it should not ever be used in version
// comparison.

var FULL = R++
var FULLPLAIN = 'v?' + src[MAINVERSION] +
                src[PRERELEASE] + '?' +
                src[BUILD] + '?'

src[FULL] = '^' + FULLPLAIN + '$'

// like full, but allows v1.2.3 and =1.2.3, which people do sometimes.
// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty
// common in the npm registry.
var LOOSEPLAIN = '[v=\\s]*' + src[MAINVERSIONLOOSE] +
                 src[PRERELEASELOOSE] + '?' +
                 src[BUILD] + '?'

var LOOSE = R++
src[LOOSE] = '^' + LOOSEPLAIN + '$'

var GTLT = R++
src[GTLT] = '((?:<|>)?=?)'

// Something like "2.*" or "1.2.x".
// Note that "x.x" is a valid xRange identifer, meaning "any version"
// Only the first item is strictly required.
var XRANGEIDENTIFIERLOOSE = R++
src[XRANGEIDENTIFIERLOOSE] = src[NUMERICIDENTIFIERLOOSE] + '|x|X|\\*'
var XRANGEIDENTIFIER = R++
src[XRANGEIDENTIFIER] = src[NUMERICIDENTIFIER] + '|x|X|\\*'

var XRANGEPLAIN = R++
src[XRANGEPLAIN] = '[v=\\s]*(' + src[XRANGEIDENTIFIER] + ')' +
                   '(?:\\.(' + src[XRANGEIDENTIFIER] + ')' +
                   '(?:\\.(' + src[XRANGEIDENTIFIER] + ')' +
                   '(?:' + src[PRERELEASE] + ')?' +
                   src[BUILD] + '?' +
                   ')?)?'

var XRANGEPLAINLOOSE = R++
src[XRANGEPLAINLOOSE] = '[v=\\s]*(' + src[XRANGEIDENTIFIERLOOSE] + ')' +
                        '(?:\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' +
                        '(?:\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' +
                        '(?:' + src[PRERELEASELOOSE] + ')?' +
                        src[BUILD] + '?' +
                        ')?)?'

var XRANGE = R++
src[XRANGE] = '^' + src[GTLT] + '\\s*' + src[XRANGEPLAIN] + '$'
var XRANGELOOSE = R++
src[XRANGELOOSE] = '^' + src[GTLT] + '\\s*' + src[XRANGEPLAINLOOSE] + '$'

// Coercion.
// Extract anything that could conceivably be a part of a valid semver
var COERCE = R++
src[COERCE] = '(?:^|[^\\d])' +
              '(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '})' +
              '(?:\\.(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' +
              '(?:\\.(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' +
              '(?:$|[^\\d])'

// Tilde ranges.
// Meaning is "reasonably at or greater than"
var LONETILDE = R++
src[LONETILDE] = '(?:~>?)'

var TILDETRIM = R++
src[TILDETRIM] = '(\\s*)' + src[LONETILDE] + '\\s+'
re[TILDETRIM] = new RegExp(src[TILDETRIM], 'g')
var tildeTrimReplace = '$1~'

var TILDE = R++
src[TILDE] = '^' + src[LONETILDE] + src[XRANGEPLAIN] + '$'
var TILDELOOSE = R++
src[TILDELOOSE] = '^' + src[LONETILDE] + src[XRANGEPLAINLOOSE] + '$'

// Caret ranges.
// Meaning is "at least and backwards compatible with"
var LONECARET = R++
src[LONECARET] = '(?:\\^)'

var CARETTRIM = R++
src[CARETTRIM] = '(\\s*)' + src[LONECARET] + '\\s+'
re[CARETTRIM] = new RegExp(src[CARETTRIM], 'g')
var caretTrimReplace = '$1^'

var CARET = R++
src[CARET] = '^' + src[LONECARET] + src[XRANGEPLAIN] + '$'
var CARETLOOSE = R++
src[CARETLOOSE] = '^' + src[LONECARET] + src[XRANGEPLAINLOOSE] + '$'

// A simple gt/lt/eq thing, or just "" to indicate "any version"
var COMPARATORLOOSE = R++
src[COMPARATORLOOSE] = '^' + src[GTLT] + '\\s*(' + LOOSEPLAIN + ')$|^$'
var COMPARATOR = R++
src[COMPARATOR] = '^' + src[GTLT] + '\\s*(' + FULLPLAIN + ')$|^$'

// An expression to strip any whitespace between the gtlt and the thing
// it modifies, so that `> 1.2.3` ==> `>1.2.3`
var COMPARATORTRIM = R++
src[COMPARATORTRIM] = '(\\s*)' + src[GTLT] +
                      '\\s*(' + LOOSEPLAIN + '|' + src[XRANGEPLAIN] + ')'

// this one has to use the /g flag
re[COMPARATORTRIM] = new RegExp(src[COMPARATORTRIM], 'g')
var comparatorTrimReplace = '$1$2$3'

// Something like `1.2.3 - 1.2.4`
// Note that these all use the loose form, because they'll be
// checked against either the strict or loose comparator form
// later.
var HYPHENRANGE = R++
src[HYPHENRANGE] = '^\\s*(' + src[XRANGEPLAIN] + ')' +
                   '\\s+-\\s+' +
                   '(' + src[XRANGEPLAIN] + ')' +
                   '\\s*$'

var HYPHENRANGELOOSE = R++
src[HYPHENRANGELOOSE] = '^\\s*(' + src[XRANGEPLAINLOOSE] + ')' +
                        '\\s+-\\s+' +
                        '(' + src[XRANGEPLAINLOOSE] + ')' +
                        '\\s*$'

// Star ranges basically just allow anything at all.
var STAR = R++
src[STAR] = '(<|>)?=?\\s*\\*'

// Compile to actual regexp objects.
// All are flag-free, unless they were created above with a flag.
for (var i = 0; i < R; i++) {
  debug(i, src[i])
  if (!re[i]) {
    re[i] = new RegExp(src[i])
  }
}

exports.parse = parse
function parse (version, options) {
  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    }
  }

  if (version instanceof SemVer) {
    return version
  }

  if (typeof version !== 'string') {
    return null
  }

  if (version.length > MAX_LENGTH) {
    return null
  }

  var r = options.loose ? re[LOOSE] : re[FULL]
  if (!r.test(version)) {
    return null
  }

  try {
    return new SemVer(version, options)
  } catch (er) {
    return null
  }
}

exports.valid = valid
function valid (version, options) {
  var v = parse(version, options)
  return v ? v.version : null
}

exports.clean = clean
function clean (version, options) {
  var s = parse(version.trim().replace(/^[=v]+/, ''), options)
  return s ? s.version : null
}

exports.SemVer = SemVer

function SemVer (version, options) {
  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    }
  }
  if (version instanceof SemVer) {
    if (version.loose === options.loose) {
      return version
    } else {
      version = version.version
    }
  } else if (typeof version !== 'string') {
    throw new TypeError('Invalid Version: ' + version)
  }

  if (version.length > MAX_LENGTH) {
    throw new TypeError('version is longer than ' + MAX_LENGTH + ' characters')
  }

  if (!(this instanceof SemVer)) {
    return new SemVer(version, options)
  }

  debug('SemVer', version, options)
  this.options = options
  this.loose = !!options.loose

  var m = version.trim().match(options.loose ? re[LOOSE] : re[FULL])

  if (!m) {
    throw new TypeError('Invalid Version: ' + version)
  }

  this.raw = version

  // these are actually numbers
  this.major = +m[1]
  this.minor = +m[2]
  this.patch = +m[3]

  if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
    throw new TypeError('Invalid major version')
  }

  if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
    throw new TypeError('Invalid minor version')
  }

  if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
    throw new TypeError('Invalid patch version')
  }

  // numberify any prerelease numeric ids
  if (!m[4]) {
    this.prerelease = []
  } else {
    this.prerelease = m[4].split('.').map(function (id) {
      if (/^[0-9]+$/.test(id)) {
        var num = +id
        if (num >= 0 && num < MAX_SAFE_INTEGER) {
          return num
        }
      }
      return id
    })
  }

  this.build = m[5] ? m[5].split('.') : []
  this.format()
}

SemVer.prototype.format = function () {
  this.version = this.major + '.' + this.minor + '.' + this.patch
  if (this.prerelease.length) {
    this.version += '-' + this.prerelease.join('.')
  }
  return this.version
}

SemVer.prototype.toString = function () {
  return this.version
}

SemVer.prototype.compare = function (other) {
  debug('SemVer.compare', this.version, this.options, other)
  if (!(other instanceof SemVer)) {
    other = new SemVer(other, this.options)
  }

  return this.compareMain(other) || this.comparePre(other)
}

SemVer.prototype.compareMain = function (other) {
  if (!(other instanceof SemVer)) {
    other = new SemVer(other, this.options)
  }

  return compareIdentifiers(this.major, other.major) ||
         compareIdentifiers(this.minor, other.minor) ||
         compareIdentifiers(this.patch, other.patch)
}

SemVer.prototype.comparePre = function (other) {
  if (!(other instanceof SemVer)) {
    other = new SemVer(other, this.options)
  }

  // NOT having a prerelease is > having one
  if (this.prerelease.length && !other.prerelease.length) {
    return -1
  } else if (!this.prerelease.length && other.prerelease.length) {
    return 1
  } else if (!this.prerelease.length && !other.prerelease.length) {
    return 0
  }

  var i = 0
  do {
    var a = this.prerelease[i]
    var b = other.prerelease[i]
    debug('prerelease compare', i, a, b)
    if (a === undefined && b === undefined) {
      return 0
    } else if (b === undefined) {
      return 1
    } else if (a === undefined) {
      return -1
    } else if (a === b) {
      continue
    } else {
      return compareIdentifiers(a, b)
    }
  } while (++i)
}

// preminor will bump the version up to the next minor release, and immediately
// down to pre-release. premajor and prepatch work the same way.
SemVer.prototype.inc = function (release, identifier) {
  switch (release) {
    case 'premajor':
      this.prerelease.length = 0
      this.patch = 0
      this.minor = 0
      this.major++
      this.inc('pre', identifier)
      break
    case 'preminor':
      this.prerelease.length = 0
      this.patch = 0
      this.minor++
      this.inc('pre', identifier)
      break
    case 'prepatch':
      // If this is already a prerelease, it will bump to the next version
      // drop any prereleases that might already exist, since they are not
      // relevant at this point.
      this.prerelease.length = 0
      this.inc('patch', identifier)
      this.inc('pre', identifier)
      break
    // If the input is a non-prerelease version, this acts the same as
    // prepatch.
    case 'prerelease':
      if (this.prerelease.length === 0) {
        this.inc('patch', identifier)
      }
      this.inc('pre', identifier)
      break

    case 'major':
      // If this is a pre-major version, bump up to the same major version.
      // Otherwise increment major.
      // 1.0.0-5 bumps to 1.0.0
      // 1.1.0 bumps to 2.0.0
      if (this.minor !== 0 ||
          this.patch !== 0 ||
          this.prerelease.length === 0) {
        this.major++
      }
      this.minor = 0
      this.patch = 0
      this.prerelease = []
      break
    case 'minor':
      // If this is a pre-minor version, bump up to the same minor version.
      // Otherwise increment minor.
      // 1.2.0-5 bumps to 1.2.0
      // 1.2.1 bumps to 1.3.0
      if (this.patch !== 0 || this.prerelease.length === 0) {
        this.minor++
      }
      this.patch = 0
      this.prerelease = []
      break
    case 'patch':
      // If this is not a pre-release version, it will increment the patch.
      // If it is a pre-release it will bump up to the same patch version.
      // 1.2.0-5 patches to 1.2.0
      // 1.2.0 patches to 1.2.1
      if (this.prerelease.length === 0) {
        this.patch++
      }
      this.prerelease = []
      break
    // This probably shouldn't be used publicly.
    // 1.0.0 "pre" would become 1.0.0-0 which is the wrong direction.
    case 'pre':
      if (this.prerelease.length === 0) {
        this.prerelease = [0]
      } else {
        var i = this.prerelease.length
        while (--i >= 0) {
          if (typeof this.prerelease[i] === 'number') {
            this.prerelease[i]++
            i = -2
          }
        }
        if (i === -1) {
          // didn't increment anything
          this.prerelease.push(0)
        }
      }
      if (identifier) {
        // 1.2.0-beta.1 bumps to 1.2.0-beta.2,
        // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0
        if (this.prerelease[0] === identifier) {
          if (isNaN(this.prerelease[1])) {
            this.prerelease = [identifier, 0]
          }
        } else {
          this.prerelease = [identifier, 0]
        }
      }
      break

    default:
      throw new Error('invalid increment argument: ' + release)
  }
  this.format()
  this.raw = this.version
  return this
}

exports.inc = inc
function inc (version, release, loose, identifier) {
  if (typeof (loose) === 'string') {
    identifier = loose
    loose = undefined
  }

  try {
    return new SemVer(version, loose).inc(release, identifier).version
  } catch (er) {
    return null
  }
}

exports.diff = diff
function diff (version1, version2) {
  if (eq(version1, version2)) {
    return null
  } else {
    var v1 = parse(version1)
    var v2 = parse(version2)
    var prefix = ''
    if (v1.prerelease.length || v2.prerelease.length) {
      prefix = 'pre'
      var defaultResult = 'prerelease'
    }
    for (var key in v1) {
      if (key === 'major' || key === 'minor' || key === 'patch') {
        if (v1[key] !== v2[key]) {
          return prefix + key
        }
      }
    }
    return defaultResult // may be undefined
  }
}

exports.compareIdentifiers = compareIdentifiers

var numeric = /^[0-9]+$/
function compareIdentifiers (a, b) {
  var anum = numeric.test(a)
  var bnum = numeric.test(b)

  if (anum && bnum) {
    a = +a
    b = +b
  }

  return a === b ? 0
    : (anum && !bnum) ? -1
    : (bnum && !anum) ? 1
    : a < b ? -1
    : 1
}

exports.rcompareIdentifiers = rcompareIdentifiers
function rcompareIdentifiers (a, b) {
  return compareIdentifiers(b, a)
}

exports.major = major
function major (a, loose) {
  return new SemVer(a, loose).major
}

exports.minor = minor
function minor (a, loose) {
  return new SemVer(a, loose).minor
}

exports.patch = patch
function patch (a, loose) {
  return new SemVer(a, loose).patch
}

exports.compare = compare
function compare (a, b, loose) {
  return new SemVer(a, loose).compare(new SemVer(b, loose))
}

exports.compareLoose = compareLoose
function compareLoose (a, b) {
  return compare(a, b, true)
}

exports.rcompare = rcompare
function rcompare (a, b, loose) {
  return compare(b, a, loose)
}

exports.sort = sort
function sort (list, loose) {
  return list.sort(function (a, b) {
    return exports.compare(a, b, loose)
  })
}

exports.rsort = rsort
function rsort (list, loose) {
  return list.sort(function (a, b) {
    return exports.rcompare(a, b, loose)
  })
}

exports.gt = gt
function gt (a, b, loose) {
  return compare(a, b, loose) > 0
}

exports.lt = lt
function lt (a, b, loose) {
  return compare(a, b, loose) < 0
}

exports.eq = eq
function eq (a, b, loose) {
  return compare(a, b, loose) === 0
}

exports.neq = neq
function neq (a, b, loose) {
  return compare(a, b, loose) !== 0
}

exports.gte = gte
function gte (a, b, loose) {
  return compare(a, b, loose) >= 0
}

exports.lte = lte
function lte (a, b, loose) {
  return compare(a, b, loose) <= 0
}

exports.cmp = cmp
function cmp (a, op, b, loose) {
  switch (op) {
    case '===':
      if (typeof a === 'object')
        a = a.version
      if (typeof b === 'object')
        b = b.version
      return a === b

    case '!==':
      if (typeof a === 'object')
        a = a.version
      if (typeof b === 'object')
        b = b.version
      return a !== b

    case '':
    case '=':
    case '==':
      return eq(a, b, loose)

    case '!=':
      return neq(a, b, loose)

    case '>':
      return gt(a, b, loose)

    case '>=':
      return gte(a, b, loose)

    case '<':
      return lt(a, b, loose)

    case '<=':
      return lte(a, b, loose)

    default:
      throw new TypeError('Invalid operator: ' + op)
  }
}

exports.Comparator = Comparator
function Comparator (comp, options) {
  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    }
  }

  if (comp instanceof Comparator) {
    if (comp.loose === !!options.loose) {
      return comp
    } else {
      comp = comp.value
    }
  }

  if (!(this instanceof Comparator)) {
    return new Comparator(comp, options)
  }

  debug('comparator', comp, options)
  this.options = options
  this.loose = !!options.loose
  this.parse(comp)

  if (this.semver === ANY) {
    this.value = ''
  } else {
    this.value = this.operator + this.semver.version
  }

  debug('comp', this)
}

var ANY = {}
Comparator.prototype.parse = function (comp) {
  var r = this.options.loose ? re[COMPARATORLOOSE] : re[COMPARATOR]
  var m = comp.match(r)

  if (!m) {
    throw new TypeError('Invalid comparator: ' + comp)
  }

  this.operator = m[1]
  if (this.operator === '=') {
    this.operator = ''
  }

  // if it literally is just '>' or '' then allow anything.
  if (!m[2]) {
    this.semver = ANY
  } else {
    this.semver = new SemVer(m[2], this.options.loose)
  }
}

Comparator.prototype.toString = function () {
  return this.value
}

Comparator.prototype.test = function (version) {
  debug('Comparator.test', version, this.options.loose)

  if (this.semver === ANY) {
    return true
  }

  if (typeof version === 'string') {
    version = new SemVer(version, this.options)
  }

  return cmp(version, this.operator, this.semver, this.options)
}

Comparator.prototype.intersects = function (comp, options) {
  if (!(comp instanceof Comparator)) {
    throw new TypeError('a Comparator is required')
  }

  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    }
  }

  var rangeTmp

  if (this.operator === '') {
    rangeTmp = new Range(comp.value, options)
    return satisfies(this.value, rangeTmp, options)
  } else if (comp.operator === '') {
    rangeTmp = new Range(this.value, options)
    return satisfies(comp.semver, rangeTmp, options)
  }

  var sameDirectionIncreasing =
    (this.operator === '>=' || this.operator === '>') &&
    (comp.operator === '>=' || comp.operator === '>')
  var sameDirectionDecreasing =
    (this.operator === '<=' || this.operator === '<') &&
    (comp.operator === '<=' || comp.operator === '<')
  var sameSemVer = this.semver.version === comp.semver.version
  var differentDirectionsInclusive =
    (this.operator === '>=' || this.operator === '<=') &&
    (comp.operator === '>=' || comp.operator === '<=')
  var oppositeDirectionsLessThan =
    cmp(this.semver, '<', comp.semver, options) &&
    ((this.operator === '>=' || this.operator === '>') &&
    (comp.operator === '<=' || comp.operator === '<'))
  var oppositeDirectionsGreaterThan =
    cmp(this.semver, '>', comp.semver, options) &&
    ((this.operator === '<=' || this.operator === '<') &&
    (comp.operator === '>=' || comp.operator === '>'))

  return sameDirectionIncreasing || sameDirectionDecreasing ||
    (sameSemVer && differentDirectionsInclusive) ||
    oppositeDirectionsLessThan || oppositeDirectionsGreaterThan
}

exports.Range = Range
function Range (range, options) {
  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    }
  }

  if (range instanceof Range) {
    if (range.loose === !!options.loose &&
        range.includePrerelease === !!options.includePrerelease) {
      return range
    } else {
      return new Range(range.raw, options)
    }
  }

  if (range instanceof Comparator) {
    return new Range(range.value, options)
  }

  if (!(this instanceof Range)) {
    return new Range(range, options)
  }

  this.options = options
  this.loose = !!options.loose
  this.includePrerelease = !!options.includePrerelease

  // First, split based on boolean or ||
  this.raw = range
  this.set = range.split(/\s*\|\|\s*/).map(function (range) {
    return this.parseRange(range.trim())
  }, this).filter(function (c) {
    // throw out any that are not relevant for whatever reason
    return c.length
  })

  if (!this.set.length) {
    throw new TypeError('Invalid SemVer Range: ' + range)
  }

  this.format()
}

Range.prototype.format = function () {
  this.range = this.set.map(function (comps) {
    return comps.join(' ').trim()
  }).join('||').trim()
  return this.range
}

Range.prototype.toString = function () {
  return this.range
}

Range.prototype.parseRange = function (range) {
  var loose = this.options.loose
  range = range.trim()
  // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`
  var hr = loose ? re[HYPHENRANGELOOSE] : re[HYPHENRANGE]
  range = range.replace(hr, hyphenReplace)
  debug('hyphen replace', range)
  // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`
  range = range.replace(re[COMPARATORTRIM], comparatorTrimReplace)
  debug('comparator trim', range, re[COMPARATORTRIM])

  // `~ 1.2.3` => `~1.2.3`
  range = range.replace(re[TILDETRIM], tildeTrimReplace)

  // `^ 1.2.3` => `^1.2.3`
  range = range.replace(re[CARETTRIM], caretTrimReplace)

  // normalize spaces
  range = range.split(/\s+/).join(' ')

  // At this point, the range is completely trimmed and
  // ready to be split into comparators.

  var compRe = loose ? re[COMPARATORLOOSE] : re[COMPARATOR]
  var set = range.split(' ').map(function (comp) {
    return parseComparator(comp, this.options)
  }, this).join(' ').split(/\s+/)
  if (this.options.loose) {
    // in loose mode, throw out any that are not valid comparators
    set = set.filter(function (comp) {
      return !!comp.match(compRe)
    })
  }
  set = set.map(function (comp) {
    return new Comparator(comp, this.options)
  }, this)

  return set
}

Range.prototype.intersects = function (range, options) {
  if (!(range instanceof Range)) {
    throw new TypeError('a Range is required')
  }

  return this.set.some(function (thisComparators) {
    return thisComparators.every(function (thisComparator) {
      return range.set.some(function (rangeComparators) {
        return rangeComparators.every(function (rangeComparator) {
          return thisComparator.intersects(rangeComparator, options)
        })
      })
    })
  })
}

// Mostly just for testing and legacy API reasons
exports.toComparators = toComparators
function toComparators (range, options) {
  return new Range(range, options).set.map(function (comp) {
    return comp.map(function (c) {
      return c.value
    }).join(' ').trim().split(' ')
  })
}

// comprised of xranges, tildes, stars, and gtlt's at this point.
// already replaced the hyphen ranges
// turn into a set of JUST comparators.
function parseComparator (comp, options) {
  debug('comp', comp, options)
  comp = replaceCarets(comp, options)
  debug('caret', comp)
  comp = replaceTildes(comp, options)
  debug('tildes', comp)
  comp = replaceXRanges(comp, options)
  debug('xrange', comp)
  comp = replaceStars(comp, options)
  debug('stars', comp)
  return comp
}

function isX (id) {
  return !id || id.toLowerCase() === 'x' || id === '*'
}

// ~, ~> --> * (any, kinda silly)
// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0
// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0
// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0
// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0
// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0
function replaceTildes (comp, options) {
  return comp.trim().split(/\s+/).map(function (comp) {
    return replaceTilde(comp, options)
  }).join(' ')
}

function replaceTilde (comp, options) {
  var r = options.loose ? re[TILDELOOSE] : re[TILDE]
  return comp.replace(r, function (_, M, m, p, pr) {
    debug('tilde', comp, _, M, m, p, pr)
    var ret

    if (isX(M)) {
      ret = ''
    } else if (isX(m)) {
      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0'
    } else if (isX(p)) {
      // ~1.2 == >=1.2.0 <1.3.0
      ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0'
    } else if (pr) {
      debug('replaceTilde pr', pr)
      ret = '>=' + M + '.' + m + '.' + p + '-' + pr +
            ' <' + M + '.' + (+m + 1) + '.0'
    } else {
      // ~1.2.3 == >=1.2.3 <1.3.0
      ret = '>=' + M + '.' + m + '.' + p +
            ' <' + M + '.' + (+m + 1) + '.0'
    }

    debug('tilde return', ret)
    return ret
  })
}

// ^ --> * (any, kinda silly)
// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0
// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0
// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0
// ^1.2.3 --> >=1.2.3 <2.0.0
// ^1.2.0 --> >=1.2.0 <2.0.0
function replaceCarets (comp, options) {
  return comp.trim().split(/\s+/).map(function (comp) {
    return replaceCaret(comp, options)
  }).join(' ')
}

function replaceCaret (comp, options) {
  debug('caret', comp, options)
  var r = options.loose ? re[CARETLOOSE] : re[CARET]
  return comp.replace(r, function (_, M, m, p, pr) {
    debug('caret', comp, _, M, m, p, pr)
    var ret

    if (isX(M)) {
      ret = ''
    } else if (isX(m)) {
      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0'
    } else if (isX(p)) {
      if (M === '0') {
        ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0'
      } else {
        ret = '>=' + M + '.' + m + '.0 <' + (+M + 1) + '.0.0'
      }
    } else if (pr) {
      debug('replaceCaret pr', pr)
      if (M === '0') {
        if (m === '0') {
          ret = '>=' + M + '.' + m + '.' + p + '-' + pr +
                ' <' + M + '.' + m + '.' + (+p + 1)
        } else {
          ret = '>=' + M + '.' + m + '.' + p + '-' + pr +
                ' <' + M + '.' + (+m + 1) + '.0'
        }
      } else {
        ret = '>=' + M + '.' + m + '.' + p + '-' + pr +
              ' <' + (+M + 1) + '.0.0'
      }
    } else {
      debug('no pr')
      if (M === '0') {
        if (m === '0') {
          ret = '>=' + M + '.' + m + '.' + p +
                ' <' + M + '.' + m + '.' + (+p + 1)
        } else {
          ret = '>=' + M + '.' + m + '.' + p +
                ' <' + M + '.' + (+m + 1) + '.0'
        }
      } else {
        ret = '>=' + M + '.' + m + '.' + p +
              ' <' + (+M + 1) + '.0.0'
      }
    }

    debug('caret return', ret)
    return ret
  })
}

function replaceXRanges (comp, options) {
  debug('replaceXRanges', comp, options)
  return comp.split(/\s+/).map(function (comp) {
    return replaceXRange(comp, options)
  }).join(' ')
}

function replaceXRange (comp, options) {
  comp = comp.trim()
  var r = options.loose ? re[XRANGELOOSE] : re[XRANGE]
  return comp.replace(r, function (ret, gtlt, M, m, p, pr) {
    debug('xRange', comp, ret, gtlt, M, m, p, pr)
    var xM = isX(M)
    var xm = xM || isX(m)
    var xp = xm || isX(p)
    var anyX = xp

    if (gtlt === '=' && anyX) {
      gtlt = ''
    }

    if (xM) {
      if (gtlt === '>' || gtlt === '<') {
        // nothing is allowed
        ret = '<0.0.0'
      } else {
        // nothing is forbidden
        ret = '*'
      }
    } else if (gtlt && anyX) {
      // we know patch is an x, because we have any x at all.
      // replace X with 0
      if (xm) {
        m = 0
      }
      p = 0

      if (gtlt === '>') {
        // >1 => >=2.0.0
        // >1.2 => >=1.3.0
        // >1.2.3 => >= 1.2.4
        gtlt = '>='
        if (xm) {
          M = +M + 1
          m = 0
          p = 0
        } else {
          m = +m + 1
          p = 0
        }
      } else if (gtlt === '<=') {
        // <=0.7.x is actually <0.8.0, since any 0.7.x should
        // pass.  Similarly, <=7.x is actually <8.0.0, etc.
        gtlt = '<'
        if (xm) {
          M = +M + 1
        } else {
          m = +m + 1
        }
      }

      ret = gtlt + M + '.' + m + '.' + p
    } else if (xm) {
      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0'
    } else if (xp) {
      ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0'
    }

    debug('xRange return', ret)

    return ret
  })
}

// Because * is AND-ed with everything else in the comparator,
// and '' means "any version", just remove the *s entirely.
function replaceStars (comp, options) {
  debug('replaceStars', comp, options)
  // Looseness is ignored here.  star is always as loose as it gets!
  return comp.trim().replace(re[STAR], '')
}

// This function is passed to string.replace(re[HYPHENRANGE])
// M, m, patch, prerelease, build
// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5
// 1.2.3 - 3.4 => >=1.2.0 <3.5.0 Any 3.4.x will do
// 1.2 - 3.4 => >=1.2.0 <3.5.0
function hyphenReplace ($0,
  from, fM, fm, fp, fpr, fb,
  to, tM, tm, tp, tpr, tb) {
  if (isX(fM)) {
    from = ''
  } else if (isX(fm)) {
    from = '>=' + fM + '.0.0'
  } else if (isX(fp)) {
    from = '>=' + fM + '.' + fm + '.0'
  } else {
    from = '>=' + from
  }

  if (isX(tM)) {
    to = ''
  } else if (isX(tm)) {
    to = '<' + (+tM + 1) + '.0.0'
  } else if (isX(tp)) {
    to = '<' + tM + '.' + (+tm + 1) + '.0'
  } else if (tpr) {
    to = '<=' + tM + '.' + tm + '.' + tp + '-' + tpr
  } else {
    to = '<=' + to
  }

  return (from + ' ' + to).trim()
}

// if ANY of the sets match ALL of its comparators, then pass
Range.prototype.test = function (version) {
  if (!version) {
    return false
  }

  if (typeof version === 'string') {
    version = new SemVer(version, this.options)
  }

  for (var i = 0; i < this.set.length; i++) {
    if (testSet(this.set[i], version, this.options)) {
      return true
    }
  }
  return false
}

function testSet (set, version, options) {
  for (var i = 0; i < set.length; i++) {
    if (!set[i].test(version)) {
      return false
    }
  }

  if (version.prerelease.length && !options.includePrerelease) {
    // Find the set of versions that are allowed to have prereleases
    // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0
    // That should allow `1.2.3-pr.2` to pass.
    // However, `1.2.4-alpha.notready` should NOT be allowed,
    // even though it's within the range set by the comparators.
    for (i = 0; i < set.length; i++) {
      debug(set[i].semver)
      if (set[i].semver === ANY) {
        continue
      }

      if (set[i].semver.prerelease.length > 0) {
        var allowed = set[i].semver
        if (allowed.major === version.major &&
            allowed.minor === version.minor &&
            allowed.patch === version.patch) {
          return true
        }
      }
    }

    // Version has a -pre, but it's not one of the ones we like.
    return false
  }

  return true
}

exports.satisfies = satisfies
function satisfies (version, range, options) {
  try {
    range = new Range(range, options)
  } catch (er) {
    return false
  }
  return range.test(version)
}

exports.maxSatisfying = maxSatisfying
function maxSatisfying (versions, range, options) {
  var max = null
  var maxSV = null
  try {
    var rangeObj = new Range(range, options)
  } catch (er) {
    return null
  }
  versions.forEach(function (v) {
    if (rangeObj.test(v)) {
      // satisfies(v, range, options)
      if (!max || maxSV.compare(v) === -1) {
        // compare(max, v, true)
        max = v
        maxSV = new SemVer(max, options)
      }
    }
  })
  return max
}

exports.minSatisfying = minSatisfying
function minSatisfying (versions, range, options) {
  var min = null
  var minSV = null
  try {
    var rangeObj = new Range(range, options)
  } catch (er) {
    return null
  }
  versions.forEach(function (v) {
    if (rangeObj.test(v)) {
      // satisfies(v, range, options)
      if (!min || minSV.compare(v) === 1) {
        // compare(min, v, true)
        min = v
        minSV = new SemVer(min, options)
      }
    }
  })
  return min
}

exports.minVersion = minVersion
function minVersion (range, loose) {
  range = new Range(range, loose)

  var minver = new SemVer('0.0.0')
  if (range.test(minver)) {
    return minver
  }

  minver = new SemVer('0.0.0-0')
  if (range.test(minver)) {
    return minver
  }

  minver = null
  for (var i = 0; i < range.set.length; ++i) {
    var comparators = range.set[i]

    comparators.forEach(function (comparator) {
      // Clone to avoid manipulating the comparator's semver object.
      var compver = new SemVer(comparator.semver.version)
      switch (comparator.operator) {
        case '>':
          if (compver.prerelease.length === 0) {
            compver.patch++
          } else {
            compver.prerelease.push(0)
          }
          compver.raw = compver.format()
          /* fallthrough */
        case '':
        case '>=':
          if (!minver || gt(minver, compver)) {
            minver = compver
          }
          break
        case '<':
        case '<=':
          /* Ignore maximum versions */
          break
        /* istanbul ignore next */
        default:
          throw new Error('Unexpected operation: ' + comparator.operator)
      }
    })
  }

  if (minver && range.test(minver)) {
    return minver
  }

  return null
}

exports.validRange = validRange
function validRange (range, options) {
  try {
    // Return '*' instead of '' so that truthiness works.
    // This will throw if it's invalid anyway
    return new Range(range, options).range || '*'
  } catch (er) {
    return null
  }
}

// Determine if version is less than all the versions possible in the range
exports.ltr = ltr
function ltr (version, range, options) {
  return outside(version, range, '<', options)
}

// Determine if version is greater than all the versions possible in the range.
exports.gtr = gtr
function gtr (version, range, options) {
  return outside(version, range, '>', options)
}

exports.outside = outside
function outside (version, range, hilo, options) {
  version = new SemVer(version, options)
  range = new Range(range, options)

  var gtfn, ltefn, ltfn, comp, ecomp
  switch (hilo) {
    case '>':
      gtfn = gt
      ltefn = lte
      ltfn = lt
      comp = '>'
      ecomp = '>='
      break
    case '<':
      gtfn = lt
      ltefn = gte
      ltfn = gt
      comp = '<'
      ecomp = '<='
      break
    default:
      throw new TypeError('Must provide a hilo val of "<" or ">"')
  }

  // If it satisifes the range it is not outside
  if (satisfies(version, range, options)) {
    return false
  }

  // From now on, variable terms are as if we're in "gtr" mode.
  // but note that everything is flipped for the "ltr" function.

  for (var i = 0; i < range.set.length; ++i) {
    var comparators = range.set[i]

    var high = null
    var low = null

    comparators.forEach(function (comparator) {
      if (comparator.semver === ANY) {
        comparator = new Comparator('>=0.0.0')
      }
      high = high || comparator
      low = low || comparator
      if (gtfn(comparator.semver, high.semver, options)) {
        high = comparator
      } else if (ltfn(comparator.semver, low.semver, options)) {
        low = comparator
      }
    })

    // If the edge version comparator has a operator then our version
    // isn't outside it
    if (high.operator === comp || high.operator === ecomp) {
      return false
    }

    // If the lowest version comparator has an operator and our version
    // is less than it then it isn't higher than the range
    if ((!low.operator || low.operator === comp) &&
        ltefn(version, low.semver)) {
      return false
    } else if (low.operator === ecomp && ltfn(version, low.semver)) {
      return false
    }
  }
  return true
}

exports.prerelease = prerelease
function prerelease (version, options) {
  var parsed = parse(version, options)
  return (parsed && parsed.prerelease.length) ? parsed.prerelease : null
}

exports.intersects = intersects
function intersects (r1, r2, options) {
  r1 = new Range(r1, options)
  r2 = new Range(r2, options)
  return r1.intersects(r2)
}

exports.coerce = coerce
function coerce (version) {
  if (version instanceof SemVer) {
    return version
  }

  if (typeof version !== 'string') {
    return null
  }

  var match = version.match(re[COERCE])

  if (match == null) {
    return null
  }

  return parse(match[1] +
    '.' + (match[2] || '0') +
    '.' + (match[3] || '0'))
}


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-core/index.js":
/*!***********************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-core/index.js ***!
  \***********************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const LocalStorage = __webpack_require__(/*! ./src/storage */ "../../node_modules/dd-trace/packages/datadog-core/src/storage/index.js")

const storage = new LocalStorage()

module.exports = { storage }


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-core/src/storage/async_hooks.js":
/*!*****************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-core/src/storage/async_hooks.js ***!
  \*****************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const { createHook, executionAsyncId } = __webpack_require__(/*! async_hooks */ "async_hooks")
const AsyncResourceStorage = __webpack_require__(/*! ./async_resource */ "../../node_modules/dd-trace/packages/datadog-core/src/storage/async_resource.js")

class AsyncHooksStorage extends AsyncResourceStorage {
  constructor () {
    super()

    this._resources = new Map()
  }

  disable () {
    super.disable()

    this._resources.clear()
  }

  _createHook () {
    return createHook({
      init: this._init.bind(this),
      destroy: this._destroy.bind(this)
    })
  }

  _init (asyncId, type, triggerAsyncId, resource) {
    super._init.apply(this, arguments)

    this._resources.set(asyncId, resource)
  }

  _destroy (asyncId) {
    this._resources.delete(asyncId)
  }

  _executionAsyncResource () {
    const asyncId = executionAsyncId()

    let resource = this._resources.get(asyncId)

    if (!resource) {
      this._resources.set(asyncId, resource = {})
    }

    return resource
  }
}

module.exports = AsyncHooksStorage


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-core/src/storage/async_resource.js":
/*!********************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-core/src/storage/async_resource.js ***!
  \********************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const { createHook, executionAsyncResource } = __webpack_require__(/*! async_hooks */ "async_hooks")

class AsyncResourceStorage {
  constructor () {
    this._ddResourceStore = Symbol('ddResourceStore')
    this._enabled = false
    this._hook = this._createHook()
  }

  disable () {
    if (!this._enabled) return

    this._hook.disable()
    this._enabled = false
  }

  getStore () {
    if (!this._enabled) return

    const resource = this._executionAsyncResource()

    return resource[this._ddResourceStore]
  }

  enterWith (store) {
    this._enable()

    const resource = this._executionAsyncResource()

    resource[this._ddResourceStore] = store
  }

  run (store, callback, ...args) {
    this._enable()

    const resource = this._executionAsyncResource()
    const oldStore = resource[this._ddResourceStore]

    resource[this._ddResourceStore] = store

    try {
      return callback(...args)
    } finally {
      resource[this._ddResourceStore] = oldStore
    }
  }

  _createHook () {
    return createHook({
      init: this._init.bind(this)
    })
  }

  _enable () {
    if (this._enabled) return

    this._enabled = true
    this._hook.enable()
  }

  _init (asyncId, type, triggerAsyncId, resource) {
    const currentResource = this._executionAsyncResource()

    if (Object.prototype.hasOwnProperty.call(currentResource, this._ddResourceStore)) {
      resource[this._ddResourceStore] = currentResource[this._ddResourceStore]
    }
  }

  _executionAsyncResource () {
    return executionAsyncResource()
  }
}

module.exports = AsyncResourceStorage


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-core/src/storage/index.js":
/*!***********************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-core/src/storage/index.js ***!
  \***********************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// TODO: default to AsyncLocalStorage when it supports triggerAsyncResource

const semver = __webpack_require__(/*! semver */ "../../node_modules/dd-trace/node_modules/semver/semver.js")

// https://github.com/nodejs/node/pull/33801
const hasJavaScriptAsyncHooks = semver.satisfies(process.versions.node, '>=14.5 || ^12.19.0')

if (hasJavaScriptAsyncHooks) {
  module.exports = __webpack_require__(/*! ./async_resource */ "../../node_modules/dd-trace/packages/datadog-core/src/storage/async_resource.js")
} else {
  module.exports = __webpack_require__(/*! ./async_hooks */ "../../node_modules/dd-trace/packages/datadog-core/src/storage/async_hooks.js")
}


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-instrumentations/index.js":
/*!***********************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-instrumentations/index.js ***!
  \***********************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(/*! ./src/amqplib */ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/amqplib.js")
__webpack_require__(/*! ./src/amqp10 */ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/amqp10.js")
__webpack_require__(/*! ./src/bluebird */ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/bluebird.js")
__webpack_require__(/*! ./src/bunyan */ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/bunyan.js")
__webpack_require__(/*! ./src/cassandra-driver */ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/cassandra-driver.js")
__webpack_require__(/*! ./src/couchbase */ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/couchbase.js")
__webpack_require__(/*! ./src/cucumber */ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/cucumber.js")
__webpack_require__(/*! ./src/dns */ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/dns.js")
__webpack_require__(/*! ./src/elasticsearch */ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/elasticsearch.js")
__webpack_require__(/*! ./src/generic-pool */ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/generic-pool.js")
__webpack_require__(/*! ./src/http */ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/http.js")
__webpack_require__(/*! ./src/ioredis */ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/ioredis.js")
__webpack_require__(/*! ./src/memcached */ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/memcached.js")
__webpack_require__(/*! ./src/mongodb-core */ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/mongodb-core.js")
__webpack_require__(/*! ./src/mongoose */ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/mongoose.js")
__webpack_require__(/*! ./src/mysql */ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/mysql.js")
__webpack_require__(/*! ./src/mysql2 */ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/mysql2.js")
__webpack_require__(/*! ./src/mocha */ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/mocha.js")
__webpack_require__(/*! ./src/net */ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/net.js")
__webpack_require__(/*! ./src/pino */ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/pino.js")
__webpack_require__(/*! ./src/pg */ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/pg.js")
__webpack_require__(/*! ./src/promise */ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/promise.js")
__webpack_require__(/*! ./src/promise-js */ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/promise-js.js")
__webpack_require__(/*! ./src/q */ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/q.js")
__webpack_require__(/*! ./src/redis */ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/redis.js")
__webpack_require__(/*! ./src/rhea */ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/rhea.js")
__webpack_require__(/*! ./src/sharedb */ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/sharedb.js")
__webpack_require__(/*! ./src/tedious */ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/tedious.js")
__webpack_require__(/*! ./src/when */ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/when.js")
__webpack_require__(/*! ./src/winston */ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/winston.js")


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/amqp10.js":
/*!****************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-instrumentations/src/amqp10.js ***!
  \****************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const {
  channel,
  addHook,
  AsyncResource
} = __webpack_require__(/*! ./helpers/instrument */ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/helpers/instrument.js")
const shimmer = __webpack_require__(/*! ../../datadog-shimmer */ "../../node_modules/dd-trace/packages/datadog-shimmer/index.js")

addHook({ name: 'amqp10', file: 'lib/sender_link.js', versions: ['>=3'] }, SenderLink => {
  const startCh = channel('apm:amqp10:send:start')
  const asyncEndCh = channel('apm:amqp10:send:async-end')
  const endCh = channel('apm:amqp10:send:end')
  const errorCh = channel('apm:amqp10:send:error')
  shimmer.wrap(SenderLink.prototype, 'send', send => function (msg, options) {
    if (!startCh.hasSubscribers) {
      return send.apply(this, arguments)
    }
    startCh.publish({ link: this })
    try {
      const promise = send.apply(this, arguments)

      if (!promise) {
        finish(asyncEndCh, errorCh)
        return promise
      }

      const asyncResource = new AsyncResource('bound-anonymous-fn')

      promise.then(asyncResource.bind(() => finish(asyncEndCh, errorCh)),
        asyncResource.bind(e => finish(asyncEndCh, errorCh, e)))

      return promise
    } catch (err) {
      finish(asyncEndCh, errorCh, err)
      throw err
    } finally {
      endCh.publish(undefined)
    }
  })
  return SenderLink
})

addHook({ name: 'amqp10', file: 'lib/receiver_link.js', versions: ['>=3'] }, ReceiverLink => {
  const startCh = channel('apm:amqp10:receive:start')
  const endCh = channel('apm:amqp10:receive:end')
  const errorCh = channel('apm:amqp10:receive:error')
  shimmer.wrap(ReceiverLink.prototype, '_messageReceived', messageReceived => function (transferFrame) {
    if (!transferFrame || transferFrame.aborted || transferFrame.more) {
      return messageReceived.apply(this, arguments)
    }
    startCh.publish({ link: this })
    try {
      return messageReceived.apply(this, arguments)
    } catch (err) {
      errorCh.publish(err)
      throw err
    } finally {
      endCh.publish(undefined)
    }
  })
  return ReceiverLink
})

function finish (asyncEndCh, errorCh, error) {
  if (error) {
    errorCh.publish(error)
  }
  asyncEndCh.publish(undefined)
}


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/amqplib.js":
/*!*****************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-instrumentations/src/amqplib.js ***!
  \*****************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const {
  channel,
  addHook
} = __webpack_require__(/*! ./helpers/instrument */ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/helpers/instrument.js")
const kebabCase = __webpack_require__(/*! lodash.kebabcase */ "../../node_modules/lodash.kebabcase/index.js")
const shimmer = __webpack_require__(/*! ../../datadog-shimmer */ "../../node_modules/dd-trace/packages/datadog-shimmer/index.js")

const startCh = channel('apm:amqplib:command:start')
const endCh = channel('apm:amqplib:command:end')
const errorCh = channel('apm:amqplib:command:error')

let methods = {}

addHook({ name: 'amqplib', file: 'lib/defs.js', versions: ['>=0.5'] }, defs => {
  methods = Object.keys(defs)
    .filter(key => Number.isInteger(defs[key]))
    .filter(key => isCamelCase(key))
    .reduce((acc, key) => Object.assign(acc, { [defs[key]]: kebabCase(key).replace('-', '.') }), {})
  return defs
})

addHook({ name: 'amqplib', file: 'lib/channel.js', versions: ['>=0.5'] }, channel => {
  shimmer.wrap(channel.Channel.prototype, 'sendImmediately', sendImmediately => function (method, fields) {
    return instrument(sendImmediately, this, arguments, methods[method], fields)
  })

  shimmer.wrap(channel.Channel.prototype, 'sendMessage', sendMessage => function (fields) {
    return instrument(sendMessage, this, arguments, 'basic.publish', fields)
  })

  shimmer.wrap(channel.BaseChannel.prototype, 'dispatchMessage', dispatchMessage => function (fields, message) {
    return instrument(dispatchMessage, this, arguments, 'basic.deliver', fields, message)
  })
  return channel
})

function instrument (send, channel, args, method, fields, message) {
  if (!startCh.hasSubscribers) {
    return send.apply(channel, args)
  }
  startCh.publish({ channel, method, fields, message })

  try {
    return send.apply(channel, args)
  } catch (err) {
    errorCh.publish(err)

    throw err
  } finally {
    endCh.publish(undefined)
  }
}

function isCamelCase (str) {
  return /([A-Z][a-z0-9]+)+/.test(str)
}


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/bluebird.js":
/*!******************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-instrumentations/src/bluebird.js ***!
  \******************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const { addHook } = __webpack_require__(/*! ./helpers/instrument */ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/helpers/instrument.js")
const { wrapThen } = __webpack_require__(/*! ./helpers/promise */ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/helpers/promise.js")
const shimmer = __webpack_require__(/*! ../../datadog-shimmer */ "../../node_modules/dd-trace/packages/datadog-shimmer/index.js")

function createGetNewLibraryCopyWrap (originalLib) {
  return function wrapGetNewLibraryCopy (getNewLibraryCopy) {
    return function getNewLibraryCopyWithTrace () {
      const libraryCopy = getNewLibraryCopy.apply(this, arguments)
      shimmer.wrap(libraryCopy.prototype, '_then', wrapThen)
      shimmer.wrap(libraryCopy, 'getNewLibraryCopy', createGetNewLibraryCopyWrap(originalLib))
      return libraryCopy
    }
  }
}

addHook({ name: 'bluebird', versions: ['>=2.0.2'] }, Promise => {
  shimmer.wrap(Promise.prototype, '_then', wrapThen)
  return Promise
})

addHook({ name: 'bluebird', versions: ['^2.11.0', '^3.4.1'] }, Promise => {
  shimmer.wrap(Promise, 'getNewLibraryCopy', createGetNewLibraryCopyWrap(Promise))
  return Promise
})


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/bunyan.js":
/*!****************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-instrumentations/src/bunyan.js ***!
  \****************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const {
  channel,
  addHook
} = __webpack_require__(/*! ./helpers/instrument */ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/helpers/instrument.js")
const shimmer = __webpack_require__(/*! ../../datadog-shimmer */ "../../node_modules/dd-trace/packages/datadog-shimmer/index.js")

addHook({ name: 'bunyan', versions: ['>=1'] }, Logger => {
  const logCh = channel('apm:bunyan:log')
  shimmer.wrap(Logger.prototype, '_emit', emit => {
    return function wrappedEmit (rec) {
      if (logCh.hasSubscribers) {
        const payload = { message: rec }
        logCh.publish(payload)
        arguments[0] = payload.message
      }
      return emit.apply(this, arguments)
    }
  })
  return Logger
})


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/cassandra-driver.js":
/*!**************************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-instrumentations/src/cassandra-driver.js ***!
  \**************************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const {
  channel,
  addHook,
  AsyncResource
} = __webpack_require__(/*! ./helpers/instrument */ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/helpers/instrument.js")
const shimmer = __webpack_require__(/*! ../../datadog-shimmer */ "../../node_modules/dd-trace/packages/datadog-shimmer/index.js")

const startCh = channel('apm:cassandra:query:start')
const asyncEndCh = channel('apm:cassandra:query:async-end')
const endCh = channel('apm:cassandra:query:end')
const errorCh = channel('apm:cassandra:query:error')
const addConnectionCh = channel(`apm:cassandra:query:addConnection`)

addHook({ name: 'cassandra-driver', versions: ['>=3.0.0'] }, cassandra => {
  shimmer.wrap(cassandra.Client.prototype, 'batch', batch => function (queries, options, callback) {
    if (!startCh.hasSubscribers) {
      return batch.apply(this, arguments)
    }
    const asyncResource = new AsyncResource('bound-anonymous-fn')
    startCh.publish({ keyspace: this.keyspace, query: queries })

    const lastIndex = arguments.length - 1
    let cb = arguments[lastIndex]

    if (typeof cb === 'function') {
      cb = asyncResource.bind(cb)
      arguments[lastIndex] = wrapCallback(asyncEndCh, errorCh, cb)
    }

    try {
      const res = batch.apply(this, arguments)
      if (typeof res === 'function' || !res) {
        return wrapCallback(asyncEndCh, errorCh, res)
      } else {
        const promiseAsyncResource = new AsyncResource('bound-anonymous-fn')
        return res.then(
          promiseAsyncResource.bind(() => finish(asyncEndCh, errorCh)),
          promiseAsyncResource.bind(err => finish(asyncEndCh, errorCh, err))
        )
      }
    } catch (e) {
      finish(asyncEndCh, errorCh, e)
      throw e
    } finally {
      endCh.publish(undefined)
    }
  })
  return cassandra
})

addHook({ name: 'cassandra-driver', versions: ['>=4.4'] }, cassandra => {
  shimmer.wrap(cassandra.Client.prototype, '_execute', _execute => function (query, params, execOptions, callback) {
    if (!startCh.hasSubscribers) {
      return _execute.apply(this, arguments)
    }
    startCh.publish({ keyspace: this.keyspace, query })
    const promise = _execute.apply(this, arguments)

    const promiseAsyncResource = new AsyncResource('bound-anonymous-fn')

    promise.then(
      promiseAsyncResource.bind(() => finish(asyncEndCh, errorCh)),
      promiseAsyncResource.bind(err => finish(asyncEndCh, errorCh, err))
    )
    endCh.publish(undefined)
    return promise
  })
  return cassandra
})

addHook({ name: 'cassandra-driver', versions: ['3 - 4.3'] }, cassandra => {
  shimmer.wrap(cassandra.Client.prototype, '_innerExecute', _innerExecute =>
    function (query, params, execOptions, callback) {
      if (!startCh.hasSubscribers) {
        return _innerExecute.apply(this, arguments)
      }
      const asyncResource = new AsyncResource('bound-anonymous-fn')
      const isValid = (args) => {
        return args.length === 4 || typeof args[3] === 'function'
      }

      if (!isValid(arguments)) {
        return _innerExecute.apply(this, arguments)
      }

      startCh.publish({ keyspace: this.keyspace, query })

      const lastIndex = arguments.length - 1
      let cb = arguments[lastIndex]

      if (typeof cb === 'function') {
        cb = asyncResource.bind(cb)
        arguments[lastIndex] = wrapCallback(asyncEndCh, errorCh, cb)
      }

      try {
        return _innerExecute.apply(this, arguments)
      } catch (e) {
        finish(asyncEndCh, errorCh, e)
        throw e
      } finally {
        endCh.publish(undefined)
      }
    }
  )
  return cassandra
})

addHook({ name: 'cassandra-driver', versions: ['>=3.3'], file: 'lib/request-execution.js' }, RequestExecution => {
  shimmer.wrap(RequestExecution.prototype, '_sendOnConnection', _sendOnConnection => function () {
    if (!startCh.hasSubscribers) {
      return _sendOnConnection.apply(this, arguments)
    }
    addConnectionCh.publish({ address: this._connection.address, port: this._connection.port })
    return _sendOnConnection.apply(this, arguments)
  })
  return RequestExecution
})

addHook({ name: 'cassandra-driver', versions: ['3.3 - 4.3'], file: 'lib/request-execution.js' }, RequestExecution => {
  shimmer.wrap(RequestExecution.prototype, 'start', start => function (getHostCallback) {
    if (!startCh.hasSubscribers) {
      return getHostCallback.apply(this, arguments)
    }
    const asyncResource = new AsyncResource('bound-anonymous-fn')
    const execution = this

    if (!isRequestValid(this, arguments, 1)) {
      return start.apply(this, arguments)
    }

    getHostCallback = asyncResource.bind(getHostCallback)

    arguments[0] = AsyncResource.bind(function () {
      addConnectionCh.publish({ address: execution._connection.address, port: execution._connection.port })
      return getHostCallback.apply(this, arguments)
    })

    return start.apply(this, arguments)
  })
  return RequestExecution
})

addHook({ name: 'cassandra-driver', versions: ['3 - 3.2'], file: 'lib/request-handler.js' }, RequestHandler => {
  shimmer.wrap(RequestHandler.prototype, 'send', send => function (request, options, callback) {
    if (!startCh.hasSubscribers) {
      return send.apply(this, arguments)
    }
    const handler = this

    if (!isRequestValid(this, arguments, 3)) {
      return send.apply(this, arguments)
    }
    const asyncResource = new AsyncResource('bound-anonymous-fn')

    callback = asyncResource.bind(callback)

    arguments[2] = AsyncResource.bind(function () {
      addConnectionCh.publish({ address: handler.connection.address, port: handler.connection.port })
      return callback.apply(this, arguments)
    })

    return send.apply(this, arguments)
  })
  return RequestHandler
})

function finish (asyncEndCh, errorCh, error) {
  if (error) {
    errorCh.publish(error)
  }
  asyncEndCh.publish(undefined)
}

function wrapCallback (asyncEndCh, errorCh, callback) {
  return AsyncResource.bind(function (err) {
    finish(asyncEndCh, errorCh, err)
    if (callback) {
      return callback.apply(this, arguments)
    }
  })
}

function isRequestValid (exec, args, length) {
  if (!exec) return false
  if (args.length !== length || typeof args[length - 1] !== 'function') return false

  return true
}


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/couchbase.js":
/*!*******************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-instrumentations/src/couchbase.js ***!
  \*******************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const {
  channel,
  addHook,
  AsyncResource
} = __webpack_require__(/*! ./helpers/instrument */ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/helpers/instrument.js")
const shimmer = __webpack_require__(/*! ../../datadog-shimmer */ "../../node_modules/dd-trace/packages/datadog-shimmer/index.js")

addHook({ name: 'couchbase', file: 'lib/bucket.js', versions: ['^2.6.5'] }, Bucket => {
  const startCh = channel('apm:couchbase:query:start')
  const asyncEndCh = channel('apm:couchbase:query:async-end')
  const endCh = channel('apm:couchbase:query:end')
  const errorCh = channel('apm:couchbase:query:error')

  Bucket.prototype._maybeInvoke = wrapMaybeInvoke(Bucket.prototype._maybeInvoke)
  Bucket.prototype.query = wrapQuery(Bucket.prototype.query)

  shimmer.wrap(Bucket.prototype, '_n1qlReq', _n1qlReq => function (host, q, adhoc, emitter) {
    if (!startCh.hasSubscribers) {
      return _n1qlReq.apply(this, arguments)
    }

    if (!emitter || !emitter.once) return _n1qlReq.apply(this, arguments)

    const n1qlQuery = q && q.statement

    startCh.publish({ resource: n1qlQuery, bucket: this })

    emitter.once('rows', AsyncResource.bind(() => {
      asyncEndCh.publish(undefined)
    }))

    emitter.once('error', AsyncResource.bind((error) => {
      errorCh.publish(error)
      asyncEndCh.publish(undefined)
    }))

    try {
      return _n1qlReq.apply(this, arguments)
    } catch (err) {
      err.stack // trigger getting the stack at the original throwing point
      errorCh.publish(err)

      throw err
    } finally {
      endCh.publish(undefined)
    }
  })

  Bucket.prototype.upsert = wrap('apm:couchbase:upsert', Bucket.prototype.upsert)
  Bucket.prototype.insert = wrap('apm:couchbase:insert', Bucket.prototype.insert)
  Bucket.prototype.replace = wrap('apm:couchbase:replace', Bucket.prototype.replace)
  Bucket.prototype.append = wrap('apm:couchbase:append', Bucket.prototype.append)
  Bucket.prototype.prepend = wrap('apm:couchbase:prepend', Bucket.prototype.prepend)

  return Bucket
})

addHook({ name: 'couchbase', file: 'lib/cluster.js', versions: ['^2.6.5'] }, Cluster => {
  Cluster.prototype._maybeInvoke = wrapMaybeInvoke(Cluster.prototype._maybeInvoke)
  Cluster.prototype.query = wrapQuery(Cluster.prototype.query)

  return Cluster
})

function findCallbackIndex (args) {
  for (let i = args.length - 1; i >= 2; i--) {
    if (typeof args[i] === 'function') return i
  }
  return -1
}

function wrapMaybeInvoke (_maybeInvoke) {
  const wrapped = function (fn, args) {
    if (!Array.isArray(args)) return _maybeInvoke.apply(this, arguments)

    const callbackIndex = args.length - 1
    const callback = args[callbackIndex]

    if (callback instanceof Function) {
      args[callbackIndex] = AsyncResource.bind(callback)
    }

    return _maybeInvoke.apply(this, arguments)
  }
  return shimmer.wrap(_maybeInvoke, wrapped)
}

function wrapQuery (query) {
  const wrapped = function (q, params, callback) {
    callback = AsyncResource.bind(arguments[arguments.length - 1])

    if (typeof callback === 'function') {
      arguments[arguments.length - 1] = callback
    }

    const res = query.apply(this, arguments)
    return res
  }
  return shimmer.wrap(query, wrapped)
}

function wrap (prefix, fn) {
  const startCh = channel(prefix + ':start')
  const endCh = channel(prefix + ':end')
  const asyncEndCh = channel(prefix + ':async-end')
  const errorCh = channel(prefix + ':error')

  const wrapped = function (key, value, options, callback) {
    if (!startCh.hasSubscribers) {
      return fn.apply(this, arguments)
    }

    const callbackIndex = findCallbackIndex(arguments)

    if (callbackIndex < 0) return fn.apply(this, arguments)

    const cb = arguments[callbackIndex]

    startCh.publish({ bucket: this })

    arguments[callbackIndex] = function (error, result) {
      if (error) {
        errorCh.publish(error)
      }
      asyncEndCh.publish(result)
      return cb.apply(this, arguments)
    }

    try {
      return fn.apply(this, arguments)
    } catch (error) {
      error.stack // trigger getting the stack at the original throwing point
      errorCh.publish(error)

      throw error
    } finally {
      endCh.publish(undefined)
    }
  }
  return shimmer.wrap(fn, wrapped)
}


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/cucumber.js":
/*!******************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-instrumentations/src/cucumber.js ***!
  \******************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const { addHook, channel } = __webpack_require__(/*! ./helpers/instrument */ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/helpers/instrument.js")
const shimmer = __webpack_require__(/*! ../../datadog-shimmer */ "../../node_modules/dd-trace/packages/datadog-shimmer/index.js")

const runStartCh = channel('ci:cucumber:run:start')
const runEndCh = channel('ci:cucumber:run:end')
const runAsyncEndCh = channel('ci:cucumber:run:async-end')
const runStepStartCh = channel('ci:cucumber:run-step:start')
const runStepEndCh = channel('ci:cucumber:run-step:end')
const errorCh = channel('ci:cucumber:error')

// TODO: remove in a later major version
const patched = new WeakSet()

function getStatusFromResult (result) {
  if (result.status === 1) {
    return { status: 'pass' }
  }
  if (result.status === 2) {
    return { status: 'skip' }
  }
  if (result.status === 4) {
    return { status: 'skip', skipReason: 'not implemented' }
  }
  return { status: 'fail', errorMessage: result.message }
}

function getStatusFromResultLatest (result) {
  if (result.status === 'PASSED') {
    return { status: 'pass' }
  }
  if (result.status === 'SKIPPED' || result.status === 'PENDING') {
    return { status: 'skip' }
  }
  if (result.status === 'UNDEFINED') {
    return { status: 'skip', skipReason: 'not implemented' }
  }
  return { status: 'fail', errorMessage: result.message }
}

function wrapRun (pl, isLatestVersion) {
  if (patched.has(pl)) return

  patched.add(pl)

  shimmer.wrap(pl.prototype, 'run', run => function () {
    if (!runStartCh.hasSubscribers) {
      return run.apply(this, arguments)
    }

    runStartCh.publish({ pickleName: this.pickle.name, pickleUri: this.pickle.uri })
    try {
      const promise = run.apply(this, arguments)
      promise.finally(() => {
        const result = this.getWorstStepResult()
        const { status, skipReason, errorMessage } = isLatestVersion
          ? getStatusFromResultLatest(result) : getStatusFromResult(result)

        runAsyncEndCh.publish({ status, skipReason, errorMessage })
      })
      return promise
    } catch (err) {
      errorCh.publish(err)
      throw err
    } finally {
      runEndCh.publish(undefined)
    }
  })
  shimmer.wrap(pl.prototype, 'runStep', runStep => function () {
    if (!runStepStartCh.hasSubscribers) {
      return runStep.apply(this, arguments)
    }
    const testStep = arguments[0]
    let resource

    if (isLatestVersion) {
      resource = testStep.text
    } else {
      resource = testStep.isHook ? 'hook' : testStep.pickleStep.text
    }

    runStepStartCh.publish({ resource })
    try {
      const promise = runStep.apply(this, arguments)

      promise.then((result) => {
        const { status, skipReason, errorMessage } = isLatestVersion
          ? getStatusFromResultLatest(result) : getStatusFromResult(result)

        runAsyncEndCh.publish({ isStep: true, status, skipReason, errorMessage })
      })
      return promise
    } catch (err) {
      errorCh.publish(err)
      throw err
    } finally {
      runStepEndCh.publish(undefined)
    }
  })
}

function pickleHook (PickleRunner) {
  const pl = PickleRunner.default

  wrapRun(pl, false)

  return PickleRunner
}

function testCaseHook (TestCaseRunner) {
  const pl = TestCaseRunner.default

  wrapRun(pl, true)

  return TestCaseRunner
}

addHook({
  name: '@cucumber/cucumber',
  versions: ['7.0.0 - 7.2.1'],
  file: 'lib/runtime/pickle_runner.js'
}, pickleHook)

addHook({
  name: '@cucumber/cucumber',
  versions: ['>=7.3.0'],
  file: 'lib/runtime/test_case_runner.js'
}, testCaseHook)

module.exports = { pickleHook, testCaseHook }


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/dns.js":
/*!*************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-instrumentations/src/dns.js ***!
  \*************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const { channel, addHook, AsyncResource } = __webpack_require__(/*! ./helpers/instrument */ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/helpers/instrument.js")
const shimmer = __webpack_require__(/*! ../../datadog-shimmer */ "../../node_modules/dd-trace/packages/datadog-shimmer/index.js")

const rrtypes = {
  resolveAny: 'ANY',
  resolve4: 'A',
  resolve6: 'AAAA',
  resolveCname: 'CNAME',
  resolveMx: 'MX',
  resolveNs: 'NS',
  resolveTxt: 'TXT',
  resolveSrv: 'SRV',
  resolvePtr: 'PTR',
  resolveNaptr: 'NAPTR',
  resolveSoa: 'SOA'
}

const rrtypeMap = new WeakMap()

addHook({ name: 'dns' }, dns => {
  dns.lookup = wrap('apm:dns:lookup', dns.lookup, 2)
  dns.lookupService = wrap('apm:dns:lookup_service', dns.lookupService, 3)
  dns.resolve = wrap('apm:dns:resolve', dns.resolve, 2)
  dns.reverse = wrap('apm:dns:reverse', dns.reverse, 2)

  patchResolveShorthands(dns)

  if (dns.Resolver) {
    dns.Resolver.prototype.resolve = wrap('apm:dns:resolve', dns.Resolver.prototype.resolve, 2)
    dns.Resolver.prototype.reverse = wrap('apm:dns:reverse', dns.Resolver.prototype.reverse, 2)

    patchResolveShorthands(dns.Resolver.prototype)
  }

  return dns
})

function patchResolveShorthands (prototype) {
  Object.keys(rrtypes)
    .filter(method => !!prototype[method])
    .forEach(method => {
      rrtypeMap.set(prototype[method], rrtypes[method])
      prototype[method] = wrap('apm:dns:resolve', prototype[method], 2, rrtypes[method])
    })
}

function wrap (prefix, fn, expectedArgs, rrtype) {
  const startCh = channel(prefix + ':start')
  const endCh = channel(prefix + ':end')
  const asyncEndCh = channel(prefix + ':async-end')
  const errorCh = channel(prefix + ':error')

  const wrapped = function () {
    const cb = AsyncResource.bind(arguments[arguments.length - 1])
    if (
      !startCh.hasSubscribers ||
      arguments.length < expectedArgs ||
      typeof cb !== 'function'
    ) {
      return fn.apply(this, arguments)
    }

    const startArgs = Array.from(arguments)
    startArgs.pop() // gets rid of the callback
    if (rrtype) {
      startArgs.push(rrtype)
    }
    startCh.publish(startArgs)

    arguments[arguments.length - 1] = function (error, result) {
      if (error) {
        errorCh.publish(error)
      }
      asyncEndCh.publish(result)
      cb.apply(this, arguments)
    }

    try {
      return fn.apply(this, arguments)
      // TODO deal with promise versions when we support `dns/promises`
    } catch (error) {
      error.stack // trigger getting the stack at the original throwing point
      errorCh.publish(error)

      throw error
    } finally {
      endCh.publish(undefined)
    }
  }

  return shimmer.wrap(fn, wrapped)
}


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/elasticsearch.js":
/*!***********************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-instrumentations/src/elasticsearch.js ***!
  \***********************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const {
  channel,
  addHook,
  AsyncResource
} = __webpack_require__(/*! ./helpers/instrument */ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/helpers/instrument.js")
const shimmer = __webpack_require__(/*! ../../datadog-shimmer */ "../../node_modules/dd-trace/packages/datadog-shimmer/index.js")

const startCh = channel('apm:elasticsearch:query:start')
const asyncEndCh = channel('apm:elasticsearch:query:async-end')
const endCh = channel('apm:elasticsearch:query:end')
const errorCh = channel('apm:elasticsearch:query:error')

addHook({ name: '@elastic/transport', file: 'lib/Transport.js', versions: ['>=8'] }, (exports) => {
  shimmer.wrap(exports.default.prototype, 'request', wrapRequest)
  return exports
})

addHook({ name: '@elastic/elasticsearch', file: 'lib/Transport.js', versions: ['>=5.6.16 <8', '>=8'] }, Transport => {
  shimmer.wrap(Transport.prototype, 'request', wrapRequest)
  return Transport
})

addHook({ name: 'elasticsearch', file: 'src/lib/transport.js', versions: ['>=10'] }, Transport => {
  shimmer.wrap(Transport.prototype, 'request', wrapRequest)
  return Transport
})

function wrapRequest (request) {
  return function (params, options, cb) {
    if (!startCh.hasSubscribers) {
      return request.apply(this, arguments)
    }

    if (!params) return request.apply(this, arguments)

    const parentResource = new AsyncResource('bound-anonymous-fn')

    startCh.publish({ params })

    const asyncResource = new AsyncResource('bound-anonymous-fn')

    try {
      const lastIndex = arguments.length - 1
      cb = arguments[lastIndex]

      if (typeof cb === 'function') {
        cb = parentResource.bind(cb)

        arguments[lastIndex] = asyncResource.bind(function (error) {
          finish(params, error)
          return cb.apply(null, arguments)
        })
        return request.apply(this, arguments)
      } else {
        const promise = request.apply(this, arguments)
        if (promise && typeof promise.then === 'function') {
          const onResolve = asyncResource.bind(() => finish(params))
          const onReject = asyncResource.bind(e => finish(params, e))

          promise.then(onResolve, onReject)
        } else {
          finish(params)
        }
        return promise
      }
    } catch (err) {
      err.stack // trigger getting the stack at the original throwing point
      errorCh.publish(err)

      throw err
    } finally {
      endCh.publish(undefined)
    }
  }
}

function finish (params, error) {
  if (error) {
    errorCh.publish(error)
  }
  asyncEndCh.publish({ params })
}


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/generic-pool.js":
/*!**********************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-instrumentations/src/generic-pool.js ***!
  \**********************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const { addHook, AsyncResource } = __webpack_require__(/*! ./helpers/instrument */ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/helpers/instrument.js")
const shimmer = __webpack_require__(/*! ../../datadog-shimmer */ "../../node_modules/dd-trace/packages/datadog-shimmer/index.js")

function createWrapAcquire () {
  return function wrapAcquire (acquire) {
    return function acquireWithTrace (callback, priority) {
      if (typeof callback === 'function') {
        arguments[0] = AsyncResource.bind(callback)
      }

      return acquire.apply(this, arguments)
    }
  }
}

function createWrapPool () {
  return function wrapPool (Pool) {
    if (typeof Pool !== 'function') return Pool

    return function PoolWithTrace (factory) {
      const pool = Pool.apply(this, arguments)

      if (pool && typeof pool.acquire === 'function') {
        shimmer.wrap(pool, 'acquire', createWrapAcquire())
      }

      return pool
    }
  }
}

addHook({
  name: 'generic-pool',
  versions: ['^2.4']
}, genericPool => {
  shimmer.wrap(genericPool.Pool.prototype, 'acquire', createWrapAcquire())
  return genericPool
})

addHook({
  name: 'generic-pool',
  versions: ['2 - 2.3']
}, genericPool => {
  shimmer.wrap(genericPool, 'Pool', createWrapPool())
  return genericPool
})


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/helpers/hook.js":
/*!**********************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-instrumentations/src/helpers/hook.js ***!
  \**********************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const path = __webpack_require__(/*! path */ "path")
const iitm = __webpack_require__(/*! ../../../dd-trace/src/iitm */ "../../node_modules/dd-trace/packages/dd-trace/src/iitm.js")
const ritm = __webpack_require__(/*! ../../../dd-trace/src/ritm */ "../../node_modules/dd-trace/packages/dd-trace/src/ritm.js")

function Hook (modules, onrequire) {
  if (!(this instanceof Hook)) return new Hook(modules, onrequire)

  this._patched = Object.create(null)

  const safeHook = (moduleExports, moduleName, moduleBaseDir) => {
    const parts = [moduleBaseDir, moduleName].filter(v => v)
    const filename = path.join(...parts)

    if (this._patched[filename]) return moduleExports

    this._patched[filename] = true

    return onrequire(moduleExports, moduleName, moduleBaseDir)
  }

  this._ritmHook = ritm(modules, {}, safeHook)
  this._iitmHook = iitm(modules, {}, (moduleExports, moduleName, moduleBaseDir) => {
    // TODO: Move this logic to import-in-the-middle and only do it for CommonJS
    // modules and not ESM. In the meantime, all the modules we instrument are
    // CommonJS modules for which the default export is always moved to
    // `default` anyway.
    if (moduleExports && moduleExports.default) {
      moduleExports.default = safeHook(moduleExports.default, moduleName, moduleBaseDir)
      return moduleExports
    } else {
      return safeHook(moduleExports, moduleName, moduleBaseDir)
    }
  })
}

Hook.prototype.unhook = function () {
  this._ritmHook.unhook()
  this._iitmHook.unhook()
  this._patched = Object.create(null)
}

module.exports = Hook


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/helpers/instrument.js":
/*!****************************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-instrumentations/src/helpers/instrument.js ***!
  \****************************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

const dc = __webpack_require__(/*! diagnostics_channel */ "diagnostics_channel")
const path = __webpack_require__(/*! path */ "path")
const semver = __webpack_require__(/*! semver */ "../../node_modules/dd-trace/node_modules/semver/semver.js")
const Hook = __webpack_require__(/*! ./hook */ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/helpers/hook.js")
const requirePackageJson = __webpack_require__(/*! ../../../dd-trace/src/require-package-json */ "../../node_modules/dd-trace/packages/dd-trace/src/require-package-json.js")
const { AsyncResource } = __webpack_require__(/*! async_hooks */ "async_hooks")
const log = __webpack_require__(/*! ../../../dd-trace/src/log */ "../../node_modules/dd-trace/packages/dd-trace/src/log.js")

const pathSepExpr = new RegExp(`\\${path.sep}`, 'g')
const channelMap = {}
exports.channel = function channel (name) {
  const maybe = channelMap[name]
  if (maybe) return maybe
  const ch = dc.channel(name)
  channelMap[name] = ch
  return ch
}

exports.addHook = function addHook ({ name, versions, file }, hook) {
  const fullFilename = filename(name, file)

  Hook([name], (moduleExports, moduleName, moduleBaseDir) => {
    moduleName = moduleName.replace(pathSepExpr, '/')

    if (moduleName !== fullFilename || !matchVersion(getVersion(moduleBaseDir), versions)) {
      return moduleExports
    }

    try {
      return hook(moduleExports)
    } catch (e) {
      log.error(e)
      return moduleExports
    }
  })
}

function matchVersion (version, ranges) {
  return !version || (ranges && ranges.some(range => semver.satisfies(semver.coerce(version), range)))
}

function getVersion (moduleBaseDir) {
  if (moduleBaseDir) {
    return requirePackageJson(moduleBaseDir, module).version
  }
}

function filename (name, file) {
  return [name, file].filter(val => val).join('/')
}

// AsyncResource.bind exists and binds `this` properly only from 17.8.0 and up.
// https://nodejs.org/api/async_context.html#asyncresourcebindfn-thisarg
if (semver.satisfies(process.versions.node, '>=17.8.0')) {
  exports.AsyncResource = AsyncResource
} else {
  exports.AsyncResource = class extends AsyncResource {
    static bind (fn, type, thisArg) {
      type = type || fn.name
      return (new exports.AsyncResource(type || 'bound-anonymous-fn')).bind(fn, thisArg)
    }

    bind (fn, thisArg) {
      let bound
      if (thisArg === undefined) {
        const resource = this
        bound = function (...args) {
          args.unshift(fn, this)
          return Reflect.apply(resource.runInAsyncScope, resource, args)
        }
      } else {
        bound = this.runInAsyncScope.bind(this, fn, thisArg)
      }
      Object.defineProperties(bound, {
        'length': {
          configurable: true,
          enumerable: false,
          value: fn.length,
          writable: false
        },
        'asyncResource': {
          configurable: true,
          enumerable: true,
          value: this,
          writable: true
        }
      })
      return bound
    }
  }
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/module.js */ "../../node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/helpers/promise.js":
/*!*************************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-instrumentations/src/helpers/promise.js ***!
  \*************************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const { AsyncResource } = __webpack_require__(/*! async_hooks */ "async_hooks")

exports.wrapThen = function wrapThen (origThen) {
  return function then (onFulfilled, onRejected, onProgress) {
    const ar = new AsyncResource('bound-anonymous-fn')

    arguments[0] = wrapCallback(ar, onFulfilled)
    arguments[1] = wrapCallback(ar, onRejected)

    // not standard but sometimes supported
    if (onProgress) {
      arguments[2] = wrapCallback(ar, onProgress)
    }

    return origThen.apply(this, arguments)
  }
}

function wrapCallback (ar, callback) {
  if (typeof callback !== 'function') return callback

  return function () {
    return ar.runInAsyncScope(() => {
      return callback.apply(this, arguments)
    })
  }
}


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/http.js":
/*!**************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-instrumentations/src/http.js ***!
  \**************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(/*! ./http/client */ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/http/client.js")
__webpack_require__(/*! ./http/server */ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/http/server.js")


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/http/client.js":
/*!*********************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-instrumentations/src/http/client.js ***!
  \*********************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* eslint-disable no-fallthrough */

const url = __webpack_require__(/*! url */ "url")
const {
  channel,
  addHook,
  AsyncResource
} = __webpack_require__(/*! ../helpers/instrument */ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/helpers/instrument.js")
const shimmer = __webpack_require__(/*! ../../../datadog-shimmer */ "../../node_modules/dd-trace/packages/datadog-shimmer/index.js")

const log = __webpack_require__(/*! ../../../dd-trace/src/log */ "../../node_modules/dd-trace/packages/dd-trace/src/log.js")

const startClientCh = channel('apm:http:client:request:start')
const asyncEndClientCh = channel('apm:http:client:request:async-end')
const endClientCh = channel('apm:http:client:request:end')
const errorClientCh = channel('apm:http:client:request:error')

addHook({ name: 'https' }, hookFn)

addHook({ name: 'http' }, hookFn)

function hookFn (http) {
  patch(http, 'request')
  patch(http, 'get')

  return http
}

function patch (http, methodName) {
  shimmer.wrap(http, methodName, instrumentRequest)

  function instrumentRequest (request) {
    return function () {
      if (!startClientCh.hasSubscribers) {
        return request.apply(this, arguments)
      }
      const asyncResource = new AsyncResource('bound-anonymous-fn')

      let args

      try {
        args = normalizeArgs.apply(null, arguments)
      } catch (e) {
        log.error(e)
        return request.apply(this, arguments)
      }
      startClientCh.publish({ args, http })

      const ar = new AsyncResource('bound-anonymous-fn')

      let finished = false
      let callback = args.callback

      if (callback) {
        callback = asyncResource.bind(callback)
      }

      const options = args.options
      const req = ar.bind(request).call(this, options, callback)
      const emit = req.emit

      const finish = (req, res) => {
        if (!finished) {
          finished = true
          asyncEndClientCh.publish({ req, res })
        }
      }

      req.emit = function (eventName, arg) {
        ar.runInAsyncScope(() => {
          switch (eventName) {
            case 'response': {
              const res = arg
              const listener = ar.bind(() => finish(req, res))
              res.on('end', listener)
              res.on('error', listener)
              break
            }
            case 'connect':
            case 'upgrade':
              finish(req, arg)
              break
            case 'error':
              errorClientCh.publish(arg)
            case 'abort': // deprecated and replaced by `close` in node 17
            case 'timeout':
            case 'close':
              finish(req)
          }
        })

        return emit.apply(this, arguments)
      }

      endClientCh.publish(undefined)

      return req
    }
  }

  function normalizeArgs (inputURL, inputOptions, cb) {
    inputURL = normalizeOptions(inputURL)

    const [callback, inputOptionsNormalized] = normalizeCallback(inputOptions, cb, inputURL)
    const options = combineOptions(inputURL, inputOptionsNormalized)
    normalizeHeaders(options)
    const uri = url.format(options)

    return { uri, options, callback }
  }

  function combineOptions (inputURL, inputOptions) {
    if (typeof inputOptions === 'object') {
      return Object.assign(inputURL || {}, inputOptions)
    } else {
      return inputURL
    }
  }
  function normalizeHeaders (options) {
    options.headers = options.headers || {}
  }

  function normalizeCallback (inputOptions, callback, inputURL) {
    if (typeof inputOptions === 'function') {
      return [inputOptions, inputURL || {}]
    } else {
      return [callback, inputOptions]
    }
  }

  function normalizeOptions (inputURL) {
    if (typeof inputURL === 'string') {
      try {
        return urlToOptions(new url.URL(inputURL))
      } catch (e) {
        return url.parse(inputURL)
      }
    } else if (inputURL instanceof url.URL) {
      return urlToOptions(inputURL)
    } else {
      return inputURL
    }
  }

  function urlToOptions (url) {
    const agent = url.agent || http.globalAgent
    const options = {
      protocol: url.protocol || agent.protocol,
      hostname: typeof url.hostname === 'string' && url.hostname.startsWith('[')
        ? url.hostname.slice(1, -1)
        : url.hostname ||
          url.host ||
          'localhost',
      hash: url.hash,
      search: url.search,
      pathname: url.pathname,
      path: `${url.pathname || ''}${url.search || ''}`,
      href: url.href
    }
    if (url.port !== '') {
      options.port = Number(url.port)
    }
    if (url.username || url.password) {
      options.auth = `${url.username}:${url.password}`
    }
    return options
  }
}


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/http/server.js":
/*!*********************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-instrumentations/src/http/server.js ***!
  \*********************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const {
  channel,
  addHook
} = __webpack_require__(/*! ../helpers/instrument */ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/helpers/instrument.js")
const shimmer = __webpack_require__(/*! ../../../datadog-shimmer */ "../../node_modules/dd-trace/packages/datadog-shimmer/index.js")

const startServerCh = channel('apm:http:server:request:start')
const endServerCh = channel('apm:http:server:request:end')
const errorServerCh = channel('apm:http:server:request:error')
const asyncEndServerCh = channel('apm:http:server:request:async-end')

addHook({ name: 'https' }, http => {
  // http.ServerResponse not present on https
  shimmer.wrap(http.Server.prototype, 'emit', wrapEmit)
  return http
})

addHook({ name: 'http' }, http => {
  shimmer.wrap(http.ServerResponse.prototype, 'emit', wrapResponseEmit)
  shimmer.wrap(http.Server.prototype, 'emit', wrapEmit)
  return http
})

function wrapResponseEmit (emit) {
  return function (eventName, event) {
    if (!startServerCh.hasSubscribers) {
      return emit.apply(this, arguments)
    }

    if (eventName === 'finish') {
      asyncEndServerCh.publish({ req: this.req })
    }

    return emit.apply(this, arguments)
  }
}
function wrapEmit (emit) {
  return function (eventName, req, res) {
    if (!startServerCh.hasSubscribers) {
      return emit.apply(this, arguments)
    }

    if (eventName === 'request') {
      res.req = req
      startServerCh.publish({ req, res })

      try {
        return emit.apply(this, arguments)
      } catch (err) {
        errorServerCh.publish(err)

        throw err
      } finally {
        endServerCh.publish(undefined)
      }
    }
    return emit.apply(this, arguments)
  }
}


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/ioredis.js":
/*!*****************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-instrumentations/src/ioredis.js ***!
  \*****************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const {
  channel,
  addHook,
  AsyncResource
} = __webpack_require__(/*! ./helpers/instrument */ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/helpers/instrument.js")
const shimmer = __webpack_require__(/*! ../../datadog-shimmer */ "../../node_modules/dd-trace/packages/datadog-shimmer/index.js")

const startCh = channel('apm:ioredis:command:start')
const asyncEndCh = channel('apm:ioredis:command:async-end')
const endCh = channel('apm:ioredis:command:end')
const errorCh = channel('apm:ioredis:command:error')

addHook({ name: 'ioredis', versions: ['>=2'] }, Redis => {
  shimmer.wrap(Redis.prototype, 'sendCommand', sendCommand => function (command, stream) {
    if (!startCh.hasSubscribers) return sendCommand.apply(this, arguments)

    if (!command || !command.promise) return sendCommand.apply(this, arguments)

    const options = this.options || {}
    const connectionName = options.connectionName
    const db = options.db
    const connectionOptions = { host: options.host, port: options.port }

    startCh.publish({ db, command: command.name, args: command.args, connectionOptions, connectionName })

    const asyncResource = new AsyncResource('bound-anonymous-fn')
    const onResolve = asyncResource.bind(() => finish(asyncEndCh, errorCh))
    const onReject = asyncResource.bind(err => finish(asyncEndCh, errorCh, err))

    command.promise.then(onResolve, onReject)

    try {
      return sendCommand.apply(this, arguments)
    } catch (err) {
      errorCh.publish(err)

      throw err
    } finally {
      endCh.publish(undefined)
    }
  })
  return Redis
})

function finish (asyncEndCh, errorCh, error) {
  if (error) {
    errorCh.publish(error)
  }
  asyncEndCh.publish(undefined)
}


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/memcached.js":
/*!*******************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-instrumentations/src/memcached.js ***!
  \*******************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const {
  channel,
  addHook,
  AsyncResource
} = __webpack_require__(/*! ./helpers/instrument */ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/helpers/instrument.js")
const shimmer = __webpack_require__(/*! ../../datadog-shimmer */ "../../node_modules/dd-trace/packages/datadog-shimmer/index.js")

addHook({ name: 'memcached', versions: ['>=2.2'] }, Memcached => {
  const startCh = channel('apm:memcached:command:start')
  const startWithArgsCh = channel('apm:memcached:command:start:with-args')
  const asyncEndCh = channel('apm:memcached:command:async-end')
  const endCh = channel('apm:memcached:command:end')
  const errorCh = channel('apm:memcached:command:error')

  shimmer.wrap(Memcached.prototype, 'command', command => function (queryCompiler, server) {
    if (!startCh.hasSubscribers) {
      return command.apply(this, arguments)
    }

    const asyncResource = new AsyncResource('bound-anonymous-fn')

    const client = this

    const wrappedQueryCompiler = function () {
      const query = queryCompiler.apply(this, arguments)
      const callback = asyncResource.bind(query.callback)

      query.callback = AsyncResource.bind(function (err) {
        if (err) {
          errorCh.publish(err)
        }
        asyncEndCh.publish(undefined)

        return callback.apply(this, arguments)
      })
      startWithArgsCh.publish({ client, server, query })

      return query
    }

    startCh.publish(undefined)

    arguments[0] = wrappedQueryCompiler

    const result = command.apply(this, arguments)
    endCh.publish(undefined)
    return result
  })

  return Memcached
})


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/mocha.js":
/*!***************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-instrumentations/src/mocha.js ***!
  \***************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

const { addHook, channel, AsyncResource } = __webpack_require__(/*! ./helpers/instrument */ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/helpers/instrument.js")
const shimmer = __webpack_require__(/*! ../../datadog-shimmer */ "../../node_modules/dd-trace/packages/datadog-shimmer/index.js")

const testStartCh = channel('ci:mocha:test:start')
const errorCh = channel('ci:mocha:test:error')
const skipCh = channel('ci:mocha:test:skip')
const testEndCh = channel('ci:mocha:test:end')
const testAsyncEndCh = channel('ci:mocha:test:async-end')
const suiteEndCh = channel('ci:mocha:suite:end')
const hookErrorCh = channel('ci:mocha:hook:error')
const parameterizedTestCh = channel('ci:mocha:test:parameterize')
const testRunEndCh = channel('ci:mocha:run:end')

// TODO: remove when root hooks and fixtures are implemented
const patched = new WeakSet()

function isRetry (test) {
  return test._currentRetry !== undefined && test._currentRetry !== 0
}

function getAllTestsInSuite (root) {
  const tests = []
  function getTests (suiteOrTest) {
    suiteOrTest.tests.forEach(test => {
      tests.push(test)
    })
    suiteOrTest.suites.forEach(suite => {
      getTests(suite)
    })
  }
  getTests(root)
  return tests
}

function mochaHook (Runner) {
  if (patched.has(Runner)) return Runner

  patched.add(Runner)

  shimmer.wrap(Runner.prototype, 'runTest', runTest => function () {
    if (!testStartCh.hasSubscribers) {
      return runTest.apply(this, arguments)
    }

    if (!isRetry(this.test)) {
      testStartCh.publish(this.test)
    }

    this.once('test end', AsyncResource.bind(() => {
      let status

      if (this.test.pending) {
        status = 'skipped'
      } else if (this.test.state !== 'failed' && !this.test.timedOut) {
        status = 'pass'
      } else {
        status = 'fail'
      }

      testAsyncEndCh.publish(status)
    }))

    this.once('fail', AsyncResource.bind((test, err) => {
      errorCh.publish(err)
    }))

    this.once('pending', AsyncResource.bind((test) => {
      skipCh.publish(test)
    }))

    try {
      return runTest.apply(this, arguments)
    } catch (err) {
      errorCh.publish(err)
      throw err
    } finally {
      testEndCh.publish(undefined)
    }
  })

  shimmer.wrap(Runner.prototype, 'runTests', runTests => function () {
    if (!suiteEndCh.hasSubscribers) {
      return runTests.apply(this, arguments)
    }
    this.once('end', AsyncResource.bind(() => {
      testRunEndCh.publish(undefined)
    }))
    runTests.apply(this, arguments)
    const suite = arguments[0]
    // We call `getAllTestsInSuite` with the root suite so every skipped test
    // should already have an associated test span.
    const tests = getAllTestsInSuite(suite)
    suiteEndCh.publish(tests)
  })

  shimmer.wrap(Runner.prototype, 'fail', fail => function (hook, error) {
    if (!hookErrorCh.hasSubscribers) {
      return fail.apply(this, arguments)
    }
    if (error && hook.ctx && hook.ctx.currentTest) {
      error.message = `${hook.title}: ${error.message}`
      hookErrorCh.publish({ test: hook.ctx.currentTest, error })
    }
    return fail.apply(this, arguments)
  })

  return Runner
}

function mochaEachHook (mochaEach) {
  if (patched.has(mochaEach)) return mochaEach

  patched.add(mochaEach)

  return shimmer.wrap(mochaEach, function () {
    const [params] = arguments
    const { it, ...rest } = mochaEach.apply(this, arguments)
    return {
      it: function (name) {
        parameterizedTestCh.publish({ name, params })
        it.apply(this, arguments)
      },
      ...rest
    }
  })
}

addHook({
  name: 'mocha',
  versions: ['>=5.2.0'],
  file: 'lib/runner.js'
}, mochaHook)

addHook({
  name: 'mocha-each',
  versions: ['>=2.0.1']
}, mochaEachHook)

module.exports = { mochaHook, mochaEachHook }


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/mongodb-core.js":
/*!**********************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-instrumentations/src/mongodb-core.js ***!
  \**********************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const {
  channel,
  addHook,
  AsyncResource
} = __webpack_require__(/*! ./helpers/instrument */ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/helpers/instrument.js")
const shimmer = __webpack_require__(/*! ../../datadog-shimmer */ "../../node_modules/dd-trace/packages/datadog-shimmer/index.js")

const startCh = channel(`apm:mongodb:query:start`)
const endCh = channel(`apm:mongodb:query:end`)
const asyncEndCh = channel(`apm:mongodb:query:async-end`)
const errorCh = channel(`apm:mongodb:query:error`)

addHook({ name: 'mongodb-core', versions: ['2 - 3.1.9'] }, Server => {
  const serverProto = Server.Server.prototype
  shimmer.wrap(serverProto, 'command', command => wrapCommand(command, 'command'))
  shimmer.wrap(serverProto, 'insert', insert => wrapCommand(insert, 'insert', 'insert'))
  shimmer.wrap(serverProto, 'update', update => wrapCommand(update, 'update', 'update'))
  shimmer.wrap(serverProto, 'remove', remove => wrapCommand(remove, 'remove', 'remove'))

  const cursorProto = Server.Cursor.prototype
  shimmer.wrap(cursorProto, '_getmore', _getmore => wrapCursor(_getmore, 'getMore', 'getMore'))
  shimmer.wrap(cursorProto, '_find', _find => wrapQuery(_find, '_find'))
  shimmer.wrap(cursorProto, 'kill', kill => wrapCursor(kill, 'killCursors', 'killCursors'))
  return Server
})

addHook({ name: 'mongodb', versions: ['>=4'], file: 'lib/cmap/connection.js' }, Connection => {
  const proto = Connection.Connection.prototype
  shimmer.wrap(proto, 'command', command => wrapConnectionCommand(command, 'command'))
  shimmer.wrap(proto, 'query', query => wrapConnectionCommand(query, 'query'))
  return Connection
})

addHook({ name: 'mongodb', versions: ['>=3.3 <4'], file: 'lib/core/wireprotocol/index.js' }, wp => wrapWp(wp))

addHook({ name: 'mongodb-core', versions: ['>=3.2'], file: 'lib/wireprotocol/index.js' }, wp => wrapWp(wp))

addHook({ name: 'mongodb-core', versions: ['~3.1.10'], file: 'lib/wireprotocol/3_2_support.js' }, WireProtocol => {
  shimmer.wrap(WireProtocol.prototype, 'command', command => wrapUnifiedCommand(command, 'command'))
  return WireProtocol
})

addHook({ name: 'mongodb-core', versions: ['~3.1.10'], file: 'lib/wireprotocol/2_6_support.js' }, WireProtocol => {
  shimmer.wrap(WireProtocol.prototype, 'command', command => wrapUnifiedCommand(command, 'command'))
  return WireProtocol
})

addHook({ name: 'mongodb', versions: ['>=3.5.4'], file: 'lib/utils.js' }, util => {
  shimmer.wrap(util, 'maybePromise', maybePromise => function (parent, callback, fn) {
    const asyncResource = new AsyncResource('bound-anonymous-fn')
    const callbackIndex = arguments.length - 2

    callback = arguments[callbackIndex]

    if (typeof callback === 'function') {
      arguments[callbackIndex] = asyncResource.bind(callback)
    }

    return maybePromise.apply(this, arguments)
  })
  return util
})

function wrapWp (wp) {
  shimmer.wrap(wp, 'command', command => wrapUnifiedCommand(command, 'command'))
  shimmer.wrap(wp, 'insert', insert => wrapUnifiedCommand(insert, 'insert', 'insert'))
  shimmer.wrap(wp, 'update', update => wrapUnifiedCommand(update, 'update', 'update'))
  shimmer.wrap(wp, 'remove', remove => wrapUnifiedCommand(remove, 'remove', 'remove'))
  shimmer.wrap(wp, 'query', query => wrapUnifiedCommand(query, 'query'))
  shimmer.wrap(wp, 'getMore', getMore => wrapUnifiedCommand(getMore, 'getMore', 'getMore'))
  shimmer.wrap(wp, 'killCursors', killCursors => wrapUnifiedCommand(killCursors, 'killCursors', 'killCursors'))
  return wp
}

function wrapUnifiedCommand (command, operation, name) {
  const wrapped = function (server, ns, ops) {
    if (!startCh.hasSubscribers) {
      return command.apply(this, arguments)
    }
    const asyncResource = new AsyncResource('bound-anonymous-fn')
    return instrument(asyncResource, operation, command, this, arguments, server, ns, ops, { name })
  }
  return shimmer.wrap(command, wrapped)
}

function wrapConnectionCommand (command, operation, name) {
  const wrapped = function (ns, ops) {
    if (!startCh.hasSubscribers) {
      return command.apply(this, arguments)
    }
    const asyncResource = new AsyncResource('bound-anonymous-fn')
    const hostParts = typeof this.address === 'string' ? this.address.split(':') : ''
    const options = hostParts.length === 2
      ? { host: hostParts[0], port: hostParts[1] }
      : {} // no port means the address is a random UUID so no host either
    const topology = { s: { options } }

    ns = `${ns.db}.${ns.collection}`
    return instrument(asyncResource, operation, command, this, arguments, topology, ns, ops, { name })
  }
  return shimmer.wrap(command, wrapped)
}

function wrapQuery (query, operation, name) {
  const wrapped = function () {
    if (!startCh.hasSubscribers) {
      return query.apply(this, arguments)
    }
    const asyncResource = new AsyncResource('bound-anonymous-fn')
    const pool = this.server.s.pool
    const ns = this.ns
    const ops = this.cmd
    return instrument(asyncResource, operation, query, this, arguments, pool, ns, ops)
  }

  return shimmer.wrap(query, wrapped)
}

function wrapCursor (cursor, operation, name) {
  const wrapped = function () {
    if (!startCh.hasSubscribers) {
      return cursor.apply(this, arguments)
    }
    const asyncResource = new AsyncResource('bound-anonymous-fn')
    const pool = this.server.s.pool
    const ns = this.ns
    return instrument(asyncResource, operation, cursor, this, arguments, pool, ns, {}, { name })
  }
  return shimmer.wrap(cursor, wrapped)
}

function wrapCommand (command, operation, name) {
  const wrapped = function (ns, ops) {
    if (!startCh.hasSubscribers) {
      return command.apply(this, arguments)
    }
    const asyncResource = new AsyncResource('bound-anonymous-fn')
    return instrument(asyncResource, operation, command, this, arguments, this, ns, ops, { name })
  }
  return shimmer.wrap(command, wrapped)
}

function instrument (ar, operation, command, ctx, args, server, ns, ops, options = {}) {
  const name = options.name || (ops && Object.keys(ops)[0])
  const index = args.length - 1
  let callback = args[index]

  if (typeof callback !== 'function') return command.apply(ctx, args)

  callback = ar.bind(callback)

  const serverInfo = server && server.s && server.s.options

  startCh.publish({ ns, ops, options: serverInfo, name })

  args[index] = AsyncResource.bind(function (err, res) {
    if (err) {
      errorCh.publish(err)
    }

    asyncEndCh.publish(undefined)

    if (callback) {
      return callback.apply(this, arguments)
    }
  })

  try {
    return command.apply(ctx, args)
  } catch (err) {
    errorCh.publish(err)

    throw err
  } finally {
    endCh.publish(undefined)
  }
}


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/mongoose.js":
/*!******************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-instrumentations/src/mongoose.js ***!
  \******************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const { addHook } = __webpack_require__(/*! ./helpers/instrument */ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/helpers/instrument.js")
const { wrapThen } = __webpack_require__(/*! ./helpers/promise */ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/helpers/promise.js")
const { AsyncResource } = __webpack_require__(/*! ./helpers/instrument */ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/helpers/instrument.js")
const shimmer = __webpack_require__(/*! ../../datadog-shimmer */ "../../node_modules/dd-trace/packages/datadog-shimmer/index.js")

function wrapAddQueue (addQueue) {
  return function addQueueWithTrace (name) {
    if (typeof name === 'function') {
      arguments[0] = AsyncResource.bind(name)
    } else if (typeof this[name] === 'function') {
      arguments[0] = AsyncResource.bind((...args) => this[name](...args))
    }

    return addQueue.apply(this, arguments)
  }
}

addHook({
  name: 'mongoose',
  versions: ['>=4.6.4']
}, mongoose => {
  if (mongoose.Promise !== global.Promise) {
    shimmer.wrap(mongoose.Promise.prototype, 'then', wrapThen)
  }

  shimmer.wrap(mongoose.Collection.prototype, 'addQueue', wrapAddQueue)
  return mongoose
})


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/mysql.js":
/*!***************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-instrumentations/src/mysql.js ***!
  \***************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const {
  channel,
  addHook,
  AsyncResource
} = __webpack_require__(/*! ./helpers/instrument */ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/helpers/instrument.js")
const shimmer = __webpack_require__(/*! ../../datadog-shimmer */ "../../node_modules/dd-trace/packages/datadog-shimmer/index.js")

addHook({ name: 'mysql', file: 'lib/Connection.js', versions: ['>=2'] }, Connection => {
  const startCh = channel('apm:mysql:query:start')
  const asyncEndCh = channel('apm:mysql:query:async-end')
  const endCh = channel('apm:mysql:query:end')
  const errorCh = channel('apm:mysql:query:error')

  shimmer.wrap(Connection.prototype, 'query', query => function () {
    const asyncResource = new AsyncResource('bound-anonymous-fn')
    if (!startCh.hasSubscribers) {
      return query.apply(this, arguments)
    }

    const sql = arguments[0].sql ? arguments[0].sql : arguments[0]
    const conf = this.config

    startCh.publish({ sql, conf })

    try {
      const res = query.apply(this, arguments)

      if (res._callback) {
        const cb = asyncResource.bind(res._callback)
        res._callback = AsyncResource.bind(function (error, result) {
          if (error) {
            errorCh.publish(error)
          }
          asyncEndCh.publish(result)

          return cb.apply(this, arguments)
        })
      } else {
        const cb = AsyncResource.bind(function () {
          asyncEndCh.publish(undefined)
        })
        res.on('end', cb)
      }

      return res
    } catch (err) {
      err.stack // trigger getting the stack at the original throwing point
      errorCh.publish(err)

      throw err
    } finally {
      endCh.publish(undefined)
    }
  })

  return Connection
})

addHook({ name: 'mysql', file: 'lib/Pool.js', versions: ['>=2'] }, Pool => {
  shimmer.wrap(Pool.prototype, 'getConnection', getConnection => function (cb) {
    arguments[0] = AsyncResource.bind(cb)
    return getConnection.apply(this, arguments)
  })
  return Pool
})


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/mysql2.js":
/*!****************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-instrumentations/src/mysql2.js ***!
  \****************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const {
  channel,
  addHook,
  AsyncResource
} = __webpack_require__(/*! ./helpers/instrument */ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/helpers/instrument.js")
const shimmer = __webpack_require__(/*! ../../datadog-shimmer */ "../../node_modules/dd-trace/packages/datadog-shimmer/index.js")

addHook({ name: 'mysql2', file: 'lib/connection.js', versions: ['>=1'] }, Connection => {
  const startCh = channel('apm:mysql2:query:start')
  const asyncEndCh = channel('apm:mysql2:query:async-end')
  const endCh = channel('apm:mysql2:query:end')
  const errorCh = channel('apm:mysql2:query:error')

  shimmer.wrap(Connection.prototype, 'addCommand', addCommand => function (cmd) {
    if (!startCh.hasSubscribers) return addCommand.apply(this, arguments)

    const asyncResource = new AsyncResource('bound-anonymous-fn')
    const name = cmd && cmd.constructor && cmd.constructor.name
    const isCommand = typeof cmd.execute === 'function'
    const isQuery = isCommand && (name === 'Execute' || name === 'Query')

    // TODO: consider supporting all commands and not just queries
    cmd.execute = isQuery
      ? wrapExecute(cmd, cmd.execute, asyncResource, this.config)
      : bindExecute(cmd, cmd.execute, asyncResource)

    return asyncResource.bind(addCommand, this).apply(this, arguments)
  })

  return Connection

  function bindExecute (cmd, execute, asyncResource) {
    return asyncResource.bind(function executeWithTrace (packet, connection) {
      if (this.onResult) {
        this.onResult = asyncResource.bind(this.onResult)
      }

      return execute.apply(this, arguments)
    }, cmd)
  }

  function wrapExecute (cmd, execute, asyncResource, config) {
    return asyncResource.bind(function executeWithTrace (packet, connection) {
      const sql = cmd.statement ? cmd.statement.query : cmd.sql

      startCh.publish({ sql, conf: config })

      if (this.onResult) {
        const onResult = asyncResource.bind(this.onResult)

        this.onResult = AsyncResource.bind(function (error) {
          if (error) {
            errorCh.publish(error)
          }
          asyncEndCh.publish(undefined)
          onResult.apply(this, arguments)
        }, 'bound-anonymous-fn', this)
      } else {
        this.on('error', AsyncResource.bind(error => errorCh.publish(error)))
        this.on('end', AsyncResource.bind(() => asyncEndCh.publish(undefined)))
      }

      this.execute = execute

      try {
        return execute.apply(this, arguments)
      } catch (err) {
        errorCh.publish(err)
      } finally {
        endCh.publish(undefined)
      }
    }, cmd)
  }
})


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/net.js":
/*!*************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-instrumentations/src/net.js ***!
  \*************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const {
  channel,
  addHook,
  AsyncResource
} = __webpack_require__(/*! ./helpers/instrument */ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/helpers/instrument.js")
const shimmer = __webpack_require__(/*! ../../datadog-shimmer */ "../../node_modules/dd-trace/packages/datadog-shimmer/index.js")

const startICPCh = channel('apm:net:ipc:start')
const asyncICPEndCh = channel('apm:net:ipc:async-end')
const endICPCh = channel('apm:net:ipc:end')
const errorICPCh = channel('apm:net:ipc:error')

const startTCPCh = channel('apm:net:tcp:start')
const asyncTCPEndCh = channel('apm:net:tcp:async-end')
const endTCPCh = channel('apm:net:tcp:end')
const errorTCPCh = channel('apm:net:tcp:error')

const connectionCh = channel(`apm:net:tcp:connection`)

addHook({ name: 'net' }, net => {
  __webpack_require__(/*! dns */ "dns")

  shimmer.wrap(net.Socket.prototype, 'connect', connect => function () {
    if (!startICPCh.hasSubscribers || !startTCPCh.hasSubscribers) {
      return connect.apply(this, arguments)
    }

    const options = getOptions(arguments)
    const lastIndex = arguments.length - 1
    const callback = arguments[lastIndex]

    if (!options) return connect.apply(this, arguments)

    const asyncResource = new AsyncResource('bound-anonymous-fn')

    if (typeof callback === 'function') {
      arguments[lastIndex] = asyncResource.bind(callback)
    }

    const protocol = options.path ? 'ipc' : 'tcp'

    if (protocol === 'ipc') {
      startICPCh.publish({ options })
      setupListeners(this, 'ipc', asyncResource)
    } else {
      startTCPCh.publish({ options })
      setupListeners(this, 'tcp', asyncResource)
    }

    try {
      return connect.apply(this, arguments)
    } catch (err) {
      protocol === 'ipc' ? errorICPCh.publish(err) : errorTCPCh.publish(err)

      throw err
    } finally {
      protocol === 'ipc' ? endICPCh.publish(undefined) : endTCPCh.publish(undefined)
    }
  })

  return net
})

function getOptions (args) {
  if (!args[0]) return

  switch (typeof args[0]) {
    case 'object':
      if (Array.isArray(args[0])) return getOptions(args[0])
      return args[0]
    case 'string':
      if (isNaN(parseFloat(args[0]))) {
        return {
          path: args[0]
        }
      }
    case 'number': // eslint-disable-line no-fallthrough
      return {
        port: args[0],
        host: typeof args[1] === 'string' ? args[1] : 'localhost'
      }
  }
}

function setupListeners (socket, protocol, ar) {
  const events = ['connect', 'error', 'close', 'timeout']

  const wrapListener = AsyncResource.bind(function (error) {
    if (error) {
      protocol === 'ipc' ? errorICPCh.publish(error) : errorTCPCh.publish(error)
    }
    protocol === 'ipc' ? asyncICPEndCh.publish(undefined) : asyncTCPEndCh.publish(undefined)
  })

  const localListener = AsyncResource.bind(function () {
    connectionCh.publish({ socket })
  })

  const cleanupListener = function () {
    socket.removeListener('connect', localListener)
    events.forEach(event => {
      socket.removeListener(event, wrapListener)
      socket.removeListener(event, cleanupListener)
    })
  }

  if (protocol === 'tcp') {
    socket.once('connect', localListener)
  }

  events.forEach(event => {
    socket.once(event, wrapListener)
    socket.once(event, cleanupListener)
  })
}


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/pg.js":
/*!************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-instrumentations/src/pg.js ***!
  \************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const {
  channel,
  addHook,
  AsyncResource
} = __webpack_require__(/*! ./helpers/instrument */ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/helpers/instrument.js")
const shimmer = __webpack_require__(/*! ../../datadog-shimmer */ "../../node_modules/dd-trace/packages/datadog-shimmer/index.js")

const startCh = channel('apm:pg:query:start')
const asyncEndCh = channel('apm:pg:query:async-end')
const endCh = channel('apm:pg:query:end')
const errorCh = channel('apm:pg:query:error')

addHook({ name: 'pg', versions: ['>=4'] }, pg => {
  shimmer.wrap(pg.Client.prototype, 'query', query => wrapQuery(query))
  return pg
})

addHook({ name: 'pg', file: 'lib/native/index.js', versions: ['>=4'] }, Client => {
  shimmer.wrap(Client.prototype, 'query', query => wrapQuery(query))
  return Client
})

function wrapQuery (query) {
  return function () {
    if (!startCh.hasSubscribers) {
      return query.apply(this, arguments)
    }

    const asyncResource = new AsyncResource('bound-anonymous-fn')

    const retval = query.apply(this, arguments)

    const queryQueue = this.queryQueue || this._queryQueue
    const activeQuery = this.activeQuery || this._activeQuery
    const pgQuery = queryQueue[queryQueue.length - 1] || activeQuery

    if (!pgQuery) {
      return retval
    }
    const statement = pgQuery.text

    startCh.publish({ params: this.connectionParameters, statement })

    const finish = AsyncResource.bind(function (error) {
      if (error) {
        errorCh.publish(error)
      }
      asyncEndCh.publish(undefined)
    })

    if (pgQuery.callback) {
      const originalCallback = asyncResource.bind(pgQuery.callback)
      pgQuery.callback = function (err, res) {
        finish(err)
        return originalCallback.apply(this, arguments)
      }
    } else if (pgQuery.once) {
      pgQuery
        .once('error', finish)
        .once('end', () => finish())
    } else {
      pgQuery.then(() => finish(), finish)
    }

    try {
      return retval
    } catch (err) {
      errorCh.publish(err)
    } finally {
      endCh.publish(undefined)
    }
  }
}


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/pino.js":
/*!**************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-instrumentations/src/pino.js ***!
  \**************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const {
  channel,
  addHook
} = __webpack_require__(/*! ./helpers/instrument */ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/helpers/instrument.js")
const shimmer = __webpack_require__(/*! ../../datadog-shimmer */ "../../node_modules/dd-trace/packages/datadog-shimmer/index.js")

function wrapPino (symbol, wrapper, pino) {
  return function pinoWithTrace () {
    const instance = pino.apply(this, arguments)

    Object.defineProperty(instance, symbol, {
      configurable: true,
      enumerable: true,
      writable: true,
      value: wrapper(instance[symbol])
    })

    return instance
  }
}

function wrapAsJson (asJson) {
  const ch = channel('apm:pino:log')
  return function asJsonWithTrace (obj, msg, num, time) {
    obj = arguments[0] = obj || {}

    const payload = { message: obj }
    ch.publish(payload)
    arguments[0] = payload.message

    return asJson.apply(this, arguments)
  }
}

function wrapMixin (mixin) {
  const ch = channel('apm:pino:log')
  return function mixinWithTrace () {
    let obj = {}

    if (mixin) {
      obj = mixin.apply(this, arguments)
    }

    const payload = { message: obj }
    ch.publish(payload)

    return payload.message
  }
}

function wrapPrettifyObject (prettifyObject) {
  const ch = channel('apm:pino:log')
  return function prettifyObjectWithTrace (input) {
    const payload = { message: input.input }
    ch.publish(payload)
    input.input = payload.message
    return prettifyObject.apply(this, arguments)
  }
}

function wrapPrettyFactory (prettyFactory) {
  const ch = channel('apm:pino:log')
  return function prettyFactoryWithTrace () {
    const pretty = prettyFactory.apply(this, arguments)
    return function prettyWithTrace (obj) {
      const payload = { message: obj }
      ch.publish(payload)
      arguments[0] = payload.message
      return pretty.apply(this, arguments)
    }
  }
}

addHook({ name: 'pino', versions: ['2 - 3', '4', '>=5 <5.14.0'] }, pino => {
  const asJsonSym = (pino.symbols && pino.symbols.asJsonSym) || 'asJson'

  return shimmer.wrap(pino, wrapPino(asJsonSym, wrapAsJson, pino))
})

addHook({ name: 'pino', versions: ['>=5.14.0 <6.8.0'] }, pino => {
  const mixinSym = pino.symbols.mixinSym

  return shimmer.wrap(pino, wrapPino(mixinSym, wrapMixin, pino))
})

addHook({ name: 'pino', versions: ['>=6.8.0'] }, pino => {
  const mixinSym = pino.symbols.mixinSym

  const wrapped = shimmer.wrap(pino, wrapPino(mixinSym, wrapMixin, pino))
  wrapped.pino = wrapped
  wrapped.default = wrapped

  return wrapped
})

addHook({ name: 'pino-pretty', file: 'lib/utils.js', versions: ['>=3'] }, utils => {
  shimmer.wrap(utils, 'prettifyObject', wrapPrettifyObject)
  return utils
})

addHook({ name: 'pino-pretty', versions: ['1 - 2'] }, prettyFactory => {
  return shimmer.wrap(prettyFactory, wrapPrettyFactory(prettyFactory))
})


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/promise-js.js":
/*!********************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-instrumentations/src/promise-js.js ***!
  \********************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const { addHook } = __webpack_require__(/*! ./helpers/instrument */ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/helpers/instrument.js")
const { wrapThen } = __webpack_require__(/*! ./helpers/promise */ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/helpers/promise.js")
const shimmer = __webpack_require__(/*! ../../datadog-shimmer */ "../../node_modules/dd-trace/packages/datadog-shimmer/index.js")

addHook({
  name: 'promise-js',
  versions: ['>=0.0.3']
}, Promise => {
  if (Promise !== global.Promise) {
    shimmer.wrap(Promise.prototype, 'then', wrapThen)
  }
  return Promise
})


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/promise.js":
/*!*****************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-instrumentations/src/promise.js ***!
  \*****************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const { addHook } = __webpack_require__(/*! ./helpers/instrument */ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/helpers/instrument.js")
const { wrapThen } = __webpack_require__(/*! ./helpers/promise */ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/helpers/promise.js")
const shimmer = __webpack_require__(/*! ../../datadog-shimmer */ "../../node_modules/dd-trace/packages/datadog-shimmer/index.js")

addHook({
  name: 'promise',
  file: 'lib/core.js',
  versions: ['>=7']
}, Promise => {
  shimmer.wrap(Promise.prototype, 'then', wrapThen)
  return Promise
})


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/q.js":
/*!***********************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-instrumentations/src/q.js ***!
  \***********************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const { addHook } = __webpack_require__(/*! ./helpers/instrument */ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/helpers/instrument.js")
const { wrapThen } = __webpack_require__(/*! ./helpers/promise */ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/helpers/promise.js")
const shimmer = __webpack_require__(/*! ../../datadog-shimmer */ "../../node_modules/dd-trace/packages/datadog-shimmer/index.js")

addHook({
  name: 'q',
  versions: ['1']
}, Q => {
  shimmer.wrap(Q.makePromise.prototype, 'then', wrapThen)
  return Q
})

addHook({
  name: 'q',
  versions: ['>=2']
}, Q => {
  shimmer.wrap(Q.Promise.prototype, 'then', wrapThen)
  return Q
})


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/redis.js":
/*!***************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-instrumentations/src/redis.js ***!
  \***************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const {
  channel,
  addHook,
  AsyncResource
} = __webpack_require__(/*! ./helpers/instrument */ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/helpers/instrument.js")
const shimmer = __webpack_require__(/*! ../../datadog-shimmer */ "../../node_modules/dd-trace/packages/datadog-shimmer/index.js")

const startCh = channel('apm:redis:command:start')
const asyncEndCh = channel('apm:redis:command:async-end')
const endCh = channel('apm:redis:command:end')
const errorCh = channel('apm:redis:command:error')

addHook({ name: '@node-redis/client', file: 'dist/lib/client/commands-queue.js', versions: ['>=1'] }, redis => {
  shimmer.wrap(redis.default.prototype, 'addCommand', addCommand => function (command) {
    if (!startCh.hasSubscribers) {
      return addCommand.apply(this, arguments)
    }

    const name = command[0]
    const args = command.slice(1)

    start(this, name, args)

    const res = addCommand.apply(this, arguments)
    const asyncResource = new AsyncResource('bound-anonymous-fn')
    const onResolve = asyncResource.bind(() => finish(asyncEndCh, errorCh))
    const onReject = asyncResource.bind(err => finish(asyncEndCh, errorCh, err))

    res.then(onResolve, onReject)
    endCh.publish(undefined)
    return res
  })
  return redis
})

addHook({ name: 'redis', versions: ['>=2.6 <4'] }, redis => {
  shimmer.wrap(redis.RedisClient.prototype, 'internal_send_command', internalSendCommand => function (options) {
    if (!startCh.hasSubscribers) return internalSendCommand.apply(this, arguments)

    if (!options.callback) return internalSendCommand.apply(this, arguments)

    const asyncResource = new AsyncResource('bound-anonymous-fn')

    const cb = asyncResource.bind(options.callback)

    start(this, options.command, options.args)

    options.callback = AsyncResource.bind(wrapCallback(asyncEndCh, errorCh, cb))

    try {
      return internalSendCommand.apply(this, arguments)
    } catch (err) {
      errorCh.publish(err)

      throw err
    } finally {
      endCh.publish(undefined)
    }
  })
  return redis
})

addHook({ name: 'redis', versions: ['>=0.12 <2.6'] }, redis => {
  shimmer.wrap(redis.RedisClient.prototype, 'send_command', sendCommand => function (command, args, callback) {
    if (!startCh.hasSubscribers) {
      return sendCommand.apply(this, arguments)
    }

    const asyncResource = new AsyncResource('bound-anonymous-fn')

    start(this, command, args)

    if (typeof callback === 'function') {
      const cb = asyncResource.bind(callback)
      arguments[2] = AsyncResource.bind(wrapCallback(asyncEndCh, errorCh, cb))
    } else if (Array.isArray(args) && typeof args[args.length - 1] === 'function') {
      const cb = asyncResource.bind(args[args.length - 1])
      args[args.length - 1] = AsyncResource.bind(wrapCallback(asyncEndCh, errorCh, cb))
    } else {
      arguments[2] = AsyncResource.bind(wrapCallback(asyncEndCh, errorCh))
    }

    try {
      return sendCommand.apply(this, arguments)
    } catch (err) {
      errorCh.publish(err)

      throw err
    } finally {
      endCh.publish(undefined)
    }
  })
  return redis
})

function start (client, command, args) {
  const db = client.selected_db
  const connectionOptions = client.connection_options || client.connection_option || client.connectionOption || {}
  startCh.publish({ db, command, args, connectionOptions })
}

function wrapCallback (asyncEndCh, errorCh, callback) {
  return function (err) {
    finish(asyncEndCh, errorCh, err)
    if (callback) {
      return callback.apply(this, arguments)
    }
  }
}

function finish (asyncEndCh, errorCh, error) {
  if (error) {
    errorCh.publish(error)
  }
  asyncEndCh.publish(undefined)
}


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/rhea.js":
/*!**************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-instrumentations/src/rhea.js ***!
  \**************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const {
  channel,
  addHook,
  AsyncResource
} = __webpack_require__(/*! ./helpers/instrument */ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/helpers/instrument.js")
const shimmer = __webpack_require__(/*! ../../datadog-shimmer */ "../../node_modules/dd-trace/packages/datadog-shimmer/index.js")

const circularBufferConstructor = Symbol('circularBufferConstructor')
const inFlightDeliveries = Symbol('inFlightDeliveries')

const patched = new WeakSet()
const dispatchCh = channel('apm:rhea:dispatch')
const errorCh = channel('apm:rhea:error')
const asyncEndCh = channel('apm:rhea:async-end')
const endCh = channel('apm:rhea:end')

const contexts = new WeakMap()

addHook({ name: 'rhea', versions: ['>=1'], file: 'lib/link.js' }, obj => {
  const startSendCh = channel('apm:rhea:send:start')
  const startReceiveCh = channel('apm:rhea:receive:start')

  const Sender = obj.Sender
  const Receiver = obj.Receiver
  shimmer.wrap(Sender.prototype, 'send', send => function (msg, tag, format) {
    if (!canTrace(this)) {
      // we can't handle disconnects or ending spans, so we can't safely instrument
      return send.apply(this, arguments)
    }

    const { host, port } = getHostAndPort(this.connection)

    const targetAddress = this.options && this.options.target &&
      this.options.target.address ? this.options.target.address : undefined

    startSendCh.publish({ targetAddress, host, port, msg })
    const delivery = send.apply(this, arguments)
    const asyncResource = new AsyncResource('bound-anonymous-fn')
    const context = {
      asyncResource
    }
    contexts.set(delivery, context)

    addToInFlightDeliveries(this.connection, delivery)
    try {
      return delivery
    } catch (err) {
      errorCh.publish(err)

      throw err
    } finally {
      endCh.publish(undefined)
    }
  })

  shimmer.wrap(Receiver.prototype, 'dispatch', dispatch => function (eventName, msgObj) {
    if (!canTrace(this)) {
      // we can't handle disconnects or ending spans, so we can't safely instrument
      return dispatch.apply(this, arguments)
    }

    if (eventName === 'message' && msgObj) {
      startReceiveCh.publish({ msgObj, connection: this.connection })

      if (msgObj.delivery) {
        const asyncResource = new AsyncResource('bound-anonymous-fn')
        const context = {
          asyncResource
        }
        contexts.set(msgObj.delivery, context)
        msgObj.delivery.update = wrapDeliveryUpdate(msgObj.delivery, msgObj.delivery.update)
        addToInFlightDeliveries(this.connection, msgObj.delivery)
      }
      try {
        return dispatch.apply(this, arguments)
      } catch (err) {
        errorCh.publish(err)

        throw err
      } finally {
        endCh.publish(undefined)
      }
    }

    return dispatch.apply(this, arguments)
  })
  return obj
})

addHook({ name: 'rhea', versions: ['>=1'], file: 'lib/connection.js' }, Connection => {
  shimmer.wrap(Connection.prototype, 'dispatch', dispatch => function (eventName, obj) {
    if (eventName === 'disconnected') {
      const error = obj.error || this.saved_error
      if (this[inFlightDeliveries]) {
        this[inFlightDeliveries].forEach(delivery => {
          const context = contexts.get(delivery)
          const asyncResource = context.asyncResource
          asyncResource.runInAsyncScope(() => {
            errorCh.publish(error)
            finish(delivery, null)
          })
        })
      }
    }
    return dispatch.apply(this, arguments)
  })
  return Connection
})

addHook({ name: 'rhea', versions: ['>=1'], file: 'lib/session.js' }, (Session) => {
  patchCircularBuffer(Session.prototype, Session)
  return Session
})

function canTrace (link) {
  return link.connection && link.session && link.session.outgoing
}

function getHostAndPort (connection) {
  let host
  let port
  if (connection && connection.options) {
    host = connection.options.host
    port = connection.options.port
  }
  return { host, port }
}

function wrapDeliveryUpdate (obj, update) {
  const context = contexts.get(obj)
  const asyncResource = context.asyncResource
  if (obj && asyncResource) {
    const cb = asyncResource.bind(update)
    return AsyncResource.bind(function wrappedUpdate (settled, stateData) {
      const state = getStateFromData(stateData)
      dispatchCh.publish({ state })
      return cb.apply(this, arguments)
    })
  }
  return function wrappedUpdate (settled, stateData) {
    return update.apply(this, arguments)
  }
}

function patchCircularBuffer (proto, Session) {
  Object.defineProperty(proto, 'outgoing', {
    configurable: true,
    get () {},
    set (outgoing) {
      delete proto.outgoing // removes the setter on the prototype
      this.outgoing = outgoing // assigns on the instance, like normal
      if (outgoing) {
        let CircularBuffer
        if (outgoing.deliveries) {
          CircularBuffer = outgoing.deliveries.constructor
        }
        if (CircularBuffer && !patched.has(CircularBuffer.prototype)) {
          shimmer.wrap(CircularBuffer.prototype, 'pop_if', popIf => function (fn) {
            arguments[0] = AsyncResource.bind(function (entry) {
              const context = contexts.get(entry)
              const asyncResource = context.asyncResource
              let shouldPop
              if (asyncResource) {
                fn = asyncResource.bind(fn, this)
                shouldPop = fn(entry)
                if (shouldPop && asyncResource) {
                  const remoteState = entry.remote_state
                  const state = remoteState && remoteState.constructor
                    ? entry.remote_state.constructor.composite_type : undefined
                  asyncResource.runInAsyncScope(() => {
                    return finish(entry, state)
                  })
                }
              }

              return shouldPop
            })
            return popIf.apply(this, arguments)
          })
          patched.add(CircularBuffer.prototype)
          const Session = proto.constructor
          if (Session) {
            Session[circularBufferConstructor] = CircularBuffer
          }
        }
      }
    }
  })
}

function addToInFlightDeliveries (connection, delivery) {
  let deliveries = connection[inFlightDeliveries]
  if (!deliveries) {
    deliveries = new Set()
    connection[inFlightDeliveries] = deliveries
  }
  deliveries.add(delivery)
}

function finish (delivery, state) {
  const obj = contexts.get(delivery)
  if (obj) {
    if (state) {
      dispatchCh.publish({ state })
    }
    asyncEndCh.publish(undefined)
    if (obj.connection && obj.connection[inFlightDeliveries]) {
      obj.connection[inFlightDeliveries].delete(delivery)
    }
  }
}

function getStateFromData (stateData) {
  if (stateData && stateData.descriptor && stateData.descriptor) {
    switch (stateData.descriptor.value) {
      case 0x24: return 'accepted'
      case 0x25: return 'rejected'
      case 0x26: return 'released'
      case 0x27: return 'modified'
    }
  }
}


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/sharedb.js":
/*!*****************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-instrumentations/src/sharedb.js ***!
  \*****************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const {
  channel,
  addHook,
  AsyncResource
} = __webpack_require__(/*! ./helpers/instrument */ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/helpers/instrument.js")
const shimmer = __webpack_require__(/*! ../../datadog-shimmer */ "../../node_modules/dd-trace/packages/datadog-shimmer/index.js")

/**
 * @description The enum values in this map are not exposed from ShareDB, so the keys are hard-coded here.
 * The values were derived from: https://github.com/share/sharedb/blob/master/lib/client/connection.js#L196
 */
const READABLE_ACTION_NAMES = {
  hs: 'handshake',
  qf: 'query-fetch',
  qs: 'query-subscribe',
  qu: 'query-unsubscribe',
  bf: 'bulk-fetch',
  bs: 'bulk-subscribe',
  bu: 'bulk-unsubscribe',
  f: 'fetch',
  s: 'subscribe',
  u: 'unsubscribe',
  op: 'op',
  nf: 'snapshot-fetch',
  nt: 'snapshot-fetch-by-ts',
  p: 'presence-broadcast',
  pr: 'presence-request',
  ps: 'presence-subscribe',
  pu: 'presence-unsubscribe'
}

addHook({ name: 'sharedb', versions: ['>=1'], file: 'lib/agent.js' }, Agent => {
  const startCh = channel('apm:sharedb:request:start')
  const asyncEndCh = channel('apm:sharedb:request:async-end')
  const endCh = channel('apm:sharedb:request:end')
  const errorCh = channel('apm:sharedb:request:error')

  shimmer.wrap(Agent.prototype, '_handleMessage', origHandleMessageFn => function (request, callback) {
    const asyncResource = new AsyncResource('bound-anonymous-fn')
    const action = request.a

    const actionName = getReadableActionName(action)

    startCh.publish({ actionName, request })

    callback = asyncResource.bind(callback)

    arguments[1] = AsyncResource.bind(function (error, res) {
      if (error) {
        errorCh.publish(error)
      }
      asyncEndCh.publish({ request, res })

      return callback.apply(this, arguments)
    })

    try {
      return origHandleMessageFn.apply(this, arguments)
    } catch (error) {
      errorCh.publish(error)

      throw error
    } finally {
      endCh.publish(undefined)
    }
  })
  return Agent
})

function getReadableActionName (action) {
  const actionName = READABLE_ACTION_NAMES[action]
  if (actionName === undefined) {
    return action
  }
  return actionName
}


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/tedious.js":
/*!*****************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-instrumentations/src/tedious.js ***!
  \*****************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const {
  channel,
  addHook,
  AsyncResource
} = __webpack_require__(/*! ./helpers/instrument */ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/helpers/instrument.js")
const shimmer = __webpack_require__(/*! ../../datadog-shimmer */ "../../node_modules/dd-trace/packages/datadog-shimmer/index.js")

addHook({ name: 'tedious', versions: [ '>=1.0.0' ] }, tedious => {
  const startCh = channel('apm:tedious:request:start')
  const asyncEndCh = channel('apm:tedious:request:async-end')
  const endCh = channel('apm:tedious:request:end')
  const errorCh = channel('apm:tedious:request:error')
  shimmer.wrap(tedious.Connection.prototype, 'makeRequest', makeRequest => function (request) {
    if (!startCh.hasSubscribers) {
      return request.apply(this, arguments)
    }

    const queryOrProcedure = getQueryOrProcedure(request)

    if (!queryOrProcedure) {
      return makeRequest.apply(this, arguments)
    }

    const asyncResource = new AsyncResource('bound-anonymous-fn')

    const connectionConfig = this.config

    startCh.publish({ queryOrProcedure, connectionConfig })

    const cb = asyncResource.bind(request.callback, request)
    request.callback = AsyncResource.bind(function (error) {
      if (error) {
        errorCh.publish(error)
      }
      asyncEndCh.publish(undefined)

      return cb.apply(this, arguments)
    }, null, request)

    try {
      return makeRequest.apply(this, arguments)
    } catch (error) {
      errorCh.publish(error)

      throw error
    } finally {
      endCh.publish(undefined)
    }
  })

  return tedious
})

function getQueryOrProcedure (request) {
  if (!request.parameters) return

  const statement = request.parametersByName.statement || request.parametersByName.stmt

  if (!statement) {
    return request.sqlTextOrProcedure
  }

  return statement.value
}


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/when.js":
/*!**************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-instrumentations/src/when.js ***!
  \**************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const { addHook } = __webpack_require__(/*! ./helpers/instrument */ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/helpers/instrument.js")
const { wrapThen } = __webpack_require__(/*! ./helpers/promise */ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/helpers/promise.js")
const shimmer = __webpack_require__(/*! ../../datadog-shimmer */ "../../node_modules/dd-trace/packages/datadog-shimmer/index.js")

addHook({
  name: 'when',
  file: 'lib/Promise.js',
  versions: ['>=3']
}, Promise => {
  shimmer.wrap(Promise.prototype, 'then', wrapThen)
  return Promise
})


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/winston.js":
/*!*****************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-instrumentations/src/winston.js ***!
  \*****************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const {
  channel,
  addHook
} = __webpack_require__(/*! ./helpers/instrument */ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/helpers/instrument.js")
const shimmer = __webpack_require__(/*! ../../datadog-shimmer */ "../../node_modules/dd-trace/packages/datadog-shimmer/index.js")

const patched = new WeakSet()

addHook({ name: 'winston', file: 'lib/winston/logger.js', versions: ['>=3'] }, Logger => {
  const logCh = channel('apm:winston:log')
  shimmer.wrap(Logger.prototype, 'write', write => {
    return function wrappedWrite (chunk, enc, cb) {
      if (logCh.hasSubscribers) {
        const payload = { message: chunk }
        logCh.publish(payload)
        arguments[0] = payload.message
      }
      return write.apply(this, arguments)
    }
  })
  return Logger
})

addHook({ name: 'winston', file: 'lib/winston/logger.js', versions: ['1', '2'] }, logger => {
  const logCh = channel('apm:winston:log')
  if (logger.Logger.prototype.configure) {
    shimmer.wrap(logger.Logger.prototype, 'configure', configure => wrapMethod(configure, logCh))
  }
  shimmer.wrap(logger.Logger.prototype, 'add', configure => wrapMethod(configure, logCh))
  return logger
})

function wrapMethod (method, logCh) {
  return function methodWithTrace () {
    const result = method.apply(this, arguments)

    if (logCh.hasSubscribers) {
      for (const name in this.transports) {
        const transport = this.transports[name]

        if (patched.has(transport) || typeof transport.log !== 'function') continue

        const log = transport.log
        transport.log = function wrappedLog (level, msg, meta, callback) {
          const payload = { message: meta || {} }
          logCh.publish(payload)
          arguments[2] = payload.message
          log.apply(this, arguments)
        }
        patched.add(transport)
      }
    }
    return result
  }
}


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-amqp10/src/index.js":
/*!************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-amqp10/src/index.js ***!
  \************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Plugin = __webpack_require__(/*! ../../dd-trace/src/plugins/plugin */ "../../node_modules/dd-trace/packages/dd-trace/src/plugins/plugin.js")
const { storage } = __webpack_require__(/*! ../../datadog-core */ "../../node_modules/dd-trace/packages/datadog-core/index.js")
const analyticsSampler = __webpack_require__(/*! ../../dd-trace/src/analytics_sampler */ "../../node_modules/dd-trace/packages/dd-trace/src/analytics_sampler.js")

class Amqp10Plugin extends Plugin {
  static get name () {
    return 'amqp10'
  }

  constructor (...args) {
    super(...args)

    this.addSub(`apm:amqp10:send:start`, ({ link }) => {
      const address = getAddress(link)
      const target = getShortName(link)

      const store = storage.getStore()
      const childOf = store ? store.span : store

      const span = this.tracer.startSpan('amqp.send', {
        childOf,
        tags: {
          'resource.name': ['send', target].filter(v => v).join(' '),
          'span.kind': 'producer',
          'amqp.link.target.address': target,
          'amqp.link.role': 'sender',
          'out.host': address.host,
          'out.port': address.port,
          'service.name': this.config.service || `${this.tracer._service}-amqp`,
          'amqp.link.name': link.name,
          'amqp.link.handle': link.handle,
          'amqp.connection.host': address.host,
          'amqp.connection.port': address.port,
          'amqp.connection.user': address.user
        }
      })

      analyticsSampler.sample(span, this.config.measured)

      this.enter(span, store)
    })

    this.addSub(`apm:amqp10:send:end`, () => {
      this.exit()
    })

    this.addSub(`apm:amqp10:send:error`, err => {
      const span = storage.getStore().span
      span.setTag('error', err)
    })

    this.addSub(`apm:amqp10:send:async-end`, () => {
      const span = storage.getStore().span
      span.finish()
    })

    this.addSub(`apm:amqp10:receive:start`, ({ link }) => {
      const source = getShortName(link)
      const address = getAddress(link)

      const store = storage.getStore()
      const childOf = store ? store.span : store

      const span = this.tracer.startSpan('amqp.receive', {
        childOf,
        tags: {
          'resource.name': ['receive', source].filter(v => v).join(' '),
          'span.kind': 'consumer',
          'span.type': 'worker',
          'amqp.link.source.address': source,
          'amqp.link.role': 'receiver',
          'service.name': this.config.service || `${this.tracer._service}-amqp`,
          'amqp.link.name': link.name,
          'amqp.link.handle': link.handle,
          'amqp.connection.host': address.host,
          'amqp.connection.port': address.port,
          'amqp.connection.user': address.user
        }
      })

      analyticsSampler.sample(span, this.config.measured)

      this.enter(span, store)
    })

    this.addSub(`apm:amqp10:receive:end`, () => {
      storage.getStore().span.finish()
      this.exit()
    })

    this.addSub(`apm:amqp10:receive:error`, err => {
      const span = storage.getStore().span
      span.setTag('error', err)
    })
  }
}

function getShortName (link) {
  if (!link || !link.name) return null

  return link.name.split('_').slice(0, -1).join('_')
}

function getAddress (link) {
  if (!link || !link.session || !link.session.connection) return {}

  return link.session.connection.address || {}
}

module.exports = Amqp10Plugin


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-amqplib/src/index.js":
/*!*************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-amqplib/src/index.js ***!
  \*************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Plugin = __webpack_require__(/*! ../../dd-trace/src/plugins/plugin */ "../../node_modules/dd-trace/packages/dd-trace/src/plugins/plugin.js")
const { storage } = __webpack_require__(/*! ../../datadog-core */ "../../node_modules/dd-trace/packages/datadog-core/index.js")
const analyticsSampler = __webpack_require__(/*! ../../dd-trace/src/analytics_sampler */ "../../node_modules/dd-trace/packages/dd-trace/src/analytics_sampler.js")
const { TEXT_MAP } = __webpack_require__(/*! ../../../ext/formats */ "../../node_modules/dd-trace/ext/formats.js")

class AmqplibPlugin extends Plugin {
  static get name () {
    return 'amqplib'
  }

  constructor (...args) {
    super(...args)

    this.addSub(`apm:amqplib:command:start`, ({ channel, method, fields, message }) => {
      const store = storage.getStore()
      let childOf

      if (method === 'basic.deliver') {
        childOf = extract(this.tracer, message)
      } else {
        fields.headers = fields.headers || {}
        childOf = store ? store.span : store
      }

      const span = this.tracer.startSpan('amqp.command', {
        childOf,
        tags: {
          'service.name': this.config.service || `${this.tracer._service}-amqp`,
          'resource.name': getResourceName(method, fields)
        }
      })

      if (channel && channel.connection && channel.connection.stream) {
        span.addTags({
          'out.host': channel.connection.stream._host,
          'out.port': channel.connection.stream.remotePort
        })
      }
      const fieldNames = [
        'queue',
        'exchange',
        'routingKey',
        'consumerTag',
        'source',
        'destination'
      ]

      switch (method) {
        case 'basic.publish':
          span.setTag('span.kind', 'producer')
          break
        case 'basic.consume':
        case 'basic.get':
        case 'basic.deliver':
          span.addTags({
            'span.kind': 'consumer',
            'span.type': 'worker'
          })
          break
        default:
          span.setTag('span.kind', 'client')
      }

      fieldNames.forEach(field => {
        fields[field] !== undefined && span.setTag(`amqp.${field}`, fields[field])
      })
      if (method === 'basic.deliver') {
        analyticsSampler.sample(span, this.config.measured, true)
      } else {
        this.tracer.inject(span, TEXT_MAP, fields.headers)
        analyticsSampler.sample(span, this.config.measured)
      }

      this.enter(span, store)
    })

    this.addSub(`apm:amqplib:command:end`, () => {
      const span = storage.getStore().span
      span.finish()
      this.exit()
    })

    this.addSub(`apm:amqplib:command:error`, err => {
      const span = storage.getStore().span
      span.setTag('error', err)
    })
  }
}

function getResourceName (method, fields = {}) {
  return [
    method,
    fields.exchange,
    fields.routingKey,
    fields.queue,
    fields.source,
    fields.destination
  ].filter(val => val).join(' ')
}

function extract (tracer, message) {
  return message
    ? tracer.extract(TEXT_MAP, message.properties.headers)
    : null
}

module.exports = AmqplibPlugin


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/helpers.js":
/*!***************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/helpers.js ***!
  \***************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Tags = __webpack_require__(/*! opentracing */ "../../node_modules/opentracing/lib/index.js").Tags

const services = {
  cloudwatchlogs: getService(__webpack_require__(/*! ./services/cloudwatchlogs */ "../../node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/services/cloudwatchlogs.js")),
  dynamodb: getService(__webpack_require__(/*! ./services/dynamodb */ "../../node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/services/dynamodb.js")),
  kinesis: getService(__webpack_require__(/*! ./services/kinesis */ "../../node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/services/kinesis.js")),
  lambda: getService(__webpack_require__(/*! ./services/lambda */ "../../node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/services/lambda.js")),
  s3: getService(__webpack_require__(/*! ./services/s3 */ "../../node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/services/s3.js")),
  redshift: getService(__webpack_require__(/*! ./services/redshift */ "../../node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/services/redshift.js")),
  sns: getService(__webpack_require__(/*! ./services/sns */ "../../node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/services/sns.js")),
  sqs: getService(__webpack_require__(/*! ./services/sqs */ "../../node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/services/sqs.js")),
  eventbridge: getService(__webpack_require__(/*! ./services/eventbridge */ "../../node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/services/eventbridge.js"))
}

function getService (Service) {
  return new Service()
}

const helpers = {
  finish (config, span, response, err) {
    if (err) {
      span.setTag('error', err)

      if (err.requestId) {
        span.addTags({ 'aws.response.request_id': err.requestId })
      }
    }

    config.hooks.request(span, response)

    span.finish()
  },

  isEnabled (serviceIdentifier, config, request) {
    if (typeof config === 'boolean') {
      return config
    } else if (!config || typeof config !== 'object' || !services[serviceIdentifier]) {
      return true
    }

    return services[serviceIdentifier].isEnabled
      ? services[serviceIdentifier].isEnabled(config, request)
      : true
  },

  addResponseTags (span, response, serviceName) {
    if (!span) return

    if (response.request) {
      this.addServicesTags(span, response, serviceName)
    }
  },

  addServicesTags (span, response, serviceName) {
    if (!span) return

    const params = response.request.params
    const operation = response.request.operation
    const extraTags = services[serviceName] ? services[serviceName].generateTags(params, operation, response) : {}
    const tags = Object.assign({
      'aws.response.request_id': response.requestId,
      'resource.name': operation,
      'span.kind': 'client'
    }, extraTags)

    span.addTags(tags)
  },

  responseExtract (serviceName, request, response, tracer) {
    if (services[serviceName] && services[serviceName].responseExtract) {
      const params = request.params
      const operation = request.operation
      return services[serviceName].responseExtract(params, operation, response, tracer)
    }
  },

  requestInject (span, request, serviceName, tracer) {
    if (!span) return

    const service = services[serviceName] && services[serviceName]
    if (service && service.requestInject) service.requestInject(span, request, tracer)
  },

  wrapCb (cb, serviceName, tags, request, tracer, childOf) {
    const awsHelpers = this
    return function wrappedCb (err, resp) {
      const maybeChildOf = awsHelpers.responseExtract(serviceName, request, resp, tracer)
      if (maybeChildOf) {
        const options = {
          childOf: maybeChildOf,
          tags: Object.assign({}, tags, { [Tags.SPAN_KIND]: 'server' })
        }
        return tracer.wrap('aws.response', options, cb).apply(this, arguments)
      } else {
        return tracer.scope().bind(cb, childOf).apply(this, arguments)
      }
    }
  }
}

module.exports = helpers


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/index.js":
/*!*************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/index.js ***!
  \*************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Tags = __webpack_require__(/*! opentracing */ "../../node_modules/opentracing/lib/index.js").Tags
const analyticsSampler = __webpack_require__(/*! ../../dd-trace/src/analytics_sampler */ "../../node_modules/dd-trace/packages/dd-trace/src/analytics_sampler.js")
const awsHelpers = __webpack_require__(/*! ./helpers */ "../../node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/helpers.js")

function createWrapRequest (tracer, config) {
  config = normalizeConfig(config)
  return function wrapRequest (send) {
    return function requestWithTrace (cb) {
      if (!this.service) return send.apply(this, arguments)

      const serviceIdentifier = this.service.serviceIdentifier

      if (!awsHelpers.isEnabled(serviceIdentifier, config[serviceIdentifier], this)) {
        return send.apply(this, arguments)
      }

      const serviceName = getServiceName(serviceIdentifier, tracer, config)
      const childOf = tracer.scope().active()
      const tags = {
        [Tags.SPAN_KIND]: 'client',
        'service.name': serviceName,
        'aws.operation': this.operation,
        'aws.region': this.service.config && this.service.config.region,
        'aws.service': this.service.api && this.service.api.className,
        'component': 'aws-sdk'
      }

      const span = tracer.startSpan('aws.request', {
        childOf,
        tags
      })

      this.on('complete', response => {
        if (!span) return

        awsHelpers.addResponseTags(span, response, serviceIdentifier, config, tracer)
        awsHelpers.finish(config, span, response, response.error)
      })

      analyticsSampler.sample(span, config.measured)

      awsHelpers.requestInject(span, this, serviceIdentifier, tracer)

      const request = this

      return tracer.scope().activate(span, () => {
        if (typeof cb === 'function') {
          arguments[0] = awsHelpers.wrapCb(cb, serviceIdentifier, tags, request, tracer, childOf)
        }
        return send.apply(this, arguments)
      })
    }
  }
}

function createWrapSetPromisesDependency (tracer, config, instrumenter, AWS) {
  return function wrapSetPromisesDependency (setPromisesDependency) {
    return function setPromisesDependencyWithTrace (dep) {
      const result = setPromisesDependency.apply(this, arguments)

      instrumenter.wrap(AWS.Request.prototype, 'promise', createWrapRequest(tracer, config))

      return result
    }
  }
}

function normalizeConfig (config) {
  const hooks = getHooks(config)

  return Object.assign({}, config, {
    splitByAwsService: config.splitByAwsService !== false,
    hooks
  })
}

function getHooks (config) {
  const noop = () => {}
  const request = (config.hooks && config.hooks.request) || noop

  return { request }
}

// TODO: test splitByAwsService when the test suite is fixed
function getServiceName (serviceIdentifier, tracer, config) {
  return config.service
    ? config.service
    : `${tracer._service}-aws-${serviceIdentifier}`
}

// <2.1.35 has breaking changes for instrumentation
// https://github.com/aws/aws-sdk-js/pull/629
module.exports = [
  {
    name: 'aws-sdk',
    versions: ['>=2.3.0'],
    patch (AWS, tracer, config) {
      this.wrap(AWS.Request.prototype, 'promise', createWrapRequest(tracer, config))
      this.wrap(AWS.config, 'setPromisesDependency', createWrapSetPromisesDependency(tracer, config, this, AWS))
    },
    unpatch (AWS) {
      this.unwrap(AWS.Request.prototype, 'promise')
      this.unwrap(AWS.config, 'setPromisesDependency')
    }
  },
  {
    name: 'aws-sdk',
    versions: ['>=2.1.35'],
    patch (AWS, tracer, config) {
      this.wrap(AWS.Request.prototype, 'send', createWrapRequest(tracer, config))
    },
    unpatch (AWS) {
      this.unwrap(AWS.Request.prototype, 'send')
    }
  }
]


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/services/cloudwatchlogs.js":
/*!*******************************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/services/cloudwatchlogs.js ***!
  \*******************************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


class CloudwatchLogs {
  generateTags (params, operation, response) {
    const tags = {}

    if (!params || !params.logGroupName) return tags

    return Object.assign(tags, {
      'resource.name': `${operation} ${params.logGroupName}`,
      'aws.cloudwatch.logs.log_group_name': params.logGroupName
    })
  }
}

module.exports = CloudwatchLogs


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/services/dynamodb.js":
/*!*************************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/services/dynamodb.js ***!
  \*************************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


class DynamoDb {
  generateTags (params, operation, response) {
    const tags = {}

    if (params) {
      if (params.TableName) {
        Object.assign(tags, {
          'resource.name': `${operation} ${params.TableName}`,
          'aws.dynamodb.table_name': params.TableName
        })
      }

      // batch operations have different format, collect table name for batch
      // https://docs.aws.amazon.com/AWSJavaScriptSDK/latest/AWS/DynamoDB.html#batchGetItem-property`
      // dynamoDB batch TableName
      if (params.RequestItems) {
        if (typeof params.RequestItems === 'object') {
          if (Object.keys(params.RequestItems).length === 1) {
            const tableName = Object.keys(params.RequestItems)[0]

            // also add span type to match serverless convention
            Object.assign(tags, {
              'resource.name': `${operation} ${tableName}`,
              'aws.dynamodb.table_name': tableName
            })
          }
        }
      }

      // TODO: DynamoDB.DocumentClient does batches on multiple tables
      // https://docs.aws.amazon.com/AWSJavaScriptSDK/latest/AWS/DynamoDB/DocumentClient.html#batchGet-property
      // it may be useful to have a different resource naming convention here to show all table names
    }

    // also add span type to match serverless convention
    Object.assign(tags, {
      'span.type': 'dynamodb'
    })

    return tags
  }
}

module.exports = DynamoDb


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/services/eventbridge.js":
/*!****************************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/services/eventbridge.js ***!
  \****************************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

const log = __webpack_require__(/*! ../../../dd-trace/src/log */ "../../node_modules/dd-trace/packages/dd-trace/src/log.js")
class EventBridge {
  generateTags (params, operation, response) {
    if (!params || !params.source) return {}

    return {
      'resource.name': `${operation} ${params.source}`,
      'aws.eventbridge.source': params.source
    }
  }

  /**
   * requestInject
   * @param {*} span
   * @param {*} request
   * @param {*} tracer
   *
   * Docs: https://docs.aws.amazon.com/eventbridge/latest/APIReference/API_PutEventsRequestEntry.html
   * We cannot use the traceHeader field as that's reserved for X-Ray.
   * Detail must be a valid JSON string
   * Max size per event is 256kb (https://docs.aws.amazon.com/eventbridge/latest/userguide/eb-putevent-size.html)
   */
  requestInject (span, request, tracer) {
    const operation = request.operation
    if (operation === 'putEvents' &&
      request.params &&
      request.params.Entries &&
      request.params.Entries.length > 0 &&
      request.params.Entries[0].Detail) {
      try {
        const details = JSON.parse(request.params.Entries[0].Detail)
        details._datadog = {}
        tracer.inject(span, 'text_map', details._datadog)
        const finalData = JSON.stringify(details)
        const byteSize = Buffer.byteLength(finalData)
        if (byteSize >= (1024 * 256)) {
          log.info('Payload size too large to pass context')
          return
        }
        request.params.Entries[0].Detail = finalData
      } catch (e) {
        log.error(e)
      }
    }
  }
}
module.exports = EventBridge


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/services/kinesis.js":
/*!************************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/services/kinesis.js ***!
  \************************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

const log = __webpack_require__(/*! ../../../dd-trace/src/log */ "../../node_modules/dd-trace/packages/dd-trace/src/log.js")
class Kinesis {
  generateTags (params, operation, response) {
    if (!params || !params.StreamName) return {}

    return {
      'resource.name': `${operation} ${params.StreamName}`,
      'aws.kinesis.stream_name': params.StreamName
    }
  }

  // AWS-SDK will b64 kinesis payloads
  // or will accept an already b64 encoded payload
  // This method handles both
  _tryParse (body) {
    try {
      return JSON.parse(body)
    } catch (e) {
      log.info('Not JSON string. Trying Base64 encoded JSON string')
    }
    try {
      return JSON.parse(Buffer.from(body, 'base64').toString('ascii'), true)
    } catch (e) {
      return null
    }
  }

  requestInject (span, request, tracer) {
    const operation = request.operation
    if (operation === 'putRecord' || operation === 'putRecords') {
      if (!request.params) {
        return
      }

      const traceData = {}
      tracer.inject(span, 'text_map', traceData)
      let injectPath
      if (request.params.Records && request.params.Records.length > 0) {
        injectPath = request.params.Records[0]
      } else if (request.params.Data) {
        injectPath = request.params
      } else {
        log.error('No valid payload passed, unable to pass trace context')
        return
      }
      const parsedData = this._tryParse(injectPath.Data)
      if (parsedData) {
        parsedData._datadog = traceData
        const finalData = JSON.stringify(parsedData)
        const byteSize = Buffer.byteLength(finalData, 'ascii')
        // Kinesis max payload size is 1MB
        // So we must ensure adding DD context won't go over that (512b is an estimate)
        if (byteSize >= 1048576) {
          log.info('Payload size too large to pass context')
          return
        }
        injectPath.Data = finalData
      } else {
        log.error('Unable to parse payload, unable to pass trace context')
      }
    }
  }
}

module.exports = Kinesis


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/services/lambda.js":
/*!***********************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/services/lambda.js ***!
  \***********************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const log = __webpack_require__(/*! ../../../dd-trace/src/log */ "../../node_modules/dd-trace/packages/dd-trace/src/log.js")

class Lambda {
  generateTags (params, operation, response) {
    const tags = {}

    if (!params || !params.FunctionName) return tags

    return Object.assign(tags, {
      'resource.name': `${operation} ${params.FunctionName}`,
      'aws.lambda': params.FunctionName
    })
  }

  requestInject (span, request, tracer) {
    const operation = request.operation
    if (operation === 'invoke') {
      if (!request.params) {
        request.params = {}
      }

      const isSyncInvocation = !request.params.InvocationType ||
        request.params.InvocationType === 'RequestResponse'

      if (isSyncInvocation) {
        try {
          // Check to see if there's already a config on the request
          let clientContext = {}
          if (request.params.ClientContext) {
            const clientContextJson = Buffer.from(request.params.ClientContext, 'base64').toString('utf-8')
            clientContext = JSON.parse(clientContextJson)
          }
          if (!clientContext.custom) {
            clientContext.custom = {}
          }
          tracer.inject(span, 'text_map', clientContext.custom)
          const newContextBase64 = Buffer.from(JSON.stringify(clientContext)).toString('base64')
          request.params.ClientContext = newContextBase64
        } catch (err) {
          log.error(err)
        }
      }
    }
  }
}

module.exports = Lambda


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/services/redshift.js":
/*!*************************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/services/redshift.js ***!
  \*************************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


class Redshift {
  generateTags (params, operation, response) {
    const tags = {}

    if (!params || !params.ClusterIdentifier) return tags

    return Object.assign(tags, {
      'resource.name': `${operation} ${params.ClusterIdentifier}`,
      'aws.redshift.cluster_identifier': params.ClusterIdentifier
    })
  }
}

module.exports = Redshift


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/services/s3.js":
/*!*******************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/services/s3.js ***!
  \*******************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


class S3 {
  generateTags (params, operation, response) {
    const tags = {}

    if (!params || !params.Bucket) return tags

    return Object.assign(tags, {
      'resource.name': `${operation} ${params.Bucket}`,
      'aws.s3.bucket_name': params.Bucket
    })
  }
}

module.exports = S3


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/services/sns.js":
/*!********************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/services/sns.js ***!
  \********************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

const log = __webpack_require__(/*! ../../../dd-trace/src/log */ "../../node_modules/dd-trace/packages/dd-trace/src/log.js")

class Sns {
  generateTags (params, operation, response) {
    if (!params) return {}

    if (!params.TopicArn && !(response.data && response.data.TopicArn)) return {}

    return {
      'resource.name': `${operation} ${params.TopicArn || response.data.TopicArn}`,
      'aws.sns.topic_arn': params.TopicArn || response.data.TopicArn
    }

    // TODO: should arn be sanitized or quantized in some way here,
    // for example if it contains a phone number?
  }

  requestInject (span, request, tracer) {
    const operation = request.operation
    if (operation === 'publish' || operation === 'publishBatch') {
      if (!request.params) {
        request.params = {}
      }
      let injectPath
      if (request.params.PublishBatchRequestEntries && request.params.PublishBatchRequestEntries.length > 0) {
        injectPath = request.params.PublishBatchRequestEntries[0]
      } else if (request.params.Message) {
        injectPath = request.params
      }
      if (!injectPath.MessageAttributes) {
        injectPath.MessageAttributes = {}
      }
      if (Object.keys(injectPath.MessageAttributes).length >= 10) { // SNS quota
        log.info('Message attributes full, skipping trace context injection')
        return
      }
      const ddInfo = {}
      tracer.inject(span, 'text_map', ddInfo)
      injectPath.MessageAttributes._datadog = {
        DataType: 'Binary',
        BinaryValue: JSON.stringify(ddInfo) // BINARY types are automatically base64 encoded
      }
    }
  }
}

module.exports = Sns


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/services/sqs.js":
/*!********************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/services/sqs.js ***!
  \********************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const log = __webpack_require__(/*! ../../../dd-trace/src/log */ "../../node_modules/dd-trace/packages/dd-trace/src/log.js")

class Sqs {
  isEnabled (config, request) {
    switch (request.operation) {
      case 'receiveMessage':
        return config.consumer !== false
      case 'sendMessage':
      case 'sendMessageBatch':
        return config.producer !== false
      default:
        return true
    }
  }

  generateTags (params, operation, response) {
    const tags = {}

    if (!params || (!params.QueueName && !params.QueueUrl)) return tags

    Object.assign(tags, {
      'resource.name': `${operation} ${params.QueueName || params.QueueUrl}`,
      'aws.sqs.queue_name': params.QueueName || params.QueueUrl
    })

    switch (operation) {
      case 'receiveMessage':
        tags['span.type'] = 'worker'
        tags['span.kind'] = 'consumer'
        break
      case 'sendMessage':
      case 'sendMessageBatch':
        tags['span.kind'] = 'producer'
        break
    }

    return tags
  }

  responseExtract (params, operation, response, tracer) {
    if (operation === 'receiveMessage') {
      if (
        (!params.MaxNumberOfMessages || params.MaxNumberOfMessages === 1) &&
        response &&
        response.Messages &&
        response.Messages[0] &&
        response.Messages[0].MessageAttributes &&
        response.Messages[0].MessageAttributes._datadog &&
        response.Messages[0].MessageAttributes._datadog.StringValue
      ) {
        const textMap = response.Messages[0].MessageAttributes._datadog.StringValue
        try {
          return tracer.extract('text_map', JSON.parse(textMap))
        } catch (err) {
          log.error(err)
          return undefined
        }
      }
    }
  }

  requestInject (span, request, tracer) {
    const operation = request.operation
    if (operation === 'sendMessage') {
      if (!request.params) {
        request.params = {}
      }
      if (!request.params.MessageAttributes) {
        request.params.MessageAttributes = {}
      } else if (Object.keys(request.params.MessageAttributes).length >= 10) { // SQS quota
        // TODO: add test when the test suite is fixed
        return
      }
      const ddInfo = {}
      tracer.inject(span, 'text_map', ddInfo)
      request.params.MessageAttributes._datadog = {
        DataType: 'String',
        StringValue: JSON.stringify(ddInfo)
      }
    }
  }
}

module.exports = Sqs


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-bunyan/src/index.js":
/*!************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-bunyan/src/index.js ***!
  \************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const LogPlugin = __webpack_require__(/*! ../../dd-trace/src/plugins/log_plugin */ "../../node_modules/dd-trace/packages/dd-trace/src/plugins/log_plugin.js")

class BunyanPlugin extends LogPlugin {
  static get name () {
    return 'bunyan'
  }
}
module.exports = BunyanPlugin


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-cassandra-driver/src/index.js":
/*!**********************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-cassandra-driver/src/index.js ***!
  \**********************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Plugin = __webpack_require__(/*! ../../dd-trace/src/plugins/plugin */ "../../node_modules/dd-trace/packages/dd-trace/src/plugins/plugin.js")
const { storage } = __webpack_require__(/*! ../../datadog-core */ "../../node_modules/dd-trace/packages/datadog-core/index.js")
const analyticsSampler = __webpack_require__(/*! ../../dd-trace/src/analytics_sampler */ "../../node_modules/dd-trace/packages/dd-trace/src/analytics_sampler.js")

class CassandraDriverPlugin extends Plugin {
  static get name () {
    return 'cassandra-driver'
  }
  constructor (...args) {
    super(...args)

    this.addSub(`apm:cassandra:query:start`, ({ keyspace, query, connectionOptions }) => {
      const store = storage.getStore()
      const childOf = store ? store.span : store

      if (Array.isArray(query)) {
        query = combine(query)
      }

      const span = this.tracer.startSpan('cassandra.query', {
        childOf,
        tags: {
          'service.name': this.config.service || `${this.tracer._service}-cassandra`,
          'resource.name': trim(query, 5000),
          'span.type': 'cassandra',
          'span.kind': 'client',
          'db.type': 'cassandra',
          'cassandra.query': query,
          'cassandra.keyspace': keyspace
        }
      })

      if (connectionOptions) {
        span.addTags({
          'out.host': connectionOptions.host,
          'out.port': connectionOptions.port
        })
      }

      analyticsSampler.sample(span, this.config.measured)
      this.enter(span, store)
    })

    this.addSub(`apm:cassandra:query:end`, () => {
      this.exit()
    })

    this.addSub(`apm:cassandra:query:error`, err => {
      storage.getStore().span.setTag('error', err)
    })

    this.addSub(`apm:cassandra:query:async-end`, () => {
      storage.getStore().span.finish()
    })

    this.addSub(`apm:cassandra:query:addConnection`, connectionOptions => {
      const store = storage.getStore()
      if (!store) {
        return
      }
      const span = store.span
      span.addTags({
        'out.host': connectionOptions.address,
        'out.port': connectionOptions.port
      })
    })
  }
}

function combine (queries) {
  return queries
    .map(query => (query.query || query).replace(/;?$/, ';'))
    .join(' ')
}

function trim (str, size) {
  if (!str || str.length <= size) return str

  return `${str.substr(0, size - 3)}...`
}

module.exports = CassandraDriverPlugin


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-connect/src/index.js":
/*!*************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-connect/src/index.js ***!
  \*************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const web = __webpack_require__(/*! ../../dd-trace/src/plugins/util/web */ "../../node_modules/dd-trace/packages/dd-trace/src/plugins/util/web.js")

function createWrapConnect (tracer, config) {
  return function wrapConnect (connect) {
    if (typeof connect !== 'function') return connect

    return function connectWithTrace () {
      const app = connect()

      if (!app) return app

      app.use = createWrapUse()(app.use)
      app.handle = createWrapHandle(tracer, config)(app.handle)

      return app
    }
  }
}

function createWrapUse () {
  return function wrapUse (use) {
    if (typeof use !== 'function') return use

    return function useWithTrace (route, fn) {
      const result = use.apply(this, arguments)

      if (!this || !Array.isArray(this.stack)) return result

      const index = this.stack.length - 1
      const layer = this.stack[index]

      if (layer && layer.handle) {
        this.stack[index].handle = wrapLayerHandle(layer)
      }

      return result
    }
  }
}

function createWrapHandle (tracer, config) {
  config = web.normalizeConfig(config)

  return function wrapHandle (handle) {
    if (typeof handle !== 'function') return handle

    return function handleWithTrace (req, res, out) {
      return web.instrument(tracer, config, req, res, 'connect.request', () => {
        return handle.apply(this, arguments)
      })
    }
  }
}

function wrapLayerHandle (layer) {
  if (typeof layer.handle !== 'function') return layer.handle

  const handle = layer.handle

  if (layer.handle.length === 4) {
    return function (error, req, res, next) {
      return callLayerHandle(layer, handle, req, [error, req, res, wrapNext(layer, req, next)])
    }
  } else {
    return function (req, res, next) {
      return callLayerHandle(layer, handle, req, [req, res, wrapNext(layer, req, next)])
    }
  }
}

function callLayerHandle (layer, handle, req, args) {
  const route = layer.route

  if (route !== '/') {
    web.enterRoute(req, route)
  }

  return web.wrapMiddleware(req, handle, 'connect.middleware', () => {
    return handle.apply(layer, args)
  })
}

function wrapNext (layer, req, next) {
  if (typeof next !== 'function' || !web.active(req)) return next

  return function nextWithTrace (error) {
    if (!error && layer.route !== '/') {
      web.exitRoute(req)
    }

    web.finish(req, error)

    next.apply(this, arguments)
  }
}

module.exports = [
  {
    name: 'connect',
    versions: ['>=3'],
    patch (connect, tracer, config) {
      // `connect` is a function so we return a wrapper that will replace its export.
      return this.wrapExport(connect, createWrapConnect(tracer, config)(connect))
    },
    unpatch (connect) {
      this.unwrapExport(connect)
    }
  },
  {
    name: 'connect',
    versions: ['2.2.2'],
    patch (connect, tracer, config) {
      this.wrap(connect.proto, 'use', createWrapUse())
      this.wrap(connect.proto, 'handle', createWrapHandle(tracer, config))
    },
    unpatch (connect) {
      this.unwrap(connect.proto, 'use')
      this.unwrap(connect.proto, 'handle')
    }
  }
]


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-couchbase/src/index.js":
/*!***************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-couchbase/src/index.js ***!
  \***************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Plugin = __webpack_require__(/*! ../../dd-trace/src/plugins/plugin */ "../../node_modules/dd-trace/packages/dd-trace/src/plugins/plugin.js")
const { storage } = __webpack_require__(/*! ../../datadog-core */ "../../node_modules/dd-trace/packages/datadog-core/index.js")
const analyticsSampler = __webpack_require__(/*! ../../dd-trace/src/analytics_sampler */ "../../node_modules/dd-trace/packages/dd-trace/src/analytics_sampler.js")

class CouchBasePlugin extends Plugin {
  static get name () {
    return 'couchbase'
  }

  addSubs (func, start, asyncEnd = defaultAsyncEnd) {
    this.addSub(`apm:couchbase:${func}:start`, start)
    this.addSub(`apm:couchbase:${func}:end`, this.exit.bind(this))
    this.addSub(`apm:couchbase:${func}:error`, errorHandler)
    this.addSub(`apm:couchbase:${func}:async-end`, asyncEnd)
  }

  startSpan (operation, customTags, store, bucket) {
    const tags = {
      'db.type': 'couchbase',
      'component': 'couchbase',
      'service.name': this.config.service || `${this.tracer._service}-couchbase`,
      'resource.name': `couchbase.${operation}`,
      'span.kind': 'client'
    }

    for (const tag in customTags) {
      tags[tag] = customTags[tag]
    }
    const span = this.tracer.startSpan(`couchbase.${operation}`, {
      childOf: store ? store.span : null,
      tags
    })

    span.setTag('couchbase.bucket.name', bucket.name || bucket._name)

    analyticsSampler.sample(span, this.config.measured)
    return span
  }

  constructor (...args) {
    super(...args)

    this.addSubs('query', ({ resource, bucket }) => {
      const store = storage.getStore()
      const span = this.startSpan('query', { 'span.type': 'sql', 'resource.name': resource }, store, bucket)
      this.enter(span, store)
    })

    this._addCommandSubs('upsert')
    this._addCommandSubs('insert')
    this._addCommandSubs('replace')
    this._addCommandSubs('append')
    this._addCommandSubs('prepend')
  }
  _addCommandSubs (name) {
    this.addSubs(name, ({ bucket }) => {
      const store = storage.getStore()
      const span = this.startSpan(name, {}, store, bucket)
      this.enter(span, store)
    })
  }
}

function defaultAsyncEnd () {
  storage.getStore().span.finish()
}

function errorHandler (error) {
  storage.getStore().span.setTag('error', error)
}

module.exports = CouchBasePlugin


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-cucumber/src/index.js":
/*!**************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-cucumber/src/index.js ***!
  \**************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Plugin = __webpack_require__(/*! ../../dd-trace/src/plugins/plugin */ "../../node_modules/dd-trace/packages/dd-trace/src/plugins/plugin.js")
const { storage } = __webpack_require__(/*! ../../datadog-core */ "../../node_modules/dd-trace/packages/datadog-core/index.js")

const {
  CI_APP_ORIGIN,
  TEST_TYPE,
  TEST_NAME,
  TEST_SUITE,
  TEST_SKIP_REASON,
  TEST_FRAMEWORK_VERSION,
  ERROR_MESSAGE,
  TEST_STATUS,
  TEST_CODE_OWNERS,
  finishAllTraceSpans,
  getTestEnvironmentMetadata,
  getTestSuitePath,
  getCodeOwnersFileEntries,
  getCodeOwnersForFilename
} = __webpack_require__(/*! ../../dd-trace/src/plugins/util/test */ "../../node_modules/dd-trace/packages/dd-trace/src/plugins/util/test.js")
const { SPAN_TYPE, RESOURCE_NAME, SAMPLING_PRIORITY } = __webpack_require__(/*! ../../../ext/tags */ "../../node_modules/dd-trace/ext/tags.js")
const { SAMPLING_RULE_DECISION } = __webpack_require__(/*! ../../dd-trace/src/constants */ "../../node_modules/dd-trace/packages/dd-trace/src/constants.js")
const { AUTO_KEEP } = __webpack_require__(/*! ../../../ext/priority */ "../../node_modules/dd-trace/ext/priority.js")

class CucumberPlugin extends Plugin {
  static get name () {
    return 'cucumber'
  }

  constructor (...args) {
    super(...args)

    const testEnvironmentMetadata = getTestEnvironmentMetadata('cucumber', this.config)
    const sourceRoot = process.cwd()
    const codeOwnersEntries = getCodeOwnersFileEntries(sourceRoot)

    this.addSub('ci:cucumber:run:start', ({ pickleName, pickleUri }) => {
      const store = storage.getStore()
      const childOf = store ? store.span : store
      const testSuite = getTestSuitePath(pickleUri, sourceRoot)

      const testSpanMetadata = {
        [SPAN_TYPE]: 'test',
        [RESOURCE_NAME]: pickleName,
        [TEST_TYPE]: 'test',
        [TEST_NAME]: pickleName,
        [TEST_SUITE]: testSuite,
        [SAMPLING_RULE_DECISION]: 1,
        [SAMPLING_PRIORITY]: AUTO_KEEP,
        [TEST_FRAMEWORK_VERSION]: this.tracer._version,
        ...testEnvironmentMetadata
      }

      const codeOwners = getCodeOwnersForFilename(testSuite, codeOwnersEntries)
      if (codeOwners) {
        testSpanMetadata[TEST_CODE_OWNERS] = codeOwners
      }

      const span = this.tracer.startSpan('cucumber.test', {
        childOf,
        tags: testSpanMetadata
      })

      span.context()._trace.origin = CI_APP_ORIGIN
      this.enter(span, store)
    })

    this.addSub('ci:cucumber:run:end', () => {
      this.exit()
    })

    this.addSub('ci:cucumber:run-step:start', ({ resource }) => {
      const store = storage.getStore()
      const childOf = store ? store.span : store
      const span = this.tracer.startSpan('cucumber.step', {
        childOf,
        tags: {
          'cucumber.step': resource,
          [RESOURCE_NAME]: resource
        }
      })
      this.enter(span, store)
    })

    this.addSub('ci:cucumber:run-step:end', () => {
      this.exit()
    })

    this.addSub('ci:cucumber:run:async-end', ({ isStep, status, skipReason, errorMessage }) => {
      const span = storage.getStore().span
      const statusTag = isStep ? 'step.status' : TEST_STATUS

      span.setTag(statusTag, status)

      if (skipReason) {
        span.setTag(TEST_SKIP_REASON, skipReason)
      }

      if (errorMessage) {
        span.setTag(ERROR_MESSAGE, errorMessage)
      }

      span.finish()
      if (!isStep) {
        finishAllTraceSpans(span)
      }
    })

    this.addSub('ci:cucumber:error', (err) => {
      if (err) {
        const span = storage.getStore().span
        span.setTag('error', err)
      }
    })
  }
}

module.exports = CucumberPlugin


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-cypress/src/index.js":
/*!*************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-cypress/src/index.js ***!
  \*************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

const Plugin = __webpack_require__(/*! ../../dd-trace/src/plugins/plugin */ "../../node_modules/dd-trace/packages/dd-trace/src/plugins/plugin.js")

// Cypress plugin does not patch any library. This is just a placeholder to
// follow the structure of the plugins
class CypressPlugin extends Plugin {
  static get name () {
    return 'cypress'
  }
}

module.exports = CypressPlugin


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-dns/src/index.js":
/*!*********************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-dns/src/index.js ***!
  \*********************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const analyticsSampler = __webpack_require__(/*! ../../dd-trace/src/analytics_sampler */ "../../node_modules/dd-trace/packages/dd-trace/src/analytics_sampler.js")
const Plugin = __webpack_require__(/*! ../../dd-trace/src/plugins/plugin */ "../../node_modules/dd-trace/packages/dd-trace/src/plugins/plugin.js")
const { storage } = __webpack_require__(/*! ../../datadog-core */ "../../node_modules/dd-trace/packages/datadog-core/index.js")

class DNSPlugin extends Plugin {
  static get name () {
    return 'dns'
  }

  addSubs (func, start, asyncEnd = defaultAsyncEnd) {
    this.addSub(`apm:dns:${func}:start`, start)
    this.addSub(`apm:dns:${func}:end`, this.exit.bind(this))
    this.addSub(`apm:dns:${func}:error`, errorHandler)
    this.addSub(`apm:dns:${func}:async-end`, asyncEnd)
  }

  startSpan (name, customTags, store) {
    const tags = {
      'service.name': this.config.service || this.tracer._service,
      'span.kind': 'client'
    }
    for (const tag in customTags) {
      tags[tag] = customTags[tag]
    }
    const span = this.tracer.startSpan(name, {
      childOf: store ? store.span : null,
      tags
    })
    analyticsSampler.sample(span, this.config.measured)
    return span
  }

  constructor (...args) {
    super(...args)

    this.addSubs('lookup', ([hostname]) => {
      const store = storage.getStore()
      const span = this.startSpan('dns.lookup', {
        'resource.name': hostname,
        'dns.hostname': hostname
      }, store)
      this.enter(span, store)
    }, (result) => {
      const { span } = storage.getStore()
      span.setTag('dns.address', result)
      span.finish()
    })

    this.addSubs('lookup_service', ([address, port]) => {
      const store = storage.getStore()
      const span = this.startSpan('dns.lookup_service', {
        'resource.name': `${address}:${port}`,
        'dns.address': address,
        'dns.port': port
      }, store)
      this.enter(span, store)
    })

    this.addSubs('resolve', ([hostname, maybeType]) => {
      const store = storage.getStore()
      const rrtype = typeof maybeType === 'string' ? maybeType : 'A'
      const span = this.startSpan('dns.resolve', {
        'resource.name': `${rrtype} ${hostname}`,
        'dns.hostname': hostname,
        'dns.rrtype': rrtype
      }, store)
      this.enter(span, store)
    })

    this.addSubs('reverse', ([ip]) => {
      const store = storage.getStore()
      const span = this.startSpan('dns.reverse', { 'resource.name': ip, 'dns.ip': ip }, store)
      this.enter(span, store)
    })
  }
}

function defaultAsyncEnd () {
  storage.getStore().span.finish()
}

function errorHandler (error) {
  storage.getStore().span.setTag('error', error)
}

module.exports = DNSPlugin


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-elasticsearch/src/index.js":
/*!*******************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-elasticsearch/src/index.js ***!
  \*******************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Plugin = __webpack_require__(/*! ../../dd-trace/src/plugins/plugin */ "../../node_modules/dd-trace/packages/dd-trace/src/plugins/plugin.js")
const { storage } = __webpack_require__(/*! ../../datadog-core */ "../../node_modules/dd-trace/packages/datadog-core/index.js")
const analyticsSampler = __webpack_require__(/*! ../../dd-trace/src/analytics_sampler */ "../../node_modules/dd-trace/packages/dd-trace/src/analytics_sampler.js")

class ElasticsearchPlugin extends Plugin {
  static get name () {
    return 'elasticsearch'
  }

  constructor (...args) {
    super(...args)

    this.addSub('apm:elasticsearch:query:start', ({ params }) => {
      const store = storage.getStore()
      const childOf = store ? store.span : store
      const body = getBody(params.body || params.bulkBody)
      const span = this.tracer.startSpan('elasticsearch.query', {
        childOf,
        tags: {
          'db.type': 'elasticsearch',
          'span.kind': 'client',
          'service.name': this.config.service || `${this.tracer._service}-elasticsearch`,
          'resource.name': `${params.method} ${quantizePath(params.path)}`,
          'span.type': 'elasticsearch',
          'elasticsearch.url': params.path,
          'elasticsearch.method': params.method,
          'elasticsearch.body': body,
          'elasticsearch.params': JSON.stringify(params.querystring || params.query)
        }
      })
      analyticsSampler.sample(span, this.config.measured)
      this.enter(span, store)
    })

    this.addSub('apm:elasticsearch:query:end', () => {
      this.exit()
    })

    this.addSub('apm:elasticsearch:query:error', err => {
      const span = storage.getStore().span
      span.setTag('error', err)
    })

    this.addSub('apm:elasticsearch:query:async-end', ({ params }) => {
      const span = storage.getStore().span
      this.config.hooks.query(span, params)
      span.finish()
    })
  }

  configure (config) {
    return super.configure(normalizeConfig(config))
  }
}

function normalizeConfig (config) {
  const hooks = getHooks(config)

  return Object.assign({}, config, {
    hooks
  })
}

function getHooks (config) {
  const noop = () => {}
  const query = (config.hooks && config.hooks.query) || noop

  return { query }
}

function getBody (body) {
  return body && JSON.stringify(body)
}

function quantizePath (path) {
  return path && path.replace(/[0-9]+/g, '?')
}

module.exports = ElasticsearchPlugin


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-express/src/index.js":
/*!*************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-express/src/index.js ***!
  \*************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const web = __webpack_require__(/*! ../../dd-trace/src/plugins/util/web */ "../../node_modules/dd-trace/packages/dd-trace/src/plugins/util/web.js")
const routerPlugin = __webpack_require__(/*! ../../datadog-plugin-router/src */ "../../node_modules/dd-trace/packages/datadog-plugin-router/src/index.js")

function createWrapHandle (tracer, config) {
  config = web.normalizeConfig(config)

  return function wrapHandle (handle) {
    return function handleWithTrace (req, res) {
      web.instrument(tracer, config, req, res, 'express.request')

      return handle.apply(this, arguments)
    }
  }
}

function patch (express, tracer, config) {
  this.wrap(express.application, 'handle', createWrapHandle(tracer, config))
  routerPlugin.patch.call(this, { prototype: express.Router }, tracer, config)
}

function unpatch (express) {
  this.unwrap(express.application, 'handle')
  routerPlugin.unpatch.call(this, { prototype: express.Router })
}

module.exports = {
  name: 'express',
  versions: ['>=4'],
  patch,
  unpatch
}


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-fastify/src/fastify.js":
/*!***************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-fastify/src/fastify.js ***!
  \***************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const methods = __webpack_require__(/*! methods */ "../../node_modules/methods/index.js").concat('all')
const web = __webpack_require__(/*! ../../dd-trace/src/plugins/util/web */ "../../node_modules/dd-trace/packages/dd-trace/src/plugins/util/web.js")

function createWrapFastify (tracer, config) {
  config = web.normalizeConfig(config)

  return function wrapFastify (fastify) {
    if (typeof fastify !== 'function') return fastify

    return function fastifyWithTrace () {
      const app = fastify.apply(this, arguments)

      if (!app) return app

      if (typeof app.addHook === 'function') {
        app.addHook('onRequest', createOnRequest(tracer, config))
        app.addHook('preHandler', preHandler)
        app.addHook = createWrapAddHook(tracer, config)(app.addHook)
      }

      methods.forEach(method => {
        app[method] = wrapMethod(app[method])
      })

      app.route = wrapRoute(app.route)

      return app
    }
  }
}

function createWrapAddHook (tracer, config) {
  return function wrapAddHook (addHook) {
    return function addHookWithTrace (name, fn) {
      fn = arguments[arguments.length - 1]

      if (typeof fn !== 'function') return addHook.apply(this, arguments)

      arguments[arguments.length - 1] = safeWrap(fn, function (request, reply, done) {
        const req = getReq(request)

        if (!req) return fn.apply(this, arguments)

        done = arguments[arguments.length - 1]

        try {
          if (typeof done === 'function') {
            arguments[arguments.length - 1] = function (err) {
              web.addError(req, err)
              return done.apply(this, arguments)
            }

            return fn.apply(this, arguments)
          } else {
            const promise = fn.apply(this, arguments)

            if (promise && typeof promise.catch === 'function') {
              return promise.catch(err => {
                web.addError(req, err)
                throw err
              })
            }

            return promise
          }
        } catch (e) {
          web.addError(req, e)
          throw e
        }
      })

      return addHook.apply(this, arguments)
    }
  }
}

function createOnRequest (tracer, config) {
  return function onRequest (request, reply, next) {
    if (typeof next !== 'function') return

    const req = getReq(request)
    const res = getRes(reply)
    const name = 'fastify.request'

    return web.instrument(tracer, config, req, res, name, () => next())
  }
}

function preHandler (request, reply, next) {
  if (typeof next !== 'function') return
  if (!reply || typeof reply.send !== 'function') return next()

  reply.send = wrapSend(reply.send)

  next()
}

function wrapSend (send) {
  return function sendWithTrace (payload) {
    const req = getReq(this && this.request)

    web.addError(req, payload)

    return send.apply(this, arguments)
  }
}

function wrapRoute (route) {
  if (typeof route !== 'function') return route

  return function routeWithTrace (opts) {
    opts.handler = wrapHandler(opts.handler)

    return route.apply(this, arguments)
  }
}

function wrapMethod (method) {
  if (typeof method !== 'function') return method

  return function methodWithTrace (url, opts, handler) {
    const lastIndex = arguments.length - 1

    handler = arguments[lastIndex]

    if (typeof handler === 'function') {
      arguments[lastIndex] = wrapHandler(handler)
    } else if (handler) {
      arguments[lastIndex].handler = wrapHandler(handler.handler)
    }

    return method.apply(this, arguments)
  }
}

function wrapHandler (handler) {
  if (!handler || typeof handler !== 'function' || handler.name === 'handlerWithTrace') {
    return handler
  }

  return function handlerWithTrace (request, reply) {
    const req = getReq(request)

    return web.reactivate(req, () => handler.apply(this, arguments))
  }
}

// TODO: move this to a common util
function safeWrap (fn, wrapper) {
  Object.defineProperty(wrapper, 'length', Object.getOwnPropertyDescriptor(fn, 'length'))

  return wrapper
}

function getReq (request) {
  return request && (request.raw || request.req || request)
}

function getRes (reply) {
  return reply && (reply.raw || reply.res || reply)
}

module.exports = [
  {
    name: 'fastify',
    versions: ['>=3'],
    patch (fastify, tracer, config) {
      // `fastify` is a function so we return a wrapper that will replace its export.
      const wrapped = this.wrapExport(fastify, createWrapFastify(tracer, config)(fastify))

      wrapped.fastify = wrapped
      wrapped.default = wrapped

      return wrapped
    },
    unpatch (fastify) {
      const unwrapped = this.unwrapExport(fastify)

      unwrapped.fastify = unwrapped
      unwrapped.default = unwrapped

      return unwrapped
    }
  },
  {
    name: 'fastify',
    versions: ['1 - 2'],
    patch (fastify, tracer, config) {
      // `fastify` is a function so we return a wrapper that will replace its export.
      return this.wrapExport(fastify, createWrapFastify(tracer, config)(fastify))
    },
    unpatch (fastify) {
      this.unwrapExport(fastify)
    }
  }
]


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-fastify/src/find-my-way.js":
/*!*******************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-fastify/src/find-my-way.js ***!
  \*******************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const web = __webpack_require__(/*! ../../dd-trace/src/plugins/util/web */ "../../node_modules/dd-trace/packages/dd-trace/src/plugins/util/web.js")

function createWrapOn () {
  return function wrapOn (on) {
    return function onWithTrace (method, path, opts) {
      const index = typeof opts === 'function' ? 2 : 3
      const handler = arguments[index]
      const wrapper = function (req) {
        web.patch(req)
        web.enterRoute(req, path)

        return handler.apply(this, arguments)
      }

      if (typeof handler === 'function') {
        arguments[index] = wrapper
      }

      return on.apply(this, arguments)
    }
  }
}

module.exports = [
  {
    name: 'find-my-way',
    versions: ['>=1'],
    patch (Router, tracer, config) {
      this.wrap(Router.prototype, 'on', createWrapOn(tracer, config))
    },
    unpatch (Router) {
      this.unwrap(Router.prototype, 'on')
    }
  }
]


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-fastify/src/index.js":
/*!*************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-fastify/src/index.js ***!
  \*************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = [].concat(
  __webpack_require__(/*! ./fastify */ "../../node_modules/dd-trace/packages/datadog-plugin-fastify/src/fastify.js"),
  __webpack_require__(/*! ./find-my-way */ "../../node_modules/dd-trace/packages/datadog-plugin-fastify/src/find-my-way.js") // TODO make this its own plugin, since restify uses it too
)


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-fs/src/index.js":
/*!********************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-fs/src/index.js ***!
  \********************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const { storage } = __webpack_require__(/*! ../../datadog-core */ "../../node_modules/dd-trace/packages/datadog-core/index.js")

let kDirReadPromisified
let kDirClosePromisified
let kHandle

const ddFhSym = Symbol('ddFileHandle')

const tagMakers = {
  open: createOpenTags,
  close: createCloseTags,
  readFile: createReadFileTags,
  writeFile: createWriteFileTags,
  appendFile: createAppendFileTags,
  access: createPathTags,
  copyFile: createCopyFileTags,
  stat: createPathTags,
  lstat: createPathTags,
  fstat: createFDTags,
  readdir: createPathTags,
  opendir: createPathTags,
  read: createFDTags,
  write: createFDTags,
  writev: createFDTags,
  chmod: createChmodTags,
  lchmod: createChmodTags,
  fchmod: createFchmodTags,
  chown: createChownTags,
  lchown: createChownTags,
  fchown: createFchownTags,
  realpath: createPathTags,
  readlink: createPathTags,
  unlink: createPathTags,
  symlink: createCopyFileTags,
  link: createCopyFileTags,
  rmdir: createPathTags,
  rename: createCopyFileTags,
  fsync: createFDTags,
  fdatasync: createFDTags,
  mkdir: createPathTags,
  truncate: createPathTags,
  ftruncate: createFDTags,
  utimes: createPathTags,
  futimes: createFDTags,
  mkdtemp: createPathTags
}

const promisifiable = ['read', 'readv', 'write', 'writev']

const orphanable = false

function createWrapCreateReadStream (config, tracer) {
  return function wrapCreateReadStream (createReadStream) {
    return function createReadStreamWithTrace (path, options) {
      if (!hasParent()) {
        return createReadStream.apply(this, arguments)
      }
      const tags = makeFSFlagTags('ReadStream', path, options, 'r', config, tracer)
      return tracer.trace('fs.operation', { tags, orphanable }, (span, done) => {
        const stream = createReadStream.apply(this, arguments)
        stream.once('end', done)
        stream.once('error', done)
        return stream
      })
    }
  }
}

function createWrapCreateWriteStream (config, tracer) {
  return function wrapCreateWriteStream (createWriteStream) {
    return function createWriteStreamWithTrace (path, options) {
      const tags = makeFSFlagTags('WriteStream', path, options, 'w', config, tracer)
      return tracer.trace('fs.operation', { tags, orphanable }, (span, done) => {
        const stream = createWriteStream.apply(this, arguments)
        stream.once('finish', done)
        stream.once('error', done)
        return stream
      })
    }
  }
}

function createWrapExists (config, tracer) {
  return function wrapExists (exists) {
    const existsWithTrace = function existsWithTrace (path, cb) {
      if (typeof cb !== 'function') {
        return exists.apply(this, arguments)
      }
      const tags = makeFSTags('exists', path, null, config, tracer)
      return tracer.trace('fs.operation', { tags, orphanable }, (span, done) => {
        arguments[1] = function (result) {
          done()
          cb.apply(this, arguments)
        }
        return exists.apply(this, arguments)
      })
    }

    copySymbols(exists, existsWithTrace)

    return existsWithTrace
  }
}

function createWrapDirRead (config, tracer, sync) {
  const name = sync ? 'dir.readSync' : 'dir.read'
  return function wrapDirRead (read) {
    function options () {
      const tags = makeFSTags(name, this.path, null, config, tracer)
      return { tags, orphanable }
    }
    return tracer.wrap('fs.operation', options, read, true)
  }
}

function createWrapDirClose (config, tracer, sync) {
  const name = sync ? 'dir.closeSync' : 'dir.close'
  return function wrapDirClose (close) {
    function options () {
      const tags = makeFSTags(name, this.path, null, config, tracer)
      return { tags, orphanable }
    }
    return tracer.wrap('fs.operation', options, close, true)
  }
}

function createWrapDirAsyncIterator (config, tracer, instrumenter) {
  return function wrapDirAsyncIterator (asyncIterator) {
    return function asyncIteratorWithTrace () {
      if (!kDirReadPromisified) {
        const keys = Reflect.ownKeys(this)
        for (const key of keys) {
          if (kDirReadPromisified && kDirClosePromisified) break
          if (typeof key !== 'symbol') continue
          if (!kDirReadPromisified && getSymbolName(key).includes('kDirReadPromisified')) {
            kDirReadPromisified = key
          }
          if (!kDirClosePromisified && getSymbolName(key).includes('kDirClosePromisified')) {
            kDirClosePromisified = key
          }
        }
      }
      instrumenter.wrap(this, kDirReadPromisified, createWrapDirRead(config, tracer))
      instrumenter.wrap(this, kDirClosePromisified, createWrapKDirClose(config, tracer, instrumenter))
      return asyncIterator.apply(this, arguments)
    }
  }
}

function createWrapKDirClose (config, tracer, instrumenter) {
  return function wrapKDirClose (kDirClose) {
    return function kDirCloseWithTrace () {
      const tags = makeFSTags('dir.close', this.path, null, config, tracer)
      return tracer.trace('fs.operation', { tags, orphanable }, (span) => {
        const p = kDirClose.apply(this, arguments)
        const unwrapBoth = () => {
          instrumenter.unwrap(this, kDirReadPromisified)
          instrumenter.unwrap(this, kDirClosePromisified)
        }
        p.then(unwrapBoth, unwrapBoth)
        return p
      })
    }
  }
}

function createOpenTags (resourceName, config, tracer) {
  return function openTags (path, flag, mode) {
    if (!flag || typeof flag === 'function') {
      flag = null
    }
    return makeFSFlagTags(resourceName, path, { flag }, 'r', config, tracer)
  }
}

function createCloseTags (resourceName, config, tracer) {
  return function closeTags (fd) {
    if (typeof fd === 'undefined' && this && this[ddFhSym]) {
      fd = this[ddFhSym].fd
    }
    if (typeof fd !== 'number' || !Number.isInteger(fd)) {
      return
    }
    return makeFSTags(resourceName, fd, null, config, tracer)
  }
}

function createReadFileTags (resourceName, config, tracer) {
  return function readFileTags (path, options) {
    return makeFSFlagTags(resourceName, path, options, 'r', config, tracer)
  }
}

function createWriteFileTags (resourceName, config, tracer) {
  return function writeFileTags (path, data, options) {
    return makeFSFlagTags(resourceName, path, options, 'w', config, tracer)
  }
}

function createAppendFileTags (resourceName, config, tracer) {
  return function appendFileTags (path, data, options) {
    return makeFSFlagTags(resourceName, path, options, 'a', config, tracer)
  }
}

function createCopyFileTags (resourceName, config, tracer) {
  return function copyFileTags (src, dest, flag) {
    return makeFSTags(resourceName, { src, dest }, null, config, tracer)
  }
}

function createChmodTags (resourceName, config, tracer) {
  return function chmodTags (fd, mode) {
    const tags = makeFSTags(resourceName, fd, null, config, tracer)
    tags['file.mode'] = mode.toString(8)
    return tags
  }
}

function createFchmodTags (resourceName, config, tracer) {
  return function fchmodTags (fd, mode) {
    if (typeof this === 'object' && this !== null && this.fd) {
      mode = fd
      fd = this.fd
    }

    const tags = makeFSTags(resourceName, fd, null, config, tracer)
    if (mode) {
      tags['file.mode'] = mode.toString(8)
    }
    return tags
  }
}

function createPathTags (resourceName, config, tracer) {
  return function pathTags (path) {
    return makeFSTags(resourceName, path, null, config, tracer)
  }
}

function createFDTags (resourceName, config, tracer) {
  return function fdTags (fd) {
    if (typeof this === 'object' && this !== null && this.fd) {
      fd = this.fd
    }
    return makeFSTags(resourceName, fd, null, config, tracer)
  }
}

function createChownTags (resourceName, config, tracer) {
  return function chownTags (fd, uid, gid) {
    const tags = makeFSTags(resourceName, fd, null, config, tracer)
    if (typeof uid === 'number') {
      tags['file.uid'] = uid.toString()
    }
    if (typeof gid === 'number') {
      tags['file.gid'] = gid.toString()
    }
    return tags
  }
}

function createFchownTags (resourceName, config, tracer) {
  return function fchownTags (fd, uid, gid) {
    if (typeof this === 'object' && this !== null && this.fd) {
      gid = uid
      uid = fd
      fd = this.fd
    }
    const tags = makeFSTags(resourceName, fd, null, config, tracer)
    if (typeof uid === 'number') {
      tags['file.uid'] = uid.toString()
    }
    if (typeof gid === 'number') {
      tags['file.gid'] = gid.toString()
    }
    return tags
  }
}

function getSymbolName (sym) {
  return sym.description || sym.toString()
}

function hasParent () {
  const store = storage.getStore()

  return store && store.span && !store.noop
}

function createWrapCb (tracer, config, name, tagMaker) {
  const makeTags = tagMaker(name, config, tracer)
  return function wrapFunction (fn) {
    return tracer.wrap('fs.operation', function () {
      if (typeof arguments[arguments.length - 1] !== 'function') {
        return
      }
      const tags = makeTags.apply(this, arguments)
      return tags ? { tags, orphanable } : { orphanable }
    }, fn, true)
  }
}

function createWrap (tracer, config, name, tagMaker) {
  const makeTags = tagMaker(name, config, tracer)

  return function wrapSyncFunction (fn) {
    return tracer.wrap('fs.operation', function () {
      const tags = makeTags.apply(this, arguments)
      return tags ? { tags, orphanable } : { orphanable }
    }, fn, true)
  }
}

function makeFSFlagTags (resourceName, path, options, defaultFlag, config, tracer) {
  const tags = makeFSTags(resourceName, path, options, config, tracer)

  if (tags) {
    let flag = defaultFlag
    if (typeof options === 'object' && options !== null) {
      if (options.flag) {
        flag = options.flag
      } else if (options.flags) {
        flag = options.flags
      }
    }
    tags['file.flag'] = flag
    return tags
  }
}

function makeFSTags (resourceName, path, options, config, tracer) {
  path = options && typeof options === 'object' && 'fd' in options ? options.fd : path
  const tags = {
    'component': 'fs',
    'span.kind': 'internal',
    'resource.name': resourceName,
    'service.name': config.service || tracer._service
  }

  switch (typeof path) {
    case 'object': {
      if (path === null) return tags
      const src = 'src' in path ? path.src : null
      const dest = 'dest' in path ? path.dest : null
      if (src || dest) {
        tags['file.src'] = src
        tags['file.dest'] = dest
      } else {
        tags['file.path'] = path
      }
      break
    }
    case 'string': {
      tags['file.path'] = path
      break
    }
    case 'number': {
      tags['file.descriptor'] = path.toString()
      break
    }
  }

  return tags
}

function copySymbols (from, to) {
  const props = Object.getOwnPropertyDescriptors(from)
  const keys = Reflect.ownKeys(props)

  for (const key of keys) {
    if (typeof key !== 'symbol' || to.hasOwnProperty(key)) continue

    Object.defineProperty(to, key, props[key])
  }
}

function getFileHandlePrototype (fs) {
  return fs.promises.open(__filename, 'r')
    .then(fh => {
      if (!kHandle) {
        kHandle = Reflect.ownKeys(fh).find(key => typeof key === 'symbol' && key.toString().includes('kHandle'))
      }
      fh.close()

      return Object.getPrototypeOf(fh)
    })
}

function patchClassicFunctions (fs, tracer, config) {
  for (const name in fs) {
    if (!fs[name]) continue
    const tagMakerName = name.endsWith('Sync') ? name.substr(0, name.length - 4) : name
    const original = fs[name]
    if (tagMakerName in tagMakers) {
      const tagMaker = tagMakers[tagMakerName]
      if (name.endsWith('Sync')) {
        this.wrap(fs, name, createWrap(tracer, config, name, tagMaker))
      } else {
        this.wrap(fs, name, createWrapCb(tracer, config, name, tagMaker))
      }
      if (name in promisifiable) {
        copySymbols(original, fs[name])
      }
    }
  }
}

function patchFileHandle (fs, tracer, config) {
  getFileHandlePrototype(fs).then((fileHandlePrototype) => {
    for (const name of Reflect.ownKeys(fileHandlePrototype)) {
      if (typeof name !== 'string' || name === 'constructor' || name === 'fd' || name === 'getAsyncId') {
        continue
      }
      let tagMaker
      const fName = 'f' + name
      if (fName in tagMakers) {
        tagMaker = tagMakers[fName]
      } else {
        tagMaker = createFDTags
      }

      const instrumenter = this

      const desc = Reflect.getOwnPropertyDescriptor(fileHandlePrototype, kHandle)
      if (!desc || !desc.get) {
        Reflect.defineProperty(fileHandlePrototype, kHandle, {
          get () {
            return this[ddFhSym]
          },
          set (h) {
            this[ddFhSym] = h
            instrumenter.wrap(this, 'close', createWrap(tracer, config, 'filehandle.close', tagMakers.close))
          },
          configurable: true
        })
      }

      this.wrap(fileHandlePrototype, name, createWrap(tracer, config, 'filehandle.' + name, tagMaker))
    }
  })
}

function patchPromiseFunctions (fs, tracer, config) {
  for (const name in fs.promises) {
    if (name in tagMakers) {
      const tagMaker = tagMakers[name]
      this.wrap(fs.promises, name, createWrap(tracer, config, 'promises.' + name, tagMaker))
    }
  }
}

function patchDirFunctions (fs, tracer, config) {
  this.wrap(fs.Dir.prototype, 'close', createWrapDirClose(config, tracer))
  this.wrap(fs.Dir.prototype, 'closeSync', createWrapDirClose(config, tracer, true))
  this.wrap(fs.Dir.prototype, 'read', createWrapDirRead(config, tracer))
  this.wrap(fs.Dir.prototype, 'readSync', createWrapDirRead(config, tracer, true))
  this.wrap(fs.Dir.prototype, Symbol.asyncIterator, createWrapDirAsyncIterator(config, tracer, this))
}

function unpatchClassicFunctions (fs) {
  for (const name in fs) {
    if (!fs[name]) continue
    const tagMakerName = name.endsWith('Sync') ? name.substr(0, name.length - 4) : name
    if (tagMakerName in tagMakers) {
      this.unwrap(fs, name)
    }
  }
}

function unpatchFileHandle (fs) {
  getFileHandlePrototype(fs).then(fileHandlePrototype => {
    for (const name of Reflect.ownKeys(fileHandlePrototype)) {
      if (typeof name !== 'string' || name === 'constructor' || name === 'fd' || name === 'getAsyncId') {
        continue
      }
      this.unwrap(fileHandlePrototype, name)
    }
    delete fileHandlePrototype[kHandle]
  })
}

function unpatchPromiseFunctions (fs) {
  for (const name in fs.promises) {
    if (name in tagMakers) {
      this.unwrap(fs.promises, name)
    }
  }
}

function unpatchDirFunctions (fs) {
  this.unwrap(fs.Dir.prototype, 'close')
  this.unwrap(fs.Dir.prototype, 'closeSync')
  this.unwrap(fs.Dir.prototype, 'read')
  this.unwrap(fs.Dir.prototype, 'readSync')
  this.unwrap(fs.Dir.prototype, Symbol.asyncIterator)
}

module.exports = {
  name: 'fs',
  patch (fs, tracer, config) {
    const realpathNative = fs.realpath.native
    const realpathSyncNative = fs.realpathSync.native
    patchClassicFunctions.call(this, fs, tracer, config)
    if (fs.promises) {
      patchFileHandle.call(this, fs, tracer, config)
      patchPromiseFunctions.call(this, fs, tracer, config)
    }
    if (fs.Dir) {
      patchDirFunctions.call(this, fs, tracer, config)
    }
    this.wrap(fs, 'createReadStream', createWrapCreateReadStream(config, tracer))
    this.wrap(fs, 'createWriteStream', createWrapCreateWriteStream(config, tracer))
    this.wrap(fs, 'existsSync', createWrap(tracer, config, 'existsSync', createPathTags))
    this.wrap(fs, 'exists', createWrapExists(config, tracer))
    if (realpathNative) {
      fs.realpath.native = createWrapCb(tracer, config, 'realpath.native', createPathTags)(realpathNative)
    }
    if (realpathSyncNative) {
      fs.realpathSync.native = createWrap(tracer, config, 'realpath.native', createPathTags)(realpathSyncNative)
    }
  },
  unpatch (fs) {
    unpatchClassicFunctions.call(this, fs)
    if (fs.promises) {
      unpatchFileHandle.call(this, fs)
      unpatchPromiseFunctions.call(this, fs)
    }
    if (fs.Dir) {
      unpatchDirFunctions.call(this, fs)
    }
    this.unwrap(fs, 'createReadStream')
    this.unwrap(fs, 'createWriteStream')
    this.unwrap(fs, 'existsSync')
    this.unwrap(fs, 'exists')
  }
}

/** TODO fs functions:

unwatchFile
watch
watchFile
*/


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-google-cloud-pubsub/src/index.js":
/*!*************************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-google-cloud-pubsub/src/index.js ***!
  \*************************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const analyticsSampler = __webpack_require__(/*! ../../dd-trace/src/analytics_sampler */ "../../node_modules/dd-trace/packages/dd-trace/src/analytics_sampler.js")

const messageSpans = new WeakMap()

function createWrapRequest (tracer, config) {
  return function wrapRequest (request) {
    return function requestWithTrace (cfg = { reqOpts: {} }, cb) {
      const topic = getTopic(cfg)
      const tags = {
        component: '@google-cloud/pubsub',
        'resource.name': [cfg.method, topic].filter(x => x).join(' '),
        'service.name': config.service || `${tracer._service}-pubsub`,
        'span.kind': 'client',
        'pubsub.method': cfg.method,
        'gcloud.project_id': this.projectId,
        'pubsub.topic': topic
      }
      if (cfg.method === 'publish') {
        tags['span.kind'] = 'producer'
      }
      cb = tracer.scope().bind(cb)
      return tracer.trace('pubsub.request', { tags }, (span, done) => {
        analyticsSampler.sample(span, config.measured)

        if (cfg.reqOpts && cfg.method === 'publish') {
          for (const msg of cfg.reqOpts.messages) {
            if (!msg.attributes) {
              msg.attributes = {}
            }
            tracer.inject(span, 'text_map', msg.attributes)
          }
        }

        arguments[1] = function (err) {
          done(err)
          return cb.apply(this, arguments)
        }

        return request.apply(this, arguments)
      })
    }
  }
}

function createWrapSubscriptionEmit (tracer, config) {
  return function wrapSubscriptionEmit (emit) {
    return function emitWithTrace (eventName, message) {
      if (eventName !== 'message' || !message) return emit.apply(this, arguments)

      const span = messageSpans.get(message)

      if (!span) return emit.apply(this, arguments)

      return tracer.scope().activate(span, () => {
        try {
          return emit.apply(this, arguments)
        } catch (e) {
          span.setTag('error', e)
          throw e
        }
      })
    }
  }
}

function createWrapLeaseDispense (tracer, config) {
  return function wrapDispense (dispense) {
    return function dispenseWithTrace (message) {
      const subscription = message._subscriber._subscription
      const topic = subscription.metadata && subscription.metadata.topic
      const tags = {
        component: '@google-cloud/pubsub',
        'resource.name': topic,
        'service.name': config.service || tracer._service,
        'gcloud.project_id': subscription.pubsub.projectId,
        'pubsub.topic': topic,
        'span.kind': 'consumer',
        'span.type': 'worker'
      }

      const childOf = tracer.extract('text_map', message.attributes)
      const span = tracer.startSpan('pubsub.receive', { tags, childOf })

      analyticsSampler.sample(span, config.measured, true)

      messageSpans.set(message, span)

      return dispense.apply(this, arguments)
    }
  }
}

function createWrapLeaseRemove (tracer, config) {
  return function wrapRemove (remove) {
    return function removeWithTrace (message) {
      finish(message)

      return remove.apply(this, arguments)
    }
  }
}

function createWrapLeaseClear (tracer, config) {
  return function wrapClear (clear) {
    return function clearWithTrace () {
      for (const message of this._messages) {
        finish(message)
      }

      return clear.apply(this, arguments)
    }
  }
}

function getTopic (cfg) {
  if (cfg.reqOpts) {
    return cfg.reqOpts[cfg.method === 'createTopic' ? 'name' : 'topic']
  }
}

function finish (message) {
  const span = messageSpans.get(message)

  if (!span) return

  span.setTag('pubsub.ack', message._handled ? 1 : 0)
  span.finish()
}

module.exports = [
  {
    name: '@google-cloud/pubsub',
    versions: ['>=1.2'],
    patch ({ PubSub, Subscription }, tracer, config) {
      this.wrap(PubSub.prototype, 'request', createWrapRequest(tracer, config))
      this.wrap(Subscription.prototype, 'emit', createWrapSubscriptionEmit(tracer, config))
    },
    unpatch ({ PubSub, Subscription }) {
      this.unwrap(PubSub.prototype, 'request')
      this.unwrap(Subscription.prototype, 'emit')
    }
  },
  {
    name: '@google-cloud/pubsub',
    versions: ['>=1.2'],
    file: 'build/src/lease-manager.js',
    patch ({ LeaseManager }, tracer, config) {
      this.wrap(LeaseManager.prototype, '_dispense', createWrapLeaseDispense(tracer, config))
      this.wrap(LeaseManager.prototype, 'remove', createWrapLeaseRemove(tracer, config))
      this.wrap(LeaseManager.prototype, 'clear', createWrapLeaseClear(tracer, config))
    },
    unpatch ({ LeaseManager }) {
      this.unwrap(LeaseManager.prototype, '_dispense')
      this.unwrap(LeaseManager.prototype, 'remove')
      this.unwrap(LeaseManager.prototype, 'clear')
    }
  }
]


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-graphql/src/index.js":
/*!*************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-graphql/src/index.js ***!
  \*************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const pick = __webpack_require__(/*! lodash.pick */ "../../node_modules/lodash.pick/index.js")
const log = __webpack_require__(/*! ../../dd-trace/src/log */ "../../node_modules/dd-trace/packages/dd-trace/src/log.js")
const analyticsSampler = __webpack_require__(/*! ../../dd-trace/src/analytics_sampler */ "../../node_modules/dd-trace/packages/dd-trace/src/analytics_sampler.js")

const contexts = new WeakMap()
const documentSources = new WeakMap()
const patchedTypes = new WeakSet()
const patchedResolvers = new WeakSet()

let tools

function createWrapExecute (tracer, config, defaultFieldResolver) {
  return function wrapExecute (execute) {
    return function executeWithTrace () {
      const args = normalizeArgs(arguments, tracer, config, defaultFieldResolver)
      const schema = args.schema
      const document = args.document
      const source = documentSources.get(document)
      const contextValue = args.contextValue
      const operation = getOperation(document, args.operationName)

      if (contexts.has(contextValue)) {
        return execute.apply(this, arguments)
      }

      if (schema) {
        wrapFields(schema._queryType, tracer, config)
        wrapFields(schema._mutationType, tracer, config)
      }

      const span = startExecutionSpan(tracer, config, operation, args)
      const context = { source, span, fields: {} }

      contexts.set(contextValue, context)

      return call(execute, span, this, arguments, (err, res) => {
        finishResolvers(context)

        setError(span, err || (res && res.errors && res.errors[0]))
        config.hooks.execute(span, args, res)
        finish(span)
      })
    }
  }
}

function createWrapParse (tracer, config) {
  return function wrapParse (parse) {
    return function parseWithTrace (source) {
      const span = startSpan(tracer, config, 'parse')

      analyticsSampler.sample(span, config.measured, true)

      let document
      try {
        document = parse.apply(this, arguments)
        const operation = getOperation(document)

        if (!operation) return document // skip schema parsing

        if (source) {
          documentSources.set(document, source.body || source)
        }

        addDocumentTags(span, document, config)

        return document
      } catch (e) {
        setError(span, e)
        throw e
      } finally {
        config.hooks.parse(span, source, document)
        finish(span)
      }
    }
  }
}

function createWrapValidate (tracer, config) {
  return function wrapValidate (validate) {
    return function validateWithTrace (schema, document, rules, typeInfo) {
      const span = startSpan(tracer, config, 'validate')

      analyticsSampler.sample(span, config.measured, true)

      // skip for schema stitching nested validation
      if (document && document.loc) {
        addDocumentTags(span, document, config)
      }

      let errors
      try {
        errors = validate.apply(this, arguments)

        setError(span, errors && errors[0])

        return errors
      } catch (e) {
        setError(span, e)
        throw e
      } finally {
        config.hooks.validate(span, document, errors)
        finish(span)
      }
    }
  }
}

function wrapFields (type, tracer, config) {
  if (!type || !type._fields || patchedTypes.has(type)) {
    return
  }

  patchedTypes.add(type)

  Object.keys(type._fields).forEach(key => {
    const field = type._fields[key]

    wrapFieldResolve(field, tracer, config)
    wrapFieldType(field, tracer, config)
  })
}

function wrapFieldResolve (field, tracer, config) {
  if (!field || !field.resolve) return

  field.resolve = wrapResolve(field.resolve, tracer, config)
}

function wrapFieldType (field, tracer, config) {
  if (!field || !field.type) return

  let unwrappedType = field.type

  while (unwrappedType.ofType) {
    unwrappedType = unwrappedType.ofType
  }

  wrapFields(unwrappedType, tracer, config)
}

function wrapResolve (resolve, tracer, config) {
  if (typeof resolve !== 'function' || patchedResolvers.has(resolve)) return resolve

  const responsePathAsArray = config.collapse
    ? withCollapse(pathToArray)
    : pathToArray

  function resolveWithTrace (source, args, contextValue, info) {
    const context = contexts.get(contextValue)

    if (!context) return resolve.apply(this, arguments)

    const path = responsePathAsArray(info && info.path)

    if (config.depth >= 0) {
      const depth = path.filter(item => typeof item === 'string').length

      if (config.depth < depth) {
        const parent = getParentField(tracer, context, path)

        return call(resolve, parent.span, this, arguments)
      }
    }

    const field = assertField(tracer, config, context, info, path)

    return call(resolve, field.span, this, arguments, err => updateField(field, err))
  }

  patchedResolvers.add(resolveWithTrace)

  return resolveWithTrace
}

function call (fn, span, thisArg, args, callback) {
  const scope = span.tracer().scope()

  callback = callback || (() => {})

  try {
    const result = scope.activate(span, () => fn.apply(thisArg, args))

    if (result && typeof result.then === 'function') {
      result.then(
        res => callback(null, res),
        err => callback(err)
      )
    } else {
      callback(null, result)
    }

    return result
  } catch (e) {
    callback(e)
    throw e
  }
}

function getParentField (tracer, context, path) {
  for (let i = path.length - 1; i > 0; i--) {
    const field = getField(context, path.slice(0, i))

    if (field) {
      return field
    }
  }

  return {
    span: context.span
  }
}

function getField (context, path) {
  return context.fields[path.join('.')]
}

function normalizeArgs (args, tracer, config, defaultFieldResolver) {
  if (args.length !== 1) return normalizePositional(args, tracer, config, defaultFieldResolver)

  args[0].contextValue = args[0].contextValue || {}
  args[0].fieldResolver = wrapResolve(args[0].fieldResolver || defaultFieldResolver, tracer, config)

  return args[0]
}

function normalizePositional (args, tracer, config, defaultFieldResolver) {
  args[3] = args[3] || {} // contextValue
  args[6] = wrapResolve(args[6] || defaultFieldResolver, tracer, config) // fieldResolver
  args.length = Math.max(args.length, 7)

  return {
    schema: args[0],
    document: args[1],
    rootValue: args[2],
    contextValue: args[3],
    variableValues: args[4],
    operationName: args[5],
    fieldResolver: args[6]
  }
}

function startExecutionSpan (tracer, config, operation, args) {
  const span = startSpan(tracer, config, 'execute')

  addExecutionTags(span, config, operation, args.document, args.operationName)
  addDocumentTags(span, args.document, config)
  addVariableTags(tracer, config, span, args.variableValues)

  analyticsSampler.sample(span, config.measured, true)

  return span
}

function addExecutionTags (span, config, operation, document, operationName) {
  const type = operation && operation.operation
  const name = operation && operation.name && operation.name.value
  const tags = {
    'resource.name': getSignature(document, name, type, config.signature)
  }

  if (type) {
    tags['graphql.operation.type'] = type
  }

  if (name) {
    tags['graphql.operation.name'] = name
  }

  span.addTags(tags)
}

function addDocumentTags (span, document, config) {
  const tags = {}

  if (config.source && document) {
    tags['graphql.source'] = documentSources.get(document)
  }

  span.addTags(tags)
}

function addVariableTags (tracer, config, span, variableValues) {
  const tags = {}

  if (variableValues && config.variables) {
    const variables = config.variables(variableValues)
    for (const param in variables) {
      tags[`graphql.variables.${param}`] = variables[param]
    }
  }

  span.addTags(tags)
}

function startSpan (tracer, config, name, options) {
  options = options || {}

  return tracer.startSpan(`graphql.${name}`, {
    childOf: options.childOf || tracer.scope().active(),
    startTime: options.startTime,
    tags: {
      'service.name': getService(tracer, config),
      'span.type': 'graphql'
    }
  })
}

function startResolveSpan (tracer, config, childOf, path, info, { source }) {
  const span = startSpan(tracer, config, 'resolve', { childOf })
  const document = source
  const fieldNode = info.fieldNodes.find(fieldNode => fieldNode.kind === 'Field')

  analyticsSampler.sample(span, config.measured)

  span.addTags({
    'resource.name': `${info.fieldName}:${info.returnType}`,
    'graphql.field.name': info.fieldName,
    'graphql.field.path': path.join('.'),
    'graphql.field.type': info.returnType.name
  })

  if (fieldNode) {
    if (config.source && document && fieldNode.loc) {
      span.setTag('graphql.source', document.substring(fieldNode.loc.start, fieldNode.loc.end))
    }

    if (config.variables && fieldNode.arguments) {
      const variables = config.variables(info.variableValues)

      fieldNode.arguments
        .filter(arg => arg.value && arg.value.kind === 'Variable')
        .filter(arg => arg.value.name && variables[arg.value.name.value])
        .map(arg => arg.value.name.value)
        .forEach(name => {
          span.setTag(`graphql.variables.${name}`, variables[name])
        })
    }
  }

  return span
}

function setError (span, error) {
  if (error) {
    span.setTag('error', error)
  }
}

function finish (span, finishTime) {
  span.finish(finishTime)
}

function finishResolvers ({ fields }) {
  Object.keys(fields).reverse().forEach(key => {
    const field = fields[key]

    setError(field.span, field.error)
    finish(field.span, field.finishTime)
  })
}

function updateField (field, error) {
  // TODO: update this to also work with no-op spans without a hack
  field.finishTime = field.span._getTime ? field.span._getTime() : 0
  field.error = field.error || error
}

function withCollapse (responsePathAsArray) {
  return function () {
    return responsePathAsArray.apply(this, arguments)
      .map(segment => typeof segment === 'number' ? '*' : segment)
  }
}

function assertField (tracer, config, context, info, path) {
  const pathString = path.join('.')
  const fields = context.fields

  let field = fields[pathString]

  if (!field) {
    const parent = getParentField(tracer, context, path)

    field = fields[pathString] = {
      parent,
      span: startResolveSpan(tracer, config, parent.span, path, info, context),
      error: null
    }
  }

  return field
}

function getService (tracer, config) {
  return config.service || tracer._service
}

function getOperation (document, operationName) {
  if (!document || !Array.isArray(document.definitions)) {
    return
  }

  const definitions = document.definitions.filter(def => def)
  const types = ['query', 'mutation', 'subscription']

  if (operationName) {
    return definitions
      .filter(def => types.indexOf(def.operation) !== -1)
      .find(def => operationName === (def.name && def.name.value))
  } else {
    return definitions.find(def => types.indexOf(def.operation) !== -1)
  }
}

function validateConfig (config) {
  return Object.assign({}, config, {
    depth: getDepth(config),
    variables: getVariablesFilter(config),
    collapse: config.collapse === undefined || !!config.collapse,
    hooks: getHooks(config)
  })
}

function getDepth (config) {
  if (typeof config.depth === 'number') {
    return config.depth
  } else if (config.hasOwnProperty('depth')) {
    log.error('Expected `depth` to be a integer.')
  }
  return -1
}

function getVariablesFilter (config) {
  if (typeof config.variables === 'function') {
    return config.variables
  } else if (config.variables instanceof Array) {
    return variables => pick(variables, config.variables)
  } else if (config.hasOwnProperty('variables')) {
    log.error('Expected `variables` to be an array or function.')
  }
  return null
}

function getSignature (document, operationName, operationType, calculate) {
  if (calculate !== false && tools !== false) {
    try {
      try {
        tools = tools || __webpack_require__(/*! ./tools */ "../../node_modules/dd-trace/packages/datadog-plugin-graphql/src/tools/index.js")
      } catch (e) {
        tools = false
        throw e
      }

      return tools.defaultEngineReportingSignature(document, operationName)
    } catch (e) {
      // safety net
    }
  }

  return [operationType, operationName].filter(val => val).join(' ')
}

function pathToArray (path) {
  const flattened = []
  let curr = path
  while (curr) {
    flattened.push(curr.key)
    curr = curr.prev
  }
  return flattened.reverse()
}

function getHooks (config) {
  const noop = () => {}
  const execute = (config.hooks && config.hooks.execute) || noop
  const parse = (config.hooks && config.hooks.parse) || noop
  const validate = (config.hooks && config.hooks.validate) || noop

  return { execute, parse, validate }
}

module.exports = [
  {
    name: 'graphql',
    file: 'execution/execute.js',
    versions: ['>=0.10'],
    patch (execute, tracer, config) {
      this.wrap(execute, 'execute', createWrapExecute(
        tracer,
        validateConfig(config),
        execute.defaultFieldResolver
      ))
    },
    unpatch (execute) {
      this.unwrap(execute, 'execute')
    }
  },
  {
    name: 'graphql',
    file: 'language/parser.js',
    versions: ['>=0.10'],
    patch (parser, tracer, config) {
      this.wrap(parser, 'parse', createWrapParse(tracer, validateConfig(config)))
    },
    unpatch (parser) {
      this.unwrap(parser, 'parse')
    }
  },
  {
    name: 'graphql',
    file: 'validation/validate.js',
    versions: ['>=0.10'],
    patch (validate, tracer, config) {
      this.wrap(validate, 'validate', createWrapValidate(tracer, validateConfig(config)))
    },
    unpatch (validate) {
      this.unwrap(validate, 'validate')
    }
  }
]


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-graphql/src/tools/index.js":
/*!*******************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-graphql/src/tools/index.js ***!
  \*******************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* eslint-disable */
// file mostly untouched from apollo-graphql


Object.defineProperty(exports, "__esModule", { value: true });
var signature_1 = __webpack_require__(/*! ./signature */ "../../node_modules/dd-trace/packages/datadog-plugin-graphql/src/tools/signature.js");
exports.defaultEngineReportingSignature = signature_1.defaultEngineReportingSignature;


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-graphql/src/tools/signature.js":
/*!***********************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-graphql/src/tools/signature.js ***!
  \***********************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* eslint-disable */
// file mostly untouched from apollo-graphql


Object.defineProperty(exports, "__esModule", { value: true });
const transforms_1 = __webpack_require__(/*! ./transforms */ "../../node_modules/dd-trace/packages/datadog-plugin-graphql/src/tools/transforms.js");
function defaultEngineReportingSignature(ast, operationName) {
    return transforms_1.printWithReducedWhitespace(transforms_1.sortAST(transforms_1.removeAliases(transforms_1.hideLiterals(transforms_1.dropUnusedDefinitions(ast, operationName)))));
}
exports.defaultEngineReportingSignature = defaultEngineReportingSignature;


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-graphql/src/tools/transforms.js":
/*!************************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-graphql/src/tools/transforms.js ***!
  \************************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* eslint-disable */
// file mostly untouched from apollo-graphql


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const visitor_1 = __webpack_require__(/*! graphql/language/visitor */ "../../node_modules/graphql/language/visitor.mjs");
const printer_1 = __webpack_require__(/*! graphql/language/printer */ "../../node_modules/graphql/language/printer.mjs");
const utilities_1 = __webpack_require__(/*! graphql/utilities */ "../../node_modules/graphql/utilities/index.mjs");
const lodash_sortby_1 = __importDefault(__webpack_require__(/*! lodash.sortby */ "../../node_modules/lodash.sortby/index.js"));
function hideLiterals(ast) {
    return visitor_1.visit(ast, {
        IntValue(node) {
            return Object.assign({}, node, { value: "0" });
        },
        FloatValue(node) {
            return Object.assign({}, node, { value: "0" });
        },
        StringValue(node) {
            return Object.assign({}, node, { value: "", block: false });
        },
        ListValue(node) {
            return Object.assign({}, node, { values: [] });
        },
        ObjectValue(node) {
            return Object.assign({}, node, { fields: [] });
        }
    });
}
exports.hideLiterals = hideLiterals;
function hideStringAndNumericLiterals(ast) {
    return visitor_1.visit(ast, {
        IntValue(node) {
            return Object.assign({}, node, { value: "0" });
        },
        FloatValue(node) {
            return Object.assign({}, node, { value: "0" });
        },
        StringValue(node) {
            return Object.assign({}, node, { value: "", block: false });
        }
    });
}
exports.hideStringAndNumericLiterals = hideStringAndNumericLiterals;
function dropUnusedDefinitions(ast, operationName) {
    const separated = utilities_1.separateOperations(ast)[operationName];
    if (!separated) {
        return ast;
    }
    return separated;
}
exports.dropUnusedDefinitions = dropUnusedDefinitions;
function sorted(items) {
    if (items) {
        return lodash_sortby_1.default.apply(null, arguments);
    }
    return undefined;
}
function sortAST(ast) {
    return visitor_1.visit(ast, {
        OperationDefinition(node) {
            return Object.assign({}, node, { variableDefinitions: sorted(node.variableDefinitions, "variable.name.value") });
        },
        SelectionSet(node) {
            return Object.assign({}, node, { selections: lodash_sortby_1.default(node.selections, "kind", "name.value") });
        },
        Field(node) {
            return Object.assign({}, node, { arguments: sorted(node.arguments, "name.value") });
        },
        FragmentSpread(node) {
            return Object.assign({}, node, { directives: sorted(node.directives, "name.value") });
        },
        InlineFragment(node) {
            return Object.assign({}, node, { directives: sorted(node.directives, "name.value") });
        },
        FragmentDefinition(node) {
            return Object.assign({}, node, { directives: sorted(node.directives, "name.value"), variableDefinitions: sorted(node.variableDefinitions, "variable.name.value") });
        },
        Directive(node) {
            return Object.assign({}, node, { arguments: sorted(node.arguments, "name.value") });
        }
    });
}
exports.sortAST = sortAST;
function removeAliases(ast) {
    return visitor_1.visit(ast, {
        Field(node) {
            return Object.assign({}, node, { alias: undefined });
        }
    });
}
exports.removeAliases = removeAliases;
function printWithReducedWhitespace(ast) {
    const sanitizedAST = visitor_1.visit(ast, {
        StringValue(node) {
            return Object.assign({}, node, { value: Buffer.from(node.value, "utf8").toString("hex"), block: false });
        }
    });
    const withWhitespace = printer_1.print(sanitizedAST);
    const minimizedButStillHex = withWhitespace
        .replace(/\s+/g, " ")
        .replace(/([^_a-zA-Z0-9]) /g, (_, c) => c)
        .replace(/ ([^_a-zA-Z0-9])/g, (_, c) => c);
    return minimizedButStillHex.replace(/"([a-f0-9]+)"/g, (_, hex) => JSON.stringify(Buffer.from(hex, "hex").toString("utf8")));
}
exports.printWithReducedWhitespace = printWithReducedWhitespace;


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-grpc/src/client.js":
/*!***********************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-grpc/src/client.js ***!
  \***********************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const analyticsSampler = __webpack_require__(/*! ../../dd-trace/src/analytics_sampler */ "../../node_modules/dd-trace/packages/dd-trace/src/analytics_sampler.js")
const Tags = __webpack_require__(/*! ../../../ext/tags */ "../../node_modules/dd-trace/ext/tags.js")
const { TEXT_MAP } = __webpack_require__(/*! ../../../ext/formats */ "../../node_modules/dd-trace/ext/formats.js")
const { ERROR } = __webpack_require__(/*! ../../../ext/tags */ "../../node_modules/dd-trace/ext/tags.js")
const kinds = __webpack_require__(/*! ./kinds */ "../../node_modules/dd-trace/packages/datadog-plugin-grpc/src/kinds.js")
const { addMethodTags, addMetadataTags, getFilter } = __webpack_require__(/*! ./util */ "../../node_modules/dd-trace/packages/datadog-plugin-grpc/src/util.js")

const patched = new WeakSet()
const instances = new WeakMap()

function createWrapMakeRequest (tracer, config, methodKind) {
  const filter = getFilter(config, 'metadata')

  return function wrapMakeRequest (makeRequest) {
    return function makeRequestWithTrace (path) {
      const args = ensureMetadata(this, arguments, 4)

      return callMethod(tracer, config, this, makeRequest, args, path, args[4], methodKind, filter)
    }
  }
}

function createWrapLoadPackageDefinition (tracer, config) {
  return function wrapLoadPackageDefinition (loadPackageDefinition) {
    return function loadPackageDefinitionWithTrace (packageDef) {
      const result = loadPackageDefinition.apply(this, arguments)

      if (!result) return result

      wrapPackageDefinition(tracer, config, result)

      return result
    }
  }
}

function createWrapMakeClientConstructor (tracer, config) {
  return function wrapMakeClientConstructor (makeClientConstructor) {
    return function makeClientConstructorWithTrace (methods) {
      const ServiceClient = makeClientConstructor.apply(this, arguments)

      wrapClientConstructor(tracer, config, ServiceClient, methods)

      return ServiceClient
    }
  }
}

function wrapPackageDefinition (tracer, config, def) {
  for (const name in def) {
    if (def[name].format) continue
    if (def[name].service && def[name].prototype) {
      wrapClientConstructor(tracer, config, def[name], def[name].service)
    } else {
      wrapPackageDefinition(tracer, config, def[name])
    }
  }
}

function wrapClientConstructor (tracer, config, ServiceClient, methods) {
  const proto = ServiceClient.prototype

  if (typeof methods !== 'object' || 'format' in methods) return

  Object.keys(methods)
    .forEach(name => {
      if (!methods[name]) return

      const originalName = methods[name].originalName
      const path = methods[name].path
      const methodKind = getMethodKind(methods[name])

      if (methods[name]) {
        proto[name] = wrapMethod(tracer, config, proto[name], path, methodKind)
      }

      if (originalName) {
        proto[originalName] = wrapMethod(tracer, config, proto[originalName], path, methodKind)
      }
    })
}

function wrapMethod (tracer, config, method, path, methodKind) {
  if (typeof method !== 'function' || patched.has(method)) {
    return method
  }

  const filter = getFilter(config, 'metadata')

  const methodWithTrace = function methodWithTrace () {
    const args = ensureMetadata(this, arguments, 1)

    return callMethod(tracer, config, this, method, args, path, args[1], methodKind, filter)
  }

  Object.assign(methodWithTrace, method)

  patched.add(methodWithTrace)

  return methodWithTrace
}

function wrapCallback (span, callback) {
  const scope = span.tracer().scope()
  const parent = scope.active()

  return function (err) {
    err && span.setTag(ERROR, err)

    if (callback) {
      return scope.bind(callback, parent).apply(this, arguments)
    }
  }
}

function wrapStream (span, call, filter) {
  if (!call || typeof call.emit !== 'function') return

  const emit = call.emit

  call.emit = function (eventName, ...args) {
    switch (eventName) {
      case 'error':
        span.setTag(ERROR, args[0] || 1)

        break
      case 'status':
        if (args[0]) {
          span.setTag('grpc.status.code', args[0].code)

          addMetadataTags(span, args[0].metadata, filter, 'response')
        }

        span.finish()

        break
    }

    return emit.apply(this, arguments)
  }
}

function callMethod (tracer, config, client, method, args, path, metadata, methodKind, filter) {
  const length = args.length
  const callback = args[length - 1]
  const scope = tracer.scope()
  const span = startSpan(tracer, config, path, methodKind)

  if (metadata) {
    addMetadataTags(span, metadata, filter, 'request')
    inject(tracer, span, metadata)
  }

  if (methodKind === kinds.unary || methodKind === kinds.client_stream) {
    if (typeof callback === 'function') {
      args[length - 1] = wrapCallback(span, callback)
    } else {
      args[length] = wrapCallback(span)
    }
  }

  const call = scope.bind(method, span).apply(client, args)

  wrapStream(span, call, filter)

  return scope.bind(call)
}

function startSpan (tracer, config, path, methodKind) {
  const scope = tracer.scope()
  const childOf = scope.active()
  const span = tracer.startSpan('grpc.request', {
    childOf,
    tags: {
      [Tags.SPAN_KIND]: 'client',
      'span.type': 'http',
      'resource.name': path,
      'service.name': config.service || `${tracer._service}-grpc-client`,
      'component': 'grpc'
    }
  })

  analyticsSampler.sample(span, config.measured)
  addMethodTags(span, path, methodKind)

  return span
}

function ensureMetadata (client, args, index) {
  const grpc = getGrpc(client)

  if (!client || !grpc) return args

  const meta = args[index]
  const normalized = []

  for (let i = 0; i < index; i++) {
    normalized.push(args[i])
  }

  if (!meta || !meta.constructor || meta.constructor.name !== 'Metadata') {
    normalized.push(new grpc.Metadata())
  }

  if (meta) {
    normalized.push(meta)
  }

  for (let i = index + 1; i < args.length; i++) {
    normalized.push(args[i])
  }

  return normalized
}

function inject (tracer, span, metadata) {
  if (typeof metadata.set !== 'function') return

  const carrier = {}

  tracer.inject(span, TEXT_MAP, carrier)

  for (const key in carrier) {
    metadata.set(key, carrier[key])
  }
}

function getMethodKind (definition) {
  if (definition.requestStream) {
    if (definition.responseStream) {
      return kinds.bidi
    }

    return kinds.client_stream
  }

  if (definition.responseStream) {
    return kinds.server_stream
  }

  return kinds.unary
}

function getGrpc (client) {
  let proto = client

  do {
    const instance = instances.get(proto)
    if (instance) return instance
  } while ((proto = Object.getPrototypeOf(proto)))
}

function patch (grpc, tracer, config) {
  if (config.client === false) return

  config = config.client || config

  const proto = grpc.Client.prototype

  instances.set(proto, grpc)

  this.wrap(proto, 'makeBidiStreamRequest', createWrapMakeRequest(tracer, config, kinds.bidi))
  this.wrap(proto, 'makeClientStreamRequest', createWrapMakeRequest(tracer, config, kinds.clientStream))
  this.wrap(proto, 'makeServerStreamRequest', createWrapMakeRequest(tracer, config, kinds.serverStream))
  this.wrap(proto, 'makeUnaryRequest', createWrapMakeRequest(tracer, config, kinds.unary))
}

function unpatch (grpc) {
  const proto = grpc.Client.prototype

  instances.delete(proto)

  this.unwrap(proto, 'makeBidiStreamRequest')
  this.unwrap(proto, 'makeClientStreamRequest')
  this.unwrap(proto, 'makeServerStreamRequest')
  this.unwrap(proto, 'makeUnaryRequest')
}

module.exports = [
  {
    name: 'grpc',
    versions: ['>=1.20.2'],
    patch,
    unpatch
  },
  {
    name: 'grpc',
    versions: ['>=1.20.2'],
    file: 'src/client.js',
    patch (client, tracer, config) {
      if (config.client === false) return

      config = config.client || config

      this.wrap(client, 'makeClientConstructor', createWrapMakeClientConstructor(tracer, config))
    },
    unpatch (client) {
      this.unwrap(client, 'makeClientConstructor')
    }
  },
  {
    name: '@grpc/grpc-js',
    versions: ['>=1.0.3'],
    patch,
    unpatch
  },
  {
    name: '@grpc/grpc-js',
    versions: ['>=1.0.3'],
    file: 'build/src/make-client.js',
    patch (client, tracer, config) {
      if (config.client === false) return

      config = config.client || config

      this.wrap(client, 'makeClientConstructor', createWrapMakeClientConstructor(tracer, config))
      this.wrap(client, 'loadPackageDefinition', createWrapLoadPackageDefinition(tracer, config))
    },
    unpatch (client) {
      this.unwrap(client, 'makeClientConstructor')
      this.unwrap(client, 'loadPackageDefinition')
    }
  }
]


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-grpc/src/index.js":
/*!**********************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-grpc/src/index.js ***!
  \**********************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const client = __webpack_require__(/*! ./client */ "../../node_modules/dd-trace/packages/datadog-plugin-grpc/src/client.js")
const server = __webpack_require__(/*! ./server */ "../../node_modules/dd-trace/packages/datadog-plugin-grpc/src/server.js")

module.exports = [].concat(client, server)


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-grpc/src/kinds.js":
/*!**********************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-grpc/src/kinds.js ***!
  \**********************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = {
  unary: 'unary',
  bidi: 'bidi_streaming',
  client_stream: 'client_streaming',
  clientStream: 'client_streaming',
  server_stream: 'server_streaming',
  serverStream: 'server_streaming'
}


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-grpc/src/server.js":
/*!***********************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-grpc/src/server.js ***!
  \***********************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const analyticsSampler = __webpack_require__(/*! ../../dd-trace/src/analytics_sampler */ "../../node_modules/dd-trace/packages/dd-trace/src/analytics_sampler.js")
const Tags = __webpack_require__(/*! ../../../ext/tags */ "../../node_modules/dd-trace/ext/tags.js")
const { TEXT_MAP } = __webpack_require__(/*! ../../../ext/formats */ "../../node_modules/dd-trace/ext/formats.js")
const { ERROR } = __webpack_require__(/*! ../../../ext/tags */ "../../node_modules/dd-trace/ext/tags.js")
const kinds = __webpack_require__(/*! ./kinds */ "../../node_modules/dd-trace/packages/datadog-plugin-grpc/src/kinds.js")
const { addMethodTags, addMetadataTags, getFilter } = __webpack_require__(/*! ./util */ "../../node_modules/dd-trace/packages/datadog-plugin-grpc/src/util.js")

// https://github.com/grpc/grpc/blob/master/doc/statuscodes.md
const OK = 0
const CANCELLED = 1

function createWrapHandler (tracer, config, handler) {
  const filter = getFilter(config, 'metadata')

  return function wrapHandler (func) {
    const isValid = (server, args) => {
      if (!server || !server.type) return false
      if (!args[0]) return false
      if (server.type !== 'unary' && !isEmitter(args[0])) return false
      if (server.type === 'unary' && typeof args[1] !== 'function') return false

      return true
    }

    return function funcWithTrace (call, callback) {
      if (!isValid(this, arguments)) return func.apply(this, arguments)

      const metadata = call.metadata
      const type = this.type
      const isStream = type !== 'unary'
      const scope = tracer.scope()
      const childOf = extract(tracer, metadata)
      const span = tracer.startSpan('grpc.request', {
        childOf,
        tags: {
          [Tags.SPAN_KIND]: 'server',
          'span.type': 'web',
          'resource.name': handler,
          'service.name': config.service || `${tracer._service}`,
          'component': 'grpc'
        }
      })

      analyticsSampler.sample(span, config.measured, true)
      addMethodTags(span, handler, kinds[type])
      addMetadataTags(span, metadata, filter, 'request')

      scope.bind(call)

      // Finish the span if the call was cancelled.
      call.once('cancelled', () => {
        span.setTag('grpc.status.code', CANCELLED)
        span.finish()
      })

      if (isStream) {
        wrapStream(span, call)
      } else {
        arguments[1] = wrapCallback(span, callback, filter, childOf)
      }

      return scope.bind(func, span).apply(this, arguments)
    }
  }
}

function createWrapRegister (tracer, config) {
  config = config.server || config

  return function wrapRegister (register) {
    return function registerWithTrace (name, handler, serialize, deserialize, type) {
      if (typeof handler === 'function') {
        arguments[1] = createWrapHandler(tracer, config, name)(handler)
      }

      return register.apply(this, arguments)
    }
  }
}

function wrapStream (span, call, tracer) {
  const emit = call.emit

  if (call.call && call.call.sendStatus) {
    call.call.sendStatus = wrapSendStatus(call.call.sendStatus, span)
  }

  call.emit = function (eventName, ...args) {
    switch (eventName) {
      case 'error':
        span.addTags({
          [ERROR]: args[0] || 1,
          'grpc.status.code': args[0] && args[0].code
        })

        span.finish()

        break

      // Finish the span of the response only if it was successful.
      // Otherwise it'll be finished in the `error` listener.
      case 'finish':
        if (call.status) {
          span.setTag('grpc.status.code', call.status.code)
        }

        if (!call.status || call.status.code === 0) {
          span.finish()
        }

        break
    }

    return emit.apply(this, arguments)
  }
}

function wrapCallback (span, callback, filter, childOf) {
  const scope = span.tracer().scope()

  return function (err, value, trailer, flags) {
    if (err instanceof Error) {
      if (err.code) {
        span.setTag('grpc.status.code', err.code)
      }

      span.setTag(ERROR, err)
    } else {
      span.setTag('grpc.status.code', OK)
    }

    if (trailer && filter) {
      addMetadataTags(span, trailer, filter, 'response')
    }

    span.finish()

    if (callback) {
      return scope.bind(callback, childOf).apply(this, arguments)
    }
  }
}

function wrapSendStatus (sendStatus, span) {
  return function sendStatusWithTrace (status) {
    span.setTag('grpc.status.code', status.code)

    return sendStatus.apply(this, arguments)
  }
}

function extract (tracer, metadata) {
  if (!metadata || typeof metadata.getMap !== 'function') return null

  return tracer.extract(TEXT_MAP, metadata.getMap())
}

function isEmitter (obj) {
  return typeof obj.emit === 'function' && typeof obj.once === 'function'
}

module.exports = [
  {
    name: 'grpc',
    versions: ['>=1.20.2'],
    file: 'src/server.js',
    patch (server, tracer, config) {
      if (config.server === false) return
      this.wrap(server.Server.prototype, 'register', createWrapRegister(tracer, config))
    },
    unpatch (server) {
      this.unwrap(server.Server.prototype, 'register')
    }
  },
  {
    name: '@grpc/grpc-js',
    versions: ['>=1'],
    file: 'build/src/server.js',
    patch (server, tracer, config) {
      if (config.server === false) return

      this.wrap(server.Server.prototype, 'register', createWrapRegister(tracer, config))
    },
    unpatch (server) {
      this.unwrap(server.Server.prototype, 'register')
    }
  }
]


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-grpc/src/util.js":
/*!*********************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-grpc/src/util.js ***!
  \*********************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const pick = __webpack_require__(/*! lodash.pick */ "../../node_modules/lodash.pick/index.js")
const log = __webpack_require__(/*! ../../dd-trace/src/log */ "../../node_modules/dd-trace/packages/dd-trace/src/log.js")

module.exports = {
  addMethodTags (span, path, kind) {
    if (typeof path !== 'string') return

    span.addTags({
      'grpc.method.path': path,
      'grpc.method.kind': kind
    })

    const methodParts = path.split('/')

    if (methodParts.length > 2) {
      const serviceParts = methodParts[1].split('.')
      const name = methodParts[2]
      const service = serviceParts.pop()
      const pkg = serviceParts.join('.')

      span.addTags({
        'grpc.method.name': name,
        'grpc.method.service': service,
        'grpc.method.package': pkg
      })
    } else {
      span.addTags({
        'grpc.method.name': methodParts[methodParts.length - 1]
      })
    }
  },

  addMetadataTags (span, metadata, filter, type) {
    if (!metadata || typeof metadata.getMap !== 'function') return

    const values = filter(metadata.getMap())

    for (const key in values) {
      span.setTag(`grpc.${type}.metadata.${key}`, values[key])
    }
  },

  // TODO: extract this to shared utils and add unit tests
  getFilter (config, filter) {
    if (typeof config[filter] === 'function') {
      return config[filter]
    }

    if (config[filter] instanceof Array) {
      return element => pick(element, config[filter])
    }

    if (config.hasOwnProperty(filter)) {
      log.error(`Expected '${filter}' to be an array or function.`)
    }

    return () => ({})
  }
}


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-hapi/src/index.js":
/*!**********************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-hapi/src/index.js ***!
  \**********************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const route = __webpack_require__(/*! ./route */ "../../node_modules/dd-trace/packages/datadog-plugin-hapi/src/route.js")
const server = __webpack_require__(/*! ./server */ "../../node_modules/dd-trace/packages/datadog-plugin-hapi/src/server.js")

module.exports = [].concat(route, server)


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-hapi/src/route.js":
/*!**********************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-hapi/src/route.js ***!
  \**********************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const web = __webpack_require__(/*! ../../dd-trace/src/plugins/util/web */ "../../node_modules/dd-trace/packages/dd-trace/src/plugins/util/web.js")

function createWrapRebuild () {
  return function wrapRebuild (rebuild) {
    return function rebuildWithTrace (event) {
      const result = rebuild.apply(this, arguments)

      if (this && Array.isArray(this._cycle)) {
        this._cycle = this._cycle.map(wrapMiddleware)
      }

      return result
    }
  }
}

function createWrapLifecycle () {
  return function wrapLifecycle (lifecycle) {
    return function lifecycleWithTrace () {
      const result = lifecycle.apply(this, arguments)

      if (Array.isArray(result)) return result.map(wrapMiddleware)

      return result
    }
  }
}

function wrapMiddleware (middleware) {
  if (typeof middleware !== 'function') return middleware

  return function (request, next) {
    if (!request || !request.raw) return middleware.apply(this, arguments)

    return web.reactivate(request.raw.req, () => middleware.apply(this, arguments))
  }
}

module.exports = [
  {
    name: '@hapi/hapi',
    versions: ['>=17.9'],
    file: 'lib/route.js',
    patch (Route, tracer, config) {
      this.wrap(Route.prototype, 'rebuild', createWrapRebuild(tracer, config))
    },
    unpatch (Route) {
      this.unwrap(Route.prototype, 'rebuild')
    }
  },
  {
    name: 'hapi',
    versions: ['>=10.4'],
    file: 'lib/route.js',
    patch (Route, tracer, config) {
      this.wrap(Route.prototype, 'rebuild', createWrapRebuild(tracer, config))
    },
    unpatch (Route) {
      this.unwrap(Route.prototype, 'rebuild')
    }
  },
  {
    name: 'hapi',
    versions: ['2 - 10.3'],
    file: 'lib/route.js',
    patch (Route, tracer, config) {
      this.wrap(Route.prototype, 'lifecycle', createWrapLifecycle(tracer, config))
    },
    unpatch (Route) {
      this.unwrap(Route.prototype, 'lifecycle')
    }
  }
]


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-hapi/src/server.js":
/*!***********************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-hapi/src/server.js ***!
  \***********************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const web = __webpack_require__(/*! ../../dd-trace/src/plugins/util/web */ "../../node_modules/dd-trace/packages/dd-trace/src/plugins/util/web.js")

function createWrapDispatch (tracer, config) {
  config = web.normalizeConfig(config)

  return function wrapDispatch (dispatch) {
    return function dispatchWithTrace (options) {
      const handler = dispatch.apply(this, arguments)

      if (typeof handler !== 'function') return handler

      return function (req, res) {
        return web.instrument(tracer, config, req, res, 'hapi.request', () => {
          return handler.apply(this, arguments)
        })
      }
    }
  }
}

function createWrapServer (tracer) {
  return function wrapServer (server) {
    return function serverWithTrace (options) {
      const app = server.apply(this, arguments)

      if (!app) return app

      if (typeof app.ext === 'function') {
        app.ext = createWrapExt(tracer)(app.ext)
      }

      if (typeof app.start === 'function') {
        app.start = createWrapStart(tracer)(app.start)
      }

      return app
    }
  }
}

function createWrapStart () {
  return function wrapStart (start) {
    return function startWithTrace () {
      if (this && typeof this.ext === 'function') {
        this.ext('onPreResponse', onPreResponse)
      }

      return start.apply(this, arguments)
    }
  }
}

function createWrapExt () {
  return function wrapExt (ext) {
    return function extWithTrace (events, method, options) {
      if (typeof events === 'object') {
        arguments[0] = wrapEvents(events)
      } else {
        arguments[1] = wrapExtension(method)
      }

      return ext.apply(this, arguments)
    }
  }
}

function wrapExtension (method) {
  return [].concat(method).map(wrapHandler)
}

function wrapEvents (events) {
  return [].concat(events).map(event => {
    if (!event || !event.method) return event

    return Object.assign({}, event, {
      method: wrapExtension(event.method)
    })
  })
}

function wrapHandler (handler) {
  if (typeof handler !== 'function') return handler

  return function (request, h) {
    if (!request || !request.raw) return handler.apply(this, arguments)

    return web.reactivate(request.raw.req, () => handler.apply(this, arguments))
  }
}

function onPreResponse (request, h) {
  if (!request || !request.raw) return reply(request, h)

  const req = request.raw.req

  web.addError(req, request.response)

  if (request.route) {
    web.enterRoute(req, request.route.path)
  }

  return reply(request, h)
}

function reply (request, h) {
  if (h.continue) {
    return typeof h.continue === 'function'
      ? h.continue()
      : h.continue
  } else if (typeof h === 'function') {
    return h()
  }
}

module.exports = [
  {
    name: '@hapi/hapi',
    versions: ['>=17.9'],
    patch (hapi, tracer, config) {
      this.wrap(hapi, ['server', 'Server'], createWrapServer(tracer, config))
    },
    unpatch (hapi) {
      this.unwrap(hapi, ['server', 'Server'])
    }
  },
  {
    name: 'hapi',
    versions: ['>=17'],
    patch (hapi, tracer, config) {
      this.wrap(hapi, ['server', 'Server'], createWrapServer(tracer, config))
    },
    unpatch (hapi) {
      this.unwrap(hapi, ['server', 'Server'])
    }
  },
  {
    name: 'hapi',
    versions: ['2 - 7.1', '8 - 16'],
    patch (hapi, tracer, config) {
      this.wrap(hapi.Server.prototype, 'start', createWrapStart(tracer, config))
      this.wrap(hapi.Server.prototype, 'ext', createWrapExt(tracer, config))
    },
    unpatch (hapi) {
      this.unwrap(hapi.Server.prototype, 'start')
      this.unwrap(hapi.Server.prototype, 'ext')
    }
  },
  {
    name: 'hapi',
    versions: ['^7.2'],
    patch (hapi, tracer, config) {
      this.wrap(hapi, 'createServer', createWrapServer(tracer, config))
    },
    unpatch (hapi) {
      this.unwrap(hapi, 'createServer')
    }
  },
  {
    name: '@hapi/hapi',
    versions: ['>=17.9'],
    file: 'lib/core.js',
    patch (Core, tracer, config) {
      this.wrap(Core.prototype, '_dispatch', createWrapDispatch(tracer, config))
    },
    unpatch (Core) {
      this.unwrap(Core.prototype, '_dispatch')
    }
  },
  {
    name: 'hapi',
    versions: ['7.2 - 16'],
    file: 'lib/connection.js',
    patch (Connection, tracer, config) {
      this.wrap(Connection.prototype, '_dispatch', createWrapDispatch(tracer, config))
    },
    unpatch (Connection) {
      this.unwrap(Connection.prototype, '_dispatch')
    }
  },
  {
    name: 'hapi',
    versions: ['>=17'],
    file: 'lib/core.js',
    patch (Core, tracer, config) {
      this.wrap(Core.prototype, '_dispatch', createWrapDispatch(tracer, config))
    },
    unpatch (Core) {
      this.unwrap(Core.prototype, '_dispatch')
    }
  },
  {
    name: 'hapi',
    versions: ['2 - 7.1'],
    file: 'lib/server.js',
    patch (Server, tracer, config) {
      this.wrap(Server.prototype, '_dispatch', createWrapDispatch(tracer, config))
    },
    unpatch (Server) {
      this.unwrap(Server.prototype, '_dispatch')
    }
  }
]


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-http/src/client.js":
/*!***********************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-http/src/client.js ***!
  \***********************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Plugin = __webpack_require__(/*! ../../dd-trace/src/plugins/plugin */ "../../node_modules/dd-trace/packages/dd-trace/src/plugins/plugin.js")
const { storage } = __webpack_require__(/*! ../../datadog-core */ "../../node_modules/dd-trace/packages/datadog-core/index.js")
const tags = __webpack_require__(/*! ../../../ext/tags */ "../../node_modules/dd-trace/ext/tags.js")
const analyticsSampler = __webpack_require__(/*! ../../dd-trace/src/analytics_sampler */ "../../node_modules/dd-trace/packages/dd-trace/src/analytics_sampler.js")
const formats = __webpack_require__(/*! ../../../ext/formats */ "../../node_modules/dd-trace/ext/formats.js")
const HTTP_HEADERS = formats.HTTP_HEADERS
const urlFilter = __webpack_require__(/*! ../../dd-trace/src/plugins/util/urlfilter */ "../../node_modules/dd-trace/packages/dd-trace/src/plugins/util/urlfilter.js")
const log = __webpack_require__(/*! ../../dd-trace/src/log */ "../../node_modules/dd-trace/packages/dd-trace/src/log.js")
const url = __webpack_require__(/*! url */ "url")

const HTTP_STATUS_CODE = tags.HTTP_STATUS_CODE
const HTTP_REQUEST_HEADERS = tags.HTTP_REQUEST_HEADERS
const HTTP_RESPONSE_HEADERS = tags.HTTP_RESPONSE_HEADERS

class HttpClientPlugin extends Plugin {
  static get name () {
    return 'http'
  }

  constructor (...args) {
    super(...args)

    this.addSub('apm:http:client:request:start', ({ args, http }) => {
      const store = storage.getStore()
      const options = args.options
      const agent = options.agent || options._defaultAgent || http.globalAgent
      const protocol = options.protocol || agent.protocol || 'http:'
      const hostname = options.hostname || options.host || 'localhost'
      const host = options.port ? `${hostname}:${options.port}` : hostname
      const path = options.path ? options.path.split(/[?#]/)[0] : '/'
      const uri = `${protocol}//${host}${path}`

      const method = (options.method || 'GET').toUpperCase()
      const childOf = store ? store.span : store
      const span = this.tracer.startSpan('http.request', {
        childOf,
        tags: {
          'span.kind': 'client',
          'service.name': getServiceName(this.tracer, this.config, options),
          'resource.name': method,
          'span.type': 'http',
          'http.method': method,
          'http.url': uri
        }
      })

      if (!(hasAmazonSignature(options) || !this.config.propagationFilter(uri))) {
        this.tracer.inject(span, HTTP_HEADERS, options.headers)
      }

      analyticsSampler.sample(span, this.config.measured)
      this.enter(span, store)
    })

    this.addSub('apm:http:client:request:end', this.exit.bind(this))

    this.addSub('apm:http:client:request:async-end', ({ req, res }) => {
      const span = storage.getStore().span
      if (res) {
        span.setTag(HTTP_STATUS_CODE, res.statusCode)

        if (!this.config.validateStatus(res.statusCode)) {
          span.setTag('error', 1)
        }

        addResponseHeaders(res, span, this.config)
      } else {
        span.setTag('error', 1)
      }

      addRequestHeaders(req, span, this.config)

      this.config.hooks.request(span, req, res)
      span.finish()
    })

    this.addSub('apm:http:client:request:error', errorHandler)
  }

  configure (config) {
    return super.configure(normalizeClientConfig(config))
  }
}

function errorHandler (err) {
  const span = storage.getStore().span
  span.addTags({
    'error.type': err.name,
    'error.msg': err.message,
    'error.stack': err.stack
  })
}

function addResponseHeaders (res, span, config) {
  config.headers.forEach(key => {
    const value = res.headers[key]

    if (value) {
      span.setTag(`${HTTP_RESPONSE_HEADERS}.${key}`, value)
    }
  })
}

function addRequestHeaders (req, span, config) {
  config.headers.forEach(key => {
    const value = req.getHeader(key)

    if (value) {
      span.setTag(`${HTTP_REQUEST_HEADERS}.${key}`, value)
    }
  })
}

function normalizeClientConfig (config) {
  const validateStatus = getStatusValidator(config)
  const propagationFilter = getFilter({ blocklist: config.propagationBlocklist })
  const headers = getHeaders(config)
  const hooks = getHooks(config)

  return Object.assign({}, config, {
    validateStatus,
    propagationFilter,
    headers,
    hooks
  })
}

function getStatusValidator (config) {
  if (typeof config.validateStatus === 'function') {
    return config.validateStatus
  } else if (config.hasOwnProperty('validateStatus')) {
    log.error('Expected `validateStatus` to be a function.')
  }
  return code => code < 400 || code >= 500
}

function getFilter (config) {
  config = Object.assign({}, config, {
    blocklist: config.blocklist || []
  })

  return urlFilter.getFilter(config)
}

function getHeaders (config) {
  if (!Array.isArray(config.headers)) return []

  return config.headers
    .filter(key => typeof key === 'string')
    .map(key => key.toLowerCase())
}

function getHooks (config) {
  const noop = () => {}
  const request = (config.hooks && config.hooks.request) || noop

  return { request }
}

function hasAmazonSignature (options) {
  if (!options) {
    return false
  }

  if (options.headers) {
    const headers = Object.keys(options.headers)
      .reduce((prev, next) => Object.assign(prev, {
        [next.toLowerCase()]: options.headers[next]
      }), {})

    if (headers['x-amz-signature']) {
      return true
    }

    if ([].concat(headers['authorization']).some(startsWith('AWS4-HMAC-SHA256'))) {
      return true
    }
  }

  return options.path && options.path.toLowerCase().indexOf('x-amz-signature=') !== -1
}

function getServiceName (tracer, config, options) {
  if (config.splitByDomain) {
    return getHost(options)
  } else if (config.service) {
    return config.service
  }

  return `${tracer._service}-http-client`
}

function getHost (options) {
  if (typeof options === 'string') {
    return url.parse(options).host
  }

  const hostname = options.hostname || options.host || 'localhost'
  const port = options.port

  return [hostname, port].filter(val => val).join(':')
}

function startsWith (searchString) {
  return value => String(value).startsWith(searchString)
}

module.exports = HttpClientPlugin


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-http/src/index.js":
/*!**********************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-http/src/index.js ***!
  \**********************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Plugin = __webpack_require__(/*! ../../dd-trace/src/plugins/plugin */ "../../node_modules/dd-trace/packages/dd-trace/src/plugins/plugin.js")
const HttpServerPlugin = __webpack_require__(/*! ./server */ "../../node_modules/dd-trace/packages/datadog-plugin-http/src/server.js")
const HttpClientPlugin = __webpack_require__(/*! ./client */ "../../node_modules/dd-trace/packages/datadog-plugin-http/src/client.js")

class HttpPlugin extends Plugin {
  static get name () {
    return 'http'
  }
  constructor (...args) {
    super(...args)
    this.server = new HttpServerPlugin(...args)
    this.client = new HttpClientPlugin(...args)
  }
  configure (config) {
    const clientConfig = config.client === false ? false : {
      ...config,
      ...config.client
    }

    const serverConfig = config.server === false ? false : {
      ...config,
      ...config.server
    }

    this.server.configure(serverConfig)
    this.client.configure(clientConfig)
  }
}

module.exports = HttpPlugin


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-http/src/server.js":
/*!***********************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-http/src/server.js ***!
  \***********************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Plugin = __webpack_require__(/*! ../../dd-trace/src/plugins/plugin */ "../../node_modules/dd-trace/packages/dd-trace/src/plugins/plugin.js")
const { storage } = __webpack_require__(/*! ../../datadog-core */ "../../node_modules/dd-trace/packages/datadog-core/index.js")
const web = __webpack_require__(/*! ../../dd-trace/src/plugins/util/web */ "../../node_modules/dd-trace/packages/dd-trace/src/plugins/util/web.js")
const { incomingHttpRequestStart } = __webpack_require__(/*! ../../dd-trace/src/appsec/gateway/channels */ "../../node_modules/dd-trace/packages/dd-trace/src/appsec/gateway/channels.js")
const tags = __webpack_require__(/*! ../../../ext/tags */ "../../node_modules/dd-trace/ext/tags.js")
const analyticsSampler = __webpack_require__(/*! ../../dd-trace/src/analytics_sampler */ "../../node_modules/dd-trace/packages/dd-trace/src/analytics_sampler.js")
const SERVICE_NAME = tags.SERVICE_NAME

class HttpServerPlugin extends Plugin {
  static get name () {
    return 'http'
  }

  constructor (...args) {
    super(...args)

    this.addSub('apm:http:server:request:start', ({ req, res }) => {
      const store = storage.getStore()
      const span = web.startSpan(this.tracer, this.config, req, res, 'http.request')

      if (this.config.service) {
        span.setTag(SERVICE_NAME, this.config.service)
      }

      analyticsSampler.sample(span, this.config.measured, true)
      this.enter(span, store)

      const context = web.getContext(req)

      if (!context.instrumented) {
        context.res.writeHead = web.wrapWriteHead(context)
        context.instrumented = true
      }

      if (incomingHttpRequestStart.hasSubscribers) {
        incomingHttpRequestStart.publish({ req, res })
      }
    })

    this.addSub('apm:http:server:request:end', () => {
      this.exit()
    })

    this.addSub('apm:http:server:request:error', (error) => {
      const span = storage.getStore().span
      span.addTags({
        'error.type': error.name,
        'error.msg': error.message,
        'error.stack': error.stack
      })
    })

    this.addSub('apm:http:server:request:async-end', ({ req }) => {
      const context = web.getContext(req)

      if (!context) return // Not created by a http.Server instance.

      web.wrapRes(context, context.req, context.res, context.res.end)()
    })
  }

  configure (config) {
    return super.configure(web.normalizeConfig(config))
  }
}

module.exports = HttpServerPlugin


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-http2/src/client.js":
/*!************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-http2/src/client.js ***!
  \************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const URL = __webpack_require__(/*! url */ "url").URL
const log = __webpack_require__(/*! ../../dd-trace/src/log */ "../../node_modules/dd-trace/packages/dd-trace/src/log.js")
const tags = __webpack_require__(/*! ../../../ext/tags */ "../../node_modules/dd-trace/ext/tags.js")
const kinds = __webpack_require__(/*! ../../../ext/kinds */ "../../node_modules/dd-trace/ext/kinds.js")
const formats = __webpack_require__(/*! ../../../ext/formats */ "../../node_modules/dd-trace/ext/formats.js")
const analyticsSampler = __webpack_require__(/*! ../../dd-trace/src/analytics_sampler */ "../../node_modules/dd-trace/packages/dd-trace/src/analytics_sampler.js")
const shimmer = __webpack_require__(/*! ../../datadog-shimmer */ "../../node_modules/dd-trace/packages/datadog-shimmer/index.js")

const HTTP_HEADERS = formats.HTTP_HEADERS
const HTTP_STATUS_CODE = tags.HTTP_STATUS_CODE
const HTTP_REQUEST_HEADERS = tags.HTTP_REQUEST_HEADERS
const HTTP_RESPONSE_HEADERS = tags.HTTP_RESPONSE_HEADERS
const SPAN_KIND = tags.SPAN_KIND
const CLIENT = kinds.CLIENT

const HTTP2_HEADER_METHOD = ':method'
const HTTP2_HEADER_PATH = ':path'
const HTTP2_HEADER_STATUS = ':status'
const HTTP2_METHOD_GET = 'GET'

function extractSessionDetails (authority, options) {
  if (typeof authority === 'string') {
    authority = new URL(authority)
  }

  const protocol = authority.protocol || options.protocol || 'https:'
  let port = '' + (authority.port !== ''
    ? authority.port : (authority.protocol === 'http:' ? 80 : 443))
  let host = authority.hostname || authority.host || 'localhost'

  if (protocol === 'https:' && options) {
    port = options.port || port
    host = options.host || host
  }

  return { protocol, port, host }
}

function getFormattedHostString (host, port) {
  return [host, port].filter(val => val).join(':')
}

function getServiceName (tracer, config, sessionDetails) {
  if (config.splitByDomain) {
    return getFormattedHostString(sessionDetails.host, sessionDetails.port)
  } else if (config.service) {
    return config.service
  }

  return `${tracer._service}-http-client`
}

function hasAmazonSignature (headers, path) {
  if (headers) {
    headers = Object.keys(headers)
      .reduce((prev, next) => Object.assign(prev, {
        [next.toLowerCase()]: headers[next]
      }), {})

    if (headers['x-amz-signature']) {
      return true
    }

    if ([].concat(headers['authorization']).some(startsWith('AWS4-HMAC-SHA256'))) {
      return true
    }
  }

  return path && path.toLowerCase().indexOf('x-amz-signature=') !== -1
}

function startsWith (searchString) {
  return value => String(value).startsWith(searchString)
}

function getStatusValidator (config) {
  if (typeof config.validateStatus === 'function') {
    return config.validateStatus
  } else if (config.hasOwnProperty('validateStatus')) {
    log.error('Expected `validateStatus` to be a function.')
  }
  return code => code < 400 || code >= 500
}

function normalizeConfig (tracer, config) {
  config = config.client || config

  const validateStatus = getStatusValidator(config)
  const headers = getHeaders(config)

  return Object.assign({}, config, {
    validateStatus,
    headers
  })
}

function addResponseTags (headers, span, config) {
  const status = headers && headers[HTTP2_HEADER_STATUS]

  span.setTag(HTTP_STATUS_CODE, status)

  if (!config.validateStatus(status)) {
    span.setTag('error', 1)
  }

  addHeaderTags(span, headers, HTTP_RESPONSE_HEADERS, config)
}

function addRequestTags (headers, span, config) {
  addHeaderTags(span, headers, HTTP_REQUEST_HEADERS, config)
}

function addErrorTags (span, error) {
  span.setTag('error', error)
}

function addHeaderTags (span, headers, prefix, config) {
  if (!headers) return

  config.headers.forEach(key => {
    const value = headers[key]

    if (value) {
      span.setTag(`${prefix}.${key}`, value)
    }
  })
}

function getHeaders (config) {
  if (!Array.isArray(config.headers)) return []

  return config.headers
    .filter(key => typeof key === 'string')
    .map(key => key.toLowerCase())
}

function startSpan (tracer, config, headers, sessionDetails) {
  headers = headers || {}

  const scope = tracer.scope()
  const childOf = scope.active()

  const path = headers[HTTP2_HEADER_PATH] || '/'
  const method = headers[HTTP2_HEADER_METHOD] || HTTP2_METHOD_GET
  const url = `${sessionDetails.protocol}//${sessionDetails.host}:${sessionDetails.port}${path}`

  const span = tracer.startSpan('http.request', {
    childOf,
    tags: {
      [SPAN_KIND]: CLIENT,
      'service.name': getServiceName(tracer, config, sessionDetails),
      'resource.name': method,
      'span.type': 'http',
      'http.method': method,
      'http.url': url.split('?')[0]
    }
  })

  if (!hasAmazonSignature(headers, path)) {
    tracer.inject(span, HTTP_HEADERS, headers)
  }

  analyticsSampler.sample(span, config.measured)
  return span
}

function createWrapEmit (tracer, config, span) {
  return function wrapEmit (emit) {
    return function emitWithTrace (event, arg1) {
      switch (event) {
        case 'response':
          addResponseTags(arg1, span, config)
          break
        case 'error':
          addErrorTags(span, arg1)
        case 'close': // eslint-disable-line no-fallthrough
          span.finish()
          break
      }
      return emit.apply(this, arguments)
    }
  }
}

function createWrapRequest (tracer, config, sessionDetails) {
  return function wrapRequest (request) {
    if (!sessionDetails) return request

    return function requestWithTrace (headers, options) {
      const scope = tracer.scope()
      const span = startSpan(tracer, config, headers, sessionDetails)

      addRequestTags(headers, span, config)

      const req = scope.bind(request, span).apply(this, arguments)

      shimmer.wrap(req, 'emit', createWrapEmit(tracer, config, span))
      scope.bind(req)

      return req
    }
  }
}

function createWrapConnect (tracer, config) {
  config = normalizeConfig(tracer, config)

  return function wrapConnect (connect) {
    return function connectWithTrace (authority, options) {
      const session = connect.apply(this, arguments)

      const sessionDetails = extractSessionDetails(authority, options)

      shimmer.wrap(session, 'request', createWrapRequest(tracer, config, sessionDetails))
      return session
    }
  }
}

module.exports = [
  {
    name: 'http2',
    patch: function (http2, tracer, config) {
      if (config.client === false) return

      this.wrap(http2, 'connect', createWrapConnect(tracer, config))
    },
    unpatch: function (http2) {
      this.unwrap(http2, 'connect')
    }
  }
]


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-http2/src/index.js":
/*!***********************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-http2/src/index.js ***!
  \***********************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const client = __webpack_require__(/*! ./client */ "../../node_modules/dd-trace/packages/datadog-plugin-http2/src/client.js")
const server = __webpack_require__(/*! ./server */ "../../node_modules/dd-trace/packages/datadog-plugin-http2/src/server.js")

module.exports = [].concat(client, server)


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-http2/src/server.js":
/*!************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-http2/src/server.js ***!
  \************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// TODO: remove usage of req._datadog when the plugin is re-enabled

const web = __webpack_require__(/*! ../../dd-trace/src/plugins/util/web */ "../../node_modules/dd-trace/packages/dd-trace/src/plugins/util/web.js")
const shimmer = __webpack_require__(/*! ../../datadog-shimmer */ "../../node_modules/dd-trace/packages/datadog-shimmer/index.js")

const analyticsSampler = __webpack_require__(/*! ../../dd-trace/src/analytics_sampler */ "../../node_modules/dd-trace/packages/dd-trace/src/analytics_sampler.js")
const tags = __webpack_require__(/*! ../../../ext/tags */ "../../node_modules/dd-trace/ext/tags.js")
const types = __webpack_require__(/*! ../../../ext/types */ "../../node_modules/dd-trace/ext/types.js")
const kinds = __webpack_require__(/*! ../../../ext/kinds */ "../../node_modules/dd-trace/ext/kinds.js")

const WEB = types.WEB
const SERVER = kinds.SERVER
const RESOURCE_NAME = tags.RESOURCE_NAME
const SERVICE_NAME = tags.SERVICE_NAME
const SPAN_TYPE = tags.SPAN_TYPE
const SPAN_KIND = tags.SPAN_KIND
const HTTP_METHOD = tags.HTTP_METHOD
const HTTP_URL = tags.HTTP_URL
const HTTP_STATUS_CODE = tags.HTTP_STATUS_CODE
const HTTP_ROUTE = tags.HTTP_ROUTE
const HTTP_REQUEST_HEADERS = tags.HTTP_REQUEST_HEADERS
const HTTP_RESPONSE_HEADERS = tags.HTTP_RESPONSE_HEADERS
const MANUAL_DROP = tags.MANUAL_DROP

const HTTP_STATUS_OK = 200
const HTTP2_HEADER_AUTHORITY = ':authority'
const HTTP2_HEADER_SCHEME = ':scheme'
const HTTP2_HEADER_METHOD = ':method'
const HTTP2_HEADER_PATH = ':path'
const HTTP2_HEADER_STATUS = ':status'

function createWrapEmit (tracer, config) {
  return function wrapEmit (emit) {
    return function emitWithTrace (event, arg1, arg2) {
      if (event === 'stream') {
        const stream = arg1
        const headers = arg2
        return instrumentStream(tracer, config, stream, headers, 'http.request', () => {
          return emit.apply(this, arguments)
        })
      } else if (event === 'request') {
        const req = arg1
        const res = arg2
        return web.instrument(tracer, config, req, res, 'http.request', () => {
          return emit.apply(this, arguments)
        })
      } else {
        return emit.apply(this, arguments)
      }
    }
  }
}

function createWrapCreateServer (tracer, config) {
  config = web.normalizeConfig(config)

  return function wrapCreateServer (createServer) {
    return function createServerWithTrace (args) {
      const server = createServer.apply(this, arguments)

      shimmer.wrap(server, 'emit', createWrapEmit(tracer, config))

      return server
    }
  }
}

function instrumentStream (tracer, config, stream, headers, name, callback) {
  if (!stream) return callback()

  headers = headers || {}

  web.patch(stream)

  const span = startStreamSpan(tracer, config, stream, headers, name)

  if (!config.filter(headers[HTTP2_HEADER_PATH])) {
    span.setTag(MANUAL_DROP, true)
  }

  if (config.service) {
    span.setTag(SERVICE_NAME, config.service)
  }

  analyticsSampler.sample(span, config.measured, true)

  wrapStreamEnd(stream)

  addRequestTags(stream, headers)
  addRequestHeaders(stream, headers)
  addResourceTags(stream, headers)

  return callback && tracer.scope().activate(span, () => callback(span))
}

function startStreamSpan (tracer, config, stream, headers, name) {
  stream._datadog.config = config

  if (stream._datadog.span) {
    return stream._datadog.span
  }

  const span = web.startChildSpan(tracer, name, headers)

  stream._datadog.tracer = tracer
  stream._datadog.span = span

  return span
}

function wrapStreamEnd (stream) {
  function wrapEnd (end) {
    return function endWithTrace () {
      const returnValue = end.apply(this, arguments)

      finishStream(stream)
      return returnValue
    }
  }

  shimmer.wrap(stream, 'end', wrapEnd)
}

function finishStream (stream) {
  if (stream._datadog.finished) return

  addResponseTags(stream)
  addResponseHeaders(stream)

  stream._datadog.span.finish()
  stream._datadog.finished = true
}

function addRequestTags (stream, headers) {
  const span = stream._datadog.span
  const url = `${headers[HTTP2_HEADER_SCHEME]}://${headers[HTTP2_HEADER_AUTHORITY]}${headers[HTTP2_HEADER_PATH]}`

  span.addTags({
    [HTTP_METHOD]: headers[HTTP2_HEADER_METHOD],
    [HTTP_URL]: url.split('?')[0],
    [SPAN_KIND]: SERVER,
    [SPAN_TYPE]: WEB
  })
}

function addRequestHeaders (stream, headers) {
  if (!headers) return

  const span = stream._datadog.span

  stream._datadog.config.headers.forEach(key => {
    const reqHeader = headers[key]

    if (reqHeader) {
      span.setTag(`${HTTP_REQUEST_HEADERS}.${key}`, reqHeader)
    }
  })
}

function addResponseTags (stream) {
  const span = stream._datadog.span
  const headers = stream.sentHeaders
  const statusCode = headers[HTTP2_HEADER_STATUS]

  span.addTags({
    [HTTP_STATUS_CODE]: statusCode | 0 || HTTP_STATUS_OK
  })

  web.addStatusError(stream, statusCode)
}

function addResponseHeaders (stream) {
  if (!stream.sentHeaders) return

  const span = stream._datadog.span

  stream._datadog.config.headers.forEach(key => {
    const resHeader = stream.sentHeaders && stream.sentHeaders[key]

    if (resHeader) {
      span.setTag(`${HTTP_RESPONSE_HEADERS}.${key}`, resHeader)
    }
  })
}

function addResourceTags (stream, headers) {
  const span = stream._datadog.span
  const tags = span.context()._tags
  const method = headers[HTTP2_HEADER_METHOD]

  if (tags[RESOURCE_NAME]) return

  const resource = [method]
    .concat(tags[HTTP_ROUTE])
    .filter(val => val)
    .join(' ')

  span.setTag(RESOURCE_NAME, resource)
}

module.exports = [
  {
    name: 'http2',
    patch (http2, tracer, config) {
      if (config.server === false) return

      this.wrap(http2, 'createServer', createWrapCreateServer(tracer, config))
      this.wrap(http2, 'createSecureServer', createWrapCreateServer(tracer, config))
    },
    unpatch (http2) {
      this.unwrap(http2, 'createServer')
      this.unwrap(http2, 'createSecureServer')
    }
  }
]

module.exports = [] // temporarily disable HTTP2 server plugin


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-ioredis/src/index.js":
/*!*************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-ioredis/src/index.js ***!
  \*************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const RedisPlugin = __webpack_require__(/*! ../../datadog-plugin-redis/src */ "../../node_modules/dd-trace/packages/datadog-plugin-redis/src/index.js")

class IORedisPlugin extends RedisPlugin {
  static get name () {
    return 'ioredis'
  }
}

module.exports = IORedisPlugin


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-jest/src/index.js":
/*!**********************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-jest/src/index.js ***!
  \**********************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

const jestEnvironment = __webpack_require__(/*! ./jest-environment */ "../../node_modules/dd-trace/packages/datadog-plugin-jest/src/jest-environment.js")
const jestJasmine2 = __webpack_require__(/*! ./jest-jasmine2 */ "../../node_modules/dd-trace/packages/datadog-plugin-jest/src/jest-jasmine2.js")

module.exports = [].concat(jestEnvironment, jestJasmine2)


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-jest/src/jest-environment.js":
/*!*********************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-jest/src/jest-environment.js ***!
  \*********************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

const { promisify } = __webpack_require__(/*! util */ "util")

const { RESOURCE_NAME } = __webpack_require__(/*! ../../../ext/tags */ "../../node_modules/dd-trace/ext/tags.js")
const {
  TEST_NAME,
  TEST_SUITE,
  TEST_STATUS,
  TEST_FRAMEWORK_VERSION,
  JEST_TEST_RUNNER,
  ERROR_MESSAGE,
  ERROR_TYPE,
  TEST_PARAMETERS,
  CI_APP_ORIGIN,
  getTestEnvironmentMetadata,
  getTestParametersString,
  finishAllTraceSpans,
  getTestSuitePath
} = __webpack_require__(/*! ../../dd-trace/src/plugins/util/test */ "../../node_modules/dd-trace/packages/dd-trace/src/plugins/util/test.js")
const {
  getFormattedJestTestParameters,
  getTestSpanTags,
  setSuppressedErrors
} = __webpack_require__(/*! ./util */ "../../node_modules/dd-trace/packages/datadog-plugin-jest/src/util.js")

const originals = new WeakMap()

function getVmContext (environment) {
  if (typeof environment.getVmContext === 'function') {
    return environment.getVmContext()
  }
  return null
}

function wrapEnvironment (BaseEnvironment) {
  return class DatadogJestEnvironment extends BaseEnvironment {
    constructor (config, context) {
      super(config, context)
      this.testSuite = getTestSuitePath(context.testPath, config.rootDir)
      this.testSpansByTestName = {}
      this.originalTestFnByTestName = {}
    }
  }
}

function createWrapTeardown (tracer, instrumenter) {
  return function wrapTeardown (teardown) {
    return async function teardownWithTrace () {
      instrumenter.unwrap(this.global.test, 'each')
      nameToParams = {}
      // for jest-jasmine2
      if (this.global.jasmine) {
        instrumenter.unwrap(this.global.jasmine.Spec.prototype, 'onException')
        instrumenter.unwrap(this.global, 'it')
        instrumenter.unwrap(this.global, 'fit')
        instrumenter.unwrap(this.global, 'xit')
      }

      instrumenter.unwrap(this.global.test, 'each')

      return teardown.apply(this, arguments).finally(() => {
        return new Promise(resolve => tracer._exporter._writer.flush(resolve))
      })
    }
  }
}

let nameToParams = {}

const isTimeout = (event) => {
  return event.error &&
  typeof event.error === 'string' &&
  event.error.startsWith('Exceeded timeout')
}

function createHandleTestEvent (tracer, testEnvironmentMetadata, instrumenter) {
  return async function handleTestEventWithTrace (event) {
    if (event.name === 'test_retry') {
      let testName = event.test && event.test.name
      const context = getVmContext(this)
      if (context) {
        const { currentTestName } = context.expect.getState()
        testName = currentTestName
      }
      // If it's a retry, we restore the original test function so that it is not wrapped again
      if (this.originalTestFnByTestName[testName]) {
        event.test.fn = this.originalTestFnByTestName[testName]
      }
      return
    }
    if (event.name === 'test_fn_failure') {
      if (!isTimeout(event)) {
        return
      }
      const context = getVmContext(this)
      if (context) {
        const { currentTestName } = context.expect.getState()
        const testSpan = this.testSpansByTestName[`${currentTestName}_${event.test.invocations}`]
        if (testSpan) {
          testSpan.setTag(ERROR_TYPE, 'Timeout')
          testSpan.setTag(ERROR_MESSAGE, event.error)
          testSpan.setTag(TEST_STATUS, 'fail')
        }
      }
      return
    }
    if (event.name === 'setup') {
      instrumenter.wrap(this.global.test, 'each', function (original) {
        return function () {
          const testParameters = getFormattedJestTestParameters(arguments)
          const eachBind = original.apply(this, arguments)
          return function () {
            const [testName] = arguments
            nameToParams[testName] = testParameters
            return eachBind.apply(this, arguments)
          }
        }
      })
      return
    }

    if (event.name !== 'test_skip' &&
      event.name !== 'test_todo' &&
      event.name !== 'test_start' &&
      event.name !== 'hook_failure') {
      return
    }
    // for hook_failure events the test entry might not be defined, because the hook
    // is not necessarily associated to a test:
    if (!event.test) {
      return
    }

    const { childOf, commonSpanTags } = getTestSpanTags(tracer, testEnvironmentMetadata)

    let testName = event.test.name
    const context = getVmContext(this)

    if (context) {
      const { currentTestName } = context.expect.getState()
      testName = currentTestName
    }
    const spanTags = {
      ...commonSpanTags,
      [TEST_NAME]: testName,
      [TEST_SUITE]: this.testSuite,
      [TEST_FRAMEWORK_VERSION]: tracer._version,
      [JEST_TEST_RUNNER]: 'jest-circus'
    }

    const testParametersString = getTestParametersString(nameToParams, event.test.name)
    if (testParametersString) {
      spanTags[TEST_PARAMETERS] = testParametersString
    }

    const resource = `${this.testSuite}.${testName}`
    if (event.name === 'test_skip' || event.name === 'test_todo') {
      const testSpan = tracer.startSpan(
        'jest.test',
        {
          childOf,
          tags: {
            ...spanTags,
            [RESOURCE_NAME]: resource,
            [TEST_STATUS]: 'skip'
          }
        }
      )
      testSpan.context()._trace.origin = CI_APP_ORIGIN
      testSpan.finish()
      return
    }
    if (event.name === 'hook_failure') {
      const testSpan = tracer.startSpan(
        'jest.test',
        {
          childOf,
          tags: {
            ...spanTags,
            [RESOURCE_NAME]: resource,
            [TEST_STATUS]: 'fail'
          }
        }
      )
      testSpan.context()._trace.origin = CI_APP_ORIGIN
      if (event.test.errors && event.test.errors.length) {
        const error = new Error(event.test.errors[0][0])
        error.stack = event.test.errors[0][1].stack
        testSpan.setTag('error', error)
      }
      testSpan.finish()
      return
    }
    // event.name === test_start at this point
    const environment = this
    environment.originalTestFnByTestName[testName] = event.test.fn

    let specFunction = event.test.fn
    if (specFunction.length) {
      specFunction = promisify(specFunction)
    }
    event.test.fn = tracer.wrap(
      'jest.test',
      {
        type: 'test',
        childOf,
        resource,
        tags: spanTags
      },
      async () => {
        let result
        const testSpan = tracer.scope().active()
        environment.testSpansByTestName[`${testName}_${event.test.invocations}`] = testSpan
        testSpan.context()._trace.origin = CI_APP_ORIGIN
        try {
          result = await specFunction()
          // it may have been set already if the test timed out
          let suppressedErrors = []
          const context = getVmContext(environment)
          if (context) {
            suppressedErrors = context.expect.getState().suppressedErrors
          }
          setSuppressedErrors(suppressedErrors, testSpan)
          if (!testSpan._spanContext._tags[TEST_STATUS]) {
            testSpan.setTag(TEST_STATUS, 'pass')
          }
        } catch (error) {
          testSpan.setTag(TEST_STATUS, 'fail')
          testSpan.setTag('error', error)
          throw error
        } finally {
          finishAllTraceSpans(testSpan)
        }
        return result
      }
    )
  }
}

function patch (Environment, tracer, config) {
  const testEnvironmentMetadata = getTestEnvironmentMetadata('jest', config)
  const proto = Environment.prototype

  this.wrap(proto, 'teardown', createWrapTeardown(tracer, this))

  const newHandleTestEvent = createHandleTestEvent(tracer, testEnvironmentMetadata, this)
  originals.set(newHandleTestEvent, proto.handleTestEvent)
  proto.handleTestEvent = newHandleTestEvent

  return wrapEnvironment(Environment)
}

function unpatch (Environment) {
  const proto = Environment.prototype

  this.unwrap(Environment.prototype, 'teardown')
  proto.handleTestEvent = originals.get(proto.handleTestEvent)
}

module.exports = [
  {
    name: 'jest-environment-node',
    versions: ['>=24.8.0'],
    patch,
    unpatch
  },
  {
    name: 'jest-environment-jsdom',
    versions: ['>=24.8.0'],
    patch,
    unpatch
  }
]


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-jest/src/jest-jasmine2.js":
/*!******************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-jest/src/jest-jasmine2.js ***!
  \******************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

const { promisify } = __webpack_require__(/*! util */ "util")

const { RESOURCE_NAME } = __webpack_require__(/*! ../../../ext/tags */ "../../node_modules/dd-trace/ext/tags.js")
const {
  TEST_NAME,
  TEST_SUITE,
  TEST_STATUS,
  TEST_FRAMEWORK_VERSION,
  JEST_TEST_RUNNER,
  CI_APP_ORIGIN,
  getTestEnvironmentMetadata,
  finishAllTraceSpans,
  getTestSuitePath
} = __webpack_require__(/*! ../../dd-trace/src/plugins/util/test */ "../../node_modules/dd-trace/packages/dd-trace/src/plugins/util/test.js")
const { getTestSpanTags, setSuppressedErrors } = __webpack_require__(/*! ./util */ "../../node_modules/dd-trace/packages/datadog-plugin-jest/src/util.js")

function createWrapIt (tracer, globalConfig, globalInput, testEnvironmentMetadata) {
  return function wrapIt (it) {
    return function itWithTrace (description, specFunction, timeout) {
      let oldSpecFunction = specFunction
      if (specFunction.length) {
        oldSpecFunction = promisify(oldSpecFunction)
      }

      const { childOf, commonSpanTags } = getTestSpanTags(tracer, testEnvironmentMetadata)

      const testSuite = getTestSuitePath(globalInput.jasmine.testPath, globalConfig.rootDir)

      const newSpecFunction = tracer.wrap(
        'jest.test',
        {
          type: 'test',
          childOf,
          tags: {
            ...commonSpanTags,
            [TEST_SUITE]: testSuite,
            [TEST_FRAMEWORK_VERSION]: tracer._version,
            [JEST_TEST_RUNNER]: 'jest-jasmine2'
          }
        },
        async (done) => {
          const testSpan = tracer.scope().active()
          const { currentTestName } = globalInput.expect.getState()
          const resource = `${testSuite}.${currentTestName}`
          testSpan.setTag(TEST_NAME, currentTestName)
          testSpan.setTag(RESOURCE_NAME, resource)
          testSpan.context()._trace.origin = CI_APP_ORIGIN
          let result
          globalInput.jasmine.testSpanByTestName[currentTestName] = testSpan

          try {
            result = await oldSpecFunction()
            const suppressedErrors = globalInput.expect.getState().suppressedErrors
            setSuppressedErrors(suppressedErrors, testSpan)
            if (!testSpan._spanContext._tags[TEST_STATUS]) {
              testSpan.setTag(TEST_STATUS, 'pass')
            }
          } catch (error) {
            testSpan.setTag(TEST_STATUS, 'fail')
            testSpan.setTag('error', error)
            if (done) {
              done(error)
            }
            throw error
          } finally {
            finishAllTraceSpans(testSpan)
          }
          if (done) {
            done(result)
          }
        }
      )
      return it(description, newSpecFunction, timeout)
    }
  }
}

function createWrapOnException (tracer, globalInput) {
  return function wrapOnException (onException) {
    return function onExceptionWithTrace (err) {
      let activeTestSpan = tracer.scope().active()
      if (!activeTestSpan) {
        activeTestSpan = globalInput.jasmine.testSpanByTestName[this.getFullName()]
      }
      if (!activeTestSpan) {
        return onException.apply(this, arguments)
      }
      const {
        [TEST_NAME]: testName,
        [TEST_SUITE]: testSuite,
        [TEST_STATUS]: testStatus
      } = activeTestSpan._spanContext._tags

      const isActiveSpanFailing = this.getFullName() === testName &&
        this.result.testPath.endsWith(testSuite)

      if (isActiveSpanFailing && !testStatus) {
        activeTestSpan.setTag(TEST_STATUS, 'fail')
        // If we don't do this, jest will show this file on its error message
        if (err.stack) {
          const stackFrames = err.stack.split('\n')
          const filteredStackFrames = stackFrames.filter(frame => !frame.includes(__dirname)).join('\n')
          err.stack = filteredStackFrames
        }
        activeTestSpan.setTag('error', err)
        // need to manually finish, as it will not be caught in `itWithTrace`
        activeTestSpan.finish()
      }

      return onException.apply(this, arguments)
    }
  }
}

function createWrapItSkip (tracer, globalConfig, globalInput, testEnvironmentMetadata) {
  return function wrapItSkip (it) {
    return function itSkipWithTrace () {
      const { childOf, commonSpanTags } = getTestSpanTags(tracer, testEnvironmentMetadata)

      const testSuite = getTestSuitePath(globalInput.jasmine.testPath, globalConfig.rootDir)

      const spec = it.apply(this, arguments)

      const testName = spec.getFullName()
      const resource = `${testSuite}.${testName}`

      const testSpan = tracer.startSpan(
        'jest.test',
        {
          childOf,
          tags: {
            ...commonSpanTags,
            [RESOURCE_NAME]: resource,
            [TEST_NAME]: testName,
            [TEST_SUITE]: testSuite,
            [TEST_STATUS]: 'skip',
            [TEST_FRAMEWORK_VERSION]: tracer._version,
            [JEST_TEST_RUNNER]: 'jest-jasmine2'
          }
        }
      )
      testSpan.context()._trace.origin = CI_APP_ORIGIN
      testSpan.finish()

      return spec
    }
  }
}

function createWrapJasmineAsyncInstall (tracer, instrumenter, testEnvironmentMetadata) {
  return function jasmineAsyncInstallWithTrace (jasmineAsyncInstall) {
    return function (globalConfig, globalInput) {
      globalInput.jasmine.testSpanByTestName = {}
      instrumenter.wrap(globalInput.jasmine.Spec.prototype, 'onException', createWrapOnException(tracer, globalInput))
      instrumenter.wrap(globalInput, 'it', createWrapIt(tracer, globalConfig, globalInput, testEnvironmentMetadata))
      // instruments 'it.only'
      instrumenter.wrap(globalInput, 'fit', createWrapIt(tracer, globalConfig, globalInput, testEnvironmentMetadata))
      // instruments 'it.skip'
      instrumenter.wrap(
        globalInput,
        'xit',
        createWrapItSkip(tracer, globalConfig, globalInput, testEnvironmentMetadata)
      )
      return jasmineAsyncInstall(globalConfig, globalInput)
    }
  }
}

module.exports = [
  {
    name: 'jest-jasmine2',
    versions: ['>=24.8.0'],
    file: 'build/jasmineAsyncInstall.js',
    patch: function (jasmineAsyncInstallExport, tracer, config) {
      const testEnvironmentMetadata = getTestEnvironmentMetadata('jest', config)
      return this.wrapExport(
        jasmineAsyncInstallExport.default,
        createWrapJasmineAsyncInstall(tracer, this, testEnvironmentMetadata)(jasmineAsyncInstallExport.default)
      )
    },
    unpatch: function (jasmineAsyncInstallExport) {
      this.unwrapExport(jasmineAsyncInstallExport.default)
    }
  }
]


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-jest/src/util.js":
/*!*********************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-jest/src/util.js ***!
  \*********************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

const { SAMPLING_RULE_DECISION } = __webpack_require__(/*! ../../dd-trace/src/constants */ "../../node_modules/dd-trace/packages/dd-trace/src/constants.js")
const { SAMPLING_PRIORITY, SPAN_TYPE } = __webpack_require__(/*! ../../../ext/tags */ "../../node_modules/dd-trace/ext/tags.js")
const { AUTO_KEEP } = __webpack_require__(/*! ../../../ext/priority */ "../../node_modules/dd-trace/ext/priority.js")
const { TEST_TYPE, TEST_STATUS, getTestParentSpan } = __webpack_require__(/*! ../../dd-trace/src/plugins/util/test */ "../../node_modules/dd-trace/packages/dd-trace/src/plugins/util/test.js")

/**
 * There are two ways to call `test.each` in `jest`:
 * 1. With an array of arrays: https://jestjs.io/docs/api#1-testeachtablename-fn-timeout
 * 2. With a tagged template literal: https://jestjs.io/docs/api#2-testeachtablename-fn-timeout
 * This function distinguishes between the two and returns the test parameters in different formats:
 * 1. An array of arrays with the different parameters to the test, e.g.
 * [[1, 2, 3], [2, 3, 5]]
 * 2. An array of objects, e.g.
 * [{ a: 1, b: 2, expected: 3 }, { a: 2, b: 3, expected: 5}]
 */
function getFormattedJestTestParameters (testParameters) {
  if (!testParameters || !testParameters.length) {
    return
  }
  const [parameterArray, ...parameterValues] = testParameters
  if (parameterValues.length === 0) { // Way 1.
    return parameterArray
  }
  // Way 2.
  const parameterKeys = parameterArray[0].split('|').map(key => key.trim())
  const formattedParameters = []
  for (let index = 0; index < parameterValues.length; index++) {
    const parameterValue = parameterValues[index]
    const parameterIndex = index % parameterKeys.length
    if (!parameterIndex) {
      formattedParameters.push({})
    }
    const parameterKey = parameterKeys[parameterIndex]
    const lastFormattedParameter = formattedParameters[formattedParameters.length - 1]
    lastFormattedParameter[parameterKey] = parameterValue
  }

  return formattedParameters
}

function getTestSpanTags (tracer, testEnvironmentMetadata) {
  const childOf = getTestParentSpan(tracer)

  const commonSpanTags = {
    [TEST_TYPE]: 'test',
    [SAMPLING_RULE_DECISION]: 1,
    [SAMPLING_PRIORITY]: AUTO_KEEP,
    [SPAN_TYPE]: 'test',
    ...testEnvironmentMetadata
  }
  return {
    childOf,
    commonSpanTags
  }
}

function setSuppressedErrors (suppressedErrors, testSpan) {
  if (suppressedErrors && suppressedErrors.length) {
    testSpan.setTag('error', suppressedErrors[0])
    testSpan.setTag(TEST_STATUS, 'fail')
  }
}

module.exports = { getFormattedJestTestParameters, getTestSpanTags, setSuppressedErrors }


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-kafkajs/src/index.js":
/*!*************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-kafkajs/src/index.js ***!
  \*************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const analyticsSampler = __webpack_require__(/*! ../../dd-trace/src/analytics_sampler */ "../../node_modules/dd-trace/packages/dd-trace/src/analytics_sampler.js")

function createWrapProducer (tracer, config) {
  return function wrapProducer (createProducer) {
    return function producerWithTrace () {
      const serviceName = config.service || `${tracer._service}-kafka`
      const producer = createProducer.apply(this, arguments)

      const send = producer.send

      const tags = {
        'service.name': serviceName,
        'span.kind': 'producer',
        'component': 'kafkajs'
      }

      producer.send = tracer.wrap('kafka.produce', { tags }, function (...args) {
        const { topic, messages = [] } = args[0]
        const currentSpan = tracer.scope().active()

        analyticsSampler.sample(currentSpan, config.measured)

        currentSpan.addTags({
          'resource.name': topic,
          'kafka.topic': topic,
          'kafka.batch_size': messages.length
        })

        for (const message of messages) {
          message.headers = message.headers || {}
          tracer.inject(currentSpan, 'text_map', message.headers)
        }

        return send.apply(this, args)
      })

      return producer
    }
  }
}

function createWrapConsumer (tracer, config) {
  return function wrapConsumer (createConsumer) {
    return function consumerWithTrace () {
      const serviceName = config.service || `${tracer._service}-kafka`
      const consumer = createConsumer.apply(this, arguments)
      const run = consumer.run

      const tags = {
        'service.name': serviceName,
        'span.kind': 'consumer',
        'span.type': 'worker',
        'component': 'kafkajs'
      }

      consumer.run = function ({ eachMessage, ...runArgs }) {
        if (typeof eachMessage !== 'function') return run({ eachMessage, ...runArgs })

        return run({
          eachMessage: function (...eachMessageArgs) {
            const { topic, partition, message } = eachMessageArgs[0]
            const childOf = extract(tracer, message.headers)

            return tracer.trace('kafka.consume', { childOf, tags }, () => {
              const currentSpan = tracer.scope().active()

              analyticsSampler.sample(currentSpan, config.measured, true)

              currentSpan.addTags({
                'resource.name': topic,
                'kafka.topic': topic,
                'kafka.partition': partition,
                'kafka.message.offset': message.offset
              })

              return eachMessage.apply(this, eachMessageArgs)
            })
          },
          ...runArgs
        })
      }

      return consumer
    }
  }
}

function extract (tracer, bufferMap) {
  if (!bufferMap) return null

  const textMap = {}

  for (const key of Object.keys(bufferMap)) {
    textMap[key] = bufferMap[key].toString()
  }

  return tracer.extract('text_map', textMap)
}

module.exports = [
  {
    name: 'kafkajs',
    versions: ['>=1.4'],
    patch ({ Kafka }, tracer, config) {
      this.wrap(
        Kafka.prototype,
        'producer',
        createWrapProducer(tracer, config)
      )
      this.wrap(
        Kafka.prototype,
        'consumer',
        createWrapConsumer(tracer, config)
      )
    },
    unpatch ({ Kafka }) {
      this.unwrap(Kafka.prototype, 'producer')
      this.unwrap(Kafka.prototype, 'consumer')
    }
  }
]


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-knex/src/index.js":
/*!**********************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-knex/src/index.js ***!
  \**********************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const { wrapThen } = __webpack_require__(/*! ../../datadog-instrumentations/src/helpers/promise */ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/helpers/promise.js")

function createPatch (file) {
  return {
    name: 'knex',
    versions: ['>=0.8.0'],
    file,
    patch (Builder) {
      this.wrap(Builder.prototype, 'then', wrapThen)
    },
    unpatch (Builder) {
      this.unwrap(Builder.prototype, 'then')
    }
  }
}

module.exports = [
  createPatch('lib/query/builder.js'),
  createPatch('lib/raw.js'),
  createPatch('lib/schema/builder.js')
]


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-koa/src/index.js":
/*!*********************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-koa/src/index.js ***!
  \*********************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const web = __webpack_require__(/*! ../../dd-trace/src/plugins/util/web */ "../../node_modules/dd-trace/packages/dd-trace/src/plugins/util/web.js")

const originals = new WeakMap()

function createWrapCallback (tracer, config) {
  config = web.normalizeConfig(config)

  return function wrapCallback (callback) {
    return function callbackWithTrace () {
      const handleRequest = callback.apply(this, arguments)

      if (typeof handleRequest !== 'function') return handleRequest

      return function handleRequestWithTrace (req, res) {
        web.instrument(tracer, config, req, res, 'koa.request')

        return handleRequest.apply(this, arguments)
      }
    }
  }
}

function createWrapCreateContext () {
  return function wrapCreateContext (createContext) {
    return function createContextWithTrace (req, res) {
      const ctx = createContext.apply(this, arguments)

      if (!ctx) return ctx

      web.patch(req)
      web.beforeEnd(req, () => {
        web.enterRoute(req, ctx.routePath)
      })

      return ctx
    }
  }
}

function createWrapUse () {
  return function wrapUse (use) {
    return function useWithTrace () {
      const result = use.apply(this, arguments)

      if (!Array.isArray(this.middleware)) return result

      const fn = this.middleware.pop()

      this.middleware.push(wrapMiddleware(fn))

      return result
    }
  }
}

function createWrapRegister (tracer, config) {
  return function wrapRegister (register) {
    return function registerWithTrace (path, methods, middleware, opts) {
      const route = register.apply(this, arguments)

      if (!Array.isArray(path) && route && Array.isArray(route.stack)) {
        wrapStack(route)
      }

      return route
    }
  }
}

function createWrapRouterUse (tracer, config) {
  return function wrapUse (use) {
    return function useWithTrace () {
      const router = use.apply(this, arguments)

      router.stack.forEach(wrapStack)

      return router
    }
  }
}

function wrapStack (layer) {
  layer.stack = layer.stack.map(middleware => {
    if (typeof middleware !== 'function') return middleware

    const original = originals.get(middleware)

    middleware = original || middleware

    const wrappedMiddleware = wrapMiddleware(middleware)

    const handler = function (ctx, next) {
      if (!ctx || !web.active(ctx.req)) return middleware.apply(this, arguments)

      web.exitRoute(ctx.req)
      web.enterRoute(ctx.req, layer.path)

      return wrappedMiddleware.apply(this, arguments)
    }

    originals.set(handler, middleware)

    return handler
  })
}

function wrapMiddleware (fn) {
  if (typeof fn !== 'function') return fn

  return function (ctx, next) {
    if (!ctx) return fn.apply(this, arguments)

    return web.wrapMiddleware(ctx.req, fn, 'koa.middleware', () => {
      try {
        const result = fn.apply(this, arguments)

        if (result && typeof result.then === 'function') {
          result.then(
            () => web.finish(ctx.req),
            err => web.finish(ctx.req, err)
          )
        } else {
          web.finish(ctx.req)
        }

        return result
      } catch (e) {
        web.finish(ctx.req, e)
        throw e
      }
    })
  }
}

module.exports = [
  {
    name: 'koa',
    versions: ['>=2'],
    patch (Koa, tracer, config) {
      this.wrap(Koa.prototype, 'callback', createWrapCallback(tracer, config))
      this.wrap(Koa.prototype, 'createContext', createWrapCreateContext(tracer, config))
      this.wrap(Koa.prototype, 'use', createWrapUse(tracer, config))
    },
    unpatch (Koa) {
      this.unwrap(Koa.prototype, 'callback')
      this.unwrap(Koa.prototype, 'createContext')
      this.unwrap(Koa.prototype, 'use')
    }
  },
  {
    name: '@koa/router',
    versions: ['>=8'],
    patch (Router, tracer, config) {
      this.wrap(Router.prototype, 'register', createWrapRegister(tracer, config))
      this.wrap(Router.prototype, 'use', createWrapRouterUse(tracer, config))
    },
    unpatch (Router) {
      this.unwrap(Router.prototype, 'register')
      this.unwrap(Router.prototype, 'use')
    }
  },
  {
    name: 'koa-router',
    versions: ['>=7'],
    patch (Router, tracer, config) {
      this.wrap(Router.prototype, 'register', createWrapRegister(tracer, config))
      this.wrap(Router.prototype, 'use', createWrapRouterUse(tracer, config))
    },
    unpatch (Router) {
      this.unwrap(Router.prototype, 'register')
      this.unwrap(Router.prototype, 'use')
    }
  }
]


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-limitd-client/src/index.js":
/*!*******************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-limitd-client/src/index.js ***!
  \*******************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function createWrapRequest (tracer) {
  const scope = tracer.scope()

  return function wrapRequest (original) {
    return function requestWithTrace (request, callback) {
      const index = arguments.length - 1

      arguments[index] = scope.bind(arguments[index])

      return original.apply(this, arguments)
    }
  }
}

module.exports = [
  {
    name: 'limitd-client',
    versions: ['>=2.8'],
    patch (LimitdClient, tracer) {
      this.wrap(LimitdClient.prototype, '_directRequest', createWrapRequest(tracer))
      this.wrap(LimitdClient.prototype, '_retriedRequest', createWrapRequest(tracer))
    },
    unpatch (LimitdClient) {
      this.unwrap(LimitdClient.prototype, '_directRequest')
      this.unwrap(LimitdClient.prototype, '_retriedRequest')
    }
  }
]


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-memcached/src/index.js":
/*!***************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-memcached/src/index.js ***!
  \***************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Plugin = __webpack_require__(/*! ../../dd-trace/src/plugins/plugin */ "../../node_modules/dd-trace/packages/dd-trace/src/plugins/plugin.js")
const { storage } = __webpack_require__(/*! ../../datadog-core */ "../../node_modules/dd-trace/packages/datadog-core/index.js")
const analyticsSampler = __webpack_require__(/*! ../../dd-trace/src/analytics_sampler */ "../../node_modules/dd-trace/packages/dd-trace/src/analytics_sampler.js")

class MemcachedPlugin extends Plugin {
  static get name () {
    return 'memcached'
  }

  constructor (...args) {
    super(...args)

    this.addSub('apm:memcached:command:start', () => {
      const store = storage.getStore()
      const childOf = store ? store.span : store
      const span = this.tracer.startSpan('memcached.command', {
        childOf,
        tags: {
          'span.kind': 'client',
          'span.type': 'memcached',
          'service.name': this.config.service || `${this.tracer._service}-memcached`
        }
      })

      analyticsSampler.sample(span, this.config.measured)
      this.enter(span, store)
    })

    this.addSub('apm:memcached:command:end', () => {
      this.exit()
    })

    this.addSub('apm:memcached:command:start:with-args', ({ client, server, query }) => {
      const span = storage.getStore().span
      span.addTags({
        'resource.name': query.type,
        'memcached.command': query.command
      })

      const address = getAddress(client, server, query)

      if (address) {
        span.addTags({
          'out.host': address[0],
          'out.port': address[1]
        })
      }
    })

    this.addSub('apm:memcached:command:error', err => {
      const span = storage.getStore().span
      span.setTag('error', err)
    })

    this.addSub('apm:memcached:command:async-end', () => {
      const span = storage.getStore().span
      span.finish()
    })
  }
}

function getAddress (client, server, query) {
  if (!server) {
    if (client.servers.length === 1) {
      server = client.servers[0]
    } else {
      let redundancy = client.redundancy && client.redundancy < client.servers.length
      const queryRedundancy = query.redundancyEnabled

      if (redundancy && queryRedundancy) {
        redundancy = client.HashRing.range(query.key, (client.redundancy + 1), true)
        server = redundancy.shift()
      } else {
        server = client.HashRing.get(query.key)
      }
    }
  }

  return server && server.split(':')
}

module.exports = MemcachedPlugin


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-microgateway-core/src/index.js":
/*!***********************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-microgateway-core/src/index.js ***!
  \***********************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const web = __webpack_require__(/*! ../../dd-trace/src/plugins/util/web */ "../../node_modules/dd-trace/packages/dd-trace/src/plugins/util/web.js")

// https://docs.apigee.com/api-platform/microgateway/3.1.x/develop-custom-plugins#eventhandlerfunctions
const listeners = [
  'onrequest',
  'ondata_request',
  'onend_request',
  'onclose_request',
  'onerror_request',
  'onresponse',
  'ondata_response',
  'onend_response',
  'onclose_response',
  'onerror_response'
]

function createWrapGateway (tracer, config) {
  config = web.normalizeConfig(config)

  return function wrapGateway (Gateway) {
    return function GatewayWithTrace (config) {
      const gateway = Gateway.apply(this, arguments)

      gateway.addPlugin = wrapAddPlugin(gateway.addPlugin)

      return gateway
    }
  }
}

function createWrapConfigProxyFactory (tracer, config) {
  config = web.normalizeConfig(config)

  return function wrapConfigProxyFactory (configProxyFactory) {
    return function configProxyFactoryWithTrace () {
      const configProxy = configProxyFactory.apply(this, arguments)

      return function configProxyWithTrace (req, res, next) {
        return web.instrument(tracer, config, req, res, 'microgateway.request', () => {
          web.beforeEnd(req, () => {
            res.proxy && web.enterRoute(req, res.proxy.base_path)
          })

          arguments[2] = wrapNext(req, next)

          return configProxy.apply(this, arguments)
        })
      }
    }
  }
}

function createWrapPluginsFactory (tracer, config) {
  config = web.normalizeConfig(config)

  return function wrapPluginsFactory (pluginsFactory) {
    return function pluginsFactoryWithTrace (plugins) {
      const pluginsMiddleware = pluginsFactory.apply(this, arguments)

      return function pluginsMiddlewareWithTrace (req, res, next) {
        arguments[2] = wrapNext(req, next)

        return pluginsMiddleware.apply(this, arguments)
      }
    }
  }
}

function wrapAddPlugin (addPlugin) {
  return function (name, plugin) {
    if (typeof plugin === 'function') {
      arguments[1] = wrapPluginInit(plugin)
    } else if (plugin && typeof plugin.init === 'function') {
      plugin.init = wrapPluginInit(plugin.init)
    }

    return addPlugin.apply(this, arguments)
  }
}

function wrapPluginInit (init) {
  return function initWithTrace (config, logging, stats) {
    const handler = init.apply(this, arguments)

    wrapListeners(handler)

    return handler
  }
}

function wrapNext (req, next) {
  return function nextWithTrace (err) {
    web.addError(req, err)

    return next.apply(this, arguments)
  }
}

function wrapListeners (handler) {
  for (const name of listeners) {
    const listener = handler[name]

    if (!listener) continue

    switch (listener.length) {
      case 3:
        handler[name] = function handlerWithTrace (req, res, next) {
          return web.reactivate(req, () => listener.apply(this, arguments))
        }
        break
      case 4:
        handler[name] = function handlerWithTrace (req, res, data, next) {
          return web.reactivate(req, () => listener.apply(this, arguments))
        }
        break
    }
  }
}

module.exports = [
  {
    name: 'microgateway-core',
    versions: ['>=2.1'],
    patch (Gateway, tracer, config) {
      return this.wrapExport(Gateway, createWrapGateway(tracer, config)(Gateway))
    },
    unpatch (Gateway) {
      this.unwrapExport(Gateway)
    }
  },
  {
    name: 'microgateway-core',
    versions: ['>=2.1'],
    file: 'lib/config-proxy-middleware.js',
    patch (configProxyFactory, tracer, config) {
      const wrapper = createWrapConfigProxyFactory(tracer, config)(configProxyFactory)
      return this.wrapExport(configProxyFactory, wrapper)
    },
    unpatch (configProxyFactory) {
      this.unwrapExport(configProxyFactory)
    }
  },
  {
    name: 'microgateway-core',
    versions: ['>=2.1'],
    file: 'lib/plugins-middleware.js',
    patch (pluginsFactory, tracer, config) {
      const wrapper = createWrapPluginsFactory(tracer, config)(pluginsFactory)
      return this.wrapExport(pluginsFactory, wrapper)
    },
    unpatch (pluginsFactory) {
      this.unwrapExport(pluginsFactory)
    }
  }
]


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-mocha/src/index.js":
/*!***********************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-mocha/src/index.js ***!
  \***********************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Plugin = __webpack_require__(/*! ../../dd-trace/src/plugins/plugin */ "../../node_modules/dd-trace/packages/dd-trace/src/plugins/plugin.js")
const { storage } = __webpack_require__(/*! ../../datadog-core */ "../../node_modules/dd-trace/packages/datadog-core/index.js")

const {
  CI_APP_ORIGIN,
  TEST_CODE_OWNERS,
  TEST_TYPE,
  TEST_NAME,
  TEST_SUITE,
  TEST_FRAMEWORK_VERSION,
  TEST_STATUS,
  TEST_PARAMETERS,
  finishAllTraceSpans,
  getTestEnvironmentMetadata,
  getTestSuitePath,
  getTestParentSpan,
  getTestParametersString,
  getCodeOwnersFileEntries,
  getCodeOwnersForFilename
} = __webpack_require__(/*! ../../dd-trace/src/plugins/util/test */ "../../node_modules/dd-trace/packages/dd-trace/src/plugins/util/test.js")
const { SPAN_TYPE, RESOURCE_NAME, SAMPLING_PRIORITY } = __webpack_require__(/*! ../../../ext/tags */ "../../node_modules/dd-trace/ext/tags.js")
const { SAMPLING_RULE_DECISION } = __webpack_require__(/*! ../../dd-trace/src/constants */ "../../node_modules/dd-trace/packages/dd-trace/src/constants.js")
const { AUTO_KEEP } = __webpack_require__(/*! ../../../ext/priority */ "../../node_modules/dd-trace/ext/priority.js")

const skippedTests = new WeakSet()

function getTestSpanMetadata (tracer, test, sourceRoot) {
  const childOf = getTestParentSpan(tracer)

  const { file: testSuiteAbsolutePath } = test
  const fullTestName = test.fullTitle()
  const testSuite = getTestSuitePath(testSuiteAbsolutePath, sourceRoot)

  return {
    childOf,
    [SPAN_TYPE]: 'test',
    [TEST_TYPE]: 'test',
    [TEST_NAME]: fullTestName,
    [TEST_SUITE]: testSuite,
    [SAMPLING_RULE_DECISION]: 1,
    [SAMPLING_PRIORITY]: AUTO_KEEP,
    [TEST_FRAMEWORK_VERSION]: tracer._version,
    [RESOURCE_NAME]: `${testSuite}.${fullTestName}`
  }
}

class MochaPlugin extends Plugin {
  static get name () {
    return 'mocha'
  }

  constructor (...args) {
    super(...args)

    this._testNameToParams = {}
    this.testEnvironmentMetadata = getTestEnvironmentMetadata('mocha', this.config)
    this.sourceRoot = process.cwd()
    this.codeOwnersEntries = getCodeOwnersFileEntries(this.sourceRoot)

    this.addSub('ci:mocha:test:start', (test) => {
      const store = storage.getStore()
      const span = this.startTestSpan(test)

      this.enter(span, store)
    })

    this.addSub('ci:mocha:test:async-end', (status) => {
      // if the status is skipped the span has already been finished
      if (status === 'skipped') {
        return
      }
      const span = storage.getStore().span

      span.setTag(TEST_STATUS, status)

      span.finish()
      finishAllTraceSpans(span)
    })

    this.addSub('ci:mocha:test:end', () => {
      this.exit()
    })

    // This covers programmatically skipped tests (that do go through `runTest`)
    this.addSub('ci:mocha:test:skip', () => {
      const span = storage.getStore().span
      span.setTag(TEST_STATUS, 'skip')
      span.finish()
    })

    this.addSub('ci:mocha:test:error', (err) => {
      if (err) {
        const span = storage.getStore().span
        if (err.constructor.name === 'Pending' && !this.forbidPending) {
          span.setTag(TEST_STATUS, 'skip')
        } else {
          span.setTag(TEST_STATUS, 'fail')
          span.setTag('error', err)
        }
      }
    })

    this.addSub('ci:mocha:suite:end', tests => {
      tests.forEach(test => {
        const { pending: isSkipped } = test
        // `tests` includes every test, so we need a way to mark
        // the test as already accounted for. We do this through `skippedTests`.
        // If the test is already marked as skipped, we don't create an additional test span.
        if (!isSkipped || skippedTests.has(test)) {
          return
        }
        skippedTests.add(test)

        const testSpan = this.startTestSpan(test)

        testSpan.setTag(TEST_STATUS, 'skip')
        testSpan.finish()
      })
    })

    this.addSub('ci:mocha:hook:error', ({ test, error }) => {
      const testSpan = this.startTestSpan(test)
      testSpan.setTag(TEST_STATUS, 'fail')
      testSpan.setTag('error', error)
      testSpan.finish()
    })

    this.addSub('ci:mocha:test:parameterize', ({ name, params }) => {
      this._testNameToParams[name] = params
    })

    this.addSub('ci:mocha:run:end', () => {
      this.tracer._exporter._writer.flush()
    })
  }

  startTestSpan (test) {
    const { childOf, ...testSpanMetadata } = getTestSpanMetadata(this.tracer, test, this.sourceRoot)

    const testParametersString = getTestParametersString(this._testNameToParams, test.title)
    if (testParametersString) {
      testSpanMetadata[TEST_PARAMETERS] = testParametersString
    }
    const codeOwners = getCodeOwnersForFilename(testSpanMetadata[TEST_SUITE], this.codeOwnersEntries)

    if (codeOwners) {
      testSpanMetadata[TEST_CODE_OWNERS] = codeOwners
    }

    const testSpan = this.tracer
      .startSpan('mocha.test', {
        childOf,
        tags: {
          ...this.testEnvironmentMetadata,
          ...testSpanMetadata
        }
      })
    testSpan.context()._trace.origin = CI_APP_ORIGIN

    return testSpan
  }
}

module.exports = MochaPlugin


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-moleculer/src/client.js":
/*!****************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-moleculer/src/client.js ***!
  \****************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const { moleculerTags } = __webpack_require__(/*! ./util */ "../../node_modules/dd-trace/packages/datadog-plugin-moleculer/src/util.js")

function createWrapCall (tracer, config) {
  return function wrapCall (call) {
    return function callWithTrace (actionName, params, opts) {
      const options = {
        service: config.service,
        resource: actionName,
        tags: {
          'span.kind': 'client'
        }
      }

      opts = arguments[2] = opts || {}
      opts.meta = opts.meta || {}

      arguments.length = Math.max(3, arguments.length)

      return tracer.trace('moleculer.call', options, () => {
        const span = tracer.scope().active()

        tracer.inject(span, 'text_map', opts.meta)

        const promise = call.apply(this, arguments)

        if (promise.ctx) {
          const endpoint = promise.ctx.endpoint || {}
          const node = endpoint.node || {}

          span.addTags({
            'out.host': node.hostname,
            'out.port': node.port,
            ...moleculerTags(this, promise.ctx, config)
          })
        }

        return promise
      })
    }
  }
}

module.exports = [
  {
    name: 'moleculer',
    versions: ['>=0.14'],
    patch ({ ServiceBroker }, tracer, config) {
      if (config.client === false) return

      config = Object.assign({}, config, config.client)

      this.wrap(ServiceBroker.prototype, 'call', createWrapCall(tracer, config))
    },
    unpatch ({ ServiceBroker }) {
      this.unwrap(ServiceBroker.prototype, 'call')
    }
  }
]


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-moleculer/src/index.js":
/*!***************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-moleculer/src/index.js ***!
  \***************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// TODO: support https://moleculer.services/docs/0.13/actions.html#Streaming

const client = __webpack_require__(/*! ./client */ "../../node_modules/dd-trace/packages/datadog-plugin-moleculer/src/client.js")
const server = __webpack_require__(/*! ./server */ "../../node_modules/dd-trace/packages/datadog-plugin-moleculer/src/server.js")

module.exports = [].concat(client, server)


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-moleculer/src/server.js":
/*!****************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-moleculer/src/server.js ***!
  \****************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const { moleculerTags } = __webpack_require__(/*! ./util */ "../../node_modules/dd-trace/packages/datadog-plugin-moleculer/src/util.js")

function createWrapRegisterMiddlewares (tracer, config) {
  return function wrapRegisterMiddlewares (registerMiddlewares) {
    return function registerMiddlewaresWithTrace (userMiddlewares) {
      if (this.middlewares && this.middlewares.add) {
        this.middlewares.add(createMiddleware(tracer, config))
      }

      return registerMiddlewares.apply(this, arguments)
    }
  }
}

function createMiddleware (tracer, config) {
  return {
    name: 'Datadog',

    localAction (next, action) {
      const broker = this

      return function datadogMiddleware (ctx) {
        const childOf = tracer.extract('text_map', ctx.meta)
        const options = {
          service: config.service,
          resource: action.name,
          type: 'web',
          tags: {
            'span.kind': 'server',
            ...moleculerTags(broker, ctx, config)
          }
        }

        if (childOf) {
          options.childOf = childOf
        }

        return tracer.trace('moleculer.action', options, () => next(ctx))
      }
    }
  }
}

module.exports = [
  {
    name: 'moleculer',
    versions: ['>=0.14'],
    patch ({ ServiceBroker }, tracer, config) {
      if (config.server === false) return

      config = Object.assign({}, config, config.server)

      this.wrap(ServiceBroker.prototype, 'registerMiddlewares', createWrapRegisterMiddlewares(tracer, config))
    },
    unpatch ({ ServiceBroker }) {
      this.unwrap(ServiceBroker.prototype, 'registerMiddlewares')
    }
  }
]


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-moleculer/src/util.js":
/*!**************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-moleculer/src/util.js ***!
  \**************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// TODO: add ctx.params when nested object properties are deprecated

function moleculerTags (broker, ctx, config) {
  const service = ctx.service || {}
  const action = ctx.action || {}
  const meta = config.meta && ctx.meta

  return {
    'moleculer.context.action': action.name,
    'moleculer.context.meta': meta,
    'moleculer.context.node_id': ctx.nodeID,
    'moleculer.context.request_id': ctx.requestID,
    'moleculer.context.service': service.name,
    'moleculer.namespace': broker.namespace,
    'moleculer.node_id': broker.nodeID
  }
}

module.exports = { moleculerTags }


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-mongodb-core/src/index.js":
/*!******************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-mongodb-core/src/index.js ***!
  \******************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Plugin = __webpack_require__(/*! ../../dd-trace/src/plugins/plugin */ "../../node_modules/dd-trace/packages/dd-trace/src/plugins/plugin.js")
const { storage } = __webpack_require__(/*! ../../datadog-core */ "../../node_modules/dd-trace/packages/datadog-core/index.js")
const analyticsSampler = __webpack_require__(/*! ../../dd-trace/src/analytics_sampler */ "../../node_modules/dd-trace/packages/dd-trace/src/analytics_sampler.js")

class MongodbCorePlugin extends Plugin {
  static get name () {
    return 'mongodb-core'
  }

  constructor (...args) {
    super(...args)

    this.addSub(`apm:mongodb:query:start`, ({ ns, ops, options, name }) => {
      const query = getQuery(ops)
      const resource = getResource(ns, query, name)
      const store = storage.getStore()
      const childOf = store ? store.span : store
      const span = this.tracer.startSpan('mongodb.query', {
        childOf,
        tags: {
          'service.name': this.config.service || `${this.tracer._service}-mongodb`,
          'resource.name': resource,
          'span.type': 'mongodb',
          'span.kind': 'client',
          'db.name': ns
        }
      })

      if (query) {
        span.setTag('mongodb.query', query)
      }

      if (options && options.host && options.port) {
        span.addTags({
          'out.host': options.host,
          'out.port': options.port
        })
      }

      analyticsSampler.sample(span, this.config.measured)
      this.enter(span, store)
    })

    this.addSub(`apm:mongodb:query:end`, () => {
      this.exit()
    })

    this.addSub(`apm:mongodb:query:error`, err => {
      storage.getStore().span.setTag('error', err)
    })

    this.addSub(`apm:mongodb:query:async-end`, () => {
      storage.getStore().span.finish()
    })
  }
}

function getQuery (cmd) {
  if (!cmd || typeof cmd !== 'object' || Array.isArray(cmd)) return
  if (cmd.query) return JSON.stringify(sanitize(cmd.query))
  if (cmd.filter) return JSON.stringify(sanitize(cmd.filter))
}

function getResource (ns, query, operationName) {
  const parts = [operationName, ns]

  if (query) {
    parts.push(query)
  }

  return parts.join(' ')
}

function shouldHide (input) {
  return !isObject(input) || Buffer.isBuffer(input) || isBSON(input)
}

function sanitize (input) {
  if (shouldHide(input)) return '?'

  const output = {}
  const queue = [{
    input,
    output,
    depth: 0
  }]

  while (queue.length) {
    const {
      input, output, depth
    } = queue.pop()
    const nextDepth = depth + 1
    for (const key in input) {
      if (typeof input[key] === 'function') continue

      const child = input[key]
      if (depth >= 20 || shouldHide(child)) {
        output[key] = '?'
      } else {
        queue.push({
          input: child,
          output: output[key] = {},
          depth: nextDepth
        })
      }
    }
  }

  return output
}

function isObject (val) {
  return typeof val === 'object' && val !== null && !(val instanceof Array)
}

function isBSON (val) {
  return val && val._bsontype
}

module.exports = MongodbCorePlugin


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-mysql/src/index.js":
/*!***********************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-mysql/src/index.js ***!
  \***********************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Plugin = __webpack_require__(/*! ../../dd-trace/src/plugins/plugin */ "../../node_modules/dd-trace/packages/dd-trace/src/plugins/plugin.js")
const { storage } = __webpack_require__(/*! ../../datadog-core */ "../../node_modules/dd-trace/packages/datadog-core/index.js")
const analyticsSampler = __webpack_require__(/*! ../../dd-trace/src/analytics_sampler */ "../../node_modules/dd-trace/packages/dd-trace/src/analytics_sampler.js")

class MySQLPlugin extends Plugin {
  static get name () {
    return 'mysql'
  }

  constructor (...args) {
    super(...args)

    this.addSub(`apm:${this.constructor.name}:query:start`, ({ sql, conf }) => {
      const store = storage.getStore()
      const childOf = store ? store.span : store
      const span = this.tracer.startSpan('mysql.query', {
        childOf,
        tags: {
          'service.name': this.config.service || `${this.tracer._service}-mysql`,
          'span.type': 'sql',
          'span.kind': 'client',
          'db.type': 'mysql',
          'db.user': conf.user,
          'out.host': conf.host,
          'out.port': conf.port,
          'resource.name': sql
        }
      })

      if (conf.database) {
        span.setTag('db.name', conf.database)
      }

      analyticsSampler.sample(span, this.config.measured)
      this.enter(span, store)
    })

    this.addSub(`apm:${this.constructor.name}:query:end`, () => {
      this.exit()
    })

    this.addSub(`apm:${this.constructor.name}:query:error`, err => {
      if (err) {
        const span = storage.getStore().span
        span.setTag('error', err)
      }
    })

    this.addSub(`apm:${this.constructor.name}:query:async-end`, () => {
      const span = storage.getStore().span
      span.finish()
    })
  }
}

module.exports = MySQLPlugin


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-mysql2/src/index.js":
/*!************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-mysql2/src/index.js ***!
  \************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const MySQLPlugin = __webpack_require__(/*! ../../datadog-plugin-mysql/src */ "../../node_modules/dd-trace/packages/datadog-plugin-mysql/src/index.js")

class MySQL2Plugin extends MySQLPlugin {
  static get name () {
    return 'mysql2'
  }
}

module.exports = MySQL2Plugin


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-net/src/index.js":
/*!*********************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-net/src/index.js ***!
  \*********************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Plugin = __webpack_require__(/*! ../../dd-trace/src/plugins/plugin */ "../../node_modules/dd-trace/packages/dd-trace/src/plugins/plugin.js")
const { storage } = __webpack_require__(/*! ../../datadog-core */ "../../node_modules/dd-trace/packages/datadog-core/index.js")
const analyticsSampler = __webpack_require__(/*! ../../dd-trace/src/analytics_sampler */ "../../node_modules/dd-trace/packages/dd-trace/src/analytics_sampler.js")

class NetPlugin extends Plugin {
  static get name () {
    return 'net'
  }

  constructor (...args) {
    super(...args)

    this.addSub(`apm:net:ipc:start`, ({ options }) => {
      const store = storage.getStore()
      const childOf = store ? store.span : store

      const span = this.tracer.startSpan('ipc.connect', {
        childOf,
        tags: {
          'resource.name': options.path,
          'ipc.path': options.path,
          'span.kind': 'client',
          'service.name': this.config.service || this.tracer._service
        }
      })

      analyticsSampler.sample(span, this.config.measured)
      this.enter(span, store)
    })

    this.addSub(`apm:net:ipc:end`, this.exit.bind(this))

    this.addSub(`apm:net:ipc:error`, errorHandler)

    this.addSub(`apm:net:ipc:async-end`, defaultAsyncEnd)

    this.addSub(`apm:net:tcp:start`, ({ options }) => {
      const store = storage.getStore()
      const childOf = store ? store.span : store

      const host = options.host || 'localhost'
      const port = options.port || 0
      const family = options.family || 4

      const span = this.tracer.startSpan('tcp.connect', {
        childOf,
        tags: {
          'resource.name': [host, port].filter(val => val).join(':'),
          'tcp.remote.host': host,
          'tcp.remote.port': port,
          'tcp.family': `IPv${family}`,
          'out.host': host,
          'out.port': port,
          'span.kind': 'client',
          'service.name': this.config.service || this.tracer._service
        }
      })

      analyticsSampler.sample(span, this.config.measured)
      this.enter(span, store)
    })

    this.addSub(`apm:net:tcp:end`, this.exit.bind(this))

    this.addSub(`apm:net:tcp:error`, errorHandler)

    this.addSub(`apm:net:tcp:async-end`, defaultAsyncEnd)

    this.addSub(`apm:net:tcp:connection`, ({ socket }) => {
      const span = storage.getStore().span
      span.addTags({
        'tcp.local.address': socket.localAddress,
        'tcp.local.port': socket.localPort
      })
    })
  }
}

function defaultAsyncEnd () {
  storage.getStore().span.finish()
}

function errorHandler (error) {
  storage.getStore().span.setTag('error', error)
}

module.exports = NetPlugin


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-next/src/index.js":
/*!**********************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-next/src/index.js ***!
  \**********************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// TODO: either instrument all or none of the render functions

const analyticsSampler = __webpack_require__(/*! ../../dd-trace/src/analytics_sampler */ "../../node_modules/dd-trace/packages/dd-trace/src/analytics_sampler.js")

const contexts = new WeakMap()

function createWrapHandleRequest (tracer, config) {
  return function wrapHandleRequest (handleRequest) {
    return function handleRequestWithTrace (req, res, pathname, query) {
      return trace(tracer, config, req, res, () => handleRequest.apply(this, arguments))
    }
  }
}

function createWrapHandleApiRequest (tracer, config) {
  return function wrapHandleApiRequest (handleApiRequest) {
    return function handleApiRequestWithTrace (req, res, pathname, query) {
      return trace(tracer, config, req, res, () => {
        const promise = handleApiRequest.apply(this, arguments)

        return promise.then(handled => {
          if (!handled) return handled

          const page = getPageFromPath(pathname, this.dynamicRoutes)

          addPage(req, page)

          return handled
        })
      })
    }
  }
}

function createWrapRenderToResponse (tracer, config) {
  return function wrapRenderToResponse (renderToResponse) {
    return function renderToResponseWithTrace (ctx) {
      return trace(tracer, config, ctx.req, ctx.res, () => renderToResponse.apply(this, arguments))
    }
  }
}

function createWrapRenderErrorToResponse (tracer, config) {
  return function wrapRenderErrorToResponse (renderErrorToResponse) {
    return function renderErrorToResponseWithTrace (ctx) {
      return trace(tracer, config, ctx.req, ctx.res, () => renderErrorToResponse.apply(this, arguments))
    }
  }
}

function createWrapRenderToHTML (tracer, config) {
  return function wrapRenderToHTML (renderToHTML) {
    return function renderToHTMLWithTrace (req, res, pathname, query, parsedUrl) {
      return trace(tracer, config, req, res, () => renderToHTML.apply(this, arguments))
    }
  }
}

function createWrapRenderErrorToHTML (tracer, config) {
  return function wrapRenderErrorToHTML (renderErrorToHTML) {
    return function renderErrorToHTMLWithTrace (err, req, res, pathname, query) {
      return trace(tracer, config, req, res, () => renderErrorToHTML.apply(this, arguments))
    }
  }
}

function createWrapFindPageComponents (tracer, config) {
  return function wrapFindPageComponents (findPageComponents) {
    return function findPageComponentsWithTrace (pathname, query) {
      const result = findPageComponents.apply(this, arguments)
      const span = tracer.scope().active()
      const req = span && span._nextReq

      if (result) {
        addPage(req, pathname)
      }

      return result
    }
  }
}

function getPageFromPath (page, dynamicRoutes = []) {
  for (const dynamicRoute of dynamicRoutes) {
    if (dynamicRoute.page.startsWith('/api') && dynamicRoute.match(page)) {
      return dynamicRoute.page
    }
  }

  return page
}

function trace (tracer, config, req, res, handler) {
  const scope = tracer.scope()
  const context = contexts.get(req)

  if (context) return scope.activate(context.span, handler)

  const childOf = scope.active()
  const tags = {
    'service.name': config.service || tracer._service,
    'resource.name': req.method,
    'span.type': 'web',
    'span.kind': 'server',
    'http.method': req.method
  }
  const span = tracer.startSpan('next.request', { childOf, tags })

  analyticsSampler.sample(span, config.measured, true)

  contexts.set(req, { span })

  const promise = scope.activate(span, handler)

  // HACK: Store the request object on the span for findPageComponents.
  // TODO: Use CLS when it will be available in core.
  span._nextReq = req

  return promise.then(
    result => finish(span, config, req, res, result),
    err => finish(span, config, req, res, null, err)
  )
}

function addPage (req, page) {
  const context = contexts.get(req)

  if (!context) return

  context.span.addTags({
    'resource.name': `${req.method} ${page}`.trim(),
    'next.page': page
  })
}

function finish (span, config, req, res, result, err) {
  span.setTag('error', err || !config.validateStatus(res.statusCode))
  span.addTags({
    'http.status_code': res.statusCode
  })
  config.hooks.request(span, req, res)
  span.finish()

  return result || err
}

function normalizeConfig (config) {
  const hooks = getHooks(config)
  const validateStatus = typeof config.validateStatus === 'function'
    ? config.validateStatus
    : code => code < 500

  return Object.assign({}, config, { hooks, validateStatus })
}

function getHooks (config) {
  const noop = () => {}
  const request = (config.hooks && config.hooks.request) || noop

  return { request }
}

module.exports = [
  {
    name: 'next',
    versions: ['>=9.5 <11.1'],
    file: 'dist/next-server/server/next-server.js',
    patch ({ default: Server }, tracer, config) {
      config = normalizeConfig(config)

      this.wrap(Server.prototype, 'handleRequest', createWrapHandleRequest(tracer, config))
      this.wrap(Server.prototype, 'handleApiRequest', createWrapHandleApiRequest(tracer, config))
      this.wrap(Server.prototype, 'renderToHTML', createWrapRenderToHTML(tracer, config))
      this.wrap(Server.prototype, 'renderErrorToHTML', createWrapRenderErrorToHTML(tracer, config))
      this.wrap(Server.prototype, 'findPageComponents', createWrapFindPageComponents(tracer, config))
    },
    unpatch ({ default: Server }) {
      this.unwrap(Server.prototype, 'handleRequest')
      this.unwrap(Server.prototype, 'handleApiRequest')
      this.unwrap(Server.prototype, 'renderToHTML')
      this.unwrap(Server.prototype, 'renderErrorToHTML')
      this.unwrap(Server.prototype, 'findPageComponents')
    }
  },

  {
    name: 'next',
    versions: ['>=11.1'],
    file: 'dist/server/next-server.js',
    patch ({ default: Server }, tracer, config) {
      config = normalizeConfig(config)

      this.wrap(Server.prototype, 'handleRequest', createWrapHandleRequest(tracer, config))
      this.wrap(Server.prototype, 'handleApiRequest', createWrapHandleApiRequest(tracer, config))
      this.wrap(Server.prototype, 'renderToResponse', createWrapRenderToResponse(tracer, config))
      this.wrap(Server.prototype, 'renderErrorToResponse', createWrapRenderErrorToResponse(tracer, config))
      this.wrap(Server.prototype, 'findPageComponents', createWrapFindPageComponents(tracer, config))
    },
    unpatch ({ default: Server }) {
      this.unwrap(Server.prototype, 'handleRequest')
      this.unwrap(Server.prototype, 'handleApiRequest')
      this.unwrap(Server.prototype, 'renderToResponse')
      this.unwrap(Server.prototype, 'renderErrorToResponse')
      this.unwrap(Server.prototype, 'findPageComponents')
    }
  }
]


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-oracledb/src/index.js":
/*!**************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-oracledb/src/index.js ***!
  \**************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const analyticsSampler = __webpack_require__(/*! ../../dd-trace/src/analytics_sampler */ "../../node_modules/dd-trace/packages/dd-trace/src/analytics_sampler.js")

const connectionAttributes = new WeakMap()
const poolAttributes = new WeakMap()

function createWrapExecute (tracer, config) {
  return function wrapExecute (execute) {
    return function executeWithTrace (dbQuery, ...args) {
      const connAttrs = connectionAttributes.get(this)
      const service = getServiceName(tracer, config, connAttrs)
      const connectStringObj = new URL('http://' + connAttrs.connectString)
      const tags = {
        'span.kind': 'client',
        'span.type': 'sql',
        'sql.query': dbQuery,
        'db.instance': connectStringObj.pathname.substring(1),
        'db.hostname': connectStringObj.hostname,
        'db.user': config.user,
        'db.port': connectStringObj.port,
        'resource.name': dbQuery,
        'service.name': service
      }

      return tracer.wrap('oracle.query', { tags }, function (...args) {
        const span = tracer.scope().active()

        analyticsSampler.sample(span, config.measured)

        return execute.apply(this, args)
      }).apply(this, arguments)
    }
  }
}

function createWrapGetConnection (tracer, config) {
  return function wrapGetConnection (getConnection) {
    return function getConnectionWithTrace (connAttrs, callback) {
      if (callback) {
        arguments[1] = (err, connection) => {
          if (connection) {
            connectionAttributes.set(connection, connAttrs)
          }
          callback(err, connection)
        }

        getConnection.apply(this, arguments)
      } else {
        return getConnection.apply(this, arguments).then((connection) => {
          connectionAttributes.set(connection, connAttrs)
          return connection
        })
      }
    }
  }
}

function createWrapCreatePool (tracer, config) {
  return function wrapCreatePool (createPool) {
    return function createPoolWithTrace (poolAttrs, callback) {
      if (callback) {
        arguments[1] = (err, pool) => {
          if (pool) {
            poolAttributes.set(pool, poolAttrs)
          }
          callback(err, pool)
        }

        createPool.apply(this, arguments)
      } else {
        return createPool.apply(this, arguments).then((pool) => {
          poolAttributes.set(pool, poolAttrs)
          return pool
        })
      }
    }
  }
}

function createWrapPoolGetConnection (tracer, config) {
  return function wrapPoolGetConnection (getConnection) {
    return function poolGetConnectionWithTrace () {
      let callback
      if (typeof arguments[arguments.length - 1] === 'function') {
        callback = arguments[arguments.length - 1]
      }
      if (callback) {
        arguments[arguments.length - 1] = (err, connection) => {
          if (connection) {
            connectionAttributes.set(connection, poolAttributes.get(this))
          }
          callback(err, connection)
        }
        getConnection.apply(this, arguments)
      } else {
        return getConnection.apply(this, arguments).then((connection) => {
          connectionAttributes.set(connection, poolAttributes.get(this))
          return connection
        })
      }
    }
  }
}

function getServiceName (tracer, config, connAttrs) {
  if (typeof config.service === 'function') {
    return config.service(connAttrs)
  } else if (config.service) {
    return config.service
  } else {
    return `${tracer._service}-oracle`
  }
}

module.exports = {
  name: 'oracledb',
  versions: ['5'],
  patch (oracledb, tracer, config) {
    this.wrap(oracledb.Connection.prototype, 'execute', createWrapExecute(tracer, config))
    this.wrap(oracledb, 'getConnection', createWrapGetConnection(tracer, config))
    this.wrap(oracledb, 'createPool', createWrapCreatePool(tracer, config))
    this.wrap(oracledb.Pool.prototype, 'getConnection', createWrapPoolGetConnection(tracer, config))
  },
  unpatch (oracledb) {
    this.unwrap(oracledb.Connection.prototype, 'execute')
    this.unwrap(oracledb, 'getConnection')
    this.unwrap(oracledb, 'createPool')
    this.unwrap(oracledb.Pool.prototype, 'getConnection')
  }
}


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-paperplane/src/index.js":
/*!****************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-paperplane/src/index.js ***!
  \****************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const web = __webpack_require__(/*! ../../dd-trace/src/plugins/util/web */ "../../node_modules/dd-trace/packages/dd-trace/src/plugins/util/web.js")

const traceRoute = handler => req => {
  const { original, route } = req

  if (web.active(original)) {
    web.enterRoute(original, route)
  }

  return handler(req)
}

const wrapLogger = tracer => logger => record => {
  const span = tracer.scope().active()

  if (!span) return logger(record)

  const correlation = {
    dd: {
      trace_id: span.context().toTraceId(),
      span_id: span.context().toSpanId()
    }
  }

  record = record instanceof Error
    ? Object.assign(record, correlation)
    : Object.assign({}, record, correlation)

  return logger(record)
}

const wrapMount = (tracer, config) => mount => opts => {
  const handler = mount(opts)

  const traced = (req, res) =>
    web.instrument(
      tracer, config, req, res, 'paperplane.request',
      () => handler(req, res)
    )

  return traced
}

const wrapRoutes = tracer => routes => handlers => {
  const traced = {}

  for (const route in handlers) {
    traced[route] = traceRoute(handlers[route])
  }

  return routes(traced)
}

const nodeMajor = Number(process.versions.node.split('.')[0])
const mainVersionRange = nodeMajor <= 12 ? ['>=2.3.2'] : nodeMajor <= 14 ? ['>=3.1.1'] : []

module.exports = [
  {
    name: 'paperplane',
    versions: mainVersionRange,
    file: 'lib/logger.js',
    patch (exports, tracer) {
      if (tracer._logInjection) {
        this.wrap(exports, 'logger', wrapLogger(tracer))
      }
    },
    unpatch (exports) {
      this.unwrap(exports, 'logger')
    }
  },
  {
    name: 'paperplane',
    versions: mainVersionRange,
    file: 'lib/mount.js',
    patch (exports, tracer, config) {
      config = web.normalizeConfig(config)
      this.wrap(exports, 'mount', wrapMount(tracer, config))
    },
    unpatch (exports) {
      this.unwrap(exports, 'mount')
    }
  },
  {
    name: 'paperplane',
    versions: mainVersionRange,
    file: 'lib/routes.js',
    patch (exports, tracer) {
      this.wrap(exports, 'routes', wrapRoutes(tracer))
    },
    unpatch (exports) {
      this.unwrap(exports, 'routes')
    }
  }
]

if (nodeMajor <= 12) {
  module.exports.push({
    name: 'paperplane',
    versions: ['2.3.0 - 2.3.1'],
    patch (paperplane, tracer, config) {
      config = web.normalizeConfig(config)
      this.wrap(paperplane, 'mount', wrapMount(tracer, config))
      this.wrap(paperplane, 'routes', wrapRoutes(tracer))
    },
    unpatch (paperplane) {
      this.unwrap(paperplane, ['mount', 'routes'])
    }
  })
}


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-pg/src/index.js":
/*!********************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-pg/src/index.js ***!
  \********************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Plugin = __webpack_require__(/*! ../../dd-trace/src/plugins/plugin */ "../../node_modules/dd-trace/packages/dd-trace/src/plugins/plugin.js")
const { storage } = __webpack_require__(/*! ../../datadog-core */ "../../node_modules/dd-trace/packages/datadog-core/index.js")
const analyticsSampler = __webpack_require__(/*! ../../dd-trace/src/analytics_sampler */ "../../node_modules/dd-trace/packages/dd-trace/src/analytics_sampler.js")

class PGPlugin extends Plugin {
  static get name () {
    return 'pg'
  }

  constructor (...args) {
    super(...args)

    this.addSub(`apm:pg:query:start`, ({ params, statement }) => {
      const service = getServiceName(this.tracer, this.config, params)
      const store = storage.getStore()
      const childOf = store ? store.span : store
      const span = this.tracer.startSpan('pg.query', {
        childOf,
        tags: {
          'service.name': service,
          'span.type': 'sql',
          'span.kind': 'client',
          'db.type': 'postgres',
          'resource.name': statement
        }
      })

      if (params) {
        span.addTags({
          'db.name': params.database,
          'db.user': params.user,
          'out.host': params.host,
          'out.port': params.port
        })
      }

      analyticsSampler.sample(span, this.config.measured)
      this.enter(span, store)
    })

    this.addSub(`apm:pg:query:end`, () => {
      this.exit()
    })

    this.addSub(`apm:pg:query:error`, err => {
      const span = storage.getStore().span
      span.setTag('error', err)
    })

    this.addSub(`apm:pg:query:async-end`, () => {
      const span = storage.getStore().span
      span.finish()
    })
  }
}

function getServiceName (tracer, config, params) {
  if (typeof config.service === 'function') {
    return config.service(params)
  } else if (config.service) {
    return config.service
  } else {
    return `${tracer._service}-postgres`
  }
}

module.exports = PGPlugin


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-pino/src/index.js":
/*!**********************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-pino/src/index.js ***!
  \**********************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const LogPlugin = __webpack_require__(/*! ../../dd-trace/src/plugins/log_plugin */ "../../node_modules/dd-trace/packages/dd-trace/src/plugins/log_plugin.js")

class PinoPlugin extends LogPlugin {
  static get name () {
    return 'pino'
  }
}

module.exports = PinoPlugin


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-redis/src/index.js":
/*!***********************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-redis/src/index.js ***!
  \***********************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Plugin = __webpack_require__(/*! ../../dd-trace/src/plugins/plugin */ "../../node_modules/dd-trace/packages/dd-trace/src/plugins/plugin.js")
const { storage } = __webpack_require__(/*! ../../datadog-core */ "../../node_modules/dd-trace/packages/datadog-core/index.js")
const analyticsSampler = __webpack_require__(/*! ../../dd-trace/src/analytics_sampler */ "../../node_modules/dd-trace/packages/dd-trace/src/analytics_sampler.js")
const urlFilter = __webpack_require__(/*! ../../dd-trace/src/plugins/util/urlfilter */ "../../node_modules/dd-trace/packages/dd-trace/src/plugins/util/urlfilter.js")

class RedisPlugin extends Plugin {
  static get name () {
    return 'redis'
  }

  constructor (...args) {
    super(...args)

    this.addSub(`apm:${this.constructor.name}:command:start`, (
      { db, command, args, connectionOptions, connectionName }
    ) => {
      if (!this.config.filter(command)) {
        return this.skip()
      }
      const store = storage.getStore()
      const childOf = store ? store.span : store
      const span = this.tracer.startSpan('redis.command', {
        childOf,
        tags: {
          'span.kind': 'client',
          'resource.name': command,
          'span.type': 'redis',
          'db.type': 'redis',
          'db.name': db || '0',
          'redis.raw_command': formatCommand(command, args)
        }
      })

      span.setTag('service.name', this.config.service || `${span.context()._tags['service.name']}-redis`)

      analyticsSampler.sample(span, this.config.measured)

      if (connectionOptions) {
        span.addTags({
          'out.host': connectionOptions.host,
          'out.port': connectionOptions.port
        })
      }

      if (this.config.splitByInstance && connectionName) {
        const service = this.config.service
          ? `${this.config.service}-${connectionName}`
          : connectionName

        span.setTag('service.name', service)
      }

      this.enter(span, store)
    })

    this.addSub(`apm:${this.constructor.name}:command:end`, () => {
      this.exit()
    })

    this.addSub(`apm:${this.constructor.name}:command:error`, err => {
      const span = storage.getStore().span
      span.setTag('error', err)
    })

    this.addSub(`apm:${this.constructor.name}:command:async-end`, () => {
      const span = storage.getStore().span
      span.finish()
    })
  }

  configure (config) {
    super.configure(normalizeConfig(config))
  }
}

function formatCommand (command, args) {
  command = command.toUpperCase()

  if (!args || command === 'AUTH') return command

  for (let i = 0, l = args.length; i < l; i++) {
    if (typeof args[i] === 'function') continue

    command = `${command} ${formatArg(args[i])}`

    if (command.length > 1000) return trim(command, 1000)
  }

  return command
}

function formatArg (arg) {
  switch (typeof arg) {
    case 'string':
    case 'number':
      return trim(String(arg), 100)
    default:
      return '?'
  }
}

function trim (str, maxlen) {
  if (str.length > maxlen) {
    str = str.substr(0, maxlen - 3) + '...'
  }

  return str
}

function normalizeConfig (config) {
  const filter = urlFilter.getFilter(config)

  return Object.assign({}, config, {
    filter
  })
}

module.exports = RedisPlugin


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-restify/src/index.js":
/*!*************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-restify/src/index.js ***!
  \*************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const web = __webpack_require__(/*! ../../dd-trace/src/plugins/util/web */ "../../node_modules/dd-trace/packages/dd-trace/src/plugins/util/web.js")
const handlers = ['use', 'pre']
const methods = ['del', 'get', 'head', 'opts', 'post', 'put', 'patch']

function createWrapSetupRequest (tracer, config, withRoute) {
  config = web.normalizeConfig(config)

  return function wrapSetupRequest (setupRequest) {
    return function setupRequestWithTrace (req, res) {
      return web.instrument(tracer, config, req, res, 'restify.request', () => {
        web.beforeEnd(req, () => {
          if (req.route && withRoute) {
            web.enterRoute(req, req.route.path)
          }
        })

        return setupRequest.apply(this, arguments)
      })
    }
  }
}

function createWrapMethod (tracer, config) {
  return function wrapMethod (method) {
    return function methodWithTrace (path) {
      const middleware = wrapMiddleware(Array.prototype.slice.call(arguments, 1))

      return method.apply(this, [path].concat(middleware))
    }
  }
}

function createWrapHandler (tracer, config) {
  return function wrapMethod (method) {
    return function methodWithTrace () {
      return method.apply(this, wrapMiddleware(arguments))
    }
  }
}

function wrapMiddleware (middleware) {
  return Array.prototype.map.call(middleware, wrapFn)
}

function wrapFn (fn) {
  if (Array.isArray(fn)) return wrapMiddleware(fn)

  return function (req, res, next) {
    return web.reactivate(req, () => fn.apply(this, arguments))
  }
}

module.exports = [
  {
    name: 'restify',
    versions: ['>=7'],
    file: 'lib/server.js',
    patch (Server, tracer, config) {
      this.wrap(Server.prototype, '_setupRequest', createWrapSetupRequest(tracer, config))
      this.wrap(Server.prototype, handlers, createWrapHandler(tracer, config))
      this.wrap(Server.prototype, methods, createWrapMethod(tracer, config))
    },
    unpatch (Server) {
      this.unwrap(Server.prototype, '_setupRequest')
      this.unwrap(Server.prototype, handlers)
      this.unwrap(Server.prototype, methods)
    }
  },
  {
    name: 'restify',
    versions: ['3 - 6'],
    file: 'lib/server.js',
    patch (Server, tracer, config) {
      this.wrap(Server.prototype, '_setupRequest', createWrapSetupRequest(tracer, config, true))
      this.wrap(Server.prototype, handlers, createWrapHandler(tracer, config))
      this.wrap(Server.prototype, methods, createWrapMethod(tracer, config))
    },
    unpatch (Server) {
      this.unwrap(Server.prototype, '_setupRequest')
      this.unwrap(Server.prototype, handlers)
      this.unwrap(Server.prototype, methods)
    }
  }
]


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-rhea/src/index.js":
/*!**********************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-rhea/src/index.js ***!
  \**********************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Plugin = __webpack_require__(/*! ../../dd-trace/src/plugins/plugin */ "../../node_modules/dd-trace/packages/dd-trace/src/plugins/plugin.js")
const { storage } = __webpack_require__(/*! ../../datadog-core */ "../../node_modules/dd-trace/packages/datadog-core/index.js")
const analyticsSampler = __webpack_require__(/*! ../../dd-trace/src/analytics_sampler */ "../../node_modules/dd-trace/packages/dd-trace/src/analytics_sampler.js")

class RheaPlugin extends Plugin {
  static get name () {
    return 'rhea'
  }

  constructor (...args) {
    super(...args)

    this.addSub(`apm:rhea:send:start`, ({ targetAddress, host, port, msg }) => {
      const store = storage.getStore()
      const childOf = store ? store.span : store
      const name = targetAddress || 'amq.topic'
      const span = this.tracer.startSpan('amqp.send', {
        childOf,
        tags: {
          'component': 'rhea',
          'resource.name': name,
          'service.name': this.config.service || `${this.tracer._service}-amqp-producer`,
          'span.kind': 'producer',
          'amqp.link.target.address': name,
          'amqp.link.role': 'sender',
          'out.host': host,
          'out.port': port
        }
      })
      analyticsSampler.sample(span, this.config.measured)
      addDeliveryAnnotations(msg, this.tracer, span)

      this.enter(span, store)
    })

    this.addSub(`apm:rhea:receive:start`, ({ msgObj, connection }) => {
      const name = getResourceNameFromMessage(msgObj)

      const store = storage.getStore()
      const childOf = extractTextMap(msgObj, this.tracer)
      const span = this.tracer.startSpan('amqp.receive', {
        childOf,
        tags: {
          'span.type': 'worker',
          'component': 'rhea',
          'resource.name': name,
          'service.name': this.config.service || this.tracer._service,
          'span.kind': 'consumer',
          'amqp.link.source.address': name,
          'amqp.link.role': 'receiver'
        }
      })
      analyticsSampler.sample(span, this.config.measured, true)

      this.enter(span, store)
    })

    this.addSub(`apm:rhea:error`, error => {
      storage.getStore().span.setTag('error', error)
    })

    this.addSub(`apm:rhea:async-end`, () => {
      const span = storage.getStore().span
      span.finish()
    })

    this.addSub(`apm:rhea:end`, () => {
      this.exit()
    })

    this.addSub(`apm:rhea:dispatch`, ({ state }) => {
      const span = storage.getStore().span
      span.setTag('amqp.delivery.state', state)
    })
  }
}

function getResourceNameFromMessage (msgObj) {
  let resourceName = 'amq.topic'
  let options = {}
  if (msgObj.receiver && msgObj.receiver.options) {
    options = msgObj.receiver.options
  }
  if (options.source && options.source.address) {
    resourceName = options.source.address
  }
  return resourceName
}

function extractTextMap (msgObj, tracer) {
  if (msgObj.message) {
    return tracer.extract('text_map', msgObj.message.delivery_annotations)
  }
}

function addDeliveryAnnotations (msg, tracer, span) {
  if (msg) {
    msg.delivery_annotations = msg.delivery_annotations || {}

    tracer.inject(span, 'text_map', msg.delivery_annotations)
  }
}

module.exports = RheaPlugin


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-router/src/index.js":
/*!************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-router/src/index.js ***!
  \************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const METHODS = __webpack_require__(/*! methods */ "../../node_modules/methods/index.js").concat('all')
const pathToRegExp = __webpack_require__(/*! path-to-regexp */ "../../node_modules/path-to-regexp/index.js")
const shimmer = __webpack_require__(/*! ../../datadog-shimmer */ "../../node_modules/dd-trace/packages/datadog-shimmer/index.js")
const web = __webpack_require__(/*! ../../dd-trace/src/plugins/util/web */ "../../node_modules/dd-trace/packages/dd-trace/src/plugins/util/web.js")

// TODO: stop checking for fast star and fast slash

const contexts = new WeakMap()
const layerMatchers = new WeakMap()
const regexpCache = Object.create(null)

function createWrapHandle (tracer, config) {
  return function wrapHandle (handle) {
    return function handleWithTrace (req, res, done) {
      web.patch(req)

      if (!contexts.has(req)) {
        const context = {
          route: '',
          stack: []
        }

        web.beforeEnd(req, () => {
          web.enterRoute(req, context.route)
        })

        contexts.set(req, context)
      }

      return handle.apply(this, arguments)
    }
  }
}

function wrapRouterMethod (original) {
  return function methodWithTrace (fn) {
    const offset = this.stack ? [].concat(this.stack).length : 0
    const router = original.apply(this, arguments)

    if (typeof this.stack === 'function') {
      this.stack = [{ handle: this.stack }]
    }

    wrapStack(this.stack, offset, extractMatchers(fn))

    return router
  }
}

function wrapLayerHandle (layer, handle) {
  handle._name = handle._name || layer.name

  let wrapCallHandle

  if (handle.length === 4) {
    wrapCallHandle = shimmer.wrap(handle, function (error, req, res, next) {
      return callHandle(layer, handle, req, [error, req, res, wrapNext(layer, req, next)])
    })
  } else {
    wrapCallHandle = shimmer.wrap(handle, function (req, res, next) {
      return callHandle(layer, handle, req, [req, res, wrapNext(layer, req, next)])
    })
  }

  // This is a workaround for the `loopback` library so that it can find the correct express layer
  // that contains the real handle function
  wrapCallHandle._datadog_orig = handle

  return wrapCallHandle
}

function wrapStack (stack, offset, matchers) {
  [].concat(stack).slice(offset).forEach(layer => {
    if (layer.__handle) { // express-async-errors
      layer.__handle = wrapLayerHandle(layer, layer.__handle)
    } else {
      layer.handle = wrapLayerHandle(layer, layer.handle)
    }

    layerMatchers.set(layer, matchers)

    if (layer.route) {
      METHODS.forEach(method => {
        if (typeof layer.route.stack === 'function') {
          layer.route.stack = [{ handle: layer.route.stack }]
        }

        layer.route[method] = wrapRouterMethod(layer.route[method])
      })
    }
  })
}

function wrapNext (layer, req, next) {
  if (!next || !web.active(req)) return next

  const originalNext = next
  const context = contexts.get(req)
  const matchers = layerMatchers.get(layer)

  return function (error) {
    if (layer.path && !isFastStar(layer, matchers) && !isFastSlash(layer, matchers)) {
      context.stack.pop()
    }

    web.finish(req, error)

    originalNext.apply(null, arguments)
  }
}

function callHandle (layer, handle, req, args) {
  const matchers = layerMatchers.get(layer)

  if (web.active(req) && matchers) {
    // Try to guess which path actually matched
    for (let i = 0; i < matchers.length; i++) {
      if (matchers[i].test(layer)) {
        const context = contexts.get(req)

        context.stack.push(matchers[i].path)

        const route = context.stack.join('')

        // Longer route is more likely to be the actual route handler route.
        if (route.length > context.route.length) {
          context.route = route
        }

        break
      }
    }
  }

  return web.wrapMiddleware(req, handle, 'express.middleware', () => {
    return handle.apply(layer, args)
  })
}

function extractMatchers (fn) {
  const arg = flatten([].concat(fn))

  if (typeof arg[0] === 'function') {
    return []
  }

  return arg.map(pattern => ({
    path: pattern instanceof RegExp ? `(${pattern})` : pattern,
    test: layer => {
      const matchers = layerMatchers.get(layer)

      return !isFastStar(layer, matchers) &&
        !isFastSlash(layer, matchers) &&
        cachedPathToRegExp(pattern).test(layer.path)
    }
  }))
}

function isFastStar (layer, matchers) {
  if (layer.regexp.fast_star !== undefined) {
    return layer.regexp.fast_star
  }

  return matchers.some(matcher => matcher.path === '*')
}

function isFastSlash (layer, matchers) {
  if (layer.regexp.fast_slash !== undefined) {
    return layer.regexp.fast_slash
  }

  return matchers.some(matcher => matcher.path === '/')
}

function flatten (arr) {
  return arr.reduce((acc, val) => Array.isArray(val) ? acc.concat(flatten(val)) : acc.concat(val), [])
}

function cachedPathToRegExp (pattern) {
  const maybeCached = regexpCache[pattern]
  if (maybeCached) {
    return maybeCached
  }
  const regexp = pathToRegExp(pattern)
  regexpCache[pattern] = regexp
  return regexp
}

module.exports = {
  name: 'router',
  versions: ['>=1'],
  patch (Router, tracer, config) {
    this.wrap(Router.prototype, 'handle', createWrapHandle(tracer, config))
    this.wrap(Router.prototype, 'use', wrapRouterMethod)
    this.wrap(Router.prototype, 'route', wrapRouterMethod)
  },
  unpatch (Router) {
    this.unwrap(Router.prototype, 'handle')
    this.unwrap(Router.prototype, 'use')
    this.unwrap(Router.prototype, 'route')
  }
}


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-sharedb/src/index.js":
/*!*************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-sharedb/src/index.js ***!
  \*************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Plugin = __webpack_require__(/*! ../../dd-trace/src/plugins/plugin */ "../../node_modules/dd-trace/packages/dd-trace/src/plugins/plugin.js")
const { storage } = __webpack_require__(/*! ../../datadog-core */ "../../node_modules/dd-trace/packages/datadog-core/index.js")

class SharedbPlugin extends Plugin {
  static get name () {
    return 'sharedb'
  }

  constructor (...args) {
    super(...args)

    this.addSub(`apm:sharedb:request:start`, ({ actionName, request }) => {
      const store = storage.getStore()
      const childOf = store ? store.span : store
      const span = this.tracer.startSpan('sharedb.request', {
        childOf,
        tags: {
          'service.name': this.config.service || this.tracer._service,
          'span.kind': 'server',
          'sharedb.action': actionName,
          'resource.name': getReadableResourceName(actionName, request.c, request.q)
        }
      })

      if (this.config.hooks && this.config.hooks.receive) {
        this.config.hooks.receive(span, request)
      }

      this.enter(span, store)
    })

    this.addSub(`apm:sharedb:request:end`, () => {
      this.exit()
    })

    this.addSub(`apm:sharedb:request:error`, err => {
      const span = storage.getStore().span
      span.setTag('error', err)
    })

    this.addSub(`apm:sharedb:request:async-end`, ({ request, res }) => {
      const span = storage.getStore().span
      if (this.config.hooks && this.config.hooks.reply) {
        this.config.hooks.reply(span, request, res)
      }
      span.finish()
    })
  }
}

function getReadableResourceName (readableActionName, collection, query) {
  if (collection) {
    readableActionName += ' ' + collection
  }
  if (query) {
    readableActionName += ' ' + JSON.stringify(sanitize(query))
  }
  return readableActionName
}

function sanitize (input) {
  const output = {}

  if (!isObject(input) || Buffer.isBuffer(input)) return '?'

  for (const key in input) {
    if (typeof input[key] === 'function') continue

    output[key] = sanitize(input[key])
  }

  return output
}

function isObject (val) {
  return typeof val === 'object' && val !== null && !(val instanceof Array)
}

module.exports = SharedbPlugin


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-tedious/src/index.js":
/*!*************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-tedious/src/index.js ***!
  \*************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Plugin = __webpack_require__(/*! ../../dd-trace/src/plugins/plugin */ "../../node_modules/dd-trace/packages/dd-trace/src/plugins/plugin.js")
const { storage } = __webpack_require__(/*! ../../datadog-core */ "../../node_modules/dd-trace/packages/datadog-core/index.js")
const analyticsSampler = __webpack_require__(/*! ../../dd-trace/src/analytics_sampler */ "../../node_modules/dd-trace/packages/dd-trace/src/analytics_sampler.js")

class TediousPlugin extends Plugin {
  static get name () {
    return 'tedious'
  }

  constructor (...args) {
    super(...args)

    this.addSub(`apm:tedious:request:start`, ({ queryOrProcedure, connectionConfig }) => {
      const store = storage.getStore()
      const childOf = store ? store.span : store
      const span = this.tracer.startSpan('tedious.request', {
        childOf,
        tags: {
          'span.kind': 'client',
          'db.type': 'mssql',
          'span.type': 'sql',
          'component': 'tedious',
          'service.name': this.config.service || `${this.tracer._service}-mssql`,
          'resource.name': queryOrProcedure,
          'out.host': connectionConfig.server,
          'out.port': connectionConfig.options.port,
          'db.user': connectionConfig.userName || connectionConfig.authentication.options.userName,
          'db.name': connectionConfig.options.database,
          'db.instance': connectionConfig.options.instanceName
        }
      })
      analyticsSampler.sample(span, this.config.measured)
      this.enter(span, store)
    })

    this.addSub(`apm:tedious:request:end`, () => {
      this.exit()
    })

    this.addSub(`apm:tedious:request:error`, err => {
      const span = storage.getStore().span
      span.setTag('error', err)
    })

    this.addSub(`apm:tedious:request:async-end`, () => {
      const span = storage.getStore().span
      span.finish()
    })
  }
}

module.exports = TediousPlugin


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-winston/src/index.js":
/*!*************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-winston/src/index.js ***!
  \*************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const LogPlugin = __webpack_require__(/*! ../../dd-trace/src/plugins/log_plugin */ "../../node_modules/dd-trace/packages/dd-trace/src/plugins/log_plugin.js")

class WinstonPlugin extends LogPlugin {
  static get name () {
    return 'winston'
  }
}
module.exports = WinstonPlugin


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-shimmer/index.js":
/*!**************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-shimmer/index.js ***!
  \**************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(/*! ./src/shimmer */ "../../node_modules/dd-trace/packages/datadog-shimmer/src/shimmer.js")


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-shimmer/src/shimmer.js":
/*!********************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-shimmer/src/shimmer.js ***!
  \********************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// Use a weak map to avoid polluting the wrapped function/method.
const unwrappers = new WeakMap()

function copyProperties (original, wrapped) {
  Object.setPrototypeOf(wrapped, original)

  const props = Object.getOwnPropertyDescriptors(original)
  const keys = Reflect.ownKeys(props)

  for (const key of keys) {
    Object.defineProperty(wrapped, key, props[key])
  }
}

function wrapFn (original, delegate) {
  assertFunction(delegate)
  assertNotClass(original) // TODO: support constructors of native classes

  const shim = function shim () {
    return delegate.apply(this, arguments)
  }

  unwrappers.set(shim, () => {
    delegate = original
  })

  copyProperties(original, shim)

  return shim
}

function wrapMethod (target, name, wrapper) {
  assertMethod(target, name)
  assertNotClass(target[name]) // TODO: support constructors of native classes
  assertFunction(wrapper)

  const original = target[name]
  const wrapped = wrapper(original)
  const descriptor = Object.getOwnPropertyDescriptor(target, name)

  if (descriptor) {
    unwrappers.set(wrapped, () => Object.defineProperty(target, name, descriptor))
  } else { // no descriptor means original was on the prototype
    unwrappers.set(wrapped, () => delete target[name])
  }

  Object.defineProperty(target, name, {
    configurable: true,
    writable: true,
    enumerable: false,
    ...descriptor,
    value: wrapped
  })

  copyProperties(original, wrapped)

  return target
}

function wrap (target, name, wrapper) {
  return typeof name === 'function'
    ? wrapFn(target, name)
    : wrapMethod(target, name, wrapper)
}

function unwrap (target, name) {
  if (!target) return target // no target to unwrap

  const unwrapper = unwrappers.get(name ? target[name] : target)

  if (!unwrapper) return target // target is already unwrapped or isn't wrapped

  unwrapper()

  return target
}

function massWrap (targets, names, wrapper) {
  targets = toArray(targets)
  names = toArray(names)

  for (const target of targets) {
    for (const name of names) {
      wrap(target, name, wrapper)
    }
  }
}

function massUnwrap (targets, names) {
  targets = toArray(targets)
  names = toArray(names)

  for (const target of targets) {
    for (const name of names) {
      unwrap(target, name)
    }
  }
}

function toArray (maybeArray) {
  return Array.isArray(maybeArray) ? maybeArray : [maybeArray]
}

function assertMethod (target, name) {
  if (!target) {
    throw new Error('No target object provided.')
  }

  if (typeof target !== 'object' && typeof target !== 'function') {
    throw new Error('Invalid target.')
  }

  if (!target[name]) {
    throw new Error(`No original method ${name}.`)
  }

  if (typeof target[name] !== 'function') {
    throw new Error(`Original method ${name} is not a function.`)
  }
}

function assertFunction (target) {
  if (!target) {
    throw new Error('No function provided.')
  }

  if (typeof target !== 'function') {
    throw new Error('Target is not a function.')
  }
}

function assertNotClass (target) {
  if (Function.prototype.toString.call(target).startsWith('class')) {
    throw new Error('Target is a native class constructor and cannot be wrapped.')
  }
}

module.exports = {
  wrap,
  massWrap,
  unwrap,
  massUnwrap
}


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/index.js":
/*!*******************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/index.js ***!
  \*******************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


if (!global._ddtrace) {
  const TracerProxy = __webpack_require__(/*! ./src/proxy */ "../../node_modules/dd-trace/packages/dd-trace/src/proxy.js")

  Object.defineProperty(global, '_ddtrace', {
    value: new TracerProxy(),
    enumerable: false,
    configurable: true,
    writable: true
  })

  global._ddtrace.default = global._ddtrace
  global._ddtrace.tracer = global._ddtrace
}

module.exports = global._ddtrace


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/lib/version.js":
/*!*************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/lib/version.js ***!
  \*************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports) {

module.exports = '2.5.0'


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/analytics_sampler.js":
/*!***********************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/analytics_sampler.js ***!
  \***********************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const { MEASURED } = __webpack_require__(/*! ../../../ext/tags */ "../../node_modules/dd-trace/ext/tags.js")

module.exports = {
  sample (span, measured, measuredByDefault) {
    if (typeof measured === 'object') {
      this.sample(span, measured[span.context()._name], measuredByDefault)
    } else if (measured !== undefined) {
      span.setTag(MEASURED, !!measured)
    } else if (measuredByDefault) {
      span.setTag(MEASURED, true)
    }
  }
}


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/appsec/addresses.js":
/*!**********************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/appsec/addresses.js ***!
  \**********************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = {
  HTTP_INCOMING_BODY: 'server.request.body',
  HTTP_INCOMING_QUERY: 'server.request.query',
  HTTP_INCOMING_HEADERS: 'server.request.headers.no_cookies',
  // TODO: 'server.request.trailers',
  HTTP_INCOMING_URL: 'server.request.uri.raw',
  HTTP_INCOMING_METHOD: 'server.request.method',
  HTTP_INCOMING_ENDPOINT: 'server.request.framework_endpoint',
  HTTP_INCOMING_PARAMS: 'server.request.path_params',
  HTTP_INCOMING_COOKIES: 'server.request.cookies',
  HTTP_INCOMING_RESPONSE_CODE: 'server.response.status',
  HTTP_INCOMING_RESPONSE_HEADERS: 'server.response.headers.no_cookies',
  // TODO: 'server.response.trailers',
  HTTP_INCOMING_REMOTE_IP: 'server.request.client_ip',
  HTTP_INCOMING_REMOTE_PORT: 'server.request.client_port'
}


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/appsec/callbacks/ddwaf.js":
/*!****************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/appsec/callbacks/ddwaf.js ***!
  \****************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const log = __webpack_require__(/*! ../../log */ "../../node_modules/dd-trace/packages/dd-trace/src/log.js")
const addresses = __webpack_require__(/*! ../addresses */ "../../node_modules/dd-trace/packages/dd-trace/src/appsec/addresses.js")
const Gateway = __webpack_require__(/*! ../gateway/engine */ "../../node_modules/dd-trace/packages/dd-trace/src/appsec/gateway/engine/index.js")
const Reporter = __webpack_require__(/*! ../reporter */ "../../node_modules/dd-trace/packages/dd-trace/src/appsec/reporter.js")

const validAddressSet = new Set(Object.values(addresses))

const DEFAULT_MAX_BUDGET = 5e3 // µs

// TODO: put reusable code in a base class
class WAFCallback {
  static loadDDWAF (rules) {
    try {
      // require in `try/catch` because this can throw at require time
      const { DDWAF } = __webpack_require__(/*! @datadog/native-appsec */ "../../node_modules/@datadog/native-appsec/index.js")

      return new DDWAF(rules)
    } catch (err) {
      log.error('AppSec could not load native package. In-app WAF features will not be available.')

      throw err
    }
  }

  constructor (rules) {
    this.ddwaf = WAFCallback.loadDDWAF(rules)
    this.wafContextCache = new WeakMap()

    // closures are faster than binds
    const self = this
    const method = (params, store) => {
      return self.action(params, store)
    }

    // might be its own class with more info later
    const callback = { method }

    const subscribedAddresses = new Set()

    for (const rule of rules.rules) {
      for (const condition of rule.conditions) {
        for (const input of condition.parameters.inputs) {
          const address = input.address.split(':', 2)[0]

          if (!validAddressSet.has(address) || subscribedAddresses.has(address)) continue

          subscribedAddresses.add(address)

          Gateway.manager.addSubscription({ addresses: [ address ], callback })
        }
      }
    }
  }

  action (params, store) {
    let wafContext

    if (store) {
      const key = store.get('context')

      if (key) {
        if (this.wafContextCache.has(key)) {
          wafContext = this.wafContextCache.get(key)
        } else {
          wafContext = this.ddwaf.createContext()
          this.wafContextCache.set(key, wafContext)
        }
      }
    }

    if (!wafContext || wafContext.disposed) {
      wafContext = this.ddwaf.createContext()
    }

    // cast status code to string
    if (params[addresses.HTTP_INCOMING_RESPONSE_CODE]) {
      params[addresses.HTTP_INCOMING_RESPONSE_CODE] = params[addresses.HTTP_INCOMING_RESPONSE_CODE] + ''
    }

    try {
      // TODO: possible optimizaion: only send params that haven't already been sent to this wafContext
      const result = wafContext.run(params, DEFAULT_MAX_BUDGET)

      return this.applyResult(result, store)
    } catch (err) {
      log.error('Error while running the AppSec WAF')
      log.error(err)
    } finally {
      wafContext.dispose()
    }
  }

  applyResult (result, store) {
    if (result.data && result.data !== '[]') {
      Reporter.reportAttack(result.data, store)
    }

    // TODO: use these values later for budget management
    // result.perfData
    // result.perfTotalRuntime
  }

  clear () {
    this.ddwaf.dispose()

    this.wafContextCache = new WeakMap()

    Gateway.manager.clear()
  }
}

module.exports = WAFCallback


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/appsec/callbacks/index.js":
/*!****************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/appsec/callbacks/index.js ***!
  \****************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// lazy loading
// TODO: cache the returned value
module.exports = {
  get DDWAF () { return __webpack_require__(/*! ./ddwaf */ "../../node_modules/dd-trace/packages/dd-trace/src/appsec/callbacks/ddwaf.js") }
}


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/appsec/gateway/als.js":
/*!************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/appsec/gateway/als.js ***!
  \************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// TODO: use datadog-core storage instead
const { AsyncLocalStorage } = __webpack_require__(/*! async_hooks */ "async_hooks")

module.exports = new AsyncLocalStorage()


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/appsec/gateway/channels.js":
/*!*****************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/appsec/gateway/channels.js ***!
  \*****************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const dc = __webpack_require__(/*! diagnostics_channel */ "diagnostics_channel")

// TODO: use TBD naming convention
//       or directly use http plugin's channels
//       when it gets converted to new plugin system
module.exports = {
  incomingHttpRequestStart: dc.channel('dd-trace:incomingHttpRequestStart'),
  incomingHttpRequestEnd: dc.channel('dd-trace:incomingHttpRequestEnd')
}


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/appsec/gateway/engine/engine.js":
/*!**********************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/appsec/gateway/engine/engine.js ***!
  \**********************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Runner = __webpack_require__(/*! ./runner */ "../../node_modules/dd-trace/packages/dd-trace/src/appsec/gateway/engine/runner.js")

const MAX_CONTEXT_SIZE = 1024

class SubscriptionManager {
  constructor () {
    this.addressToSubscriptions = new Map()
    this.addresses = new Set()
    this.subscriptions = new Set()
  }

  clear () {
    this.addressToSubscriptions = new Map()
    this.addresses = new Set()
    this.subscriptions = new Set()
  }

  addSubscription (subscription) {
    if (!subscription.addresses.length || this.subscriptions.has(subscription)) return

    for (let i = 0; i < subscription.addresses.length; ++i) {
      const address = subscription.addresses[i]

      this.addresses.add(address)

      const list = this.addressToSubscriptions.get(address)

      if (list === undefined) {
        this.addressToSubscriptions.set(address, [ subscription ])
      } else {
        list.push(subscription)
      }
    }

    this.subscriptions.add(subscription)
  }

  matchSubscriptions (newAddresses, allAddresses) {
    const addresses = new Set()
    const subscriptions = new Set()
    const knownSubscriptions = new Set()

    // TODO: possible optimization: collect matchedSubscriptions on the fly in Context#setValue
    newAddresses.forEach((newAddress) => {
      const matchedSubscriptions = this.addressToSubscriptions.get(newAddress)

      if (matchedSubscriptions === undefined) return

      for (let j = 0; j < matchedSubscriptions.length; ++j) {
        const subscription = matchedSubscriptions[j]

        if (knownSubscriptions.has(subscription) === true) continue
        knownSubscriptions.add(subscription)

        const isFulfilled = subscription.addresses.every(allAddresses.has, allAddresses)

        if (isFulfilled === true) {
          for (let k = 0; k < subscription.addresses.length; ++k) {
            addresses.add(subscription.addresses[k])
          }

          subscriptions.add(subscription)
        }
      }
    })

    return { addresses, subscriptions }
  }

  dispatch (newAddresses, allAddresses, context) {
    const matches = this.matchSubscriptions(newAddresses, allAddresses)

    // TODO: possible optimization
    // check if matches.subscriptions is empty here instead of in runner.js

    const params = {}

    matches.addresses.forEach((address) => {
      params[address] = context.resolve(address)
    })

    return Runner.runSubscriptions(matches.subscriptions, params)
  }
}

class Context {
  static setManager (manager) {
    this.manager = manager
  }

  constructor () {
    // TODO: this probably don't need to be a Map()
    this.store = new Map()
    this.allAddresses = new Set()
    this.newAddresses = new Set()
  }

  clear () {
    this.store = new Map()
    this.allAddresses = new Set()
    this.newAddresses = new Set()
  }

  setValue (address, value) {
    if (this.allAddresses.size >= MAX_CONTEXT_SIZE) return this

    // cannot optimize for objects because they're pointers
    if (typeof value !== 'object') {
      const oldValue = this.store.get(address)
      if (oldValue === value) return this
    }

    this.store.set(address, value)
    this.allAddresses.add(address)
    this.newAddresses.add(address)

    return this
  }

  dispatch () {
    if (this.newAddresses.size === 0) return []

    const result = Context.manager.dispatch(this.newAddresses, this.allAddresses, this)

    this.newAddresses.clear()

    return result
  }

  resolve (address) {
    return this.store.get(address)
  }
}

module.exports = {
  SubscriptionManager,
  Context
}


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/appsec/gateway/engine/index.js":
/*!*********************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/appsec/gateway/engine/index.js ***!
  \*********************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const { SubscriptionManager, Context } = __webpack_require__(/*! ./engine */ "../../node_modules/dd-trace/packages/dd-trace/src/appsec/gateway/engine/engine.js")
const als = __webpack_require__(/*! ../als */ "../../node_modules/dd-trace/packages/dd-trace/src/appsec/gateway/als.js")

const manager = new SubscriptionManager()
Context.setManager(manager)

function startContext () {
  const store = new Map()

  store.set('context', new Context())

  als.enterWith(store)

  return store
}

function getContext () {
  const store = als.getStore()

  return store && store.get('context')
}

function propagate (data, context = getContext()) {
  if (!context) return

  const keys = Object.keys(data)

  for (let i = 0; i < keys.length; ++i) {
    const key = keys[i]

    if (manager.addresses.has(key)) {
      context.setValue(key, data[key])
    }
  }

  context.dispatch()
}

module.exports = {
  manager,
  startContext,
  getContext,
  propagate
}


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/appsec/gateway/engine/runner.js":
/*!**********************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/appsec/gateway/engine/runner.js ***!
  \**********************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const als = __webpack_require__(/*! ../als */ "../../node_modules/dd-trace/packages/dd-trace/src/appsec/gateway/als.js")

let lock = false // lock to prevent recursive calls to runSubscriptions

function runSubscriptions (subscriptions, params) {
  const results = []

  if (lock || !subscriptions.size) return results
  lock = true

  const store = als.getStore()

  // TODO: possible optimization
  // can we deduplicate those before ?
  const executedCallbacks = new Set()

  for (const subscription of subscriptions) {
    if (executedCallbacks.has(subscription.callback)) continue
    executedCallbacks.add(subscription.callback)

    let result

    try {
      result = subscription.callback.method(params, store)
    } catch (err) {
      // TODO: log ?
      result = {}
    }

    results.push(result)
  }

  lock = false

  return results
}

module.exports = {
  runSubscriptions
}


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/appsec/index.js":
/*!******************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/appsec/index.js ***!
  \******************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const fs = __webpack_require__(/*! fs */ "fs")
const log = __webpack_require__(/*! ../log */ "../../node_modules/dd-trace/packages/dd-trace/src/log.js")
const RuleManager = __webpack_require__(/*! ./rule_manager */ "../../node_modules/dd-trace/packages/dd-trace/src/appsec/rule_manager.js")
const { incomingHttpRequestStart, incomingHttpRequestEnd } = __webpack_require__(/*! ./gateway/channels */ "../../node_modules/dd-trace/packages/dd-trace/src/appsec/gateway/channels.js")
const Gateway = __webpack_require__(/*! ./gateway/engine */ "../../node_modules/dd-trace/packages/dd-trace/src/appsec/gateway/engine/index.js")
const addresses = __webpack_require__(/*! ./addresses */ "../../node_modules/dd-trace/packages/dd-trace/src/appsec/addresses.js")
const Reporter = __webpack_require__(/*! ./reporter */ "../../node_modules/dd-trace/packages/dd-trace/src/appsec/reporter.js")
const web = __webpack_require__(/*! ../plugins/util/web */ "../../node_modules/dd-trace/packages/dd-trace/src/plugins/util/web.js")

function enable (config) {
  try {
    // TODO: enable dc_blocking: config.appsec.blocking === true

    let rules = fs.readFileSync(config.appsec.rules)
    rules = JSON.parse(rules)

    RuleManager.applyRules(rules)
  } catch (err) {
    log.error('Unable to start AppSec')
    log.error(err)

    // abort AppSec start
    RuleManager.clearAllRules()
    return
  }

  Reporter.setRateLimit(config.appsec.rateLimit)

  incomingHttpRequestStart.subscribe(incomingHttpStartTranslator)
  incomingHttpRequestEnd.subscribe(incomingHttpEndTranslator)

  // add fields needed for HTTP context reporting
  Gateway.manager.addresses.add(addresses.HTTP_INCOMING_HEADERS)
  Gateway.manager.addresses.add(addresses.HTTP_INCOMING_ENDPOINT)
  Gateway.manager.addresses.add(addresses.HTTP_INCOMING_RESPONSE_HEADERS)
  Gateway.manager.addresses.add(addresses.HTTP_INCOMING_REMOTE_IP)
}

function incomingHttpStartTranslator (data) {
  // TODO: get span from datadog-core storage instead
  const topSpan = web.root(data.req)
  if (topSpan) {
    topSpan.addTags({
      '_dd.appsec.enabled': 1,
      '_dd.runtime_family': 'nodejs'
    })
  }

  const store = Gateway.startContext()

  store.set('req', data.req)
  store.set('res', data.res)
}

function incomingHttpEndTranslator (data) {
  const context = Gateway.getContext()

  if (!context) return

  const requestHeaders = Object.assign({}, data.req.headers)
  delete requestHeaders.cookie

  // TODO: this doesn't support headers sent with res.writeHead()
  const responseHeaders = Object.assign({}, data.res.getHeaders())
  delete responseHeaders['set-cookie']

  const payload = {
    [addresses.HTTP_INCOMING_URL]: data.req.url,
    [addresses.HTTP_INCOMING_HEADERS]: requestHeaders,
    [addresses.HTTP_INCOMING_METHOD]: data.req.method,
    [addresses.HTTP_INCOMING_REMOTE_IP]: data.req.socket.remoteAddress,
    [addresses.HTTP_INCOMING_REMOTE_PORT]: data.req.socket.remotePort,
    [addresses.HTTP_INCOMING_RESPONSE_CODE]: data.res.statusCode,
    [addresses.HTTP_INCOMING_RESPONSE_HEADERS]: responseHeaders
  }

  // TODO: temporary express instrumentation, will use express plugin later
  if (data.req.body !== undefined && data.req.body !== null) {
    payload[addresses.HTTP_INCOMING_BODY] = data.req.body
  }

  if (data.req.query && typeof data.req.query === 'object') {
    payload[addresses.HTTP_INCOMING_QUERY] = data.req.query
  }

  if (data.req.route && typeof data.req.route.path === 'string') {
    payload[addresses.HTTP_INCOMING_ENDPOINT] = data.req.route.path
  }

  if (data.req.params && typeof data.req.params === 'object') {
    payload[addresses.HTTP_INCOMING_PARAMS] = data.req.params
  }

  if (data.req.cookies && typeof data.req.cookies === 'object') {
    payload[addresses.HTTP_INCOMING_COOKIES] = data.req.cookies
  }

  Gateway.propagate(payload, context)

  Reporter.finishAttacks(data.req, context)
}

function disable () {
  RuleManager.clearAllRules()

  // Channel#unsubscribe() is undefined for non active channels
  if (incomingHttpRequestStart.hasSubscribers) incomingHttpRequestStart.unsubscribe(incomingHttpStartTranslator)
  if (incomingHttpRequestEnd.hasSubscribers) incomingHttpRequestEnd.unsubscribe(incomingHttpEndTranslator)
}

module.exports = {
  enable,
  disable,
  incomingHttpStartTranslator,
  incomingHttpEndTranslator
}


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/appsec/reporter.js":
/*!*********************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/appsec/reporter.js ***!
  \*********************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const addresses = __webpack_require__(/*! ./addresses */ "../../node_modules/dd-trace/packages/dd-trace/src/appsec/addresses.js")
const Limiter = __webpack_require__(/*! ../rate_limiter */ "../../node_modules/dd-trace/packages/dd-trace/src/rate_limiter.js")
const web = __webpack_require__(/*! ../plugins/util/web */ "../../node_modules/dd-trace/packages/dd-trace/src/plugins/util/web.js")

// default limiter, configurable with setRateLimit()
let limiter = new Limiter(100)

const REQUEST_HEADERS_PASSLIST = [
  'accept',
  'accept-encoding',
  'accept-language',
  'content-encoding',
  'content-language',
  'content-length',
  'content-type',
  'forwarded',
  'forwarded-for',
  'host',
  'true-client-ip',
  'user-agent',
  'via',
  'x-client-ip',
  'x-cluster-client-ip',
  'x-forwarded',
  'x-forwarded-for',
  'x-real-ip'
]

const RESPONSE_HEADERS_PASSLIST = [
  'content-encoding',
  'content-language',
  'content-length',
  'content-type'
]

function resolveHTTPRequest (context) {
  if (!context) return {}

  const headers = context.resolve(addresses.HTTP_INCOMING_HEADERS)

  return {
    remote_ip: context.resolve(addresses.HTTP_INCOMING_REMOTE_IP),
    headers: filterHeaders(headers, REQUEST_HEADERS_PASSLIST, 'http.request.headers.')
  }
}

function resolveHTTPResponse (context) {
  if (!context) return {}

  const headers = context.resolve(addresses.HTTP_INCOMING_RESPONSE_HEADERS)

  return {
    endpoint: context.resolve(addresses.HTTP_INCOMING_ENDPOINT),
    headers: filterHeaders(headers, RESPONSE_HEADERS_PASSLIST, 'http.response.headers.')
  }
}

function filterHeaders (headers, passlist, prefix) {
  const result = {}

  if (!headers) return result

  for (let i = 0; i < passlist.length; ++i) {
    const headerName = passlist[i]

    if (headers[headerName]) {
      result[`${prefix}${formatHeaderName(headerName)}`] = headers[headerName] + ''
    }
  }

  return result
}

// TODO: this can be precomputed at start time
function formatHeaderName (name) {
  return name
    .trim()
    .slice(0, 200)
    .replace(/[^a-zA-Z0-9_\-:/]/g, '_')
    .toLowerCase()
}

function reportAttack (attackData, store) {
  const req = store && store.get('req')
  const topSpan = web.root(req)
  if (!topSpan) return false

  const currentTags = topSpan.context()._tags

  const newTags = {
    'appsec.event': 'true'
  }

  if (limiter.isAllowed()) {
    newTags['manual.keep'] = 'true' // TODO: figure out how to keep appsec traces with sampling revamp
  }

  // TODO: maybe add this to format.js later (to take decision as late as possible)
  if (!currentTags['_dd.origin']) {
    newTags['_dd.origin'] = 'appsec'
  }

  const currentJson = currentTags['_dd.appsec.json']

  // merge JSON arrays without parsing them
  if (currentJson) {
    newTags['_dd.appsec.json'] = currentJson.slice(0, -2) + ',' + attackData.slice(1, -1) + currentJson.slice(-2)
  } else {
    newTags['_dd.appsec.json'] = '{"triggers":' + attackData + '}'
  }

  const context = store.get('context')

  if (context) {
    const resolvedRequest = resolveHTTPRequest(context)

    Object.assign(newTags, resolvedRequest.headers)

    const ua = resolvedRequest.headers['http.request.headers.user-agent']
    if (ua) {
      newTags['http.useragent'] = ua
    }

    newTags['network.client.ip'] = resolvedRequest.remote_ip
  }

  topSpan.addTags(newTags)
}

function finishAttacks (req, context) {
  const topSpan = web.root(req)
  if (!topSpan || !context) return false

  const resolvedResponse = resolveHTTPResponse(context)

  const newTags = resolvedResponse.headers

  if (resolvedResponse.endpoint) {
    newTags['http.endpoint'] = resolvedResponse.endpoint
  }

  topSpan.addTags(newTags)
}

function setRateLimit (rateLimit) {
  limiter = new Limiter(rateLimit)
}

module.exports = {
  resolveHTTPRequest,
  resolveHTTPResponse,
  filterHeaders,
  formatHeaderName,
  reportAttack,
  finishAttacks,
  setRateLimit
}


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/appsec/rule_manager.js":
/*!*************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/appsec/rule_manager.js ***!
  \*************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const callbacks = __webpack_require__(/*! ./callbacks */ "../../node_modules/dd-trace/packages/dd-trace/src/appsec/callbacks/index.js")

const appliedCallbacks = new Map()

function applyRules (rules) {
  if (appliedCallbacks.has(rules)) return

  // for now there is only WAF
  const callback = new callbacks.DDWAF(rules)

  appliedCallbacks.set(rules, callback)
}

function clearAllRules () {
  for (const [key, callback] of appliedCallbacks) {
    callback.clear()

    appliedCallbacks.delete(key)
  }
}

module.exports = {
  applyRules,
  clearAllRules
}


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/ci-visibility/exporters/agentless/index.js":
/*!*********************************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/ci-visibility/exporters/agentless/index.js ***!
  \*********************************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const URL = __webpack_require__(/*! url */ "url").URL
const Writer = __webpack_require__(/*! ./writer */ "../../node_modules/dd-trace/packages/dd-trace/src/ci-visibility/exporters/agentless/writer.js")
const Scheduler = __webpack_require__(/*! ../../../exporters/scheduler */ "../../node_modules/dd-trace/packages/dd-trace/src/exporters/scheduler.js")

class AgentlessCiVisibilityExporter {
  constructor (config) {
    const { flushInterval, tags, site, url } = config
    this._url = url || new URL(`https://citestcycle-intake.${site}`)
    this._writer = new Writer({ url: this._url, tags })

    if (flushInterval > 0) {
      this._scheduler = new Scheduler(() => this._writer.flush(), flushInterval)
    }
    this._scheduler && this._scheduler.start()
  }

  export (trace) {
    this._writer.append(trace)

    if (!this._scheduler) {
      this._writer.flush()
    }
  }

  flush () {
    this._writer.flush()
  }
}

module.exports = AgentlessCiVisibilityExporter


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/ci-visibility/exporters/agentless/writer.js":
/*!**********************************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/ci-visibility/exporters/agentless/writer.js ***!
  \**********************************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

const request = __webpack_require__(/*! ../../../exporters/common/request */ "../../node_modules/dd-trace/packages/dd-trace/src/exporters/common/request.js")
const log = __webpack_require__(/*! ../../../log */ "../../node_modules/dd-trace/packages/dd-trace/src/log.js")

const { AgentlessCiVisibilityEncoder } = __webpack_require__(/*! ../../../encode/agentless-ci-visibility */ "../../node_modules/dd-trace/packages/dd-trace/src/encode/agentless-ci-visibility.js")
const BaseWriter = __webpack_require__(/*! ../../../exporters/common/writer */ "../../node_modules/dd-trace/packages/dd-trace/src/exporters/common/writer.js")

class Writer extends BaseWriter {
  constructor ({ url, tags }) {
    super(...arguments)
    const { 'runtime-id': runtimeId, env, service } = tags
    this._url = url
    this._encoder = new AgentlessCiVisibilityEncoder({ runtimeId, env, service })
  }

  _sendPayload (data, _, done) {
    makeRequest(data, this._url, (err, res) => {
      if (err) {
        log.error(err)
        done()
        return
      }
      log.debug(`Response from the intake: ${res}`)
      done()
    })
  }
}

function makeRequest (data, url, cb) {
  const options = {
    path: '/api/v2/citestcycle',
    method: 'POST',
    headers: {
      'Content-Type': 'application/msgpack',
      'dd-api-key': process.env.DATADOG_API_KEY || process.env.DD_API_KEY
    },
    timeout: 15000
  }

  options.protocol = url.protocol
  options.hostname = url.hostname
  options.port = url.port

  log.debug(() => `Request to the intake: ${JSON.stringify(options)}`)

  request(data, options, false, (err, res) => {
    cb(err, res)
  })
}

module.exports = Writer


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/config.js":
/*!************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/config.js ***!
  \************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const fs = __webpack_require__(/*! fs */ "fs")
const os = __webpack_require__(/*! os */ "os")
const URL = __webpack_require__(/*! url */ "url").URL
const path = __webpack_require__(/*! path */ "path")
const pkg = __webpack_require__(/*! ./pkg */ "../../node_modules/dd-trace/packages/dd-trace/src/pkg.js")
const coalesce = __webpack_require__(/*! koalas */ "../../node_modules/koalas/index.js")
const tagger = __webpack_require__(/*! ./tagger */ "../../node_modules/dd-trace/packages/dd-trace/src/tagger.js")
const { isTrue, isFalse } = __webpack_require__(/*! ./util */ "../../node_modules/dd-trace/packages/dd-trace/src/util.js")
const uuid = __webpack_require__(/*! crypto-randomuuid */ "../../node_modules/crypto-randomuuid/index.js")

const fromEntries = Object.fromEntries || (entries =>
  entries.reduce((obj, [k, v]) => Object.assign(obj, { [k]: v }), {}))

class Config {
  constructor (options) {
    options = options || {}

    this.tags = {}

    tagger.add(this.tags, process.env.DD_TAGS)
    tagger.add(this.tags, process.env.DD_TRACE_TAGS)
    tagger.add(this.tags, process.env.DD_TRACE_GLOBAL_TAGS)
    tagger.add(this.tags, options.tags)

    const DD_TRACING_ENABLED = coalesce(
      process.env.DD_TRACING_ENABLED,
      true
    )
    const DD_PROFILING_ENABLED = coalesce(
      options.profiling, // TODO: remove when enabled by default
      process.env.DD_EXPERIMENTAL_PROFILING_ENABLED,
      process.env.DD_PROFILING_ENABLED,
      false
    )
    const DD_PROFILING_EXPORTERS = coalesce(
      process.env.DD_PROFILING_EXPORTERS,
      'agent'
    )
    const DD_PROFILING_SOURCE_MAP = process.env.DD_PROFILING_SOURCE_MAP
    const DD_LOGS_INJECTION = coalesce(
      options.logInjection,
      process.env.DD_LOGS_INJECTION,
      false
    )
    const DD_RUNTIME_METRICS_ENABLED = coalesce(
      options.runtimeMetrics, // TODO: remove when enabled by default
      process.env.DD_RUNTIME_METRICS_ENABLED,
      false
    )
    const DD_AGENT_HOST = coalesce(
      options.hostname,
      process.env.DD_AGENT_HOST,
      process.env.DD_TRACE_AGENT_HOSTNAME,
      '127.0.0.1'
    )
    const DD_TRACE_AGENT_PORT = coalesce(
      options.port,
      process.env.DD_TRACE_AGENT_PORT,
      '8126'
    )
    const DD_TRACE_AGENT_URL = coalesce(
      options.url,
      process.env.DD_TRACE_AGENT_URL,
      process.env.DD_TRACE_URL,
      null
    )
    const DD_CIVISIBILITY_AGENTLESS_URL = process.env.DD_CIVISIBILITY_AGENTLESS_URL
    const DD_SERVICE = options.service ||
      process.env.DD_SERVICE ||
      process.env.DD_SERVICE_NAME ||
      this.tags.service ||
      process.env.AWS_LAMBDA_FUNCTION_NAME ||
      pkg.name ||
      'node'
    const DD_SERVICE_MAPPING = process.env.DD_SERVICE_MAPPING || ''
    const DD_ENV = coalesce(
      options.env,
      process.env.DD_ENV,
      this.tags.env
    )
    const DD_VERSION = coalesce(
      options.version,
      process.env.DD_VERSION,
      this.tags.version,
      pkg.version
    )
    const DD_TRACE_STARTUP_LOGS = coalesce(
      options.startupLogs,
      process.env.DD_TRACE_STARTUP_LOGS,
      false
    )
    const DD_TRACE_TELEMETRY_ENABLED = coalesce(
      process.env.DD_TRACE_TELEMETRY_ENABLED,
      true
    )
    const DD_TRACE_DEBUG = coalesce(
      process.env.DD_TRACE_DEBUG,
      false
    )
    const DD_TRACE_AGENT_PROTOCOL_VERSION = coalesce(
      options.protocolVersion,
      process.env.DD_TRACE_AGENT_PROTOCOL_VERSION,
      '0.4'
    )
    const DD_TRACE_PARTIAL_FLUSH_MIN_SPANS = coalesce(
      parseInt(options.flushMinSpans),
      parseInt(process.env.DD_TRACE_PARTIAL_FLUSH_MIN_SPANS),
      1000
    )
    const DD_TRACE_B3_ENABLED = coalesce(
      options.experimental && options.experimental.b3,
      process.env.DD_TRACE_EXPERIMENTAL_B3_ENABLED,
      false
    )
    const DD_TRACE_TRACEPARENT_ENABLED = coalesce(
      options.experimental && options.experimental.traceparent,
      process.env.DD_TRACE_EXPERIMENTAL_TRACEPARENT_ENABLED,
      false
    )
    const DD_TRACE_RUNTIME_ID_ENABLED = coalesce(
      options.experimental && options.experimental.runtimeId,
      process.env.DD_TRACE_EXPERIMENTAL_RUNTIME_ID_ENABLED,
      false
    )
    const DD_TRACE_EXPORTER = coalesce(
      options.experimental && options.experimental.exporter,
      process.env.DD_TRACE_EXPERIMENTAL_EXPORTER
    )
    const DD_TRACE_GET_RUM_DATA_ENABLED = coalesce(
      options.experimental && options.experimental.enableGetRumData,
      process.env.DD_TRACE_EXPERIMENTAL_GET_RUM_DATA_ENABLED,
      false
    )

    let appsec = options.appsec || (options.experimental && options.experimental.appsec)

    const DD_APPSEC_ENABLED = coalesce(
      appsec && (appsec === true || appsec.enabled === true), // TODO: remove when enabled by default
      process.env.DD_APPSEC_ENABLED,
      false
    )

    appsec = appsec || {}

    const DD_APPSEC_RULES = coalesce(
      appsec.rules,
      process.env.DD_APPSEC_RULES,
      path.join(__dirname, 'appsec', 'recommended.json')
    )
    const DD_APPSEC_TRACE_RATE_LIMIT = coalesce(
      appsec.rateLimit,
      process.env.DD_APPSEC_TRACE_RATE_LIMIT,
      100
    )

    const sampler = (options.experimental && options.experimental.sampler) || {}
    const ingestion = options.ingestion || {}
    const dogstatsd = coalesce(options.dogstatsd, {})

    Object.assign(sampler, {
      sampleRate: coalesce(
        options.sampleRate,
        ingestion.sampleRate,
        sampler.sampleRate,
        process.env.DD_TRACE_SAMPLE_RATE
      ),
      rateLimit: coalesce(ingestion.rateLimit, sampler.rateLimit, process.env.DD_TRACE_RATE_LIMIT)
    })

    const inAWSLambda = process.env.AWS_LAMBDA_FUNCTION_NAME !== undefined
    const defaultFlushInterval = inAWSLambda ? 0 : 2000

    this.tracing = !isFalse(DD_TRACING_ENABLED)
    this.debug = isTrue(DD_TRACE_DEBUG)
    this.logInjection = isTrue(DD_LOGS_INJECTION)
    this.env = DD_ENV
    this.url = DD_CIVISIBILITY_AGENTLESS_URL ? new URL(DD_CIVISIBILITY_AGENTLESS_URL)
      : getAgentUrl(DD_TRACE_AGENT_URL, options)
    this.site = coalesce(options.site, process.env.DD_SITE, 'datadoghq.com')
    this.hostname = DD_AGENT_HOST || (this.url && this.url.hostname)
    this.port = String(DD_TRACE_AGENT_PORT || (this.url && this.url.port))
    this.flushInterval = coalesce(parseInt(options.flushInterval, 10), defaultFlushInterval)
    this.flushMinSpans = DD_TRACE_PARTIAL_FLUSH_MIN_SPANS
    this.sampleRate = coalesce(Math.min(Math.max(sampler.sampleRate, 0), 1), 1)
    this.logger = options.logger
    this.plugins = !!coalesce(options.plugins, true)
    this.service = DD_SERVICE
    this.serviceMapping = DD_SERVICE_MAPPING.length ? fromEntries(
      DD_SERVICE_MAPPING.split(',').map(x => x.trim().split(':'))
    ) : {}
    this.version = DD_VERSION
    this.dogstatsd = {
      hostname: coalesce(dogstatsd.hostname, process.env.DD_DOGSTATSD_HOSTNAME, this.hostname),
      port: String(coalesce(dogstatsd.port, process.env.DD_DOGSTATSD_PORT, 8125))
    }
    this.runtimeMetrics = isTrue(DD_RUNTIME_METRICS_ENABLED)
    this.experimental = {
      b3: isTrue(DD_TRACE_B3_ENABLED),
      traceparent: isTrue(DD_TRACE_TRACEPARENT_ENABLED),
      runtimeId: isTrue(DD_TRACE_RUNTIME_ID_ENABLED),
      exporter: DD_TRACE_EXPORTER,
      enableGetRumData: isTrue(DD_TRACE_GET_RUM_DATA_ENABLED),
      sampler
    }
    this.reportHostname = isTrue(coalesce(options.reportHostname, process.env.DD_TRACE_REPORT_HOSTNAME, false))
    this.scope = process.env.DD_TRACE_SCOPE
    this.logLevel = coalesce(
      options.logLevel,
      process.env.DD_TRACE_LOG_LEVEL,
      'debug'
    )
    this.profiling = {
      enabled: isTrue(DD_PROFILING_ENABLED),
      sourceMap: !isFalse(DD_PROFILING_SOURCE_MAP),
      exporters: DD_PROFILING_EXPORTERS
    }
    this.lookup = options.lookup
    this.startupLogs = isTrue(DD_TRACE_STARTUP_LOGS)
    this.telemetryEnabled = isTrue(DD_TRACE_TELEMETRY_ENABLED)
    this.protocolVersion = DD_TRACE_AGENT_PROTOCOL_VERSION
    this.appsec = {
      enabled: isTrue(DD_APPSEC_ENABLED),
      rules: DD_APPSEC_RULES,
      rateLimit: DD_APPSEC_TRACE_RATE_LIMIT
    }

    tagger.add(this.tags, {
      service: this.service,
      env: this.env,
      version: this.version,
      'runtime-id': uuid()
    })
  }
}

function getAgentUrl (url, options) {
  if (url) return new URL(url)

  if (os.type() === 'Windows_NT') return

  if (
    !options.hostname &&
    !options.port &&
    !process.env.DD_AGENT_HOST &&
    !process.env.DD_TRACE_AGENT_HOSTNAME &&
    !process.env.DD_TRACE_AGENT_PORT &&
    fs.existsSync('/var/run/datadog/apm.socket')
  ) {
    return new URL('unix:///var/run/datadog/apm.socket')
  }
}

module.exports = Config


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/constants.js":
/*!***************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/constants.js ***!
  \***************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = {
  SAMPLING_PRIORITY_KEY: '_sampling_priority_v1',
  ANALYTICS_KEY: '_dd1.sr.eausr',
  ORIGIN_KEY: '_dd.origin',
  HOSTNAME_KEY: '_dd.hostname',
  SAMPLING_RULE_DECISION: '_dd.rule_psr',
  SAMPLING_LIMIT_DECISION: '_dd.limit_psr',
  SAMPLING_AGENT_DECISION: '_dd.agent_psr',
  DATADOG_LAMBDA_EXTENSION_PATH: '/opt/extensions/datadog-agent'
}


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/dogstatsd.js":
/*!***************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/dogstatsd.js ***!
  \***************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const lookup = __webpack_require__(/*! dns */ "dns").lookup // cache to avoid instrumentation
const dgram = __webpack_require__(/*! dgram */ "dgram")
const isIP = __webpack_require__(/*! net */ "net").isIP
const log = __webpack_require__(/*! ./log */ "../../node_modules/dd-trace/packages/dd-trace/src/log.js")

const MAX_BUFFER_SIZE = 1024 // limit from the agent

class Client {
  constructor (options) {
    options = options || {}

    this._host = options.host || 'localhost'
    this._family = isIP(this._host)
    this._port = options.port || 8125
    this._prefix = options.prefix || ''
    this._tags = options.tags || []
    this._queue = []
    this._buffer = ''
    this._offset = 0
    this._udp4 = this._socket('udp4')
    this._udp6 = this._socket('udp6')
  }

  gauge (stat, value, tags) {
    this._add(stat, value, 'g', tags)
  }

  increment (stat, value, tags) {
    this._add(stat, value, 'c', tags)
  }

  flush () {
    const queue = this._enqueue()

    if (this._queue.length === 0) return

    this._queue = []

    if (this._family !== 0) {
      this._sendAll(queue, this._host, this._family)
    } else {
      lookup(this._host, (err, address, family) => {
        if (err) return log.error(err)
        this._sendAll(queue, address, family)
      })
    }
  }

  _send (address, family, buffer) {
    const socket = family === 6 ? this._udp6 : this._udp4

    log.debug(`Sending to DogStatsD: ${buffer}`)

    socket.send(buffer, 0, buffer.length, this._port, address)
  }

  _sendAll (queue, address, family) {
    queue.forEach((buffer) => this._send(address, family, buffer))
  }

  _add (stat, value, type, tags) {
    const message = `${this._prefix + stat}:${value}|${type}`

    tags = tags ? this._tags.concat(tags) : this._tags

    if (tags.length > 0) {
      this._write(`${message}|#${tags.join(',')}\n`)
    } else {
      this._write(`${message}\n`)
    }
  }

  _write (message) {
    const offset = Buffer.byteLength(message)

    if (this._offset + offset > MAX_BUFFER_SIZE) {
      this._enqueue()
    }

    this._offset += offset
    this._buffer += message
  }

  _enqueue () {
    if (this._offset > 0) {
      this._queue.push(Buffer.from(this._buffer))
      this._buffer = ''
      this._offset = 0
    }

    return this._queue
  }

  _socket (type) {
    const socket = dgram.createSocket(type)

    socket.on('error', () => {})
    socket.unref()

    return socket
  }
}

module.exports = Client


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/encode/0.4.js":
/*!****************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/encode/0.4.js ***!
  \****************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Chunk = __webpack_require__(/*! ./chunk */ "../../node_modules/dd-trace/packages/dd-trace/src/encode/chunk.js")
const log = __webpack_require__(/*! ../log */ "../../node_modules/dd-trace/packages/dd-trace/src/log.js")

const SOFT_LIMIT = 8 * 1024 * 1024 // 8MB

const float64Array = new Float64Array(1)
const uInt8Float64Array = new Uint8Array(float64Array.buffer)

float64Array[0] = -1

const bigEndian = uInt8Float64Array[7] === 0

class AgentEncoder {
  constructor (writer) {
    this._traceBytes = new Chunk()
    this._stringBytes = new Chunk()
    this._writer = writer
    this._reset()
  }

  count () {
    return this._traceCount
  }

  encode (trace) {
    const bytes = this._traceBytes
    const start = bytes.length

    this._traceCount++

    this._encode(bytes, trace)

    const end = bytes.length

    log.debug(() => {
      const hex = bytes.buffer.subarray(start, end).toString('hex').match(/../g).join(' ')

      return `Adding encoded trace to buffer: ${hex}`
    })

    // we can go over the soft limit since the agent has a 50MB hard limit
    if (this._traceBytes.length > SOFT_LIMIT || this._stringBytes.length > SOFT_LIMIT) {
      this._writer.flush()
    }
  }

  makePayload () {
    const traceSize = this._traceBytes.length + 5
    const buffer = Buffer.allocUnsafe(traceSize)

    this._writeTraces(buffer)

    this._reset()

    return buffer
  }

  _encode (bytes, trace) {
    this._encodeArrayPrefix(bytes, trace)

    for (const span of trace) {
      bytes.reserve(1)

      if (span.type) {
        bytes.buffer[bytes.length++] = 0x8c

        this._encodeString(bytes, 'type')
        this._encodeString(bytes, span.type)
      } else {
        bytes.buffer[bytes.length++] = 0x8b
      }

      this._encodeString(bytes, 'trace_id')
      this._encodeId(bytes, span.trace_id)
      this._encodeString(bytes, 'span_id')
      this._encodeId(bytes, span.span_id)
      this._encodeString(bytes, 'parent_id')
      this._encodeId(bytes, span.parent_id)
      this._encodeString(bytes, 'name')
      this._encodeString(bytes, span.name)
      this._encodeString(bytes, 'resource')
      this._encodeString(bytes, span.resource)
      this._encodeString(bytes, 'service')
      this._encodeString(bytes, span.service)
      this._encodeString(bytes, 'error')
      this._encodeInteger(bytes, span.error)
      this._encodeString(bytes, 'start')
      this._encodeLong(bytes, span.start)
      this._encodeString(bytes, 'duration')
      this._encodeLong(bytes, span.duration)
      this._encodeString(bytes, 'meta')
      this._encodeMap(bytes, span.meta)
      this._encodeString(bytes, 'metrics')
      this._encodeMap(bytes, span.metrics)
    }
  }

  _reset () {
    this._traceCount = 0
    this._traceBytes.length = 0
    this._stringCount = 0
    this._stringBytes.length = 0
    this._stringMap = {}

    this._cacheString('')
  }

  _encodeArrayPrefix (bytes, value) {
    const length = value.length
    const buffer = bytes.buffer
    const offset = bytes.length

    bytes.reserve(5)
    bytes.length += 5

    buffer[offset] = 0xdd
    buffer[offset + 1] = length >> 24
    buffer[offset + 2] = length >> 16
    buffer[offset + 3] = length >> 8
    buffer[offset + 4] = length
  }

  _encodeByte (bytes, value) {
    const buffer = bytes.buffer

    bytes.reserve(1)

    buffer[bytes.length++] = value
  }

  _encodeId (bytes, id) {
    const buffer = bytes.buffer
    const offset = bytes.length

    bytes.reserve(9)
    bytes.length += 9

    id = id.toArray()

    buffer[offset] = 0xcf
    buffer[offset + 1] = id[0]
    buffer[offset + 2] = id[1]
    buffer[offset + 3] = id[2]
    buffer[offset + 4] = id[3]
    buffer[offset + 5] = id[4]
    buffer[offset + 6] = id[5]
    buffer[offset + 7] = id[6]
    buffer[offset + 8] = id[7]
  }

  _encodeInteger (bytes, value) {
    const buffer = bytes.buffer
    const offset = bytes.length

    bytes.reserve(5)
    bytes.length += 5

    buffer[offset] = 0xce
    buffer[offset + 1] = value >> 24
    buffer[offset + 2] = value >> 16
    buffer[offset + 3] = value >> 8
    buffer[offset + 4] = value
  }

  _encodeLong (bytes, value) {
    const buffer = bytes.buffer
    const offset = bytes.length
    const hi = (value / Math.pow(2, 32)) >> 0
    const lo = value >>> 0

    bytes.reserve(9)
    bytes.length += 9

    buffer[offset] = 0xcf
    buffer[offset + 1] = hi >> 24
    buffer[offset + 2] = hi >> 16
    buffer[offset + 3] = hi >> 8
    buffer[offset + 4] = hi
    buffer[offset + 5] = lo >> 24
    buffer[offset + 6] = lo >> 16
    buffer[offset + 7] = lo >> 8
    buffer[offset + 8] = lo
  }

  _encodeMap (bytes, value) {
    const keys = Object.keys(value)
    const buffer = bytes.buffer
    const offset = bytes.length

    bytes.reserve(5)
    bytes.length += 5

    let length = 0

    for (const key of keys) {
      if (typeof value[key] !== 'string' && typeof value[key] !== 'number') return
      length++

      this._encodeString(bytes, key)
      this._encodeValue(bytes, value[key])
    }

    buffer[offset] = 0xdf
    buffer[offset + 1] = length >> 24
    buffer[offset + 2] = length >> 16
    buffer[offset + 3] = length >> 8
    buffer[offset + 4] = length
  }

  _encodeValue (bytes, value) {
    switch (typeof value) {
      case 'string':
        this._encodeString(bytes, value)
        break
      case 'number':
        this._encodeFloat(bytes, value)
        break
      default:
        // should not happen
    }
  }

  _encodeString (bytes, value = '') {
    this._cacheString(value)

    const { start, end } = this._stringMap[value]

    this._stringBytes.copy(bytes, start, end)
  }

  _encodeFloat (bytes, value) {
    float64Array[0] = value

    const buffer = bytes.buffer
    const offset = bytes.length

    bytes.reserve(9)
    bytes.length += 9

    buffer[offset] = 0xcb

    if (bigEndian) {
      for (let i = 0; i <= 7; i++) {
        buffer[offset + i + 1] = uInt8Float64Array[i]
      }
    } else {
      for (let i = 7; i >= 0; i--) {
        buffer[bytes.length - i - 1] = uInt8Float64Array[i]
      }
    }
  }

  _cacheString (value) {
    if (!(value in this._stringMap)) {
      this._stringCount++
      this._stringMap[value] = {
        start: this._stringBytes.length,
        end: this._stringBytes.length + this._stringBytes.write(value)
      }
    }
  }

  _writeArrayPrefix (buffer, offset, count) {
    buffer[offset++] = 0xdd
    buffer.writeUInt32BE(count, offset)

    return offset + 4
  }

  _writeTraces (buffer, offset = 0) {
    offset = this._writeArrayPrefix(buffer, offset, this._traceCount)
    offset += this._traceBytes.buffer.copy(buffer, offset, 0, this._traceBytes.length)

    return offset
  }
}

module.exports = { AgentEncoder }


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/encode/0.5.js":
/*!****************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/encode/0.5.js ***!
  \****************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const { AgentEncoder: BaseEncoder } = __webpack_require__(/*! ./0.4 */ "../../node_modules/dd-trace/packages/dd-trace/src/encode/0.4.js")

const ARRAY_OF_TWO = 0x92
const ARRAY_OF_TWELVE = 0x9c

class AgentEncoder extends BaseEncoder {
  makePayload () {
    const prefixSize = 1
    const stringSize = this._stringBytes.length + 5
    const traceSize = this._traceBytes.length + 5
    const buffer = Buffer.allocUnsafe(prefixSize + stringSize + traceSize)

    let offset = 0

    buffer[offset++] = ARRAY_OF_TWO

    offset = this._writeStrings(buffer, offset)
    offset = this._writeTraces(buffer, offset)

    this._reset()

    return buffer
  }

  _encode (bytes, trace) {
    this._encodeArrayPrefix(bytes, trace)

    for (const span of trace) {
      this._encodeByte(bytes, ARRAY_OF_TWELVE)
      this._encodeString(bytes, span.service)
      this._encodeString(bytes, span.name)
      this._encodeString(bytes, span.resource)
      this._encodeId(bytes, span.trace_id)
      this._encodeId(bytes, span.span_id)
      this._encodeId(bytes, span.parent_id)
      this._encodeLong(bytes, span.start || 0)
      this._encodeLong(bytes, span.duration || 0)
      this._encodeInteger(bytes, span.error)
      this._encodeMap(bytes, span.meta || {})
      this._encodeMap(bytes, span.metrics || {})
      this._encodeString(bytes, span.type)
    }
  }

  _encodeString (bytes, value = '') {
    this._cacheString(value)
    this._encodeInteger(bytes, this._stringMap[value])
  }

  _cacheString (value) {
    if (!(value in this._stringMap)) {
      this._stringMap[value] = this._stringCount++
      this._stringBytes.write(value)
    }
  }

  _writeStrings (buffer, offset) {
    offset = this._writeArrayPrefix(buffer, offset, this._stringCount)
    offset += this._stringBytes.buffer.copy(buffer, offset, 0, this._stringBytes.length)

    return offset
  }
}

module.exports = { AgentEncoder }


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/encode/agentless-ci-visibility.js":
/*!************************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/encode/agentless-ci-visibility.js ***!
  \************************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

const { truncateSpan, normalizeSpan } = __webpack_require__(/*! ./tags-processors */ "../../node_modules/dd-trace/packages/dd-trace/src/encode/tags-processors.js")
const Chunk = __webpack_require__(/*! ./chunk */ "../../node_modules/dd-trace/packages/dd-trace/src/encode/chunk.js")
const { AgentEncoder } = __webpack_require__(/*! ./0.4 */ "../../node_modules/dd-trace/packages/dd-trace/src/encode/0.4.js")

const ENCODING_VERSION = 1

function formatSpan (span) {
  return {
    type: span.type === 'test' ? 'test' : 'span',
    version: ENCODING_VERSION,
    content: normalizeSpan(truncateSpan(span))
  }
}

class AgentlessCiVisibilityEncoder extends AgentEncoder {
  constructor ({ runtimeId, service, env }) {
    super(...arguments)
    this._events = []
    this.runtimeId = runtimeId
    this.service = service
    this.env = env
    this._traceBytes = new Chunk()
    this._stringBytes = new Chunk()
    this._stringCount = 0
    this._stringMap = {}

    // Used to keep track of the number of encoded events to update the
    // length of `payload.events` when calling `makePayload`
    this._eventCount = 0

    this.reset()
  }

  _encodeEventContent (bytes, content) {
    this._encodeMapPrefix(bytes, content)
    if (content.type) {
      this._encodeString(bytes, 'type')
      this._encodeString(bytes, content.type)
    }
    this._encodeString(bytes, 'trace_id')
    this._encodeId(bytes, content.trace_id)
    this._encodeString(bytes, 'span_id')
    this._encodeId(bytes, content.span_id)
    this._encodeString(bytes, 'parent_id')
    this._encodeId(bytes, content.parent_id)
    this._encodeString(bytes, 'name')
    this._encodeString(bytes, content.name)
    this._encodeString(bytes, 'resource')
    this._encodeString(bytes, content.resource)
    this._encodeString(bytes, 'service')
    this._encodeString(bytes, content.service)
    this._encodeString(bytes, 'error')
    this._encodeNumber(bytes, content.error)
    this._encodeString(bytes, 'start')
    this._encodeNumber(bytes, content.start)
    this._encodeString(bytes, 'duration')
    this._encodeNumber(bytes, content.duration)
    this._encodeString(bytes, 'meta')
    this._encodeMap(bytes, content.meta)
    this._encodeString(bytes, 'metrics')
    this._encodeMap(bytes, content.metrics)
  }

  _encodeEvent (bytes, event) {
    this._encodeMapPrefix(bytes, event)
    this._encodeString(bytes, 'type')
    this._encodeString(bytes, event.type)

    this._encodeString(bytes, 'version')
    this._encodeNumber(bytes, event.version)

    this._encodeString(bytes, 'content')
    this._encodeEventContent(bytes, event.content)
  }

  _encodeNumber (bytes, value) {
    if (Math.floor(value) !== value) { // float 64
      return this._encodeFloat(bytes, value)
    }
    return this._encodeLong(bytes, value)
  }

  _encodeLong (bytes, value) {
    const isPositive = value >= 0

    const hi = isPositive ? (value / Math.pow(2, 32)) >> 0 : Math.floor(value / Math.pow(2, 32))
    const lo = value >>> 0
    const flag = isPositive ? 0xcf : 0xd3

    const buffer = bytes.buffer
    const offset = bytes.length

    // int 64
    bytes.reserve(9)
    bytes.length += 9

    buffer[offset] = flag
    buffer[offset + 1] = hi >> 24
    buffer[offset + 2] = hi >> 16
    buffer[offset + 3] = hi >> 8
    buffer[offset + 4] = hi
    buffer[offset + 5] = lo >> 24
    buffer[offset + 6] = lo >> 16
    buffer[offset + 7] = lo >> 8
    buffer[offset + 8] = lo
  }

  _encodeMapPrefix (bytes, map) {
    const keys = Object.keys(map)
    const buffer = bytes.buffer
    const offset = bytes.length

    bytes.reserve(5)
    bytes.length += 5
    buffer[offset] = 0xdf
    buffer[offset + 1] = keys.length >> 24
    buffer[offset + 2] = keys.length >> 16
    buffer[offset + 3] = keys.length >> 8
    buffer[offset + 4] = keys.length
  }

  _encode (bytes, trace) {
    this._eventCount += trace.length
    const events = trace.map(formatSpan)

    for (const event of events) {
      this._encodeEvent(bytes, event)
    }
  }

  makePayload () {
    const bytes = this._traceBytes
    const eventsOffset = this._eventsOffset
    const eventsCount = this._eventCount

    bytes.buffer[eventsOffset] = 0xdd
    bytes.buffer[eventsOffset + 1] = eventsCount >> 24
    bytes.buffer[eventsOffset + 2] = eventsCount >> 16
    bytes.buffer[eventsOffset + 3] = eventsCount >> 8
    bytes.buffer[eventsOffset + 4] = eventsCount

    const traceSize = bytes.length
    const buffer = Buffer.allocUnsafe(traceSize)

    bytes.buffer.copy(buffer, 0, 0, bytes.length)

    this.reset()

    return buffer
  }

  _encodePayloadStart (bytes) {
    // encodes the payload up to `events`. `events` will be encoded via _encode
    const payload = {
      version: ENCODING_VERSION,
      metadata: {
        '*': {
          'language': 'javascript'
        }
      },
      events: []
    }

    if (this.env) {
      payload.metadata['*'].env = this.env
    }
    if (this.runtimeId) {
      payload.metadata['*']['runtime-id'] = this.runtimeId
    }

    this._encodeMapPrefix(bytes, payload)
    this._encodeString(bytes, 'version')
    this._encodeNumber(bytes, payload.version)
    this._encodeString(bytes, 'metadata')
    this._encodeMapPrefix(bytes, payload.metadata)
    this._encodeString(bytes, '*')
    this._encodeMap(bytes, payload.metadata['*'])
    this._encodeString(bytes, 'events')
    // Get offset of the events list to update the length of the array when calling `makePayload`
    this._eventsOffset = bytes.length
    bytes.reserve(5)
    bytes.length += 5
  }

  reset () {
    this._reset()
    this._eventCount = 0
    this._encodePayloadStart(this._traceBytes)
  }
}

module.exports = { AgentlessCiVisibilityEncoder }


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/encode/chunk.js":
/*!******************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/encode/chunk.js ***!
  \******************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const DEFAULT_MIN_SIZE = 2 * 1024 * 1024 // 2MB

/**
 * Represents a chunk of a Msgpack payload. Exposes a subset of Array and Buffer
 * interfaces so that it can be used seamlessly by any encoder code that expects
 * either.
 */
class Chunk {
  constructor (minSize = DEFAULT_MIN_SIZE) {
    this.buffer = Buffer.allocUnsafe(minSize)
    this.length = 0
    this._minSize = minSize
  }

  write (value) {
    const length = Buffer.byteLength(value)
    const offset = this.length

    if (length < 0x20) { // fixstr
      this.reserve(length + 1)
      this.length += 1
      this.buffer[offset] = length | 0xa0
    } else if (length < 0x100000000) { // str 32
      this.reserve(length + 5)
      this.length += 5
      this.buffer[offset] = 0xdb
      this.buffer[offset + 1] = length >> 24
      this.buffer[offset + 2] = length >> 16
      this.buffer[offset + 3] = length >> 8
      this.buffer[offset + 4] = length
    }

    this.length += this.buffer.utf8Write(value, this.length, length)

    return this.length - offset
  }

  copy (target, sourceStart, sourceEnd) {
    target.set(new Uint8Array(this.buffer.buffer, sourceStart, sourceEnd - sourceStart))
  }

  set (array) {
    this.reserve(array.length)

    this.buffer.set(array, this.length)
    this.length += array.length
  }

  reserve (size) {
    if (this.length + size > this.buffer.length) {
      this._resize(this._minSize * Math.ceil((this.length + size) / this._minSize))
    }
  }

  _resize (size) {
    const oldBuffer = this.buffer

    this.buffer = Buffer.allocUnsafe(size)

    oldBuffer.copy(this.buffer, 0, 0, this.length)
  }
}

module.exports = Chunk


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/encode/tags-processors.js":
/*!****************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/encode/tags-processors.js ***!
  \****************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports) {

// From agent truncators: https://github.com/DataDog/datadog-agent/blob/main/pkg/trace/agent/truncator.go

// Values from: https://github.com/DataDog/datadog-agent/blob/main/pkg/trace/traceutil/truncate.go#L22-L27
// MAX_RESOURCE_NAME_LENGTH the maximum length a span resource can have
const MAX_RESOURCE_NAME_LENGTH = 5000
// MAX_META_KEY_LENGTH the maximum length of metadata key
const MAX_META_KEY_LENGTH = 200
// MAX_META_VALUE_LENGTH the maximum length of metadata value
const MAX_META_VALUE_LENGTH = 25000
// MAX_METRIC_KEY_LENGTH the maximum length of a metric name key
const MAX_METRIC_KEY_LENGTH = MAX_META_KEY_LENGTH
// MAX_METRIC_VALUE_LENGTH the maximum length of a metric name value
const MAX_METRIC_VALUE_LENGTH = MAX_META_VALUE_LENGTH

// From agent normalizer:
// https://github.com/DataDog/datadog-agent/blob/main/pkg/trace/traceutil/normalize.go
// DEFAULT_SPAN_NAME is the default name we assign a span if it's missing and we have no reasonable fallback
const DEFAULT_SPAN_NAME = 'unnamed_operation'
// DEFAULT_SERVICE_NAME is the default name we assign a service if it's missing and we have no reasonable fallback
const DEFAULT_SERVICE_NAME = 'unnamed-service'
// MAX_NAME_LENGTH the maximum length a name can have
const MAX_NAME_LENGTH = 100
// MAX_SERVICE_LENGTH the maximum length a service can have
const MAX_SERVICE_LENGTH = 100
// MAX_TYPE_LENGTH the maximum length a span type can have
const MAX_TYPE_LENGTH = 100

const fromEntries = Object.fromEntries || (entries =>
  entries.reduce((obj, [k, v]) => Object.assign(obj, { [k]: v }), {}))

function truncateToLength (value, maxLength) {
  if (!value) {
    return value
  }
  if (value.length > maxLength) {
    return `${value.slice(0, maxLength)}...`
  }
  return value
}

function truncateSpan (span) {
  return fromEntries(Object.entries(span).map(([key, value]) => {
    switch (key) {
      case 'resource':
        return ['resource', truncateToLength(value, MAX_RESOURCE_NAME_LENGTH)]
      case 'meta':
        return ['meta', fromEntries(Object.entries(value).map(([metaKey, metaValue]) =>
          [truncateToLength(metaKey, MAX_META_KEY_LENGTH), truncateToLength(metaValue, MAX_META_VALUE_LENGTH)]
        ))]
      case 'metrics':
        return ['metrics', fromEntries(Object.entries(value).map(([metricsKey, metricsValue]) =>
          [truncateToLength(metricsKey, MAX_METRIC_KEY_LENGTH), truncateToLength(metricsValue, MAX_METRIC_VALUE_LENGTH)]
        ))]
      default:
        return [key, value]
    }
  }))
}

function normalizeSpan (span) {
  const normalizedSpan = fromEntries(Object.entries(span).map(([key, value]) => {
    switch (key) {
      case 'service':
        if (!value) {
          return [key, DEFAULT_SERVICE_NAME]
        }
        if (value.length > MAX_SERVICE_LENGTH) {
          return [key, value.slice(0, MAX_SERVICE_LENGTH)]
        }
        break
      case 'name':
        if (!value) {
          return [key, DEFAULT_SPAN_NAME]
        }
        if (value.length > MAX_NAME_LENGTH) {
          return [key, value.slice(0, MAX_NAME_LENGTH)]
        }
        break
      case 'resource':
        if (!value) {
          return [key, span.name || DEFAULT_SPAN_NAME]
        }
        break
      case 'type':
        if (!value) {
          return [key, value]
        }
        if (value.length > MAX_TYPE_LENGTH) {
          return [key, value.slice(0, MAX_TYPE_LENGTH)]
        }
    }
    return [key, value]
  }))
  if (!normalizedSpan.service) {
    normalizedSpan.service = DEFAULT_SERVICE_NAME
  }
  if (!normalizedSpan.name) {
    normalizedSpan.name = DEFAULT_SPAN_NAME
  }
  return normalizedSpan
}

module.exports = {
  truncateSpan,
  normalizeSpan,
  MAX_META_KEY_LENGTH,
  MAX_META_VALUE_LENGTH,
  MAX_METRIC_KEY_LENGTH,
  MAX_METRIC_VALUE_LENGTH,
  MAX_NAME_LENGTH,
  MAX_SERVICE_LENGTH,
  MAX_TYPE_LENGTH,
  MAX_RESOURCE_NAME_LENGTH,
  DEFAULT_SPAN_NAME,
  DEFAULT_SERVICE_NAME
}


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/exporter.js":
/*!**************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/exporter.js ***!
  \**************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const AgentExporter = __webpack_require__(/*! ./exporters/agent */ "../../node_modules/dd-trace/packages/dd-trace/src/exporters/agent/index.js")
const LogExporter = __webpack_require__(/*! ./exporters/log */ "../../node_modules/dd-trace/packages/dd-trace/src/exporters/log/index.js")
const AgentlessCiVisibilityExporter = __webpack_require__(/*! ./ci-visibility/exporters/agentless */ "../../node_modules/dd-trace/packages/dd-trace/src/ci-visibility/exporters/agentless/index.js")
const exporters = __webpack_require__(/*! ../../../ext/exporters */ "../../node_modules/dd-trace/ext/exporters.js")
const fs = __webpack_require__(/*! fs */ "fs")
const constants = __webpack_require__(/*! ./constants */ "../../node_modules/dd-trace/packages/dd-trace/src/constants.js")

module.exports = name => {
  const inAWSLambda = process.env.AWS_LAMBDA_FUNCTION_NAME !== undefined
  const usingLambdaExtension = inAWSLambda && fs.existsSync(constants.DATADOG_LAMBDA_EXTENSION_PATH)

  switch (name) {
    case exporters.LOG:
      return LogExporter
    case exporters.AGENT:
      return AgentExporter
    case exporters.DATADOG:
      return AgentlessCiVisibilityExporter
    default:
      return inAWSLambda && !usingLambdaExtension ? LogExporter : AgentExporter
  }
}


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/exporters/agent/index.js":
/*!***************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/exporters/agent/index.js ***!
  \***************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const URL = __webpack_require__(/*! url */ "url").URL
const log = __webpack_require__(/*! ../../log */ "../../node_modules/dd-trace/packages/dd-trace/src/log.js")
const Writer = __webpack_require__(/*! ./writer */ "../../node_modules/dd-trace/packages/dd-trace/src/exporters/agent/writer.js")
const Scheduler = __webpack_require__(/*! ../scheduler */ "../../node_modules/dd-trace/packages/dd-trace/src/exporters/scheduler.js")

class AgentExporter {
  constructor ({ url, hostname, port, flushInterval, lookup, protocolVersion }, prioritySampler) {
    this._url = url || new URL(`http://${hostname || 'localhost'}:${port}`)
    this._writer = new Writer({ url: this._url, prioritySampler, lookup, protocolVersion })

    if (flushInterval > 0) {
      this._scheduler = new Scheduler(() => this._writer.flush(), flushInterval)
    }
    this._scheduler && this._scheduler.start()
  }

  setUrl (url) {
    try {
      url = new URL(url)
      this._url = url
      this._writer.setUrl(url)
    } catch (e) {
      log.warn(e.stack)
    }
  }

  export (spans) {
    this._writer.append(spans)

    if (!this._scheduler) {
      this._writer.flush()
    }
  }
}

module.exports = AgentExporter


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/exporters/agent/writer.js":
/*!****************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/exporters/agent/writer.js ***!
  \****************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const request = __webpack_require__(/*! ../common/request */ "../../node_modules/dd-trace/packages/dd-trace/src/exporters/common/request.js")
const { startupLog } = __webpack_require__(/*! ../../startup-log */ "../../node_modules/dd-trace/packages/dd-trace/src/startup-log.js")
const metrics = __webpack_require__(/*! ../../metrics */ "../../node_modules/dd-trace/packages/dd-trace/src/metrics.js")
const log = __webpack_require__(/*! ../../log */ "../../node_modules/dd-trace/packages/dd-trace/src/log.js")
const tracerVersion = __webpack_require__(/*! ../../../lib/version */ "../../node_modules/dd-trace/packages/dd-trace/lib/version.js")
const BaseWriter = __webpack_require__(/*! ../common/writer */ "../../node_modules/dd-trace/packages/dd-trace/src/exporters/common/writer.js")

const METRIC_PREFIX = 'datadog.tracer.node.exporter.agent'

class Writer extends BaseWriter {
  constructor ({ prioritySampler, lookup, protocolVersion }) {
    super(...arguments)
    const AgentEncoder = getEncoder(protocolVersion)

    this._prioritySampler = prioritySampler
    this._lookup = lookup
    this._protocolVersion = protocolVersion
    this._encoder = new AgentEncoder(this)
  }

  _sendPayload (data, count, done) {
    metrics.increment(`${METRIC_PREFIX}.requests`, true)

    makeRequest(this._protocolVersion, data, count, this._url, this._lookup, true, (err, res, status) => {
      if (status) {
        metrics.increment(`${METRIC_PREFIX}.responses`, true)
        metrics.increment(`${METRIC_PREFIX}.responses.by.status`, `status:${status}`, true)
      } else if (err) {
        metrics.increment(`${METRIC_PREFIX}.errors`, true)
        metrics.increment(`${METRIC_PREFIX}.errors.by.name`, `name:${err.name}`, true)

        if (err.code) {
          metrics.increment(`${METRIC_PREFIX}.errors.by.code`, `code:${err.code}`, true)
        }
      }

      startupLog({ agentError: err })

      if (err) {
        log.error(err)
        done()
        return
      }

      log.debug(`Response from the agent: ${res}`)

      try {
        this._prioritySampler.update(JSON.parse(res).rate_by_service)
      } catch (e) {
        log.error(e)

        metrics.increment(`${METRIC_PREFIX}.errors`, true)
        metrics.increment(`${METRIC_PREFIX}.errors.by.name`, `name:${e.name}`, true)
      }
      done()
    })
  }
}

function setHeader (headers, key, value) {
  if (value) {
    headers[key] = value
  }
}

function getEncoder (protocolVersion) {
  if (protocolVersion === '0.5') {
    return __webpack_require__(/*! ../../encode/0.5 */ "../../node_modules/dd-trace/packages/dd-trace/src/encode/0.5.js").AgentEncoder
  } else {
    return __webpack_require__(/*! ../../encode/0.4 */ "../../node_modules/dd-trace/packages/dd-trace/src/encode/0.4.js").AgentEncoder
  }
}

function makeRequest (version, data, count, url, lookup, needsStartupLog, cb) {
  const options = {
    path: `/v${version}/traces`,
    method: 'PUT',
    headers: {
      'Content-Type': 'application/msgpack',
      'Datadog-Meta-Tracer-Version': tracerVersion,
      'X-Datadog-Trace-Count': String(count)
    },
    lookup
  }

  setHeader(options.headers, 'Datadog-Meta-Lang', 'nodejs')
  setHeader(options.headers, 'Datadog-Meta-Lang-Version', process.version)
  setHeader(options.headers, 'Datadog-Meta-Lang-Interpreter', process.jsEngine || 'v8')

  if (url.protocol === 'unix:') {
    options.socketPath = url.pathname
  } else {
    options.protocol = url.protocol
    options.hostname = url.hostname
    options.port = url.port
  }

  log.debug(() => `Request to the agent: ${JSON.stringify(options)}`)

  request(data, options, true, (err, res, status) => {
    if (needsStartupLog) {
      // Note that logging will only happen once, regardless of how many times this is called.
      startupLog({
        agentError: status !== 404 && status !== 200 ? err : undefined
      })
    }
    cb(err, res, status)
  })
}

module.exports = Writer


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/exporters/common/docker.js":
/*!*****************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/exporters/common/docker.js ***!
  \*****************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const fs = __webpack_require__(/*! fs */ "fs")

const uuidSource = '[0-9a-f]{8}[-_][0-9a-f]{4}[-_][0-9a-f]{4}[-_][0-9a-f]{4}[-_][0-9a-f]{12}'
const containerSource = '[0-9a-f]{64}'
const taskSource = '[0-9a-f]{32}-\\d+'
const entityReg = new RegExp(`.*(${uuidSource}|${containerSource}|${taskSource})(?:\\.scope)?$`, 'm')

const entityId = getEntityId()

function getEntityId () {
  const cgroup = readControlGroup() || ''
  const match = cgroup.trim().match(entityReg) || []

  return match[1]
}

function readControlGroup () {
  try {
    return fs.readFileSync('/proc/self/cgroup').toString()
  } catch (err) {
    // ignore
  }
}

module.exports = {
  // can be the container ID but not always depending on the orchestrator
  id () {
    return entityId
  }
}


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/exporters/common/request.js":
/*!******************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/exporters/common/request.js ***!
  \******************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const http = __webpack_require__(/*! http */ "http")
const https = __webpack_require__(/*! https */ "https")
const log = __webpack_require__(/*! ../../log */ "../../node_modules/dd-trace/packages/dd-trace/src/log.js")
const docker = __webpack_require__(/*! ./docker */ "../../node_modules/dd-trace/packages/dd-trace/src/exporters/common/docker.js")
const { storage } = __webpack_require__(/*! ../../../../datadog-core */ "../../node_modules/dd-trace/packages/datadog-core/index.js")

const httpAgent = new http.Agent({ keepAlive: true })
const httpsAgent = new https.Agent({ keepAlive: true })
const containerId = docker.id()

function request (data, options, keepAlive, callback) {
  if (!options.headers) {
    options.headers = {}
  }
  const isSecure = options.protocol === 'https:'
  const client = isSecure ? https : http
  const dataArray = [].concat(data)
  options.headers['Content-Length'] = byteLength(dataArray)

  if (containerId) {
    options.headers['Datadog-Container-ID'] = containerId
  }

  if (keepAlive) {
    options.agent = isSecure ? httpsAgent : httpAgent
  }

  const firstRequest = retriableRequest(options, client, callback)
  dataArray.forEach(buffer => firstRequest.write(buffer))

  // The first request will be retried
  const firstRequestErrorHandler = () => {
    log.debug('Retrying request to the intake')
    const retriedReq = retriableRequest(options, client, callback)
    dataArray.forEach(buffer => retriedReq.write(buffer))
    // The retried request will fail normally
    retriedReq.on('error', e => callback(new Error(`Network error trying to reach the intake: ${e.message}`)))
    retriedReq.end()
  }

  firstRequest.on('error', firstRequestErrorHandler)
  firstRequest.end()

  return firstRequest
}

function retriableRequest (options, client, callback) {
  const store = storage.getStore()

  storage.enterWith({ noop: true })

  const timeout = options.timeout || 15000

  const request = client.request(options, res => {
    let responseData = ''

    res.setTimeout(timeout)

    res.on('data', chunk => { responseData += chunk })
    res.on('end', () => {
      if (res.statusCode >= 200 && res.statusCode <= 299) {
        callback(null, responseData, res.statusCode)
      } else {
        const error = new Error(`Error from the endpoint: ${res.statusCode} ${http.STATUS_CODES[res.statusCode]}`)
        error.status = res.statusCode

        callback(error, null, res.statusCode)
      }
    })
  })
  request.setTimeout(timeout, request.abort)
  storage.enterWith(store)

  return request
}

function byteLength (data) {
  return data.length > 0 ? data.reduce((prev, next) => prev + next.length, 0) : 0
}

module.exports = request


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/exporters/common/writer.js":
/*!*****************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/exporters/common/writer.js ***!
  \*****************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

const log = __webpack_require__(/*! ../../log */ "../../node_modules/dd-trace/packages/dd-trace/src/log.js")

class Writer {
  constructor ({ url }) {
    this._url = url
  }

  flush (done = () => {}) {
    const count = this._encoder.count()

    if (count > 0) {
      const payload = this._encoder.makePayload()

      this._sendPayload(payload, count, done)
    } else {
      done()
    }
  }

  append (spans) {
    log.debug(() => `Encoding trace: ${JSON.stringify(spans)}`)

    this._encode(spans)
  }

  _encode (trace) {
    this._encoder.encode(trace)
  }

  setUrl (url) {
    this._url = url
  }
}

module.exports = Writer


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/exporters/log/index.js":
/*!*************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/exporters/log/index.js ***!
  \*************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const log = __webpack_require__(/*! ../../log */ "../../node_modules/dd-trace/packages/dd-trace/src/log.js")

const TRACE_PREFIX = '{"traces":[['
const TRACE_SUFFIX = ']]}\n'
const TRACE_FORMAT_OVERHEAD = TRACE_PREFIX.length + TRACE_SUFFIX.length
const MAX_SIZE = 64 * 1024 // 64kb

class LogExporter {
  export (spans) {
    log.debug(() => `Adding trace to queue: ${JSON.stringify(spans)}`)

    let size = TRACE_FORMAT_OVERHEAD
    let queue = []

    for (const span of spans) {
      const spanStr = JSON.stringify(span)
      if (spanStr.length + TRACE_FORMAT_OVERHEAD > MAX_SIZE) {
        log.debug('Span too large to send to logs, dropping')
        continue
      }
      if (spanStr.length + size > MAX_SIZE) {
        this._printSpans(queue)
        queue = []
        size = TRACE_FORMAT_OVERHEAD
      }
      size += spanStr.length + 1 // includes length of ',' character
      queue.push(spanStr)
    }
    if (queue.length > 0) {
      this._printSpans(queue)
    }
  }

  _printSpans (queue) {
    let logLine = TRACE_PREFIX
    let firstTrace = true
    for (const spanStr of queue) {
      if (firstTrace) {
        firstTrace = false
        logLine += spanStr
      } else {
        logLine += ',' + spanStr
      }
    }
    logLine += TRACE_SUFFIX
    process.stdout.write(logLine)
  }
}

module.exports = LogExporter


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/exporters/scheduler.js":
/*!*************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/exporters/scheduler.js ***!
  \*************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


class Scheduler {
  constructor (callback, interval) {
    this._timer = null
    this._callback = callback
    this._interval = interval
  }

  start () {
    this._timer = setInterval(this._callback, this._interval)
    this._timer.unref && this._timer.unref()

    process.once('beforeExit', this._callback)
  }

  stop () {
    clearInterval(this._timer)

    process.removeListener('beforeExit', this._callback)
  }

  reset () {
    this.stop()
    this.start()
  }
}

module.exports = Scheduler


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/format.js":
/*!************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/format.js ***!
  \************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const constants = __webpack_require__(/*! ./constants */ "../../node_modules/dd-trace/packages/dd-trace/src/constants.js")
const tags = __webpack_require__(/*! ../../../ext/tags */ "../../node_modules/dd-trace/ext/tags.js")
const id = __webpack_require__(/*! ./id */ "../../node_modules/dd-trace/packages/dd-trace/src/id.js")
const { isError } = __webpack_require__(/*! ./util */ "../../node_modules/dd-trace/packages/dd-trace/src/util.js")

const SAMPLING_PRIORITY_KEY = constants.SAMPLING_PRIORITY_KEY
const SAMPLING_RULE_DECISION = constants.SAMPLING_RULE_DECISION
const SAMPLING_LIMIT_DECISION = constants.SAMPLING_LIMIT_DECISION
const SAMPLING_AGENT_DECISION = constants.SAMPLING_AGENT_DECISION
const MEASURED = tags.MEASURED
const ORIGIN_KEY = constants.ORIGIN_KEY
const HOSTNAME_KEY = constants.HOSTNAME_KEY

const map = {
  'service.name': 'service',
  'span.type': 'type',
  'resource.name': 'resource'
}

function format (span) {
  const formatted = formatSpan(span)

  extractError(formatted, span)
  extractRootTags(formatted, span)
  extractChunkTags(formatted, span)
  extractTags(formatted, span)

  return formatted
}

function formatSpan (span) {
  const spanContext = span.context()

  return {
    trace_id: spanContext._traceId,
    span_id: spanContext._spanId,
    parent_id: spanContext._parentId || id('0'),
    name: String(spanContext._name),
    resource: String(spanContext._name),
    error: 0,
    meta: {},
    metrics: {},
    start: Math.round(span._startTime * 1e6),
    duration: Math.round(span._duration * 1e6)
  }
}

function extractTags (trace, span) {
  const context = span.context()
  const origin = context._trace.origin
  const tags = context._tags
  const hostname = context._hostname
  const priority = context._sampling.priority

  if (tags['span.kind'] && tags['span.kind'] !== 'internal') {
    addTag({}, trace.metrics, MEASURED, 1)
  }

  for (const tag in tags) {
    switch (tag) {
      case 'service.name':
      case 'span.type':
      case 'resource.name':
        addTag(trace, {}, map[tag], tags[tag])
        break
      // HACK: remove when Datadog supports numeric status code
      case 'http.status_code':
        addTag(trace.meta, {}, tag, tags[tag] && String(tags[tag]))
        break
      case HOSTNAME_KEY:
      case MEASURED:
        addTag({}, trace.metrics, tag, tags[tag] === undefined || tags[tag] ? 1 : 0)
        break
      case 'error':
        if (tags[tag] && (context._name !== 'fs.operation')) {
          trace.error = 1
        }
        break
      case 'error.type':
      case 'error.msg':
      case 'error.stack':
        // HACK: remove when implemented in the backend
        if (context._name !== 'fs.operation') {
          trace.error = 1
        }
      default: // eslint-disable-line no-fallthrough
        addTag(trace.meta, trace.metrics, tag, tags[tag])
    }
  }

  if (span.tracer()._service === tags['service.name']) {
    addTag(trace.meta, trace.metrics, 'language', 'javascript')
  }

  addTag(trace.meta, trace.metrics, SAMPLING_PRIORITY_KEY, priority)
  addTag(trace.meta, trace.metrics, ORIGIN_KEY, origin)
  addTag(trace.meta, trace.metrics, HOSTNAME_KEY, hostname)
}

function extractRootTags (trace, span) {
  const context = span.context()
  const isLocalRoot = span === context._trace.started[0]
  const parentId = context._parentId

  if (!isLocalRoot || (parentId && parentId.toString(10) !== '0')) return

  addTag({}, trace.metrics, SAMPLING_RULE_DECISION, context._trace[SAMPLING_RULE_DECISION])
  addTag({}, trace.metrics, SAMPLING_LIMIT_DECISION, context._trace[SAMPLING_LIMIT_DECISION])
  addTag({}, trace.metrics, SAMPLING_AGENT_DECISION, context._trace[SAMPLING_AGENT_DECISION])
}

function extractChunkTags (trace, span) {
  const context = span.context()
  const isLocalRoot = span === context._trace.started[0]

  if (!isLocalRoot) return

  for (const key in context._trace.tags) {
    addTag(trace.meta, trace.metrics, key, context._trace.tags[key])
  }
}

function extractError (trace, span) {
  const error = span.context()._tags['error']
  if (isError(error)) {
    addTag(trace.meta, trace.metrics, 'error.msg', error.message)
    addTag(trace.meta, trace.metrics, 'error.type', error.name)
    addTag(trace.meta, trace.metrics, 'error.stack', error.stack)
  }
}

function addTag (meta, metrics, key, value, nested) {
  switch (typeof value) {
    case 'string':
      if (!value) break
      meta[key] = value
      break
    case 'number':
      if (isNaN(value)) break
      metrics[key] = value
      break
    case 'boolean':
      metrics[key] = value ? 1 : 0
      break
    case 'undefined':
      break
    case 'object':
      if (value === null) break

      // Special case for Node.js Buffer and URL
      if (isNodeBuffer(value) || isUrl(value)) {
        metrics[key] = value.toString()
      } else if (!Array.isArray(value) && !nested) {
        for (const prop in value) {
          if (!value.hasOwnProperty(prop)) continue

          addTag(meta, metrics, `${key}.${prop}`, value[prop], true)
        }
      }

      break
  }
}

function isNodeBuffer (obj) {
  return obj.constructor && obj.constructor.name === 'Buffer' &&
    typeof obj.readInt8 === 'function' &&
    typeof obj.toString === 'function'
}

function isUrl (obj) {
  return obj.constructor && obj.constructor.name === 'URL' &&
    typeof obj.href === 'string' &&
    typeof obj.toString === 'function'
}

module.exports = format


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/histogram.js":
/*!***************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/histogram.js ***!
  \***************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const { DDSketch } = __webpack_require__(/*! @datadog/sketches-js */ "../../node_modules/@datadog/sketches-js/dist/index.js")

class Histogram {
  constructor () {
    this.reset()
  }

  get min () { return this._min }
  get max () { return this._max }
  get avg () { return this._count === 0 ? 0 : this._sum / this._count }
  get sum () { return this._sum }
  get count () { return this._count }
  get median () { return this.percentile(50) }
  get p95 () { return this.percentile(95) }

  percentile (percentile) {
    return this._histogram.getValueAtQuantile(percentile / 100) || 0
  }

  record (value) {
    if (this._count === 0) {
      this._min = this._max = value
    } else {
      this._min = Math.min(this._min, value)
      this._max = Math.max(this._max, value)
    }

    this._count++
    this._sum += value

    this._histogram.accept(value)
  }

  reset () {
    this._min = 0
    this._max = 0
    this._sum = 0
    this._count = 0

    this._histogram = new DDSketch()
  }
}

module.exports = Histogram


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/id.js":
/*!********************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/id.js ***!
  \********************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const { randomFillSync } = __webpack_require__(/*! crypto */ "crypto")

const UINT_MAX = 4294967296

const data = new Uint8Array(8 * 8192)
const zeroId = new Uint8Array(8)

const map = Array.prototype.map
const pad = byte => `${byte < 16 ? '0' : ''}${byte.toString(16)}`

let batch = 0

// Internal representation of a trace or span ID.
class Identifier {
  constructor (value, radix) {
    this._isUint64BE = true // msgpack-lite compatibility
    this._buffer = typeof radix === 'number'
      ? fromString(value, radix)
      : createBuffer(value)
  }

  toString (radix) {
    return typeof radix === 'number'
      ? toNumberString(this._buffer, radix)
      : toHexString(this._buffer)
  }

  toBuffer () {
    return this._buffer
  }

  // msgpack-lite compatibility
  toArray () {
    if (this._buffer.length === 8) {
      return this._buffer
    }
    return this._buffer.slice(-8)
  }

  toJSON () {
    return this.toString()
  }
}

// Create a buffer, using an optional hexadecimal value if provided.
function createBuffer (value) {
  if (value === '0') return zeroId
  if (!value) return pseudoRandom()

  const size = Math.ceil(value.length / 2)
  const buffer = new Array(size)

  for (let i = 0; i < size; i++) {
    buffer[i] = parseInt(value.substring(i * 2, i * 2 + 2), 16)
  }

  return buffer
}

// Convert a numerical string to a buffer using the specified radix.
function fromString (str, raddix) {
  const buffer = new Array(8)
  const len = str.length

  let pos = 0
  let high = 0
  let low = 0

  if (str[0] === '-') pos++

  const sign = pos

  while (pos < len) {
    const chr = parseInt(str[pos++], raddix)

    if (!(chr >= 0)) break // NaN

    low = low * raddix + chr
    high = high * raddix + Math.floor(low / UINT_MAX)
    low %= UINT_MAX
  }

  if (sign) {
    high = ~high

    if (low) {
      low = UINT_MAX - low
    } else {
      high++
    }
  }

  writeUInt32BE(buffer, high, 0)
  writeUInt32BE(buffer, low, 4)

  return buffer
}

// Convert a buffer to a numerical string.
function toNumberString (buffer, radix) {
  let high = readInt32(buffer, 0)
  let low = readInt32(buffer, 4)
  let str = ''

  radix = radix || 10

  while (1) {
    const mod = (high % radix) * UINT_MAX + low

    high = Math.floor(high / radix)
    low = Math.floor(mod / radix)
    str = (mod % radix).toString(radix) + str

    if (!high && !low) break
  }

  return str
}

// Convert a buffer to a hexadecimal string.
function toHexString (buffer) {
  return map.call(buffer, pad).join('')
}

// Simple pseudo-random 64-bit ID generator.
function pseudoRandom () {
  if (batch === 0) {
    randomFillSync(data)
  }

  batch = (batch + 1) % 8192

  const offset = batch * 8

  return [
    data[offset] & 0x7F, // only positive int64,
    data[offset + 1],
    data[offset + 2],
    data[offset + 3],
    data[offset + 4],
    data[offset + 5],
    data[offset + 6],
    data[offset + 7]
  ]
}

// Read a buffer to unsigned integer bytes.
function readInt32 (buffer, offset) {
  return (buffer[offset + 0] * 16777216) +
    (buffer[offset + 1] << 16) +
    (buffer[offset + 2] << 8) +
    buffer[offset + 3]
}

// Write unsigned integer bytes to a buffer.
function writeUInt32BE (buffer, value, offset) {
  buffer[3 + offset] = value & 255
  value = value >> 8
  buffer[2 + offset] = value & 255
  value = value >> 8
  buffer[1 + offset] = value & 255
  value = value >> 8
  buffer[0 + offset] = value & 255
}

module.exports = (value, radix) => new Identifier(value, radix)


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/iitm.js":
/*!**********************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/iitm.js ***!
  \**********************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const semver = __webpack_require__(/*! semver */ "../../node_modules/dd-trace/node_modules/semver/semver.js")
const logger = __webpack_require__(/*! ./log */ "../../node_modules/dd-trace/packages/dd-trace/src/log.js")

if (semver.satisfies(process.versions.node, '^12.20.0 || >=14.13.1')) {
  module.exports = __webpack_require__(/*! import-in-the-middle */ "../../node_modules/import-in-the-middle/index.js")
} else {
  logger.warn('ESM is not fully supported by this version of Node.js, ' +
    'so dd-trace will not intercept ESM loading.')
  module.exports = () => ({
    unhook: () => {}
  })
  module.exports.addHook = () => {}
  module.exports.removeHook = () => {}
}


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/instrumenter.js":
/*!******************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/instrumenter.js ***!
  \******************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const shimmer = __webpack_require__(/*! ../../datadog-shimmer */ "../../node_modules/dd-trace/packages/datadog-shimmer/index.js")
const log = __webpack_require__(/*! ./log */ "../../node_modules/dd-trace/packages/dd-trace/src/log.js")
const metrics = __webpack_require__(/*! ./metrics */ "../../node_modules/dd-trace/packages/dd-trace/src/metrics.js")
const Loader = __webpack_require__(/*! ./loader */ "../../node_modules/dd-trace/packages/dd-trace/src/loader.js")
const { isTrue } = __webpack_require__(/*! ./util */ "../../node_modules/dd-trace/packages/dd-trace/src/util.js")
const plugins = __webpack_require__(/*! ./plugins */ "../../node_modules/dd-trace/packages/dd-trace/src/plugins/index.js")
const Plugin = __webpack_require__(/*! ./plugins/plugin */ "../../node_modules/dd-trace/packages/dd-trace/src/plugins/plugin.js")
const telemetry = __webpack_require__(/*! ./telemetry */ "../../node_modules/dd-trace/packages/dd-trace/src/telemetry.js")

const disabledPlugins = process.env.DD_TRACE_DISABLED_PLUGINS

const collectDisabledPlugins = () => {
  return new Set(disabledPlugins && disabledPlugins.split(',').map(plugin => plugin.trim()))
}

function cleanEnv (name) {
  return process.env[`DD_TRACE_${name.toUpperCase()}`.replace(/[^a-z0-9_]/ig, '_')]
}

function getConfig (name, config = {}) {
  if (!name) {
    return config
  }

  const enabled = cleanEnv(`${name}_ENABLED`)
  if (enabled !== undefined) {
    config.enabled = isTrue(enabled)
  }

  return config
}

class Instrumenter {
  constructor (tracer) {
    this._tracer = tracer
    this._loader = new Loader(this)
    this._enabled = false
    this._names = new Set()
    this._plugins = new Map()
    this._instrumented = new Map()
    this._disabledPlugins = collectDisabledPlugins()
  }

  use (name, config) {
    if (typeof name !== 'string') return
    const plugin = plugins[name.toLowerCase()]
    if (plugin && plugin.prototype instanceof Plugin) return
    if (typeof config === 'boolean') {
      config = { enabled: config }
    }

    config = getConfig(name, config)

    try {
      this._set(plugin, { name, config })
      telemetry.updateIntegrations()
    } catch (e) {
      log.debug(`Could not find a plugin named "${name}".`)
    }

    if (this._enabled) {
      this._loader.reload(this._plugins)
    }
  }

  enable (config) {
    config = config || {}
    const serviceMapping = config.serviceMapping

    this._enabled = true

    if (config.plugins !== false) {
      Object.keys(plugins)
        .filter(name => !this._plugins.has(plugins[name]))
        .forEach(name => {
          if (plugins[name].prototype instanceof Plugin) return
          const pluginConfig = {}
          if (serviceMapping && serviceMapping[name]) {
            pluginConfig.service = serviceMapping[name]
          }
          this._set(plugins[name], { name, config: getConfig(name, pluginConfig) })
        })
    }

    this._loader.reload(this._plugins)
  }

  disable () {
    for (const instrumentation of this._instrumented.keys()) {
      this.unpatch(instrumentation)
    }

    this._plugins.clear()
    this._enabled = false
    this._loader.reload(this._plugins)
  }

  wrap (nodules, names, wrapper) {
    shimmer.massWrap(nodules, names, wrapper)
  }

  unwrap (nodules, names, wrapper) {
    shimmer.massUnwrap(nodules, names, wrapper)
  }

  wrapExport (moduleExports, wrapper) {
    return shimmer.wrap(moduleExports, wrapper)
  }

  unwrapExport (moduleExports) {
    return shimmer.unwrap(moduleExports)
  }

  load (plugin, meta) {
    if (!this._enabled) return

    const instrumentations = [].concat(plugin)
    const enabled = meta.config.enabled !== false

    metrics.boolean(`datadog.tracer.node.plugin.enabled.by.name`, enabled, `name:${meta.name}`)

    try {
      instrumentations
        .forEach(instrumentation => {
          this._loader.load(instrumentation, meta.config)
        })
    } catch (e) {
      log.error(e)
      this.unload(plugin)
      log.debug(`Error while trying to patch ${meta.name}. The plugin has been disabled.`)

      metrics.increment(`datadog.tracer.node.plugin.errors`, true)
    }
  }

  unload (plugin) {
    [].concat(plugin)
      .forEach(instrumentation => {
        this.unpatch(instrumentation)
        this._instrumented.delete(instrumentation)
      })

    const meta = this._plugins.get(plugin)

    if (meta) {
      this._plugins.delete(plugin)

      metrics.boolean(`datadog.tracer.node.plugin.enabled.by.name`, false, `name:${meta.name}`)
    }
  }

  patch (instrumentation, moduleExports, config) {
    let instrumented = this._instrumented.get(instrumentation)

    if (!instrumented) {
      this._instrumented.set(instrumentation, instrumented = new Set())
      telemetry.updateIntegrations()
    }

    if (!instrumented.has(this._defaultExport(moduleExports))) {
      try {
        moduleExports = instrumentation.patch.call(this, moduleExports, this._tracer._tracer, config) || moduleExports
        return moduleExports
      } finally {
        // add even on error since `unpatch` will take care of removing it.
        instrumented.add(this._defaultExport(moduleExports))
      }
    }
  }

  unpatch (instrumentation) {
    const instrumented = this._instrumented.get(instrumentation)

    if (instrumented) {
      instrumented.forEach(moduleExports => {
        try {
          instrumentation.unpatch.call(this, moduleExports, this._tracer)
        } catch (e) {
          log.error(e)
        }
      })
    }
  }

  _set (plugin, meta) {
    if (this._disabledPlugins.has(meta.name)) {
      log.debug(`Plugin "${meta.name}" was disabled via configuration option.`)
    } else {
      this._plugins.set(plugin, meta)
      this.load(plugin, meta)
    }
  }

  // ESM modules have a different export between `import` and `require` so we
  // use the default export instead when available.
  _defaultExport (moduleExports) {
    return moduleExports && (moduleExports.default || moduleExports)
  }
}

module.exports = Instrumenter


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/loader.js":
/*!************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/loader.js ***!
  \************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

const semver = __webpack_require__(/*! semver */ "../../node_modules/dd-trace/node_modules/semver/semver.js")
const Hook = __webpack_require__(/*! ../../datadog-instrumentations/src/helpers/hook */ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/helpers/hook.js")
const parse = __webpack_require__(/*! module-details-from-path */ "../../node_modules/module-details-from-path/index.js")
const path = __webpack_require__(/*! path */ "path")
const uniq = __webpack_require__(/*! lodash.uniq */ "../../node_modules/lodash.uniq/index.js")
const log = __webpack_require__(/*! ./log */ "../../node_modules/dd-trace/packages/dd-trace/src/log.js")
const requirePackageJson = __webpack_require__(/*! ./require-package-json */ "../../node_modules/dd-trace/packages/dd-trace/src/require-package-json.js")

const pathSepExpr = new RegExp(`\\${path.sep}`, 'g')

class Loader {
  constructor (instrumenter) {
    this._instrumenter = instrumenter
  }

  reload (plugins) {
    this._plugins = plugins
    this._patched = []

    const instrumentations = Array.from(this._plugins.keys())
      .reduce((prev, current) => prev.concat(current), [])

    const instrumentedModules = uniq(instrumentations
      .map(instrumentation => instrumentation.name))

    this._names = new Set(instrumentations
      .map(instrumentation => filename(instrumentation)))

    this._hook && this._hook.unhook()
    this._hook = Hook(instrumentedModules, (moduleExports, moduleName, moduleBaseDir) => {
      return this._hookModule(moduleExports, moduleName, moduleBaseDir)
    })
  }

  load (instrumentation, config) {
    this._getModules(instrumentation).forEach(nodule => {
      this._instrumenter.patch(instrumentation, nodule, config)
    })
  }

  _getModules (instrumentation) {
    const modules = []
    const ids = Object.keys(__webpack_require__.c)

    let pkg

    for (let i = 0, l = ids.length; i < l; i++) {
      const id = ids[i].replace(pathSepExpr, '/')

      if (!id.includes(`/node_modules/${instrumentation.name}/`)) continue

      if (instrumentation.file) {
        if (!id.endsWith(`/node_modules/${filename(instrumentation)}`)) continue

        const basedir = getBasedir(ids[i])

        pkg = requirePackageJson(basedir, module)
      } else {
        const basedir = getBasedir(ids[i])

        pkg = requirePackageJson(basedir, module)

        const mainFile = path.posix.normalize(pkg.main || 'index.js')
        if (!id.endsWith(`/node_modules/${instrumentation.name}/${mainFile}`)) continue
      }

      if (!matchVersion(pkg.version, instrumentation.versions)) continue

      modules.push(__webpack_require__.c[ids[i]].exports)
    }

    return modules
  }

  _hookModule (moduleExports, moduleName, moduleBaseDir) {
    moduleName = moduleName.replace(pathSepExpr, '/')

    if (!this._names.has(moduleName)) {
      return moduleExports
    }

    if (moduleBaseDir) {
      moduleBaseDir = moduleBaseDir.replace(pathSepExpr, '/')
    }

    const moduleVersion = getVersion(moduleBaseDir)

    for (const [plugin, meta] of this._plugins) {
      if (meta.config.enabled === false) {
        continue
      }
      try {
        for (const instrumentation of [].concat(plugin)) {
          if (moduleName !== filename(instrumentation) || !matchVersion(moduleVersion, instrumentation.versions)) {
            continue
          }

          moduleExports = this._instrumenter.patch(instrumentation, moduleExports, meta.config) || moduleExports
        }
      } catch (e) {
        log.error(e)
        this._instrumenter.unload(plugin)
        log.debug(`Error while trying to patch ${meta.name}. The plugin has been disabled.`)
      }
    }

    return moduleExports
  }
}

function getBasedir (id) {
  return parse(id).basedir.replace(pathSepExpr, '/')
}

function matchVersion (version, ranges) {
  return !version || (ranges && ranges.some(range => semver.satisfies(semver.coerce(version), range)))
}

function getVersion (moduleBaseDir) {
  if (moduleBaseDir) {
    return requirePackageJson(moduleBaseDir, module).version
  }
}

function filename (plugin) {
  return [plugin.name, plugin.file].filter(val => val).join('/')
}

module.exports = Loader

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/module.js */ "../../node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/log.js":
/*!*********************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/log.js ***!
  \*********************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const { storage } = __webpack_require__(/*! ../../datadog-core */ "../../node_modules/dd-trace/packages/datadog-core/index.js")

const _default = {
  debug: msg => console.debug(msg), /* eslint-disable-line no-console */
  info: msg => console.info(msg), /* eslint-disable-line no-console */
  warn: msg => console.warn(msg), /* eslint-disable-line no-console */
  error: msg => console.error(msg) /* eslint-disable-line no-console */
}

// based on: https://github.com/trentm/node-bunyan#levels
const _logLevels = {
  'debug': 20,
  'info': 30,
  'warn': 40,
  'error': 50
}

const _defaultLogLevel = 'debug'

const _checkLogLevel = (logLevel) => {
  if (logLevel && typeof logLevel === 'string') {
    return _logLevels[logLevel.toLowerCase().trim()] || _logLevels[_defaultLogLevel]
  }

  return _logLevels[_defaultLogLevel]
}

const memoize = func => {
  const cache = {}
  const memoized = function (key) {
    if (!cache[key]) {
      cache[key] = func.apply(this, arguments)
    }

    return cache[key]
  }

  return memoized
}

function processMsg (msg) {
  return typeof msg === 'function' ? msg() : msg
}

function withNoop (fn) {
  const store = storage.getStore()

  storage.enterWith({ noop: true })
  fn()
  storage.enterWith(store)
}

const log = {
  _isLogLevelEnabled (level) {
    return _logLevels[level] >= this._logLevel
  },

  use (logger) {
    if (logger && logger.debug instanceof Function && logger.error instanceof Function) {
      this._logger = logger
    }

    return this
  },

  toggle (enabled, logLevel, tracer) {
    this._enabled = enabled
    this._logLevel = _checkLogLevel(logLevel)
    this._tracer = tracer

    return this
  },

  reset () {
    this._logger = _default
    this._enabled = false
    this._deprecate = memoize((code, message) => {
      withNoop(() => this._logger.error(message))
      return this
    })
    this._logLevel = _checkLogLevel()

    return this
  },

  debug (message) {
    if (this._enabled && this._isLogLevelEnabled('debug')) {
      withNoop(() => this._logger.debug(processMsg(message)))
    }

    return this
  },

  info (message) {
    if (!this._logger.info) return this.debug(message)
    if (this._enabled && this._isLogLevelEnabled('info')) {
      withNoop(() => this._logger.info(processMsg(message)))
    }

    return this
  },

  warn (message) {
    if (!this._logger.warn) return this.debug(message)
    if (this._enabled && this._isLogLevelEnabled('warn')) {
      withNoop(() => this._logger.warn(processMsg(message)))
    }

    return this
  },

  error (err) {
    if (this._enabled && this._isLogLevelEnabled('error')) {
      if (err instanceof Function) {
        err = err()
      }

      if (typeof err !== 'object' || !err) {
        err = String(err)
      } else if (!err.stack) {
        err = String(err.message || err)
      }

      if (typeof err === 'string') {
        err = new Error(err)
      }

      withNoop(() => this._logger.error(err))
    }

    return this
  },

  deprecate (code, message) {
    return this._deprecate(code, message)
  }
}

log.reset()

module.exports = log


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/metrics.js":
/*!*************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/metrics.js ***!
  \*************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// TODO: capture every second and flush every 10 seconds

const v8 = __webpack_require__(/*! v8 */ "v8")
const os = __webpack_require__(/*! os */ "os")
const Client = __webpack_require__(/*! ./dogstatsd */ "../../node_modules/dd-trace/packages/dd-trace/src/dogstatsd.js")
const log = __webpack_require__(/*! ./log */ "../../node_modules/dd-trace/packages/dd-trace/src/log.js")
const Histogram = __webpack_require__(/*! ./histogram */ "../../node_modules/dd-trace/packages/dd-trace/src/histogram.js")

const INTERVAL = 10 * 1000

let nativeMetrics = null

let interval
let client
let time
let cpuUsage
let gauges
let counters
let histograms

reset()

module.exports = {
  start (config) {
    const tags = []

    Object.keys(config.tags)
      .filter(key => typeof config.tags[key] === 'string')
      .filter(key => {
        // Skip runtime-id unless enabled as cardinality may be too high
        if (key !== 'runtime-id') return true
        return (config.experimental && config.experimental.runtimeId)
      })
      .forEach(key => {
        // https://docs.datadoghq.com/tagging/#defining-tags
        const value = config.tags[key].replace(/[^a-z0-9_:./-]/ig, '_')

        tags.push(`${key}:${value}`)
      })

    try {
      nativeMetrics = __webpack_require__(/*! @datadog/native-metrics */ "../../node_modules/@datadog/native-metrics/index.js")
      nativeMetrics.start()
    } catch (e) {
      log.error(e)
      nativeMetrics = null
    }

    client = new Client({
      host: config.dogstatsd.hostname,
      port: config.dogstatsd.port,
      tags
    })

    time = process.hrtime()

    if (nativeMetrics) {
      interval = setInterval(() => {
        captureCommonMetrics()
        captureNativeMetrics()
        client.flush()
      }, INTERVAL)
    } else {
      cpuUsage = process.cpuUsage()

      interval = setInterval(() => {
        captureCommonMetrics()
        captureCpuUsage()
        captureHeapSpace()
        client.flush()
      }, INTERVAL)
    }

    interval.unref()
  },

  stop () {
    if (nativeMetrics) {
      nativeMetrics.stop()
    }

    clearInterval(interval)
    reset()
  },

  track (span) {
    if (nativeMetrics) {
      const handle = nativeMetrics.track(span)

      return {
        finish: () => nativeMetrics.finish(handle)
      }
    }

    return { finish: () => {} }
  },

  boolean (name, value, tag) {
    this.gauge(name, value ? 1 : 0, tag)
  },

  histogram (name, value, tag) {
    if (!client) return

    histograms[name] = histograms[name] || new Map()

    if (!histograms[name].has(tag)) {
      histograms[name].set(tag, new Histogram())
    }

    histograms[name].get(tag).record(value)
  },

  count (name, count, tag, monotonic = false) {
    if (!client) return
    if (typeof tag === 'boolean') {
      monotonic = tag
      tag = undefined
    }

    const map = monotonic ? counters : gauges

    map[name] = map[name] || new Map()

    const value = map[name].get(tag) || 0

    map[name].set(tag, value + count)
  },

  gauge (name, value, tag) {
    if (!client) return

    gauges[name] = gauges[name] || new Map()
    gauges[name].set(tag, value)
  },

  increment (name, tag, monotonic) {
    this.count(name, 1, tag, monotonic)
  },

  decrement (name, tag) {
    this.count(name, -1, tag)
  }
}

function reset () {
  interval = null
  client = null
  time = null
  cpuUsage = null
  gauges = {}
  counters = {}
  histograms = {}
  nativeMetrics = null
}

function captureCpuUsage () {
  if (!process.cpuUsage) return

  const elapsedTime = process.hrtime(time)
  const elapsedUsage = process.cpuUsage(cpuUsage)

  time = process.hrtime()
  cpuUsage = process.cpuUsage()

  const elapsedMs = elapsedTime[0] * 1000 + elapsedTime[1] / 1000000
  const userPercent = 100 * elapsedUsage.user / 1000 / elapsedMs
  const systemPercent = 100 * elapsedUsage.system / 1000 / elapsedMs
  const totalPercent = userPercent + systemPercent

  client.gauge('runtime.node.cpu.system', systemPercent.toFixed(2))
  client.gauge('runtime.node.cpu.user', userPercent.toFixed(2))
  client.gauge('runtime.node.cpu.total', totalPercent.toFixed(2))
}

function captureMemoryUsage () {
  const stats = process.memoryUsage()

  client.gauge('runtime.node.mem.heap_total', stats.heapTotal)
  client.gauge('runtime.node.mem.heap_used', stats.heapUsed)
  client.gauge('runtime.node.mem.rss', stats.rss)
  client.gauge('runtime.node.mem.total', os.totalmem())
  client.gauge('runtime.node.mem.free', os.freemem())

  stats.external && client.gauge('runtime.node.mem.external', stats.external)
}

function captureProcess () {
  client.gauge('runtime.node.process.uptime', Math.round(process.uptime()))
}

function captureHeapStats () {
  const stats = v8.getHeapStatistics()

  client.gauge('runtime.node.heap.total_heap_size', stats.total_heap_size)
  client.gauge('runtime.node.heap.total_heap_size_executable', stats.total_heap_size_executable)
  client.gauge('runtime.node.heap.total_physical_size', stats.total_physical_size)
  client.gauge('runtime.node.heap.total_available_size', stats.total_available_size)
  client.gauge('runtime.node.heap.heap_size_limit', stats.heap_size_limit)

  stats.malloced_memory && client.gauge('runtime.node.heap.malloced_memory', stats.malloced_memory)
  stats.peak_malloced_memory && client.gauge('runtime.node.heap.peak_malloced_memory', stats.peak_malloced_memory)
}

function captureHeapSpace () {
  if (!v8.getHeapSpaceStatistics) return

  const stats = v8.getHeapSpaceStatistics()

  for (let i = 0, l = stats.length; i < l; i++) {
    const tags = [`space:${stats[i].space_name}`]

    client.gauge('runtime.node.heap.size.by.space', stats[i].space_size, tags)
    client.gauge('runtime.node.heap.used_size.by.space', stats[i].space_used_size, tags)
    client.gauge('runtime.node.heap.available_size.by.space', stats[i].space_available_size, tags)
    client.gauge('runtime.node.heap.physical_size.by.space', stats[i].physical_space_size, tags)
  }
}

function captureGauges () {
  Object.keys(gauges).forEach(name => {
    gauges[name].forEach((value, tag) => {
      client.gauge(name, value, tag && [tag])
    })
  })
}

function captureCounters () {
  Object.keys(counters).forEach(name => {
    counters[name].forEach((value, tag) => {
      client.increment(name, value, tag && [tag])
    })
  })

  counters = {}
}

function captureHistograms () {
  Object.keys(histograms).forEach(name => {
    histograms[name].forEach((stats, tag) => {
      histogram(name, stats, tag && [tag])
      stats.reset()
    })
  })
}

function captureCommonMetrics () {
  captureMemoryUsage()
  captureProcess()
  captureHeapStats()
  captureGauges()
  captureCounters()
  captureHistograms()
}

function captureNativeMetrics () {
  const stats = nativeMetrics.stats()
  const spaces = stats.heap.spaces
  const elapsedTime = process.hrtime(time)

  time = process.hrtime()

  const elapsedUs = elapsedTime[0] * 1e6 + elapsedTime[1] / 1e3
  const userPercent = 100 * stats.cpu.user / elapsedUs
  const systemPercent = 100 * stats.cpu.system / elapsedUs
  const totalPercent = userPercent + systemPercent

  client.gauge('runtime.node.cpu.system', systemPercent.toFixed(2))
  client.gauge('runtime.node.cpu.user', userPercent.toFixed(2))
  client.gauge('runtime.node.cpu.total', totalPercent.toFixed(2))

  histogram('runtime.node.event_loop.delay', stats.eventLoop)

  Object.keys(stats.gc).forEach(type => {
    if (type === 'all') {
      histogram('runtime.node.gc.pause', stats.gc[type])
    } else {
      histogram('runtime.node.gc.pause.by.type', stats.gc[type], [`gc_type:${type}`])
    }
  })

  for (let i = 0, l = spaces.length; i < l; i++) {
    const tags = [`heap_space:${spaces[i].space_name}`]

    client.gauge('runtime.node.heap.size.by.space', spaces[i].space_size, tags)
    client.gauge('runtime.node.heap.used_size.by.space', spaces[i].space_used_size, tags)
    client.gauge('runtime.node.heap.available_size.by.space', spaces[i].space_available_size, tags)
    client.gauge('runtime.node.heap.physical_size.by.space', spaces[i].physical_space_size, tags)
  }
}

function histogram (name, stats, tags) {
  tags = [].concat(tags)

  client.gauge(`${name}.min`, stats.min, tags)
  client.gauge(`${name}.max`, stats.max, tags)
  client.increment(`${name}.sum`, stats.sum, tags)
  client.increment(`${name}.total`, stats.sum, tags)
  client.gauge(`${name}.avg`, stats.avg, tags)
  client.increment(`${name}.count`, stats.count, tags)
  client.gauge(`${name}.median`, stats.median, tags)
  client.gauge(`${name}.95percentile`, stats.p95, tags)
}


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/noop/scope.js":
/*!****************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/noop/scope.js ***!
  \****************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


class Scope {
  active () {
    return null
  }

  activate (span, callback) {
    if (typeof callback !== 'function') return callback

    return callback()
  }

  bind (target, span) {
    return target
  }

  unbind (target) {
    return target
  }
}

module.exports = Scope


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/noop/span.js":
/*!***************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/noop/span.js ***!
  \***************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Span = __webpack_require__(/*! opentracing */ "../../node_modules/opentracing/lib/index.js").Span
const NoopSpanContext = __webpack_require__(/*! ../noop/span_context */ "../../node_modules/dd-trace/packages/dd-trace/src/noop/span_context.js")
const id = __webpack_require__(/*! ../id */ "../../node_modules/dd-trace/packages/dd-trace/src/id.js")
const { storage } = __webpack_require__(/*! ../../../datadog-core */ "../../node_modules/dd-trace/packages/datadog-core/index.js") // TODO: noop storage?

class NoopSpan extends Span {
  constructor (tracer, parent) {
    super()

    this._store = storage.getStore()
    this._noopTracer = tracer
    this._noopContext = this._createContext(parent)
  }

  _context () {
    return this._noopContext
  }

  _tracer () {
    return this._noopTracer
  }

  _createContext (parent) {
    const spanId = id()

    if (parent) {
      return new NoopSpanContext({
        noop: this,
        traceId: parent._traceId,
        spanId,
        parentId: parent._spanId,
        baggageItems: Object.assign({}, parent._baggageItems)
      })
    } else {
      return new NoopSpanContext({
        noop: this,
        traceId: spanId,
        spanId
      })
    }
  }
}

module.exports = NoopSpan


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/noop/span_context.js":
/*!***********************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/noop/span_context.js ***!
  \***********************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const DatadogSpanContext = __webpack_require__(/*! ../opentracing/span_context */ "../../node_modules/dd-trace/packages/dd-trace/src/opentracing/span_context.js")
const priority = __webpack_require__(/*! ../../../../ext/priority */ "../../node_modules/dd-trace/ext/priority.js")

const USER_REJECT = priority.USER_REJECT

class NoopSpanContext extends DatadogSpanContext {
  constructor (props) {
    super(props)

    this._sampling.priority = USER_REJECT
  }
}

module.exports = NoopSpanContext


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/noop/tracer.js":
/*!*****************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/noop/tracer.js ***!
  \*****************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Tracer = __webpack_require__(/*! opentracing */ "../../node_modules/opentracing/lib/index.js").Tracer
const Scope = __webpack_require__(/*! ../noop/scope */ "../../node_modules/dd-trace/packages/dd-trace/src/noop/scope.js")
const Span = __webpack_require__(/*! ./span */ "../../node_modules/dd-trace/packages/dd-trace/src/noop/span.js")

class NoopTracer extends Tracer {
  constructor (config) {
    super(config)

    this._scope = new Scope()
    this._span = new Span(this)
  }

  trace (name, options, fn) {
    return fn(this._span, () => {})
  }

  wrap (name, options, fn) {
    return fn
  }

  scope () {
    return this._scope
  }

  currentSpan () {
    return null
  }

  getRumData () {
    return ''
  }

  setUrl () {
  }

  _startSpan (name, options) {
    return this._span
  }

  setUser () {
    return this
  }
}

module.exports = NoopTracer


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/opentracing/propagation/binary.js":
/*!************************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/opentracing/propagation/binary.js ***!
  \************************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


class BinaryPropagator {
  inject (spanContext, carrier) {}

  extract (carrier) {
    return null
  }
}

module.exports = BinaryPropagator


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/opentracing/propagation/http.js":
/*!**********************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/opentracing/propagation/http.js ***!
  \**********************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const TextMapPropagator = __webpack_require__(/*! ./text_map */ "../../node_modules/dd-trace/packages/dd-trace/src/opentracing/propagation/text_map.js")

class HttpPropagator extends TextMapPropagator {}

module.exports = HttpPropagator


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/opentracing/propagation/log.js":
/*!*********************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/opentracing/propagation/log.js ***!
  \*********************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const id = __webpack_require__(/*! ../../id */ "../../node_modules/dd-trace/packages/dd-trace/src/id.js")
const DatadogSpanContext = __webpack_require__(/*! ../span_context */ "../../node_modules/dd-trace/packages/dd-trace/src/opentracing/span_context.js")

class LogPropagator {
  constructor (config) {
    this._config = config
  }

  inject (spanContext, carrier) {
    if (!carrier) return

    carrier.dd = {}

    if (spanContext) {
      carrier.dd.trace_id = spanContext.toTraceId()
      carrier.dd.span_id = spanContext.toSpanId()
    }

    if (this._config.service) carrier.dd.service = this._config.service
    if (this._config.version) carrier.dd.version = this._config.version
    if (this._config.env) carrier.dd.env = this._config.env
  }

  extract (carrier) {
    if (!carrier || !carrier.dd || !carrier.dd.trace_id || !carrier.dd.span_id) {
      return null
    }

    const spanContext = new DatadogSpanContext({
      traceId: id(carrier.dd.trace_id, 10),
      spanId: id(carrier.dd.span_id, 10)
    })

    return spanContext
  }
}

module.exports = LogPropagator


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/opentracing/propagation/text_map.js":
/*!**************************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/opentracing/propagation/text_map.js ***!
  \**************************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const pick = __webpack_require__(/*! lodash.pick */ "../../node_modules/lodash.pick/index.js")
const id = __webpack_require__(/*! ../../id */ "../../node_modules/dd-trace/packages/dd-trace/src/id.js")
const DatadogSpanContext = __webpack_require__(/*! ../span_context */ "../../node_modules/dd-trace/packages/dd-trace/src/opentracing/span_context.js")
const log = __webpack_require__(/*! ../../log */ "../../node_modules/dd-trace/packages/dd-trace/src/log.js")

const { AUTO_KEEP, AUTO_REJECT, USER_KEEP } = __webpack_require__(/*! ../../../../../ext/priority */ "../../node_modules/dd-trace/ext/priority.js")

const traceKey = 'x-datadog-trace-id'
const spanKey = 'x-datadog-parent-id'
const originKey = 'x-datadog-origin'
const samplingKey = 'x-datadog-sampling-priority'
const baggagePrefix = 'ot-baggage-'
const b3TraceKey = 'x-b3-traceid'
const b3TraceExpr = /^([0-9a-f]{16}){1,2}$/i
const b3SpanKey = 'x-b3-spanid'
const b3SpanExpr = /^[0-9a-f]{16}$/i
const b3ParentKey = 'x-b3-parentspanid'
const b3SampledKey = 'x-b3-sampled'
const b3FlagsKey = 'x-b3-flags'
const b3HeaderKey = 'b3'
const sqsdHeaderHey = 'x-aws-sqsd-attr-_datadog'
const b3HeaderExpr = /^(([0-9a-f]{16}){1,2}-[0-9a-f]{16}(-[01d](-[0-9a-f]{16})?)?|[01d])$/i
const baggageExpr = new RegExp(`^${baggagePrefix}(.+)$`)
const ddKeys = [traceKey, spanKey, samplingKey, originKey]
const b3Keys = [b3TraceKey, b3SpanKey, b3ParentKey, b3SampledKey, b3FlagsKey, b3HeaderKey]
const logKeys = ddKeys.concat(b3Keys)
const traceparentExpr = /^(\d{2})-([A-Fa-f0-9]{32})-([A-Fa-f0-9]{16})-(\d{2})$/i
const traceparentKey = 'traceparent'

class TextMapPropagator {
  constructor (config) {
    this._config = config
  }

  inject (spanContext, carrier) {
    carrier[traceKey] = spanContext.toTraceId()
    carrier[spanKey] = spanContext.toSpanId()

    this._injectOrigin(spanContext, carrier)
    this._injectSamplingPriority(spanContext, carrier)
    this._injectBaggageItems(spanContext, carrier)
    this._injectB3(spanContext, carrier)
    this._injectTraceparent(spanContext, carrier)

    log.debug(() => `Inject into carrier: ${JSON.stringify(pick(carrier, logKeys))}.`)
  }

  extract (carrier) {
    const spanContext = this._extractSpanContext(carrier)

    if (!spanContext) return spanContext

    log.debug(() => `Extract from carrier: ${JSON.stringify(pick(carrier, logKeys))}.`)

    return spanContext
  }

  _injectOrigin (spanContext, carrier) {
    const origin = spanContext._trace.origin

    if (origin) {
      carrier[originKey] = origin
    }
  }

  _injectSamplingPriority (spanContext, carrier) {
    const priority = spanContext._sampling.priority

    if (Number.isInteger(priority)) {
      carrier[samplingKey] = priority.toString()
    }
  }

  _injectBaggageItems (spanContext, carrier) {
    spanContext._baggageItems && Object.keys(spanContext._baggageItems).forEach(key => {
      carrier[baggagePrefix + key] = String(spanContext._baggageItems[key])
    })
  }

  _injectB3 (spanContext, carrier) {
    if (!this._config.experimental.b3) return

    carrier[b3TraceKey] = spanContext._traceId.toString('hex')
    carrier[b3SpanKey] = spanContext._spanId.toString('hex')
    carrier[b3SampledKey] = spanContext._sampling.priority >= AUTO_KEEP ? '1' : '0'

    if (spanContext._sampling.priority > AUTO_KEEP) {
      carrier[b3FlagsKey] = '1'
    }

    if (spanContext._parentId) {
      carrier[b3ParentKey] = spanContext._parentId.toString('hex')
    }
  }

  _injectTraceparent (spanContext, carrier) {
    if (!this._config.experimental.traceparent) return

    const sampling = spanContext._sampling.priority >= AUTO_KEEP ? '01' : '00'
    const traceId = spanContext._traceId.toString('hex').padStart(32, '0')
    const spanId = spanContext._spanId.toString('hex').padStart(16, '0')
    carrier[traceparentKey] = `01-${traceId}-${spanId}-${sampling}`
  }

  _extractSpanContext (carrier) {
    return this._extractDatadogContext(carrier) ||
      this._extractTraceparentContext(carrier) ||
      this._extractB3Context(carrier) ||
      this._extractSqsdContext(carrier)
  }

  _extractDatadogContext (carrier) {
    const spanContext = this._extractGenericContext(carrier, traceKey, spanKey, 10)

    if (spanContext) {
      this._extractOrigin(carrier, spanContext)
      this._extractBaggageItems(carrier, spanContext)
      this._extractSamplingPriority(carrier, spanContext)
    }

    return spanContext
  }

  _extractB3Context (carrier) {
    if (!this._config.experimental.b3) return null

    const b3 = this._extractB3Headers(carrier)
    const debug = b3[b3FlagsKey] === '1'
    const priority = this._getPriority(b3[b3SampledKey], debug)
    const spanContext = this._extractGenericContext(b3, b3TraceKey, b3SpanKey)

    if (priority !== undefined) {
      if (!spanContext) {
        // B3 can force a sampling decision without providing IDs
        return new DatadogSpanContext({
          traceId: id(),
          spanId: null,
          sampling: { priority }
        })
      }

      spanContext._sampling.priority = priority
    }

    return spanContext
  }

  _extractSqsdContext (carrier) {
    const headerValue = carrier[sqsdHeaderHey]
    if (!headerValue) {
      return null
    }
    let parsed
    try {
      parsed = JSON.parse(headerValue)
    } catch (e) {
      return null
    }
    return this._extractDatadogContext(parsed)
  }

  _extractTraceparentContext (carrier) {
    if (!this._config.experimental.traceparent) return null

    const headerValue = carrier[traceparentKey]
    if (!headerValue) {
      return null
    }
    const matches = headerValue.match(traceparentExpr)
    if (matches.length) {
      return new DatadogSpanContext({
        traceId: id(matches[2], 16),
        spanId: id(matches[3], 16),
        sampling: { priority: matches[4] === '01' ? 1 : 0 }
      })
    }
    return null
  }

  _extractGenericContext (carrier, traceKey, spanKey, radix) {
    if (carrier[traceKey] && carrier[spanKey]) {
      return new DatadogSpanContext({
        traceId: id(carrier[traceKey], radix),
        spanId: id(carrier[spanKey], radix)
      })
    }

    return null
  }

  _extractB3Headers (carrier) {
    if (b3HeaderExpr.test(carrier[b3HeaderKey])) {
      return this._extractB3SingleHeader(carrier)
    } else {
      return this._extractB3MultipleHeaders(carrier)
    }
  }

  _extractB3MultipleHeaders (carrier) {
    const b3 = {}

    if (b3TraceExpr.test(carrier[b3TraceKey]) && b3SpanExpr.test(carrier[b3SpanKey])) {
      b3[b3TraceKey] = carrier[b3TraceKey]
      b3[b3SpanKey] = carrier[b3SpanKey]
    }

    if (carrier[b3SampledKey]) {
      b3[b3SampledKey] = carrier[b3SampledKey]
    }

    if (carrier[b3FlagsKey]) {
      b3[b3FlagsKey] = carrier[b3FlagsKey]
    }

    return b3
  }

  _extractB3SingleHeader (carrier) {
    const parts = carrier[b3HeaderKey].split('-')

    if (parts[0] === 'd') {
      return {
        [b3SampledKey]: '1',
        [b3FlagsKey]: '1'
      }
    } else if (parts.length === 1) {
      return {
        [b3SampledKey]: parts[0]
      }
    } else {
      const b3 = {
        [b3TraceKey]: parts[0],
        [b3SpanKey]: parts[1]
      }

      if (parts[2]) {
        b3[b3SampledKey] = parts[2] !== '0' ? '1' : '0'

        if (parts[2] === 'd') {
          b3[b3FlagsKey] = '1'
        }
      }

      return b3
    }
  }

  _extractOrigin (carrier, spanContext) {
    const origin = carrier[originKey]

    if (typeof carrier[originKey] === 'string') {
      spanContext._trace.origin = origin
    }
  }

  _extractBaggageItems (carrier, spanContext) {
    Object.keys(carrier).forEach(key => {
      const match = key.match(baggageExpr)

      if (match) {
        spanContext._baggageItems[match[1]] = carrier[key]
      }
    })
  }

  _extractSamplingPriority (carrier, spanContext) {
    const priority = parseInt(carrier[samplingKey], 10)

    if (Number.isInteger(priority)) {
      spanContext._sampling.priority = parseInt(carrier[samplingKey], 10)
    }
  }

  _getPriority (sampled, debug) {
    if (debug) {
      return USER_KEEP
    } else if (sampled === '1') {
      return AUTO_KEEP
    } else if (sampled === '0') {
      return AUTO_REJECT
    }
  }
}

module.exports = TextMapPropagator


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/opentracing/span.js":
/*!**********************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/opentracing/span.js ***!
  \**********************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// TODO (new internal tracer): use DC events for lifecycle metrics and test them

const opentracing = __webpack_require__(/*! opentracing */ "../../node_modules/opentracing/lib/index.js")
const now = __webpack_require__(/*! performance-now */ "../../node_modules/performance-now/lib/performance-now.js")
const semver = __webpack_require__(/*! semver */ "../../node_modules/dd-trace/node_modules/semver/semver.js")
const Span = opentracing.Span
const SpanContext = __webpack_require__(/*! ./span_context */ "../../node_modules/dd-trace/packages/dd-trace/src/opentracing/span_context.js")
const id = __webpack_require__(/*! ../id */ "../../node_modules/dd-trace/packages/dd-trace/src/id.js")
const tagger = __webpack_require__(/*! ../tagger */ "../../node_modules/dd-trace/packages/dd-trace/src/tagger.js")
const metrics = __webpack_require__(/*! ../metrics */ "../../node_modules/dd-trace/packages/dd-trace/src/metrics.js")
const log = __webpack_require__(/*! ../log */ "../../node_modules/dd-trace/packages/dd-trace/src/log.js")
const { storage } = __webpack_require__(/*! ../../../datadog-core */ "../../node_modules/dd-trace/packages/datadog-core/index.js")

const { DD_TRACE_EXPERIMENTAL_STATE_TRACKING } = process.env

const unfinishedRegistry = createRegistry('unfinished')
const finishedRegistry = createRegistry('finished')

class DatadogSpan extends Span {
  constructor (tracer, processor, prioritySampler, fields, debug) {
    super()

    const operationName = fields.operationName
    const parent = fields.parent || null
    const tags = Object.assign({}, fields.tags)
    const hostname = fields.hostname

    this._parentTracer = tracer
    this._debug = debug
    this._processor = processor
    this._prioritySampler = prioritySampler
    this._store = storage.getStore()
    this._name = operationName

    this._spanContext = this._createContext(parent)
    this._spanContext._name = operationName
    this._spanContext._tags = tags
    this._spanContext._hostname = hostname

    this._startTime = fields.startTime || this._getTime()

    if (this._debug && unfinishedRegistry) {
      metrics.increment('runtime.node.spans.unfinished')
      metrics.increment('runtime.node.spans.unfinished.by.name', `span_name:${operationName}`)

      unfinishedRegistry.register(this, operationName, this)
    }
  }

  toString () {
    const spanContext = this.context()
    const resourceName = spanContext._tags['resource.name']
    const resource = resourceName.length > 100
      ? `${resourceName.substring(0, 97)}...`
      : resourceName
    const json = JSON.stringify({
      traceId: spanContext._traceId,
      spanId: spanContext._spanId,
      parentId: spanContext._parentId,
      service: spanContext._tags['service.name'],
      name: spanContext._name,
      resource
    })

    return `Span${json}`
  }

  _createContext (parent) {
    let spanContext

    if (parent) {
      spanContext = new SpanContext({
        traceId: parent._traceId,
        spanId: id(),
        parentId: parent._spanId,
        sampling: parent._sampling,
        baggageItems: Object.assign({}, parent._baggageItems),
        trace: parent._trace
      })
    } else {
      const spanId = id()
      spanContext = new SpanContext({
        traceId: spanId,
        spanId
      })
    }

    spanContext._trace.started.push(this)
    spanContext._trace.startTime = spanContext._trace.startTime || Date.now()
    spanContext._trace.ticks = spanContext._trace.ticks || now()

    return spanContext
  }

  _getTime () {
    const { startTime, ticks } = this._spanContext._trace

    return startTime + now() - ticks
  }

  _context () {
    return this._spanContext
  }

  _tracer () {
    return this._parentTracer
  }

  _setOperationName (name) {
    this._spanContext._name = name
  }

  _setBaggageItem (key, value) {
    this._spanContext._baggageItems[key] = value
  }

  _getBaggageItem (key) {
    return this._spanContext._baggageItems[key]
  }

  _addTags (keyValuePairs) {
    tagger.add(this._spanContext._tags, keyValuePairs)

    this._prioritySampler.sample(this, false)
  }

  _finish (finishTime) {
    if (this._duration !== undefined) {
      return
    }

    if (DD_TRACE_EXPERIMENTAL_STATE_TRACKING === 'true') {
      if (!this._spanContext._tags['service.name']) {
        log.error(`Finishing invalid span: ${this}`)
      }
    }

    if (this._debug && finishedRegistry) {
      metrics.decrement('runtime.node.spans.unfinished')
      metrics.decrement('runtime.node.spans.unfinished.by.name', `span_name:${this._name}`)
      metrics.increment('runtime.node.spans.finished')
      metrics.increment('runtime.node.spans.finished.by.name', `span_name:${this._name}`)

      unfinishedRegistry.unregister(this)
      finishedRegistry.register(this, this._name)
    }

    finishTime = parseFloat(finishTime) || this._getTime()

    this._duration = finishTime - this._startTime
    this._spanContext._trace.finished.push(this)
    this._spanContext._isFinished = true
    this._processor.process(this)
  }
}

function createRegistry (type) {
  if (!semver.satisfies(process.version, '>=14.6')) return

  return new global.FinalizationRegistry(name => {
    metrics.decrement(`runtime.node.spans.${type}`)
    metrics.decrement(`runtime.node.spans.${type}.by.name`, [`span_name:${name}`])
  })
}

module.exports = DatadogSpan


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/opentracing/span_context.js":
/*!******************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/opentracing/span_context.js ***!
  \******************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const SpanContext = __webpack_require__(/*! opentracing */ "../../node_modules/opentracing/lib/index.js").SpanContext

class DatadogSpanContext extends SpanContext {
  constructor (props) {
    super()

    props = props || {}

    this._traceId = props.traceId
    this._spanId = props.spanId
    this._parentId = props.parentId || null
    this._name = props.name
    this._isFinished = props.isFinished || false
    this._tags = props.tags || {}
    this._sampling = props.sampling || {}
    this._baggageItems = props.baggageItems || {}
    this._noop = props.noop || null
    this._trace = props.trace || {
      started: [],
      finished: [],
      tags: {}
    }
  }

  toTraceId () {
    return this._traceId.toString(10)
  }

  toSpanId () {
    return this._spanId.toString(10)
  }
}

module.exports = DatadogSpanContext


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/opentracing/tracer.js":
/*!************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/opentracing/tracer.js ***!
  \************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const opentracing = __webpack_require__(/*! opentracing */ "../../node_modules/opentracing/lib/index.js")
const os = __webpack_require__(/*! os */ "os")
const Tracer = opentracing.Tracer
const Reference = opentracing.Reference
const Span = __webpack_require__(/*! ./span */ "../../node_modules/dd-trace/packages/dd-trace/src/opentracing/span.js")
const SpanContext = __webpack_require__(/*! ./span_context */ "../../node_modules/dd-trace/packages/dd-trace/src/opentracing/span_context.js")
const SpanProcessor = __webpack_require__(/*! ../span_processor */ "../../node_modules/dd-trace/packages/dd-trace/src/span_processor.js")
const PrioritySampler = __webpack_require__(/*! ../priority_sampler */ "../../node_modules/dd-trace/packages/dd-trace/src/priority_sampler.js")
const TextMapPropagator = __webpack_require__(/*! ./propagation/text_map */ "../../node_modules/dd-trace/packages/dd-trace/src/opentracing/propagation/text_map.js")
const HttpPropagator = __webpack_require__(/*! ./propagation/http */ "../../node_modules/dd-trace/packages/dd-trace/src/opentracing/propagation/http.js")
const BinaryPropagator = __webpack_require__(/*! ./propagation/binary */ "../../node_modules/dd-trace/packages/dd-trace/src/opentracing/propagation/binary.js")
const LogPropagator = __webpack_require__(/*! ./propagation/log */ "../../node_modules/dd-trace/packages/dd-trace/src/opentracing/propagation/log.js")
const formats = __webpack_require__(/*! ../../../../ext/formats */ "../../node_modules/dd-trace/ext/formats.js")

const log = __webpack_require__(/*! ../log */ "../../node_modules/dd-trace/packages/dd-trace/src/log.js")
const metrics = __webpack_require__(/*! ../metrics */ "../../node_modules/dd-trace/packages/dd-trace/src/metrics.js")
const getExporter = __webpack_require__(/*! ../exporter */ "../../node_modules/dd-trace/packages/dd-trace/src/exporter.js")

const REFERENCE_CHILD_OF = opentracing.REFERENCE_CHILD_OF
const REFERENCE_FOLLOWS_FROM = opentracing.REFERENCE_FOLLOWS_FROM

class DatadogTracer extends Tracer {
  constructor (config) {
    super()

    const Exporter = getExporter(config.experimental.exporter)

    this._service = config.service
    this._version = config.version
    this._env = config.env
    this._tags = config.tags
    this._logInjection = config.logInjection
    this._debug = config.debug
    this._prioritySampler = new PrioritySampler(config.env, config.experimental.sampler)
    this._exporter = new Exporter(config, this._prioritySampler)
    this._processor = new SpanProcessor(this._exporter, this._prioritySampler, config)
    this._url = this._exporter._url
    this._enableGetRumData = config.experimental.enableGetRumData
    this._propagators = {
      [formats.TEXT_MAP]: new TextMapPropagator(config),
      [formats.HTTP_HEADERS]: new HttpPropagator(config),
      [formats.BINARY]: new BinaryPropagator(config),
      [formats.LOG]: new LogPropagator(config)
    }
    if (config.reportHostname) {
      this._hostname = os.hostname()
    }
  }

  _startSpan (name, fields) {
    const reference = getParent(fields.references)
    const parent = reference && reference.referencedContext()
    return this._startSpanInternal(name, fields, parent)
  }

  _startSpanInternal (name, fields = {}, parent) {
    const tags = {
      'service.name': this._service
    }

    const span = new Span(this, this._processor, this._prioritySampler, {
      operationName: fields.operationName || name,
      parent,
      tags,
      startTime: fields.startTime,
      hostname: this._hostname
    }, this._debug)

    span.addTags(this._tags)
    span.addTags(fields.tags)

    return span
  }

  _inject (spanContext, format, carrier) {
    try {
      this._prioritySampler.sample(spanContext)
      this._propagators[format].inject(spanContext, carrier)
    } catch (e) {
      log.error(e)
      metrics.increment('datadog.tracer.node.inject.errors', true)
    }

    return this
  }

  _extract (format, carrier) {
    try {
      return this._propagators[format].extract(carrier)
    } catch (e) {
      log.error(e)
      metrics.increment('datadog.tracer.node.extract.errors', true)
      return null
    }
  }
}

function getParent (references = []) {
  let parent = null

  for (let i = 0; i < references.length; i++) {
    const ref = references[i]

    if (!(ref instanceof Reference)) {
      log.error(() => `Expected ${ref} to be an instance of opentracing.Reference`)
      continue
    }

    const spanContext = ref.referencedContext()
    const type = ref.type()

    if (spanContext && !(spanContext instanceof SpanContext)) {
      log.error(() => `Expected ${spanContext} to be an instance of SpanContext`)
      continue
    }

    if (type === REFERENCE_CHILD_OF) {
      parent = ref
      break
    } else if (type === REFERENCE_FOLLOWS_FROM) {
      if (!parent) {
        parent = ref
      }
    }
  }

  return parent
}

module.exports = DatadogTracer


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/pkg.js":
/*!*********************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/pkg.js ***!
  \*********************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const fs = __webpack_require__(/*! fs */ "fs")
const path = __webpack_require__(/*! path */ "path")

function findRoot () {
  return __webpack_require__.c[__webpack_require__.s] && __webpack_require__.c[__webpack_require__.s].filename
    ? path.dirname(__webpack_require__.c[__webpack_require__.s].filename)
    : process.cwd()
}

function findPkg () {
  const cwd = findRoot()
  const directory = path.resolve(cwd)
  const res = path.parse(directory)

  if (!res) return {}

  const { root } = res

  const filePath = findUp('package.json', root, directory)

  try {
    return JSON.parse(fs.readFileSync(filePath, 'utf8'))
  } catch (e) {
    return {}
  }
}

function findUp (name, root, directory) {
  while (true) {
    const current = path.resolve(directory, name)

    if (fs.existsSync(current)) return current

    if (directory === root) return

    directory = path.dirname(directory)
  }
}

module.exports = Object.assign(findPkg(), { findRoot, findUp })


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/plugin_manager.js":
/*!********************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/plugin_manager.js ***!
  \********************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const { isTrue } = __webpack_require__(/*! ./util */ "../../node_modules/dd-trace/packages/dd-trace/src/util.js")
const plugins = __webpack_require__(/*! ./plugins */ "../../node_modules/dd-trace/packages/dd-trace/src/plugins/index.js")

// instrument everything that needs Plugin System V2 instrumentation
__webpack_require__(/*! ../../datadog-instrumentations */ "../../node_modules/dd-trace/packages/datadog-instrumentations/index.js")

// TODO this is shared w/ instrumenter. DRY up.
function getConfig (name, config = {}) {
  const enabled = process.env[`DD_TRACE_${name.toUpperCase()}_ENABLED`.replace(/[^a-z0-9_]/ig, '_')]
  if (enabled !== undefined) {
    config.enabled = isTrue(enabled)
  }

  // TODO is this the best/correct place for this default?
  if (!('enabled' in config)) {
    config.enabled = true
  }

  return config
}

// TODO actually ... should we be looking at envrionment variables this deep down in the code?

// TODO this must always be a singleton.
module.exports = class PluginManager {
  constructor (tracer) {
    this._pluginsByName = {}
    for (const PluginClass of Object.values(plugins)) {
      if (typeof PluginClass !== 'function') continue
      this._pluginsByName[PluginClass.name] = new PluginClass(tracer)
    }
  }

  // like instrumenter.use()
  configurePlugin (name, pluginConfig) {
    if (!(name in this._pluginsByName)) return
    if (typeof pluginConfig === 'boolean') {
      pluginConfig = { enabled: pluginConfig }
    }

    this._pluginsByName[name].configure(getConfig(name, pluginConfig))
  }

  // like instrumenter.enable()
  configure (config) {
    const serviceMapping = config.serviceMapping

    if (config.plugins !== false) {
      for (const name in this._pluginsByName) {
        const pluginConfig = {}
        if (serviceMapping && serviceMapping[name]) {
          pluginConfig.service = serviceMapping[name]
        }
        this.configurePlugin(name, pluginConfig)
      }
    } else {
      for (const name in this._pluginsByName) {
        this.configurePlugin(name, false)
      }
    }
  }

  // This is basically just for testing. like intrumenter.disable()
  destroy () {
    for (const name in this._pluginsByName) this._pluginsByName[name].configure({ enabled: false })
  }
}


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/plugins/index.js":
/*!*******************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/plugins/index.js ***!
  \*******************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = {
  'amqp10': __webpack_require__(/*! ../../../datadog-plugin-amqp10/src */ "../../node_modules/dd-trace/packages/datadog-plugin-amqp10/src/index.js"),
  'amqplib': __webpack_require__(/*! ../../../datadog-plugin-amqplib/src */ "../../node_modules/dd-trace/packages/datadog-plugin-amqplib/src/index.js"),
  'aws-sdk': __webpack_require__(/*! ../../../datadog-plugin-aws-sdk/src */ "../../node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/index.js"),
  'bunyan': __webpack_require__(/*! ../../../datadog-plugin-bunyan/src */ "../../node_modules/dd-trace/packages/datadog-plugin-bunyan/src/index.js"),
  'cassandra-driver': __webpack_require__(/*! ../../../datadog-plugin-cassandra-driver/src */ "../../node_modules/dd-trace/packages/datadog-plugin-cassandra-driver/src/index.js"),
  'connect': __webpack_require__(/*! ../../../datadog-plugin-connect/src */ "../../node_modules/dd-trace/packages/datadog-plugin-connect/src/index.js"),
  'couchbase': __webpack_require__(/*! ../../../datadog-plugin-couchbase/src */ "../../node_modules/dd-trace/packages/datadog-plugin-couchbase/src/index.js"),
  'cucumber': __webpack_require__(/*! ../../../datadog-plugin-cucumber/src */ "../../node_modules/dd-trace/packages/datadog-plugin-cucumber/src/index.js"),
  'cypress': __webpack_require__(/*! ../../../datadog-plugin-cypress/src */ "../../node_modules/dd-trace/packages/datadog-plugin-cypress/src/index.js"),
  'dns': __webpack_require__(/*! ../../../datadog-plugin-dns/src */ "../../node_modules/dd-trace/packages/datadog-plugin-dns/src/index.js"),
  'elasticsearch': __webpack_require__(/*! ../../../datadog-plugin-elasticsearch/src */ "../../node_modules/dd-trace/packages/datadog-plugin-elasticsearch/src/index.js"),
  'express': __webpack_require__(/*! ../../../datadog-plugin-express/src */ "../../node_modules/dd-trace/packages/datadog-plugin-express/src/index.js"),
  'fastify': __webpack_require__(/*! ../../../datadog-plugin-fastify/src */ "../../node_modules/dd-trace/packages/datadog-plugin-fastify/src/index.js"),
  'fs': __webpack_require__(/*! ../../../datadog-plugin-fs/src */ "../../node_modules/dd-trace/packages/datadog-plugin-fs/src/index.js"),
  'google-cloud-pubsub': __webpack_require__(/*! ../../../datadog-plugin-google-cloud-pubsub/src */ "../../node_modules/dd-trace/packages/datadog-plugin-google-cloud-pubsub/src/index.js"),
  'graphql': __webpack_require__(/*! ../../../datadog-plugin-graphql/src */ "../../node_modules/dd-trace/packages/datadog-plugin-graphql/src/index.js"),
  'grpc': __webpack_require__(/*! ../../../datadog-plugin-grpc/src */ "../../node_modules/dd-trace/packages/datadog-plugin-grpc/src/index.js"),
  'hapi': __webpack_require__(/*! ../../../datadog-plugin-hapi/src */ "../../node_modules/dd-trace/packages/datadog-plugin-hapi/src/index.js"),
  'http': __webpack_require__(/*! ../../../datadog-plugin-http/src */ "../../node_modules/dd-trace/packages/datadog-plugin-http/src/index.js"),
  'http2': __webpack_require__(/*! ../../../datadog-plugin-http2/src */ "../../node_modules/dd-trace/packages/datadog-plugin-http2/src/index.js"),
  'ioredis': __webpack_require__(/*! ../../../datadog-plugin-ioredis/src */ "../../node_modules/dd-trace/packages/datadog-plugin-ioredis/src/index.js"),
  'jest': __webpack_require__(/*! ../../../datadog-plugin-jest/src */ "../../node_modules/dd-trace/packages/datadog-plugin-jest/src/index.js"),
  'knex': __webpack_require__(/*! ../../../datadog-plugin-knex/src */ "../../node_modules/dd-trace/packages/datadog-plugin-knex/src/index.js"),
  'koa': __webpack_require__(/*! ../../../datadog-plugin-koa/src */ "../../node_modules/dd-trace/packages/datadog-plugin-koa/src/index.js"),
  'kafkajs': __webpack_require__(/*! ../../../datadog-plugin-kafkajs/src */ "../../node_modules/dd-trace/packages/datadog-plugin-kafkajs/src/index.js"),
  'limitd-client': __webpack_require__(/*! ../../../datadog-plugin-limitd-client/src */ "../../node_modules/dd-trace/packages/datadog-plugin-limitd-client/src/index.js"),
  'memcached': __webpack_require__(/*! ../../../datadog-plugin-memcached/src */ "../../node_modules/dd-trace/packages/datadog-plugin-memcached/src/index.js"),
  'microgateway-core': __webpack_require__(/*! ../../../datadog-plugin-microgateway-core/src */ "../../node_modules/dd-trace/packages/datadog-plugin-microgateway-core/src/index.js"),
  'mocha': __webpack_require__(/*! ../../../datadog-plugin-mocha/src */ "../../node_modules/dd-trace/packages/datadog-plugin-mocha/src/index.js"),
  'moleculer': __webpack_require__(/*! ../../../datadog-plugin-moleculer/src */ "../../node_modules/dd-trace/packages/datadog-plugin-moleculer/src/index.js"),
  'mongodb-core': __webpack_require__(/*! ../../../datadog-plugin-mongodb-core/src */ "../../node_modules/dd-trace/packages/datadog-plugin-mongodb-core/src/index.js"),
  'mysql': __webpack_require__(/*! ../../../datadog-plugin-mysql/src */ "../../node_modules/dd-trace/packages/datadog-plugin-mysql/src/index.js"),
  'mysql2': __webpack_require__(/*! ../../../datadog-plugin-mysql2/src */ "../../node_modules/dd-trace/packages/datadog-plugin-mysql2/src/index.js"),
  'net': __webpack_require__(/*! ../../../datadog-plugin-net/src */ "../../node_modules/dd-trace/packages/datadog-plugin-net/src/index.js"),
  'next': __webpack_require__(/*! ../../../datadog-plugin-next/src */ "../../node_modules/dd-trace/packages/datadog-plugin-next/src/index.js"),
  'oracledb': __webpack_require__(/*! ../../../datadog-plugin-oracledb/src */ "../../node_modules/dd-trace/packages/datadog-plugin-oracledb/src/index.js"),
  'paperplane': __webpack_require__(/*! ../../../datadog-plugin-paperplane/src */ "../../node_modules/dd-trace/packages/datadog-plugin-paperplane/src/index.js"),
  'pg': __webpack_require__(/*! ../../../datadog-plugin-pg/src */ "../../node_modules/dd-trace/packages/datadog-plugin-pg/src/index.js"),
  'pino': __webpack_require__(/*! ../../../datadog-plugin-pino/src */ "../../node_modules/dd-trace/packages/datadog-plugin-pino/src/index.js"),
  'redis': __webpack_require__(/*! ../../../datadog-plugin-redis/src */ "../../node_modules/dd-trace/packages/datadog-plugin-redis/src/index.js"),
  'restify': __webpack_require__(/*! ../../../datadog-plugin-restify/src */ "../../node_modules/dd-trace/packages/datadog-plugin-restify/src/index.js"),
  'rhea': __webpack_require__(/*! ../../../datadog-plugin-rhea/src */ "../../node_modules/dd-trace/packages/datadog-plugin-rhea/src/index.js"),
  'router': __webpack_require__(/*! ../../../datadog-plugin-router/src */ "../../node_modules/dd-trace/packages/datadog-plugin-router/src/index.js"),
  'sharedb': __webpack_require__(/*! ../../../datadog-plugin-sharedb/src */ "../../node_modules/dd-trace/packages/datadog-plugin-sharedb/src/index.js"),
  'tedious': __webpack_require__(/*! ../../../datadog-plugin-tedious/src */ "../../node_modules/dd-trace/packages/datadog-plugin-tedious/src/index.js"),
  'winston': __webpack_require__(/*! ../../../datadog-plugin-winston/src */ "../../node_modules/dd-trace/packages/datadog-plugin-winston/src/index.js")
}


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/plugins/log_plugin.js":
/*!************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/plugins/log_plugin.js ***!
  \************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const { LOG } = __webpack_require__(/*! ../../../../ext/formats */ "../../node_modules/dd-trace/ext/formats.js")
const Plugin = __webpack_require__(/*! ./plugin */ "../../node_modules/dd-trace/packages/dd-trace/src/plugins/plugin.js")
const { storage } = __webpack_require__(/*! ../../../datadog-core */ "../../node_modules/dd-trace/packages/datadog-core/index.js")

const hasOwn = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop)

function messageProxy (message, holder) {
  return new Proxy(message, {
    get (target, p, receiver) {
      switch (p) {
        case Symbol.toStringTag:
          return Object.prototype.toString.call(target).slice(8, -1)
        case 'dd':
          return holder.dd
        default:
          return Reflect.get(target, p, receiver)
      }
    },
    ownKeys (target) {
      const ownKeys = Reflect.ownKeys(target)
      return hasOwn(target, 'dd') ? ownKeys : ['dd', ...ownKeys]
    },
    getOwnPropertyDescriptor (target, p) {
      return Reflect.getOwnPropertyDescriptor(p === 'dd' ? holder : target, p)
    }
  })
}

module.exports = class LogPlugin extends Plugin {
  constructor (...args) {
    super(...args)
    this.addSub(`apm:${this.constructor.name}:log`, (arg) => {
      // TODO rather than checking this every time, setting it ought to enable/disable any plugin
      // extending from this one
      if (!this.tracer._logInjection) return

      const store = storage.getStore()
      const span = store && store.span

      if (!span) return

      const holder = {}
      this.tracer.inject(span, LOG, holder)
      arg.message = messageProxy(arg.message, holder)
    })
  }
}


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/plugins/plugin.js":
/*!********************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/plugins/plugin.js ***!
  \********************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const dc = __webpack_require__(/*! diagnostics_channel */ "diagnostics_channel")
const { storage } = __webpack_require__(/*! ../../../datadog-core */ "../../node_modules/dd-trace/packages/datadog-core/index.js")

class Subscription {
  constructor (event, handler) {
    this._channel = dc.channel(event)
    this._handler = (message, name) => {
      const store = storage.getStore()
      if (!store || !store.noop) {
        handler(message, name)
      }
    }
  }

  enable () {
    this._channel.subscribe(this._handler)
  }

  disable () {
    this._channel.unsubscribe(this._handler)
  }
}

module.exports = class Plugin {
  constructor (tracer) {
    this._subscriptions = []
    this._enabled = false
    this._storeStack = []
    this._tracer = tracer
  }

  get tracer () {
    return this._tracer._tracer
  }

  enter (span, store) {
    store = store || storage.getStore()
    this._storeStack.push(store)
    storage.enterWith({ ...store, span })
  }

  /** Prevents creation of spans here and for all async descendants. */
  skip () {
    const store = storage.getStore()
    this._storeStack.push(store)
    storage.enterWith({ noop: true })
  }

  exit () {
    storage.enterWith(this._storeStack.pop())
  }

  addSub (channelName, handler) {
    this._subscriptions.push(new Subscription(channelName, handler))
  }

  configure (config) {
    if (typeof config === 'boolean') {
      config = { enabled: config }
    }
    this.config = config
    if (config.enabled && !this._enabled) {
      this._enabled = true
      this._subscriptions.forEach(sub => sub.enable())
    } else if (!config.enabled && this._enabled) {
      this._enabled = false
      this._subscriptions.forEach(sub => sub.disable())
    }
  }
}


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/plugins/util/ci.js":
/*!*********************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/plugins/util/ci.js ***!
  \*********************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

const URL = __webpack_require__(/*! url */ "url").URL

const {
  GIT_BRANCH,
  GIT_COMMIT_SHA,
  GIT_TAG,
  GIT_COMMIT_AUTHOR_EMAIL,
  GIT_COMMIT_AUTHOR_NAME,
  GIT_COMMIT_MESSAGE,
  GIT_COMMIT_AUTHOR_DATE,
  GIT_REPOSITORY_URL,
  CI_PIPELINE_ID,
  CI_PIPELINE_NAME,
  CI_PIPELINE_NUMBER,
  CI_PIPELINE_URL,
  CI_PROVIDER_NAME,
  CI_WORKSPACE_PATH,
  CI_JOB_URL,
  CI_JOB_NAME,
  CI_STAGE_NAME
} = __webpack_require__(/*! ./tags */ "../../node_modules/dd-trace/packages/dd-trace/src/plugins/util/tags.js")

// Receives a string with the form 'John Doe <john.doe@gmail.com>'
// and returns { name: 'John Doe', email: 'john.doe@gmail.com' }
function parseEmailAndName (emailAndName) {
  if (!emailAndName) {
    return { name: '', email: '' }
  }
  let name = ''
  let email = ''
  const matchNameAndEmail = emailAndName.match(/(?:"?([^"]*)"?\s)?(?:<?(.+@[^>]+)>?)/)
  if (matchNameAndEmail) {
    name = matchNameAndEmail[1]
    email = matchNameAndEmail[2]
  }

  return { name, email }
}

function removeEmptyValues (tags) {
  return Object.keys(tags).reduce((filteredTags, tag) => {
    if (!tags[tag]) {
      return filteredTags
    }
    return {
      ...filteredTags,
      [tag]: tags[tag]
    }
  }, {})
}

function normalizeTag (targetTags, tagKey, normalize) {
  if (targetTags[tagKey]) {
    targetTags[tagKey] = normalize(targetTags[tagKey])
  }
}

function normalizeRef (ref) {
  if (!ref) {
    return ref
  }
  return ref.replace(/origin\/|refs\/heads\/|tags\//gm, '')
}

function filterSensitiveInfoFromRepository (repositoryUrl) {
  if (repositoryUrl.startsWith('git@')) {
    return repositoryUrl
  }

  try {
    const { protocol, hostname, pathname } = new URL(repositoryUrl)

    return `${protocol}//${hostname}${pathname}`
  } catch (e) {
    return repositoryUrl
  }
}

function resolveTilde (filePath) {
  if (!filePath || typeof filePath !== 'string') {
    return ''
  }
  // '~/folder/path' or '~'
  if (filePath[0] === '~' && (filePath[1] === '/' || filePath.length === 1)) {
    return filePath.replace('~', process.env.HOME)
  }
  return filePath
}

module.exports = {
  normalizeRef,
  getCIMetadata () {
    const { env } = process

    let tags = {}

    if (env.JENKINS_URL) {
      const {
        WORKSPACE,
        BUILD_TAG,
        JOB_NAME,
        BUILD_NUMBER,
        BUILD_URL,
        GIT_BRANCH: JENKINS_GIT_BRANCH,
        GIT_COMMIT: JENKINS_GIT_COMMIT,
        GIT_URL: JENKINS_GIT_REPOSITORY_URL,
        GIT_URL_1: JENKINS_GIT_REPOSITORY_URL_1
      } = env

      tags = {
        [CI_PIPELINE_ID]: BUILD_TAG,
        [CI_PIPELINE_NUMBER]: BUILD_NUMBER,
        [CI_PIPELINE_URL]: BUILD_URL,
        [CI_PROVIDER_NAME]: 'jenkins',
        [GIT_COMMIT_SHA]: JENKINS_GIT_COMMIT,
        [GIT_REPOSITORY_URL]: JENKINS_GIT_REPOSITORY_URL || JENKINS_GIT_REPOSITORY_URL_1,
        [CI_WORKSPACE_PATH]: WORKSPACE
      }

      const isTag = JENKINS_GIT_BRANCH && JENKINS_GIT_BRANCH.includes('tags')
      const refKey = isTag ? GIT_TAG : GIT_BRANCH
      const ref = normalizeRef(JENKINS_GIT_BRANCH)

      tags[refKey] = ref

      let finalPipelineName = ''
      if (JOB_NAME) {
        // Job names can contain parameters, e.g. jobName/KEY1=VALUE1,KEY2=VALUE2/branchName
        const jobNameAndParams = JOB_NAME.split('/')
        if (jobNameAndParams.length > 1 && jobNameAndParams[1].includes('=')) {
          finalPipelineName = jobNameAndParams[0]
        } else {
          finalPipelineName = JOB_NAME.replace(`/${ref}`, '')
        }
        tags[CI_PIPELINE_NAME] = finalPipelineName
      }
    }

    if (env.GITLAB_CI) {
      const {
        CI_PIPELINE_ID: GITLAB_PIPELINE_ID,
        CI_PROJECT_PATH,
        CI_PIPELINE_IID,
        CI_PIPELINE_URL: GITLAB_PIPELINE_URL,
        CI_PROJECT_DIR,
        CI_COMMIT_REF_NAME,
        CI_COMMIT_TAG,
        CI_COMMIT_SHA,
        CI_REPOSITORY_URL,
        CI_JOB_URL: GITLAB_CI_JOB_URL,
        CI_JOB_STAGE,
        CI_JOB_NAME: GITLAB_CI_JOB_NAME,
        CI_COMMIT_MESSAGE,
        CI_COMMIT_TIMESTAMP,
        CI_COMMIT_AUTHOR
      } = env

      const { name, email } = parseEmailAndName(CI_COMMIT_AUTHOR)

      tags = {
        [CI_PIPELINE_ID]: GITLAB_PIPELINE_ID,
        [CI_PIPELINE_NAME]: CI_PROJECT_PATH,
        [CI_PIPELINE_NUMBER]: CI_PIPELINE_IID,
        [CI_PROVIDER_NAME]: 'gitlab',
        [GIT_COMMIT_SHA]: CI_COMMIT_SHA,
        [GIT_REPOSITORY_URL]: CI_REPOSITORY_URL,
        [CI_JOB_URL]: GITLAB_CI_JOB_URL,
        [GIT_TAG]: CI_COMMIT_TAG,
        [GIT_BRANCH]: CI_COMMIT_REF_NAME,
        [CI_WORKSPACE_PATH]: CI_PROJECT_DIR,
        [CI_PIPELINE_URL]: GITLAB_PIPELINE_URL && GITLAB_PIPELINE_URL.replace('/-/pipelines/', '/pipelines/'),
        [CI_STAGE_NAME]: CI_JOB_STAGE,
        [CI_JOB_NAME]: GITLAB_CI_JOB_NAME,
        [GIT_COMMIT_MESSAGE]: CI_COMMIT_MESSAGE,
        [GIT_COMMIT_AUTHOR_NAME]: name,
        [GIT_COMMIT_AUTHOR_EMAIL]: email,
        [GIT_COMMIT_AUTHOR_DATE]: CI_COMMIT_TIMESTAMP
      }
    }

    if (env.CIRCLECI) {
      const {
        CIRCLE_WORKFLOW_ID,
        CIRCLE_PROJECT_REPONAME,
        CIRCLE_BUILD_URL,
        CIRCLE_WORKING_DIRECTORY,
        CIRCLE_BRANCH,
        CIRCLE_TAG,
        CIRCLE_SHA1,
        CIRCLE_REPOSITORY_URL,
        CIRCLE_JOB
      } = env

      const pipelineUrl = `https://app.circleci.com/pipelines/workflows/${CIRCLE_WORKFLOW_ID}`

      tags = {
        [CI_PIPELINE_ID]: CIRCLE_WORKFLOW_ID,
        [CI_PIPELINE_NAME]: CIRCLE_PROJECT_REPONAME,
        [CI_PIPELINE_URL]: pipelineUrl,
        [CI_JOB_NAME]: CIRCLE_JOB,
        [CI_PROVIDER_NAME]: 'circleci',
        [GIT_COMMIT_SHA]: CIRCLE_SHA1,
        [GIT_REPOSITORY_URL]: CIRCLE_REPOSITORY_URL,
        [CI_JOB_URL]: CIRCLE_BUILD_URL,
        [CI_WORKSPACE_PATH]: CIRCLE_WORKING_DIRECTORY,
        [CIRCLE_TAG ? GIT_TAG : GIT_BRANCH]: CIRCLE_TAG || CIRCLE_BRANCH
      }
    }

    if (env.GITHUB_ACTIONS || env.GITHUB_ACTION) {
      const {
        GITHUB_RUN_ID,
        GITHUB_WORKFLOW,
        GITHUB_RUN_NUMBER,
        GITHUB_WORKSPACE,
        GITHUB_HEAD_REF,
        GITHUB_REF,
        GITHUB_SHA,
        GITHUB_REPOSITORY,
        GITHUB_SERVER_URL,
        GITHUB_RUN_ATTEMPT
      } = env

      const repositoryURL = `${GITHUB_SERVER_URL}/${GITHUB_REPOSITORY}.git`
      let pipelineURL = `${GITHUB_SERVER_URL}/${GITHUB_REPOSITORY}/actions/runs/${GITHUB_RUN_ID}`

      if (GITHUB_RUN_ATTEMPT) {
        pipelineURL = `${pipelineURL}/attempts/${GITHUB_RUN_ATTEMPT}`
      }

      const jobUrl = `${GITHUB_SERVER_URL}/${GITHUB_REPOSITORY}/commit/${GITHUB_SHA}/checks`

      const ref = GITHUB_HEAD_REF || GITHUB_REF || ''
      const refKey = ref.includes('tags') ? GIT_TAG : GIT_BRANCH

      tags = {
        [CI_PIPELINE_ID]: GITHUB_RUN_ID,
        [CI_PIPELINE_NAME]: GITHUB_WORKFLOW,
        [CI_PIPELINE_NUMBER]: GITHUB_RUN_NUMBER,
        [CI_PIPELINE_URL]: pipelineURL,
        [CI_PROVIDER_NAME]: 'github',
        [GIT_COMMIT_SHA]: GITHUB_SHA,
        [GIT_REPOSITORY_URL]: repositoryURL,
        [CI_JOB_URL]: jobUrl,
        [CI_WORKSPACE_PATH]: GITHUB_WORKSPACE,
        [refKey]: ref
      }
    }

    if (env.APPVEYOR) {
      const {
        APPVEYOR_REPO_NAME,
        APPVEYOR_REPO_PROVIDER,
        APPVEYOR_BUILD_FOLDER,
        APPVEYOR_BUILD_ID,
        APPVEYOR_BUILD_NUMBER,
        APPVEYOR_REPO_COMMIT,
        APPVEYOR_PULL_REQUEST_HEAD_REPO_BRANCH,
        APPVEYOR_REPO_BRANCH,
        APPVEYOR_REPO_TAG_NAME,
        APPVEYOR_REPO_COMMIT_AUTHOR,
        APPVEYOR_REPO_COMMIT_AUTHOR_EMAIL,
        APPVEYOR_REPO_COMMIT_MESSAGE_EXTENDED
      } = env

      const pipelineUrl = `https://ci.appveyor.com/project/${APPVEYOR_REPO_NAME}/builds/${APPVEYOR_BUILD_ID}`

      tags = {
        [CI_PROVIDER_NAME]: 'appveyor',
        [CI_PIPELINE_URL]: pipelineUrl,
        [CI_PIPELINE_ID]: APPVEYOR_BUILD_ID,
        [CI_PIPELINE_NAME]: APPVEYOR_REPO_NAME,
        [CI_PIPELINE_NUMBER]: APPVEYOR_BUILD_NUMBER,
        [CI_JOB_URL]: pipelineUrl,
        [CI_WORKSPACE_PATH]: APPVEYOR_BUILD_FOLDER,
        [GIT_COMMIT_AUTHOR_NAME]: APPVEYOR_REPO_COMMIT_AUTHOR,
        [GIT_COMMIT_AUTHOR_EMAIL]: APPVEYOR_REPO_COMMIT_AUTHOR_EMAIL,
        [GIT_COMMIT_MESSAGE]: APPVEYOR_REPO_COMMIT_MESSAGE_EXTENDED
      }

      if (APPVEYOR_REPO_PROVIDER === 'github') {
        const refKey = APPVEYOR_REPO_TAG_NAME ? GIT_TAG : GIT_BRANCH
        const ref = APPVEYOR_REPO_TAG_NAME || APPVEYOR_PULL_REQUEST_HEAD_REPO_BRANCH || APPVEYOR_REPO_BRANCH
        tags = {
          ...tags,
          [GIT_REPOSITORY_URL]: `https://github.com/${APPVEYOR_REPO_NAME}.git`,
          [GIT_COMMIT_SHA]: APPVEYOR_REPO_COMMIT,
          [refKey]: ref
        }
      }
    }

    if (env.TF_BUILD) {
      const {
        BUILD_SOURCESDIRECTORY,
        BUILD_BUILDID,
        BUILD_DEFINITIONNAME,
        SYSTEM_TEAMFOUNDATIONSERVERURI,
        SYSTEM_TEAMPROJECTID,
        SYSTEM_JOBID,
        SYSTEM_TASKINSTANCEID,
        SYSTEM_PULLREQUEST_SOURCEBRANCH,
        BUILD_SOURCEBRANCH,
        BUILD_SOURCEBRANCHNAME,
        SYSTEM_PULLREQUEST_SOURCECOMMITID,
        SYSTEM_PULLREQUEST_SOURCEREPOSITORYURI,
        BUILD_REPOSITORY_URI,
        BUILD_SOURCEVERSION,
        BUILD_REQUESTEDFORID,
        BUILD_REQUESTEDFOREMAIL,
        BUILD_SOURCEVERSIONMESSAGE,
        SYSTEM_STAGEDISPLAYNAME,
        SYSTEM_JOBDISPLAYNAME
      } = env

      const ref = SYSTEM_PULLREQUEST_SOURCEBRANCH || BUILD_SOURCEBRANCH || BUILD_SOURCEBRANCHNAME
      const refKey = (ref || '').includes('tags') ? GIT_TAG : GIT_BRANCH

      tags = {
        [CI_PROVIDER_NAME]: 'azurepipelines',
        [CI_PIPELINE_ID]: BUILD_BUILDID,
        [CI_PIPELINE_NAME]: BUILD_DEFINITIONNAME,
        [CI_PIPELINE_NUMBER]: BUILD_BUILDID,
        [GIT_COMMIT_SHA]: SYSTEM_PULLREQUEST_SOURCECOMMITID || BUILD_SOURCEVERSION,
        [CI_WORKSPACE_PATH]: BUILD_SOURCESDIRECTORY,
        [GIT_REPOSITORY_URL]: SYSTEM_PULLREQUEST_SOURCEREPOSITORYURI || BUILD_REPOSITORY_URI,
        [refKey]: ref,
        [GIT_COMMIT_AUTHOR_NAME]: BUILD_REQUESTEDFORID,
        [GIT_COMMIT_AUTHOR_EMAIL]: BUILD_REQUESTEDFOREMAIL,
        [GIT_COMMIT_MESSAGE]: BUILD_SOURCEVERSIONMESSAGE,
        [CI_STAGE_NAME]: SYSTEM_STAGEDISPLAYNAME,
        [CI_JOB_NAME]: SYSTEM_JOBDISPLAYNAME
      }

      if (SYSTEM_TEAMFOUNDATIONSERVERURI && SYSTEM_TEAMPROJECTID && BUILD_BUILDID) {
        const baseUrl =
          `${SYSTEM_TEAMFOUNDATIONSERVERURI}${SYSTEM_TEAMPROJECTID}/_build/results?buildId=${BUILD_BUILDID}`
        const pipelineUrl = baseUrl
        const jobUrl = `${baseUrl}&view=logs&j=${SYSTEM_JOBID}&t=${SYSTEM_TASKINSTANCEID}`

        tags = {
          ...tags,
          [CI_PIPELINE_URL]: pipelineUrl,
          [CI_JOB_URL]: jobUrl
        }
      }
    }

    if (env.BITBUCKET_COMMIT) {
      const {
        BITBUCKET_REPO_FULL_NAME,
        BITBUCKET_BUILD_NUMBER,
        BITBUCKET_BRANCH,
        BITBUCKET_COMMIT,
        BITBUCKET_GIT_SSH_ORIGIN,
        BITBUCKET_TAG,
        BITBUCKET_PIPELINE_UUID,
        BITBUCKET_CLONE_DIR
      } = env

      const url =
        `https://bitbucket.org/${BITBUCKET_REPO_FULL_NAME}/addon/pipelines/home#!/results/${BITBUCKET_BUILD_NUMBER}`

      tags = {
        [CI_PROVIDER_NAME]: 'bitbucket',
        [GIT_COMMIT_SHA]: BITBUCKET_COMMIT,
        [CI_PIPELINE_NUMBER]: BITBUCKET_BUILD_NUMBER,
        [CI_PIPELINE_NAME]: BITBUCKET_REPO_FULL_NAME,
        [CI_JOB_URL]: url,
        [CI_PIPELINE_URL]: url,
        [GIT_BRANCH]: BITBUCKET_BRANCH,
        [GIT_TAG]: BITBUCKET_TAG,
        [GIT_REPOSITORY_URL]: BITBUCKET_GIT_SSH_ORIGIN,
        [CI_WORKSPACE_PATH]: BITBUCKET_CLONE_DIR,
        [CI_PIPELINE_ID]: BITBUCKET_PIPELINE_UUID && BITBUCKET_PIPELINE_UUID.replace(/{|}/gm, '')
      }
    }

    if (env.BITRISE_BUILD_SLUG) {
      const {
        BITRISE_GIT_COMMIT,
        GIT_CLONE_COMMIT_HASH,
        BITRISEIO_GIT_BRANCH_DEST,
        BITRISE_GIT_BRANCH,
        BITRISE_BUILD_SLUG,
        BITRISE_TRIGGERED_WORKFLOW_ID,
        BITRISE_BUILD_NUMBER,
        BITRISE_BUILD_URL,
        BITRISE_SOURCE_DIR,
        GIT_REPOSITORY_URL: BITRISE_GIT_REPOSITORY_URL,
        BITRISE_GIT_TAG,
        BITRISE_GIT_MESSAGE
      } = env

      const isTag = !!BITRISE_GIT_TAG
      const refKey = isTag ? GIT_TAG : GIT_BRANCH
      const ref = BITRISE_GIT_TAG || BITRISEIO_GIT_BRANCH_DEST || BITRISE_GIT_BRANCH

      tags = {
        [CI_PROVIDER_NAME]: 'bitrise',
        [CI_PIPELINE_ID]: BITRISE_BUILD_SLUG,
        [CI_PIPELINE_NAME]: BITRISE_TRIGGERED_WORKFLOW_ID,
        [CI_PIPELINE_NUMBER]: BITRISE_BUILD_NUMBER,
        [CI_PIPELINE_URL]: BITRISE_BUILD_URL,
        [GIT_COMMIT_SHA]: BITRISE_GIT_COMMIT || GIT_CLONE_COMMIT_HASH,
        [GIT_REPOSITORY_URL]: BITRISE_GIT_REPOSITORY_URL,
        [CI_WORKSPACE_PATH]: BITRISE_SOURCE_DIR,
        [refKey]: ref,
        [GIT_COMMIT_MESSAGE]: BITRISE_GIT_MESSAGE
      }
    }

    if (env.BUILDKITE) {
      const {
        BUILDKITE_BRANCH,
        BUILDKITE_COMMIT,
        BUILDKITE_REPO,
        BUILDKITE_TAG,
        BUILDKITE_BUILD_ID,
        BUILDKITE_PIPELINE_SLUG,
        BUILDKITE_BUILD_NUMBER,
        BUILDKITE_BUILD_URL,
        BUILDKITE_JOB_ID,
        BUILDKITE_BUILD_CHECKOUT_PATH,
        BUILDKITE_BUILD_AUTHOR,
        BUILDKITE_BUILD_AUTHOR_EMAIL,
        BUILDKITE_MESSAGE
      } = env

      const ref = BUILDKITE_TAG || BUILDKITE_BRANCH
      const refKey = BUILDKITE_TAG ? GIT_TAG : GIT_BRANCH

      tags = {
        [CI_PROVIDER_NAME]: 'buildkite',
        [CI_PIPELINE_ID]: BUILDKITE_BUILD_ID,
        [CI_PIPELINE_NAME]: BUILDKITE_PIPELINE_SLUG,
        [CI_PIPELINE_NUMBER]: BUILDKITE_BUILD_NUMBER,
        [CI_PIPELINE_URL]: BUILDKITE_BUILD_URL,
        [CI_JOB_URL]: `${BUILDKITE_BUILD_URL}#${BUILDKITE_JOB_ID}`,
        [GIT_COMMIT_SHA]: BUILDKITE_COMMIT,
        [CI_WORKSPACE_PATH]: BUILDKITE_BUILD_CHECKOUT_PATH,
        [GIT_REPOSITORY_URL]: BUILDKITE_REPO,
        [refKey]: ref,
        [GIT_COMMIT_AUTHOR_NAME]: BUILDKITE_BUILD_AUTHOR,
        [GIT_COMMIT_AUTHOR_EMAIL]: BUILDKITE_BUILD_AUTHOR_EMAIL,
        [GIT_COMMIT_MESSAGE]: BUILDKITE_MESSAGE
      }
    }

    if (env.TRAVIS) {
      const {
        TRAVIS_PULL_REQUEST_BRANCH,
        TRAVIS_BRANCH,
        TRAVIS_COMMIT,
        TRAVIS_REPO_SLUG,
        TRAVIS_TAG,
        TRAVIS_JOB_WEB_URL,
        TRAVIS_BUILD_ID,
        TRAVIS_BUILD_NUMBER,
        TRAVIS_BUILD_WEB_URL,
        TRAVIS_BUILD_DIR,
        TRAVIS_COMMIT_MESSAGE
      } = env

      const isTag = !!TRAVIS_TAG
      const ref = TRAVIS_TAG || TRAVIS_PULL_REQUEST_BRANCH || TRAVIS_BRANCH
      const refKey = isTag ? GIT_TAG : GIT_BRANCH

      tags = {
        [CI_PROVIDER_NAME]: 'travisci',
        [CI_JOB_URL]: TRAVIS_JOB_WEB_URL,
        [CI_PIPELINE_ID]: TRAVIS_BUILD_ID,
        [CI_PIPELINE_NAME]: TRAVIS_REPO_SLUG,
        [CI_PIPELINE_NUMBER]: TRAVIS_BUILD_NUMBER,
        [CI_PIPELINE_URL]: TRAVIS_BUILD_WEB_URL,
        [GIT_COMMIT_SHA]: TRAVIS_COMMIT,
        [GIT_REPOSITORY_URL]: `https://github.com/${TRAVIS_REPO_SLUG}.git`,
        [CI_WORKSPACE_PATH]: TRAVIS_BUILD_DIR,
        [refKey]: ref,
        [GIT_COMMIT_MESSAGE]: TRAVIS_COMMIT_MESSAGE
      }
    }

    normalizeTag(tags, CI_WORKSPACE_PATH, resolveTilde)
    normalizeTag(tags, GIT_REPOSITORY_URL, filterSensitiveInfoFromRepository)
    normalizeTag(tags, GIT_BRANCH, normalizeRef)
    normalizeTag(tags, GIT_TAG, normalizeRef)

    return removeEmptyValues(tags)
  }
}


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/plugins/util/env.js":
/*!**********************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/plugins/util/env.js ***!
  \**********************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

const os = __webpack_require__(/*! os */ "os")

const OS_PLATFORM = 'os.platform'
const OS_VERSION = 'os.version'
const OS_ARCHITECTURE = 'os.architecture'
const RUNTIME_NAME = 'runtime.name'
const RUNTIME_VERSION = 'runtime.version'

function getRuntimeAndOSMetadata () {
  return {
    [RUNTIME_VERSION]: process.version,
    [OS_ARCHITECTURE]: process.arch,
    [OS_PLATFORM]: process.platform,
    [RUNTIME_NAME]: 'node',
    [OS_VERSION]: os.release()
  }
}

module.exports = {
  getRuntimeAndOSMetadata,
  OS_PLATFORM,
  OS_VERSION,
  OS_ARCHITECTURE,
  RUNTIME_NAME,
  RUNTIME_VERSION
}


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/plugins/util/exec.js":
/*!***********************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/plugins/util/exec.js ***!
  \***********************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

const { execSync } = __webpack_require__(/*! child_process */ "child_process")

const sanitizedExec = (cmd, options = {}) => {
  try {
    return execSync(cmd, options).toString().replace(/(\r\n|\n|\r)/gm, '')
  } catch (e) {
    return ''
  }
}

module.exports = { sanitizedExec }


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/plugins/util/git.js":
/*!**********************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/plugins/util/git.js ***!
  \**********************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

const { sanitizedExec } = __webpack_require__(/*! ./exec */ "../../node_modules/dd-trace/packages/dd-trace/src/plugins/util/exec.js")

const {
  GIT_COMMIT_SHA,
  GIT_BRANCH,
  GIT_REPOSITORY_URL,
  GIT_TAG,
  GIT_COMMIT_MESSAGE,
  GIT_COMMIT_COMMITTER_DATE,
  GIT_COMMIT_COMMITTER_EMAIL,
  GIT_COMMIT_COMMITTER_NAME,
  GIT_COMMIT_AUTHOR_DATE,
  GIT_COMMIT_AUTHOR_EMAIL,
  GIT_COMMIT_AUTHOR_NAME,
  CI_WORKSPACE_PATH
} = __webpack_require__(/*! ./tags */ "../../node_modules/dd-trace/packages/dd-trace/src/plugins/util/tags.js")

// If there is ciMetadata, it takes precedence.
function getGitMetadata (ciMetadata) {
  const {
    commitSHA,
    branch,
    repositoryUrl,
    tag,
    commitMessage,
    authorName: ciAuthorName,
    authorEmail: ciAuthorEmail,
    ciWorkspacePath
  } = ciMetadata

  // With stdio: 'pipe', errors in this command will not be output to the parent process,
  // so if `git` is not present in the env, we won't show a warning to the user.
  const [
    authorName,
    authorEmail,
    authorDate,
    committerName,
    committerEmail,
    committerDate
  ] = sanitizedExec('git show -s --format=%an,%ae,%aI,%cn,%ce,%cI', { stdio: 'pipe' }).split(',')

  return {
    [GIT_REPOSITORY_URL]:
      repositoryUrl || sanitizedExec('git ls-remote --get-url', { stdio: 'pipe' }),
    [GIT_COMMIT_MESSAGE]:
      commitMessage || sanitizedExec('git show -s --format=%s', { stdio: 'pipe' }),
    [GIT_COMMIT_AUTHOR_DATE]: authorDate,
    [GIT_COMMIT_AUTHOR_NAME]: ciAuthorName || authorName,
    [GIT_COMMIT_AUTHOR_EMAIL]: ciAuthorEmail || authorEmail,
    [GIT_COMMIT_COMMITTER_DATE]: committerDate,
    [GIT_COMMIT_COMMITTER_NAME]: committerName,
    [GIT_COMMIT_COMMITTER_EMAIL]: committerEmail,
    [GIT_BRANCH]: branch || sanitizedExec('git rev-parse --abbrev-ref HEAD', { stdio: 'pipe' }),
    [GIT_COMMIT_SHA]: commitSHA || sanitizedExec('git rev-parse HEAD', { stdio: 'pipe' }),
    [GIT_TAG]: tag,
    [CI_WORKSPACE_PATH]: ciWorkspacePath || sanitizedExec('git rev-parse --show-toplevel', { stdio: 'pipe' })
  }
}

module.exports = { getGitMetadata }


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/plugins/util/tags.js":
/*!***********************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/plugins/util/tags.js ***!
  \***********************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports) {

const GIT_COMMIT_SHA = 'git.commit.sha'
const GIT_BRANCH = 'git.branch'
const GIT_REPOSITORY_URL = 'git.repository_url'
const GIT_TAG = 'git.tag'
const GIT_COMMIT_MESSAGE = 'git.commit.message'
const GIT_COMMIT_COMMITTER_DATE = 'git.commit.committer.date'
const GIT_COMMIT_COMMITTER_EMAIL = 'git.commit.committer.email'
const GIT_COMMIT_COMMITTER_NAME = 'git.commit.committer.name'
const GIT_COMMIT_AUTHOR_DATE = 'git.commit.author.date'
const GIT_COMMIT_AUTHOR_EMAIL = 'git.commit.author.email'
const GIT_COMMIT_AUTHOR_NAME = 'git.commit.author.name'

const CI_PIPELINE_ID = 'ci.pipeline.id'
const CI_PIPELINE_NAME = 'ci.pipeline.name'
const CI_PIPELINE_NUMBER = 'ci.pipeline.number'
const CI_PIPELINE_URL = 'ci.pipeline.url'
const CI_PROVIDER_NAME = 'ci.provider.name'
const CI_WORKSPACE_PATH = 'ci.workspace_path'
const CI_JOB_URL = 'ci.job.url'
const CI_JOB_NAME = 'ci.job.name'
const CI_STAGE_NAME = 'ci.stage.name'

module.exports = {
  GIT_COMMIT_SHA,
  GIT_BRANCH,
  GIT_REPOSITORY_URL,
  GIT_TAG,
  GIT_COMMIT_MESSAGE,
  GIT_COMMIT_COMMITTER_DATE,
  GIT_COMMIT_COMMITTER_EMAIL,
  GIT_COMMIT_COMMITTER_NAME,
  GIT_COMMIT_AUTHOR_DATE,
  GIT_COMMIT_AUTHOR_EMAIL,
  GIT_COMMIT_AUTHOR_NAME,
  CI_PIPELINE_ID,
  CI_PIPELINE_NAME,
  CI_PIPELINE_NUMBER,
  CI_PIPELINE_URL,
  CI_PROVIDER_NAME,
  CI_WORKSPACE_PATH,
  CI_JOB_URL,
  CI_JOB_NAME,
  CI_STAGE_NAME
}


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/plugins/util/test.js":
/*!***********************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/plugins/util/test.js ***!
  \***********************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

const path = __webpack_require__(/*! path */ "path")
const fs = __webpack_require__(/*! fs */ "fs")

const ignore = __webpack_require__(/*! ignore */ "../../node_modules/dd-trace/node_modules/ignore/index.js")

const { getGitMetadata } = __webpack_require__(/*! ./git */ "../../node_modules/dd-trace/packages/dd-trace/src/plugins/util/git.js")
const { getUserProviderGitMetadata } = __webpack_require__(/*! ./user-provided-git */ "../../node_modules/dd-trace/packages/dd-trace/src/plugins/util/user-provided-git.js")
const { getCIMetadata } = __webpack_require__(/*! ./ci */ "../../node_modules/dd-trace/packages/dd-trace/src/plugins/util/ci.js")
const { getRuntimeAndOSMetadata } = __webpack_require__(/*! ./env */ "../../node_modules/dd-trace/packages/dd-trace/src/plugins/util/env.js")
const {
  GIT_BRANCH,
  GIT_COMMIT_SHA,
  GIT_REPOSITORY_URL,
  GIT_TAG,
  GIT_COMMIT_AUTHOR_EMAIL,
  GIT_COMMIT_AUTHOR_NAME,
  GIT_COMMIT_MESSAGE,
  CI_WORKSPACE_PATH
} = __webpack_require__(/*! ./tags */ "../../node_modules/dd-trace/packages/dd-trace/src/plugins/util/tags.js")
const id = __webpack_require__(/*! ../../id */ "../../node_modules/dd-trace/packages/dd-trace/src/id.js")

const TEST_FRAMEWORK = 'test.framework'
const TEST_FRAMEWORK_VERSION = 'test.framework_version'
const TEST_TYPE = 'test.type'
const TEST_NAME = 'test.name'
const TEST_SUITE = 'test.suite'
const TEST_STATUS = 'test.status'
const TEST_PARAMETERS = 'test.parameters'
const TEST_SKIP_REASON = 'test.skip_reason'
const TEST_IS_RUM_ACTIVE = 'test.is_rum_active'
const TEST_CODE_OWNERS = 'test.codeowners'

const ERROR_TYPE = 'error.type'
const ERROR_MESSAGE = 'error.msg'
const ERROR_STACK = 'error.stack'

const CI_APP_ORIGIN = 'ciapp-test'

const JEST_TEST_RUNNER = 'test.jest.test_runner'

module.exports = {
  TEST_CODE_OWNERS,
  TEST_FRAMEWORK,
  TEST_FRAMEWORK_VERSION,
  JEST_TEST_RUNNER,
  TEST_TYPE,
  TEST_NAME,
  TEST_SUITE,
  TEST_STATUS,
  TEST_PARAMETERS,
  TEST_SKIP_REASON,
  TEST_IS_RUM_ACTIVE,
  ERROR_TYPE,
  ERROR_MESSAGE,
  ERROR_STACK,
  CI_APP_ORIGIN,
  getTestEnvironmentMetadata,
  getTestParametersString,
  finishAllTraceSpans,
  getTestParentSpan,
  getTestSuitePath,
  getCodeOwnersFileEntries,
  getCodeOwnersForFilename
}

function getTestEnvironmentMetadata (testFramework, config) {
  // TODO: eventually these will come from the tracer (generally available)
  const ciMetadata = getCIMetadata()
  const {
    [GIT_COMMIT_SHA]: commitSHA,
    [GIT_BRANCH]: branch,
    [GIT_REPOSITORY_URL]: repositoryUrl,
    [GIT_TAG]: tag,
    [GIT_COMMIT_AUTHOR_NAME]: authorName,
    [GIT_COMMIT_AUTHOR_EMAIL]: authorEmail,
    [GIT_COMMIT_MESSAGE]: commitMessage,
    [CI_WORKSPACE_PATH]: ciWorkspacePath
  } = ciMetadata

  const gitMetadata = getGitMetadata({
    commitSHA,
    branch,
    repositoryUrl,
    tag,
    authorName,
    authorEmail,
    commitMessage,
    ciWorkspacePath
  })

  const userProvidedGitMetadata = getUserProviderGitMetadata()

  const runtimeAndOSMetadata = getRuntimeAndOSMetadata()

  const metadata = {
    [TEST_FRAMEWORK]: testFramework,
    ...gitMetadata,
    ...ciMetadata,
    ...userProvidedGitMetadata,
    ...runtimeAndOSMetadata
  }
  if (config && config.service) {
    metadata['service.name'] = config.service
  }
  return metadata
}

function getTestParametersString (parametersByTestName, testName) {
  if (!parametersByTestName[testName]) {
    return ''
  }
  try {
    // test is invoked with each parameter set sequencially
    const testParameters = parametersByTestName[testName].shift()
    return JSON.stringify({ arguments: testParameters, metadata: {} })
  } catch (e) {
    // We can't afford to interrupt the test if `testParameters` is not serializable to JSON,
    // so we ignore the test parameters and move on
    return ''
  }
}

function finishAllTraceSpans (span) {
  span.context()._trace.started.forEach(traceSpan => {
    if (traceSpan !== span) {
      traceSpan.finish()
    }
  })
}

function getTestParentSpan (tracer) {
  return tracer.extract('text_map', {
    'x-datadog-trace-id': id().toString(10),
    'x-datadog-parent-id': '0000000000000000'
  })
}
/**
 * We want to make sure that test suites are reported the same way for
 * every OS, so we replace `path.sep` by `/`
 */
function getTestSuitePath (testSuiteAbsolutePath, sourceRoot) {
  if (!testSuiteAbsolutePath) {
    return sourceRoot
  }
  const testSuitePath = testSuiteAbsolutePath === sourceRoot
    ? testSuiteAbsolutePath : path.relative(sourceRoot, testSuiteAbsolutePath)

  return testSuitePath.replace(path.sep, '/')
}

const POSSIBLE_CODEOWNERS_LOCATIONS = [
  'CODEOWNERS',
  '.github/CODEOWNERS',
  'docs/CODEOWNERS',
  '.gitlab/CODEOWNERS'
]

function getCodeOwnersFileEntries (rootDir = process.cwd()) {
  let codeOwnersContent

  POSSIBLE_CODEOWNERS_LOCATIONS.forEach(location => {
    try {
      codeOwnersContent = fs.readFileSync(`${rootDir}/${location}`).toString()
    } catch (e) {
      // retry with next path
    }
  })
  if (!codeOwnersContent) {
    return null
  }

  const entries = []
  const lines = codeOwnersContent.split('\n')

  for (const line of lines) {
    const [content] = line.split('#')
    const trimmed = content.trim()
    if (trimmed === '') continue
    const [pattern, ...owners] = trimmed.split(/\s+/)
    entries.push({ pattern, owners })
  }
  // Reverse because rules defined last take precedence
  return entries.reverse()
}

function getCodeOwnersForFilename (filename, entries) {
  if (!entries) {
    return null
  }
  for (const entry of entries) {
    try {
      const isResponsible = ignore().add(entry.pattern).ignores(filename)
      if (isResponsible) {
        return JSON.stringify(entry.owners)
      }
    } catch (e) {
      return null
    }
  }
  return null
}


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/plugins/util/urlfilter.js":
/*!****************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/plugins/util/urlfilter.js ***!
  \****************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const log = __webpack_require__(/*! ../../log */ "../../node_modules/dd-trace/packages/dd-trace/src/log.js")

const urlFilter = {
  getFilter (config) {
    if (typeof config.filter === 'function') {
      return config.filter
    } else if (config.hasOwnProperty('filter')) {
      log.error('Expected `filter` to be a function. Overriding filter property to default.')
    }

    const allowlist = config.allowlist || config.whitelist || /.*/
    const blocklist = config.blocklist || config.blacklist || []

    return uri => {
      const allowed = applyFilter(allowlist, uri)
      const blocked = applyFilter(blocklist, uri)
      return allowed && !blocked
    }

    function applyFilter (filter, uri) {
      if (typeof filter === 'function') {
        return filter(uri)
      } else if (filter instanceof RegExp) {
        return filter.test(uri)
      } else if (filter instanceof Array) {
        return filter.some(filter => applyFilter(filter, uri))
      }

      return filter === uri
    }
  }
}

module.exports = urlFilter


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/plugins/util/user-provided-git.js":
/*!************************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/plugins/util/user-provided-git.js ***!
  \************************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

const {
  GIT_COMMIT_SHA,
  GIT_BRANCH,
  GIT_REPOSITORY_URL,
  GIT_TAG,
  GIT_COMMIT_MESSAGE,
  GIT_COMMIT_COMMITTER_DATE,
  GIT_COMMIT_COMMITTER_EMAIL,
  GIT_COMMIT_COMMITTER_NAME,
  GIT_COMMIT_AUTHOR_DATE,
  GIT_COMMIT_AUTHOR_EMAIL,
  GIT_COMMIT_AUTHOR_NAME
} = __webpack_require__(/*! ./tags */ "../../node_modules/dd-trace/packages/dd-trace/src/plugins/util/tags.js")

const { normalizeRef } = __webpack_require__(/*! ./ci */ "../../node_modules/dd-trace/packages/dd-trace/src/plugins/util/ci.js")

function removeEmptyValues (tags) {
  return Object.keys(tags).reduce((filteredTags, tag) => {
    if (!tags[tag]) {
      return filteredTags
    }
    return {
      ...filteredTags,
      [tag]: tags[tag]
    }
  }, {})
}

function getUserProviderGitMetadata () {
  const {
    DD_GIT_COMMIT_SHA,
    DD_GIT_BRANCH,
    DD_GIT_REPOSITORY_URL,
    DD_GIT_TAG,
    DD_GIT_COMMIT_MESSAGE,
    DD_GIT_COMMIT_COMMITTER_NAME,
    DD_GIT_COMMIT_COMMITTER_EMAIL,
    DD_GIT_COMMIT_COMMITTER_DATE,
    DD_GIT_COMMIT_AUTHOR_NAME,
    DD_GIT_COMMIT_AUTHOR_EMAIL,
    DD_GIT_COMMIT_AUTHOR_DATE
  } = process.env

  let branch = normalizeRef(DD_GIT_BRANCH)
  let tag = normalizeRef(DD_GIT_TAG)

  if (DD_GIT_TAG) {
    branch = undefined
  }

  // if DD_GIT_BRANCH is a tag, we associate its value to TAG instead of BRANCH
  if ((DD_GIT_BRANCH || '').includes('origin/tags') || (DD_GIT_BRANCH || '').includes('refs/heads/tags')) {
    branch = undefined
    tag = normalizeRef(DD_GIT_BRANCH)
  }

  return removeEmptyValues({
    [GIT_COMMIT_SHA]: DD_GIT_COMMIT_SHA,
    [GIT_BRANCH]: branch,
    [GIT_REPOSITORY_URL]: DD_GIT_REPOSITORY_URL,
    [GIT_TAG]: tag,
    [GIT_COMMIT_MESSAGE]: DD_GIT_COMMIT_MESSAGE,
    [GIT_COMMIT_COMMITTER_NAME]: DD_GIT_COMMIT_COMMITTER_NAME,
    [GIT_COMMIT_COMMITTER_DATE]: DD_GIT_COMMIT_COMMITTER_DATE,
    [GIT_COMMIT_COMMITTER_EMAIL]: DD_GIT_COMMIT_COMMITTER_EMAIL,
    [GIT_COMMIT_AUTHOR_NAME]: DD_GIT_COMMIT_AUTHOR_NAME,
    [GIT_COMMIT_AUTHOR_EMAIL]: DD_GIT_COMMIT_AUTHOR_EMAIL,
    [GIT_COMMIT_AUTHOR_DATE]: DD_GIT_COMMIT_AUTHOR_DATE
  })
}

module.exports = { getUserProviderGitMetadata }


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/plugins/util/web.js":
/*!**********************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/plugins/util/web.js ***!
  \**********************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const uniq = __webpack_require__(/*! lodash.uniq */ "../../node_modules/lodash.uniq/index.js")
const analyticsSampler = __webpack_require__(/*! ../../analytics_sampler */ "../../node_modules/dd-trace/packages/dd-trace/src/analytics_sampler.js")
const FORMAT_HTTP_HEADERS = __webpack_require__(/*! opentracing */ "../../node_modules/opentracing/lib/index.js").FORMAT_HTTP_HEADERS
const log = __webpack_require__(/*! ../../log */ "../../node_modules/dd-trace/packages/dd-trace/src/log.js")
const tags = __webpack_require__(/*! ../../../../../ext/tags */ "../../node_modules/dd-trace/ext/tags.js")
const types = __webpack_require__(/*! ../../../../../ext/types */ "../../node_modules/dd-trace/ext/types.js")
const kinds = __webpack_require__(/*! ../../../../../ext/kinds */ "../../node_modules/dd-trace/ext/kinds.js")
const urlFilter = __webpack_require__(/*! ./urlfilter */ "../../node_modules/dd-trace/packages/dd-trace/src/plugins/util/urlfilter.js")
const { incomingHttpRequestEnd } = __webpack_require__(/*! ../../appsec/gateway/channels */ "../../node_modules/dd-trace/packages/dd-trace/src/appsec/gateway/channels.js")

const WEB = types.WEB
const SERVER = kinds.SERVER
const RESOURCE_NAME = tags.RESOURCE_NAME
const SERVICE_NAME = tags.SERVICE_NAME
const SPAN_TYPE = tags.SPAN_TYPE
const SPAN_KIND = tags.SPAN_KIND
const ERROR = tags.ERROR
const HTTP_METHOD = tags.HTTP_METHOD
const HTTP_URL = tags.HTTP_URL
const HTTP_STATUS_CODE = tags.HTTP_STATUS_CODE
const HTTP_ROUTE = tags.HTTP_ROUTE
const HTTP_REQUEST_HEADERS = tags.HTTP_REQUEST_HEADERS
const HTTP_RESPONSE_HEADERS = tags.HTTP_RESPONSE_HEADERS
const MANUAL_DROP = tags.MANUAL_DROP

const HTTP2_HEADER_AUTHORITY = ':authority'
const HTTP2_HEADER_SCHEME = ':scheme'
const HTTP2_HEADER_PATH = ':path'

const contexts = new WeakMap()
const ends = new WeakMap()

const web = {
  // Ensure the configuration has the correct structure and defaults.
  normalizeConfig (config) {
    config = config.server || config

    const headers = getHeadersToRecord(config)
    const validateStatus = getStatusValidator(config)
    const hooks = getHooks(config)
    const filter = urlFilter.getFilter(config)
    const middleware = getMiddlewareSetting(config)

    return Object.assign({}, config, {
      headers,
      validateStatus,
      hooks,
      filter,
      middleware
    })
  },

  startSpan (tracer, config, req, res, name) {
    const context = this.patch(req)
    context.config = config

    let span

    if (context.span) {
      context.span.context()._name = name
      span = context.span
    } else {
      span = web.startChildSpan(tracer, name, req.headers)
    }

    context.tracer = tracer
    context.span = span
    context.res = res

    return span
  },
  wrap (req) {
    const context = contexts.get(req)
    if (!context.instrumented) {
      this.wrapEnd(context)
      this.wrapEvents(context)
      context.instrumented = true
    }
  },
  // Start a span and activate a scope for a request.
  instrument (tracer, config, req, res, name, callback) {
    const span = this.startSpan(tracer, config, req, res, name)

    if (!config.filter(req.url)) {
      span.setTag(MANUAL_DROP, true)
    }

    if (config.service) {
      span.setTag(SERVICE_NAME, config.service)
    }

    analyticsSampler.sample(span, config.measured, true)

    this.wrap(req)

    return callback && tracer.scope().activate(span, () => callback(span))
  },

  // Reactivate the request scope in case it was changed by a middleware.
  reactivate (req, fn) {
    return reactivate(req, fn)
  },

  // Add a route segment that will be used for the resource name.
  enterRoute (req, path) {
    if (typeof path === 'string') {
      contexts.get(req).paths.push(path)
    }
  },

  // Remove the current route segment.
  exitRoute (req) {
    contexts.get(req).paths.pop()
  },

  // Start a new middleware span and activate a new scope with the span.
  wrapMiddleware (req, middleware, name, fn) {
    if (!this.active(req)) return fn()

    const context = contexts.get(req)
    const tracer = context.tracer
    const childOf = this.active(req)
    const config = context.config

    if (config.middleware === false) return this.bindAndWrapMiddlewareErrors(fn, req, tracer, childOf)

    const span = tracer.startSpan(name, { childOf })

    analyticsSampler.sample(span, config.measured)

    span.addTags({
      [RESOURCE_NAME]: middleware._name || middleware.name || '<anonymous>'
    })

    context.middleware.push(span)

    return tracer.scope().activate(span, fn)
  },

  // catch errors and apply to active span
  bindAndWrapMiddlewareErrors (fn, req, tracer, activeSpan) {
    try {
      return tracer.scope().bind(fn, activeSpan).apply(this, arguments)
    } catch (e) {
      web.addError(req, e) // TODO: remove when error formatting is moved to Span
      throw e
    }
  },

  // Finish the active middleware span.
  finish (req, error) {
    if (!this.active(req)) return

    const context = contexts.get(req)
    const span = context.middleware.pop()

    if (span) {
      if (error) {
        span.addTags({
          'error.type': error.name,
          'error.msg': error.message,
          'error.stack': error.stack
        })
      }

      span.finish()
    }
  },

  // Register a callback to run before res.end() is called.
  beforeEnd (req, callback) {
    contexts.get(req).beforeEnd.push(callback)
  },

  // Prepare the request for instrumentation.
  patch (req) {
    let context = contexts.get(req)

    if (context) return context

    context = req.stream && contexts.get(req.stream)

    if (context) {
      contexts.set(req, context)
      return context
    }

    context = {
      req,
      span: null,
      paths: [],
      middleware: [],
      beforeEnd: [],
      config: {}
    }

    contexts.set(req, context)

    return context
  },

  // Return the request root span.
  root (req) {
    const context = contexts.get(req)
    return context ? context.span : null
  },

  // Return the active span.
  active (req) {
    const context = contexts.get(req)

    if (!context) return null
    if (context.middleware.length === 0) return context.span || null

    return context.middleware.slice(-1)[0]
  },

  // Extract the parent span from the headers and start a new span as its child
  startChildSpan (tracer, name, headers) {
    const childOf = tracer.scope().active() || tracer.extract(FORMAT_HTTP_HEADERS, headers)

    const span = tracer.startSpan(name, { childOf })

    return span
  },

  // Validate a request's status code and then add error tags if necessary
  addStatusError (req, statusCode) {
    const context = contexts.get(req)
    const span = context.span
    const error = context.error

    if (!context.config.validateStatus(statusCode)) {
      span.setTag(ERROR, error || true)
    }
  },

  // Add an error to the request
  addError (req, error) {
    if (error instanceof Error) {
      const context = contexts.get(req)
      context.error = context.error || error
    }
  },

  finishMiddleware (context) {
    if (context.finished) return

    let span

    while ((span = context.middleware.pop())) {
      span.finish()
    }
  },

  finishSpan (context) {
    const { req, res } = context

    if (context.finished && !req.stream) return

    addRequestTags(context)
    addResponseTags(context)

    context.config.hooks.request(context.span, req, res)
    addResourceTag(context)

    context.span.finish()
    context.finished = true
  },
  wrapWriteHead (context) {
    const { req, res } = context
    const writeHead = res.writeHead

    return function (statusCode, statusMessage, headers) {
      headers = typeof statusMessage === 'string' ? headers : statusMessage
      headers = Object.assign(res.getHeaders(), headers)

      if (req.method.toLowerCase() === 'options' && isOriginAllowed(req, headers)) {
        addAllowHeaders(req, res, headers)
      }

      return writeHead.apply(this, arguments)
    }
  },
  getContext (req) {
    return contexts.get(req)
  },
  wrapRes (context, req, res, end) {
    return function () {
      for (const beforeEnd of context.beforeEnd) {
        beforeEnd()
      }

      web.finishMiddleware(context)

      if (incomingHttpRequestEnd.hasSubscribers) {
        incomingHttpRequestEnd.publish({ req, res })
      }

      const returnValue = end.apply(res, arguments)

      web.finishSpan(context)

      return returnValue
    }
  },
  wrapEnd (context) {
    const scope = context.tracer.scope()
    const req = context.req
    const res = context.res
    const end = res.end

    res.writeHead = web.wrapWriteHead(context)

    ends.set(res, this.wrapRes(context, req, res, end))

    Object.defineProperty(res, 'end', {
      configurable: true,
      get () {
        return ends.get(this)
      },
      set (value) {
        ends.set(this, scope.bind(value, context.span))
      }
    })
  },
  wrapEvents (context) {
    const scope = context.tracer.scope()
    const res = context.res

    scope.bind(res, context.span)
  }
}

function addAllowHeaders (req, res, headers) {
  const allowHeaders = splitHeader(headers['access-control-allow-headers'])
  const requestHeaders = splitHeader(req.headers['access-control-request-headers'])
  const contextHeaders = [
    'x-datadog-origin',
    'x-datadog-parent-id',
    'x-datadog-sampled', // Deprecated, but still accept it in case it's sent.
    'x-datadog-sampling-priority',
    'x-datadog-trace-id'
  ]

  for (const header of contextHeaders) {
    if (~requestHeaders.indexOf(header)) {
      allowHeaders.push(header)
    }
  }

  if (allowHeaders.length > 0) {
    res.setHeader('access-control-allow-headers', uniq(allowHeaders).join(','))
  }
}

function isOriginAllowed (req, headers) {
  const origin = req.headers['origin']
  const allowOrigin = headers['access-control-allow-origin']

  return origin && (allowOrigin === '*' || allowOrigin === origin)
}

function splitHeader (str) {
  return typeof str === 'string' ? str.split(/\s*,\s*/) : []
}

function reactivate (req, fn) {
  const context = contexts.get(req)

  return context
    ? context.tracer.scope().activate(context.span, fn)
    : fn()
}

function addRequestTags (context) {
  const { req, span } = context
  const url = extractURL(req)

  span.addTags({
    [HTTP_URL]: url.split('?')[0],
    [HTTP_METHOD]: req.method,
    [SPAN_KIND]: SERVER,
    [SPAN_TYPE]: WEB
  })

  addHeaders(context)
}

function addResponseTags (context) {
  const { req, res, paths, span } = context

  if (paths.length > 0) {
    span.setTag(HTTP_ROUTE, paths.join(''))
  }

  span.addTags({
    [HTTP_STATUS_CODE]: res.statusCode
  })

  web.addStatusError(req, res.statusCode)
}

function addResourceTag (context) {
  const { req, span } = context
  const tags = span.context()._tags

  if (tags['resource.name']) return

  const resource = [req.method, tags[HTTP_ROUTE]]
    .filter(val => val)
    .join(' ')

  span.setTag(RESOURCE_NAME, resource)
}

function addHeaders (context) {
  const { req, res, config, span } = context

  config.headers.forEach(key => {
    const reqHeader = req.headers[key]
    const resHeader = res.getHeader(key)

    if (reqHeader) {
      span.setTag(`${HTTP_REQUEST_HEADERS}.${key}`, reqHeader)
    }

    if (resHeader) {
      span.setTag(`${HTTP_RESPONSE_HEADERS}.${key}`, resHeader)
    }
  })
}

function extractURL (req) {
  const headers = req.headers

  if (req.stream) {
    return `${headers[HTTP2_HEADER_SCHEME]}://${headers[HTTP2_HEADER_AUTHORITY]}${headers[HTTP2_HEADER_PATH]}`
  } else {
    const protocol = getProtocol(req)
    return `${protocol}://${req.headers['host']}${req.originalUrl || req.url}`
  }
}

function getProtocol (req) {
  if (req.socket && req.socket.encrypted) return 'https'
  if (req.connection && req.connection.encrypted) return 'https'

  return 'http'
}

function getHeadersToRecord (config) {
  if (Array.isArray(config.headers)) {
    try {
      return config.headers.map(key => key.toLowerCase())
    } catch (err) {
      log.error(err)
    }
  } else if (config.hasOwnProperty('headers')) {
    log.error('Expected `headers` to be an array of strings.')
  }
  return []
}

function getStatusValidator (config) {
  if (typeof config.validateStatus === 'function') {
    return config.validateStatus
  } else if (config.hasOwnProperty('validateStatus')) {
    log.error('Expected `validateStatus` to be a function.')
  }
  return code => code < 500
}

function getHooks (config) {
  const noop = () => {}
  const request = (config.hooks && config.hooks.request) || noop

  return { request }
}

function getMiddlewareSetting (config) {
  if (config && typeof config.middleware === 'boolean') {
    return config.middleware
  } else if (config && config.hasOwnProperty('middleware')) {
    log.error('Expected `middleware` to be a boolean.')
  }

  return true
}

module.exports = web


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/priority_sampler.js":
/*!**********************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/priority_sampler.js ***!
  \**********************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const RateLimiter = __webpack_require__(/*! ./rate_limiter */ "../../node_modules/dd-trace/packages/dd-trace/src/rate_limiter.js")
const Sampler = __webpack_require__(/*! ./sampler */ "../../node_modules/dd-trace/packages/dd-trace/src/sampler.js")
const ext = __webpack_require__(/*! ../../../ext */ "../../node_modules/dd-trace/ext/index.js")
const { setSamplingRules } = __webpack_require__(/*! ./startup-log */ "../../node_modules/dd-trace/packages/dd-trace/src/startup-log.js")

const {
  SAMPLING_RULE_DECISION,
  SAMPLING_LIMIT_DECISION,
  SAMPLING_AGENT_DECISION
} = __webpack_require__(/*! ./constants */ "../../node_modules/dd-trace/packages/dd-trace/src/constants.js")

const SERVICE_NAME = ext.tags.SERVICE_NAME
const SAMPLING_PRIORITY = ext.tags.SAMPLING_PRIORITY
const MANUAL_KEEP = ext.tags.MANUAL_KEEP
const MANUAL_DROP = ext.tags.MANUAL_DROP
const USER_REJECT = ext.priority.USER_REJECT
const AUTO_REJECT = ext.priority.AUTO_REJECT
const AUTO_KEEP = ext.priority.AUTO_KEEP
const USER_KEEP = ext.priority.USER_KEEP
const DEFAULT_KEY = 'service:,env:'

const defaultSampler = new Sampler(AUTO_KEEP)

class PrioritySampler {
  constructor (env, { sampleRate, rateLimit = 100, rules = [] } = {}) {
    this._env = env
    this._rules = this._normalizeRules(rules, sampleRate)
    this._limiter = new RateLimiter(rateLimit)

    setSamplingRules(this._rules)

    this.update({})
  }

  isSampled (span) {
    const priority = this._getPriorityFromAuto(span)
    return priority === USER_KEEP || priority === AUTO_KEEP
  }

  sample (span, auto = true) {
    if (!span) return

    const context = this._getContext(span)
    const root = context._trace.started[0]

    if (context._sampling.priority !== undefined) return
    if (!root) return // noop span

    const tag = this._getPriorityFromTags(context._tags)

    if (this.validate(tag)) {
      context._sampling.priority = tag
    } else if (auto) {
      context._sampling.priority = this._getPriorityFromAuto(root)
    }
  }

  update (rates) {
    const samplers = {}

    for (const key in rates) {
      const rate = rates[key]
      const sampler = new Sampler(rate)

      samplers[key] = sampler
    }

    samplers[DEFAULT_KEY] = samplers[DEFAULT_KEY] || defaultSampler

    this._samplers = samplers
  }

  validate (samplingPriority) {
    switch (samplingPriority) {
      case USER_REJECT:
      case USER_KEEP:
      case AUTO_REJECT:
      case AUTO_KEEP:
        return true
      default:
        return false
    }
  }

  _getContext (span) {
    return typeof span.context === 'function' ? span.context() : span
  }

  _getPriorityFromAuto (span) {
    const context = this._getContext(span)
    const rule = this._findRule(context)

    return rule
      ? this._getPriorityByRule(context, rule)
      : this._getPriorityByAgent(context)
  }

  _getPriorityFromTags (tags) {
    if (tags.hasOwnProperty(MANUAL_KEEP) && tags[MANUAL_KEEP] !== false) {
      return USER_KEEP
    } else if (tags.hasOwnProperty(MANUAL_DROP) && tags[MANUAL_DROP] !== false) {
      return USER_REJECT
    } else {
      const priority = parseInt(tags[SAMPLING_PRIORITY], 10)

      if (priority === 1 || priority === 2) {
        return USER_KEEP
      } else if (priority === 0 || priority === -1) {
        return USER_REJECT
      }
    }
  }

  _getPriorityByRule (context, rule) {
    context._trace[SAMPLING_RULE_DECISION] = rule.sampleRate

    return rule.sampler.isSampled(context) && this._isSampledByRateLimit(context) ? USER_KEEP : USER_REJECT
  }

  _isSampledByRateLimit (context) {
    const allowed = this._limiter.isAllowed()

    context._trace[SAMPLING_LIMIT_DECISION] = this._limiter.effectiveRate()

    return allowed
  }

  _getPriorityByAgent (context) {
    const key = `service:${context._tags[SERVICE_NAME]},env:${this._env}`
    const sampler = this._samplers[key] || this._samplers[DEFAULT_KEY]

    context._trace[SAMPLING_AGENT_DECISION] = sampler.rate()

    return sampler.isSampled(context) ? AUTO_KEEP : AUTO_REJECT
  }

  _normalizeRules (rules, sampleRate) {
    return rules
      .concat({ sampleRate })
      .map(rule => ({ ...rule, sampleRate: parseFloat(rule.sampleRate) }))
      .filter(rule => !isNaN(rule.sampleRate))
      .map(rule => ({ ...rule, sampler: new Sampler(rule.sampleRate) }))
  }

  _findRule (context) {
    for (let i = 0, l = this._rules.length; i < l; i++) {
      if (this._matchRule(context, this._rules[i])) return this._rules[i]
    }
  }

  _matchRule (context, rule) {
    const name = context._name
    const service = context._tags['service.name']

    if (rule.name instanceof RegExp && !rule.name.test(name)) return false
    if (typeof rule.name === 'string' && rule.name !== name) return false
    if (rule.service instanceof RegExp && !rule.service.test(service)) return false
    if (typeof rule.service === 'string' && rule.service !== service) return false

    return true
  }
}

module.exports = PrioritySampler


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/profiler.js":
/*!**************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/profiler.js ***!
  \**************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const log = __webpack_require__(/*! ./log */ "../../node_modules/dd-trace/packages/dd-trace/src/log.js")
const { profiler } = __webpack_require__(/*! ./profiling */ "../../node_modules/dd-trace/packages/dd-trace/src/profiling/index.js")

module.exports = {
  start: config => {
    const { service, version, env, url, hostname, port, tags } = config
    const { enabled, sourceMap, exporters } = config.profiling
    const logger = {
      debug: (message) => log.debug(message),
      info: (message) => log.info(message),
      warn: (message) => log.warn(message),
      error: (message) => log.error(message)
    }

    profiler.start({
      enabled,
      service,
      version,
      env,
      logger,
      sourceMap,
      exporters,
      url,
      hostname,
      port,
      tags
    })
  },

  stop: () => {
    profiler.stop()
  }
}


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/profiling/config.js":
/*!**********************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/profiling/config.js ***!
  \**********************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const coalesce = __webpack_require__(/*! koalas */ "../../node_modules/koalas/index.js")
const os = __webpack_require__(/*! os */ "os")
const { URL } = __webpack_require__(/*! url */ "url")
const { AgentExporter } = __webpack_require__(/*! ./exporters/agent */ "../../node_modules/dd-trace/packages/dd-trace/src/profiling/exporters/agent.js")
const { FileExporter } = __webpack_require__(/*! ./exporters/file */ "../../node_modules/dd-trace/packages/dd-trace/src/profiling/exporters/file.js")
const { ConsoleLogger } = __webpack_require__(/*! ./loggers/console */ "../../node_modules/dd-trace/packages/dd-trace/src/profiling/loggers/console.js")
const CpuProfiler = __webpack_require__(/*! ./profilers/cpu */ "../../node_modules/dd-trace/packages/dd-trace/src/profiling/profilers/cpu.js")
const HeapProfiler = __webpack_require__(/*! ./profilers/heap */ "../../node_modules/dd-trace/packages/dd-trace/src/profiling/profilers/heap.js")
const { tagger } = __webpack_require__(/*! ./tagger */ "../../node_modules/dd-trace/packages/dd-trace/src/profiling/tagger.js")

const {
  DD_PROFILING_ENABLED,
  DD_PROFILING_PROFILERS,
  DD_ENV,
  DD_TAGS,
  DD_SERVICE,
  DD_VERSION,
  DD_TRACE_AGENT_URL,
  DD_AGENT_HOST,
  DD_TRACE_AGENT_PORT,
  DD_PROFILING_UPLOAD_TIMEOUT,
  DD_PROFILING_SOURCE_MAP
} = process.env

class Config {
  constructor (options = {}) {
    const enabled = coalesce(options.enabled, DD_PROFILING_ENABLED, true)
    const env = coalesce(options.env, DD_ENV)
    const service = options.service || DD_SERVICE || 'node'
    const host = os.hostname()
    const version = coalesce(options.version, DD_VERSION)
    // Must be longer than one minute so pad with five seconds
    const flushInterval = coalesce(options.interval, 65 * 1000)
    const uploadTimeout = coalesce(options.uploadTimeout,
      DD_PROFILING_UPLOAD_TIMEOUT, 60 * 1000)
    const sourceMap = coalesce(options.sourceMap,
      DD_PROFILING_SOURCE_MAP, true)

    this.enabled = String(enabled) !== 'false'
    this.service = service
    this.env = env
    this.host = host

    this.version = version
    this.tags = Object.assign(
      tagger.parse(DD_TAGS),
      tagger.parse(options.tags),
      tagger.parse({ env, host, service, version })
    )
    this.logger = ensureLogger(options.logger)
    this.flushInterval = flushInterval
    this.uploadTimeout = uploadTimeout
    this.sourceMap = sourceMap

    const hostname = coalesce(options.hostname, DD_AGENT_HOST, 'localhost')
    const port = coalesce(options.port, DD_TRACE_AGENT_PORT, 8126)
    this.url = new URL(coalesce(options.url, DD_TRACE_AGENT_URL,
      `http://${hostname || 'localhost'}:${port || 8126}`))

    this.exporters = ensureExporters(options.exporters || [
      new AgentExporter(this)
    ], this)

    const profilers = coalesce(options.profilers, DD_PROFILING_PROFILERS, [
      new CpuProfiler(),
      new HeapProfiler()
    ])

    this.profilers = ensureProfilers(profilers, this)
  }
}

module.exports = { Config }

function getExporter (name, options) {
  switch (name) {
    case 'agent':
      return new AgentExporter(options)
    case 'file':
      return new FileExporter(options)
  }
}

function ensureExporters (exporters, options) {
  if (typeof exporters === 'string') {
    exporters = exporters.split(',')
  }

  for (let i = 0; i < exporters.length; i++) {
    const exporter = exporters[i]
    if (typeof exporter === 'string') {
      exporters[i] = getExporter(exporter, options)
    }
  }

  return exporters
}

function getProfiler (name, options) {
  switch (name) {
    case 'cpu':
      return new CpuProfiler(options)
    case 'heap':
      return new HeapProfiler(options)
    default:
      options.logger.error(`Unknown profiler "${name}"`)
  }
}

function ensureProfilers (profilers, options) {
  if (typeof profilers === 'string') {
    profilers = profilers.split(',')
  }

  for (let i = 0; i < profilers.length; i++) {
    const profiler = profilers[i]
    if (typeof profiler === 'string') {
      profilers[i] = getProfiler(profiler, options)
    }
  }

  // Filter out any invalid profilers
  return profilers.filter(v => v)
}

function ensureLogger (logger) {
  if (typeof logger !== 'object' ||
    typeof logger.debug !== 'function' ||
    typeof logger.info !== 'function' ||
    typeof logger.warn !== 'function' ||
    typeof logger.error !== 'function') {
    return new ConsoleLogger()
  }

  return logger
}


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/profiling/exporters/agent.js":
/*!*******************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/profiling/exporters/agent.js ***!
  \*******************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const retry = __webpack_require__(/*! retry */ "../../node_modules/dd-trace/node_modules/retry/index.js")
const { request } = __webpack_require__(/*! http */ "http")
const FormData = __webpack_require__(/*! form-data */ "../../node_modules/form-data/lib/form_data.js")

// TODO: avoid using dd-trace internals. Make this a separate module?
const docker = __webpack_require__(/*! ../../exporters/common/docker */ "../../node_modules/dd-trace/packages/dd-trace/src/exporters/common/docker.js")
const version = __webpack_require__(/*! ../../../lib/version */ "../../node_modules/dd-trace/packages/dd-trace/lib/version.js")

const containerId = docker.id()

function sendRequest (options, form, callback) {
  const req = request(options, res => {
    if (res.statusCode >= 400) {
      const error = new Error(`HTTP Error ${res.statusCode}`)
      error.status = res.statusCode
      callback(error)
    } else {
      callback(null, res)
    }
  })
  req.on('error', callback)
  if (form) form.pipe(req)
  req.end()
}

function getBody (stream, callback) {
  const chunks = []
  stream.on('error', callback)
  stream.on('data', chunk => chunks.push(chunk))
  stream.on('end', () => {
    callback(null, Buffer.concat(chunks))
  })
}

function computeRetries (uploadTimeout) {
  let tries = 0
  while (tries < 2 || uploadTimeout > 1000) {
    tries++
    uploadTimeout /= 2
  }
  return [tries, Math.floor(uploadTimeout)]
}

class AgentExporter {
  constructor ({ url, logger, uploadTimeout } = {}) {
    this._url = url
    this._logger = logger

    const [backoffTries, backoffTime] = computeRetries(uploadTimeout)

    this._backoffTime = backoffTime
    this._backoffTries = backoffTries
  }

  export ({ profiles, start, end, tags }) {
    const types = Object.keys(profiles)

    const fields = [
      ['recording-start', start.toISOString()],
      ['recording-end', end.toISOString()],
      ['language', 'javascript'],
      ['runtime', 'nodejs'],
      ['runtime_version', process.version],
      ['profiler_version', version],
      ['format', 'pprof'],

      ['tags[]', 'language:javascript'],
      ['tags[]', 'runtime:nodejs'],
      ['tags[]', `runtime_version:${process.version}`],
      ['tags[]', `profiler_version:${version}`],
      ['tags[]', 'format:pprof'],
      ...Object.entries(tags).map(([key, value]) => ['tags[]', `${key}:${value}`])
    ]

    this._logger.debug(() => {
      const body = fields.map(([key, value]) => `  ${key}: ${value}`).join('\n')
      return `Building agent export report: ${'\n' + body}`
    })

    for (let index = 0; index < types.length; index++) {
      const type = types[index]
      const buffer = profiles[type]

      this._logger.debug(() => {
        const bytes = buffer.toString('hex').match(/../g).join(' ')
        return `Adding ${type} profile to agent export: ` + bytes
      })

      fields.push([`types[${index}]`, type])
      fields.push([`data[${index}]`, buffer, {
        filename: `${type}.pb.gz`,
        contentType: 'application/octet-stream',
        knownLength: buffer.length
      }])
    }

    return new Promise((resolve, reject) => {
      const operation = retry.operation({
        randomize: true,
        minTimeout: this._backoffTime,
        retries: this._backoffTries
      })

      operation.attempt((attempt) => {
        const form = new FormData()

        for (const [key, value, options] of fields) {
          form.append(key, value, options)
        }

        const options = {
          method: 'POST',
          path: '/profiling/v1/input',
          headers: form.getHeaders(),
          timeout: this._backoffTime * Math.pow(2, attempt)
        }

        if (containerId) {
          options.headers['Datadog-Container-ID'] = containerId
        }

        if (this._url.protocol === 'unix:') {
          options.socketPath = this._url.pathname
        } else {
          options.protocol = this._url.protocol
          options.hostname = this._url.hostname
          options.port = this._url.port
        }

        this._logger.debug(() => {
          return `Submitting profiler agent report attempt #${attempt} to: ${JSON.stringify(options)}`
        })

        sendRequest(options, form, (err, response) => {
          if (operation.retry(err)) {
            this._logger.error(`Error from the agent: ${err.message}`)
            return
          } else if (err) {
            reject(new Error('Profiler agent export back-off period expired'))
            return
          }

          getBody(response, (err, body) => {
            if (err) {
              this._logger.error(`Error reading agent response: ${err.message}`)
            } else {
              this._logger.debug(() => {
                const bytes = (body.toString('hex').match(/../g) || []).join(' ')
                return `Agent export response: ${bytes}`
              })
            }
          })

          resolve()
        })
      })
    })
  }
}

module.exports = { AgentExporter, computeRetries }


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/profiling/exporters/file.js":
/*!******************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/profiling/exporters/file.js ***!
  \******************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const fs = __webpack_require__(/*! fs */ "fs")
const { promisify } = __webpack_require__(/*! util */ "util")
const writeFile = promisify(fs.writeFile)

class FileExporter {
  export ({ profiles }) {
    const types = Object.keys(profiles)
    const tasks = types.map(type => {
      return writeFile(`${type}.pb.gz`, profiles[type])
    })

    return Promise.all(tasks)
  }
}

module.exports = { FileExporter }


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/profiling/index.js":
/*!*********************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/profiling/index.js ***!
  \*********************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const { Profiler } = __webpack_require__(/*! ./profiler */ "../../node_modules/dd-trace/packages/dd-trace/src/profiling/profiler.js")
const CpuProfiler = __webpack_require__(/*! ./profilers/cpu */ "../../node_modules/dd-trace/packages/dd-trace/src/profiling/profilers/cpu.js")
const HeapProfiler = __webpack_require__(/*! ./profilers/heap */ "../../node_modules/dd-trace/packages/dd-trace/src/profiling/profilers/heap.js")
const { AgentExporter } = __webpack_require__(/*! ./exporters/agent */ "../../node_modules/dd-trace/packages/dd-trace/src/profiling/exporters/agent.js")
const { FileExporter } = __webpack_require__(/*! ./exporters/file */ "../../node_modules/dd-trace/packages/dd-trace/src/profiling/exporters/file.js")
const { ConsoleLogger } = __webpack_require__(/*! ./loggers/console */ "../../node_modules/dd-trace/packages/dd-trace/src/profiling/loggers/console.js")

const profiler = new Profiler()

module.exports = {
  profiler,
  AgentExporter,
  FileExporter,
  CpuProfiler,
  HeapProfiler,
  ConsoleLogger
}


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/profiling/loggers/console.js":
/*!*******************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/profiling/loggers/console.js ***!
  \*******************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* eslint-disable no-console */

// https://en.wikipedia.org/wiki/Syslog#Severity_level
const mapping = {
  error: 3,
  warn: 4,
  info: 6,
  debug: 7
}

class ConsoleLogger {
  constructor (options = {}) {
    this._level = mapping[options.level] || mapping['error']
  }

  debug (message) {
    this._log('debug', message)
  }

  info (message) {
    this._log('info', message)
  }

  warn (message) {
    this._log('warn', message)
  }

  error (message) {
    this._log('error', message)
  }

  _log (level, message) {
    if (mapping[level] > this._level) return

    console[level](message)
  }
}

module.exports = { ConsoleLogger }


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/profiling/profiler.js":
/*!************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/profiling/profiler.js ***!
  \************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const { EventEmitter } = __webpack_require__(/*! events */ "events")
const { Config } = __webpack_require__(/*! ./config */ "../../node_modules/dd-trace/packages/dd-trace/src/profiling/config.js")

function maybeSourceMap (sourceMap) {
  if (!sourceMap) return

  const { SourceMapper } = __webpack_require__(/*! @datadog/pprof */ "../../node_modules/@datadog/pprof/out/src/index.js")
  return SourceMapper.create([
    process.cwd()
  ])
}

class Profiler extends EventEmitter {
  constructor () {
    super()
    this._enabled = false
    this._logger = undefined
    this._config = undefined
    this._timer = undefined
    this._lastStart = undefined
  }

  start (options) {
    this._start(options).catch(() => {})
    return this
  }

  async _start (options) {
    if (this._enabled) return

    const config = this._config = new Config(options)
    if (!config.enabled) return

    this._logger = config.logger
    this._enabled = true

    try {
      const mapper = await maybeSourceMap(config.sourceMap)

      for (const profiler of config.profilers) {
        // TODO: move this out of Profiler when restoring sourcemap support
        profiler.start({ mapper })
        this._logger.debug(`Started ${profiler.type} profiler`)
      }

      this._capture(config.flushInterval)
    } catch (e) {
      this._logger.error(e)
      this.stop()
    }
  }

  stop () {
    if (!this._enabled) return

    this._enabled = false

    for (const profiler of this._config.profilers) {
      profiler.stop()
      this._logger.debug(`Stopped ${profiler.type} profiler`)
    }

    clearTimeout(this._timer)
    this._timer = undefined

    return this
  }

  _capture (timeout) {
    if (!this._enabled) return
    this._lastStart = new Date()

    if (!this._timer || timeout !== this._config.flushInterval) {
      this._timer = setTimeout(() => this._collect(), timeout)
      this._timer.unref()
    } else {
      this._timer.refresh()
    }
  }

  async _collect () {
    const start = this._lastStart
    const end = new Date()
    const profiles = {}

    try {
      for (const profiler of this._config.profilers) {
        const profile = profiler.profile()
        if (!profile) continue

        profiles[profiler.type] = await profiler.encode(profile)
        this._logger.debug(`Collected ${profiler.type} profile: ` + JSON.stringify(profile))
      }

      this._capture(this._config.flushInterval)
      await this._submit(profiles, start, end)
      this._logger.debug('Submitted profiles')
    } catch (err) {
      this._logger.error(err)
      this.stop()
    }
  }

  _submit (profiles, start, end) {
    if (!Object.keys(profiles).length) {
      return Promise.reject(new Error('No profiles to submit'))
    }
    const { tags } = this._config
    const tasks = []

    for (const exporter of this._config.exporters) {
      const task = exporter.export({ profiles, start, end, tags })
        .catch(err => this._logger.error(err))

      tasks.push(task)
    }

    return Promise.all(tasks)
  }
}

module.exports = { Profiler }


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/profiling/profilers/cpu.js":
/*!*****************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/profiling/profilers/cpu.js ***!
  \*****************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


class NativeCpuProfiler {
  constructor (options = {}) {
    this.type = 'wall'
    this._samplingInterval = options.samplingInterval || 10 * 1000
    this._mapper = undefined
    this._pprof = undefined
  }

  start ({ mapper } = {}) {
    this._mapper = mapper
    this._pprof = __webpack_require__(/*! @datadog/pprof */ "../../node_modules/@datadog/pprof/out/src/index.js")

    // pprof otherwise crashes in worker threads
    if (!process._startProfilerIdleNotifier) {
      process._startProfilerIdleNotifier = () => {}
    }
    if (!process._stopProfilerIdleNotifier) {
      process._stopProfilerIdleNotifier = () => {}
    }

    this._record()
  }

  profile () {
    if (!this._stop) return
    return this._stop(true)
  }

  encode (profile) {
    return this._pprof.encode(profile)
  }

  stop () {
    if (!this._stop) return
    this._stop()
  }

  _record () {
    this._stop = this._pprof.time.start(this._samplingInterval, null,
      this._mapper, false)
  }
}

module.exports = NativeCpuProfiler


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/profiling/profilers/heap.js":
/*!******************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/profiling/profilers/heap.js ***!
  \******************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


class NativeHeapProfiler {
  constructor (options = {}) {
    this.type = 'space'
    this._samplingInterval = options.samplingInterval || 512 * 1024
    this._stackDepth = options.stackDepth || 64
    this._pprof = undefined
  }

  start ({ mapper } = {}) {
    this._mapper = mapper
    this._pprof = __webpack_require__(/*! @datadog/pprof */ "../../node_modules/@datadog/pprof/out/src/index.js")
    this._pprof.heap.start(this._samplingInterval, this._stackDepth)
  }

  profile () {
    return this._pprof.heap.profile(undefined, this._mapper)
  }

  encode (profile) {
    return this._pprof.encode(profile)
  }

  stop () {
    this._pprof.heap.stop()
  }
}

module.exports = NativeHeapProfiler


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/profiling/tagger.js":
/*!**********************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/profiling/tagger.js ***!
  \**********************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const tagger = {
  parse (tags) {
    if (!tags) return {}

    switch (typeof tags) {
      case 'object':
        if (Array.isArray(tags)) {
          return tags.reduce((prev, next) => {
            const parts = next.split(':')
            const key = parts.shift().trim()
            const value = parts.join(':').trim()

            if (!key || !value) return prev

            return Object.assign(prev, { [key]: value })
          }, {})
        } else {
          return tagger.parse(Object.keys(tags)
            .filter(key => tags[key] !== undefined && tags[key] !== null)
            .map(key => `${key}:${tags[key]}`))
        }
      case 'string':
        return tagger.parse(tags.split(','))
      default:
        return {}
    }
  }
}

module.exports = { tagger }


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/proxy.js":
/*!***********************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/proxy.js ***!
  \***********************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const BaseTracer = __webpack_require__(/*! opentracing */ "../../node_modules/opentracing/lib/index.js").Tracer
const NoopTracer = __webpack_require__(/*! ./noop/tracer */ "../../node_modules/dd-trace/packages/dd-trace/src/noop/tracer.js")
const DatadogTracer = __webpack_require__(/*! ./tracer */ "../../node_modules/dd-trace/packages/dd-trace/src/tracer.js")
const Config = __webpack_require__(/*! ./config */ "../../node_modules/dd-trace/packages/dd-trace/src/config.js")
const Instrumenter = __webpack_require__(/*! ./instrumenter */ "../../node_modules/dd-trace/packages/dd-trace/src/instrumenter.js")
const PluginManager = __webpack_require__(/*! ./plugin_manager */ "../../node_modules/dd-trace/packages/dd-trace/src/plugin_manager.js")
const metrics = __webpack_require__(/*! ./metrics */ "../../node_modules/dd-trace/packages/dd-trace/src/metrics.js")
const log = __webpack_require__(/*! ./log */ "../../node_modules/dd-trace/packages/dd-trace/src/log.js")
const { isFalse } = __webpack_require__(/*! ./util */ "../../node_modules/dd-trace/packages/dd-trace/src/util.js")
const { setStartupLogInstrumenter } = __webpack_require__(/*! ./startup-log */ "../../node_modules/dd-trace/packages/dd-trace/src/startup-log.js")
const telemetry = __webpack_require__(/*! ./telemetry */ "../../node_modules/dd-trace/packages/dd-trace/src/telemetry.js")

const noop = new NoopTracer()

class Tracer extends BaseTracer {
  constructor () {
    super()

    this._initialized = false
    this._tracer = noop
    this._instrumenter = new Instrumenter(this)
    this._pluginManager = new PluginManager(this)
    this._deprecate = method => log.deprecate(`tracer.${method}`, [
      `tracer.${method}() is deprecated.`,
      'Please use tracer.startSpan() and tracer.scope() instead.',
      'See: https://datadog.github.io/dd-trace-js/#manual-instrumentation.'
    ].join(' '))
  }

  init (options) {
    if (isFalse(process.env.DD_TRACE_ENABLED) || this._initialized) return this

    this._initialized = true

    try {
      const config = new Config(options) // TODO: support dynamic config

      log.use(config.logger)
      log.toggle(config.debug, config.logLevel, this)

      if (config.profiling.enabled) {
        // do not stop tracer initialization if the profiler fails to be imported
        try {
          const profiler = __webpack_require__(/*! ./profiler */ "../../node_modules/dd-trace/packages/dd-trace/src/profiler.js")
          profiler.start(config)
        } catch (e) {
          log.error(e)
        }
      }

      if (config.runtimeMetrics) {
        metrics.start(config)
      }

      if (config.tracing) {
        // dirty require for now so zero appsec code is executed unless explicitly enabled
        if (config.appsec.enabled) {
          __webpack_require__(/*! ./appsec */ "../../node_modules/dd-trace/packages/dd-trace/src/appsec/index.js").enable(config)
        }

        this._tracer = new DatadogTracer(config)
        this._instrumenter.enable(config)
        this._pluginManager.configure(config)
        setStartupLogInstrumenter(this._instrumenter)
        telemetry.start(config, this._instrumenter, this._pluginManager)
      }
    } catch (e) {
      log.error(e)
    }

    return this
  }

  use () {
    this._instrumenter.use(...arguments)
    this._pluginManager.configurePlugin(...arguments)
    return this
  }

  trace (name, options, fn) {
    if (!fn) {
      fn = options
      options = {}
    }

    if (typeof fn !== 'function') return

    options = options || {}

    return this._tracer.trace(name, options, fn)
  }

  wrap (name, options, fn) {
    if (!fn) {
      fn = options
      options = {}
    }

    if (typeof fn !== 'function') return fn

    options = options || {}

    return this._tracer.wrap(name, options, fn)
  }

  setUrl () {
    this._tracer.setUrl.apply(this._tracer, arguments)
    return this
  }

  startSpan () {
    return this._tracer.startSpan.apply(this._tracer, arguments)
  }

  inject () {
    return this._tracer.inject.apply(this._tracer, arguments)
  }

  extract () {
    return this._tracer.extract.apply(this._tracer, arguments)
  }

  scope () {
    return this._tracer.scope.apply(this._tracer, arguments)
  }

  currentSpan () {
    this._deprecate('currentSpan')
    return this._tracer.currentSpan.apply(this._tracer, arguments)
  }

  bind (callback) {
    this._deprecate('bind')
    return callback
  }

  bindEmitter () {
    this._deprecate('bindEmitter')
  }

  getRumData () {
    return this._tracer.getRumData.apply(this._tracer, arguments)
  }

  setUser () {
    return this._tracer.setUser.apply(this.tracer, arguments)
  }
}

module.exports = Tracer


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/rate_limiter.js":
/*!******************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/rate_limiter.js ***!
  \******************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const limiter = __webpack_require__(/*! limiter */ "../../node_modules/limiter/index.js")

class RateLimiter {
  constructor (rateLimit) {
    this._rateLimit = parseInt(rateLimit)
    this._limiter = new limiter.RateLimiter(this._rateLimit, 'second')
    this._tokensRequested = 0
    this._prevIntervalTokens = 0
    this._prevTokensRequested = 0
  }

  isAllowed () {
    const curIntervalStart = this._limiter.curIntervalStart
    const curIntervalTokens = this._limiter.tokensThisInterval
    const allowed = this._isAllowed()

    if (curIntervalStart !== this._limiter.curIntervalStart) {
      this._prevIntervalTokens = curIntervalTokens
      this._prevTokensRequested = this._tokensRequested
      this._tokensRequested = 1
    } else {
      this._tokensRequested++
    }

    return allowed
  }

  effectiveRate () {
    if (this._rateLimit < 0) return 1
    if (this._rateLimit === 0) return 0
    if (this._tokensRequested === 0) return 1

    const allowed = this._prevIntervalTokens + this._limiter.tokensThisInterval
    const requested = this._prevTokensRequested + this._tokensRequested

    return allowed / requested
  }

  _isAllowed () {
    if (this._rateLimit < 0) return true
    if (this._rateLimit === 0) return false

    return this._limiter.tryRemoveTokens(1)
  }

  _currentWindowRate () {
    if (this._rateLimit < 0) return 1
    if (this._rateLimit === 0) return 0
    if (this._tokensRequested === 0) return 1

    return this._limiter.tokensThisInterval / this._tokensRequested
  }
}

module.exports = RateLimiter


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/require-package-json.js":
/*!**************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/require-package-json.js ***!
  \**************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const path = __webpack_require__(/*! path */ "path")
const fs = __webpack_require__(/*! fs */ "fs")

/**
 * Given a package name and a module to start from, find a package's
 * package.json file, parses it, and returns the result.
 *
 * Equivalent to require(`${name}/package.json`) prior to Node 12.
 *
 * @typedef { import('module').Module } Module
 * @param {string} name
 * @param {Module} module
 * @return {Object} The parsed package.json
 */
function requirePackageJson (name, module) {
  if (path.isAbsolute(name)) {
    const candidate = path.join(name, 'package.json')
    return JSON.parse(fs.readFileSync(candidate, 'utf8'))
  }
  for (const modulePath of module.paths) {
    const candidate = path.join(modulePath, name, 'package.json')
    try {
      return JSON.parse(fs.readFileSync(candidate, 'utf8'))
    } catch (e) {
      continue
    }
  }
  throw new Error(`could not find ${name}/package.json`)
}

module.exports = requirePackageJson


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/ritm.js":
/*!**********************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/ritm.js ***!
  \**********************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const path = __webpack_require__(/*! path */ "path")
const Module = __webpack_require__(/*! module */ "module")
const parse = __webpack_require__(/*! module-details-from-path */ "../../node_modules/module-details-from-path/index.js")

const origRequire = Module.prototype.require

// derived from require-in-the-middle@3 with tweaks

module.exports = Hook

let moduleHooks = Object.create(null)
let cache = Object.create(null)
let patching = Object.create(null)
let patchedRequire = null

function Hook (modules, options, onrequire) {
  if (!(this instanceof Hook)) return new Hook(modules, options, onrequire)
  if (typeof modules === 'function') {
    onrequire = modules
    modules = null
    options = {}
  } else if (typeof options === 'function') {
    onrequire = options
    options = {}
  }

  modules = modules || []
  options = options || {}

  this.modules = modules
  this.options = options
  this.onrequire = onrequire

  if (Array.isArray(modules)) {
    for (const mod of modules) {
      const hooks = moduleHooks[mod]

      if (hooks) {
        hooks.push(onrequire)
      } else {
        moduleHooks[mod] = [onrequire]
      }
    }
  }

  if (patchedRequire) return

  patchedRequire = Module.prototype.require = function (request) {
    const filename = Module._resolveFilename(request, this)
    const core = filename.indexOf(path.sep) === -1
    let name, basedir, hooks

    // return known patched modules immediately
    if (cache[filename]) {
      // require.cache was potentially altered externally
      if (__webpack_require__.c[filename] && __webpack_require__.c[filename].exports !== cache[filename].original) {
        return __webpack_require__.c[filename].exports
      }

      return cache[filename].exports
    }

    // Check if this module has a patcher in-progress already.
    // Otherwise, mark this module as patching in-progress.
    const patched = patching[filename]
    if (!patched) {
      patching[filename] = true
    }

    const exports = origRequire.apply(this, arguments)

    // If it's already patched, just return it as-is.
    if (patched) return exports

    // The module has already been loaded,
    // so the patching mark can be cleaned up.
    delete patching[filename]

    if (core) {
      hooks = moduleHooks[filename]
      if (!hooks) return exports // abort if module name isn't on whitelist
      name = filename
    } else {
      const stat = parse(filename)
      if (!stat) return exports // abort if filename could not be parsed
      name = stat.name
      basedir = stat.basedir

      hooks = moduleHooks[name]
      if (!hooks) return exports // abort if module name isn't on whitelist

      // figure out if this is the main module file, or a file inside the module
      const paths = Module._resolveLookupPaths(name, this, true)
      if (!paths) {
        // abort if _resolveLookupPaths return null
        return exports
      }
      const res = Module._findPath(name, [basedir, ...paths])
      if (res !== filename) {
        // this is a module-internal file
        // use the module-relative path to the file, prefixed by original module name
        name = name + path.sep + path.relative(basedir, filename)
      }
    }

    // ensure that the cache entry is assigned a value before calling
    // onrequire, in case calling onrequire requires the same module.
    cache[filename] = { exports }
    cache[filename].original = exports

    for (const hook of hooks) {
      cache[filename].exports = hook(cache[filename].exports, name, basedir)
    }

    return cache[filename].exports
  }
}

Hook.reset = function () {
  Module.prototype.require = origRequire
  patchedRequire = null
  patching = Object.create(null)
  cache = Object.create(null)
  moduleHooks = Object.create(null)
}

Hook.prototype.unhook = function () {
  for (const mod of this.modules) {
    const hooks = (moduleHooks[mod] || []).filter(hook => hook !== this.onrequire)

    if (hooks.length > 0) {
      moduleHooks[mod] = hooks
    } else {
      delete moduleHooks[mod]
    }
  }

  if (Object.keys(moduleHooks).length === 0) {
    Hook.reset()
  }
}


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/sampler.js":
/*!*************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/sampler.js ***!
  \*************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


class Sampler {
  constructor (rate) {
    this._rate = rate
  }

  rate () {
    return this._rate
  }

  isSampled () {
    return this._rate === 1 || Math.random() < this._rate
  }
}

module.exports = Sampler


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/scope.js":
/*!***********************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/scope.js ***!
  \***********************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const { storage } = __webpack_require__(/*! ../../datadog-core */ "../../node_modules/dd-trace/packages/datadog-core/index.js")

// TODO: deprecate binding event emitters in 3.0

const originals = new WeakMap()
const listenerMaps = new WeakMap()
const emitterSpans = new WeakMap()
const emitterScopes = new WeakMap()
const emitters = new WeakSet()

class Scope {
  active () {
    const store = storage.getStore()

    return (store && store.span) || null
  }

  activate (span, callback) {
    if (typeof callback !== 'function') return callback

    const oldStore = storage.getStore()
    const newStore = span ? span._store : oldStore

    storage.enterWith({ ...newStore, span })

    try {
      return callback()
    } catch (e) {
      if (span && typeof span.setTag === 'function') {
        span.setTag('error', e)
      }

      throw e
    } finally {
      storage.enterWith(oldStore)
    }
  }

  bind (target, span) {
    target = this._bindEmitter(target, span)
    target = this._bindPromise(target, span)
    target = this._bindFn(target, span)

    return target
  }

  unbind (target) {
    target = this._unbindFn(target)
    target = this._unbindPromise(target)
    target = this._unbindEmitter(target)

    return target
  }

  _bindFn (fn, span) {
    if (typeof fn !== 'function') return fn

    const scope = this
    const spanOrActive = this._spanOrActive(span)

    const bound = function () {
      return scope.activate(spanOrActive, () => {
        return fn.apply(this, arguments)
      })
    }

    originals.set(bound, fn)

    return bound
  }

  _unbindFn (fn) {
    if (typeof fn !== 'function') return fn

    return originals.get(fn) || fn
  }

  _bindEmitter (emitter, span) {
    if (!this._isEmitter(emitter)) return emitter
    if (!emitters.has(emitter)) {
      Scope._wrapEmitter(emitter)
    }
    emitterSpans.set(emitter, span)
    emitterScopes.set(emitter, this)
    return emitter
  }

  // Occasionally we want to wrap a prototype rather than emitter instances,
  // so we're exposing this as a static method. This gives us a faster
  // path for binding instances of known EventEmitter subclasses.
  static _wrapEmitter (emitter) {
    wrapMethod(emitter, 'addListener', wrapAddListener)
    wrapMethod(emitter, 'prependListener', wrapAddListener)
    wrapMethod(emitter, 'on', wrapAddListener)
    wrapMethod(emitter, 'once', wrapAddListener)
    wrapMethod(emitter, 'removeListener', wrapRemoveListener)
    wrapMethod(emitter, 'off', wrapRemoveListener)
    wrapMethod(emitter, 'removeAllListeners', wrapRemoveAllListeners)
    emitters.add(emitter)
  }

  _unbindEmitter (emitter) {
    if (!this._isEmitter(emitter)) return emitter
    emitterScopes.delete(emitter)
    emitterSpans.delete(emitter)
    return emitter
  }

  _bindPromise (promise, span) {
    if (!this._isPromise(promise)) return promise

    wrapMethod(promise, 'then', wrapThen, this, span)

    return promise
  }

  _unbindPromise (promise) {
    if (!this._isPromise(promise)) return promise

    promise.then = originals.get(promise.then) || promise.then

    return promise
  }

  _spanOrActive (span) {
    return span !== undefined ? span : this.active()
  }

  _isEmitter (emitter) {
    return emitter &&
      typeof emitter.emit === 'function' &&
      typeof emitter.on === 'function' &&
      typeof emitter.addListener === 'function' &&
      typeof emitter.removeListener === 'function'
  }

  _isPromise (promise) {
    return promise && typeof promise.then === 'function'
  }
}

function getScope (emitter) {
  return emitterScopes.get(emitter) || emitterScopes.get(emitter.constructor.prototype)
}

function getSpan (emitter) {
  return emitterSpans.get(emitter) || emitterSpans.get(emitter.constructor.prototype)
}

function hasScope (emitter) {
  return emitterScopes.has(emitter) || emitterScopes.has(emitter.constructor.prototype)
}

function wrapThen (then, scope, span) {
  return function thenWithTrace (onFulfilled, onRejected) {
    const args = new Array(arguments.length)

    for (let i = 0, l = args.length; i < l; i++) {
      args[i] = scope.bind(arguments[i], span)
    }

    return then.apply(this, args)
  }
}

function wrapAddListener (addListener) {
  return function addListenerWithTrace (eventName, listener) {
    const scope = getScope(this)
    if (!scope || !listener || originals.has(listener) || listener.listener) {
      return addListener.apply(this, arguments)
    }
    const span = getSpan(this)

    const bound = scope.bind(listener, scope._spanOrActive(span))
    const listenerMap = listenerMaps.get(this) || {}

    listenerMaps.set(this, listenerMap)

    if (!listenerMap[eventName]) {
      listenerMap[eventName] = new WeakMap()
    }

    const events = listenerMap[eventName]

    if (!events.has(listener)) {
      events.set(listener, [])
    }

    events.get(listener).push(bound)

    return addListener.call(this, eventName, bound)
  }
}

function wrapRemoveListener (removeListener) {
  return function removeListenerWithTrace (eventName, listener) {
    if (!hasScope(this)) {
      return removeListener.apply(this, arguments)
    }

    const listenerMap = listenerMaps.get(this)
    const listeners = listenerMap && listenerMap[eventName]

    if (!listener || !listeners || !listeners.has(listener)) {
      return removeListener.apply(this, arguments)
    }

    for (const bound of listeners.get(listener)) {
      removeListener.call(this, eventName, bound)
    }

    listeners.delete(listener)

    return removeListener.apply(this, arguments)
  }
}

function wrapRemoveAllListeners (removeAllListeners) {
  return function removeAllListenersWithTrace (eventName) {
    const listenerMap = listenerMaps.get(this)

    if (hasScope(this) && listenerMap) {
      if (eventName) {
        delete listenerMap[eventName]
      } else {
        listenerMaps.delete(this)
      }
    }

    return removeAllListeners.apply(this, arguments)
  }
}

function wrapMethod (target, name, wrapper, ...args) {
  if (!target[name] || originals.has(target[name])) return

  const original = target[name]

  target[name] = wrapper(target[name], ...args)
  originals.set(target[name], original)
}

module.exports = Scope


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/span_processor.js":
/*!********************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/span_processor.js ***!
  \********************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const log = __webpack_require__(/*! ./log */ "../../node_modules/dd-trace/packages/dd-trace/src/log.js")
const format = __webpack_require__(/*! ./format */ "../../node_modules/dd-trace/packages/dd-trace/src/format.js")

const startedSpans = new WeakSet()
const finishedSpans = new WeakSet()

class SpanProcessor {
  constructor (exporter, prioritySampler, config) {
    this._exporter = exporter
    this._prioritySampler = prioritySampler
    this._config = config
  }

  process (span) {
    const spanContext = span.context()
    const active = []
    const formatted = []
    const trace = spanContext._trace
    const { flushMinSpans } = this._config
    const { started, finished } = trace

    if (started.length === finished.length || finished.length >= flushMinSpans) {
      this._prioritySampler.sample(spanContext)

      for (const span of started) {
        if (span._duration !== undefined) {
          formatted.push(format(span))
        } else {
          active.push(span)
        }
      }

      this._exporter.export(formatted)
      this._erase(trace, active)
    }
  }

  _erase (trace, active) {
    if (process.env.DD_TRACE_EXPERIMENTAL_STATE_TRACKING === 'true') {
      const started = new Set()
      const startedIds = new Set()
      const finished = new Set()
      const finishedIds = new Set()

      for (const span of trace.finished) {
        const context = span.context()
        const id = context.toSpanId()

        if (finished.has(span)) {
          log.error(`Span was already finished in the same trace: ${span}`)
        } else {
          finished.add(span)

          if (finishedIds.has(id)) {
            log.error(`Another span with the same ID was already finished in the same trace: ${span}`)
          } else {
            finishedIds.add(id)
          }

          if (context._trace !== trace) {
            log.error(`A span was finished in the wrong trace: ${span}.`)
          }

          if (finishedSpans.has(span)) {
            log.error(`Span was already finished in a different trace: ${span}`)
          } else {
            finishedSpans.add(span)
          }
        }
      }

      for (const span of trace.started) {
        const context = span.context()
        const id = context.toSpanId()

        if (started.has(span)) {
          log.error(`Span was already started in the same trace: ${span}`)
        } else {
          started.add(span)

          if (startedIds.has(id)) {
            log.error(`Another span with the same ID was already started in the same trace: ${span}`)
          } else {
            startedIds.add(id)
          }

          if (context._trace !== trace) {
            log.error(`A span was started in the wrong trace: ${span}.`)
          }

          if (startedSpans.has(span)) {
            log.error(`Span was already started in a different trace: ${span}`)
          } else {
            startedSpans.add(span)
          }
        }

        if (!finished.has(span)) {
          log.error(`Span started in one trace but was finished in another trace: ${span}`)
        }
      }

      for (const span of trace.finished) {
        if (!started.has(span)) {
          log.error(`Span finished in one trace but was started in another trace: ${span}`)
        }
      }
    }

    for (const span of trace.finished) {
      span.context()._tags = {}
    }

    trace.started = active
    trace.finished = []
  }
}

module.exports = SpanProcessor


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/startup-log.js":
/*!*****************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/startup-log.js ***!
  \*****************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

const mainLogger = __webpack_require__(/*! ./log */ "../../node_modules/dd-trace/packages/dd-trace/src/log.js")

const os = __webpack_require__(/*! os */ "os")
const { inspect } = __webpack_require__(/*! util */ "util")
const tracerVersion = __webpack_require__(/*! ../lib/version */ "../../node_modules/dd-trace/packages/dd-trace/lib/version.js")
const requirePackageJson = __webpack_require__(/*! ./require-package-json */ "../../node_modules/dd-trace/packages/dd-trace/src/require-package-json.js")

const logger = Object.create(mainLogger)
logger._enabled = true

let config
let instrumenter
let samplingRules = []

let alreadyRan = false

function getIntegrationsAndAnalytics () {
  const integrations = new Set()
  const extras = {}
  for (const plugin of instrumenter._instrumented.keys()) {
    if (plugin.versions) {
      try {
        const version = requirePackageJson(plugin.name, module).version
        integrations.add(`${plugin.name}@${version}`)
      } catch (e) {
        integrations.add(plugin.name)
      }
    } else {
      integrations.add(plugin.name)
    }
  }
  extras.integrations_loaded = Array.from(integrations)
  return extras
}

function startupLog ({ agentError } = {}) {
  if (!config || !instrumenter) {
    return
  }

  if (alreadyRan) {
    return
  }

  alreadyRan = true

  if (!config.startupLogs) {
    return
  }

  const url = config.url || `http://${config.hostname || 'localhost'}:${config.port}`

  const out = {
    [inspect.custom] () {
      return String(this)
    },
    toString () {
      return JSON.stringify(this)
    }
  }

  out.date = new Date().toISOString()
  out.os_name = os.type()
  out.os_version = os.release()
  out.architecture = os.arch()
  out.version = tracerVersion
  out.lang = 'nodejs'
  out.lang_version = process.versions.node
  out.env = config.env
  out.enabled = config.enabled
  out.service = config.service
  out.agent_url = url
  if (agentError) {
    out.agent_error = agentError.message
  }
  out.debug = !!config.debug
  out.sample_rate = config.sampleRate
  out.sampling_rules = samplingRules
  out.tags = config.tags
  if (config.tags && config.tags.version) {
    out.dd_version = config.tags.version
  }

  out.log_injection_enabled = !!config.logInjection
  out.runtime_metrics_enabled = !!config.runtimeMetrics
  out.profiling_enabled = !!(config.profiling || {}).enabled
  Object.assign(out, getIntegrationsAndAnalytics())

  out.appsec_enabled = !!config.appsec.enabled

  // // This next bunch is for features supported by other tracers, but not this
  // // one. They may be implemented in the future.

  // out.enabled_cli
  // out.sampling_rules_error
  // out.integration_XXX_analytics_enabled
  // out.integration_XXX_sample_rate
  // out.service_mapping
  // out.service_mapping_error

  logger.info('DATADOG TRACER CONFIGURATION - ' + out)
  if (agentError) {
    logger.warn('DATADOG TRACER DIAGNOSTIC - Agent Error: ' + agentError.message)
  }

  config = undefined
  instrumenter = undefined
  samplingRules = undefined
}

function setStartupLogConfig (aConfig) {
  config = aConfig
}

function setStartupLogInstrumenter (theInstrumenter) {
  instrumenter = theInstrumenter
}

function setSamplingRules (theRules) {
  samplingRules = theRules
}

module.exports = {
  startupLog,
  setStartupLogConfig,
  setStartupLogInstrumenter,
  setSamplingRules
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/module.js */ "../../node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/tagger.js":
/*!************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/tagger.js ***!
  \************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const log = __webpack_require__(/*! ./log */ "../../node_modules/dd-trace/packages/dd-trace/src/log.js")

function add (carrier, keyValuePairs) {
  if (!carrier || !keyValuePairs) return

  if (Array.isArray(keyValuePairs)) {
    return keyValuePairs.forEach(tags => add(carrier, tags))
  }

  try {
    if (typeof keyValuePairs === 'string') {
      const segments = keyValuePairs.split(',')
      for (const segment of segments) {
        const separatorIndex = segment.indexOf(':')
        if (separatorIndex === -1) continue

        const key = segment.slice(0, separatorIndex)
        const value = segment.slice(separatorIndex + 1)

        carrier[key.trim()] = value.trim()
      }
    } else {
      Object.assign(carrier, keyValuePairs)
    }
  } catch (e) {
    log.error(e)
  }
}

module.exports = { add }


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/telemetry.js":
/*!***************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/telemetry.js ***!
  \***************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const tracerVersion = __webpack_require__(/*! ../lib/version */ "../../node_modules/dd-trace/packages/dd-trace/lib/version.js")
const pkg = __webpack_require__(/*! ./pkg */ "../../node_modules/dd-trace/packages/dd-trace/src/pkg.js")
const containerId = __webpack_require__(/*! ./exporters/common/docker */ "../../node_modules/dd-trace/packages/dd-trace/src/exporters/common/docker.js").id()
const requirePackageJson = __webpack_require__(/*! ./require-package-json */ "../../node_modules/dd-trace/packages/dd-trace/src/require-package-json.js")
const path = __webpack_require__(/*! path */ "path")
const os = __webpack_require__(/*! os */ "os")
const request = __webpack_require__(/*! ./exporters/common/request */ "../../node_modules/dd-trace/packages/dd-trace/src/exporters/common/request.js")

let config
let instrumenter
let pluginManager

let seqId = 0
let application
let host
let interval
const sentIntegrations = new Set()

function getIntegrations () {
  const newIntegrations = []
  for (const plugin of instrumenter._instrumented.keys()) {
    if (sentIntegrations.has(plugin.name)) {
      continue
    }
    newIntegrations.push({
      name: plugin.name,
      enabled: true,
      auto_enabled: true
    })
    sentIntegrations.add(plugin.name)
  }
  for (const pluginName in pluginManager._pluginsByName) {
    if (sentIntegrations.has(pluginName)) {
      continue
    }
    newIntegrations.push({
      name: pluginName,
      enabled: pluginManager._pluginsByName[pluginName]._enabled,
      auto_enabled: true
    })
    sentIntegrations.add(pluginName)
  }
  return newIntegrations
}

function getDependencies () {
  const deps = []
  const { dependencies } = pkg
  if (!dependencies) {
    return deps
  }
  const rootDir = pkg.findRoot()
  for (const [name, version] of Object.entries(dependencies)) {
    const dep = { name }
    try {
      dep.version = requirePackageJson(
        path.join(rootDir, 'node_modules', name.replace('/', path.sep))
      ).version
    } catch (e) {
      dep.version = version
    }
    deps.push(dep)
  }
  return deps
}

function flatten (input, result = [], prefix = [], traversedObjects = null) {
  traversedObjects = traversedObjects || new WeakSet()
  if (traversedObjects.has(input)) {
    return
  }
  traversedObjects.add(input)
  for (const [key, value] of Object.entries(input)) {
    if (typeof value === 'object' && value !== null) {
      flatten(value, result, [...prefix, key], traversedObjects)
    } else {
      result.push({ name: [...prefix, key].join('.'), value })
    }
  }
  return result
}

function appStarted () {
  return {
    integrations: getIntegrations(),
    dependencies: getDependencies(),
    configuration: flatten(config),
    additional_payload: []
  }
}

function onBeforeExit () {
  process.removeListener('beforeExit', onBeforeExit)
  sendData('app-closing')
}

function createAppObject () {
  return {
    service_name: config.service,
    env: config.env,
    service_version: config.version,
    tracer_version: tracerVersion,
    language_name: 'nodejs',
    language_version: process.versions.node
  }
}

function createHostObject () {
  return {
    hostname: os.hostname(), // TODO is this enough?
    container_id: containerId
  }
}

function sendData (reqType, payload = {}) {
  const {
    hostname,
    port
  } = config
  const options = {
    hostname,
    port,
    method: 'POST',
    path: '/telemetry/proxy/api/v2/apmtelemetry',
    headers: {
      'content-type': 'application/json',
      'dd-telemetry-api-version': 'v1',
      'dd-telemetry-request-type': reqType
    }
  }
  const data = JSON.stringify({
    api_version: 'v1',
    request_type: reqType,
    tracer_time: Math.floor(Date.now() / 1000),
    runtime_id: config.tags['runtime-id'],
    seq_id: ++seqId,
    payload,
    application,
    host
  })

  request(data, options, true, () => {
    // ignore errors
  })
}

function start (aConfig, theInstrumenter, thePluginManager) {
  if (!aConfig.telemetryEnabled) {
    return
  }
  config = aConfig
  instrumenter = theInstrumenter
  pluginManager = thePluginManager
  application = createAppObject()
  host = createHostObject()
  sendData('app-started', appStarted())
  interval = setInterval(() => sendData('app-heartbeat'), 60000)
  interval.unref()
  process.on('beforeExit', onBeforeExit)
}

function stop () {
  if (!config) {
    return
  }
  clearInterval(interval)
  process.removeListener('beforeExit', onBeforeExit)
}

function updateIntegrations () {
  if (!config || !config.telemetryEnabled) {
    return
  }
  const integrations = getIntegrations()
  if (integrations.length === 0) {
    return
  }
  sendData('app-integrations-change', { integrations })
}

module.exports = {
  start,
  stop,
  updateIntegrations
}


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/tracer.js":
/*!************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/tracer.js ***!
  \************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Tracer = __webpack_require__(/*! ./opentracing/tracer */ "../../node_modules/dd-trace/packages/dd-trace/src/opentracing/tracer.js")
const tags = __webpack_require__(/*! ../../../ext/tags */ "../../node_modules/dd-trace/ext/tags.js")
const Scope = __webpack_require__(/*! ./scope */ "../../node_modules/dd-trace/packages/dd-trace/src/scope.js")
const { storage } = __webpack_require__(/*! ../../datadog-core */ "../../node_modules/dd-trace/packages/datadog-core/index.js")
const { isError } = __webpack_require__(/*! ./util */ "../../node_modules/dd-trace/packages/dd-trace/src/util.js")
const { setStartupLogConfig } = __webpack_require__(/*! ./startup-log */ "../../node_modules/dd-trace/packages/dd-trace/src/startup-log.js")

const SPAN_TYPE = tags.SPAN_TYPE
const RESOURCE_NAME = tags.RESOURCE_NAME
const SERVICE_NAME = tags.SERVICE_NAME
const MEASURED = tags.MEASURED

class DatadogTracer extends Tracer {
  constructor (config) {
    super(config)

    this._scope = new Scope()
    setStartupLogConfig(config)
  }

  trace (name, options, fn) {
    options = Object.assign({
      childOf: this.scope().active()
    }, options)

    if (!options.childOf && options.orphanable === false) {
      return fn(null, () => {})
    }

    const span = this.startSpan(name, options)

    addTags(span, options)

    try {
      if (fn.length > 1) {
        return this.scope().activate(span, () => fn(span, err => {
          addError(span, err)
          span.finish()
        }))
      }

      const result = this.scope().activate(span, () => fn(span))

      if (result && typeof result.then === 'function') {
        result.then(
          () => span.finish(),
          err => {
            addError(span, err)
            span.finish()
          }
        )
      } else {
        span.finish()
      }

      return result
    } catch (e) {
      addError(span, e)
      span.finish()
      throw e
    }
  }

  wrap (name, options, fn) {
    const tracer = this

    return function () {
      const store = storage.getStore()

      if (store && store.noop) return fn.apply(this, arguments)

      let optionsObj = options
      if (typeof optionsObj === 'function' && typeof fn === 'function') {
        optionsObj = optionsObj.apply(this, arguments)
      }

      if (optionsObj && optionsObj.orphanable === false && !tracer.scope().active()) {
        return fn.apply(this, arguments)
      }

      const lastArgId = arguments.length - 1
      const cb = arguments[lastArgId]

      if (typeof cb === 'function') {
        const scopeBoundCb = tracer.scope().bind(cb)
        return tracer.trace(name, optionsObj, (span, done) => {
          arguments[lastArgId] = function (err) {
            done(err)
            return scopeBoundCb.apply(this, arguments)
          }

          return fn.apply(this, arguments)
        })
      } else {
        return tracer.trace(name, optionsObj, () => fn.apply(this, arguments))
      }
    }
  }

  setUrl (url) {
    this._exporter.setUrl(url)
  }

  scope () {
    return this._scope
  }

  currentSpan () {
    return this.scope().active()
  }

  getRumData () {
    if (!this._enableGetRumData) {
      return ''
    }
    const span = this.scope().active().context()
    const traceId = span.toTraceId()
    const traceTime = Date.now()
    return `\
<meta name="dd-trace-id" content="${traceId}" />\
<meta name="dd-trace-time" content="${traceTime}" />`
  }

  setUser (user) {
    if (!user || !user.id) return this

    const span = this.scope().active()
    if (!span) return this

    const rootSpan = span._spanContext._trace.started[0]
    if (!rootSpan) return this

    for (const k of Object.keys(user)) {
      rootSpan.setTag(`usr.${k}`, '' + user[k])
    }

    return this
  }
}

function addError (span, error) {
  if (isError(error)) {
    span.addTags({
      'error.type': error.name,
      'error.msg': error.message,
      'error.stack': error.stack
    })
  }
}

function addTags (span, options) {
  const tags = {}

  if (options.type) tags[SPAN_TYPE] = options.type
  if (options.service) tags[SERVICE_NAME] = options.service
  if (options.resource) tags[RESOURCE_NAME] = options.resource

  tags[MEASURED] = options.measured

  span.addTags(tags)
}

module.exports = DatadogTracer


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/util.js":
/*!**********************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/util.js ***!
  \**********************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function isTrue (str) {
  str = String(str).toLowerCase()
  return str === 'true' || str === '1'
}

function isFalse (str) {
  str = String(str).toLowerCase()
  return str === 'false' || str === '0'
}

function isError (value) {
  if (value instanceof Error) {
    return true
  }
  if (value && value.message && value.stack) {
    return true
  }
  return false
}

module.exports = {
  isTrue,
  isFalse,
  isError
}


/***/ }),

/***/ "../../node_modules/delay/index.js":
/*!**********************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/delay/index.js ***!
  \**********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// From https://github.com/sindresorhus/random-int/blob/c37741b56f76b9160b0b63dae4e9c64875128146/index.js#L13-L15
const randomInteger = (minimum, maximum) => Math.floor((Math.random() * (maximum - minimum + 1)) + minimum);

const createAbortError = () => {
	const error = new Error('Delay aborted');
	error.name = 'AbortError';
	return error;
};

const createDelay = ({clearTimeout: defaultClear, setTimeout: set, willResolve}) => (ms, {value, signal} = {}) => {
	if (signal && signal.aborted) {
		return Promise.reject(createAbortError());
	}

	let timeoutId;
	let settle;
	let rejectFn;
	const clear = defaultClear || clearTimeout;

	const signalListener = () => {
		clear(timeoutId);
		rejectFn(createAbortError());
	};

	const cleanup = () => {
		if (signal) {
			signal.removeEventListener('abort', signalListener);
		}
	};

	const delayPromise = new Promise((resolve, reject) => {
		settle = () => {
			cleanup();
			if (willResolve) {
				resolve(value);
			} else {
				reject(value);
			}
		};

		rejectFn = reject;
		timeoutId = (set || setTimeout)(settle, ms);
	});

	if (signal) {
		signal.addEventListener('abort', signalListener, {once: true});
	}

	delayPromise.clear = () => {
		clear(timeoutId);
		timeoutId = null;
		settle();
	};

	return delayPromise;
};

const createWithTimers = clearAndSet => {
	const delay = createDelay({...clearAndSet, willResolve: true});
	delay.reject = createDelay({...clearAndSet, willResolve: false});
	delay.range = (minimum, maximum, options) => delay(randomInteger(minimum, maximum), options);
	return delay;
};

const delay = createWithTimers();
delay.createWithTimers = createWithTimers;

module.exports = delay;
// TODO: Remove this for the next major release
module.exports.default = delay;


/***/ }),

/***/ "../../node_modules/detect-libc/lib/detect-libc.js":
/*!**************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/detect-libc/lib/detect-libc.js ***!
  \**************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var platform = __webpack_require__(/*! os */ "os").platform();
var spawnSync = __webpack_require__(/*! child_process */ "child_process").spawnSync;
var readdirSync = __webpack_require__(/*! fs */ "fs").readdirSync;

var GLIBC = 'glibc';
var MUSL = 'musl';

var spawnOptions = {
  encoding: 'utf8',
  env: process.env
};

if (!spawnSync) {
  spawnSync = function () {
    return { status: 126, stdout: '', stderr: '' };
  };
}

function contains (needle) {
  return function (haystack) {
    return haystack.indexOf(needle) !== -1;
  };
}

function versionFromMuslLdd (out) {
  return out.split(/[\r\n]+/)[1].trim().split(/\s/)[1];
}

function safeReaddirSync (path) {
  try {
    return readdirSync(path);
  } catch (e) {}
  return [];
}

var family = '';
var version = '';
var method = '';

if (platform === 'linux') {
  // Try getconf
  var glibc = spawnSync('getconf', ['GNU_LIBC_VERSION'], spawnOptions);
  if (glibc.status === 0) {
    family = GLIBC;
    version = glibc.stdout.trim().split(' ')[1];
    method = 'getconf';
  } else {
    // Try ldd
    var ldd = spawnSync('ldd', ['--version'], spawnOptions);
    if (ldd.status === 0 && ldd.stdout.indexOf(MUSL) !== -1) {
      family = MUSL;
      version = versionFromMuslLdd(ldd.stdout);
      method = 'ldd';
    } else if (ldd.status === 1 && ldd.stderr.indexOf(MUSL) !== -1) {
      family = MUSL;
      version = versionFromMuslLdd(ldd.stderr);
      method = 'ldd';
    } else {
      // Try filesystem (family only)
      var lib = safeReaddirSync('/lib');
      if (lib.some(contains('-linux-gnu'))) {
        family = GLIBC;
        method = 'filesystem';
      } else if (lib.some(contains('libc.musl-'))) {
        family = MUSL;
        method = 'filesystem';
      } else if (lib.some(contains('ld-musl-'))) {
        family = MUSL;
        method = 'filesystem';
      } else {
        var usrSbin = safeReaddirSync('/usr/sbin');
        if (usrSbin.some(contains('glibc'))) {
          family = GLIBC;
          method = 'filesystem';
        }
      }
    }
  }
}

var isNonGlibcLinux = (family !== '' && family !== GLIBC);

module.exports = {
  GLIBC: GLIBC,
  MUSL: MUSL,
  family: family,
  version: version,
  method: method,
  isNonGlibcLinux: isNonGlibcLinux
};


/***/ }),

/***/ "../../node_modules/findit2/index.js":
/*!************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/findit2/index.js ***!
  \************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var EventEmitter = __webpack_require__(/*! events */ "events").EventEmitter;
var fs = __webpack_require__(/*! fs */ "fs");
var path = __webpack_require__(/*! path */ "path");

module.exports = findit;

function findit(basedir, opts) {
  opts = opts || {};
  var followSymlinks = !!opts.followSymlinks;
  var myFs = opts.fs || fs;
  var emitter = new EventEmitter();
  var stopped = false;
  var pending = 0;
  var seen = {};

  emitter.stop = stop;
  walkPath(basedir);
  return emitter;

  function recursiveReadDir(basedir, linkPath) {
    pendStart();
    myFs.readdir(basedir, function(err, entries) {
      if (stopped) return;
      if (err) {
        handleError(err, basedir);
        pendEnd();
        return;
      }
      entries.forEach(function(entry) {
        var fullPath = path.join(basedir, entry);
        var fullLinkPath = linkPath && path.join(linkPath, entry);
        walkPath(fullPath, fullLinkPath);
      });
      pendEnd();
    });
  }

  function walkPath(fullPath, linkPath) {
    pendStart();
    myFs.lstat(fullPath, function(err, stats) {
      if (stopped) return;
      if (err) {
        handleError(err, fullPath);
        pendEnd();
        return;
      }
      emitter.emit('path', fullPath, stats, linkPath);
      var dirStopped = false;
      if (stats.isDirectory()) {
        if (seen[fullPath]) {
          err = new Error("file system loop detected");
          err.code = 'ELOOP';
          handleError(err, fullPath);
          pendEnd();
          return;
        }
        seen[fullPath] = true;

        emitter.emit('directory', fullPath, stats, stopDir, linkPath);
        if (!dirStopped) recursiveReadDir(fullPath, linkPath);
      } else if (stats.isFile()) {
        if (!seen[fullPath]) {
          seen[fullPath] = true;
          emitter.emit('file', fullPath, stats, linkPath);
        }
      } else if (stats.isSymbolicLink()) {
        emitter.emit('link', fullPath, stats, linkPath);
        if (followSymlinks) recursiveReadLink(fullPath);
      }
      pendEnd();

      function stopDir() {
        dirStopped = true;
      }
    });
  }

  function recursiveReadLink(linkPath) {
    pendStart();
    myFs.readlink(linkPath, function(err, linkString) {
      if (stopped) return;
      if (err) {
        handleError(err, linkPath);
        pendEnd();
        return;
      }
      var fullPath = path.resolve(path.dirname(linkPath), linkString);
      emitter.emit('readlink', linkPath, fullPath);
      walkPath(fullPath, linkPath);
      pendEnd();
    });
  }

  function stop() {
    if (stopped) return;
    stopped = true;
    emitter.emit('stop');
  }

  function handleError(err, errPath) {
    if (!err || stopped) return;
    err.path = errPath;
    emitter.emit('error', err);
  }

  function pendStart() {
    pending += 1;
  }

  function pendEnd() {
    if (stopped) return;
    pending -= 1;
    if (pending === 0) {
      emitter.emit('end');
    } else if (pending < 0) {
      // this should never happen; if this gets thrown we need to debug findit
      // and this stack trace will help.
      throw new Error("pendEnd called too many times");
    }
  }
}


/***/ }),

/***/ "../../node_modules/form-data/lib/form_data.js":
/*!**********************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/form-data/lib/form_data.js ***!
  \**********************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var CombinedStream = __webpack_require__(/*! combined-stream */ "../../node_modules/combined-stream/lib/combined_stream.js");
var util = __webpack_require__(/*! util */ "util");
var path = __webpack_require__(/*! path */ "path");
var http = __webpack_require__(/*! http */ "http");
var https = __webpack_require__(/*! https */ "https");
var parseUrl = __webpack_require__(/*! url */ "url").parse;
var fs = __webpack_require__(/*! fs */ "fs");
var mime = __webpack_require__(/*! mime-types */ "../../node_modules/mime-types/index.js");
var asynckit = __webpack_require__(/*! asynckit */ "../../node_modules/asynckit/index.js");
var populate = __webpack_require__(/*! ./populate.js */ "../../node_modules/form-data/lib/populate.js");

// Public API
module.exports = FormData;

// make it a Stream
util.inherits(FormData, CombinedStream);

/**
 * Create readable "multipart/form-data" streams.
 * Can be used to submit forms
 * and file uploads to other web applications.
 *
 * @constructor
 * @param {Object} options - Properties to be added/overriden for FormData and CombinedStream
 */
function FormData(options) {
  if (!(this instanceof FormData)) {
    return new FormData(options);
  }

  this._overheadLength = 0;
  this._valueLength = 0;
  this._valuesToMeasure = [];

  CombinedStream.call(this);

  options = options || {};
  for (var option in options) {
    this[option] = options[option];
  }
}

FormData.LINE_BREAK = '\r\n';
FormData.DEFAULT_CONTENT_TYPE = 'application/octet-stream';

FormData.prototype.append = function(field, value, options) {

  options = options || {};

  // allow filename as single option
  if (typeof options == 'string') {
    options = {filename: options};
  }

  var append = CombinedStream.prototype.append.bind(this);

  // all that streamy business can't handle numbers
  if (typeof value == 'number') {
    value = '' + value;
  }

  // https://github.com/felixge/node-form-data/issues/38
  if (util.isArray(value)) {
    // Please convert your array into string
    // the way web server expects it
    this._error(new Error('Arrays are not supported.'));
    return;
  }

  var header = this._multiPartHeader(field, value, options);
  var footer = this._multiPartFooter();

  append(header);
  append(value);
  append(footer);

  // pass along options.knownLength
  this._trackLength(header, value, options);
};

FormData.prototype._trackLength = function(header, value, options) {
  var valueLength = 0;

  // used w/ getLengthSync(), when length is known.
  // e.g. for streaming directly from a remote server,
  // w/ a known file a size, and not wanting to wait for
  // incoming file to finish to get its size.
  if (options.knownLength != null) {
    valueLength += +options.knownLength;
  } else if (Buffer.isBuffer(value)) {
    valueLength = value.length;
  } else if (typeof value === 'string') {
    valueLength = Buffer.byteLength(value);
  }

  this._valueLength += valueLength;

  // @check why add CRLF? does this account for custom/multiple CRLFs?
  this._overheadLength +=
    Buffer.byteLength(header) +
    FormData.LINE_BREAK.length;

  // empty or either doesn't have path or not an http response
  if (!value || ( !value.path && !(value.readable && value.hasOwnProperty('httpVersion')) )) {
    return;
  }

  // no need to bother with the length
  if (!options.knownLength) {
    this._valuesToMeasure.push(value);
  }
};

FormData.prototype._lengthRetriever = function(value, callback) {

  if (value.hasOwnProperty('fd')) {

    // take read range into a account
    // `end` = Infinity –> read file till the end
    //
    // TODO: Looks like there is bug in Node fs.createReadStream
    // it doesn't respect `end` options without `start` options
    // Fix it when node fixes it.
    // https://github.com/joyent/node/issues/7819
    if (value.end != undefined && value.end != Infinity && value.start != undefined) {

      // when end specified
      // no need to calculate range
      // inclusive, starts with 0
      callback(null, value.end + 1 - (value.start ? value.start : 0));

    // not that fast snoopy
    } else {
      // still need to fetch file size from fs
      fs.stat(value.path, function(err, stat) {

        var fileSize;

        if (err) {
          callback(err);
          return;
        }

        // update final size based on the range options
        fileSize = stat.size - (value.start ? value.start : 0);
        callback(null, fileSize);
      });
    }

  // or http response
  } else if (value.hasOwnProperty('httpVersion')) {
    callback(null, +value.headers['content-length']);

  // or request stream http://github.com/mikeal/request
  } else if (value.hasOwnProperty('httpModule')) {
    // wait till response come back
    value.on('response', function(response) {
      value.pause();
      callback(null, +response.headers['content-length']);
    });
    value.resume();

  // something else
  } else {
    callback('Unknown stream');
  }
};

FormData.prototype._multiPartHeader = function(field, value, options) {
  // custom header specified (as string)?
  // it becomes responsible for boundary
  // (e.g. to handle extra CRLFs on .NET servers)
  if (typeof options.header == 'string') {
    return options.header;
  }

  var contentDisposition = this._getContentDisposition(value, options);
  var contentType = this._getContentType(value, options);

  var contents = '';
  var headers  = {
    // add custom disposition as third element or keep it two elements if not
    'Content-Disposition': ['form-data', 'name="' + field + '"'].concat(contentDisposition || []),
    // if no content type. allow it to be empty array
    'Content-Type': [].concat(contentType || [])
  };

  // allow custom headers.
  if (typeof options.header == 'object') {
    populate(headers, options.header);
  }

  var header;
  for (var prop in headers) {
    if (!headers.hasOwnProperty(prop)) continue;
    header = headers[prop];

    // skip nullish headers.
    if (header == null) {
      continue;
    }

    // convert all headers to arrays.
    if (!Array.isArray(header)) {
      header = [header];
    }

    // add non-empty headers.
    if (header.length) {
      contents += prop + ': ' + header.join('; ') + FormData.LINE_BREAK;
    }
  }

  return '--' + this.getBoundary() + FormData.LINE_BREAK + contents + FormData.LINE_BREAK;
};

FormData.prototype._getContentDisposition = function(value, options) {

  var filename
    , contentDisposition
    ;

  if (typeof options.filepath === 'string') {
    // custom filepath for relative paths
    filename = path.normalize(options.filepath).replace(/\\/g, '/');
  } else if (options.filename || value.name || value.path) {
    // custom filename take precedence
    // formidable and the browser add a name property
    // fs- and request- streams have path property
    filename = path.basename(options.filename || value.name || value.path);
  } else if (value.readable && value.hasOwnProperty('httpVersion')) {
    // or try http response
    filename = path.basename(value.client._httpMessage.path || '');
  }

  if (filename) {
    contentDisposition = 'filename="' + filename + '"';
  }

  return contentDisposition;
};

FormData.prototype._getContentType = function(value, options) {

  // use custom content-type above all
  var contentType = options.contentType;

  // or try `name` from formidable, browser
  if (!contentType && value.name) {
    contentType = mime.lookup(value.name);
  }

  // or try `path` from fs-, request- streams
  if (!contentType && value.path) {
    contentType = mime.lookup(value.path);
  }

  // or if it's http-reponse
  if (!contentType && value.readable && value.hasOwnProperty('httpVersion')) {
    contentType = value.headers['content-type'];
  }

  // or guess it from the filepath or filename
  if (!contentType && (options.filepath || options.filename)) {
    contentType = mime.lookup(options.filepath || options.filename);
  }

  // fallback to the default content type if `value` is not simple value
  if (!contentType && typeof value == 'object') {
    contentType = FormData.DEFAULT_CONTENT_TYPE;
  }

  return contentType;
};

FormData.prototype._multiPartFooter = function() {
  return function(next) {
    var footer = FormData.LINE_BREAK;

    var lastPart = (this._streams.length === 0);
    if (lastPart) {
      footer += this._lastBoundary();
    }

    next(footer);
  }.bind(this);
};

FormData.prototype._lastBoundary = function() {
  return '--' + this.getBoundary() + '--' + FormData.LINE_BREAK;
};

FormData.prototype.getHeaders = function(userHeaders) {
  var header;
  var formHeaders = {
    'content-type': 'multipart/form-data; boundary=' + this.getBoundary()
  };

  for (header in userHeaders) {
    if (userHeaders.hasOwnProperty(header)) {
      formHeaders[header.toLowerCase()] = userHeaders[header];
    }
  }

  return formHeaders;
};

FormData.prototype.setBoundary = function(boundary) {
  this._boundary = boundary;
};

FormData.prototype.getBoundary = function() {
  if (!this._boundary) {
    this._generateBoundary();
  }

  return this._boundary;
};

FormData.prototype.getBuffer = function() {
  var dataBuffer = new Buffer.alloc( 0 );
  var boundary = this.getBoundary();

  // Create the form content. Add Line breaks to the end of data.
  for (var i = 0, len = this._streams.length; i < len; i++) {
    if (typeof this._streams[i] !== 'function') {

      // Add content to the buffer.
      if(Buffer.isBuffer(this._streams[i])) {
        dataBuffer = Buffer.concat( [dataBuffer, this._streams[i]]);
      }else {
        dataBuffer = Buffer.concat( [dataBuffer, Buffer.from(this._streams[i])]);
      }

      // Add break after content.
      if (typeof this._streams[i] !== 'string' || this._streams[i].substring( 2, boundary.length + 2 ) !== boundary) {
        dataBuffer = Buffer.concat( [dataBuffer, Buffer.from(FormData.LINE_BREAK)] );
      }
    }
  }

  // Add the footer and return the Buffer object.
  return Buffer.concat( [dataBuffer, Buffer.from(this._lastBoundary())] );
};

FormData.prototype._generateBoundary = function() {
  // This generates a 50 character boundary similar to those used by Firefox.
  // They are optimized for boyer-moore parsing.
  var boundary = '--------------------------';
  for (var i = 0; i < 24; i++) {
    boundary += Math.floor(Math.random() * 10).toString(16);
  }

  this._boundary = boundary;
};

// Note: getLengthSync DOESN'T calculate streams length
// As workaround one can calculate file size manually
// and add it as knownLength option
FormData.prototype.getLengthSync = function() {
  var knownLength = this._overheadLength + this._valueLength;

  // Don't get confused, there are 3 "internal" streams for each keyval pair
  // so it basically checks if there is any value added to the form
  if (this._streams.length) {
    knownLength += this._lastBoundary().length;
  }

  // https://github.com/form-data/form-data/issues/40
  if (!this.hasKnownLength()) {
    // Some async length retrievers are present
    // therefore synchronous length calculation is false.
    // Please use getLength(callback) to get proper length
    this._error(new Error('Cannot calculate proper length in synchronous way.'));
  }

  return knownLength;
};

// Public API to check if length of added values is known
// https://github.com/form-data/form-data/issues/196
// https://github.com/form-data/form-data/issues/262
FormData.prototype.hasKnownLength = function() {
  var hasKnownLength = true;

  if (this._valuesToMeasure.length) {
    hasKnownLength = false;
  }

  return hasKnownLength;
};

FormData.prototype.getLength = function(cb) {
  var knownLength = this._overheadLength + this._valueLength;

  if (this._streams.length) {
    knownLength += this._lastBoundary().length;
  }

  if (!this._valuesToMeasure.length) {
    process.nextTick(cb.bind(this, null, knownLength));
    return;
  }

  asynckit.parallel(this._valuesToMeasure, this._lengthRetriever, function(err, values) {
    if (err) {
      cb(err);
      return;
    }

    values.forEach(function(length) {
      knownLength += length;
    });

    cb(null, knownLength);
  });
};

FormData.prototype.submit = function(params, cb) {
  var request
    , options
    , defaults = {method: 'post'}
    ;

  // parse provided url if it's string
  // or treat it as options object
  if (typeof params == 'string') {

    params = parseUrl(params);
    options = populate({
      port: params.port,
      path: params.pathname,
      host: params.hostname,
      protocol: params.protocol
    }, defaults);

  // use custom params
  } else {

    options = populate(params, defaults);
    // if no port provided use default one
    if (!options.port) {
      options.port = options.protocol == 'https:' ? 443 : 80;
    }
  }

  // put that good code in getHeaders to some use
  options.headers = this.getHeaders(params.headers);

  // https if specified, fallback to http in any other case
  if (options.protocol == 'https:') {
    request = https.request(options);
  } else {
    request = http.request(options);
  }

  // get content length and fire away
  this.getLength(function(err, length) {
    if (err) {
      this._error(err);
      return;
    }

    // add content length
    request.setHeader('Content-Length', length);

    this.pipe(request);
    if (cb) {
      var onResponse;

      var callback = function (error, responce) {
        request.removeListener('error', callback);
        request.removeListener('response', onResponse);

        return cb.call(this, error, responce);
      };

      onResponse = callback.bind(this, null);

      request.on('error', callback);
      request.on('response', onResponse);
    }
  }.bind(this));

  return request;
};

FormData.prototype._error = function(err) {
  if (!this.error) {
    this.error = err;
    this.pause();
    this.emit('error', err);
  }
};

FormData.prototype.toString = function () {
  return '[object FormData]';
};


/***/ }),

/***/ "../../node_modules/import-in-the-middle/index.js":
/*!*************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/import-in-the-middle/index.js ***!
  \*************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

// Unless explicitly stated otherwise all files in this repository are licensed under the Apache 2.0 License.
//
// This product includes software developed at Datadog (https://www.datadoghq.com/). Copyright 2021 Datadog, Inc.

const path = __webpack_require__(/*! path */ "path")
const parse = __webpack_require__(/*! module-details-from-path */ "../../node_modules/module-details-from-path/index.js")
const { fileURLToPath } = __webpack_require__(/*! url */ "url")

const {
  importHooks,
  specifiers,
  toHook
} = __webpack_require__(/*! ./lib/register */ "../../node_modules/import-in-the-middle/lib/register.js")

function addHook(hook) {
  importHooks.push(hook)
  toHook.forEach(([name, namespace]) => hook(name, namespace))
}

function removeHook(hook) {
  const index = importHooks.indexOf(hook)
  if (index > -1) {
    importHooks.splice(index, 1)
  }
}

function callHookFn(hookFn, namespace, name, baseDir) {
  const newDefault = hookFn(namespace, name, baseDir)
  if (newDefault && newDefault !== namespace) {
    namespace.default = newDefault
  }
}

function Hook(modules, options, hookFn) {
  if ((this instanceof Hook) === false) return new Hook(modules, options, hookFn)
  if (typeof modules === 'function') {
    hookFn = modules
    modules = null
    options = null
  } else if (typeof options === 'function') {
    hookFn = options
    options = null
  }
  const internals = options ? options.internals === true : false

  this._iitmHook = (name, namespace) => {
    const filename = name
    const isBuiltin = name.startsWith('node:')
    let baseDir

    if (isBuiltin) {
      name = name.replace(/^node:/, '')
    } else {
      name = name.replace(/^file:\/\//, '')
      const details = parse(name)
      if (details) {
        name = details.name
        baseDir = details.basedir
      }
    }

    if (modules) {
      for (const moduleName of modules) {
        if (moduleName === name) {
          if (baseDir) {
            if (internals) {
              name = name + path.sep + path.relative(baseDir, fileURLToPath(filename))
            } else {
              if (!baseDir.endsWith(specifiers.get(filename))) continue
            }
          }
          callHookFn(hookFn, namespace, name, baseDir)
        }
      }
    } else {
      callHookFn(hookFn, namespace, name, baseDir)
    }
  }

  addHook(this._iitmHook)
}

Hook.prototype.unhook = function () {
  removeHook(this._iitmHook)
}

module.exports = Hook
module.exports.addHook = addHook
module.exports.removeHook = removeHook


/***/ }),

/***/ "../../node_modules/import-in-the-middle/lib/register.js":
/*!********************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/import-in-the-middle/lib/register.js ***!
  \********************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports) {

// Unless explicitly stated otherwise all files in this repository are licensed under the Apache 2.0 License.
//
// This product includes software developed at Datadog (https://www.datadoghq.com/). Copyright 2021 Datadog, Inc.


const importHooks = [] // TODO should this be a Set?
const setters = new WeakMap()
const specifiers = new Map()
const toHook = []

const proxyHandler = {
  set(target, name, value) {
    return setters.get(target)[name](value)
  },

  defineProperty(target, property, descriptor) {
    if ((!('value' in descriptor))) {
      throw new Error('Getters/setters are not supported for exports property descriptors.')
    }

    return setters.get(target)[property](descriptor.value)
  }
}

function register(name, namespace, set, specifier) {
  specifiers.set(name, specifier)
  setters.set(namespace, set)
  const proxy = new Proxy(namespace, proxyHandler)
  importHooks.forEach(hook => hook(name, proxy))
  toHook.push([name, proxy])
}

exports.register = register
exports.importHooks = importHooks
exports.specifiers = specifiers
exports.toHook = toHook


/***/ }),

/***/ "../../node_modules/koalas/index.js":
/*!***********************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/koalas/index.js ***!
  \***********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Coalesce function to find the first valid value.
 * A valid value is one that is not undefined, not null and not NaN (not a number).
 * If no values are valid, then the last argument is returned.
 *
 * ```js
 * console.log(koalas(undefined, null, NaN, 'a', 'b'));
 * //=> 'a'
 *
 * console.log(koalas(undefined, null, NaN, {a: 'b'}, 'b'));
 * //=> {a: 'b'}
 *
 * console.log(koalas(undefined, null, NaN, ['a', 'b', 'c'], {a: 'b'}, 'b'));
 * //=> ['a', 'b', 'c']
 *
 * console.log(koalas(undefined, NaN, null));
 * //=> null
 * ```
 * @name koalas
 * @param {Mixed} `arguments` Pass in any amount of arguments.
 * @return {Mixed} First valid value.
 * @api public
 */

function koalas() {
  var len = arguments.length;
  var arg;
  for (var i = 0; i < len; i++) {
    arg = arguments[i];
    if (hasValue(arg)) {
      return arg;
    }
  }
  return arg;
}

/**
 * Check to see if a value actually has a valid value:
 *  - not undefined
 *  - not null
 *  - not NaN (not a number)
 *
 * @param  {*} `val` value to check
 * @return {Boolean} returns `true` if the `val` has a valid value
 */

function hasValue(val) {
  // eslint-disable-next-line no-self-compare
  return val != null && val === val;
}

/**
 * Expose koalas
 */

module.exports = koalas;


/***/ }),

/***/ "../../node_modules/limiter/index.js":
/*!************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/limiter/index.js ***!
  \************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {


exports.RateLimiter = __webpack_require__(/*! ./lib/rateLimiter */ "../../node_modules/limiter/lib/rateLimiter.js");
exports.TokenBucket = __webpack_require__(/*! ./lib/tokenBucket */ "../../node_modules/limiter/lib/tokenBucket.js");


/***/ }),

/***/ "../../node_modules/limiter/lib/clock.js":
/*!****************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/limiter/lib/clock.js ***!
  \****************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports) {

var getMilliseconds = function() {
  if (typeof process !== 'undefined' && process.hrtime) {
    var hrtime = process.hrtime();
    var seconds = hrtime[0];
    var nanoseconds = hrtime[1];

    return seconds * 1e3 +  Math.floor(nanoseconds / 1e6);
  }

  return new Date().getTime();
}

module.exports = getMilliseconds;


/***/ }),

/***/ "../../node_modules/limiter/lib/rateLimiter.js":
/*!**********************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/limiter/lib/rateLimiter.js ***!
  \**********************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var TokenBucket = __webpack_require__(/*! ./tokenBucket */ "../../node_modules/limiter/lib/tokenBucket.js");
var getMilliseconds = __webpack_require__(/*! ./clock */ "../../node_modules/limiter/lib/clock.js");

/**
 * A generic rate limiter. Underneath the hood, this uses a token bucket plus
 * an additional check to limit how many tokens we can remove each interval.
 * @author John Hurliman <jhurliman@jhurliman.org>
 *
 * @param {Number} tokensPerInterval Maximum number of tokens that can be
 *  removed at any given moment and over the course of one interval.
 * @param {String|Number} interval The interval length in milliseconds, or as
 *  one of the following strings: 'second', 'minute', 'hour', day'.
 * @param {Boolean} fireImmediately Optional. Whether or not the callback
 *  will fire immediately when rate limiting is in effect (default is false).
 */
var RateLimiter = function(tokensPerInterval, interval, fireImmediately) {
  this.tokenBucket = new TokenBucket(tokensPerInterval, tokensPerInterval,
    interval, null);

  // Fill the token bucket to start
  this.tokenBucket.content = tokensPerInterval;

  this.curIntervalStart = getMilliseconds();
  this.tokensThisInterval = 0;
  this.fireImmediately = fireImmediately;
};

RateLimiter.prototype = {
  tokenBucket: null,
  curIntervalStart: 0,
  tokensThisInterval: 0,
  fireImmediately: false,

  /**
   * Remove the requested number of tokens and fire the given callback. If the
   * rate limiter contains enough tokens and we haven't spent too many tokens
   * in this interval already, this will happen immediately. Otherwise, the
   * removal and callback will happen when enough tokens become available.
   * @param {Number} count The number of tokens to remove.
   * @param {Function} callback(err, remainingTokens)
   * @returns {Boolean} True if the callback was fired immediately, otherwise
   *  false.
   */
  removeTokens: function(count, callback) {
    // Make sure the request isn't for more than we can handle
    if (count > this.tokenBucket.bucketSize) {
      process.nextTick(callback.bind(null, 'Requested tokens ' + count +
        ' exceeds maximum tokens per interval ' + this.tokenBucket.bucketSize,
        null));
      return false;
    }

    var self = this;
    var now = getMilliseconds();

    // Advance the current interval and reset the current interval token count
    // if needed
    if (now < this.curIntervalStart
      || now - this.curIntervalStart >= this.tokenBucket.interval) {
      this.curIntervalStart = now;
      this.tokensThisInterval = 0;
    }

    // If we don't have enough tokens left in this interval, wait until the
    // next interval
    if (count > this.tokenBucket.tokensPerInterval - this.tokensThisInterval) {
      if (this.fireImmediately) {
        process.nextTick(callback.bind(null, null, -1));
      } else {
        var waitInterval = Math.ceil(
          this.curIntervalStart + this.tokenBucket.interval - now);

        setTimeout(function() {
          self.tokenBucket.removeTokens(count, afterTokensRemoved);
        }, waitInterval);
      }
      return false;
    }

    // Remove the requested number of tokens from the token bucket
    return this.tokenBucket.removeTokens(count, afterTokensRemoved);

    function afterTokensRemoved(err, tokensRemaining) {
      if (err) return callback(err, null);

      self.tokensThisInterval += count;
      callback(null, tokensRemaining);
    }
  },

  /**
   * Attempt to remove the requested number of tokens and return immediately.
   * If the bucket (and any parent buckets) contains enough tokens and we
   * haven't spent too many tokens in this interval already, this will return
   * true. Otherwise, false is returned.
   * @param {Number} count The number of tokens to remove.
   * @param {Boolean} True if the tokens were successfully removed, otherwise
   *  false.
   */
  tryRemoveTokens: function(count) {
    // Make sure the request isn't for more than we can handle
    if (count > this.tokenBucket.bucketSize)
      return false;

    var now = getMilliseconds();

    // Advance the current interval and reset the current interval token count
    // if needed
    if (now < this.curIntervalStart
      || now - this.curIntervalStart >= this.tokenBucket.interval) {
      this.curIntervalStart = now;
      this.tokensThisInterval = 0;
    }

    // If we don't have enough tokens left in this interval, return false
    if (count > this.tokenBucket.tokensPerInterval - this.tokensThisInterval)
      return false;

    // Try to remove the requested number of tokens from the token bucket
    var removed = this.tokenBucket.tryRemoveTokens(count);
    if (removed) {
      this.tokensThisInterval += count;
    }
    return removed;
  },

  /**
   * Returns the number of tokens remaining in the TokenBucket.
   * @returns {Number} The number of tokens remaining.
   */
  getTokensRemaining: function () {
    this.tokenBucket.drip();
    return this.tokenBucket.content;
  }
};

module.exports = RateLimiter;


/***/ }),

/***/ "../../node_modules/limiter/lib/tokenBucket.js":
/*!**********************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/limiter/lib/tokenBucket.js ***!
  \**********************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports) {


/**
 * A hierarchical token bucket for rate limiting. See
 * http://en.wikipedia.org/wiki/Token_bucket for more information.
 * @author John Hurliman <jhurliman@cull.tv>
 *
 * @param {Number} bucketSize Maximum number of tokens to hold in the bucket.
 *  Also known as the burst rate.
 * @param {Number} tokensPerInterval Number of tokens to drip into the bucket
 *  over the course of one interval.
 * @param {String|Number} interval The interval length in milliseconds, or as
 *  one of the following strings: 'second', 'minute', 'hour', day'.
 * @param {TokenBucket} parentBucket Optional. A token bucket that will act as
 *  the parent of this bucket.
 */
var TokenBucket = function(bucketSize, tokensPerInterval, interval, parentBucket) {
  this.bucketSize = bucketSize;
  this.tokensPerInterval = tokensPerInterval;

  if (typeof interval === 'string') {
    switch (interval) {
      case 'sec': case 'second':
        this.interval = 1000; break;
      case 'min': case 'minute':
        this.interval = 1000 * 60; break;
      case 'hr': case 'hour':
        this.interval = 1000 * 60 * 60; break;
      case 'day':
        this.interval = 1000 * 60 * 60 * 24; break;
      default:
        throw new Error('Invaid interval ' + interval);
    }
  } else {
    this.interval = interval;
  }

  this.parentBucket = parentBucket;
  this.content = 0;
  this.lastDrip = +new Date();
};

TokenBucket.prototype = {
  bucketSize: 1,
  tokensPerInterval: 1,
  interval: 1000,
  parentBucket: null,
  content: 0,
  lastDrip: 0,

  /**
   * Remove the requested number of tokens and fire the given callback. If the
   * bucket (and any parent buckets) contains enough tokens this will happen
   * immediately. Otherwise, the removal and callback will happen when enough
   * tokens become available.
   * @param {Number} count The number of tokens to remove.
   * @param {Function} callback(err, remainingTokens)
   * @returns {Boolean} True if the callback was fired immediately, otherwise
   *  false.
   */
  removeTokens: function(count, callback) {
    var self = this;

    // Is this an infinite size bucket?
    if (!this.bucketSize) {
      process.nextTick(callback.bind(null, null, count, Number.POSITIVE_INFINITY));
      return true;
    }

    // Make sure the bucket can hold the requested number of tokens
    if (count > this.bucketSize) {
      process.nextTick(callback.bind(null, 'Requested tokens ' + count + ' exceeds bucket size ' +
        this.bucketSize, null));
      return false;
    }

    // Drip new tokens into this bucket
    this.drip();

    // If we don't have enough tokens in this bucket, come back later
    if (count > this.content)
      return comeBackLater();

    if (this.parentBucket) {
      // Remove the requested from the parent bucket first
      return this.parentBucket.removeTokens(count, function(err, remainingTokens) {
        if (err) return callback(err, null);

        // Check that we still have enough tokens in this bucket
        if (count > self.content)
          return comeBackLater();

        // Tokens were removed from the parent bucket, now remove them from
        // this bucket and fire the callback. Note that we look at the current
        // bucket and parent bucket's remaining tokens and return the smaller
        // of the two values
        self.content -= count;
        callback(null, Math.min(remainingTokens, self.content));
      });
    } else {
      // Remove the requested tokens from this bucket and fire the callback
      this.content -= count;
      process.nextTick(callback.bind(null, null, this.content));
      return true;
    }

    function comeBackLater() {
      // How long do we need to wait to make up the difference in tokens?
      var waitInterval = Math.ceil(
        (count - self.content) * (self.interval / self.tokensPerInterval));
      setTimeout(function() { self.removeTokens(count, callback); }, waitInterval);
      return false;
    }
  },

  /**
   * Attempt to remove the requested number of tokens and return immediately.
   * If the bucket (and any parent buckets) contains enough tokens this will
   * return true, otherwise false is returned.
   * @param {Number} count The number of tokens to remove.
   * @param {Boolean} True if the tokens were successfully removed, otherwise
   *  false.
   */
  tryRemoveTokens: function(count) {
    // Is this an infinite size bucket?
    if (!this.bucketSize)
      return true;

    // Make sure the bucket can hold the requested number of tokens
    if (count > this.bucketSize)
      return false;

    // Drip new tokens into this bucket
    this.drip();

    // If we don't have enough tokens in this bucket, return false
    if (count > this.content)
      return false;

    // Try to remove the requested tokens from the parent bucket
    if (this.parentBucket && !this.parentBucket.tryRemoveTokens(count))
      return false;

    // Remove the requested tokens from this bucket and return
    this.content -= count;
    return true;
  },

  /**
   * Add any new tokens to the bucket since the last drip.
   * @returns {Boolean} True if new tokens were added, otherwise false.
   */
  drip: function() {
    if (!this.tokensPerInterval) {
      this.content = this.bucketSize;
      return;
    }

    var now = +new Date();
    var deltaMS = Math.max(now - this.lastDrip, 0);
    this.lastDrip = now;

    var dripAmount = deltaMS * (this.tokensPerInterval / this.interval);
    this.content = Math.min(this.content + dripAmount, this.bucketSize);
  }
};

module.exports = TokenBucket;


/***/ }),

/***/ "../../node_modules/lodash.kebabcase/index.js":
/*!*********************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/lodash.kebabcase/index.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports) {

/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/** Used to match words composed of alphanumeric characters. */
var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;

/** Used to match Latin Unicode letters (excluding mathematical operators). */
var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;

/** Used to compose unicode character classes. */
var rsAstralRange = '\\ud800-\\udfff',
    rsComboMarksRange = '\\u0300-\\u036f\\ufe20-\\ufe23',
    rsComboSymbolsRange = '\\u20d0-\\u20f0',
    rsDingbatRange = '\\u2700-\\u27bf',
    rsLowerRange = 'a-z\\xdf-\\xf6\\xf8-\\xff',
    rsMathOpRange = '\\xac\\xb1\\xd7\\xf7',
    rsNonCharRange = '\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',
    rsPunctuationRange = '\\u2000-\\u206f',
    rsSpaceRange = ' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000',
    rsUpperRange = 'A-Z\\xc0-\\xd6\\xd8-\\xde',
    rsVarRange = '\\ufe0e\\ufe0f',
    rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;

/** Used to compose unicode capture groups. */
var rsApos = "['\u2019]",
    rsBreak = '[' + rsBreakRange + ']',
    rsCombo = '[' + rsComboMarksRange + rsComboSymbolsRange + ']',
    rsDigits = '\\d+',
    rsDingbat = '[' + rsDingbatRange + ']',
    rsLower = '[' + rsLowerRange + ']',
    rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']',
    rsFitz = '\\ud83c[\\udffb-\\udfff]',
    rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
    rsNonAstral = '[^' + rsAstralRange + ']',
    rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
    rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
    rsUpper = '[' + rsUpperRange + ']',
    rsZWJ = '\\u200d';

/** Used to compose unicode regexes. */
var rsLowerMisc = '(?:' + rsLower + '|' + rsMisc + ')',
    rsUpperMisc = '(?:' + rsUpper + '|' + rsMisc + ')',
    rsOptLowerContr = '(?:' + rsApos + '(?:d|ll|m|re|s|t|ve))?',
    rsOptUpperContr = '(?:' + rsApos + '(?:D|LL|M|RE|S|T|VE))?',
    reOptMod = rsModifier + '?',
    rsOptVar = '[' + rsVarRange + ']?',
    rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
    rsSeq = rsOptVar + reOptMod + rsOptJoin,
    rsEmoji = '(?:' + [rsDingbat, rsRegional, rsSurrPair].join('|') + ')' + rsSeq;

/** Used to match apostrophes. */
var reApos = RegExp(rsApos, 'g');

/**
 * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
 * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
 */
var reComboMark = RegExp(rsCombo, 'g');

/** Used to match complex or compound words. */
var reUnicodeWord = RegExp([
  rsUpper + '?' + rsLower + '+' + rsOptLowerContr + '(?=' + [rsBreak, rsUpper, '$'].join('|') + ')',
  rsUpperMisc + '+' + rsOptUpperContr + '(?=' + [rsBreak, rsUpper + rsLowerMisc, '$'].join('|') + ')',
  rsUpper + '?' + rsLowerMisc + '+' + rsOptLowerContr,
  rsUpper + '+' + rsOptUpperContr,
  rsDigits,
  rsEmoji
].join('|'), 'g');

/** Used to detect strings that need a more robust regexp to match words. */
var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2,}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;

/** Used to map Latin Unicode letters to basic Latin letters. */
var deburredLetters = {
  // Latin-1 Supplement block.
  '\xc0': 'A',  '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
  '\xe0': 'a',  '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
  '\xc7': 'C',  '\xe7': 'c',
  '\xd0': 'D',  '\xf0': 'd',
  '\xc8': 'E',  '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
  '\xe8': 'e',  '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
  '\xcc': 'I',  '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
  '\xec': 'i',  '\xed': 'i', '\xee': 'i', '\xef': 'i',
  '\xd1': 'N',  '\xf1': 'n',
  '\xd2': 'O',  '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
  '\xf2': 'o',  '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
  '\xd9': 'U',  '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
  '\xf9': 'u',  '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
  '\xdd': 'Y',  '\xfd': 'y', '\xff': 'y',
  '\xc6': 'Ae', '\xe6': 'ae',
  '\xde': 'Th', '\xfe': 'th',
  '\xdf': 'ss',
  // Latin Extended-A block.
  '\u0100': 'A',  '\u0102': 'A', '\u0104': 'A',
  '\u0101': 'a',  '\u0103': 'a', '\u0105': 'a',
  '\u0106': 'C',  '\u0108': 'C', '\u010a': 'C', '\u010c': 'C',
  '\u0107': 'c',  '\u0109': 'c', '\u010b': 'c', '\u010d': 'c',
  '\u010e': 'D',  '\u0110': 'D', '\u010f': 'd', '\u0111': 'd',
  '\u0112': 'E',  '\u0114': 'E', '\u0116': 'E', '\u0118': 'E', '\u011a': 'E',
  '\u0113': 'e',  '\u0115': 'e', '\u0117': 'e', '\u0119': 'e', '\u011b': 'e',
  '\u011c': 'G',  '\u011e': 'G', '\u0120': 'G', '\u0122': 'G',
  '\u011d': 'g',  '\u011f': 'g', '\u0121': 'g', '\u0123': 'g',
  '\u0124': 'H',  '\u0126': 'H', '\u0125': 'h', '\u0127': 'h',
  '\u0128': 'I',  '\u012a': 'I', '\u012c': 'I', '\u012e': 'I', '\u0130': 'I',
  '\u0129': 'i',  '\u012b': 'i', '\u012d': 'i', '\u012f': 'i', '\u0131': 'i',
  '\u0134': 'J',  '\u0135': 'j',
  '\u0136': 'K',  '\u0137': 'k', '\u0138': 'k',
  '\u0139': 'L',  '\u013b': 'L', '\u013d': 'L', '\u013f': 'L', '\u0141': 'L',
  '\u013a': 'l',  '\u013c': 'l', '\u013e': 'l', '\u0140': 'l', '\u0142': 'l',
  '\u0143': 'N',  '\u0145': 'N', '\u0147': 'N', '\u014a': 'N',
  '\u0144': 'n',  '\u0146': 'n', '\u0148': 'n', '\u014b': 'n',
  '\u014c': 'O',  '\u014e': 'O', '\u0150': 'O',
  '\u014d': 'o',  '\u014f': 'o', '\u0151': 'o',
  '\u0154': 'R',  '\u0156': 'R', '\u0158': 'R',
  '\u0155': 'r',  '\u0157': 'r', '\u0159': 'r',
  '\u015a': 'S',  '\u015c': 'S', '\u015e': 'S', '\u0160': 'S',
  '\u015b': 's',  '\u015d': 's', '\u015f': 's', '\u0161': 's',
  '\u0162': 'T',  '\u0164': 'T', '\u0166': 'T',
  '\u0163': 't',  '\u0165': 't', '\u0167': 't',
  '\u0168': 'U',  '\u016a': 'U', '\u016c': 'U', '\u016e': 'U', '\u0170': 'U', '\u0172': 'U',
  '\u0169': 'u',  '\u016b': 'u', '\u016d': 'u', '\u016f': 'u', '\u0171': 'u', '\u0173': 'u',
  '\u0174': 'W',  '\u0175': 'w',
  '\u0176': 'Y',  '\u0177': 'y', '\u0178': 'Y',
  '\u0179': 'Z',  '\u017b': 'Z', '\u017d': 'Z',
  '\u017a': 'z',  '\u017c': 'z', '\u017e': 'z',
  '\u0132': 'IJ', '\u0133': 'ij',
  '\u0152': 'Oe', '\u0153': 'oe',
  '\u0149': "'n", '\u017f': 'ss'
};

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/**
 * A specialized version of `_.reduce` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {*} [accumulator] The initial value.
 * @param {boolean} [initAccum] Specify using the first element of `array` as
 *  the initial value.
 * @returns {*} Returns the accumulated value.
 */
function arrayReduce(array, iteratee, accumulator, initAccum) {
  var index = -1,
      length = array ? array.length : 0;

  if (initAccum && length) {
    accumulator = array[++index];
  }
  while (++index < length) {
    accumulator = iteratee(accumulator, array[index], index, array);
  }
  return accumulator;
}

/**
 * Splits an ASCII `string` into an array of its words.
 *
 * @private
 * @param {string} The string to inspect.
 * @returns {Array} Returns the words of `string`.
 */
function asciiWords(string) {
  return string.match(reAsciiWord) || [];
}

/**
 * The base implementation of `_.propertyOf` without support for deep paths.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Function} Returns the new accessor function.
 */
function basePropertyOf(object) {
  return function(key) {
    return object == null ? undefined : object[key];
  };
}

/**
 * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A
 * letters to basic Latin letters.
 *
 * @private
 * @param {string} letter The matched letter to deburr.
 * @returns {string} Returns the deburred letter.
 */
var deburrLetter = basePropertyOf(deburredLetters);

/**
 * Checks if `string` contains a word composed of Unicode symbols.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {boolean} Returns `true` if a word is found, else `false`.
 */
function hasUnicodeWord(string) {
  return reHasUnicodeWord.test(string);
}

/**
 * Splits a Unicode `string` into an array of its words.
 *
 * @private
 * @param {string} The string to inspect.
 * @returns {Array} Returns the words of `string`.
 */
function unicodeWords(string) {
  return string.match(reUnicodeWord) || [];
}

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/** Built-in value references. */
var Symbol = root.Symbol;

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolToString = symbolProto ? symbolProto.toString : undefined;

/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

/**
 * Creates a function like `_.camelCase`.
 *
 * @private
 * @param {Function} callback The function to combine each word.
 * @returns {Function} Returns the new compounder function.
 */
function createCompounder(callback) {
  return function(string) {
    return arrayReduce(words(deburr(string).replace(reApos, '')), callback, '');
  };
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && objectToString.call(value) == symbolTag);
}

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString(value) {
  return value == null ? '' : baseToString(value);
}

/**
 * Deburrs `string` by converting
 * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
 * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)
 * letters to basic Latin letters and removing
 * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to deburr.
 * @returns {string} Returns the deburred string.
 * @example
 *
 * _.deburr('déjà vu');
 * // => 'deja vu'
 */
function deburr(string) {
  string = toString(string);
  return string && string.replace(reLatin, deburrLetter).replace(reComboMark, '');
}

/**
 * Converts `string` to
 * [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to convert.
 * @returns {string} Returns the kebab cased string.
 * @example
 *
 * _.kebabCase('Foo Bar');
 * // => 'foo-bar'
 *
 * _.kebabCase('fooBar');
 * // => 'foo-bar'
 *
 * _.kebabCase('__FOO_BAR__');
 * // => 'foo-bar'
 */
var kebabCase = createCompounder(function(result, word, index) {
  return result + (index ? '-' : '') + word.toLowerCase();
});

/**
 * Splits `string` into an array of its words.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to inspect.
 * @param {RegExp|string} [pattern] The pattern to match words.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {Array} Returns the words of `string`.
 * @example
 *
 * _.words('fred, barney, & pebbles');
 * // => ['fred', 'barney', 'pebbles']
 *
 * _.words('fred, barney, & pebbles', /[^, ]+/g);
 * // => ['fred', 'barney', '&', 'pebbles']
 */
function words(string, pattern, guard) {
  string = toString(string);
  pattern = guard ? undefined : pattern;

  if (pattern === undefined) {
    return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
  }
  return string.match(pattern) || [];
}

module.exports = kebabCase;


/***/ }),

/***/ "../../node_modules/lodash.pick/index.js":
/*!****************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/lodash.pick/index.js ***!
  \****************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports) {

/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0,
    MAX_SAFE_INTEGER = 9007199254740991;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    symbolTag = '[object Symbol]';

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0: return func.call(thisArg);
    case 1: return func.call(thisArg, args[0]);
    case 2: return func.call(thisArg, args[0], args[1]);
    case 3: return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}

/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array ? array.length : 0,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}

/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/** Built-in value references. */
var Symbol = root.Symbol,
    propertyIsEnumerable = objectProto.propertyIsEnumerable,
    spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * The base implementation of `_.flatten` with support for restricting flattening.
 *
 * @private
 * @param {Array} array The array to flatten.
 * @param {number} depth The maximum recursion depth.
 * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
 * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
 * @param {Array} [result=[]] The initial result value.
 * @returns {Array} Returns the new flattened array.
 */
function baseFlatten(array, depth, predicate, isStrict, result) {
  var index = -1,
      length = array.length;

  predicate || (predicate = isFlattenable);
  result || (result = []);

  while (++index < length) {
    var value = array[index];
    if (depth > 0 && predicate(value)) {
      if (depth > 1) {
        // Recursively flatten arrays (susceptible to call stack limits).
        baseFlatten(value, depth - 1, predicate, isStrict, result);
      } else {
        arrayPush(result, value);
      }
    } else if (!isStrict) {
      result[result.length] = value;
    }
  }
  return result;
}

/**
 * The base implementation of `_.pick` without support for individual
 * property identifiers.
 *
 * @private
 * @param {Object} object The source object.
 * @param {string[]} props The property identifiers to pick.
 * @returns {Object} Returns the new object.
 */
function basePick(object, props) {
  object = Object(object);
  return basePickBy(object, props, function(value, key) {
    return key in object;
  });
}

/**
 * The base implementation of  `_.pickBy` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The source object.
 * @param {string[]} props The property identifiers to pick from.
 * @param {Function} predicate The function invoked per property.
 * @returns {Object} Returns the new object.
 */
function basePickBy(object, props, predicate) {
  var index = -1,
      length = props.length,
      result = {};

  while (++index < length) {
    var key = props[index],
        value = object[key];

    if (predicate(value, key)) {
      result[key] = value;
    }
  }
  return result;
}

/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */
function baseRest(func, start) {
  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
  return function() {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }
    index = -1;
    var otherArgs = Array(start + 1);
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = array;
    return apply(func, this, otherArgs);
  };
}

/**
 * Checks if `value` is a flattenable `arguments` object or array.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
 */
function isFlattenable(value) {
  return isArray(value) || isArguments(value) ||
    !!(spreadableSymbol && value && value[spreadableSymbol]);
}

/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */
function toKey(value) {
  if (typeof value == 'string' || isSymbol(value)) {
    return value;
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
function isArguments(value) {
  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
  return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') &&
    (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
}

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */
function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 8-9 which returns 'object' for typed array and other constructors.
  var tag = isObject(value) ? objectToString.call(value) : '';
  return tag == funcTag || tag == genTag;
}

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && objectToString.call(value) == symbolTag);
}

/**
 * Creates an object composed of the picked `object` properties.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The source object.
 * @param {...(string|string[])} [props] The property identifiers to pick.
 * @returns {Object} Returns the new object.
 * @example
 *
 * var object = { 'a': 1, 'b': '2', 'c': 3 };
 *
 * _.pick(object, ['a', 'c']);
 * // => { 'a': 1, 'c': 3 }
 */
var pick = baseRest(function(object, props) {
  return object == null ? {} : basePick(object, arrayMap(baseFlatten(props, 1), toKey));
});

module.exports = pick;


/***/ }),

/***/ "../../node_modules/lodash.uniq/index.js":
/*!****************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/lodash.uniq/index.js ***!
  \****************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports) {

/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/** `Object#toString` result references. */
var funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]';

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/**
 * A specialized version of `_.includes` for arrays without support for
 * specifying an index to search from.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */
function arrayIncludes(array, value) {
  var length = array ? array.length : 0;
  return !!length && baseIndexOf(array, value, 0) > -1;
}

/**
 * This function is like `arrayIncludes` except that it accepts a comparator.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @param {Function} comparator The comparator invoked per element.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */
function arrayIncludesWith(array, value, comparator) {
  var index = -1,
      length = array ? array.length : 0;

  while (++index < length) {
    if (comparator(value, array[index])) {
      return true;
    }
  }
  return false;
}

/**
 * The base implementation of `_.findIndex` and `_.findLastIndex` without
 * support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} predicate The function invoked per iteration.
 * @param {number} fromIndex The index to search from.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseFindIndex(array, predicate, fromIndex, fromRight) {
  var length = array.length,
      index = fromIndex + (fromRight ? 1 : -1);

  while ((fromRight ? index-- : ++index < length)) {
    if (predicate(array[index], index, array)) {
      return index;
    }
  }
  return -1;
}

/**
 * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseIndexOf(array, value, fromIndex) {
  if (value !== value) {
    return baseFindIndex(array, baseIsNaN, fromIndex);
  }
  var index = fromIndex - 1,
      length = array.length;

  while (++index < length) {
    if (array[index] === value) {
      return index;
    }
  }
  return -1;
}

/**
 * The base implementation of `_.isNaN` without support for number objects.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
 */
function baseIsNaN(value) {
  return value !== value;
}

/**
 * Checks if a cache value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function cacheHas(cache, key) {
  return cache.has(key);
}

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

/**
 * Checks if `value` is a host object in IE < 9.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
 */
function isHostObject(value) {
  // Many host objects are `Object` objects that can coerce to strings
  // despite having improperly defined `toString` methods.
  var result = false;
  if (value != null && typeof value.toString != 'function') {
    try {
      result = !!(value + '');
    } catch (e) {}
  }
  return result;
}

/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */
function setToArray(set) {
  var index = -1,
      result = Array(set.size);

  set.forEach(function(value) {
    result[++index] = value;
  });
  return result;
}

/** Used for built-in method references. */
var arrayProto = Array.prototype,
    funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/** Built-in value references. */
var splice = arrayProto.splice;

/* Built-in method references that are verified to be native. */
var Map = getNative(root, 'Map'),
    Set = getNative(root, 'Set'),
    nativeCreate = getNative(Object, 'create');

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
}

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  return this.has(key) && delete this.__data__[key];
}

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
}

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
}

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  return true;
}

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  return getMapData(this, key)['delete'](key);
}

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  getMapData(this, key).set(key, value);
  return this;
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */
function SetCache(values) {
  var index = -1,
      length = values ? values.length : 0;

  this.__data__ = new MapCache;
  while (++index < length) {
    this.add(values[index]);
  }
}

/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}

/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */
function setCacheHas(value) {
  return this.__data__.has(value);
}

// Add methods to `SetCache`.
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

/**
 * The base implementation of `_.uniqBy` without support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} [iteratee] The iteratee invoked per element.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new duplicate free array.
 */
function baseUniq(array, iteratee, comparator) {
  var index = -1,
      includes = arrayIncludes,
      length = array.length,
      isCommon = true,
      result = [],
      seen = result;

  if (comparator) {
    isCommon = false;
    includes = arrayIncludesWith;
  }
  else if (length >= LARGE_ARRAY_SIZE) {
    var set = iteratee ? null : createSet(array);
    if (set) {
      return setToArray(set);
    }
    isCommon = false;
    includes = cacheHas;
    seen = new SetCache;
  }
  else {
    seen = iteratee ? [] : result;
  }
  outer:
  while (++index < length) {
    var value = array[index],
        computed = iteratee ? iteratee(value) : value;

    value = (comparator || value !== 0) ? value : 0;
    if (isCommon && computed === computed) {
      var seenIndex = seen.length;
      while (seenIndex--) {
        if (seen[seenIndex] === computed) {
          continue outer;
        }
      }
      if (iteratee) {
        seen.push(computed);
      }
      result.push(value);
    }
    else if (!includes(seen, computed, comparator)) {
      if (seen !== result) {
        seen.push(computed);
      }
      result.push(value);
    }
  }
  return result;
}

/**
 * Creates a set object of `values`.
 *
 * @private
 * @param {Array} values The values to add to the set.
 * @returns {Object} Returns the new set.
 */
var createSet = !(Set && (1 / setToArray(new Set([,-0]))[1]) == INFINITY) ? noop : function(values) {
  return new Set(values);
};

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to process.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

/**
 * Creates a duplicate-free version of an array, using
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons, in which only the first occurrence of each
 * element is kept.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @returns {Array} Returns the new duplicate free array.
 * @example
 *
 * _.uniq([2, 1, 2]);
 * // => [2, 1]
 */
function uniq(array) {
  return (array && array.length)
    ? baseUniq(array)
    : [];
}

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 8-9 which returns 'object' for typed array and other constructors.
  var tag = isObject(value) ? objectToString.call(value) : '';
  return tag == funcTag || tag == genTag;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * This method returns `undefined`.
 *
 * @static
 * @memberOf _
 * @since 2.3.0
 * @category Util
 * @example
 *
 * _.times(2, _.noop);
 * // => [undefined, undefined]
 */
function noop() {
  // No operation performed.
}

module.exports = uniq;


/***/ }),

/***/ "../../node_modules/module-details-from-path/index.js":
/*!*****************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/module-details-from-path/index.js ***!
  \*****************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var path = __webpack_require__(/*! path */ "path")

module.exports = function (file) {
  var segments = file.split(path.sep)
  var index = segments.lastIndexOf('node_modules')
  if (index === -1) return
  if (!segments[index + 1]) return
  var scoped = segments[index + 1][0] === '@'
  var name = scoped ? segments[index + 1] + '/' + segments[index + 2] : segments[index + 1]
  var offset = scoped ? 3 : 2
  return {
    name: name,
    basedir: segments.slice(0, index + offset).join(path.sep),
    path: segments.slice(index + offset).join(path.sep)
  }
}


/***/ }),

/***/ "../../node_modules/node-gyp-build/index.js":
/*!*******************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/node-gyp-build/index.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var fs = __webpack_require__(/*! fs */ "fs")
var path = __webpack_require__(/*! path */ "path")
var os = __webpack_require__(/*! os */ "os")

// Workaround to fix webpack's build warnings: 'the request of a dependency is an expression'
var runtimeRequire =  true ? require : undefined // eslint-disable-line

var prebuildsOnly = !!process.env.PREBUILDS_ONLY
var abi = process.versions.modules // TODO: support old node where this is undef
var runtime = isElectron() ? 'electron' : 'node'
var arch = os.arch()
var platform = os.platform()
var libc = process.env.LIBC || (isAlpine(platform) ? 'musl' : 'glibc')
var armv = process.env.ARM_VERSION || (arch === 'arm64' ? '8' : process.config.variables.arm_version) || ''

module.exports = load

function load (dir) {
  return runtimeRequire(load.path(dir))
}

load.path = function (dir) {
  dir = path.resolve(dir || '.')

  try {
    var name = runtimeRequire(path.join(dir, 'package.json')).name.toUpperCase().replace(/-/g, '_')
    if (process.env[name + '_PREBUILD']) dir = process.env[name + '_PREBUILD']
  } catch (err) {}

  if (!prebuildsOnly) {
    var release = getFirst(path.join(dir, 'build/Release'), matchBuild)
    if (release) return release

    var debug = getFirst(path.join(dir, 'build/Debug'), matchBuild)
    if (debug) return debug
  }

  var names = [platform + '-' + arch]
  if (libc) names.push(platform + libc + '-' + arch)

  if ((arch === 'arm' || arch === 'arm64') && armv) {
    names.forEach(function (name) {
      names.push(name + '-v' + armv)
    })
  }

  // Find most specific flavor first
  for (var i = names.length; i--;) {
    var prebuild = getFirst(path.join(dir, 'prebuilds/' + names[i]), matchPrebuild)
    if (prebuild) return prebuild

    var napiRuntime = getFirst(path.join(dir, 'prebuilds/' + names[i]), matchNapiRuntime)
    if (napiRuntime) return napiRuntime

    var napi = getFirst(path.join(dir, 'prebuilds/' + names[i]), matchNapi)
    if (napi) return napi
  }

  throw new Error('No native build was found for runtime=' + runtime + ' abi=' + abi + ' platform=' + platform + libc + ' arch=' + arch)
}

function getFirst (dir, filter) {
  try {
    var files = fs.readdirSync(dir).filter(filter)
    return files[0] && path.join(dir, files[0])
  } catch (err) {
    return null
  }
}

function matchNapiRuntime (name) {
  return name === runtime + '-napi.node'
}

function matchNapi (name) {
  return name === 'node-napi.node'
}

function matchPrebuild (name) {
  var parts = name.split('-')
  return parts[0] === runtime && parts[1] === abi + '.node'
}

function matchBuild (name) {
  return /\.node$/.test(name)
}

function isElectron () {
  if (process.versions && process.versions.electron) return true
  if (process.env.ELECTRON_RUN_AS_NODE) return true
  return typeof window !== 'undefined' && window.process && window.process.type === 'renderer'
}

function isAlpine (platform) {
  return platform === 'linux' && fs.existsSync('/etc/alpine-release')
}


/***/ }),

/***/ "../../node_modules/opentracing/lib/binary_carrier.js":
/*!*****************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/opentracing/lib/binary_carrier.js ***!
  \*****************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Convenience class to use as a binary carrier.
 *
 * Any valid Object with a field named `buffer` may be used as a binary carrier;
 * this class is only one such type of object that can be used.
 */
var BinaryCarrier = /** @class */ (function () {
    function BinaryCarrier(buffer) {
        this.buffer = buffer;
    }
    return BinaryCarrier;
}());
exports.default = BinaryCarrier;
//# sourceMappingURL=binary_carrier.js.map

/***/ }),

/***/ "../../node_modules/opentracing/lib/constants.js":
/*!************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/opentracing/lib/constants.js ***!
  \************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * The FORMAT_BINARY format represents SpanContexts in an opaque binary
 * carrier.
 *
 * Tracer.inject() will set the buffer field to an Array-like (Array,
 * ArrayBuffer, or TypedBuffer) object containing the injected binary data.
 * Any valid Object can be used as long as the buffer field of the object
 * can be set.
 *
 * Tracer.extract() will look for `carrier.buffer`, and that field is
 * expected to be an Array-like object (Array, ArrayBuffer, or
 * TypedBuffer).
 */
exports.FORMAT_BINARY = 'binary';
/**
 * The FORMAT_TEXT_MAP format represents SpanContexts using a
 * string->string map (backed by a Javascript Object) as a carrier.
 *
 * NOTE: Unlike FORMAT_HTTP_HEADERS, FORMAT_TEXT_MAP places no restrictions
 * on the characters used in either the keys or the values of the map
 * entries.
 *
 * The FORMAT_TEXT_MAP carrier map may contain unrelated data (e.g.,
 * arbitrary gRPC metadata); as such, the Tracer implementation should use
 * a prefix or other convention to distinguish Tracer-specific key:value
 * pairs.
 */
exports.FORMAT_TEXT_MAP = 'text_map';
/**
 * The FORMAT_HTTP_HEADERS format represents SpanContexts using a
 * character-restricted string->string map (backed by a Javascript Object)
 * as a carrier.
 *
 * Keys and values in the FORMAT_HTTP_HEADERS carrier must be suitable for
 * use as HTTP headers (without modification or further escaping). That is,
 * the keys have a greatly restricted character set, casing for the keys
 * may not be preserved by various intermediaries, and the values should be
 * URL-escaped.
 *
 * The FORMAT_HTTP_HEADERS carrier map may contain unrelated data (e.g.,
 * arbitrary HTTP headers); as such, the Tracer implementation should use a
 * prefix or other convention to distinguish Tracer-specific key:value
 * pairs.
 */
exports.FORMAT_HTTP_HEADERS = 'http_headers';
/**
 * A Span may be the "child of" a parent Span. In a “child of” reference,
 * the parent Span depends on the child Span in some capacity.
 *
 * See more about reference types at https://github.com/opentracing/specification
 */
exports.REFERENCE_CHILD_OF = 'child_of';
/**
 * Some parent Spans do not depend in any way on the result of their child
 * Spans. In these cases, we say merely that the child Span “follows from”
 * the parent Span in a causal sense.
 *
 * See more about reference types at https://github.com/opentracing/specification
 */
exports.REFERENCE_FOLLOWS_FROM = 'follows_from';
//# sourceMappingURL=constants.js.map

/***/ }),

/***/ "../../node_modules/opentracing/lib/ext/tags.js":
/*!***********************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/opentracing/lib/ext/tags.js ***!
  \***********************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/** SPAN_KIND hints at relationship between spans, e.g. client/server */
exports.SPAN_KIND = 'span.kind';
/** Marks a span representing the client-side of an RPC or other remote call */
exports.SPAN_KIND_RPC_CLIENT = 'client';
/** Marks a span representing the server-side of an RPC or other remote call */
exports.SPAN_KIND_RPC_SERVER = 'server';
/** Marks a span representing the producing-side within a messaging system or other remote call */
exports.SPAN_KIND_MESSAGING_PRODUCER = 'producer';
/** Marks a span representing the consuming-side within a messaging system or other remote call */
exports.SPAN_KIND_MESSAGING_CONSUMER = 'consumer';
/**
 * ERROR (boolean) true if and only if the application considers the operation
 * represented by the Span to have failed
 */
exports.ERROR = 'error';
/**
 * COMPONENT (string) ia s low-cardinality identifier of the module, library,
 * or package that is generating a span.
 */
exports.COMPONENT = 'component';
/**
 * SAMPLING_PRIORITY (number) determines the priority of sampling this Span.
 * If greater than 0, a hint to the Tracer to do its best to capture the trace.
 * If 0, a hint to the trace to not-capture the trace. If absent, the Tracer
 * should use its default sampling mechanism.
 */
exports.SAMPLING_PRIORITY = 'sampling.priority';
// ---------------------------------------------------------------------------
// PEER_* tags can be emitted by either client-side of server-side to describe
// the other side/service in a peer-to-peer communications, like an RPC call.
// ---------------------------------------------------------------------------
/**
 * PEER_SERVICE (string) Remote service name (for some unspecified
 * definition of "service"). E.g., "elasticsearch", "a_custom_microservice", "memcache"
 */
exports.PEER_SERVICE = 'peer.service';
/** PEER_HOSTNAME (string) Remote hostname. E.g., "opentracing.io", "internal.dns.name" */
exports.PEER_HOSTNAME = 'peer.hostname';
/**
 * PEER_ADDRESS (string) Remote "address", suitable for use in a
 * networking client library. This may be a "ip:port", a bare
 * "hostname", a FQDN, or even a JDBC substring like "mysql://prod-db:3306"
 */
exports.PEER_ADDRESS = 'peer.address';
/**
 * PEER_HOST_IPV4 (number) Remote IPv4 address as a .-separated tuple.
 * E.g., "127.0.0.1"
 */
exports.PEER_HOST_IPV4 = 'peer.ipv4';
// PEER_HOST_IPV6 (string) Remote IPv6 address as a string of
// colon-separated 4-char hex tuples. E.g., "2001:0db8:85a3:0000:0000:8a2e:0370:7334"
exports.PEER_HOST_IPV6 = 'peer.ipv6';
// PEER_PORT (number) Remote port. E.g., 80
exports.PEER_PORT = 'peer.port';
// ---------------------------------------------------------------------------
// HTTP tags
// ---------------------------------------------------------------------------
/**
 * HTTP_URL (string) URL of the request being handled in this segment of the
 * trace, in standard URI format. E.g., "https://domain.net/path/to?resource=here"
 */
exports.HTTP_URL = 'http.url';
/**
 * HTTP_METHOD (string) HTTP method of the request for the associated Span. E.g.,
 * "GET", "POST"
 */
exports.HTTP_METHOD = 'http.method';
/**
 * HTTP_STATUS_CODE (number) HTTP response status code for the associated Span.
 * E.g., 200, 503, 404
 */
exports.HTTP_STATUS_CODE = 'http.status_code';
// -------------------------------------------------------------------------
// Messaging tags
// -------------------------------------------------------------------------
/**
 * MESSAGE_BUS_DESTINATION (string) An address at which messages can be exchanged.
 * E.g. A Kafka record has an associated "topic name" that can be extracted
 * by the instrumented producer or consumer and stored using this tag.
 */
exports.MESSAGE_BUS_DESTINATION = 'message_bus.destination';
// --------------------------------------------------------------------------
// Database tags
// --------------------------------------------------------------------------
/**
 * DB_INSTANCE (string) Database instance name. E.g., In java, if the
 * jdbc.url="jdbc:mysql://127.0.0.1:3306/customers", the instance name is "customers".
 */
exports.DB_INSTANCE = 'db.instance';
/**
 * DB_STATEMENT (string) A database statement for the given database type.
 * E.g., for db.type="SQL", "SELECT * FROM wuser_table";
 * for db.type="redis", "SET mykey 'WuValue'".
 */
exports.DB_STATEMENT = 'db.statement';
/**
 * DB_TYPE (string) Database type. For any SQL database, "sql". For others,
 * the lower-case database category, e.g. "cassandra", "hbase", or "redis".
 */
exports.DB_TYPE = 'db.type';
/**
 * DB_USER (string) Username for accessing database. E.g., "readonly_user"
 * or "reporting_user"
 */
exports.DB_USER = 'db.user';
//# sourceMappingURL=tags.js.map

/***/ }),

/***/ "../../node_modules/opentracing/lib/functions.js":
/*!************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/opentracing/lib/functions.js ***!
  \************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var Constants = __webpack_require__(/*! ./constants */ "../../node_modules/opentracing/lib/constants.js");
var reference_1 = __webpack_require__(/*! ./reference */ "../../node_modules/opentracing/lib/reference.js");
var span_1 = __webpack_require__(/*! ./span */ "../../node_modules/opentracing/lib/span.js");
/**
 * Return a new REFERENCE_CHILD_OF reference.
 *
 * @param {SpanContext} spanContext - the parent SpanContext instance to
 *        reference.
 * @return a REFERENCE_CHILD_OF reference pointing to `spanContext`
 */
function childOf(spanContext) {
    // Allow the user to pass a Span instead of a SpanContext
    if (spanContext instanceof span_1.default) {
        spanContext = spanContext.context();
    }
    return new reference_1.default(Constants.REFERENCE_CHILD_OF, spanContext);
}
exports.childOf = childOf;
/**
 * Return a new REFERENCE_FOLLOWS_FROM reference.
 *
 * @param {SpanContext} spanContext - the parent SpanContext instance to
 *        reference.
 * @return a REFERENCE_FOLLOWS_FROM reference pointing to `spanContext`
 */
function followsFrom(spanContext) {
    // Allow the user to pass a Span instead of a SpanContext
    if (spanContext instanceof span_1.default) {
        spanContext = spanContext.context();
    }
    return new reference_1.default(Constants.REFERENCE_FOLLOWS_FROM, spanContext);
}
exports.followsFrom = followsFrom;
//# sourceMappingURL=functions.js.map

/***/ }),

/***/ "../../node_modules/opentracing/lib/global_tracer.js":
/*!****************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/opentracing/lib/global_tracer.js ***!
  \****************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var tracer_1 = __webpack_require__(/*! ./tracer */ "../../node_modules/opentracing/lib/tracer.js");
var noopTracer = new tracer_1.default();
var _globalTracer = null;
// Allows direct importing/requiring of the global tracer:
//
// let globalTracer = require('opentracing/global');
//      OR
// import globalTracer from 'opentracing/global';
//
// Acts a bridge to the global tracer that can be safely called before the
// global tracer is initialized. The purpose of the delegation is to avoid the
// sometimes nearly intractible initialization order problems that can arise in
// applications with a complex set of dependencies, while also avoiding the
// case where
var GlobalTracerDelegate = /** @class */ (function (_super) {
    __extends(GlobalTracerDelegate, _super);
    function GlobalTracerDelegate() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    GlobalTracerDelegate.prototype.startSpan = function () {
        var tracer = _globalTracer || noopTracer;
        return tracer.startSpan.apply(tracer, arguments);
    };
    GlobalTracerDelegate.prototype.inject = function () {
        var tracer = _globalTracer || noopTracer;
        return tracer.inject.apply(tracer, arguments);
    };
    GlobalTracerDelegate.prototype.extract = function () {
        var tracer = _globalTracer || noopTracer;
        return tracer.extract.apply(tracer, arguments);
    };
    return GlobalTracerDelegate;
}(tracer_1.default));
var globalTracerDelegate = new GlobalTracerDelegate();
/**
 * Set the global Tracer.
 *
 * The behavior is undefined if this function is called more than once.
 *
 * @param {Tracer} tracer - the Tracer implementation
 */
function initGlobalTracer(tracer) {
    _globalTracer = tracer;
}
exports.initGlobalTracer = initGlobalTracer;
/**
 * Returns the global tracer.
 */
function globalTracer() {
    // Return the delegate.  Since the global tracer is largely a convenience
    // (the user can always create their own tracers), the delegate is used to
    // give the added convenience of not needing to worry about initialization
    // order.
    return globalTracerDelegate;
}
exports.globalTracer = globalTracer;
//# sourceMappingURL=global_tracer.js.map

/***/ }),

/***/ "../../node_modules/opentracing/lib/index.js":
/*!********************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/opentracing/lib/index.js ***!
  \********************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
var binary_carrier_1 = __webpack_require__(/*! ./binary_carrier */ "../../node_modules/opentracing/lib/binary_carrier.js");
exports.BinaryCarrier = binary_carrier_1.default;
var Tags = __webpack_require__(/*! ./ext/tags */ "../../node_modules/opentracing/lib/ext/tags.js");
exports.Tags = Tags;
var Noop = __webpack_require__(/*! ./noop */ "../../node_modules/opentracing/lib/noop.js");
var reference_1 = __webpack_require__(/*! ./reference */ "../../node_modules/opentracing/lib/reference.js");
exports.Reference = reference_1.default;
var span_1 = __webpack_require__(/*! ./span */ "../../node_modules/opentracing/lib/span.js");
exports.Span = span_1.default;
var span_context_1 = __webpack_require__(/*! ./span_context */ "../../node_modules/opentracing/lib/span_context.js");
exports.SpanContext = span_context_1.default;
var tracer_1 = __webpack_require__(/*! ./tracer */ "../../node_modules/opentracing/lib/tracer.js");
exports.Tracer = tracer_1.Tracer;
var mock_tracer_1 = __webpack_require__(/*! ./mock_tracer */ "../../node_modules/opentracing/lib/mock_tracer/index.js");
exports.MockTracer = mock_tracer_1.MockTracer;
__export(__webpack_require__(/*! ./global_tracer */ "../../node_modules/opentracing/lib/global_tracer.js"));
__export(__webpack_require__(/*! ./constants */ "../../node_modules/opentracing/lib/constants.js"));
__export(__webpack_require__(/*! ./functions */ "../../node_modules/opentracing/lib/functions.js"));
// Initialize the noops last to avoid a dependecy cycle between the classes.
Noop.initialize();
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../node_modules/opentracing/lib/mock_tracer/index.js":
/*!********************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/opentracing/lib/mock_tracer/index.js ***!
  \********************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var mock_context_1 = __webpack_require__(/*! ./mock_context */ "../../node_modules/opentracing/lib/mock_tracer/mock_context.js");
exports.MockContext = mock_context_1.default;
var mock_span_1 = __webpack_require__(/*! ./mock_span */ "../../node_modules/opentracing/lib/mock_tracer/mock_span.js");
exports.MockSpan = mock_span_1.default;
var mock_tracer_1 = __webpack_require__(/*! ./mock_tracer */ "../../node_modules/opentracing/lib/mock_tracer/mock_tracer.js");
exports.MockTracer = mock_tracer_1.default;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../node_modules/opentracing/lib/mock_tracer/mock_context.js":
/*!***************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/opentracing/lib/mock_tracer/mock_context.js ***!
  \***************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var span_context_1 = __webpack_require__(/*! ../span_context */ "../../node_modules/opentracing/lib/span_context.js");
/**
 * OpenTracing Context implementation designed for use in
 * unit tests.
 */
var MockContext = /** @class */ (function (_super) {
    __extends(MockContext, _super);
    function MockContext(span) {
        var _this = _super.call(this) || this;
        // Store a reference to the span itself since this is a mock tracer
        // intended to make debugging and unit testing easier.
        _this._span = span;
        return _this;
    }
    MockContext.prototype.span = function () {
        return this._span;
    };
    return MockContext;
}(span_context_1.SpanContext));
exports.MockContext = MockContext;
exports.default = MockContext;
//# sourceMappingURL=mock_context.js.map

/***/ }),

/***/ "../../node_modules/opentracing/lib/mock_tracer/mock_report.js":
/*!**************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/opentracing/lib/mock_tracer/mock_report.js ***!
  \**************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Index a collection of reported MockSpans in a way that's easy to run unit
 * test assertions against.
 */
var MockReport = /** @class */ (function () {
    function MockReport(spans) {
        var _this = this;
        this.spans = spans;
        this.spansByUUID = {};
        this.spansByTag = {};
        this.debugSpans = [];
        this.unfinishedSpans = [];
        spans.forEach(function (span) {
            if (span._finishMs === 0) {
                _this.unfinishedSpans.push(span);
            }
            _this.spansByUUID[span.uuid()] = span;
            _this.debugSpans.push(span.debug());
            var tags = span.tags();
            Object.keys(tags).forEach(function (key) {
                var val = tags[key];
                _this.spansByTag[key] = _this.spansByTag[key] || {};
                _this.spansByTag[key][val] = _this.spansByTag[key][val] || [];
                _this.spansByTag[key][val].push(span);
            });
        });
    }
    MockReport.prototype.firstSpanWithTagValue = function (key, val) {
        var m = this.spansByTag[key];
        if (!m) {
            return null;
        }
        var n = m[val];
        if (!n) {
            return null;
        }
        return n[0];
    };
    return MockReport;
}());
exports.MockReport = MockReport;
exports.default = MockReport;
//# sourceMappingURL=mock_report.js.map

/***/ }),

/***/ "../../node_modules/opentracing/lib/mock_tracer/mock_span.js":
/*!************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/opentracing/lib/mock_tracer/mock_span.js ***!
  \************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/* eslint-disable import/no-extraneous-dependencies */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var opentracing = __webpack_require__(/*! ../index */ "../../node_modules/opentracing/lib/index.js");
var mock_context_1 = __webpack_require__(/*! ./mock_context */ "../../node_modules/opentracing/lib/mock_tracer/mock_context.js");
/**
 * OpenTracing Span implementation designed for use in unit tests.
 */
var MockSpan = /** @class */ (function (_super) {
    __extends(MockSpan, _super);
    //------------------------------------------------------------------------//
    // MockSpan-specific
    //------------------------------------------------------------------------//
    function MockSpan(tracer) {
        var _this = _super.call(this) || this;
        _this._mockTracer = tracer;
        _this._uuid = _this._generateUUID();
        _this._startMs = Date.now();
        _this._finishMs = 0;
        _this._operationName = '';
        _this._tags = {};
        _this._logs = [];
        return _this;
    }
    //------------------------------------------------------------------------//
    // OpenTracing implementation
    //------------------------------------------------------------------------//
    MockSpan.prototype._context = function () {
        return new mock_context_1.default(this);
    };
    MockSpan.prototype._setOperationName = function (name) {
        this._operationName = name;
    };
    MockSpan.prototype._addTags = function (set) {
        var keys = Object.keys(set);
        for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
            var key = keys_1[_i];
            this._tags[key] = set[key];
        }
    };
    MockSpan.prototype._log = function (fields, timestamp) {
        this._logs.push({
            fields: fields,
            timestamp: timestamp
        });
    };
    MockSpan.prototype._finish = function (finishTime) {
        this._finishMs = finishTime || Date.now();
    };
    MockSpan.prototype.uuid = function () {
        return this._uuid;
    };
    MockSpan.prototype.operationName = function () {
        return this._operationName;
    };
    MockSpan.prototype.durationMs = function () {
        return this._finishMs - this._startMs;
    };
    MockSpan.prototype.tags = function () {
        return this._tags;
    };
    MockSpan.prototype.tracer = function () {
        return this._mockTracer;
    };
    MockSpan.prototype._generateUUID = function () {
        var p0 = ("00000000" + Math.abs((Math.random() * 0xFFFFFFFF) | 0).toString(16)).substr(-8);
        var p1 = ("00000000" + Math.abs((Math.random() * 0xFFFFFFFF) | 0).toString(16)).substr(-8);
        return "" + p0 + p1;
    };
    MockSpan.prototype.addReference = function (ref) {
    };
    /**
     * Returns a simplified object better for console.log()'ing.
     */
    MockSpan.prototype.debug = function () {
        var obj = {
            uuid: this._uuid,
            operation: this._operationName,
            millis: [this._finishMs - this._startMs, this._startMs, this._finishMs]
        };
        if (Object.keys(this._tags).length) {
            obj.tags = this._tags;
        }
        return obj;
    };
    return MockSpan;
}(opentracing.Span));
exports.MockSpan = MockSpan;
exports.default = MockSpan;
//# sourceMappingURL=mock_span.js.map

/***/ }),

/***/ "../../node_modules/opentracing/lib/mock_tracer/mock_tracer.js":
/*!**************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/opentracing/lib/mock_tracer/mock_tracer.js ***!
  \**************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
// TODO: Move mock-tracer to its own NPM package once it is complete and tested.
var opentracing = __webpack_require__(/*! ../index */ "../../node_modules/opentracing/lib/index.js");
var mock_report_1 = __webpack_require__(/*! ./mock_report */ "../../node_modules/opentracing/lib/mock_tracer/mock_report.js");
var mock_span_1 = __webpack_require__(/*! ./mock_span */ "../../node_modules/opentracing/lib/mock_tracer/mock_span.js");
/**
 * OpenTracing Tracer implementation designed for use in unit tests.
 */
var MockTracer = /** @class */ (function (_super) {
    __extends(MockTracer, _super);
    //------------------------------------------------------------------------//
    // MockTracer-specific
    //------------------------------------------------------------------------//
    function MockTracer() {
        var _this = _super.call(this) || this;
        _this._spans = [];
        return _this;
    }
    //------------------------------------------------------------------------//
    // OpenTracing implementation
    //------------------------------------------------------------------------//
    MockTracer.prototype._startSpan = function (name, fields) {
        // _allocSpan is given it's own method so that derived classes can
        // allocate any type of object they want, but not have to duplicate
        // the other common logic in startSpan().
        var span = this._allocSpan();
        span.setOperationName(name);
        this._spans.push(span);
        if (fields.references) {
            for (var _i = 0, _a = fields.references; _i < _a.length; _i++) {
                var ref = _a[_i];
                span.addReference(ref);
            }
        }
        // Capture the stack at the time the span started
        span._startStack = new Error().stack;
        return span;
    };
    MockTracer.prototype._inject = function (span, format, carrier) {
        throw new Error('NOT YET IMPLEMENTED');
    };
    MockTracer.prototype._extract = function (format, carrier) {
        throw new Error('NOT YET IMPLEMENTED');
    };
    MockTracer.prototype._allocSpan = function () {
        return new mock_span_1.default(this);
    };
    /**
     * Discard any buffered data.
     */
    MockTracer.prototype.clear = function () {
        this._spans = [];
    };
    /**
     * Return the buffered data in a format convenient for making unit test
     * assertions.
     */
    MockTracer.prototype.report = function () {
        return new mock_report_1.default(this._spans);
    };
    return MockTracer;
}(opentracing.Tracer));
exports.MockTracer = MockTracer;
exports.default = MockTracer;
//# sourceMappingURL=mock_tracer.js.map

/***/ }),

/***/ "../../node_modules/opentracing/lib/noop.js":
/*!*******************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/opentracing/lib/noop.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var span_1 = __webpack_require__(/*! ./span */ "../../node_modules/opentracing/lib/span.js");
var span_context_1 = __webpack_require__(/*! ./span_context */ "../../node_modules/opentracing/lib/span_context.js");
var tracer_1 = __webpack_require__(/*! ./tracer */ "../../node_modules/opentracing/lib/tracer.js");
exports.tracer = null;
exports.spanContext = null;
exports.span = null;
// Deferred initialization to avoid a dependency cycle where Tracer depends on
// Span which depends on the noop tracer.
function initialize() {
    exports.tracer = new tracer_1.default();
    exports.span = new span_1.default();
    exports.spanContext = new span_context_1.default();
}
exports.initialize = initialize;
//# sourceMappingURL=noop.js.map

/***/ }),

/***/ "../../node_modules/opentracing/lib/reference.js":
/*!************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/opentracing/lib/reference.js ***!
  \************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var span_1 = __webpack_require__(/*! ./span */ "../../node_modules/opentracing/lib/span.js");
/**
 * Reference pairs a reference type constant (e.g., REFERENCE_CHILD_OF or
 * REFERENCE_FOLLOWS_FROM) with the SpanContext it points to.
 *
 * See the exported childOf() and followsFrom() functions at the package level.
 */
var Reference = /** @class */ (function () {
    /**
     * Initialize a new Reference instance.
     *
     * @param {string} type - the Reference type constant (e.g.,
     *        REFERENCE_CHILD_OF or REFERENCE_FOLLOWS_FROM).
     * @param {SpanContext} referencedContext - the SpanContext being referred
     *        to. As a convenience, a Span instance may be passed in instead
     *        (in which case its .context() is used here).
     */
    function Reference(type, referencedContext) {
        this._type = type;
        this._referencedContext = (referencedContext instanceof span_1.default ?
            referencedContext.context() :
            referencedContext);
    }
    /**
     * @return {string} The Reference type (e.g., REFERENCE_CHILD_OF or
     *         REFERENCE_FOLLOWS_FROM).
     */
    Reference.prototype.type = function () {
        return this._type;
    };
    /**
     * @return {SpanContext} The SpanContext being referred to (e.g., the
     *         parent in a REFERENCE_CHILD_OF Reference).
     */
    Reference.prototype.referencedContext = function () {
        return this._referencedContext;
    };
    return Reference;
}());
exports.default = Reference;
//# sourceMappingURL=reference.js.map

/***/ }),

/***/ "../../node_modules/opentracing/lib/span.js":
/*!*******************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/opentracing/lib/span.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var noop = __webpack_require__(/*! ./noop */ "../../node_modules/opentracing/lib/noop.js");
/**
 * Span represents a logical unit of work as part of a broader Trace. Examples
 * of span might include remote procedure calls or a in-process function calls
 * to sub-components. A Trace has a single, top-level "root" Span that in turn
 * may have zero or more child Spans, which in turn may have children.
 */
var Span = /** @class */ (function () {
    function Span() {
    }
    // ---------------------------------------------------------------------- //
    // OpenTracing API methods
    // ---------------------------------------------------------------------- //
    /**
     * Returns the SpanContext object associated with this Span.
     *
     * @return {SpanContext}
     */
    Span.prototype.context = function () {
        return this._context();
    };
    /**
     * Returns the Tracer object used to create this Span.
     *
     * @return {Tracer}
     */
    Span.prototype.tracer = function () {
        return this._tracer();
    };
    /**
     * Sets the string name for the logical operation this span represents.
     *
     * @param {string} name
     */
    Span.prototype.setOperationName = function (name) {
        this._setOperationName(name);
        return this;
    };
    /**
     * Sets a key:value pair on this Span that also propagates to future
     * children of the associated Span.
     *
     * setBaggageItem() enables powerful functionality given a full-stack
     * opentracing integration (e.g., arbitrary application data from a web
     * client can make it, transparently, all the way into the depths of a
     * storage system), and with it some powerful costs: use this feature with
     * care.
     *
     * IMPORTANT NOTE #1: setBaggageItem() will only propagate baggage items to
     * *future* causal descendants of the associated Span.
     *
     * IMPORTANT NOTE #2: Use this thoughtfully and with care. Every key and
     * value is copied into every local *and remote* child of the associated
     * Span, and that can add up to a lot of network and cpu overhead.
     *
     * @param {string} key
     * @param {string} value
     */
    Span.prototype.setBaggageItem = function (key, value) {
        this._setBaggageItem(key, value);
        return this;
    };
    /**
     * Returns the value for a baggage item given its key.
     *
     * @param  {string} key
     *         The key for the given trace attribute.
     * @return {string}
     *         String value for the given key, or undefined if the key does not
     *         correspond to a set trace attribute.
     */
    Span.prototype.getBaggageItem = function (key) {
        return this._getBaggageItem(key);
    };
    /**
     * Adds a single tag to the span.  See `addTags()` for details.
     *
     * @param {string} key
     * @param {any} value
     */
    Span.prototype.setTag = function (key, value) {
        var _a;
        // NOTE: the call is normalized to a call to _addTags()
        this._addTags((_a = {}, _a[key] = value, _a));
        return this;
    };
    /**
     * Adds the given key value pairs to the set of span tags.
     *
     * Multiple calls to addTags() results in the tags being the superset of
     * all calls.
     *
     * The behavior of setting the same key multiple times on the same span
     * is undefined.
     *
     * The supported type of the values is implementation-dependent.
     * Implementations are expected to safely handle all types of values but
     * may choose to ignore unrecognized / unhandle-able values (e.g. objects
     * with cyclic references, function objects).
     *
     * @return {[type]} [description]
     */
    Span.prototype.addTags = function (keyValueMap) {
        this._addTags(keyValueMap);
        return this;
    };
    /**
     * Add a log record to this Span, optionally at a user-provided timestamp.
     *
     * For example:
     *
     *     span.log({
     *         size: rpc.size(),  // numeric value
     *         URI: rpc.URI(),  // string value
     *         payload: rpc.payload(),  // Object value
     *         "keys can be arbitrary strings": rpc.foo(),
     *     });
     *
     *     span.log({
     *         "error.description": someError.description(),
     *     }, someError.timestampMillis());
     *
     * @param {object} keyValuePairs
     *        An object mapping string keys to arbitrary value types. All
     *        Tracer implementations should support bool, string, and numeric
     *        value types, and some may also support Object values.
     * @param {number} timestamp
     *        An optional parameter specifying the timestamp in milliseconds
     *        since the Unix epoch. Fractional values are allowed so that
     *        timestamps with sub-millisecond accuracy can be represented. If
     *        not specified, the implementation is expected to use its notion
     *        of the current time of the call.
     */
    Span.prototype.log = function (keyValuePairs, timestamp) {
        this._log(keyValuePairs, timestamp);
        return this;
    };
    /**
     * DEPRECATED
     */
    Span.prototype.logEvent = function (eventName, payload) {
        return this._log({ event: eventName, payload: payload });
    };
    /**
     * Sets the end timestamp and finalizes Span state.
     *
     * With the exception of calls to Span.context() (which are always allowed),
     * finish() must be the last call made to any span instance, and to do
     * otherwise leads to undefined behavior.
     *
     * @param  {number} finishTime
     *         Optional finish time in milliseconds as a Unix timestamp. Decimal
     *         values are supported for timestamps with sub-millisecond accuracy.
     *         If not specified, the current time (as defined by the
     *         implementation) will be used.
     */
    Span.prototype.finish = function (finishTime) {
        this._finish(finishTime);
        // Do not return `this`. The Span generally should not be used after it
        // is finished so chaining is not desired in this context.
    };
    // ---------------------------------------------------------------------- //
    // Derived classes can choose to implement the below
    // ---------------------------------------------------------------------- //
    // By default returns a no-op SpanContext.
    Span.prototype._context = function () {
        return noop.spanContext;
    };
    // By default returns a no-op tracer.
    //
    // The base class could store the tracer that created it, but it does not
    // in order to ensure the no-op span implementation has zero members,
    // which allows V8 to aggressively optimize calls to such objects.
    Span.prototype._tracer = function () {
        return noop.tracer;
    };
    // By default does nothing
    Span.prototype._setOperationName = function (name) {
    };
    // By default does nothing
    Span.prototype._setBaggageItem = function (key, value) {
    };
    // By default does nothing
    Span.prototype._getBaggageItem = function (key) {
        return undefined;
    };
    // By default does nothing
    //
    // NOTE: both setTag() and addTags() map to this function. keyValuePairs
    // will always be an associative array.
    Span.prototype._addTags = function (keyValuePairs) {
    };
    // By default does nothing
    Span.prototype._log = function (keyValuePairs, timestamp) {
    };
    // By default does nothing
    //
    // finishTime is expected to be either a number or undefined.
    Span.prototype._finish = function (finishTime) {
    };
    return Span;
}());
exports.Span = Span;
exports.default = Span;
//# sourceMappingURL=span.js.map

/***/ }),

/***/ "../../node_modules/opentracing/lib/span_context.js":
/*!***************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/opentracing/lib/span_context.js ***!
  \***************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * SpanContext represents Span state that must propagate to descendant Spans
 * and across process boundaries.
 *
 * SpanContext is logically divided into two pieces: the user-level "Baggage"
 * (see setBaggageItem and getBaggageItem) that propagates across Span
 * boundaries and any Tracer-implementation-specific fields that are needed to
 * identify or otherwise contextualize the associated Span instance (e.g., a
 * <trace_id, span_id, sampled> tuple).
 */
var SpanContext = /** @class */ (function () {
    function SpanContext() {
    }
    // The SpanContext is entirely implementation dependent
    /**
     * Returns a string representation of the implementation internal trace ID.
     *
     * @returns {string}
     */
    SpanContext.prototype.toTraceId = function () {
        return '';
    };
    /**
     * Returns a string representation of the implementation internal span ID.
     *
     * @returns {string}
     */
    SpanContext.prototype.toSpanId = function () {
        return '';
    };
    return SpanContext;
}());
exports.SpanContext = SpanContext;
exports.default = SpanContext;
//# sourceMappingURL=span_context.js.map

/***/ }),

/***/ "../../node_modules/opentracing/lib/tracer.js":
/*!*********************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/opentracing/lib/tracer.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var Functions = __webpack_require__(/*! ./functions */ "../../node_modules/opentracing/lib/functions.js");
var Noop = __webpack_require__(/*! ./noop */ "../../node_modules/opentracing/lib/noop.js");
var span_1 = __webpack_require__(/*! ./span */ "../../node_modules/opentracing/lib/span.js");
/**
 * Tracer is the entry-point between the instrumentation API and the tracing
 * implementation.
 *
 * The default object acts as a no-op implementation.
 *
 * Note to implementators: derived classes can choose to directly implement the
 * methods in the "OpenTracing API methods" section, or optionally the subset of
 * underscore-prefixed methods to pick up the argument checking and handling
 * automatically from the base class.
 */
var Tracer = /** @class */ (function () {
    function Tracer() {
    }
    // ---------------------------------------------------------------------- //
    // OpenTracing API methods
    // ---------------------------------------------------------------------- //
    /**
     * Starts and returns a new Span representing a logical unit of work.
     *
     * For example:
     *
     *     // Start a new (parentless) root Span:
     *     var parent = Tracer.startSpan('DoWork');
     *
     *     // Start a new (child) Span:
     *     var child = Tracer.startSpan('load-from-db', {
     *         childOf: parent.context(),
     *     });
     *
     *     // Start a new async (FollowsFrom) Span:
     *     var child = Tracer.startSpan('async-cache-write', {
     *         references: [
     *             opentracing.followsFrom(parent.context())
     *         ],
     *     });
     *
     * @param {string} name - the name of the operation (REQUIRED).
     * @param {SpanOptions} [options] - options for the newly created span.
     * @return {Span} - a new Span object.
     */
    Tracer.prototype.startSpan = function (name, options) {
        if (options === void 0) { options = {}; }
        // Convert options.childOf to fields.references as needed.
        if (options.childOf) {
            // Convert from a Span or a SpanContext into a Reference.
            var childOf = Functions.childOf(options.childOf);
            if (options.references) {
                options.references.push(childOf);
            }
            else {
                options.references = [childOf];
            }
            delete (options.childOf);
        }
        return this._startSpan(name, options);
    };
    /**
     * Injects the given SpanContext instance for cross-process propagation
     * within `carrier`. The expected type of `carrier` depends on the value of
     * `format.
     *
     * OpenTracing defines a common set of `format` values (see
     * FORMAT_TEXT_MAP, FORMAT_HTTP_HEADERS, and FORMAT_BINARY), and each has
     * an expected carrier type.
     *
     * Consider this pseudocode example:
     *
     *     var clientSpan = ...;
     *     ...
     *     // Inject clientSpan into a text carrier.
     *     var headersCarrier = {};
     *     Tracer.inject(clientSpan.context(), Tracer.FORMAT_HTTP_HEADERS, headersCarrier);
     *     // Incorporate the textCarrier into the outbound HTTP request header
     *     // map.
     *     Object.assign(outboundHTTPReq.headers, headersCarrier);
     *     // ... send the httpReq
     *
     * @param  {SpanContext} spanContext - the SpanContext to inject into the
     *         carrier object. As a convenience, a Span instance may be passed
     *         in instead (in which case its .context() is used for the
     *         inject()).
     * @param  {string} format - the format of the carrier.
     * @param  {any} carrier - see the documentation for the chosen `format`
     *         for a description of the carrier object.
     */
    Tracer.prototype.inject = function (spanContext, format, carrier) {
        // Allow the user to pass a Span instead of a SpanContext
        if (spanContext instanceof span_1.default) {
            spanContext = spanContext.context();
        }
        return this._inject(spanContext, format, carrier);
    };
    /**
     * Returns a SpanContext instance extracted from `carrier` in the given
     * `format`.
     *
     * OpenTracing defines a common set of `format` values (see
     * FORMAT_TEXT_MAP, FORMAT_HTTP_HEADERS, and FORMAT_BINARY), and each has
     * an expected carrier type.
     *
     * Consider this pseudocode example:
     *
     *     // Use the inbound HTTP request's headers as a text map carrier.
     *     var headersCarrier = inboundHTTPReq.headers;
     *     var wireCtx = Tracer.extract(Tracer.FORMAT_HTTP_HEADERS, headersCarrier);
     *     var serverSpan = Tracer.startSpan('...', { childOf : wireCtx });
     *
     * @param  {string} format - the format of the carrier.
     * @param  {any} carrier - the type of the carrier object is determined by
     *         the format.
     * @return {SpanContext}
     *         The extracted SpanContext, or null if no such SpanContext could
     *         be found in `carrier`
     */
    Tracer.prototype.extract = function (format, carrier) {
        return this._extract(format, carrier);
    };
    // ---------------------------------------------------------------------- //
    // Derived classes can choose to implement the below
    // ---------------------------------------------------------------------- //
    // NOTE: the input to this method is *always* an associative array. The
    // public-facing startSpan() method normalizes the arguments so that
    // all N implementations do not need to worry about variations in the call
    // signature.
    //
    // The default behavior returns a no-op span.
    Tracer.prototype._startSpan = function (name, fields) {
        return Noop.span;
    };
    // The default behavior is a no-op.
    Tracer.prototype._inject = function (spanContext, format, carrier) {
    };
    // The default behavior is to return a no-op SpanContext.
    Tracer.prototype._extract = function (format, carrier) {
        return Noop.spanContext;
    };
    return Tracer;
}());
exports.Tracer = Tracer;
exports.default = Tracer;
//# sourceMappingURL=tracer.js.map

/***/ }),

/***/ "../../node_modules/p-limit/index.js":
/*!************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/p-limit/index.js ***!
  \************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

const Queue = __webpack_require__(/*! yocto-queue */ "../../node_modules/yocto-queue/index.js");

const pLimit = concurrency => {
	if (!((Number.isInteger(concurrency) || concurrency === Infinity) && concurrency > 0)) {
		throw new TypeError('Expected `concurrency` to be a number from 1 and up');
	}

	const queue = new Queue();
	let activeCount = 0;

	const next = () => {
		activeCount--;

		if (queue.size > 0) {
			queue.dequeue()();
		}
	};

	const run = async (fn, resolve, ...args) => {
		activeCount++;

		const result = (async () => fn(...args))();

		resolve(result);

		try {
			await result;
		} catch {}

		next();
	};

	const enqueue = (fn, resolve, ...args) => {
		queue.enqueue(run.bind(null, fn, resolve, ...args));

		(async () => {
			// This function needs to wait until the next microtask before comparing
			// `activeCount` to `concurrency`, because `activeCount` is updated asynchronously
			// when the run function is dequeued and called. The comparison in the if-statement
			// needs to happen asynchronously as well to get an up-to-date value for `activeCount`.
			await Promise.resolve();

			if (activeCount < concurrency && queue.size > 0) {
				queue.dequeue()();
			}
		})();
	};

	const generator = (fn, ...args) => new Promise(resolve => {
		enqueue(fn, resolve, ...args);
	});

	Object.defineProperties(generator, {
		activeCount: {
			get: () => activeCount
		},
		pendingCount: {
			get: () => queue.size
		},
		clearQueue: {
			value: () => {
				queue.clear();
			}
		}
	});

	return generator;
};

module.exports = pLimit;


/***/ }),

/***/ "../../node_modules/performance-now/lib/performance-now.js":
/*!**********************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/performance-now/lib/performance-now.js ***!
  \**********************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports) {

// Generated by CoffeeScript 1.12.2
(function() {
  var getNanoSeconds, hrtime, loadTime, moduleLoadTime, nodeLoadTime, upTime;

  if ((typeof performance !== "undefined" && performance !== null) && performance.now) {
    module.exports = function() {
      return performance.now();
    };
  } else if ((typeof process !== "undefined" && process !== null) && process.hrtime) {
    module.exports = function() {
      return (getNanoSeconds() - nodeLoadTime) / 1e6;
    };
    hrtime = process.hrtime;
    getNanoSeconds = function() {
      var hr;
      hr = hrtime();
      return hr[0] * 1e9 + hr[1];
    };
    moduleLoadTime = getNanoSeconds();
    upTime = process.uptime() * 1e9;
    nodeLoadTime = moduleLoadTime - upTime;
  } else if (Date.now) {
    module.exports = function() {
      return Date.now() - loadTime;
    };
    loadTime = Date.now();
  } else {
    module.exports = function() {
      return new Date().getTime() - loadTime;
    };
    loadTime = new Date().getTime();
  }

}).call(this);

//# sourceMappingURL=performance-now.js.map


/***/ }),

/***/ "../../node_modules/protobufjs/minimal.js":
/*!*****************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/protobufjs/minimal.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// minimal library entry point.


module.exports = __webpack_require__(/*! ./src/index-minimal */ "../../node_modules/protobufjs/src/index-minimal.js");


/***/ }),

/***/ "../../node_modules/protobufjs/src/index-minimal.js":
/*!***************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/protobufjs/src/index-minimal.js ***!
  \***************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var protobuf = exports;

/**
 * Build type, one of `"full"`, `"light"` or `"minimal"`.
 * @name build
 * @type {string}
 * @const
 */
protobuf.build = "minimal";

// Serialization
protobuf.Writer       = __webpack_require__(/*! ./writer */ "../../node_modules/protobufjs/src/writer.js");
protobuf.BufferWriter = __webpack_require__(/*! ./writer_buffer */ "../../node_modules/protobufjs/src/writer_buffer.js");
protobuf.Reader       = __webpack_require__(/*! ./reader */ "../../node_modules/protobufjs/src/reader.js");
protobuf.BufferReader = __webpack_require__(/*! ./reader_buffer */ "../../node_modules/protobufjs/src/reader_buffer.js");

// Utility
protobuf.util         = __webpack_require__(/*! ./util/minimal */ "../../node_modules/protobufjs/src/util/minimal.js");
protobuf.rpc          = __webpack_require__(/*! ./rpc */ "../../node_modules/protobufjs/src/rpc.js");
protobuf.roots        = __webpack_require__(/*! ./roots */ "../../node_modules/protobufjs/src/roots.js");
protobuf.configure    = configure;

/* istanbul ignore next */
/**
 * Reconfigures the library according to the environment.
 * @returns {undefined}
 */
function configure() {
    protobuf.util._configure();
    protobuf.Writer._configure(protobuf.BufferWriter);
    protobuf.Reader._configure(protobuf.BufferReader);
}

// Set up buffer utility according to the environment
configure();


/***/ }),

/***/ "../../node_modules/protobufjs/src/reader.js":
/*!********************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/protobufjs/src/reader.js ***!
  \********************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = Reader;

var util      = __webpack_require__(/*! ./util/minimal */ "../../node_modules/protobufjs/src/util/minimal.js");

var BufferReader; // cyclic

var LongBits  = util.LongBits,
    utf8      = util.utf8;

/* istanbul ignore next */
function indexOutOfRange(reader, writeLength) {
    return RangeError("index out of range: " + reader.pos + " + " + (writeLength || 1) + " > " + reader.len);
}

/**
 * Constructs a new reader instance using the specified buffer.
 * @classdesc Wire format reader using `Uint8Array` if available, otherwise `Array`.
 * @constructor
 * @param {Uint8Array} buffer Buffer to read from
 */
function Reader(buffer) {

    /**
     * Read buffer.
     * @type {Uint8Array}
     */
    this.buf = buffer;

    /**
     * Read buffer position.
     * @type {number}
     */
    this.pos = 0;

    /**
     * Read buffer length.
     * @type {number}
     */
    this.len = buffer.length;
}

var create_array = typeof Uint8Array !== "undefined"
    ? function create_typed_array(buffer) {
        if (buffer instanceof Uint8Array || Array.isArray(buffer))
            return new Reader(buffer);
        throw Error("illegal buffer");
    }
    /* istanbul ignore next */
    : function create_array(buffer) {
        if (Array.isArray(buffer))
            return new Reader(buffer);
        throw Error("illegal buffer");
    };

var create = function create() {
    return util.Buffer
        ? function create_buffer_setup(buffer) {
            return (Reader.create = function create_buffer(buffer) {
                return util.Buffer.isBuffer(buffer)
                    ? new BufferReader(buffer)
                    /* istanbul ignore next */
                    : create_array(buffer);
            })(buffer);
        }
        /* istanbul ignore next */
        : create_array;
};

/**
 * Creates a new reader using the specified buffer.
 * @function
 * @param {Uint8Array|Buffer} buffer Buffer to read from
 * @returns {Reader|BufferReader} A {@link BufferReader} if `buffer` is a Buffer, otherwise a {@link Reader}
 * @throws {Error} If `buffer` is not a valid buffer
 */
Reader.create = create();

Reader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */ util.Array.prototype.slice;

/**
 * Reads a varint as an unsigned 32 bit value.
 * @function
 * @returns {number} Value read
 */
Reader.prototype.uint32 = (function read_uint32_setup() {
    var value = 4294967295; // optimizer type-hint, tends to deopt otherwise (?!)
    return function read_uint32() {
        value = (         this.buf[this.pos] & 127       ) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) <<  7) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] &  15) << 28) >>> 0; if (this.buf[this.pos++] < 128) return value;

        /* istanbul ignore if */
        if ((this.pos += 5) > this.len) {
            this.pos = this.len;
            throw indexOutOfRange(this, 10);
        }
        return value;
    };
})();

/**
 * Reads a varint as a signed 32 bit value.
 * @returns {number} Value read
 */
Reader.prototype.int32 = function read_int32() {
    return this.uint32() | 0;
};

/**
 * Reads a zig-zag encoded varint as a signed 32 bit value.
 * @returns {number} Value read
 */
Reader.prototype.sint32 = function read_sint32() {
    var value = this.uint32();
    return value >>> 1 ^ -(value & 1) | 0;
};

/* eslint-disable no-invalid-this */

function readLongVarint() {
    // tends to deopt with local vars for octet etc.
    var bits = new LongBits(0, 0);
    var i = 0;
    if (this.len - this.pos > 4) { // fast route (lo)
        for (; i < 4; ++i) {
            // 1st..4th
            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
        // 5th
        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >>  4) >>> 0;
        if (this.buf[this.pos++] < 128)
            return bits;
        i = 0;
    } else {
        for (; i < 3; ++i) {
            /* istanbul ignore if */
            if (this.pos >= this.len)
                throw indexOutOfRange(this);
            // 1st..3th
            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
        // 4th
        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;
        return bits;
    }
    if (this.len - this.pos > 4) { // fast route (hi)
        for (; i < 5; ++i) {
            // 6th..10th
            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
    } else {
        for (; i < 5; ++i) {
            /* istanbul ignore if */
            if (this.pos >= this.len)
                throw indexOutOfRange(this);
            // 6th..10th
            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
    }
    /* istanbul ignore next */
    throw Error("invalid varint encoding");
}

/* eslint-enable no-invalid-this */

/**
 * Reads a varint as a signed 64 bit value.
 * @name Reader#int64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a varint as an unsigned 64 bit value.
 * @name Reader#uint64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a zig-zag encoded varint as a signed 64 bit value.
 * @name Reader#sint64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a varint as a boolean.
 * @returns {boolean} Value read
 */
Reader.prototype.bool = function read_bool() {
    return this.uint32() !== 0;
};

function readFixed32_end(buf, end) { // note that this uses `end`, not `pos`
    return (buf[end - 4]
          | buf[end - 3] << 8
          | buf[end - 2] << 16
          | buf[end - 1] << 24) >>> 0;
}

/**
 * Reads fixed 32 bits as an unsigned 32 bit integer.
 * @returns {number} Value read
 */
Reader.prototype.fixed32 = function read_fixed32() {

    /* istanbul ignore if */
    if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);

    return readFixed32_end(this.buf, this.pos += 4);
};

/**
 * Reads fixed 32 bits as a signed 32 bit integer.
 * @returns {number} Value read
 */
Reader.prototype.sfixed32 = function read_sfixed32() {

    /* istanbul ignore if */
    if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);

    return readFixed32_end(this.buf, this.pos += 4) | 0;
};

/* eslint-disable no-invalid-this */

function readFixed64(/* this: Reader */) {

    /* istanbul ignore if */
    if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 8);

    return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
}

/* eslint-enable no-invalid-this */

/**
 * Reads fixed 64 bits.
 * @name Reader#fixed64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads zig-zag encoded fixed 64 bits.
 * @name Reader#sfixed64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a float (32 bit) as a number.
 * @function
 * @returns {number} Value read
 */
Reader.prototype.float = function read_float() {

    /* istanbul ignore if */
    if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);

    var value = util.float.readFloatLE(this.buf, this.pos);
    this.pos += 4;
    return value;
};

/**
 * Reads a double (64 bit float) as a number.
 * @function
 * @returns {number} Value read
 */
Reader.prototype.double = function read_double() {

    /* istanbul ignore if */
    if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 4);

    var value = util.float.readDoubleLE(this.buf, this.pos);
    this.pos += 8;
    return value;
};

/**
 * Reads a sequence of bytes preceeded by its length as a varint.
 * @returns {Uint8Array} Value read
 */
Reader.prototype.bytes = function read_bytes() {
    var length = this.uint32(),
        start  = this.pos,
        end    = this.pos + length;

    /* istanbul ignore if */
    if (end > this.len)
        throw indexOutOfRange(this, length);

    this.pos += length;
    if (Array.isArray(this.buf)) // plain array
        return this.buf.slice(start, end);
    return start === end // fix for IE 10/Win8 and others' subarray returning array of size 1
        ? new this.buf.constructor(0)
        : this._slice.call(this.buf, start, end);
};

/**
 * Reads a string preceeded by its byte length as a varint.
 * @returns {string} Value read
 */
Reader.prototype.string = function read_string() {
    var bytes = this.bytes();
    return utf8.read(bytes, 0, bytes.length);
};

/**
 * Skips the specified number of bytes if specified, otherwise skips a varint.
 * @param {number} [length] Length if known, otherwise a varint is assumed
 * @returns {Reader} `this`
 */
Reader.prototype.skip = function skip(length) {
    if (typeof length === "number") {
        /* istanbul ignore if */
        if (this.pos + length > this.len)
            throw indexOutOfRange(this, length);
        this.pos += length;
    } else {
        do {
            /* istanbul ignore if */
            if (this.pos >= this.len)
                throw indexOutOfRange(this);
        } while (this.buf[this.pos++] & 128);
    }
    return this;
};

/**
 * Skips the next element of the specified wire type.
 * @param {number} wireType Wire type received
 * @returns {Reader} `this`
 */
Reader.prototype.skipType = function(wireType) {
    switch (wireType) {
        case 0:
            this.skip();
            break;
        case 1:
            this.skip(8);
            break;
        case 2:
            this.skip(this.uint32());
            break;
        case 3:
            while ((wireType = this.uint32() & 7) !== 4) {
                this.skipType(wireType);
            }
            break;
        case 5:
            this.skip(4);
            break;

        /* istanbul ignore next */
        default:
            throw Error("invalid wire type " + wireType + " at offset " + this.pos);
    }
    return this;
};

Reader._configure = function(BufferReader_) {
    BufferReader = BufferReader_;
    Reader.create = create();
    BufferReader._configure();

    var fn = util.Long ? "toLong" : /* istanbul ignore next */ "toNumber";
    util.merge(Reader.prototype, {

        int64: function read_int64() {
            return readLongVarint.call(this)[fn](false);
        },

        uint64: function read_uint64() {
            return readLongVarint.call(this)[fn](true);
        },

        sint64: function read_sint64() {
            return readLongVarint.call(this).zzDecode()[fn](false);
        },

        fixed64: function read_fixed64() {
            return readFixed64.call(this)[fn](true);
        },

        sfixed64: function read_sfixed64() {
            return readFixed64.call(this)[fn](false);
        }

    });
};


/***/ }),

/***/ "../../node_modules/protobufjs/src/reader_buffer.js":
/*!***************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/protobufjs/src/reader_buffer.js ***!
  \***************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = BufferReader;

// extends Reader
var Reader = __webpack_require__(/*! ./reader */ "../../node_modules/protobufjs/src/reader.js");
(BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;

var util = __webpack_require__(/*! ./util/minimal */ "../../node_modules/protobufjs/src/util/minimal.js");

/**
 * Constructs a new buffer reader instance.
 * @classdesc Wire format reader using node buffers.
 * @extends Reader
 * @constructor
 * @param {Buffer} buffer Buffer to read from
 */
function BufferReader(buffer) {
    Reader.call(this, buffer);

    /**
     * Read buffer.
     * @name BufferReader#buf
     * @type {Buffer}
     */
}

BufferReader._configure = function () {
    /* istanbul ignore else */
    if (util.Buffer)
        BufferReader.prototype._slice = util.Buffer.prototype.slice;
};


/**
 * @override
 */
BufferReader.prototype.string = function read_string_buffer() {
    var len = this.uint32(); // modifies pos
    return this.buf.utf8Slice
        ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len))
        : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + len, this.len));
};

/**
 * Reads a sequence of bytes preceeded by its length as a varint.
 * @name BufferReader#bytes
 * @function
 * @returns {Buffer} Value read
 */

BufferReader._configure();


/***/ }),

/***/ "../../node_modules/protobufjs/src/roots.js":
/*!*******************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/protobufjs/src/roots.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = {};

/**
 * Named roots.
 * This is where pbjs stores generated structures (the option `-r, --root` specifies a name).
 * Can also be used manually to make roots available accross modules.
 * @name roots
 * @type {Object.<string,Root>}
 * @example
 * // pbjs -r myroot -o compiled.js ...
 *
 * // in another module:
 * require("./compiled.js");
 *
 * // in any subsequent module:
 * var root = protobuf.roots["myroot"];
 */


/***/ }),

/***/ "../../node_modules/protobufjs/src/rpc.js":
/*!*****************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/protobufjs/src/rpc.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Streaming RPC helpers.
 * @namespace
 */
var rpc = exports;

/**
 * RPC implementation passed to {@link Service#create} performing a service request on network level, i.e. by utilizing http requests or websockets.
 * @typedef RPCImpl
 * @type {function}
 * @param {Method|rpc.ServiceMethod<Message<{}>,Message<{}>>} method Reflected or static method being called
 * @param {Uint8Array} requestData Request data
 * @param {RPCImplCallback} callback Callback function
 * @returns {undefined}
 * @example
 * function rpcImpl(method, requestData, callback) {
 *     if (protobuf.util.lcFirst(method.name) !== "myMethod") // compatible with static code
 *         throw Error("no such method");
 *     asynchronouslyObtainAResponse(requestData, function(err, responseData) {
 *         callback(err, responseData);
 *     });
 * }
 */

/**
 * Node-style callback as used by {@link RPCImpl}.
 * @typedef RPCImplCallback
 * @type {function}
 * @param {Error|null} error Error, if any, otherwise `null`
 * @param {Uint8Array|null} [response] Response data or `null` to signal end of stream, if there hasn't been an error
 * @returns {undefined}
 */

rpc.Service = __webpack_require__(/*! ./rpc/service */ "../../node_modules/protobufjs/src/rpc/service.js");


/***/ }),

/***/ "../../node_modules/protobufjs/src/rpc/service.js":
/*!*************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/protobufjs/src/rpc/service.js ***!
  \*************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = Service;

var util = __webpack_require__(/*! ../util/minimal */ "../../node_modules/protobufjs/src/util/minimal.js");

// Extends EventEmitter
(Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;

/**
 * A service method callback as used by {@link rpc.ServiceMethod|ServiceMethod}.
 *
 * Differs from {@link RPCImplCallback} in that it is an actual callback of a service method which may not return `response = null`.
 * @typedef rpc.ServiceMethodCallback
 * @template TRes extends Message<TRes>
 * @type {function}
 * @param {Error|null} error Error, if any
 * @param {TRes} [response] Response message
 * @returns {undefined}
 */

/**
 * A service method part of a {@link rpc.Service} as created by {@link Service.create}.
 * @typedef rpc.ServiceMethod
 * @template TReq extends Message<TReq>
 * @template TRes extends Message<TRes>
 * @type {function}
 * @param {TReq|Properties<TReq>} request Request message or plain object
 * @param {rpc.ServiceMethodCallback<TRes>} [callback] Node-style callback called with the error, if any, and the response message
 * @returns {Promise<Message<TRes>>} Promise if `callback` has been omitted, otherwise `undefined`
 */

/**
 * Constructs a new RPC service instance.
 * @classdesc An RPC service as returned by {@link Service#create}.
 * @exports rpc.Service
 * @extends util.EventEmitter
 * @constructor
 * @param {RPCImpl} rpcImpl RPC implementation
 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
 */
function Service(rpcImpl, requestDelimited, responseDelimited) {

    if (typeof rpcImpl !== "function")
        throw TypeError("rpcImpl must be a function");

    util.EventEmitter.call(this);

    /**
     * RPC implementation. Becomes `null` once the service is ended.
     * @type {RPCImpl|null}
     */
    this.rpcImpl = rpcImpl;

    /**
     * Whether requests are length-delimited.
     * @type {boolean}
     */
    this.requestDelimited = Boolean(requestDelimited);

    /**
     * Whether responses are length-delimited.
     * @type {boolean}
     */
    this.responseDelimited = Boolean(responseDelimited);
}

/**
 * Calls a service method through {@link rpc.Service#rpcImpl|rpcImpl}.
 * @param {Method|rpc.ServiceMethod<TReq,TRes>} method Reflected or static method
 * @param {Constructor<TReq>} requestCtor Request constructor
 * @param {Constructor<TRes>} responseCtor Response constructor
 * @param {TReq|Properties<TReq>} request Request message or plain object
 * @param {rpc.ServiceMethodCallback<TRes>} callback Service callback
 * @returns {undefined}
 * @template TReq extends Message<TReq>
 * @template TRes extends Message<TRes>
 */
Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {

    if (!request)
        throw TypeError("request must be specified");

    var self = this;
    if (!callback)
        return util.asPromise(rpcCall, self, method, requestCtor, responseCtor, request);

    if (!self.rpcImpl) {
        setTimeout(function() { callback(Error("already ended")); }, 0);
        return undefined;
    }

    try {
        return self.rpcImpl(
            method,
            requestCtor[self.requestDelimited ? "encodeDelimited" : "encode"](request).finish(),
            function rpcCallback(err, response) {

                if (err) {
                    self.emit("error", err, method);
                    return callback(err);
                }

                if (response === null) {
                    self.end(/* endedByRPC */ true);
                    return undefined;
                }

                if (!(response instanceof responseCtor)) {
                    try {
                        response = responseCtor[self.responseDelimited ? "decodeDelimited" : "decode"](response);
                    } catch (err) {
                        self.emit("error", err, method);
                        return callback(err);
                    }
                }

                self.emit("data", response, method);
                return callback(null, response);
            }
        );
    } catch (err) {
        self.emit("error", err, method);
        setTimeout(function() { callback(err); }, 0);
        return undefined;
    }
};

/**
 * Ends this service and emits the `end` event.
 * @param {boolean} [endedByRPC=false] Whether the service has been ended by the RPC implementation.
 * @returns {rpc.Service} `this`
 */
Service.prototype.end = function end(endedByRPC) {
    if (this.rpcImpl) {
        if (!endedByRPC) // signal end to rpcImpl
            this.rpcImpl(null, null, null);
        this.rpcImpl = null;
        this.emit("end").off();
    }
    return this;
};


/***/ }),

/***/ "../../node_modules/protobufjs/src/util/longbits.js":
/*!***************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/protobufjs/src/util/longbits.js ***!
  \***************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = LongBits;

var util = __webpack_require__(/*! ../util/minimal */ "../../node_modules/protobufjs/src/util/minimal.js");

/**
 * Constructs new long bits.
 * @classdesc Helper class for working with the low and high bits of a 64 bit value.
 * @memberof util
 * @constructor
 * @param {number} lo Low 32 bits, unsigned
 * @param {number} hi High 32 bits, unsigned
 */
function LongBits(lo, hi) {

    // note that the casts below are theoretically unnecessary as of today, but older statically
    // generated converter code might still call the ctor with signed 32bits. kept for compat.

    /**
     * Low bits.
     * @type {number}
     */
    this.lo = lo >>> 0;

    /**
     * High bits.
     * @type {number}
     */
    this.hi = hi >>> 0;
}

/**
 * Zero bits.
 * @memberof util.LongBits
 * @type {util.LongBits}
 */
var zero = LongBits.zero = new LongBits(0, 0);

zero.toNumber = function() { return 0; };
zero.zzEncode = zero.zzDecode = function() { return this; };
zero.length = function() { return 1; };

/**
 * Zero hash.
 * @memberof util.LongBits
 * @type {string}
 */
var zeroHash = LongBits.zeroHash = "\0\0\0\0\0\0\0\0";

/**
 * Constructs new long bits from the specified number.
 * @param {number} value Value
 * @returns {util.LongBits} Instance
 */
LongBits.fromNumber = function fromNumber(value) {
    if (value === 0)
        return zero;
    var sign = value < 0;
    if (sign)
        value = -value;
    var lo = value >>> 0,
        hi = (value - lo) / 4294967296 >>> 0;
    if (sign) {
        hi = ~hi >>> 0;
        lo = ~lo >>> 0;
        if (++lo > 4294967295) {
            lo = 0;
            if (++hi > 4294967295)
                hi = 0;
        }
    }
    return new LongBits(lo, hi);
};

/**
 * Constructs new long bits from a number, long or string.
 * @param {Long|number|string} value Value
 * @returns {util.LongBits} Instance
 */
LongBits.from = function from(value) {
    if (typeof value === "number")
        return LongBits.fromNumber(value);
    if (util.isString(value)) {
        /* istanbul ignore else */
        if (util.Long)
            value = util.Long.fromString(value);
        else
            return LongBits.fromNumber(parseInt(value, 10));
    }
    return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;
};

/**
 * Converts this long bits to a possibly unsafe JavaScript number.
 * @param {boolean} [unsigned=false] Whether unsigned or not
 * @returns {number} Possibly unsafe number
 */
LongBits.prototype.toNumber = function toNumber(unsigned) {
    if (!unsigned && this.hi >>> 31) {
        var lo = ~this.lo + 1 >>> 0,
            hi = ~this.hi     >>> 0;
        if (!lo)
            hi = hi + 1 >>> 0;
        return -(lo + hi * 4294967296);
    }
    return this.lo + this.hi * 4294967296;
};

/**
 * Converts this long bits to a long.
 * @param {boolean} [unsigned=false] Whether unsigned or not
 * @returns {Long} Long
 */
LongBits.prototype.toLong = function toLong(unsigned) {
    return util.Long
        ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned))
        /* istanbul ignore next */
        : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };
};

var charCodeAt = String.prototype.charCodeAt;

/**
 * Constructs new long bits from the specified 8 characters long hash.
 * @param {string} hash Hash
 * @returns {util.LongBits} Bits
 */
LongBits.fromHash = function fromHash(hash) {
    if (hash === zeroHash)
        return zero;
    return new LongBits(
        ( charCodeAt.call(hash, 0)
        | charCodeAt.call(hash, 1) << 8
        | charCodeAt.call(hash, 2) << 16
        | charCodeAt.call(hash, 3) << 24) >>> 0
    ,
        ( charCodeAt.call(hash, 4)
        | charCodeAt.call(hash, 5) << 8
        | charCodeAt.call(hash, 6) << 16
        | charCodeAt.call(hash, 7) << 24) >>> 0
    );
};

/**
 * Converts this long bits to a 8 characters long hash.
 * @returns {string} Hash
 */
LongBits.prototype.toHash = function toHash() {
    return String.fromCharCode(
        this.lo        & 255,
        this.lo >>> 8  & 255,
        this.lo >>> 16 & 255,
        this.lo >>> 24      ,
        this.hi        & 255,
        this.hi >>> 8  & 255,
        this.hi >>> 16 & 255,
        this.hi >>> 24
    );
};

/**
 * Zig-zag encodes this long bits.
 * @returns {util.LongBits} `this`
 */
LongBits.prototype.zzEncode = function zzEncode() {
    var mask =   this.hi >> 31;
    this.hi  = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
    this.lo  = ( this.lo << 1                   ^ mask) >>> 0;
    return this;
};

/**
 * Zig-zag decodes this long bits.
 * @returns {util.LongBits} `this`
 */
LongBits.prototype.zzDecode = function zzDecode() {
    var mask = -(this.lo & 1);
    this.lo  = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
    this.hi  = ( this.hi >>> 1                  ^ mask) >>> 0;
    return this;
};

/**
 * Calculates the length of this longbits when encoded as a varint.
 * @returns {number} Length
 */
LongBits.prototype.length = function length() {
    var part0 =  this.lo,
        part1 = (this.lo >>> 28 | this.hi << 4) >>> 0,
        part2 =  this.hi >>> 24;
    return part2 === 0
         ? part1 === 0
           ? part0 < 16384
             ? part0 < 128 ? 1 : 2
             : part0 < 2097152 ? 3 : 4
           : part1 < 16384
             ? part1 < 128 ? 5 : 6
             : part1 < 2097152 ? 7 : 8
         : part2 < 128 ? 9 : 10;
};


/***/ }),

/***/ "../../node_modules/protobufjs/src/util/minimal.js":
/*!**************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/protobufjs/src/util/minimal.js ***!
  \**************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var util = exports;

// used to return a Promise where callback is omitted
util.asPromise = __webpack_require__(/*! @protobufjs/aspromise */ "../../node_modules/@protobufjs/aspromise/index.js");

// converts to / from base64 encoded strings
util.base64 = __webpack_require__(/*! @protobufjs/base64 */ "../../node_modules/@protobufjs/base64/index.js");

// base class of rpc.Service
util.EventEmitter = __webpack_require__(/*! @protobufjs/eventemitter */ "../../node_modules/@protobufjs/eventemitter/index.js");

// float handling accross browsers
util.float = __webpack_require__(/*! @protobufjs/float */ "../../node_modules/@protobufjs/float/index.js");

// requires modules optionally and hides the call from bundlers
util.inquire = __webpack_require__(/*! @protobufjs/inquire */ "../../node_modules/@protobufjs/inquire/index.js");

// converts to / from utf8 encoded strings
util.utf8 = __webpack_require__(/*! @protobufjs/utf8 */ "../../node_modules/@protobufjs/utf8/index.js");

// provides a node-like buffer pool in the browser
util.pool = __webpack_require__(/*! @protobufjs/pool */ "../../node_modules/@protobufjs/pool/index.js");

// utility to work with the low and high bits of a 64 bit value
util.LongBits = __webpack_require__(/*! ./longbits */ "../../node_modules/protobufjs/src/util/longbits.js");

/**
 * Whether running within node or not.
 * @memberof util
 * @type {boolean}
 */
util.isNode = Boolean(typeof global !== "undefined"
                   && global
                   && global.process
                   && global.process.versions
                   && global.process.versions.node);

/**
 * Global object reference.
 * @memberof util
 * @type {Object}
 */
util.global = util.isNode && global
           || typeof window !== "undefined" && window
           || typeof self   !== "undefined" && self
           || this; // eslint-disable-line no-invalid-this

/**
 * An immuable empty array.
 * @memberof util
 * @type {Array.<*>}
 * @const
 */
util.emptyArray = Object.freeze ? Object.freeze([]) : /* istanbul ignore next */ []; // used on prototypes

/**
 * An immutable empty object.
 * @type {Object}
 * @const
 */
util.emptyObject = Object.freeze ? Object.freeze({}) : /* istanbul ignore next */ {}; // used on prototypes

/**
 * Tests if the specified value is an integer.
 * @function
 * @param {*} value Value to test
 * @returns {boolean} `true` if the value is an integer
 */
util.isInteger = Number.isInteger || /* istanbul ignore next */ function isInteger(value) {
    return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
};

/**
 * Tests if the specified value is a string.
 * @param {*} value Value to test
 * @returns {boolean} `true` if the value is a string
 */
util.isString = function isString(value) {
    return typeof value === "string" || value instanceof String;
};

/**
 * Tests if the specified value is a non-null object.
 * @param {*} value Value to test
 * @returns {boolean} `true` if the value is a non-null object
 */
util.isObject = function isObject(value) {
    return value && typeof value === "object";
};

/**
 * Checks if a property on a message is considered to be present.
 * This is an alias of {@link util.isSet}.
 * @function
 * @param {Object} obj Plain object or message instance
 * @param {string} prop Property name
 * @returns {boolean} `true` if considered to be present, otherwise `false`
 */
util.isset =

/**
 * Checks if a property on a message is considered to be present.
 * @param {Object} obj Plain object or message instance
 * @param {string} prop Property name
 * @returns {boolean} `true` if considered to be present, otherwise `false`
 */
util.isSet = function isSet(obj, prop) {
    var value = obj[prop];
    if (value != null && obj.hasOwnProperty(prop)) // eslint-disable-line eqeqeq, no-prototype-builtins
        return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
    return false;
};

/**
 * Any compatible Buffer instance.
 * This is a minimal stand-alone definition of a Buffer instance. The actual type is that exported by node's typings.
 * @interface Buffer
 * @extends Uint8Array
 */

/**
 * Node's Buffer class if available.
 * @type {Constructor<Buffer>}
 */
util.Buffer = (function() {
    try {
        var Buffer = util.inquire("buffer").Buffer;
        // refuse to use non-node buffers if not explicitly assigned (perf reasons):
        return Buffer.prototype.utf8Write ? Buffer : /* istanbul ignore next */ null;
    } catch (e) {
        /* istanbul ignore next */
        return null;
    }
})();

// Internal alias of or polyfull for Buffer.from.
util._Buffer_from = null;

// Internal alias of or polyfill for Buffer.allocUnsafe.
util._Buffer_allocUnsafe = null;

/**
 * Creates a new buffer of whatever type supported by the environment.
 * @param {number|number[]} [sizeOrArray=0] Buffer size or number array
 * @returns {Uint8Array|Buffer} Buffer
 */
util.newBuffer = function newBuffer(sizeOrArray) {
    /* istanbul ignore next */
    return typeof sizeOrArray === "number"
        ? util.Buffer
            ? util._Buffer_allocUnsafe(sizeOrArray)
            : new util.Array(sizeOrArray)
        : util.Buffer
            ? util._Buffer_from(sizeOrArray)
            : typeof Uint8Array === "undefined"
                ? sizeOrArray
                : new Uint8Array(sizeOrArray);
};

/**
 * Array implementation used in the browser. `Uint8Array` if supported, otherwise `Array`.
 * @type {Constructor<Uint8Array>}
 */
util.Array = typeof Uint8Array !== "undefined" ? Uint8Array /* istanbul ignore next */ : Array;

/**
 * Any compatible Long instance.
 * This is a minimal stand-alone definition of a Long instance. The actual type is that exported by long.js.
 * @interface Long
 * @property {number} low Low bits
 * @property {number} high High bits
 * @property {boolean} unsigned Whether unsigned or not
 */

/**
 * Long.js's Long class if available.
 * @type {Constructor<Long>}
 */
util.Long = /* istanbul ignore next */ util.global.dcodeIO && /* istanbul ignore next */ util.global.dcodeIO.Long
         || /* istanbul ignore next */ util.global.Long
         || util.inquire("long");

/**
 * Regular expression used to verify 2 bit (`bool`) map keys.
 * @type {RegExp}
 * @const
 */
util.key2Re = /^true|false|0|1$/;

/**
 * Regular expression used to verify 32 bit (`int32` etc.) map keys.
 * @type {RegExp}
 * @const
 */
util.key32Re = /^-?(?:0|[1-9][0-9]*)$/;

/**
 * Regular expression used to verify 64 bit (`int64` etc.) map keys.
 * @type {RegExp}
 * @const
 */
util.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;

/**
 * Converts a number or long to an 8 characters long hash string.
 * @param {Long|number} value Value to convert
 * @returns {string} Hash
 */
util.longToHash = function longToHash(value) {
    return value
        ? util.LongBits.from(value).toHash()
        : util.LongBits.zeroHash;
};

/**
 * Converts an 8 characters long hash string to a long or number.
 * @param {string} hash Hash
 * @param {boolean} [unsigned=false] Whether unsigned or not
 * @returns {Long|number} Original value
 */
util.longFromHash = function longFromHash(hash, unsigned) {
    var bits = util.LongBits.fromHash(hash);
    if (util.Long)
        return util.Long.fromBits(bits.lo, bits.hi, unsigned);
    return bits.toNumber(Boolean(unsigned));
};

/**
 * Merges the properties of the source object into the destination object.
 * @memberof util
 * @param {Object.<string,*>} dst Destination object
 * @param {Object.<string,*>} src Source object
 * @param {boolean} [ifNotSet=false] Merges only if the key is not already set
 * @returns {Object.<string,*>} Destination object
 */
function merge(dst, src, ifNotSet) { // used by converters
    for (var keys = Object.keys(src), i = 0; i < keys.length; ++i)
        if (dst[keys[i]] === undefined || !ifNotSet)
            dst[keys[i]] = src[keys[i]];
    return dst;
}

util.merge = merge;

/**
 * Converts the first character of a string to lower case.
 * @param {string} str String to convert
 * @returns {string} Converted string
 */
util.lcFirst = function lcFirst(str) {
    return str.charAt(0).toLowerCase() + str.substring(1);
};

/**
 * Creates a custom error constructor.
 * @memberof util
 * @param {string} name Error name
 * @returns {Constructor<Error>} Custom error constructor
 */
function newError(name) {

    function CustomError(message, properties) {

        if (!(this instanceof CustomError))
            return new CustomError(message, properties);

        // Error.call(this, message);
        // ^ just returns a new error instance because the ctor can be called as a function

        Object.defineProperty(this, "message", { get: function() { return message; } });

        /* istanbul ignore next */
        if (Error.captureStackTrace) // node
            Error.captureStackTrace(this, CustomError);
        else
            Object.defineProperty(this, "stack", { value: new Error().stack || "" });

        if (properties)
            merge(this, properties);
    }

    (CustomError.prototype = Object.create(Error.prototype)).constructor = CustomError;

    Object.defineProperty(CustomError.prototype, "name", { get: function() { return name; } });

    CustomError.prototype.toString = function toString() {
        return this.name + ": " + this.message;
    };

    return CustomError;
}

util.newError = newError;

/**
 * Constructs a new protocol error.
 * @classdesc Error subclass indicating a protocol specifc error.
 * @memberof util
 * @extends Error
 * @template T extends Message<T>
 * @constructor
 * @param {string} message Error message
 * @param {Object.<string,*>} [properties] Additional properties
 * @example
 * try {
 *     MyMessage.decode(someBuffer); // throws if required fields are missing
 * } catch (e) {
 *     if (e instanceof ProtocolError && e.instance)
 *         console.log("decoded so far: " + JSON.stringify(e.instance));
 * }
 */
util.ProtocolError = newError("ProtocolError");

/**
 * So far decoded message instance.
 * @name util.ProtocolError#instance
 * @type {Message<T>}
 */

/**
 * A OneOf getter as returned by {@link util.oneOfGetter}.
 * @typedef OneOfGetter
 * @type {function}
 * @returns {string|undefined} Set field name, if any
 */

/**
 * Builds a getter for a oneof's present field name.
 * @param {string[]} fieldNames Field names
 * @returns {OneOfGetter} Unbound getter
 */
util.oneOfGetter = function getOneOf(fieldNames) {
    var fieldMap = {};
    for (var i = 0; i < fieldNames.length; ++i)
        fieldMap[fieldNames[i]] = 1;

    /**
     * @returns {string|undefined} Set field name, if any
     * @this Object
     * @ignore
     */
    return function() { // eslint-disable-line consistent-return
        for (var keys = Object.keys(this), i = keys.length - 1; i > -1; --i)
            if (fieldMap[keys[i]] === 1 && this[keys[i]] !== undefined && this[keys[i]] !== null)
                return keys[i];
    };
};

/**
 * A OneOf setter as returned by {@link util.oneOfSetter}.
 * @typedef OneOfSetter
 * @type {function}
 * @param {string|undefined} value Field name
 * @returns {undefined}
 */

/**
 * Builds a setter for a oneof's present field name.
 * @param {string[]} fieldNames Field names
 * @returns {OneOfSetter} Unbound setter
 */
util.oneOfSetter = function setOneOf(fieldNames) {

    /**
     * @param {string} name Field name
     * @returns {undefined}
     * @this Object
     * @ignore
     */
    return function(name) {
        for (var i = 0; i < fieldNames.length; ++i)
            if (fieldNames[i] !== name)
                delete this[fieldNames[i]];
    };
};

/**
 * Default conversion options used for {@link Message#toJSON} implementations.
 *
 * These options are close to proto3's JSON mapping with the exception that internal types like Any are handled just like messages. More precisely:
 *
 * - Longs become strings
 * - Enums become string keys
 * - Bytes become base64 encoded strings
 * - (Sub-)Messages become plain objects
 * - Maps become plain objects with all string keys
 * - Repeated fields become arrays
 * - NaN and Infinity for float and double fields become strings
 *
 * @type {IConversionOptions}
 * @see https://developers.google.com/protocol-buffers/docs/proto3?hl=en#json
 */
util.toJSONOptions = {
    longs: String,
    enums: String,
    bytes: String,
    json: true
};

// Sets up buffer utility according to the environment (called in index-minimal)
util._configure = function() {
    var Buffer = util.Buffer;
    /* istanbul ignore if */
    if (!Buffer) {
        util._Buffer_from = util._Buffer_allocUnsafe = null;
        return;
    }
    // because node 4.x buffers are incompatible & immutable
    // see: https://github.com/dcodeIO/protobuf.js/pull/665
    util._Buffer_from = Buffer.from !== Uint8Array.from && Buffer.from ||
        /* istanbul ignore next */
        function Buffer_from(value, encoding) {
            return new Buffer(value, encoding);
        };
    util._Buffer_allocUnsafe = Buffer.allocUnsafe ||
        /* istanbul ignore next */
        function Buffer_allocUnsafe(size) {
            return new Buffer(size);
        };
};


/***/ }),

/***/ "../../node_modules/protobufjs/src/writer.js":
/*!********************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/protobufjs/src/writer.js ***!
  \********************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = Writer;

var util      = __webpack_require__(/*! ./util/minimal */ "../../node_modules/protobufjs/src/util/minimal.js");

var BufferWriter; // cyclic

var LongBits  = util.LongBits,
    base64    = util.base64,
    utf8      = util.utf8;

/**
 * Constructs a new writer operation instance.
 * @classdesc Scheduled writer operation.
 * @constructor
 * @param {function(*, Uint8Array, number)} fn Function to call
 * @param {number} len Value byte length
 * @param {*} val Value to write
 * @ignore
 */
function Op(fn, len, val) {

    /**
     * Function to call.
     * @type {function(Uint8Array, number, *)}
     */
    this.fn = fn;

    /**
     * Value byte length.
     * @type {number}
     */
    this.len = len;

    /**
     * Next operation.
     * @type {Writer.Op|undefined}
     */
    this.next = undefined;

    /**
     * Value to write.
     * @type {*}
     */
    this.val = val; // type varies
}

/* istanbul ignore next */
function noop() {} // eslint-disable-line no-empty-function

/**
 * Constructs a new writer state instance.
 * @classdesc Copied writer state.
 * @memberof Writer
 * @constructor
 * @param {Writer} writer Writer to copy state from
 * @ignore
 */
function State(writer) {

    /**
     * Current head.
     * @type {Writer.Op}
     */
    this.head = writer.head;

    /**
     * Current tail.
     * @type {Writer.Op}
     */
    this.tail = writer.tail;

    /**
     * Current buffer length.
     * @type {number}
     */
    this.len = writer.len;

    /**
     * Next state.
     * @type {State|null}
     */
    this.next = writer.states;
}

/**
 * Constructs a new writer instance.
 * @classdesc Wire format writer using `Uint8Array` if available, otherwise `Array`.
 * @constructor
 */
function Writer() {

    /**
     * Current length.
     * @type {number}
     */
    this.len = 0;

    /**
     * Operations head.
     * @type {Object}
     */
    this.head = new Op(noop, 0, 0);

    /**
     * Operations tail
     * @type {Object}
     */
    this.tail = this.head;

    /**
     * Linked forked states.
     * @type {Object|null}
     */
    this.states = null;

    // When a value is written, the writer calculates its byte length and puts it into a linked
    // list of operations to perform when finish() is called. This both allows us to allocate
    // buffers of the exact required size and reduces the amount of work we have to do compared
    // to first calculating over objects and then encoding over objects. In our case, the encoding
    // part is just a linked list walk calling operations with already prepared values.
}

var create = function create() {
    return util.Buffer
        ? function create_buffer_setup() {
            return (Writer.create = function create_buffer() {
                return new BufferWriter();
            })();
        }
        /* istanbul ignore next */
        : function create_array() {
            return new Writer();
        };
};

/**
 * Creates a new writer.
 * @function
 * @returns {BufferWriter|Writer} A {@link BufferWriter} when Buffers are supported, otherwise a {@link Writer}
 */
Writer.create = create();

/**
 * Allocates a buffer of the specified size.
 * @param {number} size Buffer size
 * @returns {Uint8Array} Buffer
 */
Writer.alloc = function alloc(size) {
    return new util.Array(size);
};

// Use Uint8Array buffer pool in the browser, just like node does with buffers
/* istanbul ignore else */
if (util.Array !== Array)
    Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);

/**
 * Pushes a new operation to the queue.
 * @param {function(Uint8Array, number, *)} fn Function to call
 * @param {number} len Value byte length
 * @param {number} val Value to write
 * @returns {Writer} `this`
 * @private
 */
Writer.prototype._push = function push(fn, len, val) {
    this.tail = this.tail.next = new Op(fn, len, val);
    this.len += len;
    return this;
};

function writeByte(val, buf, pos) {
    buf[pos] = val & 255;
}

function writeVarint32(val, buf, pos) {
    while (val > 127) {
        buf[pos++] = val & 127 | 128;
        val >>>= 7;
    }
    buf[pos] = val;
}

/**
 * Constructs a new varint writer operation instance.
 * @classdesc Scheduled varint writer operation.
 * @extends Op
 * @constructor
 * @param {number} len Value byte length
 * @param {number} val Value to write
 * @ignore
 */
function VarintOp(len, val) {
    this.len = len;
    this.next = undefined;
    this.val = val;
}

VarintOp.prototype = Object.create(Op.prototype);
VarintOp.prototype.fn = writeVarint32;

/**
 * Writes an unsigned 32 bit value as a varint.
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.uint32 = function write_uint32(value) {
    // here, the call to this.push has been inlined and a varint specific Op subclass is used.
    // uint32 is by far the most frequently used operation and benefits significantly from this.
    this.len += (this.tail = this.tail.next = new VarintOp(
        (value = value >>> 0)
                < 128       ? 1
        : value < 16384     ? 2
        : value < 2097152   ? 3
        : value < 268435456 ? 4
        :                     5,
    value)).len;
    return this;
};

/**
 * Writes a signed 32 bit value as a varint.
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.int32 = function write_int32(value) {
    return value < 0
        ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) // 10 bytes per spec
        : this.uint32(value);
};

/**
 * Writes a 32 bit value as a varint, zig-zag encoded.
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.sint32 = function write_sint32(value) {
    return this.uint32((value << 1 ^ value >> 31) >>> 0);
};

function writeVarint64(val, buf, pos) {
    while (val.hi) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
        val.hi >>>= 7;
    }
    while (val.lo > 127) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = val.lo >>> 7;
    }
    buf[pos++] = val.lo;
}

/**
 * Writes an unsigned 64 bit value as a varint.
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.uint64 = function write_uint64(value) {
    var bits = LongBits.from(value);
    return this._push(writeVarint64, bits.length(), bits);
};

/**
 * Writes a signed 64 bit value as a varint.
 * @function
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.int64 = Writer.prototype.uint64;

/**
 * Writes a signed 64 bit value as a varint, zig-zag encoded.
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.sint64 = function write_sint64(value) {
    var bits = LongBits.from(value).zzEncode();
    return this._push(writeVarint64, bits.length(), bits);
};

/**
 * Writes a boolish value as a varint.
 * @param {boolean} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.bool = function write_bool(value) {
    return this._push(writeByte, 1, value ? 1 : 0);
};

function writeFixed32(val, buf, pos) {
    buf[pos    ] =  val         & 255;
    buf[pos + 1] =  val >>> 8   & 255;
    buf[pos + 2] =  val >>> 16  & 255;
    buf[pos + 3] =  val >>> 24;
}

/**
 * Writes an unsigned 32 bit value as fixed 32 bits.
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.fixed32 = function write_fixed32(value) {
    return this._push(writeFixed32, 4, value >>> 0);
};

/**
 * Writes a signed 32 bit value as fixed 32 bits.
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.sfixed32 = Writer.prototype.fixed32;

/**
 * Writes an unsigned 64 bit value as fixed 64 bits.
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.fixed64 = function write_fixed64(value) {
    var bits = LongBits.from(value);
    return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
};

/**
 * Writes a signed 64 bit value as fixed 64 bits.
 * @function
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.sfixed64 = Writer.prototype.fixed64;

/**
 * Writes a float (32 bit).
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.float = function write_float(value) {
    return this._push(util.float.writeFloatLE, 4, value);
};

/**
 * Writes a double (64 bit float).
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.double = function write_double(value) {
    return this._push(util.float.writeDoubleLE, 8, value);
};

var writeBytes = util.Array.prototype.set
    ? function writeBytes_set(val, buf, pos) {
        buf.set(val, pos); // also works for plain array values
    }
    /* istanbul ignore next */
    : function writeBytes_for(val, buf, pos) {
        for (var i = 0; i < val.length; ++i)
            buf[pos + i] = val[i];
    };

/**
 * Writes a sequence of bytes.
 * @param {Uint8Array|string} value Buffer or base64 encoded string to write
 * @returns {Writer} `this`
 */
Writer.prototype.bytes = function write_bytes(value) {
    var len = value.length >>> 0;
    if (!len)
        return this._push(writeByte, 1, 0);
    if (util.isString(value)) {
        var buf = Writer.alloc(len = base64.length(value));
        base64.decode(value, buf, 0);
        value = buf;
    }
    return this.uint32(len)._push(writeBytes, len, value);
};

/**
 * Writes a string.
 * @param {string} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.string = function write_string(value) {
    var len = utf8.length(value);
    return len
        ? this.uint32(len)._push(utf8.write, len, value)
        : this._push(writeByte, 1, 0);
};

/**
 * Forks this writer's state by pushing it to a stack.
 * Calling {@link Writer#reset|reset} or {@link Writer#ldelim|ldelim} resets the writer to the previous state.
 * @returns {Writer} `this`
 */
Writer.prototype.fork = function fork() {
    this.states = new State(this);
    this.head = this.tail = new Op(noop, 0, 0);
    this.len = 0;
    return this;
};

/**
 * Resets this instance to the last state.
 * @returns {Writer} `this`
 */
Writer.prototype.reset = function reset() {
    if (this.states) {
        this.head   = this.states.head;
        this.tail   = this.states.tail;
        this.len    = this.states.len;
        this.states = this.states.next;
    } else {
        this.head = this.tail = new Op(noop, 0, 0);
        this.len  = 0;
    }
    return this;
};

/**
 * Resets to the last state and appends the fork state's current write length as a varint followed by its operations.
 * @returns {Writer} `this`
 */
Writer.prototype.ldelim = function ldelim() {
    var head = this.head,
        tail = this.tail,
        len  = this.len;
    this.reset().uint32(len);
    if (len) {
        this.tail.next = head.next; // skip noop
        this.tail = tail;
        this.len += len;
    }
    return this;
};

/**
 * Finishes the write operation.
 * @returns {Uint8Array} Finished buffer
 */
Writer.prototype.finish = function finish() {
    var head = this.head.next, // skip noop
        buf  = this.constructor.alloc(this.len),
        pos  = 0;
    while (head) {
        head.fn(head.val, buf, pos);
        pos += head.len;
        head = head.next;
    }
    // this.head = this.tail = null;
    return buf;
};

Writer._configure = function(BufferWriter_) {
    BufferWriter = BufferWriter_;
    Writer.create = create();
    BufferWriter._configure();
};


/***/ }),

/***/ "../../node_modules/protobufjs/src/writer_buffer.js":
/*!***************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/protobufjs/src/writer_buffer.js ***!
  \***************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = BufferWriter;

// extends Writer
var Writer = __webpack_require__(/*! ./writer */ "../../node_modules/protobufjs/src/writer.js");
(BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;

var util = __webpack_require__(/*! ./util/minimal */ "../../node_modules/protobufjs/src/util/minimal.js");

/**
 * Constructs a new buffer writer instance.
 * @classdesc Wire format writer using node buffers.
 * @extends Writer
 * @constructor
 */
function BufferWriter() {
    Writer.call(this);
}

BufferWriter._configure = function () {
    /**
     * Allocates a buffer of the specified size.
     * @function
     * @param {number} size Buffer size
     * @returns {Buffer} Buffer
     */
    BufferWriter.alloc = util._Buffer_allocUnsafe;

    BufferWriter.writeBytesBuffer = util.Buffer && util.Buffer.prototype instanceof Uint8Array && util.Buffer.prototype.set.name === "set"
        ? function writeBytesBuffer_set(val, buf, pos) {
          buf.set(val, pos); // faster than copy (requires node >= 4 where Buffers extend Uint8Array and set is properly inherited)
          // also works for plain array values
        }
        /* istanbul ignore next */
        : function writeBytesBuffer_copy(val, buf, pos) {
          if (val.copy) // Buffer values
            val.copy(buf, pos, 0, val.length);
          else for (var i = 0; i < val.length;) // plain array values
            buf[pos++] = val[i++];
        };
};


/**
 * @override
 */
BufferWriter.prototype.bytes = function write_bytes_buffer(value) {
    if (util.isString(value))
        value = util._Buffer_from(value, "base64");
    var len = value.length >>> 0;
    this.uint32(len);
    if (len)
        this._push(BufferWriter.writeBytesBuffer, len, value);
    return this;
};

function writeStringBuffer(val, buf, pos) {
    if (val.length < 40) // plain js is faster for short strings (probably due to redundant assertions)
        util.utf8.write(val, buf, pos);
    else if (buf.utf8Write)
        buf.utf8Write(val, pos);
    else
        buf.write(val, pos);
}

/**
 * @override
 */
BufferWriter.prototype.string = function write_string_buffer(value) {
    var len = util.Buffer.byteLength(value);
    this.uint32(len);
    if (len)
        this._push(writeStringBuffer, len, value);
    return this;
};


/**
 * Finishes the write operation.
 * @name BufferWriter#finish
 * @function
 * @returns {Buffer} Finished buffer
 */

BufferWriter._configure();


/***/ }),

/***/ "../../node_modules/split/index.js":
/*!**********************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/split/index.js ***!
  \**********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

//filter will reemit the data if cb(err,pass) pass is truthy

// reduce is more tricky
// maybe we want to group the reductions or emit progress updates occasionally
// the most basic reduce just emits one 'data' event after it has recieved 'end'


var through = __webpack_require__(/*! through */ "../../node_modules/through/index.js")
var Decoder = __webpack_require__(/*! string_decoder */ "string_decoder").StringDecoder

module.exports = split

//TODO pass in a function to map across the lines.

function split (matcher, mapper, options) {
  var decoder = new Decoder()
  var soFar = ''
  var maxLength = options && options.maxLength;
  var trailing = options && options.trailing === false ? false : true
  if('function' === typeof matcher)
    mapper = matcher, matcher = null
  if (!matcher)
    matcher = /\r?\n/

  function emit(stream, piece) {
    if(mapper) {
      try {
        piece = mapper(piece)
      }
      catch (err) {
        return stream.emit('error', err)
      }
      if('undefined' !== typeof piece)
        stream.queue(piece)
    }
    else
      stream.queue(piece)
  }

  function next (stream, buffer) {
    var pieces = ((soFar != null ? soFar : '') + buffer).split(matcher)
    soFar = pieces.pop()

    if (maxLength && soFar.length > maxLength)
      return stream.emit('error', new Error('maximum buffer reached'))

    for (var i = 0; i < pieces.length; i++) {
      var piece = pieces[i]
      emit(stream, piece)
    }
  }

  return through(function (b) {
    next(this, decoder.write(b))
  },
  function () {
    if(decoder.end)
      next(this, decoder.end())
    if(trailing && soFar != null)
      emit(this, soFar)
    this.queue(null)
  })
}


/***/ }),

/***/ "../../node_modules/through/index.js":
/*!************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/through/index.js ***!
  \************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var Stream = __webpack_require__(/*! stream */ "stream")

// through
//
// a stream that does nothing but re-emit the input.
// useful for aggregating a series of changing but not ending streams into one stream)

exports = module.exports = through
through.through = through

//create a readable writable stream.

function through (write, end, opts) {
  write = write || function (data) { this.queue(data) }
  end = end || function () { this.queue(null) }

  var ended = false, destroyed = false, buffer = [], _ended = false
  var stream = new Stream()
  stream.readable = stream.writable = true
  stream.paused = false

//  stream.autoPause   = !(opts && opts.autoPause   === false)
  stream.autoDestroy = !(opts && opts.autoDestroy === false)

  stream.write = function (data) {
    write.call(this, data)
    return !stream.paused
  }

  function drain() {
    while(buffer.length && !stream.paused) {
      var data = buffer.shift()
      if(null === data)
        return stream.emit('end')
      else
        stream.emit('data', data)
    }
  }

  stream.queue = stream.push = function (data) {
//    console.error(ended)
    if(_ended) return stream
    if(data === null) _ended = true
    buffer.push(data)
    drain()
    return stream
  }

  //this will be registered as the first 'end' listener
  //must call destroy next tick, to make sure we're after any
  //stream piped from here.
  //this is only a problem if end is not emitted synchronously.
  //a nicer way to do this is to make sure this is the last listener for 'end'

  stream.on('end', function () {
    stream.readable = false
    if(!stream.writable && stream.autoDestroy)
      process.nextTick(function () {
        stream.destroy()
      })
  })

  function _end () {
    stream.writable = false
    end.call(stream)
    if(!stream.readable && stream.autoDestroy)
      stream.destroy()
  }

  stream.end = function (data) {
    if(ended) return
    ended = true
    if(arguments.length) stream.write(data)
    _end() // will emit or queue
    return stream
  }

  stream.destroy = function () {
    if(destroyed) return
    destroyed = true
    ended = true
    buffer.length = 0
    stream.writable = stream.readable = false
    stream.emit('close')
    return stream
  }

  stream.pause = function () {
    if(stream.paused) return
    stream.paused = true
    return stream
  }

  stream.resume = function () {
    if(stream.paused) {
      stream.paused = false
      stream.emit('resume')
    }
    drain()
    //may have become paused again,
    //as drain emits 'data'.
    if(!stream.paused)
      stream.emit('drain')
    return stream
  }
  return stream
}



/***/ }),

/***/ "../../node_modules/yocto-queue/index.js":
/*!****************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/yocto-queue/index.js ***!
  \****************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports) {

class Node {
	/// value;
	/// next;

	constructor(value) {
		this.value = value;

		// TODO: Remove this when targeting Node.js 12.
		this.next = undefined;
	}
}

class Queue {
	// TODO: Use private class fields when targeting Node.js 12.
	// #_head;
	// #_tail;
	// #_size;

	constructor() {
		this.clear();
	}

	enqueue(value) {
		const node = new Node(value);

		if (this._head) {
			this._tail.next = node;
			this._tail = node;
		} else {
			this._head = node;
			this._tail = node;
		}

		this._size++;
	}

	dequeue() {
		const current = this._head;
		if (!current) {
			return;
		}

		this._head = this._head.next;
		this._size--;
		return current.value;
	}

	clear() {
		this._head = undefined;
		this._tail = undefined;
		this._size = 0;
	}

	get size() {
		return this._size;
	}

	* [Symbol.iterator]() {
		let current = this._head;

		while (current) {
			yield current.value;
			current = current.next;
		}
	}
}

module.exports = Queue;


/***/ }),

/***/ "child_process":
/*!********************************!*\
  !*** external "child_process" ***!
  \********************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports) {

module.exports = require("child_process");

/***/ }),

/***/ "dgram":
/*!************************!*\
  !*** external "dgram" ***!
  \************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports) {

module.exports = require("dgram");

/***/ }),

/***/ "diagnostics_channel":
/*!**************************************!*\
  !*** external "diagnostics_channel" ***!
  \**************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports) {

module.exports = require("diagnostics_channel");

/***/ }),

/***/ "dns":
/*!**********************!*\
  !*** external "dns" ***!
  \**********************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports) {

module.exports = require("dns");

/***/ }),

/***/ "v8":
/*!*********************!*\
  !*** external "v8" ***!
  \*********************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports) {

module.exports = require("v8");

/***/ })

};
//# sourceMappingURL=index.f52e6a841984f0e503cc.hot-update.js.map