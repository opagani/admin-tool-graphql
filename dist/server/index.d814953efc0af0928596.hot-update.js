exports.id = "index";
exports.modules = {

/***/ "../../modules/particles-js-node-logger/src/pinoLogger.ts":
/*!*********************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/modules/particles-js-node-logger/src/pinoLogger.ts ***!
  \*********************************************************************************************************/
/*! exports provided: PinoLogger */
/*! exports used: PinoLogger */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return PinoLogger; });
/* harmony import */ var core_js_modules_es_array_join_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! core-js/modules/es.array.join.js */ "../../node_modules/core-js/modules/es.array.join.js");
/* harmony import */ var core_js_modules_es_array_join_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_join_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var core_js_modules_es_object_define_property_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! core-js/modules/es.object.define-property.js */ "../../node_modules/core-js/modules/es.object.define-property.js");
/* harmony import */ var core_js_modules_es_object_define_property_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_object_define_property_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var core_js_modules_es_object_set_prototype_of_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! core-js/modules/es.object.set-prototype-of.js */ "../../node_modules/core-js/modules/es.object.set-prototype-of.js");
/* harmony import */ var core_js_modules_es_object_set_prototype_of_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_object_set_prototype_of_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var core_js_modules_es_object_get_prototype_of_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! core-js/modules/es.object.get-prototype-of.js */ "../../node_modules/core-js/modules/es.object.get-prototype-of.js");
/* harmony import */ var core_js_modules_es_object_get_prototype_of_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_object_get_prototype_of_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var core_js_modules_es_reflect_construct_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! core-js/modules/es.reflect.construct.js */ "../../node_modules/core-js/modules/es.reflect.construct.js");
/* harmony import */ var core_js_modules_es_reflect_construct_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_reflect_construct_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var core_js_modules_es_object_create_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! core-js/modules/es.object.create.js */ "../../node_modules/core-js/modules/es.object.create.js");
/* harmony import */ var core_js_modules_es_object_create_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_object_create_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var core_js_modules_es_object_keys_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! core-js/modules/es.object.keys.js */ "../../node_modules/core-js/modules/es.object.keys.js");
/* harmony import */ var core_js_modules_es_object_keys_js__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_object_keys_js__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var core_js_modules_es_symbol_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! core-js/modules/es.symbol.js */ "../../node_modules/core-js/modules/es.symbol.js");
/* harmony import */ var core_js_modules_es_symbol_js__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_symbol_js__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var core_js_modules_es_array_filter_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! core-js/modules/es.array.filter.js */ "../../node_modules/core-js/modules/es.array.filter.js");
/* harmony import */ var core_js_modules_es_array_filter_js__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_filter_js__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var core_js_modules_es_object_get_own_property_descriptor_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! core-js/modules/es.object.get-own-property-descriptor.js */ "../../node_modules/core-js/modules/es.object.get-own-property-descriptor.js");
/* harmony import */ var core_js_modules_es_object_get_own_property_descriptor_js__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_object_get_own_property_descriptor_js__WEBPACK_IMPORTED_MODULE_9__);
/* harmony import */ var core_js_modules_es_array_for_each_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! core-js/modules/es.array.for-each.js */ "../../node_modules/core-js/modules/es.array.for-each.js");
/* harmony import */ var core_js_modules_es_array_for_each_js__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_for_each_js__WEBPACK_IMPORTED_MODULE_10__);
/* harmony import */ var core_js_modules_web_dom_collections_for_each_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! core-js/modules/web.dom-collections.for-each.js */ "../../node_modules/core-js/modules/web.dom-collections.for-each.js");
/* harmony import */ var core_js_modules_web_dom_collections_for_each_js__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_web_dom_collections_for_each_js__WEBPACK_IMPORTED_MODULE_11__);
/* harmony import */ var core_js_modules_es_object_get_own_property_descriptors_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! core-js/modules/es.object.get-own-property-descriptors.js */ "../../node_modules/core-js/modules/es.object.get-own-property-descriptors.js");
/* harmony import */ var core_js_modules_es_object_get_own_property_descriptors_js__WEBPACK_IMPORTED_MODULE_12___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_object_get_own_property_descriptors_js__WEBPACK_IMPORTED_MODULE_12__);
/* harmony import */ var core_js_modules_es_object_define_properties_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! core-js/modules/es.object.define-properties.js */ "../../node_modules/core-js/modules/es.object.define-properties.js");
/* harmony import */ var core_js_modules_es_object_define_properties_js__WEBPACK_IMPORTED_MODULE_13___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_object_define_properties_js__WEBPACK_IMPORTED_MODULE_13__);
/* harmony import */ var core_js_modules_es_symbol_description_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! core-js/modules/es.symbol.description.js */ "../../node_modules/core-js/modules/es.symbol.description.js");
/* harmony import */ var core_js_modules_es_symbol_description_js__WEBPACK_IMPORTED_MODULE_14___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_symbol_description_js__WEBPACK_IMPORTED_MODULE_14__);
/* harmony import */ var core_js_modules_es_object_to_string_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! core-js/modules/es.object.to-string.js */ "../../node_modules/core-js/modules/es.object.to-string.js");
/* harmony import */ var core_js_modules_es_object_to_string_js__WEBPACK_IMPORTED_MODULE_15___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_object_to_string_js__WEBPACK_IMPORTED_MODULE_15__);
/* harmony import */ var core_js_modules_es_symbol_iterator_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! core-js/modules/es.symbol.iterator.js */ "../../node_modules/core-js/modules/es.symbol.iterator.js");
/* harmony import */ var core_js_modules_es_symbol_iterator_js__WEBPACK_IMPORTED_MODULE_16___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_symbol_iterator_js__WEBPACK_IMPORTED_MODULE_16__);
/* harmony import */ var core_js_modules_es_array_iterator_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! core-js/modules/es.array.iterator.js */ "../../node_modules/core-js/modules/es.array.iterator.js");
/* harmony import */ var core_js_modules_es_array_iterator_js__WEBPACK_IMPORTED_MODULE_17___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_iterator_js__WEBPACK_IMPORTED_MODULE_17__);
/* harmony import */ var core_js_modules_es_string_iterator_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! core-js/modules/es.string.iterator.js */ "../../node_modules/core-js/modules/es.string.iterator.js");
/* harmony import */ var core_js_modules_es_string_iterator_js__WEBPACK_IMPORTED_MODULE_18___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_string_iterator_js__WEBPACK_IMPORTED_MODULE_18__);
/* harmony import */ var core_js_modules_web_dom_collections_iterator_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! core-js/modules/web.dom-collections.iterator.js */ "../../node_modules/core-js/modules/web.dom-collections.iterator.js");
/* harmony import */ var core_js_modules_web_dom_collections_iterator_js__WEBPACK_IMPORTED_MODULE_19___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_web_dom_collections_iterator_js__WEBPACK_IMPORTED_MODULE_19__);
/* harmony import */ var _zg_rentals_particles_js_base_logger__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! @zg-rentals/particles-js-base-logger */ "../../modules/particles-js-base-logger/src/index.ts");
/* harmony import */ var child_process__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! child_process */ "child_process");
/* harmony import */ var child_process__WEBPACK_IMPORTED_MODULE_21___default = /*#__PURE__*/__webpack_require__.n(child_process__WEBPACK_IMPORTED_MODULE_21__);
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! fs */ "fs");
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_22___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_22__);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! path */ "path");
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_23___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_23__);
/* harmony import */ var pino__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! pino */ "../../modules/particles-js-node-logger/node_modules/pino/pino.js");
/* harmony import */ var pino__WEBPACK_IMPORTED_MODULE_24___default = /*#__PURE__*/__webpack_require__.n(pino__WEBPACK_IMPORTED_MODULE_24__);
/* harmony import */ var stream__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! stream */ "stream");
/* harmony import */ var stream__WEBPACK_IMPORTED_MODULE_25___default = /*#__PURE__*/__webpack_require__.n(stream__WEBPACK_IMPORTED_MODULE_25__);
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }






















function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }







var PinoLogger = /*#__PURE__*/function (_BaseLogger) {
  _inherits(PinoLogger, _BaseLogger);

  var _super = _createSuper(PinoLogger);

  function PinoLogger() {
    var _this;

    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$pinoArgs = _ref.pinoArgs,
        pinoArgs = _ref$pinoArgs === void 0 ? {} : _ref$pinoArgs,
        _ref$logPath = _ref.logPath,
        logPath = _ref$logPath === void 0 ? '' : _ref$logPath,
        _ref$prettyPath = _ref.prettyPath,
        prettyPath = _ref$prettyPath === void 0 ? 'node_modules/pino-pretty/bin.js' : _ref$prettyPath,
        _ref$__reset = _ref.__reset,
        __reset = _ref$__reset === void 0 ? function () {} : _ref$__reset;

    _classCallCheck(this, PinoLogger);

    _this = _super.call(this, {
      __reset: __reset,
      runtime: 'node'
    });

    _defineProperty(_assertThisInitialized(_this), "logger", void 0);

    _defineProperty(_assertThisInitialized(_this), "prettyLogger", void 0);

    _defineProperty(_assertThisInitialized(_this), "_enableLogSync", true);

    _defineProperty(_assertThisInitialized(_this), "runtime", void 0);

    _this.runtime = 'node';
    var cwd = process.cwd();
    var logThrough = new stream__WEBPACK_IMPORTED_MODULE_25___default.a.PassThrough();
    _this.logger = pino__WEBPACK_IMPORTED_MODULE_24___default()(_objectSpread({
      level: 'info'
    }, pinoArgs), logThrough);

    if (logPath) {
      logThrough.pipe(fs__WEBPACK_IMPORTED_MODULE_22___default.a.createWriteStream(logPath, {
        flags: 'a'
      }));
    }

    if (prettyPath) {
      var prettyLogger = child_process__WEBPACK_IMPORTED_MODULE_21___default.a.spawn(process.execPath, [path__WEBPACK_IMPORTED_MODULE_23___default.a.join(process.cwd(), prettyPath), '-c'], {
        cwd: cwd,
        env: process.env
      });
      logThrough.pipe(prettyLogger.stdin);
      prettyLogger.stdout.pipe(process.stdout);
      _this.prettyLogger = prettyLogger;
    } else {
      logThrough.pipe(process.stdout);
    }

    return _this;
  }

  _createClass(PinoLogger, [{
    key: "child",
    value: function child(name, bindings) {
      if (name.length > 255) {
        throw new Error("child logger name length is ".concat(name.length, ", must be less than 255"));
      }

      var logger = this.logger.child(_objectSpread(_objectSpread({}, bindings), {}, {
        name: name
      }));

      this._children.set(name, logger);

      return logger;
    }
  }, {
    key: "error",
    value: function error() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      this.logger.error(args);
    }
  }, {
    key: "warn",
    value: function warn() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      this.logger.warn(args);
    }
  }, {
    key: "info",
    value: function info() {
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }

      this.logger.info(args);
    }
  }, {
    key: "debug",
    value: function debug() {
      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }

      this.logger.debug(args);
    }
  }, {
    key: "trace",
    value: function trace() {
      for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
        args[_key5] = arguments[_key5];
      }

      this.logger.trace(args);
    }
  }, {
    key: "_getChildLogger",
    value: function _getChildLogger(name) {
      return this._children.get(name);
    }
  }, {
    key: "setChildLogLevel",
    value: function setChildLogLevel(name, level) {
      var logger = this._getChildLogger(name);

      if (logger) logger.level = level || process.env.LOG_LEVEL || 'warn';
    }
  }]);

  return PinoLogger;
}(_zg_rentals_particles_js_base_logger__WEBPACK_IMPORTED_MODULE_20__[/* BaseLogger */ "a"]);

/***/ }),

/***/ "../../node_modules/@datadog/native-appsec/index.js":
false,

/***/ "../../node_modules/@datadog/native-appsec/lib/loader.js":
false,

/***/ "../../node_modules/@datadog/native-appsec/vendor sync recursive ^\\.\\/.*\\/appsec\\.node$":
false,

/***/ "../../node_modules/@datadog/native-appsec/vendor/darwin-x64-unknown/appsec.node":
false,

/***/ "../../node_modules/@datadog/native-metrics/index.js":
false,

/***/ "../../node_modules/@datadog/pprof/node_modules/pify/index.js":
false,

/***/ "../../node_modules/@datadog/pprof/node_modules/source-map/lib/array-set.js":
false,

/***/ "../../node_modules/@datadog/pprof/node_modules/source-map/lib/base64-vlq.js":
false,

/***/ "../../node_modules/@datadog/pprof/node_modules/source-map/lib/base64.js":
false,

/***/ "../../node_modules/@datadog/pprof/node_modules/source-map/lib/binary-search.js":
false,

/***/ "../../node_modules/@datadog/pprof/node_modules/source-map/lib/mapping-list.js":
false,

/***/ "../../node_modules/@datadog/pprof/node_modules/source-map/lib/read-wasm.js":
false,

/***/ "../../node_modules/@datadog/pprof/node_modules/source-map/lib/source-map-consumer.js":
false,

/***/ "../../node_modules/@datadog/pprof/node_modules/source-map/lib/source-map-generator.js":
false,

/***/ "../../node_modules/@datadog/pprof/node_modules/source-map/lib/source-node.js":
false,

/***/ "../../node_modules/@datadog/pprof/node_modules/source-map/lib/util.js":
false,

/***/ "../../node_modules/@datadog/pprof/node_modules/source-map/lib/wasm.js":
false,

/***/ "../../node_modules/@datadog/pprof/node_modules/source-map/source-map.js":
false,

/***/ "../../node_modules/@datadog/pprof/out/src/heap-profiler-bindings.js":
false,

/***/ "../../node_modules/@datadog/pprof/out/src/heap-profiler.js":
false,

/***/ "../../node_modules/@datadog/pprof/out/src/index.js":
false,

/***/ "../../node_modules/@datadog/pprof/out/src/profile-encoder.js":
false,

/***/ "../../node_modules/@datadog/pprof/out/src/profile-serializer.js":
false,

/***/ "../../node_modules/@datadog/pprof/out/src/sourcemapper/sourcemapper.js":
false,

/***/ "../../node_modules/@datadog/pprof/out/src/time-profiler-bindings.js":
false,

/***/ "../../node_modules/@datadog/pprof/out/src/time-profiler.js":
false,

/***/ "../../node_modules/@datadog/pprof/out/third_party/cloud-debug-nodejs/src/agent/io/scanner.js":
false,

/***/ "../../node_modules/@datadog/pprof/proto/profile.js":
false,

/***/ "../../node_modules/@datadog/sketches-js/dist/ddsketch/DDSketch.js":
false,

/***/ "../../node_modules/@datadog/sketches-js/dist/ddsketch/index.js":
false,

/***/ "../../node_modules/@datadog/sketches-js/dist/ddsketch/mapping/CubicallyInterpolatedMapping.js":
false,

/***/ "../../node_modules/@datadog/sketches-js/dist/ddsketch/mapping/KeyMapping.js":
false,

/***/ "../../node_modules/@datadog/sketches-js/dist/ddsketch/mapping/LinearlyInterpolatedMapping.js":
false,

/***/ "../../node_modules/@datadog/sketches-js/dist/ddsketch/mapping/LogarithmicMapping.js":
false,

/***/ "../../node_modules/@datadog/sketches-js/dist/ddsketch/mapping/index.js":
false,

/***/ "../../node_modules/@datadog/sketches-js/dist/ddsketch/math.js":
false,

/***/ "../../node_modules/@datadog/sketches-js/dist/ddsketch/proto/compiled.js":
false,

/***/ "../../node_modules/@datadog/sketches-js/dist/ddsketch/store/CollapsingHighestDenseStore.js":
false,

/***/ "../../node_modules/@datadog/sketches-js/dist/ddsketch/store/CollapsingLowestDenseStore.js":
false,

/***/ "../../node_modules/@datadog/sketches-js/dist/ddsketch/store/DenseStore.js":
false,

/***/ "../../node_modules/@datadog/sketches-js/dist/ddsketch/store/index.js":
false,

/***/ "../../node_modules/@datadog/sketches-js/dist/ddsketch/store/util.js":
false,

/***/ "../../node_modules/@datadog/sketches-js/dist/index.js":
false,

/***/ "../../node_modules/atob/node-atob.js":
/*!*************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/atob/node-atob.js ***!
  \*************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function atob(str) {
  return Buffer.from(str, 'base64').toString('binary');
}

module.exports = atob.atob = atob;


/***/ }),

/***/ "../../node_modules/base64-js/index.js":
/*!**************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/base64-js/index.js ***!
  \**************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}


/***/ }),

/***/ "../../node_modules/container-info/index.js":
/*!*******************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/container-info/index.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const fs = __webpack_require__(/*! fs */ "fs")

const uuidSource = '[0-9a-f]{8}[-_][0-9a-f]{4}[-_][0-9a-f]{4}[-_][0-9a-f]{4}[-_][0-9a-f]{12}'
const containerSource = '[0-9a-f]{64}'
const taskSource = '[0-9a-f]{32}'

const lineReg = /^(\d+):([^:]*):(.+)$/
const podReg = new RegExp(`pod(${uuidSource})(?:.slice)?$`)
const containerReg = new RegExp(`(${uuidSource}|${containerSource})(?:.scope)?$`)
const taskReg = new RegExp(`^/ecs/(${taskSource})/.*$`)

const ecsMetadataFile = process.env.ECS_CONTAINER_METADATA_FILE
const ecsMetadata = ecsMetadataSync()

function parseLine (line) {
  const [ id, groups, path ] = (line.match(lineReg) || []).slice(1)
  const data = { id, groups, path }
  const parts = path.split('/')

  const controllers = groups.split(',')
  if (controllers) data.controllers = controllers

  const containerId = (parts.pop().match(containerReg) || [])[1]
  if (containerId) data.containerId = containerId

  const podId = (parts.pop().match(podReg) || [])[1]
  if (podId) data.podId = podId

  const taskId = (path.match(taskReg) || [])[1]
  if (taskId) data.taskId = taskId

  return data
}

function parse (contents) {
  const data = {
    entries: []
  }

  for (let line of contents.split('\n')) {
    line = line.trim()
    if (line) {
      const lineData = parseLine(line)
      data.entries.push(lineData)
      if (lineData.containerId) {
        data.containerId = lineData.containerId
      }
      if (lineData.podId) {
        data.podId = lineData.podId
      }
      if (lineData.taskId) {
        data.taskId = lineData.taskId
        if (ecsMetadata) {
          data.containerId = ecsMetadata.ContainerID
        }
      }
    }
  }

  return data
}

function containerInfo (pid = 'self') {
  return new Promise((resolve) => {
    fs.readFile(`/proc/${pid}/cgroup`, (err, data) => {
      resolve(err ? undefined : parse(data.toString()))
    })
  })
}

function containerInfoSync (pid = 'self') {
  try {
    const data = fs.readFileSync(`/proc/${pid}/cgroup`)
    return parse(data.toString())
  } catch (err) {}
}

function ecsMetadataSync () {
  try {
    return ecsMetadataFile && JSON.parse(fs.readFileSync(ecsMetadataFile))
  } catch (err) {}
}

module.exports = containerInfo
containerInfo.sync = containerInfoSync
containerInfo.parse = parse


/***/ }),

/***/ "../../node_modules/crypto-randomuuid/index.js":
false,

/***/ "../../node_modules/crypto-randomuuid/polyfill.js":
false,

/***/ "../../node_modules/crypto-randomuuid/validators.js":
false,

/***/ "../../node_modules/dd-trace/ext/exporters.js":
/*!*********************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/ext/exporters.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = {
  LOG: 'log',
  BROWSER: 'browser',
  AGENT: 'agent'
}


/***/ }),

/***/ "../../node_modules/dd-trace/ext/scopes.js":
/*!******************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/ext/scopes.js ***!
  \******************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = {
  ASYNC_RESOURCE: 'async_resource',
  ASYNC_LOCAL_STORAGE: 'async_local_storage',
  ASYNC_HOOKS: 'async_hooks',
  NOOP: 'noop'
}


/***/ }),

/***/ "../../node_modules/dd-trace/node_modules/find-up/index.js":
/*!**********************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/node_modules/find-up/index.js ***!
  \**********************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

const path = __webpack_require__(/*! path */ "path");
const locatePath = __webpack_require__(/*! locate-path */ "../../node_modules/dd-trace/node_modules/locate-path/index.js");

module.exports = (filename, opts) => {
	opts = opts || {};

	const startDir = path.resolve(opts.cwd || '');
	const root = path.parse(startDir).root;

	const filenames = [].concat(filename);

	return new Promise(resolve => {
		(function find(dir) {
			locatePath(filenames, {cwd: dir}).then(file => {
				if (file) {
					resolve(path.join(dir, file));
				} else if (dir === root) {
					resolve(null);
				} else {
					find(path.dirname(dir));
				}
			});
		})(startDir);
	});
};

module.exports.sync = (filename, opts) => {
	opts = opts || {};

	let dir = path.resolve(opts.cwd || '');
	const root = path.parse(dir).root;

	const filenames = [].concat(filename);

	// eslint-disable-next-line no-constant-condition
	while (true) {
		const file = locatePath.sync(filenames, {cwd: dir});

		if (file) {
			return path.join(dir, file);
		} else if (dir === root) {
			return null;
		}

		dir = path.dirname(dir);
	}
};


/***/ }),

/***/ "../../node_modules/dd-trace/node_modules/ignore/index.js":
false,

/***/ "../../node_modules/dd-trace/node_modules/locate-path/index.js":
/*!**************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/node_modules/locate-path/index.js ***!
  \**************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

const path = __webpack_require__(/*! path */ "path");
const pathExists = __webpack_require__(/*! path-exists */ "../../node_modules/dd-trace/node_modules/path-exists/index.js");
const pLocate = __webpack_require__(/*! p-locate */ "../../node_modules/dd-trace/node_modules/p-locate/index.js");

module.exports = (iterable, opts) => {
	opts = Object.assign({
		cwd: process.cwd()
	}, opts);

	return pLocate(iterable, el => pathExists(path.resolve(opts.cwd, el)), opts);
};

module.exports.sync = (iterable, opts) => {
	opts = Object.assign({
		cwd: process.cwd()
	}, opts);

	for (const el of iterable) {
		if (pathExists.sync(path.resolve(opts.cwd, el))) {
			return el;
		}
	}
};


/***/ }),

/***/ "../../node_modules/dd-trace/node_modules/p-limit/index.js":
/*!**********************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/node_modules/p-limit/index.js ***!
  \**********************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

const pTry = __webpack_require__(/*! p-try */ "../../node_modules/dd-trace/node_modules/p-try/index.js");

module.exports = concurrency => {
	if (concurrency < 1) {
		throw new TypeError('Expected `concurrency` to be a number from 1 and up');
	}

	const queue = [];
	let activeCount = 0;

	const next = () => {
		activeCount--;

		if (queue.length > 0) {
			queue.shift()();
		}
	};

	return fn => new Promise((resolve, reject) => {
		const run = () => {
			activeCount++;

			pTry(fn).then(
				val => {
					resolve(val);
					next();
				},
				err => {
					reject(err);
					next();
				}
			);
		};

		if (activeCount < concurrency) {
			run();
		} else {
			queue.push(run);
		}
	});
};


/***/ }),

/***/ "../../node_modules/dd-trace/node_modules/p-locate/index.js":
/*!***********************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/node_modules/p-locate/index.js ***!
  \***********************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

const pLimit = __webpack_require__(/*! p-limit */ "../../node_modules/dd-trace/node_modules/p-limit/index.js");

class EndError extends Error {
	constructor(value) {
		super();
		this.value = value;
	}
}

// the input can also be a promise, so we `Promise.all()` them both
const finder = el => Promise.all(el).then(val => val[1] === true && Promise.reject(new EndError(val[0])));

module.exports = (iterable, tester, opts) => {
	opts = Object.assign({
		concurrency: Infinity,
		preserveOrder: true
	}, opts);

	const limit = pLimit(opts.concurrency);

	// start all the promises concurrently with optional limit
	const items = Array.from(iterable).map(el => [el, limit(() => Promise.resolve(el).then(tester))]);

	// check the promises either serially or concurrently
	const checkLimit = pLimit(opts.preserveOrder ? 1 : Infinity);

	return Promise.all(items.map(el => checkLimit(() => finder(el))))
		.then(() => {})
		.catch(err => err instanceof EndError ? err.value : Promise.reject(err));
};


/***/ }),

/***/ "../../node_modules/dd-trace/node_modules/p-try/index.js":
/*!********************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/node_modules/p-try/index.js ***!
  \********************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = cb => new Promise(resolve => {
	resolve(cb());
});


/***/ }),

/***/ "../../node_modules/dd-trace/node_modules/path-exists/index.js":
/*!**************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/node_modules/path-exists/index.js ***!
  \**************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

const fs = __webpack_require__(/*! fs */ "fs");

module.exports = fp => new Promise(resolve => {
	fs.access(fp, err => {
		resolve(!err);
	});
});

module.exports.sync = fp => {
	try {
		fs.accessSync(fp);
		return true;
	} catch (err) {
		return false;
	}
};


/***/ }),

/***/ "../../node_modules/dd-trace/node_modules/path-type/index.js":
/*!************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/node_modules/path-type/index.js ***!
  \************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

const fs = __webpack_require__(/*! fs */ "fs");
const pify = __webpack_require__(/*! pify */ "../../node_modules/dd-trace/node_modules/pify/index.js");

function type(fn, fn2, fp) {
	if (typeof fp !== 'string') {
		return Promise.reject(new TypeError(`Expected a string, got ${typeof fp}`));
	}

	return pify(fs[fn])(fp)
		.then(stats => stats[fn2]())
		.catch(err => {
			if (err.code === 'ENOENT') {
				return false;
			}

			throw err;
		});
}

function typeSync(fn, fn2, fp) {
	if (typeof fp !== 'string') {
		throw new TypeError(`Expected a string, got ${typeof fp}`);
	}

	try {
		return fs[fn](fp)[fn2]();
	} catch (err) {
		if (err.code === 'ENOENT') {
			return false;
		}

		throw err;
	}
}

exports.file = type.bind(null, 'stat', 'isFile');
exports.dir = type.bind(null, 'stat', 'isDirectory');
exports.symlink = type.bind(null, 'lstat', 'isSymbolicLink');
exports.fileSync = typeSync.bind(null, 'statSync', 'isFile');
exports.dirSync = typeSync.bind(null, 'statSync', 'isDirectory');
exports.symlinkSync = typeSync.bind(null, 'lstatSync', 'isSymbolicLink');


/***/ }),

/***/ "../../node_modules/dd-trace/node_modules/pify/index.js":
/*!*******************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/node_modules/pify/index.js ***!
  \*******************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const processFn = (fn, opts) => function () {
	const P = opts.promiseModule;
	const args = new Array(arguments.length);

	for (let i = 0; i < arguments.length; i++) {
		args[i] = arguments[i];
	}

	return new P((resolve, reject) => {
		if (opts.errorFirst) {
			args.push(function (err, result) {
				if (opts.multiArgs) {
					const results = new Array(arguments.length - 1);

					for (let i = 1; i < arguments.length; i++) {
						results[i - 1] = arguments[i];
					}

					if (err) {
						results.unshift(err);
						reject(results);
					} else {
						resolve(results);
					}
				} else if (err) {
					reject(err);
				} else {
					resolve(result);
				}
			});
		} else {
			args.push(function (result) {
				if (opts.multiArgs) {
					const results = new Array(arguments.length - 1);

					for (let i = 0; i < arguments.length; i++) {
						results[i] = arguments[i];
					}

					resolve(results);
				} else {
					resolve(result);
				}
			});
		}

		fn.apply(this, args);
	});
};

module.exports = (obj, opts) => {
	opts = Object.assign({
		exclude: [/.+(Sync|Stream)$/],
		errorFirst: true,
		promiseModule: Promise
	}, opts);

	const filter = key => {
		const match = pattern => typeof pattern === 'string' ? key === pattern : pattern.test(key);
		return opts.include ? opts.include.some(match) : !opts.exclude.some(match);
	};

	let ret;
	if (typeof obj === 'function') {
		ret = function () {
			if (opts.excludeMain) {
				return obj.apply(this, arguments);
			}

			return processFn(obj, opts).apply(this, arguments);
		};
	} else {
		ret = Object.create(Object.getPrototypeOf(obj));
	}

	for (const key in obj) { // eslint-disable-line guard-for-in
		const x = obj[key];
		ret[key] = typeof x === 'function' && filter(key) ? processFn(x, opts) : x;
	}

	return ret;
};


/***/ }),

/***/ "../../node_modules/dd-trace/node_modules/read-pkg-up/index.js":
/*!**************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/node_modules/read-pkg-up/index.js ***!
  \**************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

const findUp = __webpack_require__(/*! find-up */ "../../node_modules/dd-trace/node_modules/find-up/index.js");
const readPkg = __webpack_require__(/*! read-pkg */ "../../node_modules/dd-trace/node_modules/read-pkg/index.js");

module.exports = opts => {
	return findUp('package.json', opts).then(fp => {
		if (!fp) {
			return {};
		}

		return readPkg(fp, opts).then(pkg => ({pkg, path: fp}));
	});
};

module.exports.sync = opts => {
	const fp = findUp.sync('package.json', opts);

	if (!fp) {
		return {};
	}

	return {
		pkg: readPkg.sync(fp, opts),
		path: fp
	};
};


/***/ }),

/***/ "../../node_modules/dd-trace/node_modules/read-pkg/index.js":
/*!***********************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/node_modules/read-pkg/index.js ***!
  \***********************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

const path = __webpack_require__(/*! path */ "path");
const loadJsonFile = __webpack_require__(/*! load-json-file */ "../../node_modules/load-json-file/index.js");
const pathType = __webpack_require__(/*! path-type */ "../../node_modules/dd-trace/node_modules/path-type/index.js");

module.exports = (fp, opts) => {
	if (typeof fp !== 'string') {
		opts = fp;
		fp = '.';
	}

	opts = opts || {};

	return pathType.dir(fp)
		.then(isDir => {
			if (isDir) {
				fp = path.join(fp, 'package.json');
			}

			return loadJsonFile(fp);
		})
		.then(x => {
			if (opts.normalize !== false) {
				__webpack_require__(/*! normalize-package-data */ "../../node_modules/normalize-package-data/lib/normalize.js")(x);
			}

			return x;
		});
};

module.exports.sync = (fp, opts) => {
	if (typeof fp !== 'string') {
		opts = fp;
		fp = '.';
	}

	opts = opts || {};
	fp = pathType.dirSync(fp) ? path.join(fp, 'package.json') : fp;

	const x = loadJsonFile.sync(fp);

	if (opts.normalize !== false) {
		__webpack_require__(/*! normalize-package-data */ "../../node_modules/normalize-package-data/lib/normalize.js")(x);
	}

	return x;
};


/***/ }),

/***/ "../../node_modules/dd-trace/node_modules/require-in-the-middle/index.js":
/*!************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/node_modules/require-in-the-middle/index.js ***!
  \************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var path = __webpack_require__(/*! path */ "path")
var Module = __webpack_require__(/*! module */ "module")
var resolve = __webpack_require__(/*! resolve */ "../../node_modules/resolve/index.js")
var parse = __webpack_require__(/*! module-details-from-path */ "../../node_modules/module-details-from-path/index.js")

var orig = Module.prototype.require

module.exports = function hook (modules, options, onrequire) {
  if (typeof modules === 'function') return hook(null, {}, modules)
  if (typeof options === 'function') return hook(modules, {}, options)

  if (typeof Module._resolveFilename !== 'function') {
    console.error('Error: Expected Module._resolveFilename to be a function (was: %s) - aborting!', typeof Module._resolveFilename)
    console.error('Please report this error as an issue related to Node.js %s at %s', process.version, __webpack_require__(/*! ./package.json */ "../../node_modules/dd-trace/node_modules/require-in-the-middle/package.json").bugs.url)
    return
  }

  options = options || {}

  hook.cache = {}

  var patching = {}

  Module.prototype.require = function (request) {
    var filename = Module._resolveFilename(request, this)
    var core = filename.indexOf(path.sep) === -1
    var name, basedir

    // return known patched modules immediately
    if (hook.cache.hasOwnProperty(filename)) {
      return hook.cache[filename]
    }

    // Check if this module has a patcher in-progress already.
    // Otherwise, mark this module as patching in-progress.
    var patched = patching[filename]
    if (!patched) {
      patching[filename] = true
    }

    var exports = orig.apply(this, arguments)

    // If it's already patched, just return it as-is.
    if (patched) return exports

    // The module has already been loaded,
    // so the patching mark can be cleaned up.
    delete patching[filename]

    if (core) {
      if (modules && modules.indexOf(filename) === -1) return exports // abort if module name isn't on whitelist
      name = filename
    } else {
      var stat = parse(filename)
      if (!stat) return exports // abort if filename could not be parsed
      name = stat.name
      basedir = stat.basedir

      if (modules && modules.indexOf(name) === -1) return exports // abort if module name isn't on whitelist

      // figure out if this is the main module file, or a file inside the module
      try {
        var res = resolve.sync(name, { basedir: basedir })
      } catch (e) {
        return exports // abort if module could not be resolved (e.g. no main in package.json and no index.js file)
      }
      if (res !== filename) {
        // this is a module-internal file
        if (options.internals) {
          // use the module-relative path to the file, prefixed by original module name
          name = name + path.sep + path.relative(basedir, filename)
        } else return exports // abort if not main module file
      }
    }

    // only call onrequire the first time a module is loaded
    if (!hook.cache.hasOwnProperty(filename)) {
      // ensure that the cache entry is assigned a value before calling
      // onrequire, in case calling onrequire requires the same module.
      hook.cache[filename] = exports
      hook.cache[filename] = onrequire(exports, name, basedir)
    }

    return hook.cache[filename]
  }
}


/***/ }),

/***/ "../../node_modules/dd-trace/node_modules/require-in-the-middle/package.json":
/*!****************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/node_modules/require-in-the-middle/package.json ***!
  \****************************************************************************************************************************/
/*! exports provided: name, version, description, main, dependencies, devDependencies, scripts, repository, keywords, author, license, bugs, homepage, coordinates, default */
/*! all exports used */
/***/ (function(module) {

module.exports = JSON.parse("{\"name\":\"require-in-the-middle\",\"version\":\"2.2.2\",\"description\":\"Module to hook into the Node.js require function\",\"main\":\"index.js\",\"dependencies\":{\"module-details-from-path\":\"^1.0.3\",\"resolve\":\"^1.5.0\"},\"devDependencies\":{\"ipp-printer\":\"^1.0.0\",\"patterns\":\"^1.0.3\",\"roundround\":\"^0.2.0\",\"standard\":\"^11.0.0\",\"tape\":\"^4.9.0\"},\"scripts\":{\"test\":\"standard && tape test/test.js\"},\"repository\":{\"type\":\"git\",\"url\":\"git+https://github.com/opbeat/require-in-the-middle.git\"},\"keywords\":[\"require\",\"hook\",\"shim\",\"shimmer\",\"shimming\",\"patch\",\"monkey\",\"monkeypatch\",\"module\",\"load\"],\"author\":\"Thomas Watson Steen <w@tson.dk> (https://twitter.com/wa7son)\",\"license\":\"MIT\",\"bugs\":{\"url\":\"https://github.com/opbeat/require-in-the-middle/issues\"},\"homepage\":\"https://github.com/opbeat/require-in-the-middle#readme\",\"coordinates\":[55.6779395,12.5715844]}");

/***/ }),

/***/ "../../node_modules/dd-trace/node_modules/retry/index.js":
false,

/***/ "../../node_modules/dd-trace/node_modules/retry/lib/retry.js":
false,

/***/ "../../node_modules/dd-trace/node_modules/retry/lib/retry_operation.js":
false,

/***/ "../../node_modules/dd-trace/node_modules/source-map/lib/array-set.js":
/*!*********************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/node_modules/source-map/lib/array-set.js ***!
  \*********************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports) {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

/**
 * A data structure which is a combination of an array and a set. Adding a new
 * member is O(1), testing for membership is O(1), and finding the index of an
 * element is O(1). Removing elements from the set is not supported. Only
 * strings are supported for membership.
 */
class ArraySet {
  constructor() {
    this._array = [];
    this._set = new Map();
  }

  /**
   * Static method for creating ArraySet instances from an existing array.
   */
  static fromArray(aArray, aAllowDuplicates) {
    const set = new ArraySet();
    for (let i = 0, len = aArray.length; i < len; i++) {
      set.add(aArray[i], aAllowDuplicates);
    }
    return set;
  }

  /**
   * Return how many unique items are in this ArraySet. If duplicates have been
   * added, than those do not count towards the size.
   *
   * @returns Number
   */
  size() {
    return this._set.size;
  }

  /**
   * Add the given string to this set.
   *
   * @param String aStr
   */
  add(aStr, aAllowDuplicates) {
    const isDuplicate = this.has(aStr);
    const idx = this._array.length;
    if (!isDuplicate || aAllowDuplicates) {
      this._array.push(aStr);
    }
    if (!isDuplicate) {
      this._set.set(aStr, idx);
    }
  }

  /**
   * Is the given string a member of this set?
   *
   * @param String aStr
   */
  has(aStr) {
      return this._set.has(aStr);
  }

  /**
   * What is the index of the given string in the array?
   *
   * @param String aStr
   */
  indexOf(aStr) {
    const idx = this._set.get(aStr);
    if (idx >= 0) {
        return idx;
    }
    throw new Error('"' + aStr + '" is not in the set.');
  }

  /**
   * What is the element at the given index?
   *
   * @param Number aIdx
   */
  at(aIdx) {
    if (aIdx >= 0 && aIdx < this._array.length) {
      return this._array[aIdx];
    }
    throw new Error("No element indexed by " + aIdx);
  }

  /**
   * Returns the array representation of this set (which has the proper indices
   * indicated by indexOf). Note that this is a copy of the internal array used
   * for storing the members so that no one can mess with internal state.
   */
  toArray() {
    return this._array.slice();
  }
}
exports.ArraySet = ArraySet;


/***/ }),

/***/ "../../node_modules/dd-trace/node_modules/source-map/lib/base64-vlq.js":
/*!**********************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/node_modules/source-map/lib/base64-vlq.js ***!
  \**********************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 *
 * Based on the Base 64 VLQ implementation in Closure Compiler:
 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
 *
 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *  * Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above
 *    copyright notice, this list of conditions and the following
 *    disclaimer in the documentation and/or other materials provided
 *    with the distribution.
 *  * Neither the name of Google Inc. nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

const base64 = __webpack_require__(/*! ./base64 */ "../../node_modules/dd-trace/node_modules/source-map/lib/base64.js");

// A single base 64 digit can contain 6 bits of data. For the base 64 variable
// length quantities we use in the source map spec, the first bit is the sign,
// the next four bits are the actual value, and the 6th bit is the
// continuation bit. The continuation bit tells us whether there are more
// digits in this value following this digit.
//
//   Continuation
//   |    Sign
//   |    |
//   V    V
//   101011

const VLQ_BASE_SHIFT = 5;

// binary: 100000
const VLQ_BASE = 1 << VLQ_BASE_SHIFT;

// binary: 011111
const VLQ_BASE_MASK = VLQ_BASE - 1;

// binary: 100000
const VLQ_CONTINUATION_BIT = VLQ_BASE;

/**
 * Converts from a two-complement value to a value where the sign bit is
 * placed in the least significant bit.  For example, as decimals:
 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
 */
function toVLQSigned(aValue) {
  return aValue < 0
    ? ((-aValue) << 1) + 1
    : (aValue << 1) + 0;
}

/**
 * Converts to a two-complement value from a value where the sign bit is
 * placed in the least significant bit.  For example, as decimals:
 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
 */
// eslint-disable-next-line no-unused-vars
function fromVLQSigned(aValue) {
  const isNegative = (aValue & 1) === 1;
  const shifted = aValue >> 1;
  return isNegative
    ? -shifted
    : shifted;
}

/**
 * Returns the base 64 VLQ encoded value.
 */
exports.encode = function base64VLQ_encode(aValue) {
  let encoded = "";
  let digit;

  let vlq = toVLQSigned(aValue);

  do {
    digit = vlq & VLQ_BASE_MASK;
    vlq >>>= VLQ_BASE_SHIFT;
    if (vlq > 0) {
      // There are still more digits in this value, so we must make sure the
      // continuation bit is marked.
      digit |= VLQ_CONTINUATION_BIT;
    }
    encoded += base64.encode(digit);
  } while (vlq > 0);

  return encoded;
};


/***/ }),

/***/ "../../node_modules/dd-trace/node_modules/source-map/lib/base64.js":
/*!******************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/node_modules/source-map/lib/base64.js ***!
  \******************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports) {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

const intToCharMap = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");

/**
 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
 */
exports.encode = function(number) {
  if (0 <= number && number < intToCharMap.length) {
    return intToCharMap[number];
  }
  throw new TypeError("Must be between 0 and 63: " + number);
};


/***/ }),

/***/ "../../node_modules/dd-trace/node_modules/source-map/lib/binary-search.js":
/*!*************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/node_modules/source-map/lib/binary-search.js ***!
  \*************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports) {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

exports.GREATEST_LOWER_BOUND = 1;
exports.LEAST_UPPER_BOUND = 2;

/**
 * Recursive implementation of binary search.
 *
 * @param aLow Indices here and lower do not contain the needle.
 * @param aHigh Indices here and higher do not contain the needle.
 * @param aNeedle The element being searched for.
 * @param aHaystack The non-empty array being searched.
 * @param aCompare Function which takes two elements and returns -1, 0, or 1.
 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 */
function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
  // This function terminates when one of the following is true:
  //
  //   1. We find the exact element we are looking for.
  //
  //   2. We did not find the exact element, but we can return the index of
  //      the next-closest element.
  //
  //   3. We did not find the exact element, and there is no next-closest
  //      element than the one we are searching for, so we return -1.
  const mid = Math.floor((aHigh - aLow) / 2) + aLow;
  const cmp = aCompare(aNeedle, aHaystack[mid], true);
  if (cmp === 0) {
    // Found the element we are looking for.
    return mid;
  } else if (cmp > 0) {
    // Our needle is greater than aHaystack[mid].
    if (aHigh - mid > 1) {
      // The element is in the upper half.
      return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
    }

    // The exact needle element was not found in this haystack. Determine if
    // we are in termination case (3) or (2) and return the appropriate thing.
    if (aBias == exports.LEAST_UPPER_BOUND) {
      return aHigh < aHaystack.length ? aHigh : -1;
    }
    return mid;
  }

  // Our needle is less than aHaystack[mid].
  if (mid - aLow > 1) {
    // The element is in the lower half.
    return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
  }

  // we are in termination case (3) or (2) and return the appropriate thing.
  if (aBias == exports.LEAST_UPPER_BOUND) {
    return mid;
  }
  return aLow < 0 ? -1 : aLow;
}

/**
 * This is an implementation of binary search which will always try and return
 * the index of the closest element if there is no exact hit. This is because
 * mappings between original and generated line/col pairs are single points,
 * and there is an implicit region between each of them, so a miss just means
 * that you aren't on the very start of a region.
 *
 * @param aNeedle The element you are looking for.
 * @param aHaystack The array that is being searched.
 * @param aCompare A function which takes the needle and an element in the
 *     array and returns -1, 0, or 1 depending on whether the needle is less
 *     than, equal to, or greater than the element, respectively.
 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.
 */
exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
  if (aHaystack.length === 0) {
    return -1;
  }

  let index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack,
                              aCompare, aBias || exports.GREATEST_LOWER_BOUND);
  if (index < 0) {
    return -1;
  }

  // We have found either the exact element, or the next-closest element than
  // the one we are searching for. However, there may be more than one such
  // element. Make sure we always return the smallest of these.
  while (index - 1 >= 0) {
    if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
      break;
    }
    --index;
  }

  return index;
};


/***/ }),

/***/ "../../node_modules/dd-trace/node_modules/source-map/lib/mapping-list.js":
/*!************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/node_modules/source-map/lib/mapping-list.js ***!
  \************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2014 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

const util = __webpack_require__(/*! ./util */ "../../node_modules/dd-trace/node_modules/source-map/lib/util.js");

/**
 * Determine whether mappingB is after mappingA with respect to generated
 * position.
 */
function generatedPositionAfter(mappingA, mappingB) {
  // Optimized for most common case
  const lineA = mappingA.generatedLine;
  const lineB = mappingB.generatedLine;
  const columnA = mappingA.generatedColumn;
  const columnB = mappingB.generatedColumn;
  return lineB > lineA || lineB == lineA && columnB >= columnA ||
         util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
}

/**
 * A data structure to provide a sorted view of accumulated mappings in a
 * performance conscious manner. It trades a negligible overhead in general
 * case for a large speedup in case of mappings being added in order.
 */
class MappingList {
  constructor() {
    this._array = [];
    this._sorted = true;
    // Serves as infimum
    this._last = {generatedLine: -1, generatedColumn: 0};
  }

  /**
   * Iterate through internal items. This method takes the same arguments that
   * `Array.prototype.forEach` takes.
   *
   * NOTE: The order of the mappings is NOT guaranteed.
   */
  unsortedForEach(aCallback, aThisArg) {
    this._array.forEach(aCallback, aThisArg);
  }

  /**
   * Add the given source mapping.
   *
   * @param Object aMapping
   */
  add(aMapping) {
    if (generatedPositionAfter(this._last, aMapping)) {
      this._last = aMapping;
      this._array.push(aMapping);
    } else {
      this._sorted = false;
      this._array.push(aMapping);
    }
  }

  /**
   * Returns the flat, sorted array of mappings. The mappings are sorted by
   * generated position.
   *
   * WARNING: This method returns internal data without copying, for
   * performance. The return value must NOT be mutated, and should be treated as
   * an immutable borrow. If you want to take ownership, you must make your own
   * copy.
   */
  toArray() {
    if (!this._sorted) {
      this._array.sort(util.compareByGeneratedPositionsInflated);
      this._sorted = true;
    }
    return this._array;
  }
}

exports.MappingList = MappingList;


/***/ }),

/***/ "../../node_modules/dd-trace/node_modules/source-map/lib/read-wasm.js":
/*!*********************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/node_modules/source-map/lib/read-wasm.js ***!
  \*********************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

if (typeof fetch === "function") {
  // Web version of reading a wasm file into an array buffer.

  let mappingsWasmUrl = null;

  module.exports = function readWasm() {
    if (typeof mappingsWasmUrl !== "string") {
      throw new Error("You must provide the URL of lib/mappings.wasm by calling " +
                      "SourceMapConsumer.initialize({ 'lib/mappings.wasm': ... }) " +
                      "before using SourceMapConsumer");
    }

    return fetch(mappingsWasmUrl)
      .then(response => response.arrayBuffer());
  };

  module.exports.initialize = url => mappingsWasmUrl = url;
} else {
  // Node version of reading a wasm file into an array buffer.
  const fs = __webpack_require__(/*! fs */ "fs");
  const path = __webpack_require__(/*! path */ "path");

  module.exports = function readWasm() {
    return new Promise((resolve, reject) => {
      const wasmPath = path.join(__dirname, "mappings.wasm");
      fs.readFile(wasmPath, null, (error, data) => {
        if (error) {
          reject(error);
          return;
        }

        resolve(data.buffer);
      });
    });
  };

  module.exports.initialize = _ => {
    console.debug("SourceMapConsumer.initialize is a no-op when running in node.js");
  };
}


/***/ }),

/***/ "../../node_modules/dd-trace/node_modules/source-map/lib/source-map-consumer.js":
/*!*******************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/node_modules/source-map/lib/source-map-consumer.js ***!
  \*******************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

const util = __webpack_require__(/*! ./util */ "../../node_modules/dd-trace/node_modules/source-map/lib/util.js");
const binarySearch = __webpack_require__(/*! ./binary-search */ "../../node_modules/dd-trace/node_modules/source-map/lib/binary-search.js");
const ArraySet = __webpack_require__(/*! ./array-set */ "../../node_modules/dd-trace/node_modules/source-map/lib/array-set.js").ArraySet;
const base64VLQ = __webpack_require__(/*! ./base64-vlq */ "../../node_modules/dd-trace/node_modules/source-map/lib/base64-vlq.js"); // eslint-disable-line no-unused-vars
const readWasm = __webpack_require__(/*! ../lib/read-wasm */ "../../node_modules/dd-trace/node_modules/source-map/lib/read-wasm.js");
const wasm = __webpack_require__(/*! ./wasm */ "../../node_modules/dd-trace/node_modules/source-map/lib/wasm.js");

const INTERNAL = Symbol("smcInternal");

class SourceMapConsumer {
  constructor(aSourceMap, aSourceMapURL) {
    // If the constructor was called by super(), just return Promise<this>.
    // Yes, this is a hack to retain the pre-existing API of the base-class
    // constructor also being an async factory function.
    if (aSourceMap == INTERNAL) {
      return Promise.resolve(this);
    }

    return _factory(aSourceMap, aSourceMapURL);
  }

  static initialize(opts) {
    readWasm.initialize(opts["lib/mappings.wasm"]);
  }

  static fromSourceMap(aSourceMap, aSourceMapURL) {
    return _factoryBSM(aSourceMap, aSourceMapURL);
  }

  /**
   * Construct a new `SourceMapConsumer` from `rawSourceMap` and `sourceMapUrl`
   * (see the `SourceMapConsumer` constructor for details. Then, invoke the `async
   * function f(SourceMapConsumer) -> T` with the newly constructed consumer, wait
   * for `f` to complete, call `destroy` on the consumer, and return `f`'s return
   * value.
   *
   * You must not use the consumer after `f` completes!
   *
   * By using `with`, you do not have to remember to manually call `destroy` on
   * the consumer, since it will be called automatically once `f` completes.
   *
   * ```js
   * const xSquared = await SourceMapConsumer.with(
   *   myRawSourceMap,
   *   null,
   *   async function (consumer) {
   *     // Use `consumer` inside here and don't worry about remembering
   *     // to call `destroy`.
   *
   *     const x = await whatever(consumer);
   *     return x * x;
   *   }
   * );
   *
   * // You may not use that `consumer` anymore out here; it has
   * // been destroyed. But you can use `xSquared`.
   * console.log(xSquared);
   * ```
   */
  static with(rawSourceMap, sourceMapUrl, f) {
    // Note: The `acorn` version that `webpack` currently depends on doesn't
    // support `async` functions, and the nodes that we support don't all have
    // `.finally`. Therefore, this is written a bit more convolutedly than it
    // should really be.

    let consumer = null;
    const promise = new SourceMapConsumer(rawSourceMap, sourceMapUrl);
    return promise
      .then(c => {
        consumer = c;
        return f(c);
      })
      .then(x => {
        if (consumer) {
          consumer.destroy();
        }
        return x;
      }, e => {
        if (consumer) {
          consumer.destroy();
        }
        throw e;
      });
  }

  /**
   * Parse the mappings in a string in to a data structure which we can easily
   * query (the ordered arrays in the `this.__generatedMappings` and
   * `this.__originalMappings` properties).
   */
  _parseMappings(aStr, aSourceRoot) {
    throw new Error("Subclasses must implement _parseMappings");
  }

  /**
   * Iterate over each mapping between an original source/line/column and a
   * generated line/column in this source map.
   *
   * @param Function aCallback
   *        The function that is called with each mapping.
   * @param Object aContext
   *        Optional. If specified, this object will be the value of `this` every
   *        time that `aCallback` is called.
   * @param aOrder
   *        Either `SourceMapConsumer.GENERATED_ORDER` or
   *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
   *        iterate over the mappings sorted by the generated file's line/column
   *        order or the original's source/line/column order, respectively. Defaults to
   *        `SourceMapConsumer.GENERATED_ORDER`.
   */
  eachMapping(aCallback, aContext, aOrder) {
    throw new Error("Subclasses must implement eachMapping");
  }

  /**
   * Returns all generated line and column information for the original source,
   * line, and column provided. If no column is provided, returns all mappings
   * corresponding to a either the line we are searching for or the next
   * closest line that has any mappings. Otherwise, returns all mappings
   * corresponding to the given line and either the column we are searching for
   * or the next closest column that has any offsets.
   *
   * The only argument is an object with the following properties:
   *
   *   - source: The filename of the original source.
   *   - line: The line number in the original source.  The line number is 1-based.
   *   - column: Optional. the column number in the original source.
   *    The column number is 0-based.
   *
   * and an array of objects is returned, each with the following properties:
   *
   *   - line: The line number in the generated source, or null.  The
   *    line number is 1-based.
   *   - column: The column number in the generated source, or null.
   *    The column number is 0-based.
   */
  allGeneratedPositionsFor(aArgs) {
    throw new Error("Subclasses must implement allGeneratedPositionsFor");
  }

  destroy() {
    throw new Error("Subclasses must implement destroy");
  }
}

/**
 * The version of the source mapping spec that we are consuming.
 */
SourceMapConsumer.prototype._version = 3;
SourceMapConsumer.GENERATED_ORDER = 1;
SourceMapConsumer.ORIGINAL_ORDER = 2;

SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
SourceMapConsumer.LEAST_UPPER_BOUND = 2;

exports.SourceMapConsumer = SourceMapConsumer;

/**
 * A BasicSourceMapConsumer instance represents a parsed source map which we can
 * query for information about the original file positions by giving it a file
 * position in the generated source.
 *
 * The first parameter is the raw source map (either as a JSON string, or
 * already parsed to an object). According to the spec, source maps have the
 * following attributes:
 *
 *   - version: Which version of the source map spec this map is following.
 *   - sources: An array of URLs to the original source files.
 *   - names: An array of identifiers which can be referenced by individual mappings.
 *   - sourceRoot: Optional. The URL root from which all sources are relative.
 *   - sourcesContent: Optional. An array of contents of the original source files.
 *   - mappings: A string of base64 VLQs which contain the actual mappings.
 *   - file: Optional. The generated file this source map is associated with.
 *
 * Here is an example source map, taken from the source map spec[0]:
 *
 *     {
 *       version : 3,
 *       file: "out.js",
 *       sourceRoot : "",
 *       sources: ["foo.js", "bar.js"],
 *       names: ["src", "maps", "are", "fun"],
 *       mappings: "AA,AB;;ABCDE;"
 *     }
 *
 * The second parameter, if given, is a string whose value is the URL
 * at which the source map was found.  This URL is used to compute the
 * sources array.
 *
 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#
 */
class BasicSourceMapConsumer extends SourceMapConsumer {
  constructor(aSourceMap, aSourceMapURL) {
    return super(INTERNAL).then(that => {
      let sourceMap = aSourceMap;
      if (typeof aSourceMap === "string") {
        sourceMap = util.parseSourceMapInput(aSourceMap);
      }

      const version = util.getArg(sourceMap, "version");
      let sources = util.getArg(sourceMap, "sources");
      // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which
      // requires the array) to play nice here.
      const names = util.getArg(sourceMap, "names", []);
      let sourceRoot = util.getArg(sourceMap, "sourceRoot", null);
      const sourcesContent = util.getArg(sourceMap, "sourcesContent", null);
      const mappings = util.getArg(sourceMap, "mappings");
      const file = util.getArg(sourceMap, "file", null);

      // Once again, Sass deviates from the spec and supplies the version as a
      // string rather than a number, so we use loose equality checking here.
      if (version != that._version) {
        throw new Error("Unsupported version: " + version);
      }

      if (sourceRoot) {
        sourceRoot = util.normalize(sourceRoot);
      }

      sources = sources
        .map(String)
        // Some source maps produce relative source paths like "./foo.js" instead of
        // "foo.js".  Normalize these first so that future comparisons will succeed.
        // See bugzil.la/1090768.
        .map(util.normalize)
        // Always ensure that absolute sources are internally stored relative to
        // the source root, if the source root is absolute. Not doing this would
        // be particularly problematic when the source root is a prefix of the
        // source (valid, but why??). See github issue #199 and bugzil.la/1188982.
        .map(function(source) {
          return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source)
            ? util.relative(sourceRoot, source)
            : source;
        });

      // Pass `true` below to allow duplicate names and sources. While source maps
      // are intended to be compressed and deduplicated, the TypeScript compiler
      // sometimes generates source maps with duplicates in them. See Github issue
      // #72 and bugzil.la/889492.
      that._names = ArraySet.fromArray(names.map(String), true);
      that._sources = ArraySet.fromArray(sources, true);

      that._absoluteSources = that._sources.toArray().map(function(s) {
        return util.computeSourceURL(sourceRoot, s, aSourceMapURL);
      });

      that.sourceRoot = sourceRoot;
      that.sourcesContent = sourcesContent;
      that._mappings = mappings;
      that._sourceMapURL = aSourceMapURL;
      that.file = file;

      that._computedColumnSpans = false;
      that._mappingsPtr = 0;
      that._wasm = null;

      return wasm().then(w => {
        that._wasm = w;
        return that;
      });
    });
  }

  /**
   * Utility function to find the index of a source.  Returns -1 if not
   * found.
   */
  _findSourceIndex(aSource) {
    let relativeSource = aSource;
    if (this.sourceRoot != null) {
      relativeSource = util.relative(this.sourceRoot, relativeSource);
    }

    if (this._sources.has(relativeSource)) {
      return this._sources.indexOf(relativeSource);
    }

    // Maybe aSource is an absolute URL as returned by |sources|.  In
    // this case we can't simply undo the transform.
    for (let i = 0; i < this._absoluteSources.length; ++i) {
      if (this._absoluteSources[i] == aSource) {
        return i;
      }
    }

    return -1;
  }

  /**
   * Create a BasicSourceMapConsumer from a SourceMapGenerator.
   *
   * @param SourceMapGenerator aSourceMap
   *        The source map that will be consumed.
   * @param String aSourceMapURL
   *        The URL at which the source map can be found (optional)
   * @returns BasicSourceMapConsumer
   */
  static fromSourceMap(aSourceMap, aSourceMapURL) {
    return new BasicSourceMapConsumer(aSourceMap.toString());
  }

  get sources() {
    return this._absoluteSources.slice();
  }

  _getMappingsPtr() {
    if (this._mappingsPtr === 0) {
      this._parseMappings(this._mappings, this.sourceRoot);
    }

    return this._mappingsPtr;
  }

  /**
   * Parse the mappings in a string in to a data structure which we can easily
   * query (the ordered arrays in the `this.__generatedMappings` and
   * `this.__originalMappings` properties).
   */
  _parseMappings(aStr, aSourceRoot) {
    const size = aStr.length;

    const mappingsBufPtr = this._wasm.exports.allocate_mappings(size);
    const mappingsBuf = new Uint8Array(this._wasm.exports.memory.buffer, mappingsBufPtr, size);
    for (let i = 0; i < size; i++) {
      mappingsBuf[i] = aStr.charCodeAt(i);
    }

    const mappingsPtr = this._wasm.exports.parse_mappings(mappingsBufPtr);

    if (!mappingsPtr) {
      const error = this._wasm.exports.get_last_error();
      let msg = `Error parsing mappings (code ${error}): `;

      // XXX: keep these error codes in sync with `fitzgen/source-map-mappings`.
      switch (error) {
        case 1:
          msg += "the mappings contained a negative line, column, source index, or name index";
          break;
        case 2:
          msg += "the mappings contained a number larger than 2**32";
          break;
        case 3:
          msg += "reached EOF while in the middle of parsing a VLQ";
          break;
        case 4:
          msg += "invalid base 64 character while parsing a VLQ";
          break;
        default:
          msg += "unknown error code";
          break;
      }

      throw new Error(msg);
    }

    this._mappingsPtr = mappingsPtr;
  }

  eachMapping(aCallback, aContext, aOrder) {
    const context = aContext || null;
    const order = aOrder || SourceMapConsumer.GENERATED_ORDER;
    const sourceRoot = this.sourceRoot;

    this._wasm.withMappingCallback(
      mapping => {
        if (mapping.source !== null) {
          mapping.source = this._sources.at(mapping.source);
          mapping.source = util.computeSourceURL(sourceRoot, mapping.source, this._sourceMapURL);

          if (mapping.name !== null) {
            mapping.name = this._names.at(mapping.name);
          }
        }

        aCallback.call(context, mapping);
      },
      () => {
        switch (order) {
        case SourceMapConsumer.GENERATED_ORDER:
          this._wasm.exports.by_generated_location(this._getMappingsPtr());
          break;
        case SourceMapConsumer.ORIGINAL_ORDER:
          this._wasm.exports.by_original_location(this._getMappingsPtr());
          break;
        default:
          throw new Error("Unknown order of iteration.");
        }
      }
    );
  }

  allGeneratedPositionsFor(aArgs) {
    let source = util.getArg(aArgs, "source");
    const originalLine = util.getArg(aArgs, "line");
    const originalColumn = aArgs.column || 0;

    source = this._findSourceIndex(source);
    if (source < 0) {
      return [];
    }

    if (originalLine < 1) {
      throw new Error("Line numbers must be >= 1");
    }

    if (originalColumn < 0) {
      throw new Error("Column numbers must be >= 0");
    }

    const mappings = [];

    this._wasm.withMappingCallback(
      m => {
        let lastColumn = m.lastGeneratedColumn;
        if (this._computedColumnSpans && lastColumn === null) {
          lastColumn = Infinity;
        }
        mappings.push({
          line: m.generatedLine,
          column: m.generatedColumn,
          lastColumn,
        });
      }, () => {
        this._wasm.exports.all_generated_locations_for(
          this._getMappingsPtr(),
          source,
          originalLine - 1,
          "column" in aArgs,
          originalColumn
        );
      }
    );

    return mappings;
  }

  destroy() {
    if (this._mappingsPtr !== 0) {
      this._wasm.exports.free_mappings(this._mappingsPtr);
      this._mappingsPtr = 0;
    }
  }

  /**
   * Compute the last column for each generated mapping. The last column is
   * inclusive.
   */
  computeColumnSpans() {
    if (this._computedColumnSpans) {
      return;
    }

    this._wasm.exports.compute_column_spans(this._getMappingsPtr());
    this._computedColumnSpans = true;
  }

  /**
   * Returns the original source, line, and column information for the generated
   * source's line and column positions provided. The only argument is an object
   * with the following properties:
   *
   *   - line: The line number in the generated source.  The line number
   *     is 1-based.
   *   - column: The column number in the generated source.  The column
   *     number is 0-based.
   *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
   *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
   *     closest element that is smaller than or greater than the one we are
   *     searching for, respectively, if the exact element cannot be found.
   *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
   *
   * and an object is returned with the following properties:
   *
   *   - source: The original source file, or null.
   *   - line: The line number in the original source, or null.  The
   *     line number is 1-based.
   *   - column: The column number in the original source, or null.  The
   *     column number is 0-based.
   *   - name: The original identifier, or null.
   */
  originalPositionFor(aArgs) {
    const needle = {
      generatedLine: util.getArg(aArgs, "line"),
      generatedColumn: util.getArg(aArgs, "column")
    };

    if (needle.generatedLine < 1) {
      throw new Error("Line numbers must be >= 1");
    }

    if (needle.generatedColumn < 0) {
      throw new Error("Column numbers must be >= 0");
    }

    let bias = util.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND);
    if (bias == null) {
      bias = SourceMapConsumer.GREATEST_LOWER_BOUND;
    }

    let mapping;
    this._wasm.withMappingCallback(m => mapping = m, () => {
      this._wasm.exports.original_location_for(
        this._getMappingsPtr(),
        needle.generatedLine - 1,
        needle.generatedColumn,
        bias
      );
    });

    if (mapping) {
      if (mapping.generatedLine === needle.generatedLine) {
        let source = util.getArg(mapping, "source", null);
        if (source !== null) {
          source = this._sources.at(source);
          source = util.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);
        }

        let name = util.getArg(mapping, "name", null);
        if (name !== null) {
          name = this._names.at(name);
        }

        return {
          source,
          line: util.getArg(mapping, "originalLine", null),
          column: util.getArg(mapping, "originalColumn", null),
          name
        };
      }
    }

    return {
      source: null,
      line: null,
      column: null,
      name: null
    };
  }

  /**
   * Return true if we have the source content for every source in the source
   * map, false otherwise.
   */
  hasContentsOfAllSources() {
    if (!this.sourcesContent) {
      return false;
    }
    return this.sourcesContent.length >= this._sources.size() &&
      !this.sourcesContent.some(function(sc) { return sc == null; });
  }

  /**
   * Returns the original source content. The only argument is the url of the
   * original source file. Returns null if no original source content is
   * available.
   */
  sourceContentFor(aSource, nullOnMissing) {
    if (!this.sourcesContent) {
      return null;
    }

    const index = this._findSourceIndex(aSource);
    if (index >= 0) {
      return this.sourcesContent[index];
    }

    let relativeSource = aSource;
    if (this.sourceRoot != null) {
      relativeSource = util.relative(this.sourceRoot, relativeSource);
    }

    let url;
    if (this.sourceRoot != null
        && (url = util.urlParse(this.sourceRoot))) {
      // XXX: file:// URIs and absolute paths lead to unexpected behavior for
      // many users. We can help them out when they expect file:// URIs to
      // behave like it would if they were running a local HTTP server. See
      // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.
      const fileUriAbsPath = relativeSource.replace(/^file:\/\//, "");
      if (url.scheme == "file"
          && this._sources.has(fileUriAbsPath)) {
        return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];
      }

      if ((!url.path || url.path == "/")
          && this._sources.has("/" + relativeSource)) {
        return this.sourcesContent[this._sources.indexOf("/" + relativeSource)];
      }
    }

    // This function is used recursively from
    // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we
    // don't want to throw if we can't find the source - we just want to
    // return null, so we provide a flag to exit gracefully.
    if (nullOnMissing) {
      return null;
    }

    throw new Error('"' + relativeSource + '" is not in the SourceMap.');
  }

  /**
   * Returns the generated line and column information for the original source,
   * line, and column positions provided. The only argument is an object with
   * the following properties:
   *
   *   - source: The filename of the original source.
   *   - line: The line number in the original source.  The line number
   *     is 1-based.
   *   - column: The column number in the original source.  The column
   *     number is 0-based.
   *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
   *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
   *     closest element that is smaller than or greater than the one we are
   *     searching for, respectively, if the exact element cannot be found.
   *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
   *
   * and an object is returned with the following properties:
   *
   *   - line: The line number in the generated source, or null.  The
   *     line number is 1-based.
   *   - column: The column number in the generated source, or null.
   *     The column number is 0-based.
   */
  generatedPositionFor(aArgs) {
    let source = util.getArg(aArgs, "source");
    source = this._findSourceIndex(source);
    if (source < 0) {
      return {
        line: null,
        column: null,
        lastColumn: null
      };
    }

    const needle = {
      source,
      originalLine: util.getArg(aArgs, "line"),
      originalColumn: util.getArg(aArgs, "column")
    };

    if (needle.originalLine < 1) {
      throw new Error("Line numbers must be >= 1");
    }

    if (needle.originalColumn < 0) {
      throw new Error("Column numbers must be >= 0");
    }

    let bias = util.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND);
    if (bias == null) {
      bias = SourceMapConsumer.GREATEST_LOWER_BOUND;
    }

    let mapping;
    this._wasm.withMappingCallback(m => mapping = m, () => {
      this._wasm.exports.generated_location_for(
        this._getMappingsPtr(),
        needle.source,
        needle.originalLine - 1,
        needle.originalColumn,
        bias
      );
    });

    if (mapping) {
      if (mapping.source === needle.source) {
        let lastColumn = mapping.lastGeneratedColumn;
        if (this._computedColumnSpans && lastColumn === null) {
          lastColumn = Infinity;
        }
        return {
          line: util.getArg(mapping, "generatedLine", null),
          column: util.getArg(mapping, "generatedColumn", null),
          lastColumn,
        };
      }
    }

    return {
      line: null,
      column: null,
      lastColumn: null
    };
  }
}

BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;
exports.BasicSourceMapConsumer = BasicSourceMapConsumer;

/**
 * An IndexedSourceMapConsumer instance represents a parsed source map which
 * we can query for information. It differs from BasicSourceMapConsumer in
 * that it takes "indexed" source maps (i.e. ones with a "sections" field) as
 * input.
 *
 * The first parameter is a raw source map (either as a JSON string, or already
 * parsed to an object). According to the spec for indexed source maps, they
 * have the following attributes:
 *
 *   - version: Which version of the source map spec this map is following.
 *   - file: Optional. The generated file this source map is associated with.
 *   - sections: A list of section definitions.
 *
 * Each value under the "sections" field has two fields:
 *   - offset: The offset into the original specified at which this section
 *       begins to apply, defined as an object with a "line" and "column"
 *       field.
 *   - map: A source map definition. This source map could also be indexed,
 *       but doesn't have to be.
 *
 * Instead of the "map" field, it's also possible to have a "url" field
 * specifying a URL to retrieve a source map from, but that's currently
 * unsupported.
 *
 * Here's an example source map, taken from the source map spec[0], but
 * modified to omit a section which uses the "url" field.
 *
 *  {
 *    version : 3,
 *    file: "app.js",
 *    sections: [{
 *      offset: {line:100, column:10},
 *      map: {
 *        version : 3,
 *        file: "section.js",
 *        sources: ["foo.js", "bar.js"],
 *        names: ["src", "maps", "are", "fun"],
 *        mappings: "AAAA,E;;ABCDE;"
 *      }
 *    }],
 *  }
 *
 * The second parameter, if given, is a string whose value is the URL
 * at which the source map was found.  This URL is used to compute the
 * sources array.
 *
 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt
 */
class IndexedSourceMapConsumer extends SourceMapConsumer {
  constructor(aSourceMap, aSourceMapURL) {
    return super(INTERNAL).then(that => {
      let sourceMap = aSourceMap;
      if (typeof aSourceMap === "string") {
        sourceMap = util.parseSourceMapInput(aSourceMap);
      }

      const version = util.getArg(sourceMap, "version");
      const sections = util.getArg(sourceMap, "sections");

      if (version != that._version) {
        throw new Error("Unsupported version: " + version);
      }

      that._sources = new ArraySet();
      that._names = new ArraySet();
      that.__generatedMappings = null;
      that.__originalMappings = null;
      that.__generatedMappingsUnsorted = null;
      that.__originalMappingsUnsorted = null;

      let lastOffset = {
        line: -1,
        column: 0
      };
      return Promise.all(sections.map(s => {
        if (s.url) {
          // The url field will require support for asynchronicity.
          // See https://github.com/mozilla/source-map/issues/16
          throw new Error("Support for url field in sections not implemented.");
        }
        const offset = util.getArg(s, "offset");
        const offsetLine = util.getArg(offset, "line");
        const offsetColumn = util.getArg(offset, "column");

        if (offsetLine < lastOffset.line ||
            (offsetLine === lastOffset.line && offsetColumn < lastOffset.column)) {
          throw new Error("Section offsets must be ordered and non-overlapping.");
        }
        lastOffset = offset;

        const cons = new SourceMapConsumer(util.getArg(s, "map"), aSourceMapURL);
        return cons.then(consumer => {
          return {
            generatedOffset: {
              // The offset fields are 0-based, but we use 1-based indices when
              // encoding/decoding from VLQ.
              generatedLine: offsetLine + 1,
              generatedColumn: offsetColumn + 1
            },
            consumer
          };
        });
      })).then(s => {
        that._sections = s;
        return that;
      });
    });
  }

  // `__generatedMappings` and `__originalMappings` are arrays that hold the
  // parsed mapping coordinates from the source map's "mappings" attribute. They
  // are lazily instantiated, accessed via the `_generatedMappings` and
  // `_originalMappings` getters respectively, and we only parse the mappings
  // and create these arrays once queried for a source location. We jump through
  // these hoops because there can be many thousands of mappings, and parsing
  // them is expensive, so we only want to do it if we must.
  //
  // Each object in the arrays is of the form:
  //
  //     {
  //       generatedLine: The line number in the generated code,
  //       generatedColumn: The column number in the generated code,
  //       source: The path to the original source file that generated this
  //               chunk of code,
  //       originalLine: The line number in the original source that
  //                     corresponds to this chunk of generated code,
  //       originalColumn: The column number in the original source that
  //                       corresponds to this chunk of generated code,
  //       name: The name of the original symbol which generated this chunk of
  //             code.
  //     }
  //
  // All properties except for `generatedLine` and `generatedColumn` can be
  // `null`.
  //
  // `_generatedMappings` is ordered by the generated positions.
  //
  // `_originalMappings` is ordered by the original positions.
  get _generatedMappings() {
    if (!this.__generatedMappings) {
      this._sortGeneratedMappings();
    }

    return this.__generatedMappings;
  }

  get _originalMappings() {
    if (!this.__originalMappings) {
      this._sortOriginalMappings();
    }

    return this.__originalMappings;
  }

  get _generatedMappingsUnsorted() {
    if (!this.__generatedMappingsUnsorted) {
      this._parseMappings(this._mappings, this.sourceRoot);
    }

    return this.__generatedMappingsUnsorted;
  }

  get _originalMappingsUnsorted() {
    if (!this.__originalMappingsUnsorted) {
      this._parseMappings(this._mappings, this.sourceRoot);
    }

    return this.__originalMappingsUnsorted;
  }

  _sortGeneratedMappings() {
    const mappings = this._generatedMappingsUnsorted;
    mappings.sort(util.compareByGeneratedPositionsDeflated);
    this.__generatedMappings = mappings;
  }

  _sortOriginalMappings() {
    const mappings = this._originalMappingsUnsorted;
    mappings.sort(util.compareByOriginalPositions);
    this.__originalMappings = mappings;
  }

  /**
   * The list of original sources.
   */
  get sources() {
    const sources = [];
    for (let i = 0; i < this._sections.length; i++) {
      for (let j = 0; j < this._sections[i].consumer.sources.length; j++) {
        sources.push(this._sections[i].consumer.sources[j]);
      }
    }
    return sources;
  }

  /**
   * Returns the original source, line, and column information for the generated
   * source's line and column positions provided. The only argument is an object
   * with the following properties:
   *
   *   - line: The line number in the generated source.  The line number
   *     is 1-based.
   *   - column: The column number in the generated source.  The column
   *     number is 0-based.
   *
   * and an object is returned with the following properties:
   *
   *   - source: The original source file, or null.
   *   - line: The line number in the original source, or null.  The
   *     line number is 1-based.
   *   - column: The column number in the original source, or null.  The
   *     column number is 0-based.
   *   - name: The original identifier, or null.
   */
  originalPositionFor(aArgs) {
    const needle = {
      generatedLine: util.getArg(aArgs, "line"),
      generatedColumn: util.getArg(aArgs, "column")
    };

    // Find the section containing the generated position we're trying to map
    // to an original position.
    const sectionIndex = binarySearch.search(needle, this._sections,
      function(aNeedle, section) {
        const cmp = aNeedle.generatedLine - section.generatedOffset.generatedLine;
        if (cmp) {
          return cmp;
        }

        return (aNeedle.generatedColumn -
                section.generatedOffset.generatedColumn);
      });
    const section = this._sections[sectionIndex];

    if (!section) {
      return {
        source: null,
        line: null,
        column: null,
        name: null
      };
    }

    return section.consumer.originalPositionFor({
      line: needle.generatedLine -
        (section.generatedOffset.generatedLine - 1),
      column: needle.generatedColumn -
        (section.generatedOffset.generatedLine === needle.generatedLine
         ? section.generatedOffset.generatedColumn - 1
         : 0),
      bias: aArgs.bias
    });
  }

  /**
   * Return true if we have the source content for every source in the source
   * map, false otherwise.
   */
  hasContentsOfAllSources() {
    return this._sections.every(function(s) {
      return s.consumer.hasContentsOfAllSources();
    });
  }

  /**
   * Returns the original source content. The only argument is the url of the
   * original source file. Returns null if no original source content is
   * available.
   */
  sourceContentFor(aSource, nullOnMissing) {
    for (let i = 0; i < this._sections.length; i++) {
      const section = this._sections[i];

      const content = section.consumer.sourceContentFor(aSource, true);
      if (content) {
        return content;
      }
    }
    if (nullOnMissing) {
      return null;
    }
    throw new Error('"' + aSource + '" is not in the SourceMap.');
  }

  /**
   * Returns the generated line and column information for the original source,
   * line, and column positions provided. The only argument is an object with
   * the following properties:
   *
   *   - source: The filename of the original source.
   *   - line: The line number in the original source.  The line number
   *     is 1-based.
   *   - column: The column number in the original source.  The column
   *     number is 0-based.
   *
   * and an object is returned with the following properties:
   *
   *   - line: The line number in the generated source, or null.  The
   *     line number is 1-based.
   *   - column: The column number in the generated source, or null.
   *     The column number is 0-based.
   */
  generatedPositionFor(aArgs) {
    for (let i = 0; i < this._sections.length; i++) {
      const section = this._sections[i];

      // Only consider this section if the requested source is in the list of
      // sources of the consumer.
      if (section.consumer._findSourceIndex(util.getArg(aArgs, "source")) === -1) {
        continue;
      }
      const generatedPosition = section.consumer.generatedPositionFor(aArgs);
      if (generatedPosition) {
        const ret = {
          line: generatedPosition.line +
            (section.generatedOffset.generatedLine - 1),
          column: generatedPosition.column +
            (section.generatedOffset.generatedLine === generatedPosition.line
             ? section.generatedOffset.generatedColumn - 1
             : 0)
        };
        return ret;
      }
    }

    return {
      line: null,
      column: null
    };
  }

  /**
   * Parse the mappings in a string in to a data structure which we can easily
   * query (the ordered arrays in the `this.__generatedMappings` and
   * `this.__originalMappings` properties).
   */
  _parseMappings(aStr, aSourceRoot) {
    const generatedMappings = this.__generatedMappingsUnsorted = [];
    const originalMappings = this.__originalMappingsUnsorted = [];
    for (let i = 0; i < this._sections.length; i++) {
      const section = this._sections[i];

      const sectionMappings = [];
      section.consumer.eachMapping(m => sectionMappings.push(m));

      for (let j = 0; j < sectionMappings.length; j++) {
        const mapping = sectionMappings[j];

        // TODO: test if null is correct here.  The original code used
        // `source`, which would actually have gotten used as null because
        // var's get hoisted.
        // See: https://github.com/mozilla/source-map/issues/333
        let source = util.computeSourceURL(section.consumer.sourceRoot, null, this._sourceMapURL);
        this._sources.add(source);
        source = this._sources.indexOf(source);

        let name = null;
        if (mapping.name) {
          this._names.add(mapping.name);
          name = this._names.indexOf(mapping.name);
        }

        // The mappings coming from the consumer for the section have
        // generated positions relative to the start of the section, so we
        // need to offset them to be relative to the start of the concatenated
        // generated file.
        const adjustedMapping = {
          source,
          generatedLine: mapping.generatedLine +
            (section.generatedOffset.generatedLine - 1),
          generatedColumn: mapping.generatedColumn +
            (section.generatedOffset.generatedLine === mapping.generatedLine
            ? section.generatedOffset.generatedColumn - 1
            : 0),
          originalLine: mapping.originalLine,
          originalColumn: mapping.originalColumn,
          name
        };

        generatedMappings.push(adjustedMapping);
        if (typeof adjustedMapping.originalLine === "number") {
          originalMappings.push(adjustedMapping);
        }
      }
    }
  }

  eachMapping(aCallback, aContext, aOrder) {
    const context = aContext || null;
    const order = aOrder || SourceMapConsumer.GENERATED_ORDER;

    let mappings;
    switch (order) {
    case SourceMapConsumer.GENERATED_ORDER:
      mappings = this._generatedMappings;
      break;
    case SourceMapConsumer.ORIGINAL_ORDER:
      mappings = this._originalMappings;
      break;
    default:
      throw new Error("Unknown order of iteration.");
    }

    const sourceRoot = this.sourceRoot;
    mappings.map(function(mapping) {
      let source = null;
      if (mapping.source !== null) {
        source = this._sources.at(mapping.source);
        source = util.computeSourceURL(sourceRoot, source, this._sourceMapURL);
      }
      return {
        source,
        generatedLine: mapping.generatedLine,
        generatedColumn: mapping.generatedColumn,
        originalLine: mapping.originalLine,
        originalColumn: mapping.originalColumn,
        name: mapping.name === null ? null : this._names.at(mapping.name)
      };
    }, this).forEach(aCallback, context);
  }

  /**
   * Find the mapping that best matches the hypothetical "needle" mapping that
   * we are searching for in the given "haystack" of mappings.
   */
  _findMapping(aNeedle, aMappings, aLineName,
              aColumnName, aComparator, aBias) {
    // To return the position we are searching for, we must first find the
    // mapping for the given position and then return the opposite position it
    // points to. Because the mappings are sorted, we can use binary search to
    // find the best mapping.

    if (aNeedle[aLineName] <= 0) {
      throw new TypeError("Line must be greater than or equal to 1, got "
                          + aNeedle[aLineName]);
    }
    if (aNeedle[aColumnName] < 0) {
      throw new TypeError("Column must be greater than or equal to 0, got "
                          + aNeedle[aColumnName]);
    }

    return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
  }

  allGeneratedPositionsFor(aArgs) {
    const line = util.getArg(aArgs, "line");

    // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping
    // returns the index of the closest mapping less than the needle. By
    // setting needle.originalColumn to 0, we thus find the last mapping for
    // the given line, provided such a mapping exists.
    const needle = {
      source: util.getArg(aArgs, "source"),
      originalLine: line,
      originalColumn: util.getArg(aArgs, "column", 0)
    };

    needle.source = this._findSourceIndex(needle.source);
    if (needle.source < 0) {
      return [];
    }

    if (needle.originalLine < 1) {
      throw new Error("Line numbers must be >= 1");
    }

    if (needle.originalColumn < 0) {
      throw new Error("Column numbers must be >= 0");
    }

    const mappings = [];

    let index = this._findMapping(needle,
                                  this._originalMappings,
                                  "originalLine",
                                  "originalColumn",
                                  util.compareByOriginalPositions,
                                  binarySearch.LEAST_UPPER_BOUND);
    if (index >= 0) {
      let mapping = this._originalMappings[index];

      if (aArgs.column === undefined) {
        const originalLine = mapping.originalLine;

        // Iterate until either we run out of mappings, or we run into
        // a mapping for a different line than the one we found. Since
        // mappings are sorted, this is guaranteed to find all mappings for
        // the line we found.
        while (mapping && mapping.originalLine === originalLine) {
          let lastColumn = mapping.lastGeneratedColumn;
          if (this._computedColumnSpans && lastColumn === null) {
            lastColumn = Infinity;
          }
          mappings.push({
            line: util.getArg(mapping, "generatedLine", null),
            column: util.getArg(mapping, "generatedColumn", null),
            lastColumn,
          });

          mapping = this._originalMappings[++index];
        }
      } else {
        const originalColumn = mapping.originalColumn;

        // Iterate until either we run out of mappings, or we run into
        // a mapping for a different line than the one we were searching for.
        // Since mappings are sorted, this is guaranteed to find all mappings for
        // the line we are searching for.
        while (mapping &&
               mapping.originalLine === line &&
               mapping.originalColumn == originalColumn) {
          let lastColumn = mapping.lastGeneratedColumn;
          if (this._computedColumnSpans && lastColumn === null) {
            lastColumn = Infinity;
          }
          mappings.push({
            line: util.getArg(mapping, "generatedLine", null),
            column: util.getArg(mapping, "generatedColumn", null),
            lastColumn,
          });

          mapping = this._originalMappings[++index];
        }
      }
    }

    return mappings;
  }

  destroy() {
    for (let i = 0; i < this._sections.length; i++) {
      this._sections[i].consumer.destroy();
    }
  }
}
exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;

/*
 * Cheat to get around inter-twingled classes.  `factory()` can be at the end
 * where it has access to non-hoisted classes, but it gets hoisted itself.
 */
function _factory(aSourceMap, aSourceMapURL) {
  let sourceMap = aSourceMap;
  if (typeof aSourceMap === "string") {
    sourceMap = util.parseSourceMapInput(aSourceMap);
  }

  const consumer = sourceMap.sections != null
      ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL)
      : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);
  return Promise.resolve(consumer);
}

function _factoryBSM(aSourceMap, aSourceMapURL) {
  return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);
}


/***/ }),

/***/ "../../node_modules/dd-trace/node_modules/source-map/lib/source-map-generator.js":
/*!********************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/node_modules/source-map/lib/source-map-generator.js ***!
  \********************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

const base64VLQ = __webpack_require__(/*! ./base64-vlq */ "../../node_modules/dd-trace/node_modules/source-map/lib/base64-vlq.js");
const util = __webpack_require__(/*! ./util */ "../../node_modules/dd-trace/node_modules/source-map/lib/util.js");
const ArraySet = __webpack_require__(/*! ./array-set */ "../../node_modules/dd-trace/node_modules/source-map/lib/array-set.js").ArraySet;
const MappingList = __webpack_require__(/*! ./mapping-list */ "../../node_modules/dd-trace/node_modules/source-map/lib/mapping-list.js").MappingList;

/**
 * An instance of the SourceMapGenerator represents a source map which is
 * being built incrementally. You may pass an object with the following
 * properties:
 *
 *   - file: The filename of the generated source.
 *   - sourceRoot: A root for all relative URLs in this source map.
 */
class SourceMapGenerator {
  constructor(aArgs) {
    if (!aArgs) {
      aArgs = {};
    }
    this._file = util.getArg(aArgs, "file", null);
    this._sourceRoot = util.getArg(aArgs, "sourceRoot", null);
    this._skipValidation = util.getArg(aArgs, "skipValidation", false);
    this._sources = new ArraySet();
    this._names = new ArraySet();
    this._mappings = new MappingList();
    this._sourcesContents = null;
  }

  /**
   * Creates a new SourceMapGenerator based on a SourceMapConsumer
   *
   * @param aSourceMapConsumer The SourceMap.
   */
  static fromSourceMap(aSourceMapConsumer) {
    const sourceRoot = aSourceMapConsumer.sourceRoot;
    const generator = new SourceMapGenerator({
      file: aSourceMapConsumer.file,
      sourceRoot
    });
    aSourceMapConsumer.eachMapping(function(mapping) {
      const newMapping = {
        generated: {
          line: mapping.generatedLine,
          column: mapping.generatedColumn
        }
      };

      if (mapping.source != null) {
        newMapping.source = mapping.source;
        if (sourceRoot != null) {
          newMapping.source = util.relative(sourceRoot, newMapping.source);
        }

        newMapping.original = {
          line: mapping.originalLine,
          column: mapping.originalColumn
        };

        if (mapping.name != null) {
          newMapping.name = mapping.name;
        }
      }

      generator.addMapping(newMapping);
    });
    aSourceMapConsumer.sources.forEach(function(sourceFile) {
      let sourceRelative = sourceFile;
      if (sourceRoot !== null) {
        sourceRelative = util.relative(sourceRoot, sourceFile);
      }

      if (!generator._sources.has(sourceRelative)) {
        generator._sources.add(sourceRelative);
      }

      const content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        generator.setSourceContent(sourceFile, content);
      }
    });
    return generator;
  }

  /**
   * Add a single mapping from original source line and column to the generated
   * source's line and column for this source map being created. The mapping
   * object should have the following properties:
   *
   *   - generated: An object with the generated line and column positions.
   *   - original: An object with the original line and column positions.
   *   - source: The original source file (relative to the sourceRoot).
   *   - name: An optional original token name for this mapping.
   */
  addMapping(aArgs) {
    const generated = util.getArg(aArgs, "generated");
    const original = util.getArg(aArgs, "original", null);
    let source = util.getArg(aArgs, "source", null);
    let name = util.getArg(aArgs, "name", null);

    if (!this._skipValidation) {
      this._validateMapping(generated, original, source, name);
    }

    if (source != null) {
      source = String(source);
      if (!this._sources.has(source)) {
        this._sources.add(source);
      }
    }

    if (name != null) {
      name = String(name);
      if (!this._names.has(name)) {
        this._names.add(name);
      }
    }

    this._mappings.add({
      generatedLine: generated.line,
      generatedColumn: generated.column,
      originalLine: original != null && original.line,
      originalColumn: original != null && original.column,
      source,
      name
    });
  }

  /**
   * Set the source content for a source file.
   */
  setSourceContent(aSourceFile, aSourceContent) {
    let source = aSourceFile;
    if (this._sourceRoot != null) {
      source = util.relative(this._sourceRoot, source);
    }

    if (aSourceContent != null) {
      // Add the source content to the _sourcesContents map.
      // Create a new _sourcesContents map if the property is null.
      if (!this._sourcesContents) {
        this._sourcesContents = Object.create(null);
      }
      this._sourcesContents[util.toSetString(source)] = aSourceContent;
    } else if (this._sourcesContents) {
      // Remove the source file from the _sourcesContents map.
      // If the _sourcesContents map is empty, set the property to null.
      delete this._sourcesContents[util.toSetString(source)];
      if (Object.keys(this._sourcesContents).length === 0) {
        this._sourcesContents = null;
      }
    }
  }

  /**
   * Applies the mappings of a sub-source-map for a specific source file to the
   * source map being generated. Each mapping to the supplied source file is
   * rewritten using the supplied source map. Note: The resolution for the
   * resulting mappings is the minimium of this map and the supplied map.
   *
   * @param aSourceMapConsumer The source map to be applied.
   * @param aSourceFile Optional. The filename of the source file.
   *        If omitted, SourceMapConsumer's file property will be used.
   * @param aSourceMapPath Optional. The dirname of the path to the source map
   *        to be applied. If relative, it is relative to the SourceMapConsumer.
   *        This parameter is needed when the two source maps aren't in the same
   *        directory, and the source map to be applied contains relative source
   *        paths. If so, those relative source paths need to be rewritten
   *        relative to the SourceMapGenerator.
   */
  applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
    let sourceFile = aSourceFile;
    // If aSourceFile is omitted, we will use the file property of the SourceMap
    if (aSourceFile == null) {
      if (aSourceMapConsumer.file == null) {
        throw new Error(
          "SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, " +
          'or the source map\'s "file" property. Both were omitted.'
        );
      }
      sourceFile = aSourceMapConsumer.file;
    }
    const sourceRoot = this._sourceRoot;
    // Make "sourceFile" relative if an absolute Url is passed.
    if (sourceRoot != null) {
      sourceFile = util.relative(sourceRoot, sourceFile);
    }
    // Applying the SourceMap can add and remove items from the sources and
    // the names array.
    const newSources = this._mappings.toArray().length > 0
      ? new ArraySet()
      : this._sources;
    const newNames = new ArraySet();

    // Find mappings for the "sourceFile"
    this._mappings.unsortedForEach(function(mapping) {
      if (mapping.source === sourceFile && mapping.originalLine != null) {
        // Check if it can be mapped by the source map, then update the mapping.
        const original = aSourceMapConsumer.originalPositionFor({
          line: mapping.originalLine,
          column: mapping.originalColumn
        });
        if (original.source != null) {
          // Copy mapping
          mapping.source = original.source;
          if (aSourceMapPath != null) {
            mapping.source = util.join(aSourceMapPath, mapping.source);
          }
          if (sourceRoot != null) {
            mapping.source = util.relative(sourceRoot, mapping.source);
          }
          mapping.originalLine = original.line;
          mapping.originalColumn = original.column;
          if (original.name != null) {
            mapping.name = original.name;
          }
        }
      }

      const source = mapping.source;
      if (source != null && !newSources.has(source)) {
        newSources.add(source);
      }

      const name = mapping.name;
      if (name != null && !newNames.has(name)) {
        newNames.add(name);
      }

    }, this);
    this._sources = newSources;
    this._names = newNames;

    // Copy sourcesContents of applied map.
    aSourceMapConsumer.sources.forEach(function(srcFile) {
      const content = aSourceMapConsumer.sourceContentFor(srcFile);
      if (content != null) {
        if (aSourceMapPath != null) {
          srcFile = util.join(aSourceMapPath, srcFile);
        }
        if (sourceRoot != null) {
          srcFile = util.relative(sourceRoot, srcFile);
        }
        this.setSourceContent(srcFile, content);
      }
    }, this);
  }

  /**
   * A mapping can have one of the three levels of data:
   *
   *   1. Just the generated position.
   *   2. The Generated position, original position, and original source.
   *   3. Generated and original position, original source, as well as a name
   *      token.
   *
   * To maintain consistency, we validate that any new mapping being added falls
   * in to one of these categories.
   */
  _validateMapping(aGenerated, aOriginal, aSource, aName) {
    // When aOriginal is truthy but has empty values for .line and .column,
    // it is most likely a programmer error. In this case we throw a very
    // specific error message to try to guide them the right way.
    // For example: https://github.com/Polymer/polymer-bundler/pull/519
    if (aOriginal && typeof aOriginal.line !== "number" && typeof aOriginal.column !== "number") {
        throw new Error(
            "original.line and original.column are not numbers -- you probably meant to omit " +
            "the original mapping entirely and only map the generated position. If so, pass " +
            "null for the original mapping instead of an object with empty or null values."
        );
    }

    if (aGenerated && "line" in aGenerated && "column" in aGenerated
        && aGenerated.line > 0 && aGenerated.column >= 0
        && !aOriginal && !aSource && !aName) {
      // Case 1.

    } else if (aGenerated && "line" in aGenerated && "column" in aGenerated
             && aOriginal && "line" in aOriginal && "column" in aOriginal
             && aGenerated.line > 0 && aGenerated.column >= 0
             && aOriginal.line > 0 && aOriginal.column >= 0
             && aSource) {
      // Cases 2 and 3.

    } else {
      throw new Error("Invalid mapping: " + JSON.stringify({
        generated: aGenerated,
        source: aSource,
        original: aOriginal,
        name: aName
      }));
    }
  }

  /**
   * Serialize the accumulated mappings in to the stream of base 64 VLQs
   * specified by the source map format.
   */
  _serializeMappings() {
    let previousGeneratedColumn = 0;
    let previousGeneratedLine = 1;
    let previousOriginalColumn = 0;
    let previousOriginalLine = 0;
    let previousName = 0;
    let previousSource = 0;
    let result = "";
    let next;
    let mapping;
    let nameIdx;
    let sourceIdx;

    const mappings = this._mappings.toArray();
    for (let i = 0, len = mappings.length; i < len; i++) {
      mapping = mappings[i];
      next = "";

      if (mapping.generatedLine !== previousGeneratedLine) {
        previousGeneratedColumn = 0;
        while (mapping.generatedLine !== previousGeneratedLine) {
          next += ";";
          previousGeneratedLine++;
        }
      } else if (i > 0) {
        if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
          continue;
        }
        next += ",";
      }

      next += base64VLQ.encode(mapping.generatedColumn
                                 - previousGeneratedColumn);
      previousGeneratedColumn = mapping.generatedColumn;

      if (mapping.source != null) {
        sourceIdx = this._sources.indexOf(mapping.source);
        next += base64VLQ.encode(sourceIdx - previousSource);
        previousSource = sourceIdx;

        // lines are stored 0-based in SourceMap spec version 3
        next += base64VLQ.encode(mapping.originalLine - 1
                                   - previousOriginalLine);
        previousOriginalLine = mapping.originalLine - 1;

        next += base64VLQ.encode(mapping.originalColumn
                                   - previousOriginalColumn);
        previousOriginalColumn = mapping.originalColumn;

        if (mapping.name != null) {
          nameIdx = this._names.indexOf(mapping.name);
          next += base64VLQ.encode(nameIdx - previousName);
          previousName = nameIdx;
        }
      }

      result += next;
    }

    return result;
  }

  _generateSourcesContent(aSources, aSourceRoot) {
    return aSources.map(function(source) {
      if (!this._sourcesContents) {
        return null;
      }
      if (aSourceRoot != null) {
        source = util.relative(aSourceRoot, source);
      }
      const key = util.toSetString(source);
      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)
        ? this._sourcesContents[key]
        : null;
    }, this);
  }

  /**
   * Externalize the source map.
   */
  toJSON() {
    const map = {
      version: this._version,
      sources: this._sources.toArray(),
      names: this._names.toArray(),
      mappings: this._serializeMappings()
    };
    if (this._file != null) {
      map.file = this._file;
    }
    if (this._sourceRoot != null) {
      map.sourceRoot = this._sourceRoot;
    }
    if (this._sourcesContents) {
      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
    }

    return map;
  }

  /**
   * Render the source map being generated to a string.
   */
  toString() {
    return JSON.stringify(this.toJSON());
  }
}

SourceMapGenerator.prototype._version = 3;
exports.SourceMapGenerator = SourceMapGenerator;


/***/ }),

/***/ "../../node_modules/dd-trace/node_modules/source-map/lib/source-node.js":
/*!***********************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/node_modules/source-map/lib/source-node.js ***!
  \***********************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

const SourceMapGenerator = __webpack_require__(/*! ./source-map-generator */ "../../node_modules/dd-trace/node_modules/source-map/lib/source-map-generator.js").SourceMapGenerator;
const util = __webpack_require__(/*! ./util */ "../../node_modules/dd-trace/node_modules/source-map/lib/util.js");

// Matches a Windows-style `\r\n` newline or a `\n` newline used by all other
// operating systems these days (capturing the result).
const REGEX_NEWLINE = /(\r?\n)/;

// Newline character code for charCodeAt() comparisons
const NEWLINE_CODE = 10;

// Private symbol for identifying `SourceNode`s when multiple versions of
// the source-map library are loaded. This MUST NOT CHANGE across
// versions!
const isSourceNode = "$$$isSourceNode$$$";

/**
 * SourceNodes provide a way to abstract over interpolating/concatenating
 * snippets of generated JavaScript source code while maintaining the line and
 * column information associated with the original source code.
 *
 * @param aLine The original line number.
 * @param aColumn The original column number.
 * @param aSource The original source's filename.
 * @param aChunks Optional. An array of strings which are snippets of
 *        generated JS, or other SourceNodes.
 * @param aName The original identifier.
 */
class SourceNode {
  constructor(aLine, aColumn, aSource, aChunks, aName) {
    this.children = [];
    this.sourceContents = {};
    this.line = aLine == null ? null : aLine;
    this.column = aColumn == null ? null : aColumn;
    this.source = aSource == null ? null : aSource;
    this.name = aName == null ? null : aName;
    this[isSourceNode] = true;
    if (aChunks != null) this.add(aChunks);
  }

  /**
   * Creates a SourceNode from generated code and a SourceMapConsumer.
   *
   * @param aGeneratedCode The generated code
   * @param aSourceMapConsumer The SourceMap for the generated code
   * @param aRelativePath Optional. The path that relative sources in the
   *        SourceMapConsumer should be relative to.
   */
  static fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
    // The SourceNode we want to fill with the generated code
    // and the SourceMap
    const node = new SourceNode();

    // All even indices of this array are one line of the generated code,
    // while all odd indices are the newlines between two adjacent lines
    // (since `REGEX_NEWLINE` captures its match).
    // Processed fragments are accessed by calling `shiftNextLine`.
    const remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
    let remainingLinesIndex = 0;
    const shiftNextLine = function() {
      const lineContents = getNextLine();
      // The last line of a file might not have a newline.
      const newLine = getNextLine() || "";
      return lineContents + newLine;

      function getNextLine() {
        return remainingLinesIndex < remainingLines.length ?
            remainingLines[remainingLinesIndex++] : undefined;
      }
    };

    // We need to remember the position of "remainingLines"
    let lastGeneratedLine = 1, lastGeneratedColumn = 0;

    // The generate SourceNodes we need a code range.
    // To extract it current and last mapping is used.
    // Here we store the last mapping.
    let lastMapping = null;
    let nextLine;

    aSourceMapConsumer.eachMapping(function(mapping) {
      if (lastMapping !== null) {
        // We add the code from "lastMapping" to "mapping":
        // First check if there is a new line in between.
        if (lastGeneratedLine < mapping.generatedLine) {
          // Associate first line with "lastMapping"
          addMappingWithCode(lastMapping, shiftNextLine());
          lastGeneratedLine++;
          lastGeneratedColumn = 0;
          // The remaining code is added without mapping
        } else {
          // There is no new line in between.
          // Associate the code between "lastGeneratedColumn" and
          // "mapping.generatedColumn" with "lastMapping"
          nextLine = remainingLines[remainingLinesIndex] || "";
          const code = nextLine.substr(0, mapping.generatedColumn -
                                        lastGeneratedColumn);
          remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn -
                                              lastGeneratedColumn);
          lastGeneratedColumn = mapping.generatedColumn;
          addMappingWithCode(lastMapping, code);
          // No more remaining code, continue
          lastMapping = mapping;
          return;
        }
      }
      // We add the generated code until the first mapping
      // to the SourceNode without any mapping.
      // Each line is added as separate string.
      while (lastGeneratedLine < mapping.generatedLine) {
        node.add(shiftNextLine());
        lastGeneratedLine++;
      }
      if (lastGeneratedColumn < mapping.generatedColumn) {
        nextLine = remainingLines[remainingLinesIndex] || "";
        node.add(nextLine.substr(0, mapping.generatedColumn));
        remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
        lastGeneratedColumn = mapping.generatedColumn;
      }
      lastMapping = mapping;
    }, this);
    // We have processed all mappings.
    if (remainingLinesIndex < remainingLines.length) {
      if (lastMapping) {
        // Associate the remaining code in the current line with "lastMapping"
        addMappingWithCode(lastMapping, shiftNextLine());
      }
      // and add the remaining lines without any mapping
      node.add(remainingLines.splice(remainingLinesIndex).join(""));
    }

    // Copy sourcesContent into SourceNode
    aSourceMapConsumer.sources.forEach(function(sourceFile) {
      const content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        if (aRelativePath != null) {
          sourceFile = util.join(aRelativePath, sourceFile);
        }
        node.setSourceContent(sourceFile, content);
      }
    });

    return node;

    function addMappingWithCode(mapping, code) {
      if (mapping === null || mapping.source === undefined) {
        node.add(code);
      } else {
        const source = aRelativePath
          ? util.join(aRelativePath, mapping.source)
          : mapping.source;
        node.add(new SourceNode(mapping.originalLine,
                                mapping.originalColumn,
                                source,
                                code,
                                mapping.name));
      }
    }
  }

  /**
   * Add a chunk of generated JS to this source node.
   *
   * @param aChunk A string snippet of generated JS code, another instance of
   *        SourceNode, or an array where each member is one of those things.
   */
  add(aChunk) {
    if (Array.isArray(aChunk)) {
      aChunk.forEach(function(chunk) {
        this.add(chunk);
      }, this);
    } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
      if (aChunk) {
        this.children.push(aChunk);
      }
    } else {
      throw new TypeError(
        "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
      );
    }
    return this;
  }

  /**
   * Add a chunk of generated JS to the beginning of this source node.
   *
   * @param aChunk A string snippet of generated JS code, another instance of
   *        SourceNode, or an array where each member is one of those things.
   */
  prepend(aChunk) {
    if (Array.isArray(aChunk)) {
      for (let i = aChunk.length - 1; i >= 0; i--) {
        this.prepend(aChunk[i]);
      }
    } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
      this.children.unshift(aChunk);
    } else {
      throw new TypeError(
        "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
      );
    }
    return this;
  }

  /**
   * Walk over the tree of JS snippets in this node and its children. The
   * walking function is called once for each snippet of JS and is passed that
   * snippet and the its original associated source's line/column location.
   *
   * @param aFn The traversal function.
   */
  walk(aFn) {
    let chunk;
    for (let i = 0, len = this.children.length; i < len; i++) {
      chunk = this.children[i];
      if (chunk[isSourceNode]) {
        chunk.walk(aFn);
      } else if (chunk !== "") {
        aFn(chunk, { source: this.source,
                      line: this.line,
                      column: this.column,
                      name: this.name });
      }
    }
  }

  /**
   * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between
   * each of `this.children`.
   *
   * @param aSep The separator.
   */
  join(aSep) {
    let newChildren;
    let i;
    const len = this.children.length;
    if (len > 0) {
      newChildren = [];
      for (i = 0; i < len - 1; i++) {
        newChildren.push(this.children[i]);
        newChildren.push(aSep);
      }
      newChildren.push(this.children[i]);
      this.children = newChildren;
    }
    return this;
  }

  /**
   * Call String.prototype.replace on the very right-most source snippet. Useful
   * for trimming whitespace from the end of a source node, etc.
   *
   * @param aPattern The pattern to replace.
   * @param aReplacement The thing to replace the pattern with.
   */
  replaceRight(aPattern, aReplacement) {
    const lastChild = this.children[this.children.length - 1];
    if (lastChild[isSourceNode]) {
      lastChild.replaceRight(aPattern, aReplacement);
    } else if (typeof lastChild === "string") {
      this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
    } else {
      this.children.push("".replace(aPattern, aReplacement));
    }
    return this;
  }

  /**
   * Set the source content for a source file. This will be added to the SourceMapGenerator
   * in the sourcesContent field.
   *
   * @param aSourceFile The filename of the source file
   * @param aSourceContent The content of the source file
   */
  setSourceContent(aSourceFile, aSourceContent) {
    this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
  }

  /**
   * Walk over the tree of SourceNodes. The walking function is called for each
   * source file content and is passed the filename and source content.
   *
   * @param aFn The traversal function.
   */
  walkSourceContents(aFn) {
    for (let i = 0, len = this.children.length; i < len; i++) {
      if (this.children[i][isSourceNode]) {
        this.children[i].walkSourceContents(aFn);
      }
    }

    const sources = Object.keys(this.sourceContents);
    for (let i = 0, len = sources.length; i < len; i++) {
      aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
    }
  }

  /**
   * Return the string representation of this source node. Walks over the tree
   * and concatenates all the various snippets together to one string.
   */
  toString() {
    let str = "";
    this.walk(function(chunk) {
      str += chunk;
    });
    return str;
  }

  /**
   * Returns the string representation of this source node along with a source
   * map.
   */
  toStringWithSourceMap(aArgs) {
    const generated = {
      code: "",
      line: 1,
      column: 0
    };
    const map = new SourceMapGenerator(aArgs);
    let sourceMappingActive = false;
    let lastOriginalSource = null;
    let lastOriginalLine = null;
    let lastOriginalColumn = null;
    let lastOriginalName = null;
    this.walk(function(chunk, original) {
      generated.code += chunk;
      if (original.source !== null
          && original.line !== null
          && original.column !== null) {
        if (lastOriginalSource !== original.source
          || lastOriginalLine !== original.line
          || lastOriginalColumn !== original.column
          || lastOriginalName !== original.name) {
          map.addMapping({
            source: original.source,
            original: {
              line: original.line,
              column: original.column
            },
            generated: {
              line: generated.line,
              column: generated.column
            },
            name: original.name
          });
        }
        lastOriginalSource = original.source;
        lastOriginalLine = original.line;
        lastOriginalColumn = original.column;
        lastOriginalName = original.name;
        sourceMappingActive = true;
      } else if (sourceMappingActive) {
        map.addMapping({
          generated: {
            line: generated.line,
            column: generated.column
          }
        });
        lastOriginalSource = null;
        sourceMappingActive = false;
      }
      for (let idx = 0, length = chunk.length; idx < length; idx++) {
        if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
          generated.line++;
          generated.column = 0;
          // Mappings end at eol
          if (idx + 1 === length) {
            lastOriginalSource = null;
            sourceMappingActive = false;
          } else if (sourceMappingActive) {
            map.addMapping({
              source: original.source,
              original: {
                line: original.line,
                column: original.column
              },
              generated: {
                line: generated.line,
                column: generated.column
              },
              name: original.name
            });
          }
        } else {
          generated.column++;
        }
      }
    });
    this.walkSourceContents(function(sourceFile, sourceContent) {
      map.setSourceContent(sourceFile, sourceContent);
    });

    return { code: generated.code, map };
  }
}

exports.SourceNode = SourceNode;


/***/ }),

/***/ "../../node_modules/dd-trace/node_modules/source-map/lib/util.js":
/*!****************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/node_modules/source-map/lib/util.js ***!
  \****************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports) {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

/**
 * This is a helper function for getting values from parameter/options
 * objects.
 *
 * @param args The object we are extracting values from
 * @param name The name of the property we are getting.
 * @param defaultValue An optional value to return if the property is missing
 * from the object. If this is not specified and the property is missing, an
 * error will be thrown.
 */
function getArg(aArgs, aName, aDefaultValue) {
  if (aName in aArgs) {
    return aArgs[aName];
  } else if (arguments.length === 3) {
    return aDefaultValue;
  }
    throw new Error('"' + aName + '" is a required argument.');

}
exports.getArg = getArg;

const urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
const dataUrlRegexp = /^data:.+\,.+$/;

function urlParse(aUrl) {
  const match = aUrl.match(urlRegexp);
  if (!match) {
    return null;
  }
  return {
    scheme: match[1],
    auth: match[2],
    host: match[3],
    port: match[4],
    path: match[5]
  };
}
exports.urlParse = urlParse;

function urlGenerate(aParsedUrl) {
  let url = "";
  if (aParsedUrl.scheme) {
    url += aParsedUrl.scheme + ":";
  }
  url += "//";
  if (aParsedUrl.auth) {
    url += aParsedUrl.auth + "@";
  }
  if (aParsedUrl.host) {
    url += aParsedUrl.host;
  }
  if (aParsedUrl.port) {
    url += ":" + aParsedUrl.port;
  }
  if (aParsedUrl.path) {
    url += aParsedUrl.path;
  }
  return url;
}
exports.urlGenerate = urlGenerate;

const MAX_CACHED_INPUTS = 32;

/**
 * Takes some function `f(input) -> result` and returns a memoized version of
 * `f`.
 *
 * We keep at most `MAX_CACHED_INPUTS` memoized results of `f` alive. The
 * memoization is a dumb-simple, linear least-recently-used cache.
 */
function lruMemoize(f) {
  const cache = [];

  return function(input) {
    for (let i = 0; i < cache.length; i++) {
      if (cache[i].input === input) {
        const temp = cache[0];
        cache[0] = cache[i];
        cache[i] = temp;
        return cache[0].result;
      }
    }

    const result = f(input);

    cache.unshift({
      input,
      result,
    });

    if (cache.length > MAX_CACHED_INPUTS) {
      cache.pop();
    }

    return result;
  };
}

/**
 * Normalizes a path, or the path portion of a URL:
 *
 * - Replaces consecutive slashes with one slash.
 * - Removes unnecessary '.' parts.
 * - Removes unnecessary '<dir>/..' parts.
 *
 * Based on code in the Node.js 'path' core module.
 *
 * @param aPath The path or url to normalize.
 */
const normalize = lruMemoize(function normalize(aPath) {
  let path = aPath;
  const url = urlParse(aPath);
  if (url) {
    if (!url.path) {
      return aPath;
    }
    path = url.path;
  }
  const isAbsolute = exports.isAbsolute(path);

  // Split the path into parts between `/` characters. This is much faster than
  // using `.split(/\/+/g)`.
  const parts = [];
  let start = 0;
  let i = 0;
  while (true) {
    start = i;
    i = path.indexOf("/", start);
    if (i === -1) {
      parts.push(path.slice(start));
      break;
    } else {
      parts.push(path.slice(start, i));
      while (i < path.length && path[i] === "/") {
        i++;
      }
    }
  }

  let up = 0;
  for (i = parts.length - 1; i >= 0; i--) {
    const part = parts[i];
    if (part === ".") {
      parts.splice(i, 1);
    } else if (part === "..") {
      up++;
    } else if (up > 0) {
      if (part === "") {
        // The first part is blank if the path is absolute. Trying to go
        // above the root is a no-op. Therefore we can remove all '..' parts
        // directly after the root.
        parts.splice(i + 1, up);
        up = 0;
      } else {
        parts.splice(i, 2);
        up--;
      }
    }
  }
  path = parts.join("/");

  if (path === "") {
    path = isAbsolute ? "/" : ".";
  }

  if (url) {
    url.path = path;
    return urlGenerate(url);
  }
  return path;
});
exports.normalize = normalize;

/**
 * Joins two paths/URLs.
 *
 * @param aRoot The root path or URL.
 * @param aPath The path or URL to be joined with the root.
 *
 * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
 *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
 *   first.
 * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
 *   is updated with the result and aRoot is returned. Otherwise the result
 *   is returned.
 *   - If aPath is absolute, the result is aPath.
 *   - Otherwise the two paths are joined with a slash.
 * - Joining for example 'http://' and 'www.example.com' is also supported.
 */
function join(aRoot, aPath) {
  if (aRoot === "") {
    aRoot = ".";
  }
  if (aPath === "") {
    aPath = ".";
  }
  const aPathUrl = urlParse(aPath);
  const aRootUrl = urlParse(aRoot);
  if (aRootUrl) {
    aRoot = aRootUrl.path || "/";
  }

  // `join(foo, '//www.example.org')`
  if (aPathUrl && !aPathUrl.scheme) {
    if (aRootUrl) {
      aPathUrl.scheme = aRootUrl.scheme;
    }
    return urlGenerate(aPathUrl);
  }

  if (aPathUrl || aPath.match(dataUrlRegexp)) {
    return aPath;
  }

  // `join('http://', 'www.example.com')`
  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
    aRootUrl.host = aPath;
    return urlGenerate(aRootUrl);
  }

  const joined = aPath.charAt(0) === "/"
    ? aPath
    : normalize(aRoot.replace(/\/+$/, "") + "/" + aPath);

  if (aRootUrl) {
    aRootUrl.path = joined;
    return urlGenerate(aRootUrl);
  }
  return joined;
}
exports.join = join;

exports.isAbsolute = function(aPath) {
  return aPath.charAt(0) === "/" || urlRegexp.test(aPath);
};

/**
 * Make a path relative to a URL or another path.
 *
 * @param aRoot The root path or URL.
 * @param aPath The path or URL to be made relative to aRoot.
 */
function relative(aRoot, aPath) {
  if (aRoot === "") {
    aRoot = ".";
  }

  aRoot = aRoot.replace(/\/$/, "");

  // It is possible for the path to be above the root. In this case, simply
  // checking whether the root is a prefix of the path won't work. Instead, we
  // need to remove components from the root one by one, until either we find
  // a prefix that fits, or we run out of components to remove.
  let level = 0;
  while (aPath.indexOf(aRoot + "/") !== 0) {
    const index = aRoot.lastIndexOf("/");
    if (index < 0) {
      return aPath;
    }

    // If the only part of the root that is left is the scheme (i.e. http://,
    // file:///, etc.), one or more slashes (/), or simply nothing at all, we
    // have exhausted all components, so the path is not relative to the root.
    aRoot = aRoot.slice(0, index);
    if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
      return aPath;
    }

    ++level;
  }

  // Make sure we add a "../" for each component we removed from the root.
  return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
}
exports.relative = relative;

const supportsNullProto = (function() {
  const obj = Object.create(null);
  return !("__proto__" in obj);
}());

function identity(s) {
  return s;
}

/**
 * Because behavior goes wacky when you set `__proto__` on objects, we
 * have to prefix all the strings in our set with an arbitrary character.
 *
 * See https://github.com/mozilla/source-map/pull/31 and
 * https://github.com/mozilla/source-map/issues/30
 *
 * @param String aStr
 */
function toSetString(aStr) {
  if (isProtoString(aStr)) {
    return "$" + aStr;
  }

  return aStr;
}
exports.toSetString = supportsNullProto ? identity : toSetString;

function fromSetString(aStr) {
  if (isProtoString(aStr)) {
    return aStr.slice(1);
  }

  return aStr;
}
exports.fromSetString = supportsNullProto ? identity : fromSetString;

function isProtoString(s) {
  if (!s) {
    return false;
  }

  const length = s.length;

  if (length < 9 /* "__proto__".length */) {
    return false;
  }

  /* eslint-disable no-multi-spaces */
  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||
      s.charCodeAt(length - 2) !== 95  /* '_' */ ||
      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||
      s.charCodeAt(length - 4) !== 116 /* 't' */ ||
      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||
      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||
      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||
      s.charCodeAt(length - 8) !== 95  /* '_' */ ||
      s.charCodeAt(length - 9) !== 95  /* '_' */) {
    return false;
  }
  /* eslint-enable no-multi-spaces */

  for (let i = length - 10; i >= 0; i--) {
    if (s.charCodeAt(i) !== 36 /* '$' */) {
      return false;
    }
  }

  return true;
}

/**
 * Comparator between two mappings where the original positions are compared.
 *
 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
 * mappings with the same original source/line/column, but different generated
 * line and column the same. Useful when searching for a mapping with a
 * stubbed out mapping.
 */
function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
  let cmp = strcmp(mappingA.source, mappingB.source);
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;
  if (cmp !== 0 || onlyCompareOriginal) {
    return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.generatedLine - mappingB.generatedLine;
  if (cmp !== 0) {
    return cmp;
  }

  return strcmp(mappingA.name, mappingB.name);
}
exports.compareByOriginalPositions = compareByOriginalPositions;

/**
 * Comparator between two mappings with deflated source and name indices where
 * the generated positions are compared.
 *
 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
 * mappings with the same generated line and column, but different
 * source/name/original line and column the same. Useful when searching for a
 * mapping with a stubbed out mapping.
 */
function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
  let cmp = mappingA.generatedLine - mappingB.generatedLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
  if (cmp !== 0 || onlyCompareGenerated) {
    return cmp;
  }

  cmp = strcmp(mappingA.source, mappingB.source);
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;
  if (cmp !== 0) {
    return cmp;
  }

  return strcmp(mappingA.name, mappingB.name);
}
exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;

function strcmp(aStr1, aStr2) {
  if (aStr1 === aStr2) {
    return 0;
  }

  if (aStr1 === null) {
    return 1; // aStr2 !== null
  }

  if (aStr2 === null) {
    return -1; // aStr1 !== null
  }

  if (aStr1 > aStr2) {
    return 1;
  }

  return -1;
}

/**
 * Comparator between two mappings with inflated source and name strings where
 * the generated positions are compared.
 */
function compareByGeneratedPositionsInflated(mappingA, mappingB) {
  let cmp = mappingA.generatedLine - mappingB.generatedLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = strcmp(mappingA.source, mappingB.source);
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;
  if (cmp !== 0) {
    return cmp;
  }

  return strcmp(mappingA.name, mappingB.name);
}
exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;

/**
 * Strip any JSON XSSI avoidance prefix from the string (as documented
 * in the source maps specification), and then parse the string as
 * JSON.
 */
function parseSourceMapInput(str) {
  return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ""));
}
exports.parseSourceMapInput = parseSourceMapInput;

/**
 * Compute the URL of a source given the the source root, the source's
 * URL, and the source map's URL.
 */
function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
  sourceURL = sourceURL || "";

  if (sourceRoot) {
    // This follows what Chrome does.
    if (sourceRoot[sourceRoot.length - 1] !== "/" && sourceURL[0] !== "/") {
      sourceRoot += "/";
    }
    // The spec says:
    //   Line 4: An optional source root, useful for relocating source
    //   files on a server or removing repeated values in the
    //   sources entry.  This value is prepended to the individual
    //   entries in the source field.
    sourceURL = sourceRoot + sourceURL;
  }

  // Historically, SourceMapConsumer did not take the sourceMapURL as
  // a parameter.  This mode is still somewhat supported, which is why
  // this code block is conditional.  However, it's preferable to pass
  // the source map URL to SourceMapConsumer, so that this function
  // can implement the source URL resolution algorithm as outlined in
  // the spec.  This block is basically the equivalent of:
  //    new URL(sourceURL, sourceMapURL).toString()
  // ... except it avoids using URL, which wasn't available in the
  // older releases of node still supported by this library.
  //
  // The spec says:
  //   If the sources are not absolute URLs after prepending of the
  //   sourceRoot, the sources are resolved relative to the
  //   SourceMap (like resolving script src in a html document).
  if (sourceMapURL) {
    const parsed = urlParse(sourceMapURL);
    if (!parsed) {
      throw new Error("sourceMapURL could not be parsed");
    }
    if (parsed.path) {
      // Strip the last path component, but keep the "/".
      const index = parsed.path.lastIndexOf("/");
      if (index >= 0) {
        parsed.path = parsed.path.substring(0, index + 1);
      }
    }
    sourceURL = join(urlGenerate(parsed), sourceURL);
  }

  return normalize(sourceURL);
}
exports.computeSourceURL = computeSourceURL;


/***/ }),

/***/ "../../node_modules/dd-trace/node_modules/source-map/lib/wasm.js":
/*!****************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/node_modules/source-map/lib/wasm.js ***!
  \****************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

const readWasm = __webpack_require__(/*! ../lib/read-wasm */ "../../node_modules/dd-trace/node_modules/source-map/lib/read-wasm.js");

/**
 * Provide the JIT with a nice shape / hidden class.
 */
function Mapping() {
  this.generatedLine = 0;
  this.generatedColumn = 0;
  this.lastGeneratedColumn = null;
  this.source = null;
  this.originalLine = null;
  this.originalColumn = null;
  this.name = null;
}

let cachedWasm = null;

module.exports = function wasm() {
  if (cachedWasm) {
    return cachedWasm;
  }

  const callbackStack = [];

  cachedWasm = readWasm().then(buffer => {
      return WebAssembly.instantiate(buffer, {
        env: {
          mapping_callback(
            generatedLine,
            generatedColumn,

            hasLastGeneratedColumn,
            lastGeneratedColumn,

            hasOriginal,
            source,
            originalLine,
            originalColumn,

            hasName,
            name
          ) {
            const mapping = new Mapping();
            // JS uses 1-based line numbers, wasm uses 0-based.
            mapping.generatedLine = generatedLine + 1;
            mapping.generatedColumn = generatedColumn;

            if (hasLastGeneratedColumn) {
              // JS uses inclusive last generated column, wasm uses exclusive.
              mapping.lastGeneratedColumn = lastGeneratedColumn - 1;
            }

            if (hasOriginal) {
              mapping.source = source;
              // JS uses 1-based line numbers, wasm uses 0-based.
              mapping.originalLine = originalLine + 1;
              mapping.originalColumn = originalColumn;

              if (hasName) {
                mapping.name = name;
              }
            }

            callbackStack[callbackStack.length - 1](mapping);
          },

          start_all_generated_locations_for() { console.time("all_generated_locations_for"); },
          end_all_generated_locations_for() { console.timeEnd("all_generated_locations_for"); },

          start_compute_column_spans() { console.time("compute_column_spans"); },
          end_compute_column_spans() { console.timeEnd("compute_column_spans"); },

          start_generated_location_for() { console.time("generated_location_for"); },
          end_generated_location_for() { console.timeEnd("generated_location_for"); },

          start_original_location_for() { console.time("original_location_for"); },
          end_original_location_for() { console.timeEnd("original_location_for"); },

          start_parse_mappings() { console.time("parse_mappings"); },
          end_parse_mappings() { console.timeEnd("parse_mappings"); },

          start_sort_by_generated_location() { console.time("sort_by_generated_location"); },
          end_sort_by_generated_location() { console.timeEnd("sort_by_generated_location"); },

          start_sort_by_original_location() { console.time("sort_by_original_location"); },
          end_sort_by_original_location() { console.timeEnd("sort_by_original_location"); },
        }
      });
  }).then(Wasm => {
    return {
      exports: Wasm.instance.exports,
      withMappingCallback: (mappingCallback, f) => {
        callbackStack.push(mappingCallback);
        try {
          f();
        } finally {
          callbackStack.pop();
        }
      }
    };
  }).then(null, e => {
    cachedWasm = null;
    throw e;
  });

  return cachedWasm;
};


/***/ }),

/***/ "../../node_modules/dd-trace/node_modules/source-map/source-map.js":
/*!******************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/node_modules/source-map/source-map.js ***!
  \******************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

/*
 * Copyright 2009-2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE.txt or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
exports.SourceMapGenerator = __webpack_require__(/*! ./lib/source-map-generator */ "../../node_modules/dd-trace/node_modules/source-map/lib/source-map-generator.js").SourceMapGenerator;
exports.SourceMapConsumer = __webpack_require__(/*! ./lib/source-map-consumer */ "../../node_modules/dd-trace/node_modules/source-map/lib/source-map-consumer.js").SourceMapConsumer;
exports.SourceNode = __webpack_require__(/*! ./lib/source-node */ "../../node_modules/dd-trace/node_modules/source-map/lib/source-node.js").SourceNode;


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-core/index.js":
false,

/***/ "../../node_modules/dd-trace/packages/datadog-core/src/storage/async_hooks.js":
false,

/***/ "../../node_modules/dd-trace/packages/datadog-core/src/storage/async_resource.js":
false,

/***/ "../../node_modules/dd-trace/packages/datadog-core/src/storage/index.js":
false,

/***/ "../../node_modules/dd-trace/packages/datadog-instrumentations/index.js":
false,

/***/ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/amqp10.js":
false,

/***/ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/amqplib.js":
false,

/***/ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/bluebird.js":
false,

/***/ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/bunyan.js":
false,

/***/ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/cassandra-driver.js":
false,

/***/ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/couchbase.js":
false,

/***/ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/cucumber.js":
false,

/***/ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/dns.js":
false,

/***/ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/elasticsearch.js":
false,

/***/ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/generic-pool.js":
false,

/***/ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/helpers/hook.js":
false,

/***/ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/helpers/instrument.js":
false,

/***/ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/helpers/promise.js":
false,

/***/ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/http.js":
false,

/***/ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/http/client.js":
false,

/***/ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/http/server.js":
false,

/***/ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/ioredis.js":
false,

/***/ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/memcached.js":
false,

/***/ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/mocha.js":
false,

/***/ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/mongodb-core.js":
false,

/***/ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/mongoose.js":
false,

/***/ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/mysql.js":
false,

/***/ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/mysql2.js":
false,

/***/ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/net.js":
false,

/***/ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/pg.js":
false,

/***/ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/pino.js":
false,

/***/ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/promise-js.js":
false,

/***/ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/promise.js":
false,

/***/ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/q.js":
false,

/***/ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/redis.js":
false,

/***/ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/rhea.js":
false,

/***/ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/sharedb.js":
false,

/***/ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/tedious.js":
false,

/***/ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/when.js":
false,

/***/ "../../node_modules/dd-trace/packages/datadog-instrumentations/src/winston.js":
false,

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-amqp10/src/index.js":
/*!************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-amqp10/src/index.js ***!
  \************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const analyticsSampler = __webpack_require__(/*! ../../dd-trace/src/analytics_sampler */ "../../node_modules/dd-trace/packages/dd-trace/src/analytics_sampler.js")

function createWrapSend (tracer, config) {
  return function wrapSend (send) {
    return function sendWithTrace (msg, options) {
      const span = startSendSpan(tracer, config, this)

      try {
        const promise = tracer.scope().activate(span, () => {
          return send.apply(this, arguments)
        })

        return wrapPromise(promise, span)
      } catch (e) {
        finish(span, e)
        throw e
      }
    }
  }
}

function createWrapMessageReceived (tracer, config) {
  return function wrapMessageReceived (messageReceived) {
    return function messageReceivedWithTrace (transferFrame) {
      if (!transferFrame || transferFrame.aborted || transferFrame.more) {
        return messageReceived.apply(this, arguments)
      }

      const span = startReceiveSpan(tracer, config, this)

      return tracer.scope().activate(span, () => {
        messageReceived.apply(this, arguments)
        span.finish()
      })
    }
  }
}

function startSendSpan (tracer, config, link) {
  const address = getAddress(link)
  const target = getShortName(link)

  const span = tracer.startSpan(`amqp.send`, {
    tags: {
      'resource.name': ['send', target].filter(v => v).join(' '),
      'span.kind': 'producer',
      'amqp.link.target.address': target,
      'amqp.link.role': 'sender',
      'out.host': address.host,
      'out.port': address.port
    }
  })

  addTags(tracer, config, span, link)

  analyticsSampler.sample(span, config.analytics)

  return span
}

function startReceiveSpan (tracer, config, link) {
  const source = getShortName(link)
  const span = tracer.startSpan(`amqp.receive`, {
    tags: {
      'resource.name': ['receive', source].filter(v => v).join(' '),
      'span.kind': 'consumer',
      'amqp.link.source.address': source,
      'amqp.link.role': 'receiver'
    }
  })

  addTags(tracer, config, span, link)

  analyticsSampler.sample(span, config.analytics, true)

  return span
}

function addTags (tracer, config, span, link = {}) {
  const address = getAddress(link)

  span.addTags({
    'service.name': config.service || `${tracer._service}-amqp`,
    'span.type': 'worker',
    'amqp.link.name': link.name,
    'amqp.link.handle': link.handle,
    'amqp.connection.host': address.host,
    'amqp.connection.port': address.port,
    'amqp.connection.user': address.user
  })

  return span
}

function finish (span, error) {
  if (error) {
    span.addTags({
      'error.type': error.name,
      'error.msg': error.message,
      'error.stack': error.stack
    })
  }

  span.finish()
}

function wrapPromise (promise, span) {
  if (!promise) {
    finish(span)
    return promise
  }

  promise.then(() => finish(span), e => finish(span, e))

  return promise
}

function getShortName (link) {
  if (!link || !link.name) return null

  return link.name.split('_').slice(0, -1).join('_')
}

function getAddress (link) {
  if (!link || !link.session || !link.session.connection) return {}

  return link.session.connection.address || {}
}

module.exports = [
  {
    name: 'amqp10',
    file: 'lib/sender_link.js',
    versions: ['>=3'],
    patch (SenderLink, tracer, config) {
      this.wrap(SenderLink.prototype, 'send', createWrapSend(tracer, config))
    },
    unpatch (SenderLink) {
      this.unwrap(SenderLink.prototype, 'send')
    }
  },
  {
    name: 'amqp10',
    file: 'lib/receiver_link.js',
    versions: ['>=3'],
    patch (ReceiverLink, tracer, config) {
      this.wrap(ReceiverLink.prototype, '_messageReceived', createWrapMessageReceived(tracer, config))
    },
    unpatch (ReceiverLink) {
      this.unwrap(ReceiverLink.prototype, '_messageReceived')
    }
  }
]


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-amqplib/src/index.js":
/*!*************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-amqplib/src/index.js ***!
  \*************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const kebabCase = __webpack_require__(/*! lodash.kebabcase */ "../../node_modules/lodash.kebabcase/index.js")
const analyticsSampler = __webpack_require__(/*! ../../dd-trace/src/analytics_sampler */ "../../node_modules/dd-trace/packages/dd-trace/src/analytics_sampler.js")
const { TEXT_MAP } = __webpack_require__(/*! ../../../ext/formats */ "../../node_modules/dd-trace/ext/formats.js")

let methods = {}

function createWrapSendImmediately (tracer, config) {
  return function wrapSendImmediately (sendImmediately) {
    return function sendImmediatelyWithTrace (method, fields) {
      return sendWithTrace(sendImmediately, this, arguments, tracer, config, methods[method], fields)
    }
  }
}

function createWrapSendMessage (tracer, config) {
  return function wrapSendMessage (sendMessage) {
    return function sendMessageWithTrace (fields) {
      return sendWithTrace(sendMessage, this, arguments, tracer, config, 'basic.publish', fields)
    }
  }
}

function createWrapDispatchMessage (tracer, config) {
  return function wrapDispatchMessage (dispatchMessage) {
    return function dispatchMessageWithTrace (fields, message) {
      const childOf = extract(tracer, message)
      const span = tracer.startSpan('amqp.command', { childOf })

      addTags(this, tracer, config, span, 'basic.deliver', fields)

      analyticsSampler.sample(span, config.analytics, true)

      tracer.scope().activate(span, () => {
        try {
          dispatchMessage.apply(this, arguments)
        } catch (e) {
          throw addError(span, e)
        } finally {
          span.finish()
        }
      })
    }
  }
}

function sendWithTrace (send, channel, args, tracer, config, method, fields) {
  const childOf = tracer.scope().active()
  const span = tracer.startSpan('amqp.command', { childOf })

  fields.headers = fields.headers || {}

  addTags(channel, tracer, config, span, method, fields)
  tracer.inject(span, TEXT_MAP, fields.headers)

  analyticsSampler.sample(span, config.analytics)

  return tracer.scope().activate(span, () => {
    try {
      return send.apply(channel, args)
    } catch (e) {
      throw addError(span, e)
    } finally {
      span.finish()
    }
  })
}

function isCamelCase (str) {
  return /([A-Z][a-z0-9]+)+/.test(str)
}

function getResourceName (method, fields = {}) {
  return [
    method,
    fields.exchange,
    fields.routingKey,
    fields.queue,
    fields.source,
    fields.destination
  ].filter(val => val).join(' ')
}

function addError (span, error) {
  span.addTags({
    'error.type': error.name,
    'error.msg': error.message,
    'error.stack': error.stack
  })

  return error
}

function addTags (channel, tracer, config, span, method, fields) {
  const fieldNames = [
    'queue',
    'exchange',
    'routingKey',
    'consumerTag',
    'source',
    'destination'
  ]

  span.addTags({
    'service.name': config.service || `${tracer._service}-amqp`,
    'resource.name': getResourceName(method, fields),
    'span.type': 'worker'
  })

  if (channel && channel.connection && channel.connection.stream) {
    span.addTags({
      'out.host': channel.connection.stream._host,
      'out.port': channel.connection.stream.remotePort
    })
  }

  switch (method) {
    case 'basic.publish':
      span.setTag('span.kind', 'producer')
      break
    case 'basic.consume':
    case 'basic.get':
    case 'basic.deliver':
      span.setTag('span.kind', 'consumer')
      break
  }

  fieldNames.forEach(field => {
    fields[field] !== undefined && span.setTag(`amqp.${field}`, fields[field])
  })
}

function extract (tracer, message) {
  return message
    ? tracer.extract(TEXT_MAP, message.properties.headers)
    : null
}

module.exports = [
  {
    name: 'amqplib',
    file: 'lib/defs.js',
    versions: ['>=0.5'],
    patch (defs, tracer, config) {
      methods = Object.keys(defs)
        .filter(key => Number.isInteger(defs[key]))
        .filter(key => isCamelCase(key))
        .reduce((acc, key) => Object.assign(acc, { [defs[key]]: kebabCase(key).replace('-', '.') }), {})
    },
    unpatch (defs) {
      methods = {}
    }
  },
  {
    name: 'amqplib',
    file: 'lib/channel.js',
    versions: ['>=0.5'],
    patch (channel, tracer, config) {
      this.wrap(channel.Channel.prototype, 'sendImmediately', createWrapSendImmediately(tracer, config))
      this.wrap(channel.Channel.prototype, 'sendMessage', createWrapSendMessage(tracer, config))
      this.wrap(channel.BaseChannel.prototype, 'dispatchMessage', createWrapDispatchMessage(tracer, config))
    },
    unpatch (channel) {
      this.unwrap(channel.Channel.prototype, 'sendImmediately')
      this.unwrap(channel.Channel.prototype, 'sendMessage')
      this.unwrap(channel.BaseChannel.prototype, 'dispatchMessage')
    }
  }
]


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/helpers.js":
/*!***************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/helpers.js ***!
  \***************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Tags = __webpack_require__(/*! opentracing */ "../../node_modules/opentracing/lib/index.js").Tags

const services = {
  cloudwatchlogs: getService('cloudwatchlogs'),
  dynamodb: getService('dynamodb'),
  kinesis: getService('kinesis'),
  s3: getService('s3'),
  redshift: getService('redshift'),
  sns: getService('sns'),
  sqs: getService('sqs')
}

function getService (serviceName) {
  const Service = __webpack_require__("../../node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/services sync recursive ^\\.\\/.*$")(`./${serviceName}`)
  return new Service()
}

const helpers = {
  finish (span, err) {
    if (err) {
      span.setTag('error', err)

      if (err.requestId) {
        span.addTags({ 'aws.response.request_id': err.requestId })
      }
    }

    span.finish()
  },

  addResponseTags (span, response, serviceName, config) {
    if (!span) return

    if (response.request) {
      this.addServicesTags(span, response, serviceName)
    }

    config.hooks.request(span, response)
  },

  addServicesTags (span, response, serviceName) {
    if (!span) return

    const params = response.request.params
    const operation = response.request.operation
    const extraTags = services[serviceName] ? services[serviceName].generateTags(params, operation, response) : {}
    const tags = Object.assign({
      'aws.response.request_id': response.requestId,
      'resource.name': operation
    }, extraTags)

    span.addTags(tags)
  },

  responseExtract (serviceName, request, response, tracer) {
    if (services[serviceName] && services[serviceName].responseExtract) {
      const params = request.params
      const operation = request.operation
      return services[serviceName].responseExtract(params, operation, response, tracer)
    }
  },

  requestInject (span, request, serviceName, tracer) {
    if (!span) return

    const inject = services[serviceName] && services[serviceName].requestInject
    if (inject) inject(span, request, tracer)
  },

  wrapCb (cb, serviceName, tags, request, tracer, childOf) {
    const awsHelpers = this
    return function wrappedCb (err, resp) {
      const maybeChildOf = awsHelpers.responseExtract(serviceName, request, resp, tracer)
      if (maybeChildOf) {
        const options = {
          childOf: maybeChildOf,
          tags: Object.assign({}, tags, { [Tags.SPAN_KIND]: 'server' })
        }
        return tracer.wrap('aws.response', options, cb).call(this, err, resp)
      } else {
        return tracer.scope().bind(cb, childOf).call(this, err, resp)
      }
    }
  }
}

module.exports = helpers


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/index.js":
/*!*************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/index.js ***!
  \*************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Tags = __webpack_require__(/*! opentracing */ "../../node_modules/opentracing/lib/index.js").Tags
const analyticsSampler = __webpack_require__(/*! ../../dd-trace/src/analytics_sampler */ "../../node_modules/dd-trace/packages/dd-trace/src/analytics_sampler.js")
const awsHelpers = __webpack_require__(/*! ./helpers */ "../../node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/helpers.js")

function createWrapRequest (tracer, config) {
  config = normalizeConfig(config)

  return function wrapRequest (send) {
    return function requestWithTrace (cb) {
      if (!this.service) return send.apply(this, arguments)

      const serviceIdentifier = this.service.serviceIdentifier
      const serviceName = getServiceName(serviceIdentifier, tracer, config)
      const childOf = tracer.scope().active()
      const tags = {
        [Tags.SPAN_KIND]: 'client',
        'service.name': serviceName,
        'aws.operation': this.operation,
        'aws.region': this.service.config && this.service.config.region,
        'aws.service': this.service.api && this.service.api.className,
        'component': 'aws-sdk'
      }

      const span = tracer.startSpan('aws.request', {
        childOf,
        tags
      })

      this.on('complete', response => {
        if (!span) return

        awsHelpers.addResponseTags(span, response, serviceIdentifier, config, tracer)
        awsHelpers.finish(span, response.error)
      })

      analyticsSampler.sample(span, config.analytics)

      awsHelpers.requestInject(span, this, serviceIdentifier, tracer)

      const request = this

      return tracer.scope().activate(span, () => {
        let boundCb
        if (typeof cb === 'function') {
          boundCb = awsHelpers.wrapCb(cb, serviceIdentifier, tags, request, tracer, childOf)
        } else {
          boundCb = cb
        }
        return send.call(this, boundCb)
      })
    }
  }
}

function createWrapSetPromisesDependency (tracer, config, instrumenter, AWS) {
  return function wrapSetPromisesDependency (setPromisesDependency) {
    return function setPromisesDependencyWithTrace (dep) {
      const result = setPromisesDependency.apply(this, arguments)

      instrumenter.wrap(AWS.Request.prototype, 'promise', createWrapRequest(tracer, config))

      return result
    }
  }
}

function normalizeConfig (config) {
  const hooks = getHooks(config)

  return Object.assign({}, config, {
    splitByAwsService: config.splitByAwsService !== false,
    hooks
  })
}

function getHooks (config) {
  const noop = () => {}
  const request = (config.hooks && config.hooks.request) || noop

  return { request }
}

// TODO: test splitByAwsService when the test suite is fixed
function getServiceName (serviceIdentifier, tracer, config) {
  const service = config.service || tracer._service

  return config.splitByAwsService
    ? `${service}-aws-${serviceIdentifier}`
    : service
}

// <2.1.35 has breaking changes for instrumentation
// https://github.com/aws/aws-sdk-js/pull/629
module.exports = [
  {
    name: 'aws-sdk',
    versions: ['>=2.3.0'],
    patch (AWS, tracer, config) {
      this.wrap(AWS.Request.prototype, 'promise', createWrapRequest(tracer, config))
      this.wrap(AWS.config, 'setPromisesDependency', createWrapSetPromisesDependency(tracer, config, this, AWS))
    },
    unpatch (AWS) {
      this.unwrap(AWS.Request.prototype, 'promise')
      this.unwrap(AWS.config, 'setPromisesDependency')
    }
  },
  {
    name: 'aws-sdk',
    versions: ['>=2.1.35'],
    patch (AWS, tracer, config) {
      this.wrap(AWS.Request.prototype, 'send', createWrapRequest(tracer, config))
    },
    unpatch (AWS) {
      this.wrap(AWS.Request.prototype, 'send')
    }
  }
]


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/services sync recursive ^\\.\\/.*$":
/*!***************************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/services sync ^\.\/.*$ ***!
  \***************************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var map = {
	"./cloudwatchlogs": "../../node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/services/cloudwatchlogs.js",
	"./cloudwatchlogs.js": "../../node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/services/cloudwatchlogs.js",
	"./dynamodb": "../../node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/services/dynamodb.js",
	"./dynamodb.js": "../../node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/services/dynamodb.js",
	"./kinesis": "../../node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/services/kinesis.js",
	"./kinesis.js": "../../node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/services/kinesis.js",
	"./redshift": "../../node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/services/redshift.js",
	"./redshift.js": "../../node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/services/redshift.js",
	"./s3": "../../node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/services/s3.js",
	"./s3.js": "../../node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/services/s3.js",
	"./sns": "../../node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/services/sns.js",
	"./sns.js": "../../node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/services/sns.js",
	"./sqs": "../../node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/services/sqs.js",
	"./sqs.js": "../../node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/services/sqs.js"
};


function webpackContext(req) {
	var id = webpackContextResolve(req);
	return __webpack_require__(id);
}
function webpackContextResolve(req) {
	if(!__webpack_require__.o(map, req)) {
		var e = new Error("Cannot find module '" + req + "'");
		e.code = 'MODULE_NOT_FOUND';
		throw e;
	}
	return map[req];
}
webpackContext.keys = function webpackContextKeys() {
	return Object.keys(map);
};
webpackContext.resolve = webpackContextResolve;
module.exports = webpackContext;
webpackContext.id = "../../node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/services sync recursive ^\\.\\/.*$";

/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/services/eventbridge.js":
false,

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/services/kinesis.js":
/*!************************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/services/kinesis.js ***!
  \************************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


class Kinesis {
  generateTags (params, operation, response) {
    const tags = {}

    if (!params || !params.StreamName) return tags

    return Object.assign(tags, {
      'resource.name': `${operation} ${params.StreamName}`,
      'aws.kinesis.stream_name': params.StreamName
    })
  }
}

module.exports = Kinesis


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/services/lambda.js":
false,

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/services/sns.js":
/*!********************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/services/sns.js ***!
  \********************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


class Sns {
  generateTags (params, operation, response) {
    const tags = {}

    if (!params) return tags

    if (!params.TopicArn && !(response.data && response.data.TopicArn)) return tags

    return Object.assign(tags, {
      'resource.name': `${operation} ${params.TopicArn || response.data.TopicArn}`,
      'aws.sns.topic_arn': params.TopicArn || response.data.TopicArn
    })

    // TODO: should arn be sanitized or quantized in some way here,
    // for example if it contains a phone number?
  }
}

module.exports = Sns


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/services/sqs.js":
/*!********************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/services/sqs.js ***!
  \********************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const log = __webpack_require__(/*! ../../../dd-trace/src/log */ "../../node_modules/dd-trace/packages/dd-trace/src/log.js")

class Sqs {
  generateTags (params, operation, response) {
    const tags = {}

    if (!params || (!params.QueueName && !params.QueueUrl)) return tags

    return Object.assign(tags, {
      'resource.name': `${operation} ${params.QueueName || params.QueueUrl}`,
      'aws.sqs.queue_name': params.QueueName || params.QueueUrl
    })
  }

  responseExtract (params, operation, response, tracer) {
    if (operation === 'receiveMessage') {
      if (
        (!params.MaxNumberOfMessages || params.MaxNumberOfMessages === 1) &&
        response &&
        response.Messages &&
        response.Messages[0] &&
        response.Messages[0].MessageAttributes &&
        response.Messages[0].MessageAttributes._datadog &&
        response.Messages[0].MessageAttributes._datadog.StringValue
      ) {
        const textMap = response.Messages[0].MessageAttributes._datadog.StringValue
        try {
          return tracer.extract('text_map', JSON.parse(textMap))
        } catch (err) {
          log.error(err)
          return undefined
        }
      }
    }
  }

  requestInject (span, request, tracer) {
    const operation = request.operation
    if (operation === 'sendMessage') {
      if (!request.params) {
        request.params = {}
      }
      if (!request.params.MessageAttributes) {
        request.params.MessageAttributes = {}
      } else if (Object.keys(request.params.MessageAttributes).length >= 10) { // SQS quota
        // TODO: add test when the test suite is fixed
        return
      }
      const ddInfo = {}
      tracer.inject(span, 'text_map', ddInfo)
      request.params.MessageAttributes._datadog = {
        DataType: 'String',
        StringValue: JSON.stringify(ddInfo)
      }
    }
  }
}

module.exports = Sqs


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-bluebird/src/index.js":
/*!**************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-bluebird/src/index.js ***!
  \**************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const tx = __webpack_require__(/*! ../../dd-trace/src/plugins/util/promise */ "../../node_modules/dd-trace/packages/dd-trace/src/plugins/util/promise.js")

const DD_LIB_COPIES = '_datadog_library_copies'

function createGetNewLibraryCopyWrap (tracer, config, originalLib, shim) {
  return function wrapGetNewLibraryCopy (getNewLibraryCopy) {
    return function getNewLibraryCopyWithTrace () {
      const libraryCopy = getNewLibraryCopy.apply(this, arguments)
      shim.wrap(libraryCopy.prototype, '_then', tx.createWrapThen(tracer, config))
      shim.wrap(libraryCopy, 'getNewLibraryCopy', createGetNewLibraryCopyWrap(tracer, config, originalLib, shim))
      addToLibraryCopies(originalLib, libraryCopy)
      return libraryCopy
    }
  }
}

function addToLibraryCopies (originalLib, libraryCopy) {
  let libraryCopies = originalLib[DD_LIB_COPIES]

  if (!libraryCopies) {
    libraryCopies = new Set()

    Object.defineProperty(originalLib, DD_LIB_COPIES, {
      writable: true,
      configurable: true,
      value: libraryCopies
    })
  }
  libraryCopies.add(libraryCopy)
}

function unwrapLibraryCopies (originalLib, shim) {
  const libraryCopies = originalLib[DD_LIB_COPIES]

  if (libraryCopies) {
    libraryCopies.forEach(libraryCopy => {
      shim.unwrap(libraryCopy.prototype, '_then')
      shim.unwrap(libraryCopy, 'getNewLibraryCopy')
    })
    libraryCopies.clear()
    delete originalLib[DD_LIB_COPIES]
  }
}

module.exports = [
  {
    name: 'bluebird',
    versions: ['^2.11.0', '^3.4.1'],
    patch (Promise, tracer, config) {
      this.wrap(Promise, 'getNewLibraryCopy', createGetNewLibraryCopyWrap(tracer, config, Promise, this))
    },
    unpatch (Promise) {
      this.unwrap(Promise, 'getNewLibraryCopy')
      unwrapLibraryCopies(Promise, this)
    }
  },
  {
    name: 'bluebird',
    versions: ['>=2.0.2'], // 2.0.0 and 2.0.1 were removed from npm
    patch (Promise, tracer, config) {
      this.wrap(Promise.prototype, '_then', tx.createWrapThen(tracer, config))
    },
    unpatch (Promise) {
      this.unwrap(Promise.prototype, '_then')
    }
  }
]


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-bunyan/src/index.js":
/*!************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-bunyan/src/index.js ***!
  \************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const { LOG } = __webpack_require__(/*! ../../../ext/formats */ "../../node_modules/dd-trace/ext/formats.js")

function createWrapEmit (tracer, config) {
  return function wrapEmit (emit) {
    return function emitWithTrace (rec, noemit) {
      const span = tracer.scope().active()

      tracer.inject(span, LOG, rec)

      return emit.apply(this, arguments)
    }
  }
}

module.exports = {
  name: 'bunyan',
  versions: ['>=1'],
  patch (Logger, tracer, config) {
    if (!tracer._logInjection) return
    this.wrap(Logger.prototype, '_emit', createWrapEmit(tracer, config))
  },
  unpatch (Logger) {
    this.unwrap(Logger.prototype, '_emit')
  }
}


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-cassandra-driver/src/index.js":
/*!**********************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-cassandra-driver/src/index.js ***!
  \**********************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const tx = __webpack_require__(/*! ../../dd-trace/src/plugins/util/tx */ "../../node_modules/dd-trace/packages/dd-trace/src/plugins/util/tx.js")

function createWrapInnerExecute (tracer, config) {
  const isValid = (args) => {
    return args.length === 4 || typeof args[3] === 'function'
  }

  return function wrapInnerExecute (_innerExecute) {
    return function _innerExecuteWithTrace (query, params, execOptions, callback) {
      if (!isValid(arguments)) {
        return _innerExecute.apply(this, arguments)
      }

      const scope = tracer.scope()
      const childOf = scope.active()
      const span = start(tracer, config, this, query)

      callback = scope.bind(callback, childOf)

      return scope.bind(_innerExecute, span).call(this, query, params, execOptions, function (err) {
        finish(span, err)
        return callback.apply(this, arguments)
      })
    }
  }
}
function createWrapExecute (tracer, config) {
  return function wrapExecute (_execute) {
    return function _executeWithTrace (query, params, execOptions, callback) {
      const span = start(tracer, config, this, query)
      const promise = tracer.scope().bind(_execute, span).apply(this, arguments)

      return tx.wrap(span, promise)
    }
  }
}

function createWrapExecutionStart (tracer, config) {
  return function wrapExecutionStart (start) {
    return function startWithTrace (getHostCallback) {
      const span = tracer.scope().active()
      const execution = this

      if (!isRequestValid(this, arguments, 1, span)) {
        return start.apply(this, arguments)
      }

      return start.call(this, function () {
        addHost(span, execution._connection)
        return getHostCallback.apply(this, arguments)
      })
    }
  }
}

function createWrapSendOnConnection (tracer, config) {
  return function wrapSendOnConnection (_sendOnConnection) {
    return function _sendOnConnectionWithTrace () {
      const span = tracer.scope().active()

      addHost(span, this._connection)

      return _sendOnConnection.apply(this, arguments)
    }
  }
}

function createWrapSend (tracer, config) {
  return function wrapSend (send) {
    return function sendWithTrace (request, options, callback) {
      const span = tracer.scope().active()
      const handler = this

      if (!isRequestValid(this, arguments, 3, span)) {
        return send.apply(this, arguments)
      }

      return send.call(this, request, options, function () {
        addHost(span, handler.connection)
        return callback.apply(this, arguments)
      })
    }
  }
}

function createWrapBatch (tracer, config) {
  return function wrapBatch (batch) {
    return function batchWithTrace (queries, options, callback) {
      const query = combine(queries)
      const span = start(tracer, config, this, query)
      const scope = tracer.scope()
      const fn = scope.bind(batch, span)

      callback = arguments[arguments.length - 1]

      if (typeof callback === 'function') {
        arguments[arguments.length - 1] = tx.wrap(span, callback)
      }

      try {
        return tx.wrap(span, fn.apply(this, arguments))
      } catch (e) {
        finish(span, e)
        throw e
      }
    }
  }
}

function createWrapStream (tracer, config) {
  return function wrapStream (stream) {
    return function streamWithTrace (query, params, options, callback) {
      return tracer.scope().bind(stream.apply(this, arguments))
    }
  }
}

function start (tracer, config, client = {}, query) {
  const scope = tracer.scope()
  const childOf = scope.active()
  const span = tracer.startSpan('cassandra.query', {
    childOf,
    tags: {
      'service.name': config.service || `${tracer._service}-cassandra`,
      'resource.name': trim(query, 5000),
      'span.type': 'cassandra',
      'span.kind': 'client',
      'db.type': 'cassandra',
      'cassandra.query': query,
      'cassandra.keyspace': client.keyspace
    }
  })

  return span
}

function finish (span, error) {
  addError(span, error)

  span.finish()

  return error
}

function addTag (span, key, value) {
  if (value) {
    span.setTag(key, value)
  }
}

function addHost (span, connection) {
  if (span && connection) {
    addTag(span, 'out.host', connection.address)
    addTag(span, 'out.port', connection.port)
  }
}

function addError (span, error) {
  if (error && error instanceof Error) {
    span.addTags({
      'error.type': error.name,
      'error.msg': error.message,
      'error.stack': error.stack
    })
  }

  return error
}

function isRequestValid (exec, args, length, span) {
  if (!exec) return false
  if (args.length !== length || typeof args[length - 1] !== 'function') return false
  if (!span || span.context()._name !== 'cassandra.query') return false

  return true
}

function combine (queries) {
  if (!Array.isArray(queries)) return []

  return queries
    .map(query => (query.query || query).replace(/;?$/, ';'))
    .join(' ')
}

function trim (str, size) {
  if (!str || str.length <= size) return str

  return `${str.substr(0, size - 3)}...`
}

module.exports = [
  {
    name: 'cassandra-driver',
    versions: ['>=3.0.0'],
    patch (cassandra, tracer, config) {
      this.wrap(cassandra.Client.prototype, 'batch', createWrapBatch(tracer, config))
      this.wrap(cassandra.Client.prototype, 'stream', createWrapStream(tracer, config))
    },
    unpatch (cassandra) {
      this.unwrap(cassandra.Client.prototype, 'batch')
      this.unwrap(cassandra.Client.prototype, 'stream')
    }
  },
  {
    name: 'cassandra-driver',
    versions: ['>=4.4'],
    patch (cassandra, tracer, config) {
      this.wrap(cassandra.Client.prototype, '_execute', createWrapExecute(tracer, config))
    },
    unpatch (cassandra) {
      this.unwrap(cassandra.Client.prototype, '_execute')
    }
  },
  {
    name: 'cassandra-driver',
    versions: ['3 - 4.3'],
    patch (cassandra, tracer, config) {
      this.wrap(cassandra.Client.prototype, '_innerExecute', createWrapInnerExecute(tracer, config))
    },
    unpatch (cassandra) {
      this.unwrap(cassandra.Client.prototype, '_innerExecute')
    }
  },
  {
    name: 'cassandra-driver',
    versions: ['>=3.3'],
    file: 'lib/request-execution.js',
    patch (RequestExecution, tracer, config) {
      this.wrap(RequestExecution.prototype, '_sendOnConnection', createWrapSendOnConnection(tracer, config))
    },
    unpatch (RequestExecution) {
      this.unwrap(RequestExecution.prototype, '_sendOnConnection')
    }
  },
  {
    name: 'cassandra-driver',
    versions: ['3.3 - 4.3'],
    file: 'lib/request-execution.js',
    patch (RequestExecution, tracer, config) {
      this.wrap(RequestExecution.prototype, 'start', createWrapExecutionStart(tracer, config))
    },
    unpatch (RequestExecution) {
      this.unwrap(RequestExecution.prototype, 'start')
    }
  },
  {
    name: 'cassandra-driver',
    versions: ['3 - 3.2'],
    file: 'lib/request-handler.js',
    patch (RequestHandler, tracer, config) {
      this.wrap(RequestHandler.prototype, 'send', createWrapSend(tracer, config))
    },
    unpatch (RequestHandler) {
      this.unwrap(RequestHandler.prototype, 'send')
    }
  }
]


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-couchbase/src/index.js":
/*!***************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-couchbase/src/index.js ***!
  \***************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Tags = __webpack_require__(/*! ../../../ext/tags */ "../../node_modules/dd-trace/ext/tags.js")
const Kinds = __webpack_require__(/*! ../../../ext/kinds */ "../../node_modules/dd-trace/ext/kinds.js")
const analyticsSampler = __webpack_require__(/*! ../../dd-trace/src/analytics_sampler */ "../../node_modules/dd-trace/packages/dd-trace/src/analytics_sampler.js")

function startQuerySpan (tracer, config, query) {
  const childOf = tracer.scope().active()
  const span = tracer.startSpan('couchbase.query', {
    childOf,
    tags: {
      'db.type': 'couchbase',
      'span.type': 'sql',
      'component': 'couchbase',
      'service.name': config.service || `${tracer._service}-couchbase`,
      'resource.name': query,
      [Tags.SPAN_KIND]: Kinds.CLIENT
    }
  })

  analyticsSampler.sample(span, config.analytics)

  return span
}

function onRequestFinish (emitter, span) {
  emitter.once('rows', () => {
    span.finish()
  })
  emitter.once('error', (err) => {
    span.setTag(Tags.ERROR, err)
    span.finish()
  })
}

function createWrapMaybeInvoke (tracer) {
  return function wrapMaybeInvoke (_maybeInvoke) {
    return function maybeInvokeWithTrace (fn, args) {
      if (!Array.isArray(args)) return _maybeInvoke.apply(this, arguments)

      const scope = tracer.scope()
      const callbackIndex = args.length - 1
      const callback = args[callbackIndex]

      if (callback instanceof Function) {
        args[callbackIndex] = scope.bind(callback)
      }

      return scope.bind(_maybeInvoke).apply(this, arguments)
    }
  }
}

function createWrapQuery (tracer) {
  return function wrapQuery (query) {
    return function queryWithTrace (q, params, callback) {
      const scope = tracer.scope()

      callback = arguments[arguments.length - 1]

      if (typeof callback === 'function') {
        arguments[arguments.length - 1] = scope.bind(callback)
      }

      return scope.bind(query.apply(this, arguments))
    }
  }
}

function createWrapN1qlReq (tracer, config) {
  return function wrapN1qlReq (_n1qlReq) {
    return function n1qlReqWithTrace (host, q, adhoc, emitter) {
      if (!emitter || !emitter.once) return _n1qlReq.apply(this, arguments)

      const scope = tracer.scope()
      const n1qlQuery = q && q.statement
      const span = startQuerySpan(tracer, config, n1qlQuery)

      addBucketTag(span, this)
      onRequestFinish(emitter, span)

      return scope.bind(_n1qlReq, span).apply(this, arguments)
    }
  }
}

function addBucketTag (span, bucket) {
  span.setTag('couchbase.bucket.name', bucket.name || bucket._name)
}

function wrapRequests (Class, tracer, config) {
  this.wrap(Class.prototype, '_n1qlReq', createWrapN1qlReq(tracer, config))
}

function unwrapRequests (Class) {
  this.unwrap(Class.prototype, '_n1qlReq')
}

function wrapCouchbase (Class, tracer, config) {
  this.wrap(Class.prototype, '_maybeInvoke', createWrapMaybeInvoke(tracer, config))
  this.wrap(Class.prototype, 'query', createWrapQuery(tracer))
}

function unwrapCouchbase (Class) {
  this.unwrap(Class.prototype, '_maybeInvoke')
  this.unwrap(Class.prototype, 'query')
}

module.exports = [
  {
    name: 'couchbase',
    versions: ['^2.4.2'],
    file: 'lib/bucket.js',
    patch (Bucket, tracer, config) {
      tracer.scope().bind(Bucket.prototype)

      wrapCouchbase.call(this, Bucket, tracer, config)
      wrapRequests.call(this, Bucket, tracer, config)
    },
    unpatch (Bucket, tracer) {
      tracer.scope().unbind(Bucket.prototype)

      unwrapCouchbase.call(this, Bucket)
      unwrapRequests.call(this, Bucket)
    }
  },
  {
    name: 'couchbase',
    versions: ['^2.4.2'],
    file: 'lib/cluster.js',
    patch: wrapCouchbase,
    unpatch: unwrapCouchbase
  }
]


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-cucumber/src/index.js":
false,

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-cypress/src/index.js":
false,

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-dns/src/index.js":
/*!*********************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-dns/src/index.js ***!
  \*********************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const analyticsSampler = __webpack_require__(/*! ../../dd-trace/src/analytics_sampler */ "../../node_modules/dd-trace/packages/dd-trace/src/analytics_sampler.js")
const tx = __webpack_require__(/*! ../../dd-trace/src/plugins/util/tx */ "../../node_modules/dd-trace/packages/dd-trace/src/plugins/util/tx.js")

const rrtypes = {
  resolveAny: 'ANY',
  resolve4: 'A',
  resolve6: 'AAAA',
  resolveCname: 'CNAME',
  resolveMx: 'MX',
  resolveNs: 'NS',
  resolveTxt: 'TXT',
  resolveSrv: 'SRV',
  resolvePtr: 'PTR',
  resolveNaptr: 'NAPTR',
  resolveSoa: 'SOA'
}

function createWrapLookup (tracer, config) {
  return function wrapLookup (lookup) {
    return function lookupWithTrace (hostname, options, callback) {
      if (!isArgsValid(arguments, 2)) return lookup.apply(this, arguments)

      const span = startSpan(tracer, config, 'dns.lookup', {
        'resource.name': hostname,
        'dns.hostname': hostname
      })

      wrapArgs(span, arguments, (e, address) => {
        span.setTag('dns.address', address)
      })

      return tracer.scope().activate(span, () => lookup.apply(this, arguments))
    }
  }
}

function createWrapLookupService (tracer, config) {
  return function wrapLookupService (lookupService) {
    return function lookupServiceWithTrace (address, port, callback) {
      if (!isArgsValid(arguments, 3)) return lookupService.apply(this, arguments)

      const span = startSpan(tracer, config, 'dns.lookup_service', {
        'resource.name': `${address}:${port}`,
        'dns.address': address,
        'dns.port': port
      })

      wrapArgs(span, arguments)

      return tracer.scope().activate(span, () => lookupService.apply(this, arguments))
    }
  }
}

function createWrapResolve (tracer, config) {
  return function wrapResolve (resolve) {
    return function resolveWithTrace (hostname, rrtype, callback) {
      if (!isArgsValid(arguments, 2)) return resolve.apply(this, arguments)

      if (typeof rrtype !== 'string') {
        rrtype = 'A'
      }

      const span = wrapResolver(tracer, config, rrtype, arguments)

      return tracer.scope().activate(span, () => resolve.apply(this, arguments))
    }
  }
}

function createWrapResolver (tracer, config, rrtype) {
  return function wrapResolve (resolve) {
    return function resolveWithTrace (hostname, callback) {
      if (!isArgsValid(arguments, 2)) return resolve.apply(this, arguments)

      const span = wrapResolver(tracer, config, rrtype, arguments)

      return tracer.scope().activate(span, () => resolve.apply(this, arguments))
    }
  }
}

function createWrapReverse (tracer, config) {
  return function wrapReverse (reverse) {
    return function reverseWithTrace (ip, callback) {
      if (!isArgsValid(arguments, 2)) return reverse.apply(this, arguments)

      const span = startSpan(tracer, config, 'dns.reverse', {
        'resource.name': ip,
        'dns.ip': ip
      })

      wrapArgs(span, arguments)

      return tracer.scope().activate(span, () => reverse.apply(this, arguments))
    }
  }
}

function startSpan (tracer, config, operation, tags) {
  const childOf = tracer.scope().active()
  const span = tracer.startSpan(operation, {
    childOf,
    tags: Object.assign({
      'span.kind': 'client',
      'service.name': config.service || `${tracer._service}-dns`
    }, tags)
  })

  analyticsSampler.sample(span, config.analytics)

  return span
}

function isArgsValid (args, minLength) {
  if (args.length < minLength) return false
  if (typeof args[args.length - 1] !== 'function') return false

  return true
}

function wrapArgs (span, args, callback) {
  const original = args[args.length - 1]
  const fn = tx.wrap(span, original)

  args[args.length - 1] = function () {
    callback && callback.apply(null, arguments)
    return fn.apply(this, arguments)
  }
}

function wrapResolver (tracer, config, rrtype, args) {
  const hostname = args[0]
  const span = startSpan(tracer, config, 'dns.resolve', {
    'resource.name': `${rrtype} ${hostname}`,
    'dns.hostname': hostname,
    'dns.rrtype': rrtype
  })

  wrapArgs(span, args)

  return span
}

function patchResolveShorthands (tracer, config, shim, prototype) {
  Object.keys(rrtypes)
    .filter(method => !!prototype[method])
    .forEach(method => {
      shim.wrap(prototype, method, createWrapResolver(tracer, config, rrtypes[method]))
    })
}

function unpatchResolveShorthands (shim, prototype) {
  Object.keys(rrtypes)
    .filter(method => !!prototype[method])
    .forEach(method => {
      shim.unwrap(prototype, method)
    })
}

module.exports = [
  {
    name: 'dns',
    patch (dns, tracer, config) {
      this.wrap(dns, 'lookup', createWrapLookup(tracer, config))
      this.wrap(dns, 'lookupService', createWrapLookupService(tracer, config))
      this.wrap(dns, 'resolve', createWrapResolve(tracer, config))
      this.wrap(dns, 'reverse', createWrapReverse(tracer, config))

      patchResolveShorthands(tracer, config, this, dns)

      if (dns.Resolver) {
        this.wrap(dns.Resolver.prototype, 'resolve', createWrapResolve(tracer, config))
        this.wrap(dns.Resolver.prototype, 'reverse', createWrapReverse(tracer, config))

        patchResolveShorthands(tracer, config, this, dns.Resolver.prototype)
      }
    },
    unpatch (dns) {
      this.unwrap(dns, [
        'lookup',
        'lookupService',
        'resolve',
        'reverse'
      ])

      unpatchResolveShorthands(this, dns)

      if (dns.Resolver) {
        this.unwrap(dns.prototype.Resolver, [
          'resolve',
          'reverse'
        ])

        unpatchResolveShorthands(this, dns.Resolver.prototype)
      }
    }
  }
]


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-elasticsearch/src/index.js":
/*!*******************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-elasticsearch/src/index.js ***!
  \*******************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Tags = __webpack_require__(/*! opentracing */ "../../node_modules/opentracing/lib/index.js").Tags
const analyticsSampler = __webpack_require__(/*! ../../dd-trace/src/analytics_sampler */ "../../node_modules/dd-trace/packages/dd-trace/src/analytics_sampler.js")

function createWrapRequest (tracer, config) {
  config = normalizeConfig(config)
  return function wrapRequest (request) {
    return function requestWithTrace (params, options, cb) {
      if (!params) return request.apply(this, arguments)

      const childOf = tracer.scope().active()
      const span = tracer.startSpan('elasticsearch.query', {
        childOf,
        tags: {
          [Tags.SPAN_KIND]: Tags.SPAN_KIND_RPC_CLIENT,
          [Tags.DB_TYPE]: 'elasticsearch',
          'service.name': config.service || `${tracer._service}-elasticsearch`,
          'resource.name': `${params.method} ${quantizePath(params.path)}`,
          'span.type': 'elasticsearch',
          'elasticsearch.url': params.path,
          'elasticsearch.method': params.method,
          'elasticsearch.params': JSON.stringify(params.querystring || params.query)
        }
      })

      if (params.body) {
        span.setTag('elasticsearch.body', JSON.stringify(params.body))
      }

      analyticsSampler.sample(span, config.analytics)

      cb = request.length === 2 || typeof options === 'function'
        ? tracer.scope().bind(options, childOf)
        : tracer.scope().bind(cb, childOf)

      return tracer.scope().activate(span, () => {
        if (typeof cb === 'function') {
          if (request.length === 2) {
            return request.call(this, params, wrapCallback(tracer, span, params, config, cb))
          } else {
            return request.call(this, params, options, wrapCallback(tracer, span, params, config, cb))
          }
        } else {
          const promise = request.apply(this, arguments)

          if (promise && typeof promise.then === 'function') {
            promise.then(() => finish(span, params, config), e => finish(span, params, config, e))
          } else {
            finish(span, params, config)
          }

          return promise
        }
      })
    }
  }
}

function wrapCallback (tracer, span, params, config, done) {
  return function (err) {
    finish(span, params, config, err)
    done.apply(null, arguments)
  }
}

function finish (span, params, config, err) {
  if (err) {
    span.addTags({
      'error.type': err.name,
      'error.msg': err.message,
      'error.stack': err.stack
    })
  }

  config.hooks.query(span, params)

  span.finish()
}

function quantizePath (path) {
  return path && path.replace(/[0-9]+/g, '?')
}

function normalizeConfig (config) {
  const hooks = getHooks(config)

  return Object.assign({}, config, {
    hooks
  })
}

function getHooks (config) {
  const noop = () => {}
  const query = (config.hooks && config.hooks.query) || noop

  return { query }
}

module.exports = [
  {
    name: 'elasticsearch',
    file: 'src/lib/transport.js',
    versions: ['>=10'],
    patch (Transport, tracer, config) {
      this.wrap(Transport.prototype, 'request', createWrapRequest(tracer, config))
    },
    unpatch (Transport) {
      this.unwrap(Transport.prototype, 'request')
    }
  },
  {
    name: '@elastic/elasticsearch',
    file: 'lib/Transport.js',
    versions: ['>=5.6.16'], // initial version of this module
    patch (Transport, tracer, config) {
      this.wrap(Transport.prototype, 'request', createWrapRequest(tracer, config))
    },
    unpatch (Transport) {
      this.unwrap(Transport.prototype, 'request')
    }
  }
]


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-fastify/src/fastify.js":
/*!***************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-fastify/src/fastify.js ***!
  \***************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const methods = __webpack_require__(/*! methods */ "../../node_modules/methods/index.js").concat('all')
const web = __webpack_require__(/*! ../../dd-trace/src/plugins/util/web */ "../../node_modules/dd-trace/packages/dd-trace/src/plugins/util/web.js")

function createWrapFastify (tracer, config) {
  config = web.normalizeConfig(config)

  return function wrapFastify (fastify) {
    if (typeof fastify !== 'function') return fastify

    return function fastifyWithTrace () {
      const app = fastify.apply(this, arguments)

      if (!app) return app

      if (typeof app.addHook === 'function') {
        app.addHook('onRequest', createOnRequest(tracer, config))
        app.addHook('preHandler', preHandler)
      }

      methods.forEach(method => {
        app[method] = wrapMethod(app[method])
      })

      app.route = wrapRoute(app.route)

      return app
    }
  }
}

function createOnRequest (tracer, config) {
  return function onRequest (request, reply, next) {
    if (typeof next !== 'function') return

    const req = getReq(request)
    const res = getRes(reply)
    const name = 'fastify.request'

    return web.instrument(tracer, config, req, res, name, () => next())
  }
}

function preHandler (request, reply, next) {
  if (typeof next !== 'function') return
  if (!reply || typeof reply.send !== 'function') return next()

  reply.send = wrapSend(reply.send)

  next()
}

function wrapSend (send) {
  return function sendWithTrace (payload) {
    const req = getReq(this && this.request)

    web.addError(req, payload)

    return send.apply(this, arguments)
  }
}

function wrapRoute (route) {
  if (typeof route !== 'function') return route

  return function routeWithTrace (opts) {
    opts.handler = wrapHandler(opts.handler)

    return route.apply(this, arguments)
  }
}

function wrapMethod (method) {
  if (typeof method !== 'function') return method

  return function methodWithTrace (url, opts, handler) {
    const lastIndex = arguments.length - 1

    arguments[lastIndex] = wrapHandler(arguments[lastIndex])

    return method.apply(this, arguments)
  }
}

function wrapHandler (handler) {
  return function handlerWithTrace (request, reply) {
    const req = getReq(request)

    return web.reactivate(req, () => handler.apply(this, arguments))
  }
}

function getReq (request) {
  return request && (request.raw || request.req || request)
}

function getRes (reply) {
  return reply && (reply.raw || reply.res || reply)
}

module.exports = [
  {
    name: 'fastify',
    versions: ['>=1'],
    patch (fastify, tracer, config) {
      // `fastify` is a function so we return a wrapper that will replace its export.
      return this.wrapExport(fastify, createWrapFastify(tracer, config)(fastify))
    },
    unpatch (fastify) {
      this.unwrapExport(fastify)
    }
  }
]


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-fastify/src/index.js":
/*!*************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-fastify/src/index.js ***!
  \*************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = [].concat(
  __webpack_require__(/*! ./fastify */ "../../node_modules/dd-trace/packages/datadog-plugin-fastify/src/fastify.js"),
  __webpack_require__(/*! ./find-my-way */ "../../node_modules/dd-trace/packages/datadog-plugin-fastify/src/find-my-way.js")
)


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-fs/src/index.js":
/*!********************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-fs/src/index.js ***!
  \********************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


let kDirReadPromisified
let kDirClosePromisified
let kHandle

const ddFhSym = Symbol('ddFileHandle')

const tagMakers = {
  open: createOpenTags,
  close: createCloseTags,
  readFile: createReadFileTags,
  writeFile: createWriteFileTags,
  appendFile: createAppendFileTags,
  access: createPathTags,
  copyFile: createCopyFileTags,
  stat: createPathTags,
  lstat: createPathTags,
  fstat: createFDTags,
  readdir: createPathTags,
  opendir: createPathTags,
  read: createFDTags,
  write: createFDTags,
  writev: createFDTags,
  chmod: createChmodTags,
  lchmod: createChmodTags,
  fchmod: createFchmodTags,
  chown: createChownTags,
  lchown: createChownTags,
  fchown: createFchownTags,
  realpath: createPathTags,
  readlink: createPathTags,
  unlink: createPathTags,
  symlink: createCopyFileTags,
  link: createCopyFileTags,
  rmdir: createPathTags,
  rename: createCopyFileTags,
  fsync: createFDTags,
  fdatasync: createFDTags,
  mkdir: createPathTags,
  truncate: createPathTags,
  ftruncate: createFDTags,
  utimes: createPathTags,
  futimes: createFDTags,
  mkdtemp: createPathTags
}

const promisifiable = ['read', 'readv', 'write', 'writev']

const orphanable = false

function createWrapCreateReadStream (config, tracer) {
  return function wrapCreateReadStream (createReadStream) {
    return function createReadStreamWithTrace (path, options) {
      if (!hasParent(tracer)) {
        return createReadStream.apply(this, arguments)
      }
      const tags = makeFSFlagTags('ReadStream', path, options, 'r', config, tracer)
      return tracer.trace('fs.operation', { tags, orphanable }, (span, done) => {
        const stream = createReadStream.apply(this, arguments)
        stream.once('end', done)
        stream.once('error', done)
        return stream
      })
    }
  }
}

function createWrapCreateWriteStream (config, tracer) {
  return function wrapCreateWriteStream (createWriteStream) {
    return function createWriteStreamWithTrace (path, options) {
      const tags = makeFSFlagTags('WriteStream', path, options, 'w', config, tracer)
      return tracer.trace('fs.operation', { tags, orphanable }, (span, done) => {
        const stream = createWriteStream.apply(this, arguments)
        stream.once('finish', done)
        stream.once('error', done)
        return stream
      })
    }
  }
}

function createWrapExists (config, tracer) {
  return function wrapExists (exists) {
    const existsWithTrace = function existsWithTrace (path, cb) {
      if (typeof cb !== 'function') {
        return exists.apply(this, arguments)
      }
      const tags = makeFSTags('exists', path, null, config, tracer)
      return tracer.trace('fs.operation', { tags, orphanable }, (span, done) => {
        arguments[1] = function (result) {
          done()
          cb.apply(this, arguments)
        }
        return exists.apply(this, arguments)
      })
    }

    copySymbols(exists, existsWithTrace)

    return existsWithTrace
  }
}

function createWrapDirRead (config, tracer, sync) {
  const name = sync ? 'dir.readSync' : 'dir.read'
  return function wrapDirRead (read) {
    function options () {
      const tags = makeFSTags(name, this.path, null, config, tracer)
      return { tags, orphanable }
    }
    return tracer.wrap('fs.operation', options, read, true)
  }
}

function createWrapDirClose (config, tracer, sync) {
  const name = sync ? 'dir.closeSync' : 'dir.close'
  return function wrapDirClose (close) {
    function options () {
      const tags = makeFSTags(name, this.path, null, config, tracer)
      return { tags, orphanable }
    }
    return tracer.wrap('fs.operation', options, close, true)
  }
}

function createWrapDirAsyncIterator (config, tracer, instrumenter) {
  return function wrapDirAsyncIterator (asyncIterator) {
    return function asyncIteratorWithTrace () {
      if (!kDirReadPromisified) {
        const keys = Reflect.ownKeys(this)
        for (const key of keys) {
          if (kDirReadPromisified && kDirClosePromisified) break
          if (typeof key !== 'symbol') continue
          if (!kDirReadPromisified && getSymbolName(key).includes('kDirReadPromisified')) {
            kDirReadPromisified = key
          }
          if (!kDirClosePromisified && getSymbolName(key).includes('kDirClosePromisified')) {
            kDirClosePromisified = key
          }
        }
      }
      instrumenter.wrap(this, kDirReadPromisified, createWrapDirRead(config, tracer))
      instrumenter.wrap(this, kDirClosePromisified, createWrapKDirClose(config, tracer, instrumenter))
      return asyncIterator.call(this)
    }
  }
}

function createWrapKDirClose (config, tracer, instrumenter) {
  return function wrapKDirClose (kDirClose) {
    return function kDirCloseWithTrace () {
      const tags = makeFSTags('dir.close', this.path, null, config, tracer)
      return tracer.trace('fs.operation', { tags, orphanable }, (span) => {
        const p = kDirClose.call(this)
        const unwrapBoth = () => {
          instrumenter.unwrap(this, kDirReadPromisified)
          instrumenter.unwrap(this, kDirClosePromisified)
        }
        p.then(unwrapBoth, unwrapBoth)
        return p
      })
    }
  }
}

function createOpenTags (resourceName, config, tracer) {
  return function openTags (path, flag, mode) {
    if (!flag || typeof flag === 'function') {
      flag = null
    }
    return makeFSFlagTags(resourceName, path, { flag }, 'r', config, tracer)
  }
}

function createCloseTags (resourceName, config, tracer) {
  return function closeTags (fd) {
    if (typeof fd === 'undefined' && this && this[ddFhSym]) {
      fd = this[ddFhSym].fd
    }
    if (typeof fd !== 'number' || !Number.isInteger(fd)) {
      return
    }
    return makeFSTags(resourceName, fd, null, config, tracer)
  }
}

function createReadFileTags (resourceName, config, tracer) {
  return function readFileTags (path, options) {
    return makeFSFlagTags(resourceName, path, options, 'r', config, tracer)
  }
}

function createWriteFileTags (resourceName, config, tracer) {
  return function writeFileTags (path, data, options) {
    return makeFSFlagTags(resourceName, path, options, 'w', config, tracer)
  }
}

function createAppendFileTags (resourceName, config, tracer) {
  return function appendFileTags (path, data, options) {
    return makeFSFlagTags(resourceName, path, options, 'a', config, tracer)
  }
}

function createCopyFileTags (resourceName, config, tracer) {
  return function copyFileTags (src, dest, flag) {
    return makeFSTags(resourceName, { src, dest }, null, config, tracer)
  }
}

function createChmodTags (resourceName, config, tracer) {
  return function chmodTags (fd, mode) {
    const tags = makeFSTags(resourceName, fd, null, config, tracer)
    tags['file.mode'] = mode.toString(8)
    return tags
  }
}

function createFchmodTags (resourceName, config, tracer) {
  return function fchmodTags (fd, mode) {
    if (typeof this === 'object' && this !== null && this.fd) {
      mode = fd
      fd = this.fd
    }

    const tags = makeFSTags(resourceName, fd, null, config, tracer)
    if (mode) {
      tags['file.mode'] = mode.toString(8)
    }
    return tags
  }
}

function createPathTags (resourceName, config, tracer) {
  return function pathTags (path) {
    return makeFSTags(resourceName, path, null, config, tracer)
  }
}

function createFDTags (resourceName, config, tracer) {
  return function fdTags (fd) {
    if (typeof this === 'object' && this !== null && this.fd) {
      fd = this.fd
    }
    return makeFSTags(resourceName, fd, null, config, tracer)
  }
}

function createChownTags (resourceName, config, tracer) {
  return function chownTags (fd, uid, gid) {
    const tags = makeFSTags(resourceName, fd, null, config, tracer)
    if (typeof uid === 'number') {
      tags['file.uid'] = uid.toString()
    }
    if (typeof gid === 'number') {
      tags['file.gid'] = gid.toString()
    }
    return tags
  }
}

function createFchownTags (resourceName, config, tracer) {
  return function fchownTags (fd, uid, gid) {
    if (typeof this === 'object' && this !== null && this.fd) {
      gid = uid
      uid = fd
      fd = this.fd
    }
    const tags = makeFSTags(resourceName, fd, null, config, tracer)
    if (typeof uid === 'number') {
      tags['file.uid'] = uid.toString()
    }
    if (typeof gid === 'number') {
      tags['file.gid'] = gid.toString()
    }
    return tags
  }
}

function getSymbolName (sym) {
  return sym.description || sym.toString()
}

function hasParent (tracer) {
  return !!tracer.scope().active()
}

function createWrapCb (tracer, config, name, tagMaker) {
  const makeTags = tagMaker(name, config, tracer)
  return function wrapFunction (fn) {
    return tracer.wrap('fs.operation', function () {
      if (typeof arguments[arguments.length - 1] !== 'function') {
        return
      }
      const tags = makeTags.apply(this, arguments)
      return tags ? { tags, orphanable } : { orphanable }
    }, fn, true)
  }
}

function createWrap (tracer, config, name, tagMaker) {
  const makeTags = tagMaker(name, config, tracer)

  return function wrapSyncFunction (fn) {
    return tracer.wrap('fs.operation', function () {
      const tags = makeTags.apply(this, arguments)
      return tags ? { tags, orphanable } : { orphanable }
    }, fn, true)
  }
}

function makeFSFlagTags (resourceName, path, options, defaultFlag, config, tracer) {
  const tags = makeFSTags(resourceName, path, options, config, tracer)

  if (tags) {
    let flag = defaultFlag
    if (typeof options === 'object' && options !== null) {
      if (options.flag) {
        flag = options.flag
      } else if (options.flags) {
        flag = options.flags
      }
    }
    tags['file.flag'] = flag
    return tags
  }
}

function makeFSTags (resourceName, path, options, config, tracer) {
  path = options && typeof options === 'object' && 'fd' in options ? options.fd : path
  const tags = {
    'component': 'fs',
    'span.kind': 'internal',
    'resource.name': resourceName,
    'service.name': config.service || `${tracer._service}-fs`
  }

  switch (typeof path) {
    case 'object': {
      if (path === null) return
      const src = 'src' in path ? path.src : null
      const dest = 'dest' in path ? path.dest : null
      if (src || dest) {
        tags['file.src'] = src
        tags['file.dest'] = dest
      } else {
        tags['file.path'] = path
      }
      break
    }
    case 'string': {
      tags['file.path'] = path
      break
    }
    case 'number': {
      tags['file.descriptor'] = path.toString()
      break
    }
  }

  return tags
}

function copySymbols (from, to) {
  const props = Object.getOwnPropertyDescriptors(from)
  const keys = Reflect.ownKeys(props)

  for (const key of keys) {
    if (typeof key !== 'symbol' || to.hasOwnProperty(key)) continue

    Object.defineProperty(to, key, props[key])
  }
}

function getFileHandlePrototype (fs) {
  return fs.promises.open(__filename, 'r')
    .then(fh => {
      if (!kHandle) {
        kHandle = Reflect.ownKeys(fh).find(key => typeof key === 'symbol' && key.toString().includes('kHandle'))
      }
      fh.close()

      return Object.getPrototypeOf(fh)
    })
}

function patchClassicFunctions (fs, tracer, config) {
  for (const name in fs) {
    if (!fs[name]) continue
    const tagMakerName = name.endsWith('Sync') ? name.substr(0, name.length - 4) : name
    const original = fs[name]
    if (tagMakerName in tagMakers) {
      const tagMaker = tagMakers[tagMakerName]
      if (name.endsWith('Sync')) {
        this.wrap(fs, name, createWrap(tracer, config, name, tagMaker))
      } else {
        this.wrap(fs, name, createWrapCb(tracer, config, name, tagMaker))
      }
      if (name in promisifiable) {
        copySymbols(original, fs[name])
      }
    }
  }
}

function patchFileHandle (fs, tracer, config) {
  getFileHandlePrototype(fs).then((fileHandlePrototype) => {
    for (const name of Reflect.ownKeys(fileHandlePrototype)) {
      if (typeof name !== 'string' || name === 'constructor' || name === 'fd' || name === 'getAsyncId') {
        continue
      }
      let tagMaker
      const fName = 'f' + name
      if (fName in tagMakers) {
        tagMaker = tagMakers[fName]
      } else {
        tagMaker = createFDTags
      }

      const instrumenter = this

      const desc = Reflect.getOwnPropertyDescriptor(fileHandlePrototype, kHandle)
      if (!desc || !desc.get) {
        Reflect.defineProperty(fileHandlePrototype, kHandle, {
          get () {
            return this[ddFhSym]
          },
          set (h) {
            this[ddFhSym] = h
            instrumenter.wrap(this, 'close', createWrap(tracer, config, 'filehandle.close', tagMakers.close))
          },
          configurable: true
        })
      }

      this.wrap(fileHandlePrototype, name, createWrap(tracer, config, 'filehandle.' + name, tagMaker))
    }
  })
}

function patchPromiseFunctions (fs, tracer, config) {
  for (const name in fs.promises) {
    if (name in tagMakers) {
      const tagMaker = tagMakers[name]
      this.wrap(fs.promises, name, createWrap(tracer, config, 'promises.' + name, tagMaker))
    }
  }
}

function patchDirFunctions (fs, tracer, config) {
  this.wrap(fs.Dir.prototype, 'close', createWrapDirClose(config, tracer))
  this.wrap(fs.Dir.prototype, 'closeSync', createWrapDirClose(config, tracer, true))
  this.wrap(fs.Dir.prototype, 'read', createWrapDirRead(config, tracer))
  this.wrap(fs.Dir.prototype, 'readSync', createWrapDirRead(config, tracer, true))
  this.wrap(fs.Dir.prototype, Symbol.asyncIterator, createWrapDirAsyncIterator(config, tracer, this))
}

function unpatchClassicFunctions (fs) {
  for (const name in fs) {
    if (!fs[name]) continue
    const tagMakerName = name.endsWith('Sync') ? name.substr(0, name.length - 4) : name
    if (tagMakerName in tagMakers) {
      this.unwrap(fs, name)
    }
  }
}

function unpatchFileHandle (fs) {
  getFileHandlePrototype(fs).then(fileHandlePrototype => {
    for (const name of Reflect.ownKeys(fileHandlePrototype)) {
      if (typeof name !== 'string' || name === 'constructor' || name === 'fd' || name === 'getAsyncId') {
        continue
      }
      this.unwrap(fileHandlePrototype, name)
    }
    delete fileHandlePrototype[kHandle]
  })
}

function unpatchPromiseFunctions (fs) {
  for (const name in fs.promises) {
    if (name in tagMakers) {
      this.unwrap(fs.promises, name)
    }
  }
}

function unpatchDirFunctions (fs) {
  this.unwrap(fs.Dir.prototype, 'close')
  this.unwrap(fs.Dir.prototype, 'closeSync')
  this.unwrap(fs.Dir.prototype, 'read')
  this.unwrap(fs.Dir.prototype, 'readSync')
  this.unwrap(fs.Dir.prototype, Symbol.asyncIterator)
}

module.exports = {
  name: 'fs',
  patch (fs, tracer, config) {
    patchClassicFunctions.call(this, fs, tracer, config)
    if (fs.promises) {
      patchFileHandle.call(this, fs, tracer, config)
      patchPromiseFunctions.call(this, fs, tracer, config)
    }
    if (fs.Dir) {
      patchDirFunctions.call(this, fs, tracer, config)
    }
    this.wrap(fs, 'createReadStream', createWrapCreateReadStream(config, tracer))
    this.wrap(fs, 'createWriteStream', createWrapCreateWriteStream(config, tracer))
    this.wrap(fs, 'existsSync', createWrap(tracer, config, 'existsSync', createPathTags))
    this.wrap(fs, 'exists', createWrapExists(config, tracer))
  },
  unpatch (fs) {
    unpatchClassicFunctions.call(this, fs)
    if (fs.promises) {
      unpatchFileHandle.call(this, fs)
      unpatchPromiseFunctions.call(this, fs)
    }
    if (fs.Dir) {
      unpatchDirFunctions.call(this, fs)
    }
    this.unwrap(fs, 'createReadStream')
    this.unwrap(fs, 'createWriteStream')
    this.unwrap(fs, 'existsSync')
    this.unwrap(fs, 'exists')
  }
}

/** TODO fs functions:

unwatchFile
watch
watchFile
*/


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-generic-pool/src/index.js":
/*!******************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-generic-pool/src/index.js ***!
  \******************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function createWrapAcquire (tracer, config) {
  return function wrapAcquire (acquire) {
    return function acquireWithTrace (callback, priority) {
      if (typeof callback === 'function') {
        arguments[0] = tracer.scope().bind(callback)
      }

      return acquire.apply(this, arguments)
    }
  }
}

function createWrapPool (tracer, config, instrumenter) {
  return function wrapPool (Pool) {
    if (typeof Pool !== 'function') return Pool

    return function PoolWithTrace (factory) {
      const pool = Pool.apply(this, arguments)

      if (pool && typeof pool.acquire === 'function') {
        instrumenter.wrap(pool, 'acquire', createWrapAcquire(tracer, config))
      }

      return pool
    }
  }
}

module.exports = [
  {
    name: 'generic-pool',
    versions: ['^2.4'],
    patch (genericPool, tracer, config) {
      this.wrap(genericPool.Pool.prototype, 'acquire', createWrapAcquire(tracer, config))
    },
    unpatch (genericPool) {
      this.unwrap(genericPool.Pool.prototype, 'acquire')
    }
  },
  {
    name: 'generic-pool',
    versions: ['2 - 2.3'],
    patch (genericPool, tracer, config) {
      this.wrap(genericPool, 'Pool', createWrapPool(tracer, config, this))
    },
    unpatch (genericPool) {
      this.unwrap(genericPool, 'Pool')
    }
  }
]


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-google-cloud-pubsub/src/index.js":
/*!*************************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-google-cloud-pubsub/src/index.js ***!
  \*************************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function createWrapRequest (tracer, config) {
  return function wrapRequest (request) {
    return function requestWithTrace (cfg = { reqOpts: {} }, cb) {
      const topic = getTopic(cfg)
      const tags = {
        component: '@google-cloud/pubsub',
        'resource.name': [cfg.method, topic].filter(x => x).join(' '),
        'service.name': config.service || `${tracer._service}-pubsub`,
        'pubsub.method': cfg.method,
        'gcloud.project_id': this.projectId,
        'pubsub.topic': topic
      }
      if (cfg.method === 'publish') {
        tags['span.kind'] = 'producer'
      }
      cb = tracer.scope().bind(cb)
      return tracer.trace('pubsub.request', { tags }, (span, done) => {
        if (cfg.reqOpts && cfg.method === 'publish') {
          for (const msg of cfg.reqOpts.messages) {
            if (!msg.attributes) {
              msg.attributes = {}
            }
            tracer.inject(span, 'text_map', msg.attributes)
          }
        }

        arguments[1] = function (err) {
          done(err)
          return cb.apply(this, arguments)
        }

        return request.apply(this, arguments)
      })
    }
  }
}

function createWrapSubscriptionEmit (tracer, config) {
  return function wrapSubscriptionEmit (emit) {
    return function emitWithTrace (eventName, message) {
      if (eventName !== 'message' || !message || !message._datadog_span) {
        return emit.apply(this, arguments)
      }

      const span = message._datadog_span

      return tracer.scope().activate(span, () => {
        try {
          return emit.apply(this, arguments)
        } catch (e) {
          span.setTag('error', e)
          throw e
        }
      })
    }
  }
}

function createWrapLeaseDispense (tracer, config) {
  return function wrapDispense (dispense) {
    return function dispenseWithTrace (message) {
      const subscription = message._subscriber._subscription
      const topic = subscription.metadata && subscription.metadata.topic
      const tags = {
        component: '@google-cloud/pubsub',
        'resource.name': topic,
        'service.name': config.service || tracer._service,
        'gcloud.project_id': subscription.pubsub.projectId,
        'pubsub.topic': topic,
        'span.kind': 'consumer'
      }

      const childOf = tracer.extract('text_map', message.attributes)
      const span = tracer.startSpan('pubsub.receive', { tags, childOf })

      message._datadog_span = span

      return dispense.apply(this, arguments)
    }
  }
}

function createWrapLeaseRemove (tracer, config) {
  return function wrapRemove (remove) {
    return function removeWithTrace (message) {
      finish(message)

      return remove.apply(this, arguments)
    }
  }
}

function createWrapLeaseClear (tracer, config) {
  return function wrapClear (clear) {
    return function clearWithTrace () {
      for (const message of this._messages) {
        finish(message)
      }

      return clear.apply(this, arguments)
    }
  }
}

function getTopic (cfg) {
  if (cfg.reqOpts) {
    return cfg.reqOpts[cfg.method === 'createTopic' ? 'name' : 'topic']
  }
}

function finish (message) {
  const span = message._datadog_span

  if (!span) return

  span.setTag('pubsub.ack', message._handled ? 1 : 0)
  span.finish()
}

module.exports = [
  {
    name: '@google-cloud/pubsub',
    versions: ['>=1.2'],
    patch ({ PubSub, Subscription }, tracer, config) {
      this.wrap(PubSub.prototype, 'request', createWrapRequest(tracer, config))
      this.wrap(Subscription.prototype, 'emit', createWrapSubscriptionEmit(tracer, config))
    },
    unpatch ({ PubSub, Subscription }) {
      this.unwrap(PubSub.prototype, 'request')
      this.unwrap(Subscription.prototype, 'emit')
    }
  },
  {
    name: '@google-cloud/pubsub',
    versions: ['>=1.2'],
    file: 'build/src/lease-manager.js',
    patch ({ LeaseManager }, tracer, config) {
      this.wrap(LeaseManager.prototype, '_dispense', createWrapLeaseDispense(tracer, config))
      this.wrap(LeaseManager.prototype, 'remove', createWrapLeaseRemove(tracer, config))
      this.wrap(LeaseManager.prototype, 'clear', createWrapLeaseClear(tracer, config))
    },
    unpatch ({ LeaseManager }) {
      this.unwrap(LeaseManager.prototype, '_dispense')
      this.unwrap(LeaseManager.prototype, 'remove')
      this.unwrap(LeaseManager.prototype, 'clear')
    }
  }
]


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-graphql/src/index.js":
/*!*************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-graphql/src/index.js ***!
  \*************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const pick = __webpack_require__(/*! lodash.pick */ "../../node_modules/lodash.pick/index.js")
const log = __webpack_require__(/*! ../../dd-trace/src/log */ "../../node_modules/dd-trace/packages/dd-trace/src/log.js")
const analyticsSampler = __webpack_require__(/*! ../../dd-trace/src/analytics_sampler */ "../../node_modules/dd-trace/packages/dd-trace/src/analytics_sampler.js")

let tools

function createWrapExecute (tracer, config, defaultFieldResolver) {
  return function wrapExecute (execute) {
    return function executeWithTrace () {
      const args = normalizeArgs(arguments)
      const schema = args.schema
      const document = args.document
      const source = document && document._datadog_source
      const fieldResolver = args.fieldResolver || defaultFieldResolver
      const contextValue = args.contextValue = args.contextValue || {}
      const operation = getOperation(document, args.operationName)

      if (contextValue._datadog_graphql) {
        return execute.apply(this, arguments)
      }

      args.fieldResolver = wrapResolve(fieldResolver, tracer, config)

      if (schema) {
        wrapFields(schema._queryType, tracer, config)
        wrapFields(schema._mutationType, tracer, config)
      }

      const span = startExecutionSpan(tracer, config, operation, args)

      contextValue._datadog_graphql = { source, span, fields: {} }

      return call(execute, span, this, [args], (err, res) => {
        finishResolvers(contextValue, config)

        setError(span, err || (res && res.errors && res.errors[0]))
        config.hooks.execute(span, args, res)
        finish(span)
      })
    }
  }
}

function createWrapParse (tracer, config) {
  return function wrapParse (parse) {
    return function parseWithTrace (source) {
      const span = startSpan(tracer, config, 'parse')

      analyticsSampler.sample(span, config.analytics)

      try {
        const document = parse.apply(this, arguments)
        const operation = getOperation(document)

        if (!operation) return document // skip schema parsing

        if (source) {
          document._datadog_source = source.body || source
        }

        addDocumentTags(span, document)

        return document
      } catch (e) {
        setError(span, e)
        throw e
      } finally {
        finish(span)
      }
    }
  }
}

function createWrapValidate (tracer, config) {
  return function wrapValidate (validate) {
    return function validateWithTrace (schema, document, rules, typeInfo) {
      const span = startSpan(tracer, config, 'validate')

      analyticsSampler.sample(span, config.analytics)

      // skip for schema stitching nested validation
      if (document && document.loc) {
        addDocumentTags(span, document)
      }

      try {
        const errors = validate.apply(this, arguments)

        setError(span, errors && errors[0])

        return errors
      } catch (e) {
        setError(span, e)
        throw e
      } finally {
        finish(span)
      }
    }
  }
}

function wrapFields (type, tracer, config) {
  if (!type || !type._fields || type._datadog_patched) {
    return
  }

  type._datadog_patched = true

  Object.keys(type._fields).forEach(key => {
    const field = type._fields[key]

    wrapFieldResolve(field, tracer, config)
    wrapFieldType(field, tracer, config)
  })
}

function wrapFieldResolve (field, tracer, config) {
  if (!field || !field.resolve) return

  field.resolve = wrapResolve(field.resolve, tracer, config)
}

function wrapFieldType (field, tracer, config) {
  if (!field || !field.type) return

  let unwrappedType = field.type

  while (unwrappedType.ofType) {
    unwrappedType = unwrappedType.ofType
  }

  wrapFields(unwrappedType, tracer, config)
}

function wrapResolve (resolve, tracer, config) {
  if (resolve._datadog_patched || typeof resolve !== 'function') return resolve

  const responsePathAsArray = config.collapse
    ? withCollapse(pathToArray)
    : pathToArray

  function resolveWithTrace (source, args, contextValue, info) {
    if (!contextValue._datadog_graphql) return resolve.apply(this, arguments)

    const path = responsePathAsArray(info && info.path)
    const depth = path.filter(item => typeof item === 'string').length

    if (config.depth >= 0 && config.depth < depth) {
      const parent = getParentField(tracer, contextValue, path)

      return call(resolve, parent.span, this, arguments)
    }

    const field = assertField(tracer, config, contextValue, info, path)

    return call(resolve, field.span, this, arguments, err => updateField(field, err))
  }

  resolveWithTrace._datadog_patched = true

  return resolveWithTrace
}

function call (fn, span, thisArg, args, callback) {
  const scope = span.tracer().scope()

  callback = callback || (() => {})

  try {
    const result = scope.activate(span, () => fn.apply(thisArg, args))

    if (result && typeof result.then === 'function') {
      result.then(
        res => callback(null, res),
        err => callback(err)
      )
    } else {
      callback(null, result)
    }

    return result
  } catch (e) {
    callback(e)
    throw e
  }
}

function getParentField (tracer, contextValue, path) {
  for (let i = path.length - 1; i > 0; i--) {
    const field = getField(contextValue, path.slice(0, i))

    if (field) {
      return field
    }
  }

  return {
    span: contextValue._datadog_graphql.span
  }
}

function getField (contextValue, path) {
  return contextValue._datadog_graphql.fields[path.join('.')]
}

function normalizeArgs (args) {
  if (args.length === 1) {
    return args[0]
  }

  return {
    schema: args[0],
    document: args[1],
    rootValue: args[2],
    contextValue: args[3],
    variableValues: args[4],
    operationName: args[5],
    fieldResolver: args[6]
  }
}

function startExecutionSpan (tracer, config, operation, args) {
  const span = startSpan(tracer, config, 'execute')

  addExecutionTags(span, config, operation, args.document, args.operationName)
  addDocumentTags(span, args.document)
  addVariableTags(tracer, config, span, args.variableValues)

  analyticsSampler.sample(span, config.analytics)

  return span
}

function addExecutionTags (span, config, operation, document, operationName) {
  const type = operation && operation.operation
  const name = operation && operation.name && operation.name.value
  const tags = {
    'resource.name': getSignature(document, name, type, config.signature)
  }

  if (type) {
    tags['graphql.operation.type'] = type
  }

  if (name) {
    tags['graphql.operation.name'] = name
  }

  span.addTags(tags)
}

function addDocumentTags (span, document) {
  const tags = {}

  if (document && document._datadog_source) {
    tags['graphql.source'] = document._datadog_source
  }

  span.addTags(tags)
}

function addVariableTags (tracer, config, span, variableValues) {
  const tags = {}

  if (variableValues && config.variables) {
    const variables = config.variables(variableValues)
    for (const param in variables) {
      tags[`graphql.variables.${param}`] = variables[param]
    }
  }

  span.addTags(tags)
}

function startSpan (tracer, config, name, options) {
  options = options || {}

  return tracer.startSpan(`graphql.${name}`, {
    childOf: options.childOf || tracer.scope().active(),
    startTime: options.startTime,
    tags: {
      'service.name': getService(tracer, config),
      'span.type': 'graphql'
    }
  })
}

function startResolveSpan (tracer, config, childOf, path, info, contextValue) {
  const span = startSpan(tracer, config, 'resolve', { childOf })
  const document = contextValue._datadog_graphql.source
  const fieldNode = info.fieldNodes.find(fieldNode => fieldNode.kind === 'Field')

  span.addTags({
    'resource.name': `${info.fieldName}:${info.returnType}`,
    'graphql.field.name': info.fieldName,
    'graphql.field.path': path.join('.'),
    'graphql.field.type': info.returnType.name
  })

  if (fieldNode) {
    if (document && fieldNode.loc) {
      span.setTag('graphql.source', document.substring(fieldNode.loc.start, fieldNode.loc.end))
    }

    if (config.variables && fieldNode.arguments) {
      const variables = config.variables(info.variableValues)

      fieldNode.arguments
        .filter(arg => arg.value && arg.value.kind === 'Variable')
        .filter(arg => arg.value.name && variables[arg.value.name.value])
        .map(arg => arg.value.name.value)
        .forEach(name => {
          span.setTag(`graphql.variables.${name}`, variables[name])
        })
    }
  }

  return span
}

function setError (span, error) {
  if (error) {
    span.setTag('error', error)
  }
}

function finish (span, finishTime) {
  span.finish(finishTime)
}

function finishResolvers (contextValue) {
  const fields = contextValue._datadog_graphql.fields

  Object.keys(fields).reverse().forEach(key => {
    const field = fields[key]

    setError(field.span, field.error)
    finish(field.span, field.finishTime)
  })
}

function updateField (field, error) {
  // TODO: update this to also work with no-op spans without a hack
  field.finishTime = field.span._getTime ? field.span._getTime() : 0
  field.error = field.error || error
}

function withCollapse (responsePathAsArray) {
  return function () {
    return responsePathAsArray.apply(this, arguments)
      .map(segment => typeof segment === 'number' ? '*' : segment)
  }
}

function assertField (tracer, config, contextValue, info, path) {
  const pathString = path.join('.')
  const fields = contextValue._datadog_graphql.fields

  let field = fields[pathString]

  if (!field) {
    const parent = getParentField(tracer, contextValue, path)

    field = fields[pathString] = {
      parent,
      span: startResolveSpan(tracer, config, parent.span, path, info, contextValue),
      error: null
    }
  }

  return field
}

function getService (tracer, config) {
  return config.service || `${tracer._service}-graphql`
}

function getOperation (document, operationName) {
  if (!document || !Array.isArray(document.definitions)) {
    return
  }

  const definitions = document.definitions.filter(def => def)
  const types = ['query', 'mutation', 'subscription']

  if (operationName) {
    return definitions
      .filter(def => types.indexOf(def.operation) !== -1)
      .find(def => operationName === (def.name && def.name.value))
  } else {
    return definitions.find(def => types.indexOf(def.operation) !== -1)
  }
}

function validateConfig (config) {
  return Object.assign({}, config, {
    depth: getDepth(config),
    variables: getVariablesFilter(config),
    collapse: config.collapse === undefined || !!config.collapse,
    hooks: getHooks(config)
  })
}

function getDepth (config) {
  if (typeof config.depth === 'number') {
    return config.depth
  } else if (config.hasOwnProperty('depth')) {
    log.error('Expected `depth` to be a integer.')
  }
  return -1
}

function getVariablesFilter (config) {
  if (typeof config.variables === 'function') {
    return config.variables
  } else if (config.variables instanceof Array) {
    return variables => pick(variables, config.variables)
  } else if (config.hasOwnProperty('variables')) {
    log.error('Expected `variables` to be an array or function.')
  }
  return null
}

function getSignature (document, operationName, operationType, calculate) {
  if (calculate !== false && tools !== false) {
    try {
      try {
        tools = tools || __webpack_require__(/*! ./tools */ "../../node_modules/dd-trace/packages/datadog-plugin-graphql/src/tools/index.js")
      } catch (e) {
        tools = false
        throw e
      }

      return tools.defaultEngineReportingSignature(document, operationName)
    } catch (e) {
      // safety net
    }
  }

  return [operationType, operationName].filter(val => val).join(' ')
}

function pathToArray (path) {
  const flattened = []
  let curr = path
  while (curr) {
    flattened.push(curr.key)
    curr = curr.prev
  }
  return flattened.reverse()
}

function getHooks (config) {
  const noop = () => {}
  const execute = (config.hooks && config.hooks.execute) || noop

  return { execute }
}

module.exports = [
  {
    name: 'graphql',
    file: 'execution/execute.js',
    versions: ['>=0.10'],
    patch (execute, tracer, config) {
      this.wrap(execute, 'execute', createWrapExecute(
        tracer,
        validateConfig(config),
        execute.defaultFieldResolver
      ))
    },
    unpatch (execute) {
      this.unwrap(execute, 'execute')
    }
  },
  {
    name: 'graphql',
    file: 'language/parser.js',
    versions: ['>=0.10'],
    patch (parser, tracer, config) {
      this.wrap(parser, 'parse', createWrapParse(tracer, validateConfig(config)))
    },
    unpatch (parser) {
      this.unwrap(parser, 'parse')
    }
  },
  {
    name: 'graphql',
    file: 'validation/validate.js',
    versions: ['>=0.10'],
    patch (validate, tracer, config) {
      this.wrap(validate, 'validate', createWrapValidate(tracer, validateConfig(config)))
    },
    unpatch (validate) {
      this.unwrap(validate, 'validate')
    }
  }
]


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-grpc/src/client.js":
/*!***********************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-grpc/src/client.js ***!
  \***********************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Tags = __webpack_require__(/*! ../../../ext/tags */ "../../node_modules/dd-trace/ext/tags.js")
const { TEXT_MAP } = __webpack_require__(/*! ../../../ext/formats */ "../../node_modules/dd-trace/ext/formats.js")
const { ERROR } = __webpack_require__(/*! ../../../ext/tags */ "../../node_modules/dd-trace/ext/tags.js")
const kinds = __webpack_require__(/*! ./kinds */ "../../node_modules/dd-trace/packages/datadog-plugin-grpc/src/kinds.js")
const { addMethodTags, addMetadataTags, getFilter } = __webpack_require__(/*! ./util */ "../../node_modules/dd-trace/packages/datadog-plugin-grpc/src/util.js")

function createWrapLoadPackageDefinition (tracer, config) {
  config = config.client || config

  return function wrapLoadPackageDefinition (loadPackageDefinition) {
    return function loadPackageDefinitionWithTrace (packageDef) {
      const result = loadPackageDefinition.apply(this, arguments)

      if (!result) return result

      wrapPackageDefinition(tracer, config, result)

      return result
    }
  }
}

function createWrapMakeClientConstructor (tracer, config) {
  config = config.client || config

  return function wrapMakeClientConstructor (makeClientConstructor) {
    return function makeClientConstructorWithTrace (methods) {
      const ServiceClient = makeClientConstructor.apply(this, arguments)

      wrapClientConstructor(tracer, config, ServiceClient, methods)

      return ServiceClient
    }
  }
}

function wrapPackageDefinition (tracer, config, def) {
  for (const name in def) {
    if (def[name].format) continue
    if (def[name].service) {
      wrapClientConstructor(tracer, config, def[name], def[name].service)
    } else {
      wrapPackageDefinition(tracer, config, def[name])
    }
  }
}

function wrapClientConstructor (tracer, config, ServiceClient, methods) {
  const proto = ServiceClient.prototype

  if (typeof methods !== 'object' || 'format' in methods) return

  Object.keys(methods)
    .forEach(name => {
      if (!methods[name]) return

      const originalName = methods[name].originalName
      const path = methods[name].path
      const methodKind = getMethodKind(methods[name])

      if (methods[name]) {
        proto[name] = wrapMethod(tracer, config, proto[name], path, methodKind)
      }

      if (originalName) {
        proto[originalName] = wrapMethod(tracer, config, proto[originalName], path, methodKind)
      }
    })
}

function wrapMethod (tracer, config, method, path, methodKind) {
  if (typeof method !== 'function' || method._datadog_patched) {
    return method
  }

  const filter = getFilter(config, 'metadata')

  const methodWithTrace = function methodWithTrace () {
    const args = ensureMetadata(this, arguments)
    const length = args.length
    const metadata = args[1]
    const callback = args[length - 1]
    const scope = tracer.scope()
    const span = startSpan(tracer, config, path, methodKind)

    if (metadata) {
      addMetadataTags(span, metadata, filter, 'request')
      inject(tracer, span, metadata)
    }

    if (methodKind === kinds.unary || methodKind === kinds.client_stream) {
      if (typeof callback === 'function') {
        args[length - 1] = wrapCallback(span, callback)
      } else {
        args[length] = wrapCallback(span)
      }
    }

    const call = scope.bind(method, span).apply(this, args)

    wrapStream(span, call, filter)

    return scope.bind(call)
  }

  Object.assign(methodWithTrace, method)

  methodWithTrace._datadog_patched = true

  return methodWithTrace
}

function wrapCallback (span, callback) {
  const scope = span.tracer().scope()
  const parent = scope.active()

  return function (err) {
    err && span.setTag(ERROR, err)

    if (callback) {
      return scope.bind(callback, parent).apply(this, arguments)
    }
  }
}

function wrapStream (span, call, filter) {
  if (!call || typeof call.emit !== 'function') return

  const emit = call.emit

  call.emit = function (eventName, ...args) {
    switch (eventName) {
      case 'error':
        span.setTag(ERROR, args[0] || 1)

        break
      case 'status':
        if (args[0]) {
          span.setTag('grpc.status.code', args[0].code)

          addMetadataTags(span, args[0].metadata, filter, 'response')
        }

        span.finish()

        break
    }

    return emit.apply(this, arguments)
  }
}

function startSpan (tracer, config, path, methodKind) {
  const scope = tracer.scope()
  const childOf = scope.active()
  const span = tracer.startSpan('grpc.request', {
    childOf,
    tags: {
      [Tags.SPAN_KIND]: 'client',
      'resource.name': path,
      'service.name': config.service || `${tracer._service}-grpc-client`,
      'component': 'grpc'
    }
  })

  addMethodTags(span, path, methodKind)

  return span
}

function ensureMetadata (client, args) {
  if (!client || !client._datadog) return args

  const normalized = [args[0]]

  if (!args[1] || !args[1].constructor || args[1].constructor.name !== 'Metadata') {
    normalized.push(new client._datadog.grpc.Metadata())
  }

  for (let i = 1; i < args.length; i++) {
    normalized.push(args[i])
  }

  return normalized
}

function inject (tracer, span, metadata) {
  if (typeof metadata.set !== 'function') return

  const carrier = {}

  tracer.inject(span, TEXT_MAP, carrier)

  for (const key in carrier) {
    metadata.set(key, carrier[key])
  }
}

function getMethodKind (definition) {
  if (definition.requestStream) {
    if (definition.responseStream) {
      return kinds.bidi
    }

    return kinds.client_stream
  }

  if (definition.responseStream) {
    return kinds.server_stream
  }

  return kinds.unary
}

module.exports = [
  {
    name: 'grpc',
    versions: ['>=1.13'],
    patch (grpc, tracer, config) {
      if (config.client === false) return

      grpc.Client.prototype._datadog = { grpc }
    },
    unpatch (grpc) {
      delete grpc.Client._datadog
    }
  },
  {
    name: 'grpc',
    versions: ['>=1.13'],
    file: 'src/client.js',
    patch (client, tracer, config) {
      if (config.client === false) return

      this.wrap(client, 'makeClientConstructor', createWrapMakeClientConstructor(tracer, config))
    },
    unpatch (client) {
      this.unwrap(client, 'makeClientConstructor')
    }
  },
  {
    name: '@grpc/grpc-js',
    versions: ['>=1.0.3'],
    patch (grpc, tracer, config) {
      if (config.client === false) return

      grpc.Client.prototype._datadog = { grpc }
    },
    unpatch (grpc) {
      delete grpc.Client._datadog
    }
  },
  {
    name: '@grpc/grpc-js',
    versions: ['>=1.0.3'],
    file: 'build/src/make-client.js',
    patch (client, tracer, config) {
      if (config.client === false) return

      this.wrap(client, 'makeClientConstructor', createWrapMakeClientConstructor(tracer, config))
      this.wrap(client, 'loadPackageDefinition', createWrapLoadPackageDefinition(tracer, config))
    },
    unpatch (client) {
      this.unwrap(client, 'makeClientConstructor')
      this.unwrap(client, 'loadPackageDefinition')
    }
  }
]


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-grpc/src/server.js":
/*!***********************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-grpc/src/server.js ***!
  \***********************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Tags = __webpack_require__(/*! ../../../ext/tags */ "../../node_modules/dd-trace/ext/tags.js")
const { TEXT_MAP } = __webpack_require__(/*! ../../../ext/formats */ "../../node_modules/dd-trace/ext/formats.js")
const { ERROR } = __webpack_require__(/*! ../../../ext/tags */ "../../node_modules/dd-trace/ext/tags.js")
const kinds = __webpack_require__(/*! ./kinds */ "../../node_modules/dd-trace/packages/datadog-plugin-grpc/src/kinds.js")
const { addMethodTags, addMetadataTags, getFilter } = __webpack_require__(/*! ./util */ "../../node_modules/dd-trace/packages/datadog-plugin-grpc/src/util.js")

// https://github.com/grpc/grpc/blob/master/doc/statuscodes.md
const OK = 0
const CANCELLED = 1

function createWrapHandler (tracer, config, handler) {
  const filter = getFilter(config, 'metadata')

  return function wrapHandler (func) {
    const isValid = (server, args) => {
      if (!server || !server.type) return false
      if (!args[0]) return false
      if (server.type !== 'unary' && !isEmitter(args[0])) return false
      if (server.type === 'unary' && typeof args[1] !== 'function') return false

      return true
    }

    return function funcWithTrace (call, callback) {
      if (!isValid(this, arguments)) return func.apply(this, arguments)

      const metadata = call.metadata
      const type = this.type
      const isStream = type !== 'unary'
      const scope = tracer.scope()
      const childOf = extract(tracer, metadata)
      const span = tracer.startSpan('grpc.request', {
        childOf,
        tags: {
          [Tags.SPAN_KIND]: 'server',
          'resource.name': handler,
          'service.name': config.service || `${tracer._service}`,
          'component': 'grpc'
        }
      })

      addMethodTags(span, handler, kinds[type])
      addMetadataTags(span, metadata, filter, 'request')

      scope.bind(call)

      // Finish the span if the call was cancelled.
      call.once('cancelled', () => {
        span.setTag('grpc.status.code', CANCELLED)
        span.finish()
      })

      if (isStream) {
        wrapStream(span, call)
      } else {
        arguments[1] = wrapCallback(span, callback, filter, childOf)
      }

      return scope.bind(func, span).apply(this, arguments)
    }
  }
}

function createWrapRegister (tracer, config) {
  config = config.server || config

  return function wrapRegister (register) {
    return function registerWithTrace (name, handler, serialize, deserialize, type) {
      if (typeof handler === 'function') {
        arguments[1] = createWrapHandler(tracer, config, name)(handler)
      }

      return register.apply(this, arguments)
    }
  }
}

function wrapStream (span, call, tracer) {
  const emit = call.emit

  if (call.call && call.call.sendStatus) {
    call.call.sendStatus = wrapSendStatus(call.call.sendStatus, span)
  }

  call.emit = function (eventName, ...args) {
    switch (eventName) {
      case 'error':
        span.addTags({
          [ERROR]: args[0] || 1,
          'grpc.status.code': args[0] && args[0].code
        })

        span.finish()

        break

      // Finish the span of the response only if it was successful.
      // Otherwise it'll be finished in the `error` listener.
      case 'finish':
        if (call.status) {
          span.setTag('grpc.status.code', call.status.code)
        }

        if (!call.status || call.status.code === 0) {
          span.finish()
        }

        break
    }

    return emit.apply(this, arguments)
  }
}

function wrapCallback (span, callback, filter, childOf) {
  const scope = span.tracer().scope()

  return function (err, value, trailer, flags) {
    if (err instanceof Error) {
      if (err.code) {
        span.setTag('grpc.status.code', err.code)
      }

      span.setTag(ERROR, err)
    } else {
      span.setTag('grpc.status.code', OK)
    }

    if (trailer && filter) {
      addMetadataTags(span, trailer, filter, 'response')
    }

    span.finish()

    if (callback) {
      return scope.bind(callback, childOf).apply(this, arguments)
    }
  }
}

function wrapSendStatus (sendStatus, span) {
  return function sendStatusWithTrace (status) {
    span.setTag('grpc.status.code', status.code)

    return sendStatus.apply(this, arguments)
  }
}

function extract (tracer, metadata) {
  if (!metadata || typeof metadata.getMap !== 'function') return null

  return tracer.extract(TEXT_MAP, metadata.getMap())
}

function isEmitter (obj) {
  return typeof obj.emit === 'function' && typeof obj.once === 'function'
}

module.exports = [
  {
    name: 'grpc',
    versions: ['>=1.13'],
    file: 'src/server.js',
    patch (server, tracer, config) {
      if (config.server === false) return
      this.wrap(server.Server.prototype, 'register', createWrapRegister(tracer, config))
    },
    unpatch (server) {
      this.unwrap(server.Server.prototype, 'register')
    }
  },
  {
    name: '@grpc/grpc-js',
    versions: ['>=1'],
    file: 'build/src/server.js',
    patch (server, tracer, config) {
      if (config.server === false) return

      this.wrap(server.Server.prototype, 'register', createWrapRegister(tracer, config))
    },
    unpatch (server) {
      this.unwrap(server.Server.prototype, 'register')
    }
  }
]


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-grpc/src/util.js":
/*!*********************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-grpc/src/util.js ***!
  \*********************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const pick = __webpack_require__(/*! lodash.pick */ "../../node_modules/lodash.pick/index.js")
const log = __webpack_require__(/*! ../../dd-trace/src/log */ "../../node_modules/dd-trace/packages/dd-trace/src/log.js")

module.exports = {
  addMethodTags (span, path, kind) {
    if (typeof path !== 'string') return

    span.addTags({
      'grpc.method.path': path,
      'grpc.method.kind': kind
    })

    const methodParts = path.split('/')

    if (methodParts.length < 2) return

    const serviceParts = methodParts[1].split('.')
    const name = methodParts[2]
    const service = serviceParts.pop()
    const pkg = serviceParts.join('.')

    span.addTags({
      'grpc.method.name': name,
      'grpc.method.service': service,
      'grpc.method.package': pkg
    })
  },

  addMetadataTags (span, metadata, filter, type) {
    if (!metadata || typeof metadata.getMap !== 'function') return

    const values = filter(metadata.getMap())

    for (const key in values) {
      span.setTag(`grpc.${type}.metadata.${key}`, values[key])
    }
  },

  // TODO: extract this to shared utils and add unit tests
  getFilter (config, filter) {
    if (typeof config[filter] === 'function') {
      return config[filter]
    }

    if (config[filter] instanceof Array) {
      return element => pick(element, config[filter])
    }

    if (config.hasOwnProperty(filter)) {
      log.error(`Expected '${filter}' to be an array or function.`)
    }

    return () => ({})
  }
}


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-hapi/src/server.js":
/*!***********************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-hapi/src/server.js ***!
  \***********************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const web = __webpack_require__(/*! ../../dd-trace/src/plugins/util/web */ "../../node_modules/dd-trace/packages/dd-trace/src/plugins/util/web.js")

function createWrapDispatch (tracer, config) {
  config = web.normalizeConfig(config)

  return function wrapDispatch (dispatch) {
    return function dispatchWithTrace (options) {
      const handler = dispatch.apply(this, arguments)

      if (typeof handler !== 'function') return handler

      return function (req, res) {
        return web.instrument(tracer, config, req, res, 'hapi.request', () => {
          return handler.apply(this, arguments)
        })
      }
    }
  }
}

function createWrapServer (tracer) {
  return function wrapServer (server) {
    return function serverWithTrace (options) {
      const app = server.apply(this, arguments)

      if (!app) return app

      if (typeof app.ext === 'function') {
        app.ext = createWrapExt(tracer)(app.ext)
      }

      if (typeof app.start === 'function') {
        app.start = createWrapStart(tracer)(app.start)
      }

      return app
    }
  }
}

function createWrapStart () {
  return function wrapStart (start) {
    return function startWithTrace () {
      if (this && typeof this.ext === 'function') {
        this.ext('onPreResponse', onPreResponse)
      }

      return start.apply(this, arguments)
    }
  }
}

function createWrapExt () {
  return function wrapExt (ext) {
    return function extWithTrace (events, method, options) {
      if (typeof events === 'object') {
        events = wrapEvents(events)
      } else {
        method = wrapExtension(method)
      }

      return ext.call(this, events, method, options)
    }
  }
}

function wrapExtension (method) {
  return [].concat(method).map(wrapHandler)
}

function wrapEvents (events) {
  return [].concat(events).map(event => {
    if (!event || !event.method) return event

    return Object.assign({}, event, {
      method: wrapExtension(event.method)
    })
  })
}

function wrapHandler (handler) {
  if (typeof handler !== 'function') return handler

  return function (request, h) {
    if (!request || !request.raw) return handler.apply(this, arguments)

    return web.reactivate(request.raw.req, () => handler.apply(this, arguments))
  }
}

function onPreResponse (request, h) {
  if (!request || !request.raw) return reply(request, h)

  const req = request.raw.req

  web.addError(req, request.response)

  if (request.route) {
    web.enterRoute(req, request.route.path)
  }

  return reply(request, h)
}

function reply (request, h) {
  if (h.continue) {
    return typeof h.continue === 'function'
      ? h.continue()
      : h.continue
  } else if (typeof h === 'function') {
    return h()
  }
}

module.exports = [
  {
    name: '@hapi/hapi',
    versions: ['>=17.9'],
    patch (hapi, tracer, config) {
      this.wrap(hapi, ['server', 'Server'], createWrapServer(tracer, config))
    },
    unpatch (hapi) {
      this.unwrap(hapi, ['server', 'Server'])
    }
  },
  {
    name: 'hapi',
    versions: ['>=17'],
    patch (hapi, tracer, config) {
      this.wrap(hapi, ['server', 'Server'], createWrapServer(tracer, config))
    },
    unpatch (hapi) {
      this.unwrap(hapi, ['server', 'Server'])
    }
  },
  {
    name: 'hapi',
    versions: ['2 - 7.1', '8 - 16'],
    patch (hapi, tracer, config) {
      this.wrap(hapi.Server.prototype, 'start', createWrapStart(tracer, config))
      this.wrap(hapi.Server.prototype, 'ext', createWrapExt(tracer, config))
    },
    unpatch (hapi) {
      this.unwrap(hapi.Server.prototype, 'start')
      this.unwrap(hapi.Server.prototype, 'ext')
    }
  },
  {
    name: 'hapi',
    versions: ['^7.2'],
    patch (hapi, tracer, config) {
      this.wrap(hapi, 'createServer', createWrapServer(tracer, config))
    },
    unpatch (hapi) {
      this.unwrap(hapi, 'createServer')
    }
  },
  {
    name: '@hapi/hapi',
    versions: ['>=17.9'],
    file: 'lib/core.js',
    patch (Core, tracer, config) {
      this.wrap(Core.prototype, '_dispatch', createWrapDispatch(tracer, config))
    },
    unpatch (Core) {
      this.unwrap(Core.prototype, '_dispatch')
    }
  },
  {
    name: 'hapi',
    versions: ['7.2 - 16'],
    file: 'lib/connection.js',
    patch (Connection, tracer, config) {
      this.wrap(Connection.prototype, '_dispatch', createWrapDispatch(tracer, config))
    },
    unpatch (Connection) {
      this.unwrap(Connection.prototype, '_dispatch')
    }
  },
  {
    name: 'hapi',
    versions: ['>=17'],
    file: 'lib/core.js',
    patch (Core, tracer, config) {
      this.wrap(Core.prototype, '_dispatch', createWrapDispatch(tracer, config))
    },
    unpatch (Core) {
      this.unwrap(Core.prototype, '_dispatch')
    }
  },
  {
    name: 'hapi',
    versions: ['2 - 7.1'],
    file: 'lib/server.js',
    patch (Server, tracer, config) {
      this.wrap(Server.prototype, '_dispatch', createWrapDispatch(tracer, config))
    },
    unpatch (Server) {
      this.unwrap(Server.prototype, '_dispatch')
    }
  }
]


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-http/src/client.js":
/*!***********************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-http/src/client.js ***!
  \***********************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const url = __webpack_require__(/*! url */ "url")
const semver = __webpack_require__(/*! semver */ "../../node_modules/dd-trace/node_modules/semver/semver.js")
const opentracing = __webpack_require__(/*! opentracing */ "../../node_modules/opentracing/lib/index.js")
const log = __webpack_require__(/*! ../../dd-trace/src/log */ "../../node_modules/dd-trace/packages/dd-trace/src/log.js")
const constants = __webpack_require__(/*! ../../dd-trace/src/constants */ "../../node_modules/dd-trace/packages/dd-trace/src/constants.js")
const tags = __webpack_require__(/*! ../../../ext/tags */ "../../node_modules/dd-trace/ext/tags.js")
const kinds = __webpack_require__(/*! ../../../ext/kinds */ "../../node_modules/dd-trace/ext/kinds.js")
const formats = __webpack_require__(/*! ../../../ext/formats */ "../../node_modules/dd-trace/ext/formats.js")
const urlFilter = __webpack_require__(/*! ../../dd-trace/src/plugins/util/urlfilter */ "../../node_modules/dd-trace/packages/dd-trace/src/plugins/util/urlfilter.js")
const analyticsSampler = __webpack_require__(/*! ../../dd-trace/src/analytics_sampler */ "../../node_modules/dd-trace/packages/dd-trace/src/analytics_sampler.js")

const Reference = opentracing.Reference

const HTTP_HEADERS = formats.HTTP_HEADERS
const HTTP_STATUS_CODE = tags.HTTP_STATUS_CODE
const HTTP_REQUEST_HEADERS = tags.HTTP_REQUEST_HEADERS
const HTTP_RESPONSE_HEADERS = tags.HTTP_RESPONSE_HEADERS
const SPAN_KIND = tags.SPAN_KIND
const CLIENT = kinds.CLIENT
const REFERENCE_CHILD_OF = opentracing.REFERENCE_CHILD_OF
const REFERENCE_NOOP = constants.REFERENCE_NOOP

function patch (http, methodName, tracer, config) {
  config = normalizeConfig(tracer, config)
  this.wrap(http, methodName, fn => makeRequestTrace(fn))

  function makeRequestTrace (request) {
    return function requestTrace () {
      let args

      try {
        args = normalizeArgs.apply(null, arguments)
      } catch (e) {
        log.error(e)
        return request.apply(this, arguments)
      }

      const options = args.options
      const agent = options.agent || options._defaultAgent || http.globalAgent
      const protocol = options.protocol || agent.protocol || 'http:'
      const hostname = options.hostname || options.host || 'localhost'
      const host = options.port ? `${hostname}:${options.port}` : hostname
      const path = options.path ? options.path.split(/[?#]/)[0] : '/'
      const uri = `${protocol}//${host}${path}`

      let callback = args.callback

      const method = (options.method || 'GET').toUpperCase()

      const scope = tracer.scope()
      const childOf = scope.active()
      const type = config.filter(uri) ? REFERENCE_CHILD_OF : REFERENCE_NOOP
      const span = tracer.startSpan('http.request', {
        references: [
          new Reference(type, childOf)
        ],
        tags: {
          [SPAN_KIND]: CLIENT,
          'service.name': getServiceName(tracer, config, options),
          'resource.name': method,
          'span.type': 'http',
          'http.method': method,
          'http.url': uri
        }
      })

      if (!hasAmazonSignature(options)) {
        tracer.inject(span, HTTP_HEADERS, options.headers)
      }

      analyticsSampler.sample(span, config.analytics)

      callback = scope.bind(callback, childOf)

      const req = scope.bind(request, span).call(this, options, callback)
      const emit = req.emit

      req.emit = function (eventName, arg) {
        switch (eventName) {
          case 'response': {
            const res = arg

            scope.bind(res)

            span.setTag(HTTP_STATUS_CODE, res.statusCode)

            addResponseHeaders(res, span, config)

            if (!config.validateStatus(res.statusCode)) {
              span.setTag('error', 1)
            }

            res.on('end', () => finish(req, res, span, config))

            break
          }
          case 'error':
            addError(span, arg)
          case 'abort': // eslint-disable-line no-fallthrough
          case 'close': // eslint-disable-line no-fallthrough
            finish(req, null, span, config)
        }

        return emit.apply(this, arguments)
      }

      scope.bind(req)

      return req
    }
  }

  function finish (req, res, span, config) {
    addRequestHeaders(req, span, config)

    config.hooks.request(span, req, res)

    span.finish()
  }

  function addError (span, error) {
    span.addTags({
      'error.type': error.name,
      'error.msg': error.message,
      'error.stack': error.stack
    })

    return error
  }

  function addRequestHeaders (req, span, config) {
    config.headers.forEach(key => {
      const value = req.getHeader(key)

      if (value) {
        span.setTag(`${HTTP_REQUEST_HEADERS}.${key}`, value)
      }
    })
  }

  function addResponseHeaders (res, span, config) {
    config.headers.forEach(key => {
      const value = res.headers[key]

      if (value) {
        span.setTag(`${HTTP_RESPONSE_HEADERS}.${key}`, value)
      }
    })
  }

  function normalizeArgs (inputURL, inputOptions, cb) {
    inputURL = normalizeOptions(inputURL)

    const [callback, inputOptionsNormalized] = normalizeCallback(inputOptions, cb, inputURL)
    const options = combineOptions(inputURL, inputOptionsNormalized)
    normalizeHeaders(options)
    const uri = url.format(options)

    return { uri, options, callback }
  }

  function normalizeCallback (inputOptions, callback, inputURL) {
    if (typeof inputOptions === 'function') {
      return [inputOptions, inputURL || {}]
    } else {
      return [callback, inputOptions]
    }
  }

  function combineOptions (inputURL, inputOptions) {
    if (typeof inputOptions === 'object') {
      return Object.assign(inputURL || {}, inputOptions)
    } else {
      return inputURL
    }
  }

  function normalizeHeaders (options) {
    options.headers = options.headers || {}
  }

  // https://github.com/nodejs/node/blob/7e911d8b03a838e5ac6bb06c5b313533e89673ef/lib/internal/url.js#L1271
  function urlToOptions (url) {
    const agent = url.agent || http.globalAgent
    const options = {
      protocol: url.protocol || agent.protocol,
      hostname: typeof url.hostname === 'string' && url.hostname.startsWith('[')
        ? url.hostname.slice(1, -1)
        : url.hostname ||
        url.host ||
        'localhost',
      hash: url.hash,
      search: url.search,
      pathname: url.pathname,
      path: `${url.pathname || ''}${url.search || ''}`,
      href: url.href
    }
    if (url.port !== '') {
      options.port = Number(url.port)
    }
    if (url.username || url.password) {
      options.auth = `${url.username}:${url.password}`
    }
    return options
  }

  function normalizeOptions (inputURL) {
    if (typeof inputURL === 'string') {
      try {
        return urlToOptions(new url.URL(inputURL))
      } catch (e) {
        return url.parse(inputURL)
      }
    } else if (inputURL instanceof url.URL) {
      return urlToOptions(inputURL)
    } else {
      return inputURL
    }
  }
}

function getHost (options) {
  if (typeof options === 'string') {
    return url.parse(options).host
  }

  const hostname = options.hostname || options.host || 'localhost'
  const port = options.port

  return [hostname, port].filter(val => val).join(':')
}

function getServiceName (tracer, config, options) {
  if (config.splitByDomain) {
    return getHost(options)
  } else if (config.service) {
    return config.service
  }

  return `${tracer._service}-http-client`
}

function hasAmazonSignature (options) {
  if (!options) {
    return false
  }

  if (options.headers) {
    const headers = Object.keys(options.headers)
      .reduce((prev, next) => Object.assign(prev, {
        [next.toLowerCase()]: options.headers[next]
      }), {})

    if (headers['x-amz-signature']) {
      return true
    }

    if ([].concat(headers['authorization']).some(startsWith('AWS4-HMAC-SHA256'))) {
      return true
    }
  }

  return options.path && options.path.toLowerCase().indexOf('x-amz-signature=') !== -1
}

function startsWith (searchString) {
  return value => String(value).startsWith(searchString)
}

function unpatch (http) {
  this.unwrap(http, 'request')
  this.unwrap(http, 'get')
}

function getStatusValidator (config) {
  if (typeof config.validateStatus === 'function') {
    return config.validateStatus
  } else if (config.hasOwnProperty('validateStatus')) {
    log.error('Expected `validateStatus` to be a function.')
  }
  return code => code < 400 || code >= 500
}

function getFilter (tracer, config) {
  const blacklist = tracer._url ? [getAgentFilter(tracer._url)] : []

  config = Object.assign({}, config, {
    blacklist: blacklist.concat(config.blacklist || [])
  })

  return urlFilter.getFilter(config)
}

function getAgentFilter (url) {
  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#Escaping
  const agentFilter = url.href.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')

  return RegExp(`^${agentFilter}/.*$`, 'i')
}

function normalizeConfig (tracer, config) {
  config = config.client || config

  const validateStatus = getStatusValidator(config)
  const filter = getFilter(tracer, config)
  const headers = getHeaders(config)
  const hooks = getHooks(config)

  return Object.assign({}, config, {
    validateStatus,
    filter,
    headers,
    hooks
  })
}

function getHeaders (config) {
  if (!Array.isArray(config.headers)) return []

  return config.headers
    .filter(key => typeof key === 'string')
    .map(key => key.toLowerCase())
}

function getHooks (config) {
  const noop = () => {}
  const request = (config.hooks && config.hooks.request) || noop

  return { request }
}

module.exports = [
  {
    name: 'http',
    patch: function (http, tracer, config) {
      if (config.client === false) return

      patch.call(this, http, 'request', tracer, config)
      if (semver.satisfies(process.version, '>=8')) {
        /**
         * In newer Node versions references internal to modules, such as `http(s).get` calling `http(s).request`, do
         * not use externally patched versions, which is why we need to also patch `get` here separately.
         */
        patch.call(this, http, 'get', tracer, config)
      }
    },
    unpatch
  },
  {
    name: 'https',
    patch: function (http, tracer, config) {
      if (config.client === false) return

      if (semver.satisfies(process.version, '>=9')) {
        patch.call(this, http, 'request', tracer, config)
        patch.call(this, http, 'get', tracer, config)
      } else {
        /**
         * Below Node v9 the `https` module invokes `http.request`, which would end up counting requests twice.
         * So rather then patch the `https` module, we ensure the `http` module is patched and we count only there.
         */
        __webpack_require__(/*! http */ "http")
      }
    },
    unpatch
  }
]


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-http/src/index.js":
/*!**********************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-http/src/index.js ***!
  \**********************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const client = __webpack_require__(/*! ./client */ "../../node_modules/dd-trace/packages/datadog-plugin-http/src/client.js")
const server = __webpack_require__(/*! ./server */ "../../node_modules/dd-trace/packages/datadog-plugin-http/src/server.js")

module.exports = [].concat(client, server)


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-http/src/server.js":
/*!***********************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-http/src/server.js ***!
  \***********************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const web = __webpack_require__(/*! ../../dd-trace/src/plugins/util/web */ "../../node_modules/dd-trace/packages/dd-trace/src/plugins/util/web.js")
const Scope = __webpack_require__(/*! ../../dd-trace/src/scope/base */ "../../node_modules/dd-trace/packages/dd-trace/src/scope/base.js")

function createWrapEmit (tracer, config) {
  config = web.normalizeConfig(config)

  return function wrapEmit (emit) {
    return function emitWithTrace (eventName, req, res) {
      if (eventName === 'request') {
        return web.instrument(tracer, config, req, res, 'http.request', () => {
          return emit.apply(this, arguments)
        })
      }

      return emit.apply(this, arguments)
    }
  }
}

function plugin (name) {
  return {
    name,
    patch (http, tracer, config) {
      if (config.server === false) return

      this.wrap(http.Server.prototype, 'emit', createWrapEmit(tracer, config))
      if (http.ServerResponse) { // not present on https
        Scope._wrapEmitter(http.ServerResponse.prototype)
      }
    },
    unpatch (http) {
      this.unwrap(http.Server.prototype, 'emit')
    }
  }
}

module.exports = [
  plugin('http'),
  plugin('https')
]


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-http2/src/client.js":
/*!************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-http2/src/client.js ***!
  \************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const URL = __webpack_require__(/*! url */ "url").URL
const opentracing = __webpack_require__(/*! opentracing */ "../../node_modules/opentracing/lib/index.js")
const log = __webpack_require__(/*! ../../dd-trace/src/log */ "../../node_modules/dd-trace/packages/dd-trace/src/log.js")
const constants = __webpack_require__(/*! ../../dd-trace/src/constants */ "../../node_modules/dd-trace/packages/dd-trace/src/constants.js")
const tags = __webpack_require__(/*! ../../../ext/tags */ "../../node_modules/dd-trace/ext/tags.js")
const kinds = __webpack_require__(/*! ../../../ext/kinds */ "../../node_modules/dd-trace/ext/kinds.js")
const formats = __webpack_require__(/*! ../../../ext/formats */ "../../node_modules/dd-trace/ext/formats.js")
const urlFilter = __webpack_require__(/*! ../../dd-trace/src/plugins/util/urlfilter */ "../../node_modules/dd-trace/packages/dd-trace/src/plugins/util/urlfilter.js")
const analyticsSampler = __webpack_require__(/*! ../../dd-trace/src/analytics_sampler */ "../../node_modules/dd-trace/packages/dd-trace/src/analytics_sampler.js")
const shimmer = __webpack_require__(/*! shimmer */ "../../node_modules/shimmer/index.js")

const Reference = opentracing.Reference

const HTTP_HEADERS = formats.HTTP_HEADERS
const HTTP_STATUS_CODE = tags.HTTP_STATUS_CODE
const HTTP_REQUEST_HEADERS = tags.HTTP_REQUEST_HEADERS
const HTTP_RESPONSE_HEADERS = tags.HTTP_RESPONSE_HEADERS
const SPAN_KIND = tags.SPAN_KIND
const CLIENT = kinds.CLIENT
const REFERENCE_CHILD_OF = opentracing.REFERENCE_CHILD_OF
const REFERENCE_NOOP = constants.REFERENCE_NOOP

const HTTP2_HEADER_METHOD = ':method'
const HTTP2_HEADER_PATH = ':path'
const HTTP2_HEADER_STATUS = ':status'
const HTTP2_METHOD_GET = 'GET'

function extractSessionDetails (authority, options) {
  if (typeof authority === 'string') {
    authority = new URL(authority)
  }

  const protocol = authority.protocol || options.protocol || 'https:'
  let port = '' + (authority.port !== ''
    ? authority.port : (authority.protocol === 'http:' ? 80 : 443))
  let host = authority.hostname || authority.host || 'localhost'

  if (protocol === 'https:' && options) {
    port = options.port || port
    host = options.host || host
  }

  return { protocol, port, host }
}

function getFormattedHostString (host, port) {
  return [host, port].filter(val => val).join(':')
}

function getServiceName (tracer, config, sessionDetails) {
  if (config.splitByDomain) {
    return getFormattedHostString(sessionDetails.host, sessionDetails.port)
  } else if (config.service) {
    return config.service
  }

  return `${tracer._service}-http-client`
}

function hasAmazonSignature (headers, path) {
  if (headers) {
    headers = Object.keys(headers)
      .reduce((prev, next) => Object.assign(prev, {
        [next.toLowerCase()]: headers[next]
      }), {})

    if (headers['x-amz-signature']) {
      return true
    }

    if ([].concat(headers['authorization']).some(startsWith('AWS4-HMAC-SHA256'))) {
      return true
    }
  }

  return path && path.toLowerCase().indexOf('x-amz-signature=') !== -1
}

function startsWith (searchString) {
  return value => String(value).startsWith(searchString)
}

function getStatusValidator (config) {
  if (typeof config.validateStatus === 'function') {
    return config.validateStatus
  } else if (config.hasOwnProperty('validateStatus')) {
    log.error('Expected `validateStatus` to be a function.')
  }
  return code => code < 400 || code >= 500
}

function getFilter (tracer, config) {
  const blacklist = tracer._url ? [`${tracer._url.href}/v0.4/traces`] : []

  config = Object.assign({}, config, {
    blacklist: blacklist.concat(config.blacklist || [])
  })

  return urlFilter.getFilter(config)
}

function normalizeConfig (tracer, config) {
  config = config.client || config

  const validateStatus = getStatusValidator(config)
  const filter = getFilter(tracer, config)
  const headers = getHeaders(config)

  return Object.assign({}, config, {
    validateStatus,
    filter,
    headers
  })
}

function addResponseTags (headers, span, config) {
  const status = headers && headers[HTTP2_HEADER_STATUS]

  span.setTag(HTTP_STATUS_CODE, status)

  if (!config.validateStatus(status)) {
    span.setTag('error', 1)
  }

  addHeaderTags(span, headers, HTTP_RESPONSE_HEADERS, config)
}

function addRequestTags (headers, span, config) {
  addHeaderTags(span, headers, HTTP_REQUEST_HEADERS, config)
}

function addErrorTags (span, error) {
  span.setTag('error', error)
}

function addHeaderTags (span, headers, prefix, config) {
  if (!headers) return

  config.headers.forEach(key => {
    const value = headers[key]

    if (value) {
      span.setTag(`${prefix}.${key}`, value)
    }
  })
}

function getHeaders (config) {
  if (!Array.isArray(config.headers)) return []

  return config.headers
    .filter(key => typeof key === 'string')
    .map(key => key.toLowerCase())
}

function startSpan (tracer, config, headers, sessionDetails) {
  headers = headers || {}

  const scope = tracer.scope()
  const childOf = scope.active()

  const path = headers[HTTP2_HEADER_PATH] || '/'
  const method = headers[HTTP2_HEADER_METHOD] || HTTP2_METHOD_GET
  const url = `${sessionDetails.protocol}//${sessionDetails.host}:${sessionDetails.port}${path}`

  const type = config.filter(url) ? REFERENCE_CHILD_OF : REFERENCE_NOOP

  const span = tracer.startSpan('http.request', {
    references: [
      new Reference(type, childOf)
    ],
    tags: {
      [SPAN_KIND]: CLIENT,
      'service.name': getServiceName(tracer, config, sessionDetails),
      'resource.name': method,
      'span.type': 'http',
      'http.method': method,
      'http.url': url.split('?')[0]
    }
  })

  if (!hasAmazonSignature(headers, path)) {
    tracer.inject(span, HTTP_HEADERS, headers)
  }

  analyticsSampler.sample(span, config.analytics)
  return span
}

function createWrapEmit (tracer, config, span) {
  return function wrapEmit (emit) {
    return function emitWithTrace (event, arg1) {
      switch (event) {
        case 'response':
          addResponseTags(arg1, span, config)
          break
        case 'error':
          addErrorTags(span, arg1)
        case 'close': // eslint-disable-line no-fallthrough
          span.finish()
          break
      }
      return emit.apply(this, arguments)
    }
  }
}

function createWrapRequest (tracer, config, sessionDetails) {
  return function wrapRequest (request) {
    if (!sessionDetails) return request

    return function requestWithTrace (headers, options) {
      const scope = tracer.scope()
      const span = startSpan(tracer, config, headers, sessionDetails)

      addRequestTags(headers, span, config)

      const req = scope.bind(request, span).apply(this, arguments)

      shimmer.wrap(req, 'emit', createWrapEmit(tracer, config, span))
      scope.bind(req)

      return req
    }
  }
}

function createWrapConnect (tracer, config) {
  config = normalizeConfig(tracer, config)

  return function wrapConnect (connect) {
    return function connectWithTrace (authority, options) {
      const session = connect.apply(this, arguments)

      const sessionDetails = extractSessionDetails(authority, options)

      shimmer.wrap(session, 'request', createWrapRequest(tracer, config, sessionDetails))
      return session
    }
  }
}

module.exports = [
  {
    name: 'http2',
    patch: function (http2, tracer, config) {
      if (config.client === false) return

      this.wrap(http2, 'connect', createWrapConnect(tracer, config))
    },
    unpatch: function (http2) {
      this.unwrap(http2, 'connect')
    }
  }
]


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-http2/src/server.js":
/*!************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-http2/src/server.js ***!
  \************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const web = __webpack_require__(/*! ../../dd-trace/src/plugins/util/web */ "../../node_modules/dd-trace/packages/dd-trace/src/plugins/util/web.js")
const shimmer = __webpack_require__(/*! shimmer */ "../../node_modules/shimmer/index.js")

const analyticsSampler = __webpack_require__(/*! ../../dd-trace/src/analytics_sampler */ "../../node_modules/dd-trace/packages/dd-trace/src/analytics_sampler.js")
const tags = __webpack_require__(/*! ../../../ext/tags */ "../../node_modules/dd-trace/ext/tags.js")
const types = __webpack_require__(/*! ../../../ext/types */ "../../node_modules/dd-trace/ext/types.js")
const kinds = __webpack_require__(/*! ../../../ext/kinds */ "../../node_modules/dd-trace/ext/kinds.js")

const WEB = types.WEB
const SERVER = kinds.SERVER
const RESOURCE_NAME = tags.RESOURCE_NAME
const SERVICE_NAME = tags.SERVICE_NAME
const SPAN_TYPE = tags.SPAN_TYPE
const SPAN_KIND = tags.SPAN_KIND
const HTTP_METHOD = tags.HTTP_METHOD
const HTTP_URL = tags.HTTP_URL
const HTTP_STATUS_CODE = tags.HTTP_STATUS_CODE
const HTTP_ROUTE = tags.HTTP_ROUTE
const HTTP_REQUEST_HEADERS = tags.HTTP_REQUEST_HEADERS
const HTTP_RESPONSE_HEADERS = tags.HTTP_RESPONSE_HEADERS

const HTTP_STATUS_OK = 200
const HTTP2_HEADER_AUTHORITY = ':authority'
const HTTP2_HEADER_SCHEME = ':scheme'
const HTTP2_HEADER_METHOD = ':method'
const HTTP2_HEADER_PATH = ':path'
const HTTP2_HEADER_STATUS = ':status'

function createWrapEmit (tracer, config) {
  return function wrapEmit (emit) {
    return function emitWithTrace (event, arg1, arg2) {
      if (event === 'stream') {
        const stream = arg1
        const headers = arg2
        return instrumentStream(tracer, config, stream, headers, 'http.request', () => {
          return emit.apply(this, arguments)
        })
      } else if (event === 'request') {
        const req = arg1
        const res = arg2
        return web.instrument(tracer, config, req, res, 'http.request', () => {
          return emit.apply(this, arguments)
        })
      } else {
        return emit.apply(this, arguments)
      }
    }
  }
}

function createWrapCreateServer (tracer, config) {
  config = web.normalizeConfig(config)

  return function wrapCreateServer (createServer) {
    return function createServerWithTrace (args) {
      const server = createServer.apply(this, arguments)

      shimmer.wrap(server, 'emit', createWrapEmit(tracer, config))

      return server
    }
  }
}

function instrumentStream (tracer, config, stream, headers, name, callback) {
  if (!stream) return callback()

  headers = headers || {}

  web.patch(stream)

  const span = startStreamSpan(tracer, config, stream, headers, name)

  // TODO: replace this with a REFERENCE_NOOP after we split http/express/etc
  if (!config.filter(headers[HTTP2_HEADER_PATH])) {
    span.context()._traceFlags.sampled = false
  }

  if (config.service) {
    span.setTag(SERVICE_NAME, config.service)
  }

  analyticsSampler.sample(span, config.analytics, true)

  wrapStreamEnd(stream)

  addRequestTags(stream, headers)
  addRequestHeaders(stream, headers)
  addResourceTags(stream, headers)

  return callback && tracer.scope().activate(span, () => callback(span))
}

function startStreamSpan (tracer, config, stream, headers, name) {
  stream._datadog.config = config

  if (stream._datadog.span) {
    return stream._datadog.span
  }

  const span = web.startChildSpan(tracer, name, headers)

  stream._datadog.tracer = tracer
  stream._datadog.span = span

  return span
}

function wrapStreamEnd (stream) {
  function wrapEnd (end) {
    return function endWithTrace () {
      const returnValue = end.apply(this, arguments)

      finishStream(stream)
      return returnValue
    }
  }

  shimmer.wrap(stream, 'end', wrapEnd)
}

function finishStream (stream) {
  if (stream._datadog.finished) return

  addResponseTags(stream)
  addResponseHeaders(stream)

  stream._datadog.span.finish()
  stream._datadog.finished = true
}

function addRequestTags (stream, headers) {
  const span = stream._datadog.span
  const url = `${headers[HTTP2_HEADER_SCHEME]}://${headers[HTTP2_HEADER_AUTHORITY]}${headers[HTTP2_HEADER_PATH]}`

  span.addTags({
    [HTTP_METHOD]: headers[HTTP2_HEADER_METHOD],
    [HTTP_URL]: url.split('?')[0],
    [SPAN_KIND]: SERVER,
    [SPAN_TYPE]: WEB
  })
}

function addRequestHeaders (stream, headers) {
  if (!headers) return

  const span = stream._datadog.span

  stream._datadog.config.headers.forEach(key => {
    const reqHeader = headers[key]

    if (reqHeader) {
      span.setTag(`${HTTP_REQUEST_HEADERS}.${key}`, reqHeader)
    }
  })
}

function addResponseTags (stream) {
  const span = stream._datadog.span
  const headers = stream.sentHeaders
  const statusCode = headers[HTTP2_HEADER_STATUS]

  span.addTags({
    [HTTP_STATUS_CODE]: statusCode | 0 || HTTP_STATUS_OK
  })

  web.addStatusError(stream, statusCode)
}

function addResponseHeaders (stream) {
  if (!stream.sentHeaders) return

  const span = stream._datadog.span

  stream._datadog.config.headers.forEach(key => {
    const resHeader = stream.sentHeaders && stream.sentHeaders[key]

    if (resHeader) {
      span.setTag(`${HTTP_RESPONSE_HEADERS}.${key}`, resHeader)
    }
  })
}

function addResourceTags (stream, headers) {
  const span = stream._datadog.span
  const tags = span.context()._tags
  const method = headers[HTTP2_HEADER_METHOD]

  if (tags[RESOURCE_NAME]) return

  const resource = [method]
    .concat(tags[HTTP_ROUTE])
    .filter(val => val)
    .join(' ')

  span.setTag(RESOURCE_NAME, resource)
}

module.exports = [
  {
    name: 'http2',
    patch (http2, tracer, config) {
      if (config.server === false) return

      this.wrap(http2, 'createServer', createWrapCreateServer(tracer, config))
      this.wrap(http2, 'createSecureServer', createWrapCreateServer(tracer, config))
    },
    unpatch (http2) {
      this.unwrap(http2, 'createServer')
      this.unwrap(http2, 'createSecureServer')
    }
  }
]

module.exports = [] // temporarily disable HTTP2 server plugin


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-ioredis/src/index.js":
/*!*************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-ioredis/src/index.js ***!
  \*************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const tx = __webpack_require__(/*! ../../dd-trace/src/plugins/util/redis */ "../../node_modules/dd-trace/packages/dd-trace/src/plugins/util/redis.js")

function createWrapSendCommand (tracer, config) {
  return function wrapSendCommand (sendCommand) {
    return function sendCommandWithTrace (command, stream) {
      if (!command || !command.promise || !config.filter(command.name)) return sendCommand.apply(this, arguments)

      const options = this.options || {}
      const db = options.db
      const span = tx.instrument(tracer, config, db, command.name, command.args)

      tx.setHost(span, options.host, options.port)
      tx.wrap(span, command.promise)

      return tracer.scope().bind(sendCommand, span).apply(this, arguments)
    }
  }
}

module.exports = {
  name: 'ioredis',
  versions: ['>=2'],
  patch (Redis, tracer, config) {
    config = tx.normalizeConfig(config)
    this.wrap(Redis.prototype, 'sendCommand', createWrapSendCommand(tracer, config))
  },
  unpatch (Redis) {
    this.unwrap(Redis.prototype, 'sendCommand')
  }
}


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-jest/src/index.js":
false,

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-jest/src/jest-environment.js":
false,

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-jest/src/jest-jasmine2.js":
false,

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-jest/src/util.js":
false,

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-kafkajs/src/index.js":
false,

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-knex/src/index.js":
/*!**********************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-knex/src/index.js ***!
  \**********************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const tx = __webpack_require__(/*! ../../dd-trace/src/plugins/util/promise */ "../../node_modules/dd-trace/packages/dd-trace/src/plugins/util/promise.js")

function createPatch (file) {
  return {
    name: 'knex',
    versions: ['>=0.8.0'],
    file,
    patch (Builder, tracer, config) {
      this.wrap(Builder.prototype, 'then', tx.createWrapThen(tracer, config))
    },
    unpatch (Builder) {
      this.unwrap(Builder.prototype, 'then')
    }
  }
}

module.exports = [
  createPatch('lib/query/builder.js'),
  createPatch('lib/raw.js'),
  createPatch('lib/schema/builder.js')
]


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-koa/src/index.js":
/*!*********************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-koa/src/index.js ***!
  \*********************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const web = __webpack_require__(/*! ../../dd-trace/src/plugins/util/web */ "../../node_modules/dd-trace/packages/dd-trace/src/plugins/util/web.js")

function createWrapCallback (tracer, config) {
  config = web.normalizeConfig(config)

  return function wrapCallback (callback) {
    return function callbackWithTrace () {
      const handleRequest = callback.apply(this, arguments)

      if (typeof handleRequest !== 'function') return handleRequest

      return function handleRequestWithTrace (req, res) {
        web.instrument(tracer, config, req, res, 'koa.request')

        return handleRequest.apply(this, arguments)
      }
    }
  }
}

function createWrapCreateContext () {
  return function wrapCreateContext (createContext) {
    return function createContextWithTrace (req, res) {
      const ctx = createContext.apply(this, arguments)

      if (!ctx) return ctx

      web.patch(req)
      web.beforeEnd(req, () => {
        web.enterRoute(req, ctx.routePath)
      })

      return ctx
    }
  }
}

function createWrapUse () {
  return function wrapUse (use) {
    return function useWithTrace () {
      const result = use.apply(this, arguments)

      if (!Array.isArray(this.middleware)) return result

      const fn = this.middleware.pop()

      this.middleware.push(wrapMiddleware(fn))

      return result
    }
  }
}

function createWrapRegister (tracer, config) {
  return function wrapRegister (register) {
    return function registerWithTrace (path, methods, middleware, opts) {
      const route = register.apply(this, arguments)

      if (!Array.isArray(path) && route && Array.isArray(route.stack)) {
        wrapStack(route)
      }

      return route
    }
  }
}

function createWrapRouterUse (tracer, config) {
  return function wrapUse (use) {
    return function useWithTrace () {
      const router = use.apply(this, arguments)

      router.stack.forEach(wrapStack)

      return router
    }
  }
}

function wrapStack (layer) {
  layer.stack = layer.stack.map(middleware => {
    if (typeof middleware !== 'function') return middleware

    middleware = middleware._dd_original || middleware

    const wrappedMiddleware = wrapMiddleware(middleware)

    const handler = function (ctx, next) {
      if (!ctx || !web.active(ctx.req)) return middleware.apply(this, arguments)

      web.exitRoute(ctx.req)
      web.enterRoute(ctx.req, layer.path)

      return wrappedMiddleware.apply(this, arguments)
    }

    handler._dd_original = middleware

    return handler
  })
}

function wrapMiddleware (fn) {
  if (typeof fn !== 'function') return fn

  return function (ctx, next) {
    if (!ctx) return fn.apply(this, arguments)

    return web.wrapMiddleware(ctx.req, fn, 'koa.middleware', () => {
      try {
        const result = fn.apply(this, arguments)

        if (result && typeof result.then === 'function') {
          result.then(
            () => web.finish(ctx.req),
            err => web.finish(ctx.req, err)
          )
        } else {
          web.finish(ctx.req)
        }

        return result
      } catch (e) {
        web.finish(ctx.req, e)
        throw e
      }
    })
  }
}

module.exports = [
  {
    name: 'koa',
    versions: ['>=2'],
    patch (Koa, tracer, config) {
      this.wrap(Koa.prototype, 'callback', createWrapCallback(tracer, config))
      this.wrap(Koa.prototype, 'createContext', createWrapCreateContext(tracer, config))
      this.wrap(Koa.prototype, 'use', createWrapUse(tracer, config))
    },
    unpatch (Koa) {
      this.unwrap(Koa.prototype, 'callback')
      this.unwrap(Koa.prototype, 'createContext')
      this.unwrap(Koa.prototype, 'use')
    }
  },
  {
    name: '@koa/router',
    versions: ['>=8'],
    patch (Router, tracer, config) {
      this.wrap(Router.prototype, 'register', createWrapRegister(tracer, config))
      this.wrap(Router.prototype, 'use', createWrapRouterUse(tracer, config))
    },
    unpatch (Router) {
      this.unwrap(Router.prototype, 'register')
      this.unwrap(Router.prototype, 'use')
    }
  },
  {
    name: 'koa-router',
    versions: ['>=7'],
    patch (Router, tracer, config) {
      this.wrap(Router.prototype, 'register', createWrapRegister(tracer, config))
      this.wrap(Router.prototype, 'use', createWrapRouterUse(tracer, config))
    },
    unpatch (Router) {
      this.unwrap(Router.prototype, 'register')
      this.unwrap(Router.prototype, 'use')
    }
  }
]


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-memcached/src/index.js":
/*!***************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-memcached/src/index.js ***!
  \***************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const analyticsSampler = __webpack_require__(/*! ../../dd-trace/src/analytics_sampler */ "../../node_modules/dd-trace/packages/dd-trace/src/analytics_sampler.js")

function createWrapCommand (tracer, config) {
  return function wrapCommand (command) {
    return function commandWithTrace (queryCompiler, server) {
      const scope = tracer.scope()
      const childOf = scope.active()
      const span = tracer.startSpan('memcached.command', {
        childOf,
        tags: {
          'span.kind': 'client',
          'span.type': 'memcached',
          'service.name': config.service || `${tracer._service}-memcached`
        }
      })

      analyticsSampler.sample(span, config.analytics)

      queryCompiler = wrapQueryCompiler(queryCompiler, this, server, scope, span)

      return scope.bind(command, span).call(this, queryCompiler, server)
    }
  }
}

function wrapQueryCompiler (original, client, server, scope, span) {
  const parent = scope.active()

  return function () {
    const query = original.apply(this, arguments)
    const callback = query.callback

    span.addTags({
      'resource.name': query.type,
      'memcached.command': query.command
    })

    addHost(span, client, server, query)

    query.callback = scope.bind(function (err) {
      addError(span, err)

      span.finish()

      return callback.apply(this, arguments)
    }, parent)

    return query
  }
}

function addHost (span, client, server, query) {
  const address = getAddress(client, server, query)

  if (address) {
    span.addTags({
      'out.host': address[0],
      'out.port': address[1]
    })
  }
}

function addError (span, error) {
  if (error) {
    span.addTags({
      'error.type': error.name,
      'error.msg': error.message,
      'error.stack': error.stack
    })
  }

  return error
}

function getAddress (client, server, query) {
  if (!server) {
    if (client.servers.length === 1) {
      server = client.servers[0]
    } else {
      let redundancy = client.redundancy && client.redundancy < client.servers.length
      const queryRedundancy = query.redundancyEnabled

      if (redundancy && queryRedundancy) {
        redundancy = client.HashRing.range(query.key, (client.redundancy + 1), true)
        server = redundancy.shift()
      } else {
        server = client.HashRing.get(query.key)
      }
    }
  }

  return server && server.split(':')
}

module.exports = {
  name: 'memcached',
  versions: ['>=2.2'],
  patch (Memcached, tracer, config) {
    this.wrap(Memcached.prototype, 'command', createWrapCommand(tracer, config))
  },
  unpatch (Memcached) {
    this.unwrap(Memcached.prototype, 'command')
  }
}


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-microgateway-core/src/index.js":
/*!***********************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-microgateway-core/src/index.js ***!
  \***********************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const web = __webpack_require__(/*! ../../dd-trace/src/plugins/util/web */ "../../node_modules/dd-trace/packages/dd-trace/src/plugins/util/web.js")

// https://docs.apigee.com/api-platform/microgateway/3.1.x/develop-custom-plugins#eventhandlerfunctions
const listeners = [
  'onrequest',
  'ondata_request',
  'onend_request',
  'onclose_request',
  'onerror_request',
  'onresponse',
  'ondata_response',
  'onend_response',
  'onclose_response',
  'onerror_response'
]

function createWrapGateway (tracer, config) {
  config = web.normalizeConfig(config)

  return function wrapGateway (Gateway) {
    return function GatewayWithTrace (config) {
      const gateway = Gateway.apply(this, arguments)

      gateway.addPlugin = wrapAddPlugin(gateway.addPlugin)

      return gateway
    }
  }
}

function createWrapConfigProxyFactory (tracer, config) {
  config = web.normalizeConfig(config)

  return function wrapConfigProxyFactory (configProxyFactory) {
    return function configProxyFactoryWithTrace () {
      const configProxy = configProxyFactory.apply(this, arguments)

      return function configProxyWithTrace (req, res, next) {
        return web.instrument(tracer, config, req, res, 'microgateway.request', () => {
          web.beforeEnd(req, () => {
            res.proxy && web.enterRoute(req, res.proxy.base_path)
          })

          return configProxy.call(this, req, res, wrapNext(req, next))
        })
      }
    }
  }
}

function createWrapPluginsFactory (tracer, config) {
  config = web.normalizeConfig(config)

  return function wrapPluginsFactory (pluginsFactory) {
    return function pluginsFactoryWithTrace (plugins) {
      const pluginsMiddleware = pluginsFactory.apply(this, arguments)

      return function pluginsMiddlewareWithTrace (req, res, next) {
        return pluginsMiddleware.call(this, req, res, wrapNext(req, next))
      }
    }
  }
}

function wrapAddPlugin (addPlugin) {
  return function (name, plugin) {
    if (typeof plugin === 'function') {
      plugin = wrapPluginInit(plugin)
    } else if (plugin && typeof plugin.init === 'function') {
      plugin.init = wrapPluginInit(plugin.init)
    }

    return addPlugin.call(this, name, plugin)
  }
}

function wrapPluginInit (init) {
  return function initWithTrace (config, logging, stats) {
    const handler = init.apply(this, arguments)

    if (!handler._dd_patched) {
      wrapListeners(handler)
    }

    return handler
  }
}

function wrapNext (req, next) {
  return function nextWithTrace (err) {
    web.addError(req, err)

    return next.apply(this, arguments)
  }
}

function wrapListeners (handler) {
  for (const name of listeners) {
    const listener = handler[name]

    if (!listener) continue

    switch (listener.length) {
      case 3:
        handler[name] = function handlerWithTrace (req, res, next) {
          return web.reactivate(req, () => listener.apply(this, arguments))
        }
        break
      case 4:
        handler[name] = function handlerWithTrace (req, res, data, next) {
          return web.reactivate(req, () => listener.apply(this, arguments))
        }
        break
    }
  }
}

module.exports = [
  {
    name: 'microgateway-core',
    versions: ['>=2.1'],
    patch (Gateway, tracer, config) {
      return this.wrapExport(Gateway, createWrapGateway(tracer, config)(Gateway))
    },
    unpatch (Gateway) {
      this.unwrapExport(Gateway)
    }
  },
  {
    name: 'microgateway-core',
    versions: ['>=2.1'],
    file: 'lib/config-proxy-middleware.js',
    patch (configProxyFactory, tracer, config) {
      const wrapper = createWrapConfigProxyFactory(tracer, config)(configProxyFactory)
      return this.wrapExport(configProxyFactory, wrapper)
    },
    unpatch (configProxyFactory) {
      this.unwrapExport(configProxyFactory)
    }
  },
  {
    name: 'microgateway-core',
    versions: ['>=2.1'],
    file: 'lib/plugins-middleware.js',
    patch (pluginsFactory, tracer, config) {
      const wrapper = createWrapPluginsFactory(tracer, config)(pluginsFactory)
      return this.wrapExport(pluginsFactory, wrapper)
    },
    unpatch (pluginsFactory) {
      this.unwrapExport(pluginsFactory)
    }
  }
]


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-mocha/src/index.js":
false,

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-moleculer/src/client.js":
false,

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-moleculer/src/index.js":
false,

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-moleculer/src/server.js":
false,

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-moleculer/src/util.js":
false,

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-mongodb-core/src/index.js":
/*!******************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-mongodb-core/src/index.js ***!
  \******************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const unified = __webpack_require__(/*! ./unified */ "../../node_modules/dd-trace/packages/datadog-plugin-mongodb-core/src/unified.js")
const legacy = __webpack_require__(/*! ./legacy */ "../../node_modules/dd-trace/packages/datadog-plugin-mongodb-core/src/legacy.js")

module.exports = [].concat(unified, legacy)


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-mongodb-core/src/legacy.js":
/*!*******************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-mongodb-core/src/legacy.js ***!
  \*******************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const { instrument } = __webpack_require__(/*! ./util */ "../../node_modules/dd-trace/packages/datadog-plugin-mongodb-core/src/util.js")

function createWrapCommand (tracer, config, name) {
  return function wrapCommand (command) {
    return function commandWithTrace (ns, ops) {
      return instrument(command, this, arguments, this, ns, ops, tracer, config, { name })
    }
  }
}

function createWrapQuery (tracer, config) {
  return function wrapQuery (query) {
    return function queryWithTrace () {
      const pool = this.server.s.pool
      const ns = this.ns
      const ops = this.cmd

      return instrument(query, this, arguments, pool, ns, ops, tracer, config)
    }
  }
}

function createWrapCursor (tracer, config, name) {
  return function wrapCursor (cursor) {
    return function cursorWithTrace () {
      const pool = this.server.s.pool
      const ns = this.ns

      return instrument(cursor, this, arguments, pool, ns, {}, tracer, config, { name })
    }
  }
}

module.exports = [
  {
    name: 'mongodb-core',
    versions: ['2 - 3.1.9'],
    patch ({ Cursor, Server }, tracer, config) {
      this.wrap(Server.prototype, 'command', createWrapCommand(tracer, config))
      this.wrap(Server.prototype, 'insert', createWrapCommand(tracer, config, 'insert'))
      this.wrap(Server.prototype, 'update', createWrapCommand(tracer, config, 'update'))
      this.wrap(Server.prototype, 'remove', createWrapCommand(tracer, config, 'remove'))
      this.wrap(Cursor.prototype, '_getmore', createWrapCursor(tracer, config, 'getMore'))
      this.wrap(Cursor.prototype, '_find', createWrapQuery(tracer, config))
      this.wrap(Cursor.prototype, 'kill', createWrapCursor(tracer, config, 'killCursors'))
    },
    unpatch ({ Cursor, Server }) {
      this.unwrap(Server.prototype, 'command')
      this.unwrap(Server.prototype, 'insert')
      this.unwrap(Server.prototype, 'update')
      this.unwrap(Server.prototype, 'remove')
      this.unwrap(Cursor.prototype, '_getmore')
      this.unwrap(Cursor.prototype, '_find')
      this.unwrap(Cursor.prototype, 'kill')
    }
  }
]


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-mongodb-core/src/unified.js":
/*!********************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-mongodb-core/src/unified.js ***!
  \********************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const { instrument } = __webpack_require__(/*! ./util */ "../../node_modules/dd-trace/packages/datadog-plugin-mongodb-core/src/util.js")

function createWrapCommand (tracer, config, name) {
  return function wrapCommand (command) {
    return function commandWithTrace (server, ns, ops) {
      return instrument(command, this, arguments, server, ns, ops, tracer, config, { name })
    }
  }
}

function patch (wp, tracer, config) {
  this.wrap(wp, 'command', createWrapCommand(tracer, config))
  this.wrap(wp, 'insert', createWrapCommand(tracer, config, 'insert'))
  this.wrap(wp, 'update', createWrapCommand(tracer, config, 'update'))
  this.wrap(wp, 'remove', createWrapCommand(tracer, config, 'remove'))
  this.wrap(wp, 'query', createWrapCommand(tracer, config))
  this.wrap(wp, 'getMore', createWrapCommand(tracer, config, 'getMore'))
  this.wrap(wp, 'killCursors', createWrapCommand(tracer, config, 'killCursors'))
}

function unpatch (wp) {
  this.unwrap(wp, 'command')
  this.unwrap(wp, 'insert')
  this.unwrap(wp, 'update')
  this.unwrap(wp, 'remove')
  this.unwrap(wp, 'query')
  this.unwrap(wp, 'getMore')
  this.unwrap(wp, 'killCursors')
}

function patchClass (WireProtocol, tracer, config) {
  this.wrap(WireProtocol.prototype, 'command', createWrapCommand(tracer, config))
}

function unpatchClass (WireProtocol) {
  this.unwrap(WireProtocol.prototype, 'command')
}

module.exports = [
  {
    name: 'mongodb',
    versions: ['>=3.3'],
    file: 'lib/core/wireprotocol/index.js',
    patch,
    unpatch
  },
  {
    name: 'mongodb-core',
    versions: ['>=3.2'],
    file: 'lib/wireprotocol/index.js',
    patch,
    unpatch
  },
  {
    name: 'mongodb-core',
    versions: ['~3.1.10'],
    file: 'lib/wireprotocol/3_2_support.js',
    patch: patchClass,
    unpatch: unpatchClass
  },
  {
    name: 'mongodb-core',
    versions: ['~3.1.10'],
    file: 'lib/wireprotocol/2_6_support.js',
    patch: patchClass,
    unpatch: unpatchClass
  }
]


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-mongodb-core/src/util.js":
/*!*****************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-mongodb-core/src/util.js ***!
  \*****************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const analyticsSampler = __webpack_require__(/*! ../../dd-trace/src/analytics_sampler */ "../../node_modules/dd-trace/packages/dd-trace/src/analytics_sampler.js")

function instrument (command, ctx, args, server, ns, ops, tracer, config, options = {}) {
  const name = options.name || (ops && Object.keys(ops)[0])
  const index = args.length - 1
  const callback = args[index]

  if (typeof callback !== 'function') return command.apply(ctx, args)

  const span = startSpan(tracer, config, ns, ops, server, name)

  if (name !== 'getMore' && name !== 'killCursors') {
    analyticsSampler.sample(span, config.analytics)
  }

  args[index] = wrapCallback(tracer, span, callback)

  return tracer.scope().bind(command, span).apply(ctx, args)
}

function startSpan (tracer, config, ns, ops, server, name) {
  const scope = tracer.scope()
  const childOf = scope.active()
  const span = tracer.startSpan('mongodb.query', { childOf })

  addTags(span, tracer, config, ns, ops, server, name)

  return span
}

function wrapCallback (tracer, span, done) {
  return tracer.scope().bind((err, res) => {
    if (err) {
      span.addTags({
        'error.type': err.name,
        'error.msg': err.message,
        'error.stack': err.stack
      })
    }

    span.finish()

    if (done) {
      done(err, res)
    }
  })
}

function addTags (span, tracer, config, ns, cmd, topology, operationName) {
  const query = getQuery(cmd)
  const resource = getResource(ns, query, operationName)

  span.addTags({
    'service.name': config.service || `${tracer._service}-mongodb`,
    'resource.name': resource,
    'span.type': 'mongodb',
    'db.name': ns
  })

  if (query) {
    span.setTag('mongodb.query', query)
  }

  addHost(span, topology)
}

function addHost (span, topology) {
  const options = topology && topology.s && topology.s.options

  if (options && options.host && options.port) {
    span.addTags({
      'out.host': topology.s.options.host,
      'out.port': topology.s.options.port
    })
  }
}

function getQuery (cmd) {
  if (!cmd || typeof cmd !== 'object' || Array.isArray(cmd)) return
  if (cmd.query) return JSON.stringify(sanitize(cmd.query))
  if (cmd.filter) return JSON.stringify(sanitize(cmd.filter))
}

function getResource (ns, query, operationName) {
  const parts = [operationName, ns]

  if (query) {
    parts.push(query)
  }

  return parts.join(' ')
}

function sanitize (input) {
  const output = {}

  if (!isObject(input) || Buffer.isBuffer(input) || isBSON(input)) return '?'

  for (const key in input) {
    if (typeof input[key] === 'function') continue

    output[key] = sanitize(input[key])
  }

  return output
}

function isObject (val) {
  return typeof val === 'object' && val !== null && !(val instanceof Array)
}

function isBSON (val) {
  return val && val._bsontype
}

module.exports = { instrument }


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-mongoose/src/index.js":
/*!**************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-mongoose/src/index.js ***!
  \**************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const tx = __webpack_require__(/*! ../../dd-trace/src/plugins/util/promise */ "../../node_modules/dd-trace/packages/dd-trace/src/plugins/util/promise.js")

function createWrapCollectionAddQueue (tracer, config) {
  return function wrapAddQueue (addQueue) {
    return function addQueueWithTrace (name) {
      const scope = tracer.scope()

      if (typeof name === 'function') {
        arguments[0] = scope.bind(name)
      } else if (typeof this[name] === 'function') {
        arguments[0] = scope.bind((...args) => this[name](...args))
      }

      return addQueue.apply(this, arguments)
    }
  }
}

module.exports = [
  {
    name: 'mongoose',
    versions: ['>=4.6.4'],
    patch (mongoose, tracer, config) {
      if (mongoose.Promise !== global.Promise) {
        this.wrap(mongoose.Promise.prototype, 'then', tx.createWrapThen(tracer, config))
      }

      this.wrap(mongoose.Collection.prototype, 'addQueue', createWrapCollectionAddQueue(tracer, config))
    },
    unpatch (mongoose) {
      if (mongoose.Promise !== global.Promise) {
        this.unwrap(mongoose.Promise.prototype, 'then')
      }

      this.unwrap(mongoose.Collection.prototype, 'addQueue')
    }
  }
]


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-mysql/src/index.js":
/*!***********************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-mysql/src/index.js ***!
  \***********************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Tags = __webpack_require__(/*! opentracing */ "../../node_modules/opentracing/lib/index.js").Tags
const analyticsSampler = __webpack_require__(/*! ../../dd-trace/src/analytics_sampler */ "../../node_modules/dd-trace/packages/dd-trace/src/analytics_sampler.js")

function createWrapQuery (tracer, config) {
  return function wrapQuery (query) {
    return function queryWithTrace (sql, values, cb) {
      const scope = tracer.scope()
      const childOf = scope.active()
      const span = tracer.startSpan('mysql.query', {
        childOf,
        tags: {
          [Tags.SPAN_KIND]: Tags.SPAN_KIND_RPC_CLIENT,
          'service.name': config.service || `${tracer._service}-mysql`,
          'span.type': 'sql',
          'db.type': 'mysql',
          'db.user': this.config.user,
          'out.host': this.config.host,
          'out.port': this.config.port
        }
      })

      if (this.config.database) {
        span.setTag('db.name', this.config.database)
      }

      analyticsSampler.sample(span, config.analytics)

      const sequence = scope.bind(query, span).call(this, sql, values, cb)

      scope.bind(sequence)

      span.setTag('resource.name', sequence.sql)

      if (sequence._callback) {
        sequence._callback = wrapCallback(tracer, span, childOf, sequence._callback)
      } else {
        sequence.on('end', () => {
          span.finish()
        })
      }

      return sequence
    }
  }
}

function createWrapGetConnection (tracer, config) {
  return function wrapGetConnection (getConnection) {
    return function getConnectionWithTrace (cb) {
      const scope = tracer.scope()
      return scope.bind(getConnection).call(this, scope.bind(cb))
    }
  }
}

function wrapCallback (tracer, span, parent, done) {
  return tracer.scope().bind((...args) => {
    const err = args[0]
    if (err) {
      span.addTags({
        'error.type': err.name,
        'error.msg': err.message,
        'error.stack': err.stack
      })
    }

    span.finish()

    done(...args)
  }, parent)
}

function patchConnection (Connection, tracer, config) {
  this.wrap(Connection.prototype, 'query', createWrapQuery(tracer, config))
}

function unpatchConnection (Connection) {
  this.unwrap(Connection.prototype, 'query')
}

function patchPool (Pool, tracer, config) {
  this.wrap(Pool.prototype, 'getConnection', createWrapGetConnection(tracer, config))
}

function unpatchPool (Pool) {
  this.unwrap(Pool.prototype, 'getConnection')
}

module.exports = [
  {
    name: 'mysql',
    file: 'lib/Connection.js',
    versions: ['>=2'],
    patch: patchConnection,
    unpatch: unpatchConnection
  },
  {
    name: 'mysql',
    file: 'lib/Pool.js',
    versions: ['>=2'],
    patch: patchPool,
    unpatch: unpatchPool
  }
]


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-mysql2/src/index.js":
/*!************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-mysql2/src/index.js ***!
  \************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Tags = __webpack_require__(/*! opentracing */ "../../node_modules/opentracing/lib/index.js").Tags
const analyticsSampler = __webpack_require__(/*! ../../dd-trace/src/analytics_sampler */ "../../node_modules/dd-trace/packages/dd-trace/src/analytics_sampler.js")

function createWrapAddCommand (tracer, config) {
  return function wrapAddCommand (addCommand) {
    return function addCommandWithTrace (cmd) {
      const name = cmd && cmd.constructor && cmd.constructor.name
      const isCommand = typeof cmd.execute === 'function'
      const isSupported = name === 'Execute' || name === 'Query'

      if (isCommand && isSupported) {
        cmd.execute = wrapExecute(tracer, config, cmd.execute)
      }

      return addCommand.apply(this, arguments)
    }
  }
}

function wrapExecute (tracer, config, execute) {
  const scope = tracer.scope()
  const childOf = scope.active()

  return function executeWithTrace (packet, connection) {
    const connectionConfig = (connection && connection.config) || {}
    const sql = this.statement ? this.statement.query : this.sql
    const span = tracer.startSpan('mysql.query', {
      childOf,
      tags: {
        [Tags.SPAN_KIND]: Tags.SPAN_KIND_RPC_CLIENT,
        'service.name': config.service || `${tracer._service}-mysql`,
        'resource.name': sql,
        'span.type': 'sql',
        'db.type': 'mysql',
        'db.user': connectionConfig.user,
        'db.name': connectionConfig.database,
        'out.host': connectionConfig.host,
        'out.port': connectionConfig.port
      }
    })

    analyticsSampler.sample(span, config.analytics)

    if (typeof this.onResult === 'function') {
      this.onResult = wrapCallback(tracer, span, childOf, this.onResult)
    } else {
      this.on('error', error => span.addTags({ error }))
      this.on('end', () => span.finish())
    }

    this.execute = execute

    return scope.bind(execute, span).apply(this, arguments)
  }
}

function wrapCallback (tracer, span, parent, done) {
  return tracer.scope().bind((error, res) => {
    span.addTags({ error })
    span.finish()

    done(error, res)
  }, parent)
}

module.exports = [
  {
    name: 'mysql2',
    file: 'lib/connection.js',
    versions: ['>=1'],
    patch (Connection, tracer, config) {
      this.wrap(Connection.prototype, 'addCommand', createWrapAddCommand(tracer, config))
    },
    unpatch (Connection) {
      this.unwrap(Connection.prototype, 'addCommand')
    }
  },
  {
    name: 'mysql2',
    file: 'lib/commands/command.js',
    versions: ['>=1'],
    patch (Command, tracer, config) {
      tracer.scope().bind(Command.prototype)
    },
    unpatch (Command, tracer) {
      tracer.scope().unbind(Command.prototype)
    }
  }
]


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-net/src/index.js":
/*!*********************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-net/src/index.js ***!
  \*********************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const tx = __webpack_require__(/*! ../../dd-trace/src/plugins/util/tx */ "../../node_modules/dd-trace/packages/dd-trace/src/plugins/util/tx.js")
const analyticsSampler = __webpack_require__(/*! ../../dd-trace/src/analytics_sampler */ "../../node_modules/dd-trace/packages/dd-trace/src/analytics_sampler.js")

function createWrapConnect (tracer, config) {
  return function wrapConnect (connect) {
    return function connectWithTrace () {
      const scope = tracer.scope()
      const options = getOptions(arguments)
      const lastIndex = arguments.length - 1
      const callback = arguments[lastIndex]

      if (!options) return connect.apply(this, arguments)

      if (typeof callback === 'function') {
        arguments[lastIndex] = scope.bind(callback)
      }

      const span = options.path
        ? wrapIpc(tracer, config, this, options)
        : wrapTcp(tracer, config, this, options)

      analyticsSampler.sample(span, config.analytics)

      return scope.bind(connect, span).apply(this, arguments)
    }
  }
}

function wrapTcp (tracer, config, socket, options) {
  const host = options.host || 'localhost'
  const port = options.port || 0
  const family = options.family || 4

  const span = startSpan(tracer, config, 'tcp', {
    'resource.name': [host, port].filter(val => val).join(':'),
    'tcp.remote.host': host,
    'tcp.remote.port': port,
    'tcp.family': `IPv${family}`,
    'out.host': host,
    'out.port': port
  })

  setupListeners(socket, span, 'tcp')

  return span
}

function wrapIpc (tracer, config, socket, options) {
  const span = startSpan(tracer, config, 'ipc', {
    'resource.name': options.path,
    'ipc.path': options.path
  })

  setupListeners(socket, span, 'ipc')

  return span
}

function startSpan (tracer, config, protocol, tags) {
  const childOf = tracer.scope().active()
  const span = tracer.startSpan(`${protocol}.connect`, {
    childOf,
    tags: Object.assign({
      'span.kind': 'client',
      'service.name': config.service || `${tracer._service}-${protocol}`
    }, tags)
  })

  return span
}

function getOptions (args) {
  if (!args[0]) return

  switch (typeof args[0]) {
    case 'object':
      if (Array.isArray(args[0])) return getOptions(args[0])
      return args[0]
    case 'string':
      if (isNaN(parseFloat(args[0]))) {
        return {
          path: args[0]
        }
      }
    case 'number': // eslint-disable-line no-fallthrough
      return {
        port: args[0],
        host: typeof args[1] === 'string' ? args[1] : 'localhost'
      }
  }
}

function setupListeners (socket, span, protocol) {
  const events = ['connect', 'error', 'close', 'timeout']

  const wrapListener = tx.wrap(span)

  const localListener = () => {
    span.addTags({
      'tcp.local.address': socket.localAddress,
      'tcp.local.port': socket.localPort
    })
  }

  const cleanupListener = () => {
    socket.removeListener('connect', localListener)

    events.forEach(event => {
      socket.removeListener(event, wrapListener)
      socket.removeListener(event, cleanupListener)
    })
  }

  if (protocol === 'tcp') {
    socket.once('connect', localListener)
  }

  events.forEach(event => {
    socket.once(event, wrapListener)
    socket.once(event, cleanupListener)
  })
}

module.exports = {
  name: 'net',
  patch (net, tracer, config) {
    __webpack_require__(/*! dns */ "dns") // net will otherwise get an unpatched version for DNS lookups

    tracer.scope().bind(net.Socket.prototype)

    this.wrap(net.Socket.prototype, 'connect', createWrapConnect(tracer, config))
  },
  unpatch (net, tracer) {
    tracer.scope().unbind(net.Socket.prototype)

    this.unwrap(net.Socket.prototype, 'connect')
  }
}


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-next/src/index.js":
false,

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-oracledb/src/index.js":
false,

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-paperplane/src/index.js":
/*!****************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-paperplane/src/index.js ***!
  \****************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const web = __webpack_require__(/*! ../../dd-trace/src/plugins/util/web */ "../../node_modules/dd-trace/packages/dd-trace/src/plugins/util/web.js")

const traceRoute = handler => req => {
  const { original, route } = req

  if (web.active(original)) {
    web.enterRoute(original, route)
  }

  return handler(req)
}

const wrapLogger = tracer => logger => record => {
  const span = tracer.scope().active()

  if (!span) return logger(record)

  const correlation = {
    dd: {
      trace_id: span.context().toTraceId(),
      span_id: span.context().toSpanId()
    }
  }

  record = record instanceof Error
    ? Object.assign(record, correlation)
    : Object.assign({}, record, correlation)

  return logger(record)
}

const wrapMount = (tracer, config) => mount => opts => {
  const handler = mount(opts)

  const traced = (req, res) =>
    web.instrument(
      tracer, config, req, res, 'paperplane.request',
      () => handler(req, res)
    )

  return traced
}

const wrapRoutes = tracer => routes => handlers => {
  const traced = {}

  for (const route in handlers) {
    traced[route] = traceRoute(handlers[route])
  }

  return routes(traced)
}

module.exports = [
  {
    name: 'paperplane',
    versions: ['>=2.3.2'],
    file: 'lib/logger.js',
    patch (exports, tracer) {
      if (tracer._logInjection) {
        this.wrap(exports, 'logger', wrapLogger(tracer))
      }
    },
    unpatch (exports) {
      this.unwrap(exports, 'logger')
    }
  },
  {
    name: 'paperplane',
    versions: ['>=2.3.2'],
    file: 'lib/mount.js',
    patch (exports, tracer, config) {
      config = web.normalizeConfig(config)
      this.wrap(exports, 'mount', wrapMount(tracer, config))
    },
    unpatch (exports) {
      this.unwrap(exports, 'mount')
    }
  },
  {
    name: 'paperplane',
    versions: ['>=2.3.2'],
    file: 'lib/routes.js',
    patch (exports, tracer) {
      this.wrap(exports, 'routes', wrapRoutes(tracer))
    },
    unpatch (exports) {
      this.unwrap(exports, 'routes')
    }
  },
  {
    name: 'paperplane',
    versions: ['2.3.0 - 2.3.1'],
    patch (paperplane, tracer, config) {
      config = web.normalizeConfig(config)
      this.wrap(paperplane, 'mount', wrapMount(tracer, config))
      this.wrap(paperplane, 'routes', wrapRoutes(tracer))
    },
    unpatch (paperplane) {
      this.unwrap(paperplane, ['mount', 'routes'])
    }
  }
]


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-pg/src/index.js":
/*!********************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-pg/src/index.js ***!
  \********************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Tags = __webpack_require__(/*! opentracing */ "../../node_modules/opentracing/lib/index.js").Tags
const analyticsSampler = __webpack_require__(/*! ../../dd-trace/src/analytics_sampler */ "../../node_modules/dd-trace/packages/dd-trace/src/analytics_sampler.js")

const OPERATION_NAME = 'pg.query'

function createWrapQuery (tracer, config) {
  return function wrapQuery (query) {
    return function queryWithTrace () {
      const scope = tracer.scope()
      const childOf = scope.active()
      const params = this.connectionParameters
      const service = getServiceName(tracer, config, params)
      const span = tracer.startSpan(OPERATION_NAME, {
        childOf,
        tags: {
          [Tags.SPAN_KIND]: Tags.SPAN_KIND_RPC_CLIENT,
          'service.name': service,
          'span.type': 'sql',
          'db.type': 'postgres'
        }
      })

      analyticsSampler.sample(span, config.analytics)

      const retval = scope.bind(query, span).apply(this, arguments)
      const queryQueue = this.queryQueue || this._queryQueue
      const activeQuery = this.activeQuery || this._activeQuery
      const pgQuery = queryQueue[queryQueue.length - 1] || activeQuery

      if (!pgQuery) {
        return retval
      }

      const originalCallback = pgQuery.callback
      const statement = pgQuery.text

      span.setTag('resource.name', statement)

      if (params) {
        span.addTags({
          'db.name': params.database,
          'db.user': params.user,
          'out.host': params.host,
          'out.port': params.port
        })
      }

      const finish = (error) => {
        span.setTag('error', error)
        span.finish()
      }

      if (originalCallback) {
        pgQuery.callback = scope.bind((err, res) => {
          finish(err)
          originalCallback(err, res)
        }, childOf)
      } else if (pgQuery.once) {
        pgQuery
          .once('error', finish)
          .once('end', () => finish())
      } else {
        pgQuery.then(() => finish(), finish)
      }

      return retval
    }
  }
}

function getServiceName (tracer, config, params) {
  if (typeof config.service === 'function') {
    return config.service(params)
  } else if (config.service) {
    return config.service
  } else {
    return `${tracer._service}-postgres`
  }
}

module.exports = [
  {
    name: 'pg',
    versions: ['>=4'],
    patch (pg, tracer, config) {
      this.wrap(pg.Client.prototype, 'query', createWrapQuery(tracer, config))
    },
    unpatch (pg) {
      this.unwrap(pg.Client.prototype, 'query')
    }
  },
  {
    name: 'pg',
    versions: ['>=4'],
    file: 'lib/native/index.js',
    patch (Client, tracer, config) {
      this.wrap(Client.prototype, 'query', createWrapQuery(tracer, config))
    },
    unpatch (Client) {
      this.unwrap(Client.prototype, 'query')
    }
  }
]


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-pino/src/index.js":
/*!**********************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-pino/src/index.js ***!
  \**********************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const { LOG } = __webpack_require__(/*! ../../../ext/formats */ "../../node_modules/dd-trace/ext/formats.js")

function createWrapPino (tracer, config) {
  return function wrapPino (pino) {
    return function pinoWithTrace () {
      const instance = pino.apply(this, arguments)
      const asJsonSym = (pino.symbols && pino.symbols.asJsonSym) || 'asJson'

      Object.defineProperty(instance, asJsonSym, {
        configurable: true,
        enumerable: true,
        writable: true,
        value: createWrapAsJson(tracer, config)(instance[asJsonSym])
      })

      return instance
    }
  }
}

function createWrapAsJson (tracer, config) {
  return function wrapAsJson (asJson) {
    return function asJsonWithTrace (obj, msg, num, time) {
      const span = tracer.scope().active()

      obj = arguments[0] = obj || {}

      tracer.inject(span, LOG, obj)

      const json = asJson.apply(this, arguments)

      obj && delete obj.dd

      return json
    }
  }
}

module.exports = [
  {
    name: 'pino',
    versions: ['2 - 3', '4', '>=5'],
    patch (pino, tracer, config) {
      if (!tracer._logInjection) return
      return this.wrapExport(pino, createWrapPino(tracer, config)(pino))
    },
    unpatch (pino) {
      return this.unwrapExport(pino)
    }
  }
]


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-promise-js/src/index.js":
/*!****************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-promise-js/src/index.js ***!
  \****************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const tx = __webpack_require__(/*! ../../dd-trace/src/plugins/util/promise */ "../../node_modules/dd-trace/packages/dd-trace/src/plugins/util/promise.js")

module.exports = [
  {
    name: 'promise-js',
    versions: ['>=0.0.3'],
    patch (Promise, tracer, config) {
      if (Promise !== global.Promise) {
        this.wrap(Promise.prototype, 'then', tx.createWrapThen(tracer, config))
      }
    },
    unpatch (Promise) {
      if (Promise !== global.Promise) {
        this.unwrap(Promise.prototype, 'then')
      }
    }
  }
]


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-promise/src/index.js":
/*!*************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-promise/src/index.js ***!
  \*************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const tx = __webpack_require__(/*! ../../dd-trace/src/plugins/util/promise */ "../../node_modules/dd-trace/packages/dd-trace/src/plugins/util/promise.js")

module.exports = [
  {
    name: 'promise',
    file: 'lib/core.js',
    versions: ['>=7'],
    patch (Promise, tracer, config) {
      this.wrap(Promise.prototype, 'then', tx.createWrapThen(tracer, config))
    },
    unpatch (Promise) {
      this.unwrap(Promise.prototype, 'then')
    }
  }
]


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-q/src/index.js":
/*!*******************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-q/src/index.js ***!
  \*******************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const tx = __webpack_require__(/*! ../../dd-trace/src/plugins/util/promise */ "../../node_modules/dd-trace/packages/dd-trace/src/plugins/util/promise.js")

module.exports = [
  {
    name: 'q',
    versions: ['>=1'],
    patch (Q, tracer, config) {
      this.wrap(Q.makePromise.prototype, 'then', tx.createWrapThen(tracer, config))
    },
    unpatch (Q) {
      this.unwrap(Q.makePromise.prototype, 'then')
    }
  }
]


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-redis/src/index.js":
/*!***********************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-redis/src/index.js ***!
  \***********************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const tx = __webpack_require__(/*! ../../dd-trace/src/plugins/util/redis */ "../../node_modules/dd-trace/packages/dd-trace/src/plugins/util/redis.js")

function createWrapInternalSendCommand (tracer, config) {
  return function wrapInternalSendCommand (internalSendCommand) {
    return function internalSendCommandWithTrace (options) {
      if (!config.filter(options.command)) return internalSendCommand.apply(this, arguments)

      const scope = tracer.scope()
      const span = startSpan(tracer, config, this, options.command, options.args)

      options.callback = scope.bind(tx.wrap(span, options.callback))

      return scope.bind(internalSendCommand, span).call(this, options)
    }
  }
}

function createWrapSendCommand (tracer, config) {
  return function wrapSendCommand (sendCommand) {
    return function sendCommandWithTrace (command, args, callback) {
      if (!config.filter(command)) return sendCommand.apply(this, arguments)

      const scope = tracer.scope()
      const span = startSpan(tracer, config, this, command, args)

      if (typeof callback === 'function') {
        callback = scope.bind(tx.wrap(span, callback))
      } else if (Array.isArray(args) && typeof args[args.length - 1] === 'function') {
        args[args.length - 1] = scope.bind(tx.wrap(span, args[args.length - 1]))
      } else {
        callback = tx.wrap(span)
      }

      return scope.bind(sendCommand, span).call(this, command, args, callback)
    }
  }
}

function startSpan (tracer, config, client, command, args) {
  const db = client.selected_db
  const connectionOptions = client.connection_options || client.connection_option || client.connectionOption || {}
  const span = tx.instrument(tracer, config, db, command, args)

  tx.setHost(span, connectionOptions.host, connectionOptions.port)

  return span
}

module.exports = [
  {
    name: 'redis',
    versions: ['>=2.6'],
    patch (redis, tracer, config) {
      config = tx.normalizeConfig(config)
      this.wrap(redis.RedisClient.prototype, 'internal_send_command', createWrapInternalSendCommand(tracer, config))
    },
    unpatch (redis) {
      this.unwrap(redis.RedisClient.prototype, 'internal_send_command')
    }
  },
  {
    name: 'redis',
    versions: ['>=0.12 <2.6'],
    patch (redis, tracer, config) {
      config = tx.normalizeConfig(config)
      this.wrap(redis.RedisClient.prototype, 'send_command', createWrapSendCommand(tracer, config))
    },
    unpatch (redis) {
      this.unwrap(redis.RedisClient.prototype, 'send_command')
    }
  }
]


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-restify/src/index.js":
/*!*************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-restify/src/index.js ***!
  \*************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const web = __webpack_require__(/*! ../../dd-trace/src/plugins/util/web */ "../../node_modules/dd-trace/packages/dd-trace/src/plugins/util/web.js")
const handlers = ['use', 'pre']
const methods = ['del', 'get', 'head', 'opts', 'post', 'put', 'patch']

function createWrapSetupRequest (tracer, config) {
  config = web.normalizeConfig(config)

  return function wrapSetupRequest (setupRequest) {
    return function setupRequestWithTrace (req, res) {
      return web.instrument(tracer, config, req, res, 'restify.request', () => {
        web.beforeEnd(req, () => {
          if (req.route) {
            web.enterRoute(req, req.route.path)
          }
        })

        return setupRequest.apply(this, arguments)
      })
    }
  }
}

function createWrapMethod (tracer, config) {
  return function wrapMethod (method) {
    return function methodWithTrace (path) {
      const middleware = wrapMiddleware(Array.prototype.slice.call(arguments, 1))

      return method.apply(this, [path].concat(middleware))
    }
  }
}

function createWrapHandler (tracer, config) {
  return function wrapMethod (method) {
    return function methodWithTrace () {
      return method.apply(this, wrapMiddleware(arguments))
    }
  }
}

function wrapMiddleware (middleware) {
  return Array.prototype.map.call(middleware, wrapFn)
}

function wrapFn (fn) {
  if (Array.isArray(fn)) return wrapMiddleware(fn)

  return function (req, res, next) {
    return web.reactivate(req, () => fn.apply(this, arguments))
  }
}

module.exports = [
  {
    name: 'restify',
    versions: ['>=3'],
    file: 'lib/server.js',
    patch (Server, tracer, config) {
      this.wrap(Server.prototype, '_setupRequest', createWrapSetupRequest(tracer, config))
      this.wrap(Server.prototype, handlers, createWrapHandler(tracer, config))
      this.wrap(Server.prototype, methods, createWrapMethod(tracer, config))
    },
    unpatch (Server) {
      this.unwrap(Server.prototype, '_setupRequest')
      this.unwrap(Server.prototype, handlers)
      this.unwrap(Server.prototype, methods)
    }
  }
]


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-rhea/src/index.js":
/*!**********************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-rhea/src/index.js ***!
  \**********************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const dd = Symbol('datadog')
const circularBufferConstructor = Symbol('circularBufferConstructor')
const inFlightDeliveries = Symbol('inFlightDeliveries')

function createWrapSend (tracer, config, instrumenter) {
  return function wrapSend (send) {
    return function sendWithTrace (msg, tag, format) {
      if (!canTrace(this)) {
        // we can't handle disconnects or ending spans, so we can't safely instrument
        return send.apply(this, arguments)
      }
      const name = getResourceNameFromSender(this)
      const { host, port } = getHostAndPort(this.connection)
      return tracer.trace('amqp.send', {
        tags: {
          'component': 'rhea',
          'resource.name': name,
          'service.name': config.service || `${tracer._service}-amqp-producer`,
          'span.kind': 'producer',
          'amqp.link.target.address': name,
          'amqp.link.role': 'sender',
          'out.host': host,
          'out.port': port
        }
      }, (span, done) => {
        addDeliveryAnnotations(msg, tracer, span)
        const delivery = send.apply(this, arguments)
        delivery[dd] = { done, span }
        addToInFlightDeliveries(this.connection, delivery)
        return delivery
      })
    }
  }
}

function createWrapConnectionDispatch (tracer, config) {
  return function wrapDispatch (dispatch) {
    return function dispatchWithTrace (eventName, obj) {
      if (eventName === 'disconnected') {
        const error = obj.error || this.saved_error
        if (this[inFlightDeliveries]) {
          this[inFlightDeliveries].forEach(delivery => {
            const { span } = delivery[dd]
            span.addTags({ error })
            finish(delivery, null)
          })
        }
      }
      return dispatch.apply(this, arguments)
    }
  }
}

function createWrapReceiverDispatch (tracer, config, instrumenter) {
  return function wrapDispatch (dispatch) {
    return function dispatchWithTrace (eventName, msgObj) {
      if (!canTrace(this)) {
        // we can't handle disconnects or ending spans, so we can't safely instrument
        return dispatch.apply(this, arguments)
      }
      if (eventName === 'message' && msgObj) {
        const name = getResourceNameFromMessage(msgObj)
        const childOf = getAnnotations(msgObj, tracer)
        return tracer.trace('amqp.receive', {
          tags: {
            'component': 'rhea',
            'resource.name': name,
            'service.name': config.service || tracer._service,
            'span.kind': 'consumer',
            'amqp.link.source.address': name,
            'amqp.link.role': 'receiver'
          },
          childOf
        }, (span, done) => {
          if (msgObj.delivery) {
            msgObj.delivery[dd] = { done, span }
            msgObj.delivery.update = wrapDeliveryUpdate(msgObj.delivery.update)
            addToInFlightDeliveries(this.connection, msgObj.delivery)
          }
          return dispatch.apply(this, arguments)
        })
      }

      return dispatch.apply(this, arguments)
    }
  }
}

function createWrapCircularBufferPopIf () {
  return function wrapCircularBufferPopIf (popIf) {
    return function wrappedPopIf (fn) {
      const wrappedFn = entry => {
        const shouldPop = fn(entry)
        if (shouldPop && entry[dd]) {
          const remoteState = entry.remote_state
          const state = remoteState && remoteState.constructor
            ? entry.remote_state.constructor.composite_type : undefined
          finish(entry, state)
        }
        return shouldPop
      }
      return popIf.call(this, wrappedFn)
    }
  }
}

function wrapDeliveryUpdate (update) {
  return function wrappedUpdate (settled, stateData) {
    if (this[dd]) {
      const state = getStateFromData(stateData)
      this[dd].span.setTag('amqp.delivery.state', state)
    }
    return update.apply(this, arguments)
  }
}

function patchCircularBuffer (proto, instrumenter) {
  Object.defineProperty(proto, 'outgoing', {
    configurable: true,
    get () {},
    set (outgoing) {
      delete proto.outgoing // removes the setter on the prototype
      this.outgoing = outgoing // assigns on the instance, like normal
      if (outgoing) {
        let CircularBuffer
        if (outgoing.deliveries) {
          CircularBuffer = outgoing.deliveries.constructor
        }
        if (CircularBuffer && !CircularBuffer.prototype.pop_if._datadog_patched) {
          instrumenter.wrap(CircularBuffer.prototype, 'pop_if', createWrapCircularBufferPopIf())
          const Session = proto.constructor
          if (Session) {
            Session[circularBufferConstructor] = CircularBuffer
          }
        }
      }
    }
  })
}

function addToInFlightDeliveries (connection, delivery) {
  let deliveries = connection[inFlightDeliveries]
  if (!deliveries) {
    deliveries = new Set()
    connection[inFlightDeliveries] = deliveries
  }
  deliveries.add(delivery)
  delivery[dd].connection = connection
}

function getHostAndPort (connection) {
  let host
  let port
  if (connection && connection.options) {
    host = connection.options.host
    port = connection.options.port
  }
  return { host, port }
}

function addDeliveryAnnotations (msg, tracer, span) {
  if (msg) {
    msg.delivery_annotations = msg.delivery_annotations || {}
    tracer.inject(span, 'text_map', msg.delivery_annotations)
  }
}

function getStateFromData (stateData) {
  if (stateData && stateData.descriptor && stateData.descriptor) {
    switch (stateData.descriptor.value) {
      case 0x24: return 'accepted'
      case 0x25: return 'rejected'
      case 0x26: return 'released'
      case 0x27: return 'modified'
    }
  }
}

function finish (delivery, state) {
  if (delivery[dd]) {
    if (state) {
      delivery[dd].span.setTag('amqp.delivery.state', state)
    }
    delivery[dd].done()
    if (delivery[dd].connection && delivery[dd].connection[inFlightDeliveries]) {
      delivery[dd].connection[inFlightDeliveries].delete(delivery)
    }
    delete delivery[dd]
  }
}

function getResourceNameFromMessage (msgObj) {
  let resourceName = 'amq.topic'
  let options = {}
  if (msgObj.receiver && msgObj.receiver.options) {
    options = msgObj.receiver.options
  }
  if (options.source && options.source.address) {
    resourceName = options.source.address
  }
  return resourceName
}

function getResourceNameFromSender (sender) {
  let resourceName = 'amq.topic'
  if (sender.options && sender.options.target && sender.options.target.address) {
    resourceName = sender.options.target.address
  }
  return resourceName
}

function getAnnotations (msgObj, tracer) {
  if (msgObj.message) {
    return tracer.extract('text_map', msgObj.message.delivery_annotations)
  }
}

function canTrace (link) {
  return link.connection && link.session && link.session.outgoing
}

module.exports = [
  {
    name: 'rhea',
    versions: ['>=1'],
    file: 'lib/link.js',
    patch ({ Sender, Receiver }, tracer, config) {
      this.wrap(Sender.prototype, 'send', createWrapSend(tracer, config, this))
      this.wrap(Receiver.prototype, 'dispatch', createWrapReceiverDispatch(tracer, config, this))
    },
    unpatch ({ Sender, Receiver }, tracer) {
      this.unwrap(Sender.prototype, 'send')
      this.unwrap(Receiver.prototype, 'dispatch')
    }
  },
  {
    name: 'rhea',
    versions: ['>=1'],
    file: 'lib/connection.js',
    patch (Connection, tracer, config) {
      this.wrap(Connection.prototype, 'dispatch', createWrapConnectionDispatch(tracer, config))
    },
    unpatch (Connection, tracer) {
      this.unwrap(Connection.prototype, 'dispatch')
    }
  },
  {
    name: 'rhea',
    versions: ['>=1'],
    file: 'lib/session.js',
    patch (Session, tracer, config) {
      patchCircularBuffer(Session.prototype, this)
    },
    unpatch (Session, tracer) {
      if (Session[circularBufferConstructor]) {
        this.unwrap(Session[circularBufferConstructor].prototype, 'pop_if')
      }
    }
  }
]


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-router/src/index.js":
/*!************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-router/src/index.js ***!
  \************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const METHODS = __webpack_require__(/*! methods */ "../../node_modules/methods/index.js").concat('all')
const pathToRegExp = __webpack_require__(/*! path-to-regexp */ "../../node_modules/path-to-regexp/index.js")
const web = __webpack_require__(/*! ../../dd-trace/src/plugins/util/web */ "../../node_modules/dd-trace/packages/dd-trace/src/plugins/util/web.js")

const regexpCache = Object.create(null)

function createWrapHandle (tracer, config) {
  return function wrapHandle (handle) {
    return function handleWithTracer (req, res, done) {
      web.patch(req)

      return handle.apply(this, arguments)
    }
  }
}

function wrapRouterMethod (original) {
  return function methodWithTrace (fn) {
    const offset = this.stack ? [].concat(this.stack).length : 0
    const router = original.apply(this, arguments)

    if (typeof this.stack === 'function') {
      this.stack = [{ handle: this.stack }]
    }

    wrapStack(this.stack, offset, extractMatchers(fn))

    return router
  }
}

function wrapLayerHandle (layer, handle) {
  handle._name = handle._name || layer.name

  let wrapCallHandle

  if (handle.length === 4) {
    wrapCallHandle = function (error, req, res, next) {
      return callHandle(layer, handle, req, [error, req, res, wrapNext(layer, req, next)])
    }
  } else {
    wrapCallHandle = function (req, res, next) {
      return callHandle(layer, handle, req, [req, res, wrapNext(layer, req, next)])
    }
  }

  // This is a workaround for the `loopback` library so that it can find the correct express layer
  // that contains the real handle function
  wrapCallHandle._datadog_orig = handle

  return wrapCallHandle
}

function wrapStack (stack, offset, matchers) {
  [].concat(stack).slice(offset).forEach(layer => {
    if (layer.__handle) { // express-async-errors
      layer.__handle = wrapLayerHandle(layer, layer.__handle)
    } else {
      layer.handle = wrapLayerHandle(layer, layer.handle)
    }

    layer._datadog_matchers = matchers

    if (layer.route) {
      METHODS.forEach(method => {
        if (typeof layer.route.stack === 'function') {
          layer.route.stack = [{ handle: layer.route.stack }]
        }

        layer.route[method] = wrapRouterMethod(layer.route[method])
      })
    }
  })
}

function wrapNext (layer, req, next) {
  if (!next || !web.active(req)) return next

  const originalNext = next

  return function (error) {
    if (!error && layer.path && !isFastStar(layer) && !isFastSlash(layer)) {
      web.exitRoute(req)
    }

    web.finish(req, error)

    originalNext.apply(null, arguments)
  }
}

function callHandle (layer, handle, req, args) {
  const matchers = layer._datadog_matchers

  if (web.active(req) && matchers) {
    // Try to guess which path actually matched
    for (let i = 0; i < matchers.length; i++) {
      if (matchers[i].test(layer)) {
        web.enterRoute(req, matchers[i].path)

        break
      }
    }
  }

  return web.wrapMiddleware(req, handle, 'express.middleware', () => {
    return handle.apply(layer, args)
  })
}

function extractMatchers (fn) {
  const arg = flatten([].concat(fn))

  if (typeof arg[0] === 'function') {
    return []
  }

  return arg.map(pattern => ({
    path: pattern instanceof RegExp ? `(${pattern})` : pattern,
    test: layer => !isFastStar(layer) && !isFastSlash(layer) && cachedPathToRegExp(pattern).test(layer.path)
  }))
}

function isFastStar (layer) {
  if (layer.regexp.fast_star !== undefined) {
    return layer.regexp.fast_star
  }

  return layer._datadog_matchers.some(matcher => matcher.path === '*')
}

function isFastSlash (layer) {
  if (layer.regexp.fast_slash !== undefined) {
    return layer.regexp.fast_slash
  }

  return layer._datadog_matchers.some(matcher => matcher.path === '/')
}

function flatten (arr) {
  return arr.reduce((acc, val) => Array.isArray(val) ? acc.concat(flatten(val)) : acc.concat(val), [])
}

function cachedPathToRegExp (pattern) {
  const maybeCached = regexpCache[pattern]
  if (maybeCached) {
    return maybeCached
  }
  const regexp = pathToRegExp(pattern)
  regexpCache[pattern] = regexp
  return regexp
}

module.exports = {
  name: 'router',
  versions: ['>=1'],
  patch (Router, tracer, config) {
    this.wrap(Router.prototype, 'handle', createWrapHandle(tracer, config))
    this.wrap(Router.prototype, 'use', wrapRouterMethod)
    this.wrap(Router.prototype, 'route', wrapRouterMethod)
  },
  unpatch (Router) {
    this.unwrap(Router.prototype, 'handle')
    this.unwrap(Router.prototype, 'use')
    this.unwrap(Router.prototype, 'route')
  }
}


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-sharedb/src/index.js":
false,

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-tedious/src/index.js":
/*!*************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-tedious/src/index.js ***!
  \*************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Tags = __webpack_require__(/*! ../../../ext/tags */ "../../node_modules/dd-trace/ext/tags.js")
const Kinds = __webpack_require__(/*! ../../../ext/kinds */ "../../node_modules/dd-trace/ext/kinds.js")
const analyticsSampler = __webpack_require__(/*! ../../dd-trace/src/analytics_sampler */ "../../node_modules/dd-trace/packages/dd-trace/src/analytics_sampler.js")
const tx = __webpack_require__(/*! ../../dd-trace/src/plugins/util/tx */ "../../node_modules/dd-trace/packages/dd-trace/src/plugins/util/tx.js")

const procnameRegex = /^sp_[a-z]+$/

function createWrapMakeRequest (tracer, config) {
  return function wrapMakeRequest (makeRequest) {
    return function makeRequestWithTrace (request) {
      const connectionConfig = this.config
      const scope = tracer.scope()
      const childOf = scope.active()
      const queryOrProcedure = getQueryOrProcedure(request)

      if (!queryOrProcedure) {
        return makeRequest.apply(this, arguments)
      }

      const span = tracer.startSpan('tedious.request', {
        childOf,
        tags: {
          [Tags.SPAN_KIND]: Kinds.CLIENT,
          'db.type': 'mssql',
          'span.type': 'sql',
          'component': 'tedious',
          'service.name': config.service || `${tracer._service}-mssql`,
          'resource.name': queryOrProcedure
        }
      })

      addConnectionTags(span, connectionConfig)
      addDatabaseTags(span, connectionConfig)
      addProcIdTags(span, request)

      analyticsSampler.sample(span, config.analytics)
      request.callback = tx.wrap(span, request.callback)

      return scope.bind(makeRequest, span).apply(this, arguments)
    }
  }
}

function createWrapGetRowStream (tracer) {
  return function wrapGetRowStream (getRowStream) {
    return function getRowStreamWithTrace () {
      const scope = tracer.scope()

      const rowToPacketTransform = getRowStream.apply(this, arguments)
      return scope.bind(rowToPacketTransform)
    }
  }
}

function getQueryOrProcedure (request) {
  if (!request.parameters) return

  const statement = request.parametersByName.statement || request.parametersByName.stmt

  if (!statement) {
    return request.sqlTextOrProcedure
  }

  return statement.value
}

function addConnectionTags (span, connectionConfig) {
  span.setTag('out.host', connectionConfig.server)
  span.setTag('out.port', connectionConfig.options.port)
}

function addDatabaseTags (span, connectionConfig) {
  span.setTag('db.user', connectionConfig.userName || connectionConfig.authentication.options.userName)
  span.setTag('db.name', connectionConfig.options.database)
  span.setTag('db.instance', connectionConfig.options.instanceName)
}

function addProcIdTags (span, request) {
  if (!procnameRegex.test(request.sqlTextOrProcedure)) return
  span.setTag('tds.proc.name', request.sqlTextOrProcedure)
}

module.exports = [
  {
    name: 'tedious',
    versions: [ '>=1.0.0' ],
    patch (tedious, tracer, config) {
      this.wrap(tedious.Connection.prototype, 'makeRequest', createWrapMakeRequest(tracer, config))

      if (tedious.BulkLoad && tedious.BulkLoad.prototype.getRowStream) {
        this.wrap(tedious.BulkLoad.prototype, 'getRowStream', createWrapGetRowStream(tracer))
      }

      tracer.scope().bind(tedious.Request.prototype)
      tracer.scope().bind(tedious.Connection.prototype)
    },
    unpatch (tedious, tracer) {
      this.unwrap(tedious.Connection.prototype, 'makeRequest')

      if (tedious.BulkLoad) {
        this.unwrap(tedious.BulkLoad.prototype, 'getRowStream')
      }

      tracer.scope().unbind(tedious.Request.prototype)
      tracer.scope().unbind(tedious.Connection.prototype)
    }
  }
]


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-when/src/index.js":
/*!**********************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-when/src/index.js ***!
  \**********************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const tx = __webpack_require__(/*! ../../dd-trace/src/plugins/util/promise */ "../../node_modules/dd-trace/packages/dd-trace/src/plugins/util/promise.js")

module.exports = [
  {
    name: 'when',
    file: 'lib/Promise.js',
    versions: ['>=3'],
    patch (Promise, tracer, config) {
      this.wrap(Promise.prototype, 'then', tx.createWrapThen(tracer, config))
    },
    unpatch (Promise) {
      this.unwrap(Promise.prototype, 'then')
    }
  }
]


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-plugin-winston/src/index.js":
/*!*************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/datadog-plugin-winston/src/index.js ***!
  \*************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const { LOG } = __webpack_require__(/*! ../../../ext/formats */ "../../node_modules/dd-trace/ext/formats.js")

function createWrapWrite (tracer, config) {
  return function wrapWrite (write) {
    return function writeWithTrace (chunk, encoding, callback) {
      const span = tracer.scope().active()

      tracer.inject(span, LOG, chunk)

      const result = write.apply(this, arguments)

      delete chunk.dd

      return result
    }
  }
}

function createWrapMethod (tracer, config) {
  return function wrapMethod (method) {
    return function methodWithTrace () {
      const result = method.apply(this, arguments)

      for (const name in this.transports) {
        const transport = this.transports[name]

        if (transport._dd_patched || typeof transport.log !== 'function') continue

        transport.log = createWrapLog(tracer, config)(transport.log)
        transport._dd_patched = true
      }

      return result
    }
  }
}

function createWrapLog (tracer, config) {
  return function wrapLog (log) {
    return function logWithTrace (level, msg, meta, callback) {
      const span = tracer.scope().active()

      meta = arguments[2] = meta || {}

      tracer.inject(span, LOG, meta)

      const result = log.apply(this, arguments)

      delete meta.dd

      return result
    }
  }
}

module.exports = [
  {
    name: 'winston',
    file: 'lib/winston/logger.js',
    versions: ['>=3'],
    patch (Logger, tracer, config) {
      if (!tracer._logInjection) return
      this.wrap(Logger.prototype, 'write', createWrapWrite(tracer, config))
    },
    unpatch (Logger) {
      this.unwrap(Logger.prototype, 'write')
    }
  },
  {
    name: 'winston',
    file: 'lib/winston/logger.js',
    versions: ['2'],
    patch (logger, tracer, config) {
      if (!tracer._logInjection) return
      this.wrap(logger.Logger.prototype, 'configure', createWrapMethod(tracer, config))
      this.wrap(logger.Logger.prototype, 'add', createWrapMethod(tracer, config))
    },
    unpatch (logger) {
      this.unwrap(logger.Logger.prototype, 'configure')
      this.unwrap(logger.Logger.prototype, 'add')
    }
  },
  {
    name: 'winston',
    file: 'lib/winston/logger.js',
    versions: ['1'],
    patch (logger, tracer, config) {
      if (!tracer._logInjection) return
      this.wrap(logger.Logger.prototype, 'add', createWrapMethod(tracer, config))
    },
    unpatch (logger) {
      this.unwrap(logger.Logger.prototype, 'add')
    }
  }
]


/***/ }),

/***/ "../../node_modules/dd-trace/packages/datadog-shimmer/index.js":
false,

/***/ "../../node_modules/dd-trace/packages/datadog-shimmer/src/shimmer.js":
false,

/***/ "../../node_modules/dd-trace/packages/dd-trace/index.js":
/*!*******************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/index.js ***!
  \*******************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const platform = __webpack_require__(/*! ./src/platform */ "../../node_modules/dd-trace/packages/dd-trace/src/platform/index.js")
const node = __webpack_require__(/*! ./src/platform/node */ "../../node_modules/dd-trace/packages/dd-trace/src/platform/node/index.js")

platform.use(node)

const TracerProxy = __webpack_require__(/*! ./src/proxy */ "../../node_modules/dd-trace/packages/dd-trace/src/proxy.js")

module.exports = new TracerProxy()
module.exports.default = module.exports
module.exports.tracer = module.exports


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/lib/version.js":
/*!*************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/lib/version.js ***!
  \*************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports) {

module.exports = '0.29.1'


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/analytics_sampler.js":
/*!***********************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/analytics_sampler.js ***!
  \***********************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const ANALYTICS = __webpack_require__(/*! ../../../ext/tags */ "../../node_modules/dd-trace/ext/tags.js").ANALYTICS

let enabled = false

module.exports = {
  enable () {
    enabled = true
  },

  disable () {
    enabled = false
  },

  sample (span, rate, inherit) {
    if (typeof rate === 'object') {
      this.sample(span, rate[span.context()._name], inherit)
    } else if (rate !== undefined) {
      span.setTag(ANALYTICS, rate)
    } else if (inherit && enabled) {
      span.setTag(ANALYTICS, 1)
    }
  }
}


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/appsec/addresses.js":
false,

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/appsec/callbacks/ddwaf.js":
false,

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/appsec/callbacks/index.js":
false,

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/appsec/gateway/als.js":
false,

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/appsec/gateway/channels.js":
false,

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/appsec/gateway/engine/engine.js":
false,

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/appsec/gateway/engine/index.js":
false,

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/appsec/gateway/engine/runner.js":
false,

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/appsec/index.js":
false,

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/appsec/reporter.js":
false,

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/appsec/rule_manager.js":
false,

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/ci-visibility/exporters/agentless/index.js":
false,

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/ci-visibility/exporters/agentless/writer.js":
false,

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/config.js":
/*!************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/config.js ***!
  \************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const URL = __webpack_require__(/*! url-parse */ "../../node_modules/url-parse/index.js")
const platform = __webpack_require__(/*! ./platform */ "../../node_modules/dd-trace/packages/dd-trace/src/platform/index.js")
const coalesce = __webpack_require__(/*! koalas */ "../../node_modules/koalas/index.js")
const scopes = __webpack_require__(/*! ../../../ext/scopes */ "../../node_modules/dd-trace/ext/scopes.js")
const tagger = __webpack_require__(/*! ./tagger */ "../../node_modules/dd-trace/packages/dd-trace/src/tagger.js")
const id = __webpack_require__(/*! ./id */ "../../node_modules/dd-trace/packages/dd-trace/src/id.js")
const { isTrue, isFalse } = __webpack_require__(/*! ./util */ "../../node_modules/dd-trace/packages/dd-trace/src/util.js")

const runtimeId = `${id().toString()}${id().toString()}`

class Config {
  constructor (options) {
    options = options || {}

    this.tags = {}

    tagger.add(this.tags, platform.env('DD_TAGS'))
    tagger.add(this.tags, platform.env('DD_TRACE_TAGS'))
    tagger.add(this.tags, platform.env('DD_TRACE_GLOBAL_TAGS'))
    tagger.add(this.tags, options.tags)

    const DD_TRACE_ANALYTICS_ENABLED = coalesce(
      options.analytics,
      platform.env('DD_TRACE_ANALYTICS_ENABLED'),
      platform.env('DD_TRACE_ANALYTICS'),
      false
    )
    // Temporary disabled
    const DD_PROFILING_ENABLED = coalesce(
      // options.profiling,
      // platform.env('DD_PROFILING_ENABLED'),
      platform.env('DD_EXPERIMENTAL_PROFILING_ENABLED'),
      false
    )
    const DD_PROFILING_EXPORTERS = coalesce(
      platform.env('DD_PROFILING_EXPORTERS'),
      'agent'
    )
    const DD_PROFILING_SOURCE_MAP = platform.env('DD_PROFILING_SOURCE_MAP')
    const DD_LOGS_INJECTION = coalesce(
      options.logInjection,
      platform.env('DD_LOGS_INJECTION'),
      false
    )
    const DD_RUNTIME_METRICS_ENABLED = coalesce(
      options.runtimeMetrics,
      platform.env('DD_RUNTIME_METRICS_ENABLED'),
      false
    )
    const DD_AGENT_HOST = coalesce(
      options.hostname,
      platform.env('DD_AGENT_HOST'),
      platform.env('DD_TRACE_AGENT_HOSTNAME'),
      '127.0.0.1'
    )
    const DD_TRACE_AGENT_PORT = coalesce(
      options.port,
      platform.env('DD_TRACE_AGENT_PORT'),
      '8126'
    )
    const DD_TRACE_AGENT_URL = coalesce(
      options.url,
      platform.env('DD_TRACE_AGENT_URL'),
      platform.env('DD_TRACE_URL'),
      null
    )
    const DD_SERVICE = options.service ||
      platform.env('DD_SERVICE') ||
      platform.env('DD_SERVICE_NAME') ||
      this.tags.service ||
      platform.service() ||
      'node'
    const DD_ENV = coalesce(
      options.env,
      platform.env('DD_ENV'),
      this.tags.env
    )
    const DD_VERSION = coalesce(
      options.version,
      platform.env('DD_VERSION'),
      this.tags.version,
      platform.appVersion()
    )
    const DD_TRACE_STARTUP_LOGS = coalesce(
      options.startupLogs,
      platform.env('DD_TRACE_STARTUP_LOGS'),
      true
    )
    const DD_TRACE_ENABLED = coalesce(
      options.enabled,
      platform.env('DD_TRACE_ENABLED'),
      true
    )
    const DD_TRACE_DEBUG = coalesce(
      options.debug,
      platform.env('DD_TRACE_DEBUG'),
      false
    )
    const DD_TRACE_AGENT_PROTOCOL_VERSION = coalesce(
      options.protocolVersion,
      platform.env('DD_TRACE_AGENT_PROTOCOL_VERSION'),
      '0.4'
    )

    const sampler = (options.experimental && options.experimental.sampler) || {}
    const ingestion = options.ingestion || {}
    const dogstatsd = coalesce(options.dogstatsd, {})

    Object.assign(sampler, {
      sampleRate: coalesce(ingestion.sampleRate, sampler.sampleRate, platform.env('DD_TRACE_SAMPLE_RATE')),
      rateLimit: coalesce(ingestion.rateLimit, sampler.rateLimit, platform.env('DD_TRACE_RATE_LIMIT'))
    })

    this.enabled = isTrue(DD_TRACE_ENABLED)
    this.debug = isTrue(DD_TRACE_DEBUG)
    this.logInjection = isTrue(DD_LOGS_INJECTION)
    this.env = DD_ENV
    this.url = DD_TRACE_AGENT_URL && new URL(DD_TRACE_AGENT_URL)
    this.site = coalesce(options.site, platform.env('DD_SITE'), 'datadoghq.com')
    this.hostname = DD_AGENT_HOST || (this.url && this.url.hostname)
    this.port = String(DD_TRACE_AGENT_PORT || (this.url && this.url.port))
    this.flushInterval = coalesce(parseInt(options.flushInterval, 10), 2000)
    this.sampleRate = coalesce(Math.min(Math.max(options.sampleRate, 0), 1), 1)
    this.logger = options.logger
    this.plugins = !!coalesce(options.plugins, true)
    this.service = DD_SERVICE
    this.version = DD_VERSION
    this.analytics = isTrue(DD_TRACE_ANALYTICS_ENABLED)
    this.dogstatsd = {
      hostname: coalesce(dogstatsd.hostname, platform.env(`DD_DOGSTATSD_HOSTNAME`), this.hostname),
      port: String(coalesce(dogstatsd.port, platform.env('DD_DOGSTATSD_PORT'), 8125))
    }
    this.runtimeMetrics = isTrue(DD_RUNTIME_METRICS_ENABLED)
    this.trackAsyncScope = options.trackAsyncScope !== false
    this.experimental = {
      b3: !(!options.experimental || !options.experimental.b3),
      runtimeId: !(!options.experimental || !options.experimental.runtimeId),
      exporter: options.experimental && options.experimental.exporter,
      peers: (options.experimental && options.experimental.distributedTracingOriginWhitelist) || [],
      enableGetRumData: (options.experimental && !!options.experimental.enableGetRumData),
      sampler,
      internalErrors: options.experimental && options.experimental.internalErrors
    }
    this.reportHostname = isTrue(coalesce(options.reportHostname, platform.env('DD_TRACE_REPORT_HOSTNAME'), false))
    this.scope = isFalse(platform.env('DD_CONTEXT_PROPAGATION'))
      ? scopes.NOOP
      : coalesce(options.scope, platform.env('DD_TRACE_SCOPE'))
    this.clientToken = coalesce(options.clientToken, platform.env('DD_CLIENT_TOKEN'))
    this.logLevel = coalesce(
      options.logLevel,
      platform.env('DD_TRACE_LOG_LEVEL'),
      'debug'
    )
    this.profiling = {
      enabled: isTrue(DD_PROFILING_ENABLED),
      sourceMap: !isFalse(DD_PROFILING_SOURCE_MAP),
      exporters: DD_PROFILING_EXPORTERS
    }
    this.lookup = options.lookup
    this.startupLogs = isTrue(DD_TRACE_STARTUP_LOGS)
    this.protocolVersion = DD_TRACE_AGENT_PROTOCOL_VERSION

    tagger.add(this.tags, { service: this.service, env: this.env, version: this.version })

    if (this.experimental.runtimeId) {
      tagger.add(this.tags, {
        'runtime-id': runtimeId
      })
    }
  }
}

module.exports = Config


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/constants.js":
/*!***************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/constants.js ***!
  \***************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = {
  SAMPLE_RATE_METRIC_KEY: '_sample_rate',
  SAMPLING_PRIORITY_KEY: '_sampling_priority_v1',
  ANALYTICS_KEY: '_dd1.sr.eausr',
  ORIGIN_KEY: '_dd.origin',
  HOSTNAME_KEY: '_dd.hostname',
  REFERENCE_NOOP: 'noop',
  SAMPLING_RULE_DECISION: '_dd.rule_psr',
  SAMPLING_LIMIT_DECISION: '_dd.limit_psr',
  SAMPLING_AGENT_DECISION: '_dd.agent_psr'
}


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/dogstatsd.js":
false,

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/encode/0.4.js":
/*!****************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/encode/0.4.js ***!
  \****************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const { encode } = __webpack_require__(/*! ./notepack */ "../../node_modules/dd-trace/packages/dd-trace/src/encode/notepack.js")
const log = __webpack_require__(/*! ../log */ "../../node_modules/dd-trace/packages/dd-trace/src/log.js")

const HARD_LIMIT = 8 * 1024 * 1024 // 8MB

class AgentEncoder {
  constructor (writer) {
    this._writer = writer
    this._reset()
  }

  count () {
    return this._traces.length
  }

  encode (trace) {
    const buffer = encode(trace)

    log.debug(() => `Adding encoded trace to buffer: ${buffer.toString('hex').match(/../g).join(' ')}`)

    if (buffer.length + this._size > HARD_LIMIT) {
      this._writer.flush()
    }

    this._size += buffer.length
    this._traces.push(buffer)
  }

  makePayload () {
    const prefix = Buffer.alloc(5)

    prefix[0] = 0xdd
    prefix.writeUInt32BE(this._traces.length, 1)

    const buffer = [prefix, ...this._traces]

    this._reset()

    return buffer
  }

  _reset () {
    this._traces = []
    this._size = 0
  }
}

module.exports = { AgentEncoder }


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/encode/0.5.js":
/*!****************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/encode/0.5.js ***!
  \****************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const notepack = __webpack_require__(/*! ./notepack */ "../../node_modules/dd-trace/packages/dd-trace/src/encode/notepack.js")
const log = __webpack_require__(/*! ../log */ "../../node_modules/dd-trace/packages/dd-trace/src/log.js")

const ARRAY_OF_TWO = 0x92
const ARRAY_OF_TWELVE = 0x9c
const SOFT_LIMIT = 8 * 1024 * 1024 // 8MB

const float64Array = new Float64Array(1)
const uInt8Float64Array = new Uint8Array(float64Array.buffer)

float64Array[0] = -1

const bigEndian = uInt8Float64Array[7] === 0

class AgentEncoder {
  constructor (writer) {
    this._writer = writer
    this._reset()
  }

  count () {
    return this._traces.length
  }

  encode (trace) {
    const bytes = []

    this._encode(bytes, trace)
    this._traces.push(bytes)
    this._traceSize += bytes.length

    log.debug(() => `Adding encoded trace to buffer: ${bytes.map(b => b.toString(16)).join(' ')}`)

    // we can go over the soft limit since the agent has a 50MB hard limit
    if (this._traceSize + this._stringSize > SOFT_LIMIT) {
      this._writer.flush()
    }
  }

  makePayload () {
    const prefixSize = 1
    const stringSize = this._stringSize + 5
    const traceSize = this._traceSize + 5
    const buffer = Buffer.allocUnsafe(prefixSize + stringSize + traceSize)

    let offset = 0

    buffer[offset++] = ARRAY_OF_TWO

    offset = this._writeStrings(buffer, offset)
    offset = this._writeTraces(buffer, offset)

    this._reset()

    return buffer
  }

  _encode (bytes, trace) {
    this._encodeArrayPrefix(bytes, trace)

    for (const span of trace) {
      this._encodeByte(bytes, ARRAY_OF_TWELVE)
      this._encodeString(bytes, span.service)
      this._encodeString(bytes, span.name)
      this._encodeString(bytes, span.resource)
      this._encodeId(bytes, span.trace_id)
      this._encodeId(bytes, span.span_id)
      this._encodeId(bytes, span.parent_id)
      this._encodeInteger(bytes, span.start || 0)
      this._encodeInteger(bytes, span.duration || 0)
      this._encodeInteger(bytes, span.error)
      this._encodeMap(bytes, span.meta || {})
      this._encodeMap(bytes, span.metrics || {})
      this._encodeString(bytes, span.type)
    }
  }

  _reset () {
    this._traces = []
    this._traceSize = 0
    this._stringDefers = [{ value: '', length: 0, prefix: [0xa0] }]
    this._stringMap = { '': 0 }
    this._stringSize = 1
  }

  _encodeArrayPrefix (bytes, value) {
    const length = value.length

    if (length < 0x10) { // fixarray
      bytes.push(length | 0x90)
    } else if (length < 0x10000) { // array 16
      bytes.push(0xdc, length >> 8, length)
    } else if (length < 0x100000000) { // array 32
      bytes.push(0xdd, length >> 24, length >> 16, length >> 8, length)
    } else {
      throw new Error('Array too large')
    }
  }

  _encodeByte (bytes, value) {
    bytes.push(value)
  }

  _encodeId (bytes, id) {
    id = id.toArray()
    bytes.push(0xcf, id[0], id[1], id[2], id[3], id[4], id[5], id[6], id[7])
  }

  _encodeInteger (bytes, value) {
    notepack._encode(bytes, [], value)
  }

  _encodeMap (bytes, value) {
    const keys = []
    const allKeys = Object.keys(value)

    let key = ''

    for (let i = 0, l = allKeys.length; i < l; i++) {
      key = allKeys[i]
      if (typeof value[key] !== 'function') {
        keys.push(key)
      }
    }

    const length = keys.length

    if (length < 0x10) { // fixmap
      bytes.push(length | 0x80)
    } else if (length < 0x10000) { // map 16
      bytes.push(0xde, length >> 8, length)
    } else if (length < 0x100000000) { // map 32
      bytes.push(0xdf, length >> 24, length >> 16, length >> 8, length)
    } else {
      throw new Error('Object too large')
    }

    for (let i = 0; i < length; i++) {
      key = keys[i]
      this._encodeString(bytes, key)
      this._encodeValue(bytes, value[key])
    }
  }

  _encodeValue (bytes, value) {
    switch (typeof value) {
      case 'string':
        this._encodeString(bytes, value)
        break
      case 'number':
        this._encodeFloat(bytes, value)
        break
      default:
        // should not happen
    }
  }

  _encodeString (bytes, value = '') {
    if (!(value in this._stringMap)) {
      const prefix = []
      const defers = []
      const size = notepack._encode(prefix, defers, value)
      const length = defers[0].length

      this._stringSize += size
      this._stringMap[value] = this._stringDefers.length
      this._stringDefers.push({ value, length, prefix })
    }

    this._encodeInteger(bytes, this._stringMap[value])
  }

  _encodeFloat (bytes, value) {
    float64Array[0] = value

    bytes.push(0xcb)

    if (bigEndian) {
      for (let i = 0; i <= 7; i++) {
        bytes.push(uInt8Float64Array[i])
      }
    } else {
      for (let i = 7; i >= 0; i--) {
        bytes.push(uInt8Float64Array[i])
      }
    }
  }

  _writeArrayPrefix (buffer, offset, count) {
    buffer[offset++] = 0xdd
    buffer.writeUInt32BE(count, offset)

    return offset + 4
  }

  _writeString (buffer, offset, defer) {
    for (let i = 0, l = defer.prefix.length; i < l; i++) {
      buffer[offset++] = defer.prefix[i]
    }

    if (defer.length > notepack.MICRO_OPT_LEN) {
      buffer.write(defer.value, offset, defer.length, 'utf8')
    } else {
      notepack.utf8Write(buffer, offset, defer.value)
    }

    return offset + defer.length
  }

  _writeStrings (buffer, offset) {
    offset = this._writeArrayPrefix(buffer, offset, this._stringDefers.length)

    for (const defer of this._stringDefers) {
      offset = this._writeString(buffer, offset, defer)
    }

    return offset
  }

  _writeTraces (buffer, offset) {
    offset = this._writeArrayPrefix(buffer, offset, this._traces.length)

    for (const trace of this._traces) {
      for (const byte of trace) {
        buffer[offset++] = byte
      }
    }

    return offset
  }
}

module.exports = { AgentEncoder }


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/encode/agentless-ci-visibility.js":
false,

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/encode/chunk.js":
false,

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/encode/notepack.js":
/*!*********************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/encode/notepack.js ***!
  \*********************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* eslint-disable */
// modified from https://github.com/darrachequesne/notepack/blob/master/lib/encode.js



const MICRO_OPT_LEN = 32;

// Faster for short strings than buffer.write
function utf8Write(arr, offset, str) {
  let c = 0;
  for (let i = 0, l = str.length; i < l; i++) {
    c = str.charCodeAt(i);
    if (c < 0x80) {
      arr[offset++] = c;
    } else if (c < 0x800) {
      arr[offset++] = 0xc0 | (c >> 6);
      arr[offset++] = 0x80 | (c & 0x3f);
    } else if (c < 0xd800 || c >= 0xe000) {
      arr[offset++] = 0xe0 | (c >> 12);
      arr[offset++] = 0x80 | (c >> 6) & 0x3f;
      arr[offset++] = 0x80 | (c & 0x3f);
    } else {
      i++;
      c = 0x10000 + (((c & 0x3ff) << 10) | (str.charCodeAt(i) & 0x3ff));
      arr[offset++] = 0xf0 | (c >> 18);
      arr[offset++] = 0x80 | (c >> 12) & 0x3f;
      arr[offset++] = 0x80 | (c >> 6) & 0x3f;
      arr[offset++] = 0x80 | (c & 0x3f);
    }
  }
}

// Faster for short strings than Buffer.byteLength
function utf8Length(str) {
  let c = 0, length = 0;
  for (let i = 0, l = str.length; i < l; i++) {
    c = str.charCodeAt(i);
    if (c < 0x80) {
      length += 1;
    } else if (c < 0x800) {
      length += 2;
    } else if (c < 0xd800 || c >= 0xe000) {
      length += 3;
    } else {
      i++;
      length += 4;
    }
  }
  return length;
}

const cache = new Map();
const cacheMaxSize = process.env.NOTEPACK_ENCODE_CACHE_MAX_SIZE || 1024;

/*jshint latedef: nofunc */
function encodeKey(bytes, defers, key) {
  if (cache.has(key)) {
    const buffer = cache.get(key);
    defers.push({ bin: buffer, length: buffer.length, offset: bytes.length });
    return buffer.length;
  }
  if (cache.size > cacheMaxSize) {
    return _encode(bytes, defers, key);
  }
  const keyBytes = [];
  const size = _encode(keyBytes, [], key);
  const keyBuffer = Buffer.allocUnsafe(size);
  for (let i = 0, l = keyBytes.length; i < l; i++) {
    keyBuffer[i] = keyBytes[i];
  }
  utf8Write(keyBuffer, keyBytes.length, key);
  defers.push({ bin: keyBuffer, length: size, offset: bytes.length });
  cache.set(key, keyBuffer);
  return size;
}

function _encode(bytes, defers, value) {
  let hi = 0, lo = 0, length = 0, size = 0;

  switch (typeof value) {
    case 'string':
      if (value.length > MICRO_OPT_LEN) {
        length = Buffer.byteLength(value);
      } else {
        length = utf8Length(value);
      }

      if (length < 0x20) { // fixstr
        bytes.push(length | 0xa0);
        size = 1;
      } else if (length < 0x100) { // str 8
        bytes.push(0xd9, length);
        size = 2;
      } else if (length < 0x10000) { // str 16
        bytes.push(0xda, length >> 8, length);
        size = 3;
      } else if (length < 0x100000000) { // str 32
        bytes.push(0xdb, length >> 24, length >> 16, length >> 8, length);
        size = 5;
      } else {
        throw new Error('String too long');
      }
      defers.push({ str: value, length: length, offset: bytes.length });
      return size + length;
    case 'number':
      // TODO: encode to float 32?

      if (Math.floor(value) !== value || !isFinite(value)) { // float 64
        bytes.push(0xcb);
        defers.push({ float: value, length: 8, offset: bytes.length });
        return 9;
      }

      if (value >= 0) {
        if (value < 0x80) { // positive fixnum
          bytes.push(value);
          return 1;
        }

        if (value < 0x100) { // uint 8
          bytes.push(0xcc, value);
          return 2;
        }

        if (value < 0x10000) { // uint 16
          bytes.push(0xcd, value >> 8, value);
          return 3;
        }

        if (value < 0x100000000) { // uint 32
          bytes.push(0xce, value >> 24, value >> 16, value >> 8, value);
          return 5;
        }
        // uint 64
        hi = (value / Math.pow(2, 32)) >> 0;
        lo = value >>> 0;
        bytes.push(0xcf, hi >> 24, hi >> 16, hi >> 8, hi, lo >> 24, lo >> 16, lo >> 8, lo);
        return 9;
      } else {

        if (value >= -0x20) { // negative fixnum
          bytes.push(value);
          return 1;
        }

        if (value >= -0x80) { // int 8
          bytes.push(0xd0, value);
          return 2;
        }

        if (value >= -0x8000) { // int 16
          bytes.push(0xd1, value >> 8, value);
          return 3;
        }

        if (value >= -0x80000000) { // int 32
          bytes.push(0xd2, value >> 24, value >> 16, value >> 8, value);
          return 5;
        }
        // int 64
        hi = Math.floor(value / Math.pow(2, 32));
        lo = value >>> 0;
        bytes.push(0xd3, hi >> 24, hi >> 16, hi >> 8, hi, lo >> 24, lo >> 16, lo >> 8, lo);
        return 9;
      }
      break;
    case 'object':
      // nil
      if (value === null) {
        bytes.push(0xc0);
        return 1;
      }

      // uint 64
      if (value._isUint64BE) {
        value = value.toArray();
        bytes.push(0xcf, value[0], value[1], value[2], value[3], value[4], value[5], value[6], value[7]);
        return 9;
      }

      if (Array.isArray(value)) {
        length = value.length;

        if (length < 0x10) { // fixarray
          bytes.push(length | 0x90);
          size = 1;
        } else if (length < 0x10000) { // array 16
          bytes.push(0xdc, length >> 8, length);
          size = 3;
        } else if (length < 0x100000000) { // array 32
          bytes.push(0xdd, length >> 24, length >> 16, length >> 8, length);
          size = 5;
        } else {
          throw new Error('Array too large');
        }
        for (let i = 0; i < length; i++) {
          size += _encode(bytes, defers, value[i]);
        }
        return size;
      }

      if (value instanceof Date) { // fixext 8 / Date
        const time = value.getTime();
        hi = Math.floor(time / Math.pow(2, 32));
        lo = time >>> 0;
        bytes.push(0xd7, 0, hi >> 24, hi >> 16, hi >> 8, hi, lo >> 24, lo >> 16, lo >> 8, lo);
        return 10;
      }

      if (value instanceof Buffer) {
        length = value.length;

        if (length < 0x100) { // bin 8
          bytes.push(0xc4, length);
          size = 2;
        } else if (length < 0x10000) { // bin 16
          bytes.push(0xc5, length >> 8, length);
          size = 3;
        } else if (length < 0x100000000) { // bin 32
          bytes.push(0xc6, length >> 24, length >> 16, length >> 8, length);
          size = 5;
        } else {
          throw new Error('Buffer too large');
        }
        defers.push({ bin: value, length: length, offset: bytes.length });
        return size + length;
      }

      if (value instanceof ArrayBuffer || ArrayBuffer.isView(value)) {
        const arraybuffer = value.buffer || value;
        length = arraybuffer.byteLength;

        // ext 8
        if (length < 0x100) {
          bytes.push(0xc7, length, 0);
          size = 3;
        } else if (length < 0x10000) { // ext 16
          bytes.push(0xc8, length >> 8, length, 0);
          size = 4;
        } else if (length < 0x100000000) { // ext 32
          bytes.push(0xc9, length >> 24, length >> 16, length >> 8, length, 0);
          size = 6;
        } else {
          throw new Error('ArrayBuffer too large');
        }
        defers.push({ arraybuffer: arraybuffer, length: length, offset: bytes.length });
        return size + length;
      }

      if (typeof value.toJSON === 'function') {
        return _encode(bytes, defers, value.toJSON());
      }

      const keys = [], allKeys = Object.keys(value);
      let key = '';

      for (let i = 0, l = allKeys.length; i < l; i++) {
        key = allKeys[i];
        if (typeof value[key] !== 'function') {
          keys.push(key);
        }
      }
      length = keys.length;

      if (length < 0x10) { // fixmap
        bytes.push(length | 0x80);
        size = 1;
      } else if (length < 0x10000) { // map 16
        bytes.push(0xde, length >> 8, length);
        size = 3;
      } else if (length < 0x100000000) { // map 32
        bytes.push(0xdf, length >> 24, length >> 16, length >> 8, length);
        size = 5;
      } else {
        throw new Error('Object too large');
      }

      for (let i = 0; i < length; i++) {
        key = keys[i];
        size += encodeKey(bytes, defers, key);
        size += _encode(bytes, defers, value[key]);
      }
      return size;
    case 'boolean': // false/true
      bytes.push(value ? 0xc3 : 0xc2);
      return 1;
    case 'undefined': // fixext 1 / undefined
      bytes.push(0xd4, 0, 0);
      return 3;
    default:
      throw new Error('Could not encode');
  }
}

function encode(value) {
  const bytes = [], defers = [], size = _encode(bytes, defers, value);
  const buf = Buffer.allocUnsafe(size);

  let deferIndex = 0, deferWritten = 0, nextOffset = -1;
  if (defers.length > 0) {
    nextOffset = defers[0].offset;
  }

  let defer, deferLength = 0, offset = 0;
  for (let i = 0, l = bytes.length; i < l; i++) {
    buf[deferWritten + i] = bytes[i];
    while (i + 1 === nextOffset) {
      defer = defers[deferIndex];
      deferLength = defer.length;
      offset = deferWritten + nextOffset;
      if (defer.bin) {
        if (deferLength > MICRO_OPT_LEN) {
          defer.bin.copy(buf, offset, 0, deferLength);
        } else {
          const bin = defer.bin;
          for (let j = 0; j < deferLength; j++) {
            buf[offset + j] = bin[j];
          }
        }
      } else if (defer.str) {
        if (deferLength > MICRO_OPT_LEN) {
          buf.write(defer.str, offset, deferLength, 'utf8');
        } else {
          utf8Write(buf, offset, defer.str);
        }
      } else if (defer.float !== undefined) {
        buf.writeDoubleBE(defer.float, offset);
      } else if (defer.arraybuffer) {
        const arr = new Uint8Array(defer.arraybuffer);
        for (let k = 0; k < deferLength; k++) {
          buf[offset + k] = arr[k];
        }
      }
      deferIndex++;
      deferWritten += deferLength;
      if (defers[deferIndex]) {
        nextOffset = defers[deferIndex].offset;
      } else {
        break;
      }
    }
  }
  return buf;
}

module.exports = { encode, _encode, utf8Length, utf8Write, MICRO_OPT_LEN };


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/encode/tags-processors.js":
false,

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/exporter.js":
false,

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/exporters/agent/index.js":
/*!***************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/exporters/agent/index.js ***!
  \***************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const URL = __webpack_require__(/*! url-parse */ "../../node_modules/url-parse/index.js")
const log = __webpack_require__(/*! ../../log */ "../../node_modules/dd-trace/packages/dd-trace/src/log.js")
const Writer = __webpack_require__(/*! ./writer */ "../../node_modules/dd-trace/packages/dd-trace/src/exporters/agent/writer.js")
const Scheduler = __webpack_require__(/*! ./scheduler */ "../../node_modules/dd-trace/packages/dd-trace/src/exporters/agent/scheduler.js")

class AgentExporter {
  constructor ({ url, hostname, port, flushInterval, lookup, protocolVersion }, prioritySampler) {
    this._url = url || new URL(`http://${hostname || 'localhost'}:${port}`)
    this._writer = new Writer({ url: this._url, prioritySampler, lookup, protocolVersion })

    if (flushInterval > 0) {
      this._scheduler = new Scheduler(() => this._writer.flush(), flushInterval)
    }
    this._scheduler && this._scheduler.start()
  }

  setUrl (url) {
    try {
      url = new URL(url)
      this._url = url
      this._writer.setUrl(url)
    } catch (e) {
      log.warn(e.stack)
    }
  }

  export (spans) {
    this._writer.append(spans)

    if (!this._scheduler) {
      this._writer.flush()
    }
  }
}

module.exports = AgentExporter


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/exporters/agent/scheduler.js":
/*!*******************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/exporters/agent/scheduler.js ***!
  \*******************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const platform = __webpack_require__(/*! ../../platform */ "../../node_modules/dd-trace/packages/dd-trace/src/platform/index.js")

class Scheduler {
  constructor (callback, interval) {
    this._timer = null
    this._callback = callback
    this._interval = interval
  }

  start () {
    this._timer = setInterval(this._callback, this._interval)
    this._timer.unref && this._timer.unref()

    platform.on('exit', this._callback)
  }

  stop () {
    clearInterval(this._timer)

    platform.off('exit', this._callback)
  }

  reset () {
    this.stop()
    this.start()
  }
}

module.exports = Scheduler


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/exporters/agent/writer.js":
/*!****************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/exporters/agent/writer.js ***!
  \****************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const platform = __webpack_require__(/*! ../../platform */ "../../node_modules/dd-trace/packages/dd-trace/src/platform/index.js")
const log = __webpack_require__(/*! ../../log */ "../../node_modules/dd-trace/packages/dd-trace/src/log.js")
const tracerVersion = __webpack_require__(/*! ../../../lib/version */ "../../node_modules/dd-trace/packages/dd-trace/lib/version.js")

const METRIC_PREFIX = 'datadog.tracer.node.exporter.agent'

class Writer {
  constructor ({ url, prioritySampler, lookup, protocolVersion }) {
    const AgentEncoder = getEncoder(protocolVersion)

    this._url = url
    this._prioritySampler = prioritySampler
    this._lookup = lookup
    this._protocolVersion = protocolVersion
    this._encoderForVersion = new AgentEncoder(this)
  }

  append (spans) {
    log.debug(() => `Encoding trace: ${JSON.stringify(spans)}`)

    this._encode(spans)
  }

  _sendPayload (data, count, done) {
    platform.metrics().increment(`${METRIC_PREFIX}.requests`, true)

    makeRequest(this._protocolVersion, data, count, this._url, this._lookup, true, (err, res, status) => {
      if (status) {
        platform.metrics().increment(`${METRIC_PREFIX}.responses`, true)
        platform.metrics().increment(`${METRIC_PREFIX}.responses.by.status`, `status:${status}`, true)
      } else if (err) {
        platform.metrics().increment(`${METRIC_PREFIX}.errors`, true)
        platform.metrics().increment(`${METRIC_PREFIX}.errors.by.name`, `name:${err.name}`, true)

        if (err.code) {
          platform.metrics().increment(`${METRIC_PREFIX}.errors.by.code`, `code:${err.code}`, true)
        }
      }

      platform.startupLog.startupLog({ agentError: err })

      if (err) {
        log.error(err)
        done()
        return
      }

      log.debug(`Response from the agent: ${res}`)

      try {
        this._prioritySampler.update(JSON.parse(res).rate_by_service)
      } catch (e) {
        log.error(e)

        platform.metrics().increment(`${METRIC_PREFIX}.errors`, true)
        platform.metrics().increment(`${METRIC_PREFIX}.errors.by.name`, `name:${e.name}`, true)
      }
      done()
    })
  }

  setUrl (url) {
    this._url = url
  }

  _encode (trace) {
    this._encoderForVersion.encode(trace)
  }

  flush (done = () => {}) {
    const count = this._encoderForVersion.count()

    if (count > 0) {
      const payload = this._encoderForVersion.makePayload()

      this._sendPayload(payload, count, done)
    } else {
      done()
    }
  }
}

function setHeader (headers, key, value) {
  if (value) {
    headers[key] = value
  }
}

function getEncoder (protocolVersion) {
  if (protocolVersion === '0.5') {
    return __webpack_require__(/*! ../../encode/0.5 */ "../../node_modules/dd-trace/packages/dd-trace/src/encode/0.5.js").AgentEncoder
  } else {
    return __webpack_require__(/*! ../../encode/0.4 */ "../../node_modules/dd-trace/packages/dd-trace/src/encode/0.4.js").AgentEncoder
  }
}

function makeRequest (version, data, count, url, lookup, needsStartupLog, cb) {
  const options = {
    path: `/v${version}/traces`,
    method: 'PUT',
    headers: {
      'Content-Type': 'application/msgpack',
      'Datadog-Meta-Tracer-Version': tracerVersion,
      'X-Datadog-Trace-Count': String(count)
    },
    lookup
  }

  setHeader(options.headers, 'Datadog-Meta-Lang', platform.name())
  setHeader(options.headers, 'Datadog-Meta-Lang-Version', platform.version())
  setHeader(options.headers, 'Datadog-Meta-Lang-Interpreter', platform.engine())

  if (url.protocol === 'unix:') {
    options.socketPath = url.pathname
  } else {
    options.protocol = url.protocol
    options.hostname = url.hostname
    options.port = url.port
  }

  log.debug(() => `Request to the agent: ${JSON.stringify(options)}`)

  platform.request(Object.assign({ data }, options), (err, res, status) => {
    if (needsStartupLog) {
      // Note that logging will only happen once, regardless of how many times this is called.
      platform.startupLog.startupLog({
        agentError: status !== 404 && status !== 200 ? err : undefined
      })
    }
    cb(err, res, status)
  })
}

module.exports = Writer


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/exporters/common/docker.js":
false,

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/exporters/common/request.js":
false,

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/exporters/common/writer.js":
false,

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/exporters/scheduler.js":
false,

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/format.js":
/*!************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/format.js ***!
  \************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const constants = __webpack_require__(/*! ./constants */ "../../node_modules/dd-trace/packages/dd-trace/src/constants.js")
const tags = __webpack_require__(/*! ../../../ext/tags */ "../../node_modules/dd-trace/ext/tags.js")
const log = __webpack_require__(/*! ./log */ "../../node_modules/dd-trace/packages/dd-trace/src/log.js")
const id = __webpack_require__(/*! ./id */ "../../node_modules/dd-trace/packages/dd-trace/src/id.js")

const SAMPLING_PRIORITY_KEY = constants.SAMPLING_PRIORITY_KEY
const ANALYTICS_KEY = constants.ANALYTICS_KEY
const ANALYTICS = tags.ANALYTICS
const MEASURED = tags.MEASURED
const ORIGIN_KEY = constants.ORIGIN_KEY
const HOSTNAME_KEY = constants.HOSTNAME_KEY

const map = {
  'service.name': 'service',
  'span.type': 'type',
  'resource.name': 'resource'
}

function format (span) {
  const formatted = formatSpan(span)

  extractError(formatted, span)
  extractTags(formatted, span)
  extractAnalytics(formatted, span)

  return formatted
}

function formatSpan (span) {
  const spanContext = span.context()

  return {
    trace_id: spanContext._traceId,
    span_id: spanContext._spanId,
    parent_id: spanContext._parentId || id('0'),
    name: serialize(spanContext._name),
    resource: serialize(spanContext._name),
    error: 0,
    meta: {},
    metrics: {},
    start: Math.round(span._startTime * 1e6),
    duration: Math.round(span._duration * 1e6)
  }
}

function extractTags (trace, span) {
  const context = span.context()
  const origin = context._trace.origin
  const tags = context._tags
  const hostname = context._hostname
  const priority = context._sampling.priority
  const internalErrors = span.tracer()._internalErrors

  for (const tag in tags) {
    switch (tag) {
      case 'service.name':
      case 'span.type':
      case 'resource.name':
        addTag(trace, {}, map[tag], tags[tag])
        break
      // HACK: remove when Datadog supports numeric status code
      case 'http.status_code':
        addTag(trace.meta, {}, tag, tags[tag] && String(tags[tag]))
        break
      case HOSTNAME_KEY:
      case ANALYTICS:
        break
      case MEASURED:
        addTag({}, trace.metrics, tag, tags[tag] === undefined || tags[tag] ? 1 : 0)
        break
      case 'error':
        if (tags[tag] && (tags['span.kind'] !== 'internal' || internalErrors)) {
          trace.error = 1
        }
        break
      case 'error.type':
      case 'error.msg':
      case 'error.stack':
        // HACK: remove when implemented in the backend
        if (tags['span.kind'] !== 'internal' || internalErrors) {
          trace.error = 1
        }
      default: // eslint-disable-line no-fallthrough
        addTag(trace.meta, trace.metrics, tag, tags[tag])
    }
  }

  if (span.tracer()._service === tags['service.name']) {
    addTag(trace.meta, trace.metrics, 'language', 'javascript')
  }

  addTag(trace.meta, trace.metrics, SAMPLING_PRIORITY_KEY, priority)
  addTag(trace.meta, trace.metrics, ORIGIN_KEY, origin)
  addTag(trace.meta, trace.metrics, HOSTNAME_KEY, hostname)
}

function extractError (trace, span) {
  const error = span.context()._tags['error']

  if (error instanceof Error) {
    trace.meta['error.msg'] = error.message
    trace.meta['error.type'] = error.name
    trace.meta['error.stack'] = error.stack
  }
}

function extractAnalytics (trace, span) {
  let analytics = span.context()._tags[ANALYTICS]

  if (analytics === true) {
    analytics = 1
  } else {
    analytics = parseFloat(analytics)
  }

  if (!isNaN(analytics)) {
    trace.metrics[ANALYTICS_KEY] = Math.max(Math.min(analytics, 1), 0)
  }
}

function addTag (meta, metrics, key, value, seen) {
  switch (typeof value) {
    case 'string':
      meta[key] = value
      break
    case 'number':
      if (isNaN(value)) break
      metrics[key] = value
      break
    case 'undefined':
      break
    case 'object':
      if (value === null) break

      // Special case for Node.js Buffer and URL
      if (isNodeBuffer(value) || isUrl(value)) {
        metrics[key] = value.toString()
        break
      }

      if (!Array.isArray(value)) {
        addObjectTag(meta, metrics, key, value, seen)
        break
      }

    default: // eslint-disable-line no-fallthrough
      addTag(meta, metrics, key, serialize(value))
  }
}

function addObjectTag (meta, metrics, key, value, seen) {
  seen = seen || []

  if (~seen.indexOf(value)) {
    meta[key] = '[Circular]'
    return
  }

  seen.push(value)

  for (const prop in value) {
    addTag(meta, metrics, `${key}.${prop}`, value[prop], seen)
  }

  seen.pop()
}

function serialize (obj) {
  try {
    return obj && typeof obj.toString !== 'function' ? JSON.stringify(obj) : String(obj)
  } catch (e) {
    log.error(e)
  }
}

function isNodeBuffer (obj) {
  return obj.constructor && obj.constructor.name === 'Buffer' &&
    typeof obj.readInt8 === 'function' &&
    typeof obj.toString === 'function'
}

function isUrl (obj) {
  return obj.constructor && obj.constructor.name === 'URL' &&
    typeof obj.href === 'string' &&
    typeof obj.toString === 'function'
}

module.exports = format


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/histogram.js":
/*!***************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/histogram.js ***!
  \***************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const hdr = __webpack_require__(/*! hdr-histogram-js */ "../../node_modules/hdr-histogram-js/index.js")

const highestTrackableValue = 3.6e12 // 1 hour

class Histogram {
  constructor () {
    this._histogram = hdr.build({
      highestTrackableValue
    })

    this.reset()
  }

  get min () { return this._min }
  get max () { return this._max }
  get avg () { return this._count === 0 ? 0 : this._sum / this._count }
  get sum () { return this._sum }
  get count () { return this._count }
  get median () { return this.percentile(50) }
  get p95 () { return this.percentile(95) }

  percentile (percentile) {
    return this._histogram.getValueAtPercentile(percentile)
  }

  record (value) {
    if (this._count === 0) {
      this._min = this._max = value
    } else {
      this._min = Math.min(this._min, value)
      this._max = Math.max(this._max, value)
    }

    this._count++
    this._sum += value

    this._histogram.recordValue(value)
  }

  reset () {
    this._min = 0
    this._max = 0
    this._sum = 0
    this._count = 0

    this._histogram.reset()
  }
}

module.exports = Histogram


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/id.js":
/*!********************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/id.js ***!
  \********************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const platform = __webpack_require__(/*! ./platform */ "../../node_modules/dd-trace/packages/dd-trace/src/platform/index.js")

const UINT_MAX = 4294967296

const zeroId = new Uint8Array(8)

// Cryptographically secure local seeds to mitigate Math.random() seed reuse.
const seed = new Uint32Array(2)

if (platform.crypto) {
  platform.crypto.getRandomValues(seed)
}

const map = Array.prototype.map
const pad = byte => `${byte < 16 ? '0' : ''}${byte.toString(16)}`

// Internal representation of a trace or span ID.
class Identifier {
  constructor (value, radix) {
    this._isUint64BE = true // msgpack-lite compatibility
    this._buffer = typeof radix === 'number'
      ? fromString(value, radix)
      : createBuffer(value)
  }

  toString (radix) {
    return typeof radix === 'number'
      ? toNumberString(this._buffer, radix)
      : toHexString(this._buffer)
  }

  toBuffer () {
    return this._buffer
  }

  // msgpack-lite compatibility
  toArray () {
    if (this._buffer.length === 8) {
      return this._buffer
    }
    return this._buffer.subarray(-8)
  }

  toJSON () {
    return this.toString()
  }
}

// Create a buffer, using an optional hexadecimal value if provided.
function createBuffer (value) {
  if (value === '0') return zeroId
  if (!value) return pseudoRandom()

  const size = Math.ceil(value.length / 2)
  const buffer = new Uint8Array(size)

  for (let i = 0; i < size; i++) {
    buffer[i] = parseInt(value.substring(i * 2, i * 2 + 2), 16)
  }

  return buffer
}

// Convert a numerical string to a buffer using the specified radix.
function fromString (str, raddix) {
  const buffer = new Uint8Array(8)
  const len = str.length

  let pos = 0
  let high = 0
  let low = 0

  if (str[0] === '-') pos++

  const sign = pos

  while (pos < len) {
    const chr = parseInt(str[pos++], raddix)

    if (!(chr >= 0)) break // NaN

    low = low * raddix + chr
    high = high * raddix + Math.floor(low / UINT_MAX)
    low %= UINT_MAX
  }

  if (sign) {
    high = ~high

    if (low) {
      low = UINT_MAX - low
    } else {
      high++
    }
  }

  writeUInt32BE(buffer, high, 0)
  writeUInt32BE(buffer, low, 4)

  return buffer
}

// Convert a buffer to a numerical string.
function toNumberString (buffer, radix) {
  let high = readInt32(buffer, 0)
  let low = readInt32(buffer, 4)
  let str = ''

  radix = radix || 10

  while (1) {
    const mod = (high % radix) * UINT_MAX + low

    high = Math.floor(high / radix)
    low = Math.floor(mod / radix)
    str = (mod % radix).toString(radix) + str

    if (!high && !low) break
  }

  return str
}

// Convert a buffer to a hexadecimal string.
function toHexString (buffer) {
  return map.call(buffer, pad).join('')
}

// Simple pseudo-random 64-bit ID generator.
function pseudoRandom () {
  const buffer = new Uint8Array(8)

  const hi = randomUInt32(seed[0]) & 0x7FFFFFFF // only positive int64
  const lo = randomUInt32(seed[1])

  writeUInt32BE(buffer, hi, 0)
  writeUInt32BE(buffer, lo, 4)

  return buffer
}

// Generate a random unsigned 32-bit integer.
function randomUInt32 (seed) {
  return seed ^ Math.floor(Math.random() * (0xFFFFFFFF + 1))
}

// Read a buffer to unsigned integer bytes.
function readInt32 (buffer, offset) {
  return (buffer[offset + 0] * 16777216) +
    (buffer[offset + 1] << 16) +
    (buffer[offset + 2] << 8) +
    buffer[offset + 3]
}

// Write unsigned integer bytes to a buffer.
function writeUInt32BE (buffer, value, offset) {
  buffer[3 + offset] = value & 255
  value = value >> 8
  buffer[2 + offset] = value & 255
  value = value >> 8
  buffer[1 + offset] = value & 255
  value = value >> 8
  buffer[0 + offset] = value & 255
}

module.exports = (value, radix) => new Identifier(value, radix)


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/iitm.js":
false,

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/instrumenter.js":
/*!******************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/instrumenter.js ***!
  \******************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const shimmer = __webpack_require__(/*! shimmer */ "../../node_modules/shimmer/index.js")
const log = __webpack_require__(/*! ./log */ "../../node_modules/dd-trace/packages/dd-trace/src/log.js")
const platform = __webpack_require__(/*! ./platform */ "../../node_modules/dd-trace/packages/dd-trace/src/platform/index.js")
const { isTrue, isFalse } = __webpack_require__(/*! ./util */ "../../node_modules/dd-trace/packages/dd-trace/src/util.js")

shimmer({ logger: () => {} })

const plugins = platform.plugins

const disabldPlugins = platform.env('DD_TRACE_DISABLED_PLUGINS')

const collectDisabledPlugins = () => {
  return new Set(disabldPlugins && disabldPlugins.split(',').map(plugin => plugin.trim()))
}

function cleanEnv (name) {
  return platform.env(`DD_TRACE_${name.toUpperCase()}`.replace(/[^a-z0-9_]/ig, '_'))
}

function getConfig (name, config = {}) {
  if (!name) {
    return config
  }

  const enabled = cleanEnv(`${name}_ENABLED`)
  if (enabled !== undefined) {
    config.enabled = isTrue(enabled)
  }

  const analyticsEnabled = cleanEnv(`${name}_ANALYTICS_ENABLED`)
  const analyticsSampleRate = Math.min(Math.max(cleanEnv(`${name}_ANALYTICS_SAMPLE_RATE`), 0), 1)

  if (isFalse(analyticsEnabled)) {
    config.analytics = false
  } else if (!Number.isNaN(analyticsSampleRate)) {
    config.analytics = analyticsSampleRate
  } else if (isTrue(analyticsEnabled)) {
    config.analytics = true
  }

  return config
}

class Instrumenter {
  constructor (tracer) {
    this._tracer = tracer
    this._loader = new platform.Loader(this)
    this._enabled = false
    this._names = new Set()
    this._plugins = new Map()
    this._instrumented = new Map()
    this._disabledPlugins = collectDisabledPlugins()
  }

  use (name, config) {
    if (typeof config === 'boolean') {
      config = { enabled: config }
    }

    config = getConfig(name, config)

    try {
      this._set(plugins[name.toLowerCase()], { name, config })
    } catch (e) {
      log.debug(`Could not find a plugin named "${name}".`)
    }

    if (this._enabled) {
      this._loader.reload(this._plugins)
    }
  }

  enable (config) {
    config = config || {}

    this._enabled = true

    if (config.plugins !== false) {
      Object.keys(plugins)
        .filter(name => !this._plugins.has(plugins[name]))
        .forEach(name => {
          this._set(plugins[name], { name, config: getConfig(name) })
        })
    }

    this._loader.reload(this._plugins)
  }

  disable () {
    for (const instrumentation of this._instrumented.keys()) {
      this.unpatch(instrumentation)
    }

    this._plugins.clear()
    this._enabled = false
    this._loader.reload(this._plugins)
  }

  wrap (nodules, names, wrapper) {
    nodules = [].concat(nodules)
    names = [].concat(names)

    nodules.forEach(nodule => {
      names.forEach(name => {
        if (typeof nodule[name] !== 'function') {
          throw new Error(`Expected object ${nodule} to contain method ${name}.`)
        }

        Object.defineProperty(nodule[name], '_datadog_patched', {
          value: true,
          configurable: true
        })
      })
    })

    shimmer.massWrap.call(this, nodules, names, function (original, name) {
      const wrapped = wrapper(original, name)
      const props = Object.getOwnPropertyDescriptors(original)
      const keys = Reflect.ownKeys(props)

      // https://github.com/othiym23/shimmer/issues/19
      for (const key of keys) {
        if (typeof key !== 'symbol' || wrapped.hasOwnProperty(key)) continue

        Object.defineProperty(wrapped, key, props[key])
      }

      return wrapped
    })
  }

  unwrap (nodules, names, wrapper) {
    nodules = [].concat(nodules)
    names = [].concat(names)

    shimmer.massUnwrap.call(this, nodules, names, wrapper)

    nodules.forEach(nodule => {
      names.forEach(name => {
        nodule[name] && delete nodule[name]._datadog_patched
      })
    })
  }

  wrapExport (moduleExports, wrapper) {
    if (typeof moduleExports !== 'function') return moduleExports

    const props = Object.keys(moduleExports)
    const shim = function () {
      return moduleExports._datadog_wrapper.apply(this, arguments)
    }

    for (const prop of props) {
      shim[prop] = moduleExports[prop]
    }

    moduleExports._datadog_wrapper = wrapper

    return shim
  }

  unwrapExport (moduleExports) {
    if (moduleExports && moduleExports._datadog_wrapper) {
      moduleExports._datadog_wrapper = moduleExports
    }

    return moduleExports
  }

  load (plugin, meta) {
    if (!this._enabled) return

    const instrumentations = [].concat(plugin)
    const enabled = meta.config.enabled !== false

    platform.metrics().boolean(`datadog.tracer.node.plugin.enabled.by.name`, enabled, `name:${meta.name}`)

    try {
      instrumentations
        .forEach(instrumentation => {
          this._loader.load(instrumentation, meta.config)
        })
    } catch (e) {
      log.error(e)
      this.unload(plugin)
      log.debug(`Error while trying to patch ${meta.name}. The plugin has been disabled.`)

      platform.metrics().increment(`datadog.tracer.node.plugin.errors`, true)
    }
  }

  unload (plugin) {
    [].concat(plugin)
      .forEach(instrumentation => {
        this.unpatch(instrumentation)
        this._instrumented.delete(instrumentation)
      })

    const meta = this._plugins.get(plugin)

    if (meta) {
      this._plugins.delete(plugin)

      platform.metrics().boolean(`datadog.tracer.node.plugin.enabled.by.name`, false, `name:${meta.name}`)
    }
  }

  patch (instrumentation, moduleExports, config) {
    let instrumented = this._instrumented.get(instrumentation)

    if (!instrumented) {
      this._instrumented.set(instrumentation, instrumented = new Set())
    }

    if (!instrumented.has(moduleExports)) {
      instrumented.add(moduleExports)
      return instrumentation.patch.call(this, moduleExports, this._tracer._tracer, config)
    }
  }

  unpatch (instrumentation) {
    const instrumented = this._instrumented.get(instrumentation)

    if (instrumented) {
      instrumented.forEach(moduleExports => {
        try {
          instrumentation.unpatch.call(this, moduleExports, this._tracer)
        } catch (e) {
          log.error(e)
        }
      })
    }
  }

  _set (plugin, meta) {
    if (this._disabledPlugins.has(meta.name)) {
      log.debug(`Plugin "${meta.name}" was disabled via configuration option.`)
    } else {
      this._plugins.set(plugin, meta)
      this.load(plugin, meta)
    }
  }
}

module.exports = Instrumenter


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/loader.js":
false,

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/log.js":
/*!*********************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/log.js ***!
  \*********************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const NoopSpan = __webpack_require__(/*! ./noop/span */ "../../node_modules/dd-trace/packages/dd-trace/src/noop/span.js")

const _default = {
  debug: msg => console.debug(msg), /* eslint-disable-line no-console */
  info: msg => console.info(msg), /* eslint-disable-line no-console */
  warn: msg => console.warn(msg), /* eslint-disable-line no-console */
  error: msg => console.error(msg) /* eslint-disable-line no-console */
}

// based on: https://github.com/trentm/node-bunyan#levels
const _logLevels = {
  'debug': 20,
  'info': 30,
  'warn': 40,
  'error': 50
}

const _defaultLogLevel = 'debug'

const _checkLogLevel = (logLevel) => {
  if (logLevel && typeof logLevel === 'string') {
    return _logLevels[logLevel.toLowerCase().trim()] || _logLevels[_defaultLogLevel]
  }

  return _logLevels[_defaultLogLevel]
}

const memoize = func => {
  const cache = {}
  const memoized = function (key) {
    if (!cache[key]) {
      cache[key] = func.apply(this, arguments)
    }

    return cache[key]
  }

  return memoized
}

function processMsg (msg) {
  return typeof msg === 'function' ? msg() : msg
}

function withNoop (fn) {
  if (!log._tracer) {
    fn()
  } else {
    log._tracer.scope().activate(log._noopSpan(), fn)
  }
}

const log = {
  _isLogLevelEnabled (level) {
    return _logLevels[level] >= this._logLevel
  },

  use (logger) {
    if (logger && logger.debug instanceof Function && logger.error instanceof Function) {
      this._logger = logger
    }

    return this
  },

  toggle (enabled, logLevel, tracer) {
    this._enabled = enabled
    this._logLevel = _checkLogLevel(logLevel)
    this._tracer = tracer

    return this
  },

  _noopSpan () {
    if (!this.__noopSpan) {
      this.__noopSpan = new NoopSpan(this._tracer)
    }
    return this.__noopSpan
  },

  reset () {
    this._logger = _default
    this._enabled = false
    delete this._tracer
    delete this.__noopSpan
    this._deprecate = memoize((code, message) => {
      withNoop(() => this._logger.error(message))
      return this
    })
    this._logLevel = _checkLogLevel()

    return this
  },

  debug (message) {
    if (this._enabled && this._isLogLevelEnabled('debug')) {
      withNoop(() => this._logger.debug(processMsg(message)))
    }

    return this
  },

  info (message) {
    if (!this._logger.info) return this.debug(message)
    if (this._enabled && this._isLogLevelEnabled('info')) {
      withNoop(() => this._logger.info(processMsg(message)))
    }

    return this
  },

  warn (message) {
    if (!this._logger.warn) return this.debug(message)
    if (this._enabled && this._isLogLevelEnabled('warn')) {
      withNoop(() => this._logger.warn(processMsg(message)))
    }

    return this
  },

  error (err) {
    if (this._enabled && this._isLogLevelEnabled('error')) {
      if (err instanceof Function) {
        err = err()
      }

      if (typeof err !== 'object' || !err) {
        err = String(err)
      } else if (!err.stack) {
        err = String(err.message || err)
      }

      if (typeof err === 'string') {
        err = new Error(err)
      }

      withNoop(() => this._logger.error(err))
    }

    return this
  },

  deprecate (code, message) {
    return this._deprecate(code, message)
  }
}

log.reset()

module.exports = log


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/metrics.js":
false,

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/noop/scope.js":
false,

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/noop/span.js":
/*!***************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/noop/span.js ***!
  \***************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Span = __webpack_require__(/*! opentracing */ "../../node_modules/opentracing/lib/index.js").Span
const NoopSpanContext = __webpack_require__(/*! ../noop/span_context */ "../../node_modules/dd-trace/packages/dd-trace/src/noop/span_context.js")
const id = __webpack_require__(/*! ../id */ "../../node_modules/dd-trace/packages/dd-trace/src/id.js")

class NoopSpan extends Span {
  constructor (tracer, parent) {
    super()

    this._noopTracer = tracer
    this._noopContext = this._createContext(parent)
  }

  _context () {
    return this._noopContext
  }

  _tracer () {
    return this._noopTracer
  }

  _createContext (parent) {
    const spanId = id()

    if (parent) {
      return new NoopSpanContext({
        noop: this,
        traceId: parent._traceId,
        spanId,
        parentId: parent._spanId,
        baggageItems: Object.assign({}, parent._baggageItems)
      })
    } else {
      return new NoopSpanContext({
        noop: this,
        traceId: spanId,
        spanId
      })
    }
  }
}

module.exports = NoopSpan


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/noop/span_context.js":
/*!***********************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/noop/span_context.js ***!
  \***********************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const DatadogSpanContext = __webpack_require__(/*! ../opentracing/span_context */ "../../node_modules/dd-trace/packages/dd-trace/src/opentracing/span_context.js")
const priority = __webpack_require__(/*! ../../../../ext/priority */ "../../node_modules/dd-trace/ext/priority.js")

const USER_REJECT = priority.USER_REJECT

class NoopSpanContext extends DatadogSpanContext {
  constructor (props) {
    super(props)

    this._traceFlags.sampled = false
    this._sampling.priority = USER_REJECT
  }
}

module.exports = NoopSpanContext


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/noop/tracer.js":
/*!*****************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/noop/tracer.js ***!
  \*****************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Tracer = __webpack_require__(/*! opentracing */ "../../node_modules/opentracing/lib/index.js").Tracer
const Scope = __webpack_require__(/*! ../scope/base */ "../../node_modules/dd-trace/packages/dd-trace/src/scope/base.js")
const Span = __webpack_require__(/*! ./span */ "../../node_modules/dd-trace/packages/dd-trace/src/noop/span.js")
const platform = __webpack_require__(/*! ../platform */ "../../node_modules/dd-trace/packages/dd-trace/src/platform/index.js")

class NoopTracer extends Tracer {
  constructor (config) {
    super(config)

    let ScopeManager

    if (platform.env('DD_CONTEXT_PROPAGATION') === 'false') {
      ScopeManager = __webpack_require__(/*! ../scope/noop/scope_manager */ "../../node_modules/dd-trace/packages/dd-trace/src/scope/noop/scope_manager.js")
    } else {
      ScopeManager = __webpack_require__(/*! ../scope/scope_manager */ "../../node_modules/dd-trace/packages/dd-trace/src/scope/scope_manager.js")
    }

    this._scopeManager = new ScopeManager()
    this._scope = new Scope(config)
    this._span = new Span(this)
  }

  trace (name, options, fn) {
    return fn(this._span, () => {})
  }

  wrap (name, options, fn) {
    return fn
  }

  scopeManager () {
    return this._scopeManager
  }

  scope () {
    return this._scope
  }

  currentSpan () {
    return null
  }

  getRumData () {
    return ''
  }

  setUrl () {
  }

  _startSpan (name, options) {
    return this._span
  }
}

module.exports = NoopTracer


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/opentracing/propagation/text_map.js":
/*!**************************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/opentracing/propagation/text_map.js ***!
  \**************************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const pick = __webpack_require__(/*! lodash.pick */ "../../node_modules/lodash.pick/index.js")
const id = __webpack_require__(/*! ../../id */ "../../node_modules/dd-trace/packages/dd-trace/src/id.js")
const DatadogSpanContext = __webpack_require__(/*! ../span_context */ "../../node_modules/dd-trace/packages/dd-trace/src/opentracing/span_context.js")
const NoopSpanContext = __webpack_require__(/*! ../../noop/span_context */ "../../node_modules/dd-trace/packages/dd-trace/src/noop/span_context.js")
const log = __webpack_require__(/*! ../../log */ "../../node_modules/dd-trace/packages/dd-trace/src/log.js")

const traceKey = 'x-datadog-trace-id'
const spanKey = 'x-datadog-parent-id'
const originKey = 'x-datadog-origin'
const samplingKey = 'x-datadog-sampling-priority'
const sampleKey = 'x-datadog-sampled'
const baggagePrefix = 'ot-baggage-'
const b3TraceKey = 'x-b3-traceid'
const b3TraceExpr = /^([0-9a-f]{16}){1,2}$/i
const b3SpanKey = 'x-b3-spanid'
const b3SpanExpr = /^[0-9a-f]{16}$/i
const b3ParentKey = 'x-b3-parentspanid'
const b3SampledKey = 'x-b3-sampled'
const b3FlagsKey = 'x-b3-flags'
const b3HeaderKey = 'b3'
const b3HeaderExpr = /^(([0-9a-f]{16}){1,2}-[0-9a-f]{16}(-[01d](-[0-9a-f]{16})?)?|[01d])$/i
const baggageExpr = new RegExp(`^${baggagePrefix}(.+)$`)
const ddKeys = [traceKey, spanKey, samplingKey, originKey]
const b3Keys = [b3TraceKey, b3SpanKey, b3ParentKey, b3SampledKey, b3FlagsKey, b3HeaderKey]
const logKeys = ddKeys.concat(b3Keys)

class TextMapPropagator {
  constructor (config) {
    this._config = config
  }

  inject (spanContext, carrier) {
    carrier[traceKey] = spanContext.toTraceId()
    carrier[spanKey] = spanContext.toSpanId()
    carrier[sampleKey] = spanContext._traceFlags.sampled ? '1' : '0'

    this._injectOrigin(spanContext, carrier)
    this._injectSamplingPriority(spanContext, carrier)
    this._injectBaggageItems(spanContext, carrier)
    this._injectB3(spanContext, carrier)

    log.debug(() => `Inject into carrier: ${JSON.stringify(pick(carrier, logKeys))}.`)
  }

  extract (carrier) {
    const spanContext = this._extractSpanContext(carrier)

    if (!spanContext) return spanContext

    this._extractOrigin(carrier, spanContext)
    this._extractBaggageItems(carrier, spanContext)
    this._extractSamplingPriority(carrier, spanContext)

    log.debug(() => `Extract from carrier: ${JSON.stringify(pick(carrier, logKeys))}.`)

    return spanContext
  }

  _injectOrigin (spanContext, carrier) {
    const origin = spanContext._trace.origin

    if (origin) {
      carrier[originKey] = origin
    }
  }

  _injectSamplingPriority (spanContext, carrier) {
    const priority = spanContext._sampling.priority

    if (Number.isInteger(priority)) {
      carrier[samplingKey] = priority.toString()
    }
  }

  _injectBaggageItems (spanContext, carrier) {
    spanContext._baggageItems && Object.keys(spanContext._baggageItems).forEach(key => {
      carrier[baggagePrefix + key] = String(spanContext._baggageItems[key])
    })
  }

  _injectB3 (spanContext, carrier) {
    if (!this._config.experimental.b3) return

    carrier[b3TraceKey] = spanContext._traceId.toString('hex')
    carrier[b3SpanKey] = spanContext._spanId.toString('hex')
    carrier[b3SampledKey] = spanContext._traceFlags.sampled ? '1' : '0'

    if (spanContext._traceFlags.debug) {
      carrier[b3FlagsKey] = '1'
    }

    if (spanContext._parentId) {
      carrier[b3ParentKey] = spanContext._parentId.toString('hex')
    }
  }

  _extractSpanContext (carrier) {
    const context = this._extractContext(carrier)

    if (!context) return null

    if (context.traceFlags.sampled !== false) {
      return new DatadogSpanContext(context)
    } else {
      return new NoopSpanContext(context)
    }
  }

  _extractContext (carrier) {
    return this._extractDatadogContext(carrier) || this._extractB3Context(carrier)
  }

  _extractDatadogContext (carrier) {
    const sampled = this._isSampled(carrier[sampleKey])

    return this._extractGenericContext(carrier, traceKey, spanKey, { sampled }, 10)
  }

  _extractB3Context (carrier) {
    if (!this._config.experimental.b3) return null

    const b3 = this._extractB3Headers(carrier)
    const debug = b3[b3FlagsKey] === '1'
    const sampled = this._isSampled(b3[b3SampledKey], debug)

    return this._extractGenericContext(b3, b3TraceKey, b3SpanKey, { sampled, debug })
  }

  _extractGenericContext (carrier, traceKey, spanKey, traceFlags, radix) {
    if (carrier[traceKey] && carrier[spanKey]) {
      return {
        traceId: id(carrier[traceKey], radix),
        spanId: id(carrier[spanKey], radix),
        traceFlags
      }
    } else if (typeof traceFlags.sampled === 'boolean') {
      return {
        traceId: id(),
        spanId: null,
        traceFlags
      }
    }

    return null
  }

  _extractB3Headers (carrier) {
    if (b3HeaderExpr.test(carrier[b3HeaderKey])) {
      return this._extractB3SingleHeader(carrier)
    } else {
      return this._extractB3MultipleHeaders(carrier)
    }
  }

  _extractB3MultipleHeaders (carrier) {
    const b3 = {}

    if (b3TraceExpr.test(carrier[b3TraceKey]) && b3SpanExpr.test(carrier[b3SpanKey])) {
      b3[b3TraceKey] = carrier[b3TraceKey]
      b3[b3SpanKey] = carrier[b3SpanKey]
    }

    if (carrier[b3SampledKey]) {
      b3[b3SampledKey] = carrier[b3SampledKey]
    }

    if (carrier[b3FlagsKey]) {
      b3[b3FlagsKey] = carrier[b3FlagsKey]
    }

    return b3
  }

  _extractB3SingleHeader (carrier) {
    const parts = carrier[b3HeaderKey].split('-')

    if (parts[0] === 'd') {
      return {
        [b3SampledKey]: '1',
        [b3FlagsKey]: '1'
      }
    } else if (parts.length === 1) {
      return {
        [b3SampledKey]: parts[0]
      }
    } else {
      const b3 = {
        [b3TraceKey]: parts[0],
        [b3SpanKey]: parts[1],
        [b3SampledKey]: parts[2] !== '0' ? '1' : '0'
      }

      if (parts[2] === 'd') {
        b3[b3FlagsKey] = '1'
      }

      return b3
    }
  }

  _extractOrigin (carrier, spanContext) {
    const origin = carrier[originKey]

    if (typeof carrier[originKey] === 'string') {
      spanContext._trace.origin = origin
    }
  }

  _extractBaggageItems (carrier, spanContext) {
    Object.keys(carrier).forEach(key => {
      const match = key.match(baggageExpr)

      if (match) {
        spanContext._baggageItems[match[1]] = carrier[key]
      }
    })
  }

  _extractSamplingPriority (carrier, spanContext) {
    const priority = parseInt(carrier[samplingKey], 10)

    if (Number.isInteger(priority)) {
      spanContext._sampling.priority = parseInt(carrier[samplingKey], 10)
    }
  }

  _isSampled (sampled, debug) {
    if (debug || sampled === '1') {
      return true
    } else if (sampled === '0') {
      return false
    }

    return null
  }
}

module.exports = TextMapPropagator


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/opentracing/span.js":
/*!**********************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/opentracing/span.js ***!
  \**********************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const opentracing = __webpack_require__(/*! opentracing */ "../../node_modules/opentracing/lib/index.js")
const Span = opentracing.Span
const SpanContext = __webpack_require__(/*! ./span_context */ "../../node_modules/dd-trace/packages/dd-trace/src/opentracing/span_context.js")
const platform = __webpack_require__(/*! ../platform */ "../../node_modules/dd-trace/packages/dd-trace/src/platform/index.js")
const constants = __webpack_require__(/*! ../constants */ "../../node_modules/dd-trace/packages/dd-trace/src/constants.js")
const id = __webpack_require__(/*! ../id */ "../../node_modules/dd-trace/packages/dd-trace/src/id.js")
const tagger = __webpack_require__(/*! ../tagger */ "../../node_modules/dd-trace/packages/dd-trace/src/tagger.js")

const SAMPLE_RATE_METRIC_KEY = constants.SAMPLE_RATE_METRIC_KEY

class DatadogSpan extends Span {
  constructor (tracer, processor, sampler, prioritySampler, fields, debug) {
    super()

    const operationName = fields.operationName
    const parent = fields.parent || null
    const tags = Object.assign({
      [SAMPLE_RATE_METRIC_KEY]: sampler.rate()
    }, fields.tags)
    const hostname = fields.hostname

    this._parentTracer = tracer
    this._debug = debug
    this._sampler = sampler
    this._processor = processor
    this._prioritySampler = prioritySampler

    this._spanContext = this._createContext(parent)
    this._spanContext._name = operationName
    this._spanContext._tags = tags
    this._spanContext._hostname = hostname

    this._startTime = fields.startTime || this._getTime()

    if (debug) {
      this._handle = platform.metrics().track(this)
    }
  }

  toString () {
    const spanContext = this.context()
    const resourceName = spanContext._tags['resource.name']
    const resource = resourceName.length > 100
      ? `${resourceName.substring(0, 97)}...`
      : resourceName
    const json = JSON.stringify({
      traceId: spanContext._traceId,
      spanId: spanContext._spanId,
      parentId: spanContext._parentId,
      service: spanContext._tags['service.name'],
      name: spanContext._name,
      resource
    })

    return `Span${json}`
  }

  _createContext (parent) {
    let spanContext

    if (parent) {
      spanContext = new SpanContext({
        traceId: parent._traceId,
        spanId: id(),
        parentId: parent._spanId,
        sampling: parent._sampling,
        baggageItems: Object.assign({}, parent._baggageItems),
        trace: parent._trace
      })
    } else {
      const spanId = id()
      spanContext = new SpanContext({
        traceId: spanId,
        spanId
      })
    }

    spanContext._trace.started.push(this)
    spanContext._trace.startTime = spanContext._trace.startTime || Date.now()
    spanContext._trace.ticks = spanContext._trace.ticks || platform.now()

    return spanContext
  }

  _getTime () {
    const { startTime, ticks } = this._spanContext._trace

    return startTime + platform.now() - ticks
  }

  _context () {
    return this._spanContext
  }

  _tracer () {
    return this._parentTracer
  }

  _setOperationName (name) {
    this._spanContext._name = name
  }

  _setBaggageItem (key, value) {
    this._spanContext._baggageItems[key] = value
  }

  _getBaggageItem (key) {
    return this._spanContext._baggageItems[key]
  }

  _addTags (keyValuePairs) {
    tagger.add(this._spanContext._tags, keyValuePairs)
  }

  _finish (finishTime) {
    if (this._duration !== undefined) {
      return
    }

    finishTime = parseFloat(finishTime) || this._getTime()

    this._duration = finishTime - this._startTime
    this._spanContext._trace.finished.push(this)
    this._spanContext._isFinished = true

    if (this._debug) {
      this._handle.finish()
    }

    this._processor.process(this)
  }
}

module.exports = DatadogSpan


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/opentracing/span_context.js":
/*!******************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/opentracing/span_context.js ***!
  \******************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const SpanContext = __webpack_require__(/*! opentracing */ "../../node_modules/opentracing/lib/index.js").SpanContext

class DatadogSpanContext extends SpanContext {
  constructor (props) {
    super()

    props = props || {}

    this._traceId = props.traceId
    this._spanId = props.spanId
    this._parentId = props.parentId || null
    this._name = props.name
    this._isFinished = props.isFinished || false
    this._tags = props.tags || {}
    this._sampling = props.sampling || {}
    this._baggageItems = props.baggageItems || {}
    this._traceFlags = props.traceFlags || {}
    this._traceFlags.sampled = this._traceFlags.sampled !== false
    this._traceFlags.debug = this._traceFlags.debug === true
    this._noop = props.noop || null
    this._trace = props.trace || {
      started: [],
      finished: []
    }
  }

  toTraceId () {
    return this._traceId.toString(10)
  }

  toSpanId () {
    return this._spanId.toString(10)
  }
}

module.exports = DatadogSpanContext


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/opentracing/tracer.js":
/*!************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/opentracing/tracer.js ***!
  \************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const opentracing = __webpack_require__(/*! opentracing */ "../../node_modules/opentracing/lib/index.js")
const Tracer = opentracing.Tracer
const Reference = opentracing.Reference
const Span = __webpack_require__(/*! ./span */ "../../node_modules/dd-trace/packages/dd-trace/src/opentracing/span.js")
const SpanContext = __webpack_require__(/*! ./span_context */ "../../node_modules/dd-trace/packages/dd-trace/src/opentracing/span_context.js")
const SpanProcessor = __webpack_require__(/*! ../span_processor */ "../../node_modules/dd-trace/packages/dd-trace/src/span_processor.js")
const Sampler = __webpack_require__(/*! ../sampler */ "../../node_modules/dd-trace/packages/dd-trace/src/sampler.js")
const PrioritySampler = __webpack_require__(/*! ../priority_sampler */ "../../node_modules/dd-trace/packages/dd-trace/src/priority_sampler.js")
const TextMapPropagator = __webpack_require__(/*! ./propagation/text_map */ "../../node_modules/dd-trace/packages/dd-trace/src/opentracing/propagation/text_map.js")
const HttpPropagator = __webpack_require__(/*! ./propagation/http */ "../../node_modules/dd-trace/packages/dd-trace/src/opentracing/propagation/http.js")
const BinaryPropagator = __webpack_require__(/*! ./propagation/binary */ "../../node_modules/dd-trace/packages/dd-trace/src/opentracing/propagation/binary.js")
const LogPropagator = __webpack_require__(/*! ./propagation/log */ "../../node_modules/dd-trace/packages/dd-trace/src/opentracing/propagation/log.js")
const NoopSpan = __webpack_require__(/*! ../noop/span */ "../../node_modules/dd-trace/packages/dd-trace/src/noop/span.js")
const formats = __webpack_require__(/*! ../../../../ext/formats */ "../../node_modules/dd-trace/ext/formats.js")

const log = __webpack_require__(/*! ../log */ "../../node_modules/dd-trace/packages/dd-trace/src/log.js")
const constants = __webpack_require__(/*! ../constants */ "../../node_modules/dd-trace/packages/dd-trace/src/constants.js")
const platform = __webpack_require__(/*! ../platform */ "../../node_modules/dd-trace/packages/dd-trace/src/platform/index.js")

const REFERENCE_NOOP = constants.REFERENCE_NOOP
const REFERENCE_CHILD_OF = opentracing.REFERENCE_CHILD_OF
const REFERENCE_FOLLOWS_FROM = opentracing.REFERENCE_FOLLOWS_FROM

class DatadogTracer extends Tracer {
  constructor (config) {
    super()

    const Exporter = platform.exporter(config.experimental.exporter)

    this._service = config.service
    this._version = config.version
    this._env = config.env
    this._tags = config.tags
    this._logInjection = config.logInjection
    this._analytics = config.analytics
    this._debug = config.debug
    this._internalErrors = config.experimental.internalErrors
    this._prioritySampler = new PrioritySampler(config.env, config.experimental.sampler)
    this._exporter = new Exporter(config, this._prioritySampler)
    this._processor = new SpanProcessor(this._exporter, this._prioritySampler)
    this._url = this._exporter._url
    this._sampler = new Sampler(config.sampleRate)
    this._peers = config.experimental.peers
    this._enableGetRumData = config.experimental.enableGetRumData
    this._propagators = {
      [formats.TEXT_MAP]: new TextMapPropagator(config),
      [formats.HTTP_HEADERS]: new HttpPropagator(config),
      [formats.BINARY]: new BinaryPropagator(config),
      [formats.LOG]: new LogPropagator(config)
    }
    if (config.reportHostname) {
      this._hostname = platform.hostname()
    }
  }

  startSpan (name, fields) {
    if (fields) {
      if (fields.references) {
        return super.startSpan(name, fields)
      } else if (fields.childOf) {
        let parent = fields.childOf
        if (parent instanceof Span) {
          parent = parent.context()
        }
        if (parent instanceof SpanContext) {
          return this._startSpanInternal(name, fields, parent, REFERENCE_CHILD_OF)
        }
      }
    }
    return this._startSpanInternal(name, fields, null, null)
  }

  _startSpan (name, fields) {
    const reference = getParent(fields.references)
    const type = reference && reference.type()
    const parent = reference && reference.referencedContext()
    return this._startSpanInternal(name, fields, parent, type)
  }

  _startSpanInternal (name, fields = {}, parent, type) {
    if (parent && parent._noop) return parent._noop
    if (!isSampled(this._sampler, parent, type)) return new NoopSpan(this, parent)

    const tags = {
      'service.name': this._service
    }

    const span = new Span(this, this._processor, this._sampler, this._prioritySampler, {
      operationName: fields.operationName || name,
      parent,
      tags,
      startTime: fields.startTime,
      hostname: this._hostname
    }, this._debug)

    span.addTags(this._tags)
    span.addTags(fields.tags)
    span.addTags(platform.tags())

    return span
  }

  _inject (spanContext, format, carrier) {
    try {
      this._prioritySampler.sample(spanContext)
      this._propagators[format].inject(spanContext, carrier)
    } catch (e) {
      log.error(e)
      platform.metrics().increment('datadog.tracer.node.inject.errors', true)
    }

    return this
  }

  _extract (format, carrier) {
    try {
      return this._propagators[format].extract(carrier)
    } catch (e) {
      log.error(e)
      platform.metrics().increment('datadog.tracer.node.extract.errors', true)
      return null
    }
  }
}

function getParent (references = []) {
  let parent = null

  for (let i = 0; i < references.length; i++) {
    const ref = references[i]

    if (!(ref instanceof Reference)) {
      log.error(() => `Expected ${ref} to be an instance of opentracing.Reference`)
      continue
    }

    const spanContext = ref.referencedContext()
    const type = ref.type()

    if (type !== REFERENCE_NOOP && spanContext && !(spanContext instanceof SpanContext)) {
      log.error(() => `Expected ${spanContext} to be an instance of SpanContext`)
      continue
    }

    if (type === REFERENCE_CHILD_OF || type === REFERENCE_NOOP) {
      parent = ref
      break
    } else if (type === REFERENCE_FOLLOWS_FROM) {
      if (!parent) {
        parent = ref
      }
    }
  }

  return parent
}

function isSampled (sampler, parent, type) {
  if (type === REFERENCE_NOOP) return false
  if (parent && !parent._traceFlags.sampled) return false
  if (!parent && !sampler.isSampled()) return false

  return true
}

module.exports = DatadogTracer


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/pkg.js":
false,

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/platform/index.js":
/*!********************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/platform/index.js ***!
  \********************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = {
  use (impl) {
    Object.assign(this, impl)
  },

  configure (config) {
    this._config = config
  }
}


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/platform/node sync recursive":
/*!*********************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/platform/node sync ***!
  \*********************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports) {

function webpackEmptyContext(req) {
	var e = new Error("Cannot find module '" + req + "'");
	e.code = 'MODULE_NOT_FOUND';
	throw e;
}
webpackEmptyContext.keys = function() { return []; };
webpackEmptyContext.resolve = webpackEmptyContext;
module.exports = webpackEmptyContext;
webpackEmptyContext.id = "../../node_modules/dd-trace/packages/dd-trace/src/platform/node sync recursive";

/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/platform/node sync recursive ^.*\\/.*$":
/*!******************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/platform/node sync ^.*\/.*$ ***!
  \******************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var map = {
	"./": "../../node_modules/dd-trace/packages/dd-trace/src/platform/node/index.js",
	"./agents": "../../node_modules/dd-trace/packages/dd-trace/src/platform/node/agents.js",
	"./agents.js": "../../node_modules/dd-trace/packages/dd-trace/src/platform/node/agents.js",
	"./crypto": "../../node_modules/dd-trace/packages/dd-trace/src/platform/node/crypto.js",
	"./crypto.js": "../../node_modules/dd-trace/packages/dd-trace/src/platform/node/crypto.js",
	"./dogstatsd": "../../node_modules/dd-trace/packages/dd-trace/src/platform/node/dogstatsd.js",
	"./dogstatsd.js": "../../node_modules/dd-trace/packages/dd-trace/src/platform/node/dogstatsd.js",
	"./env": "../../node_modules/dd-trace/packages/dd-trace/src/platform/node/env.js",
	"./env.js": "../../node_modules/dd-trace/packages/dd-trace/src/platform/node/env.js",
	"./exporter": "../../node_modules/dd-trace/packages/dd-trace/src/platform/node/exporter.js",
	"./exporter.js": "../../node_modules/dd-trace/packages/dd-trace/src/platform/node/exporter.js",
	"./hostname": "../../node_modules/dd-trace/packages/dd-trace/src/platform/node/hostname.js",
	"./hostname.js": "../../node_modules/dd-trace/packages/dd-trace/src/platform/node/hostname.js",
	"./index": "../../node_modules/dd-trace/packages/dd-trace/src/platform/node/index.js",
	"./index.js": "../../node_modules/dd-trace/packages/dd-trace/src/platform/node/index.js",
	"./loader": "../../node_modules/dd-trace/packages/dd-trace/src/platform/node/loader.js",
	"./loader.js": "../../node_modules/dd-trace/packages/dd-trace/src/platform/node/loader.js",
	"./metrics": "../../node_modules/dd-trace/packages/dd-trace/src/platform/node/metrics.js",
	"./metrics.js": "../../node_modules/dd-trace/packages/dd-trace/src/platform/node/metrics.js",
	"./now": "../../node_modules/dd-trace/packages/dd-trace/src/platform/node/now.js",
	"./now.js": "../../node_modules/dd-trace/packages/dd-trace/src/platform/node/now.js",
	"./pkg": "../../node_modules/dd-trace/packages/dd-trace/src/platform/node/pkg.js",
	"./pkg.js": "../../node_modules/dd-trace/packages/dd-trace/src/platform/node/pkg.js",
	"./profiler": "../../node_modules/dd-trace/packages/dd-trace/src/platform/node/profiler.js",
	"./profiler.js": "../../node_modules/dd-trace/packages/dd-trace/src/platform/node/profiler.js",
	"./request": "../../node_modules/dd-trace/packages/dd-trace/src/platform/node/request.js",
	"./request.js": "../../node_modules/dd-trace/packages/dd-trace/src/platform/node/request.js",
	"./startup-log": "../../node_modules/dd-trace/packages/dd-trace/src/platform/node/startup-log.js",
	"./startup-log.js": "../../node_modules/dd-trace/packages/dd-trace/src/platform/node/startup-log.js",
	"./validate": "../../node_modules/dd-trace/packages/dd-trace/src/platform/node/validate.js",
	"./validate.js": "../../node_modules/dd-trace/packages/dd-trace/src/platform/node/validate.js"
};


function webpackContext(req) {
	var id = webpackContextResolve(req);
	return __webpack_require__(id);
}
function webpackContextResolve(req) {
	if(!__webpack_require__.o(map, req)) {
		var e = new Error("Cannot find module '" + req + "'");
		e.code = 'MODULE_NOT_FOUND';
		throw e;
	}
	return map[req];
}
webpackContext.keys = function webpackContextKeys() {
	return Object.keys(map);
};
webpackContext.resolve = webpackContextResolve;
module.exports = webpackContext;
webpackContext.id = "../../node_modules/dd-trace/packages/dd-trace/src/platform/node sync recursive ^.*\\/.*$";

/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/platform/node sync recursive ^.*\\/package\\.json$":
/*!*****************************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/platform/node sync ^.*\/package\.json$ ***!
  \*****************************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports) {

function webpackEmptyContext(req) {
	var e = new Error("Cannot find module '" + req + "'");
	e.code = 'MODULE_NOT_FOUND';
	throw e;
}
webpackEmptyContext.keys = function() { return []; };
webpackEmptyContext.resolve = webpackEmptyContext;
module.exports = webpackEmptyContext;
webpackEmptyContext.id = "../../node_modules/dd-trace/packages/dd-trace/src/platform/node sync recursive ^.*\\/package\\.json$";

/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/platform/node/agents.js":
/*!**************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/platform/node/agents.js ***!
  \**************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const http = __webpack_require__(/*! http */ "http")
const https = __webpack_require__(/*! https */ "https")

let agents

module.exports = config => agents || (agents = {
  httpAgent: new http.Agent({ keepAlive: true, lookup: config.lookup }),
  httpsAgent: new https.Agent({ keepAlive: true, lookup: config.lookup })
})


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/platform/node/crypto.js":
/*!**************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/platform/node/crypto.js ***!
  \**************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const { randomBytes } = __webpack_require__(/*! crypto */ "crypto")

module.exports = {
  getRandomValues (typedArray) {
    const size = typedArray.length * typedArray.BYTES_PER_ELEMENT
    const buffer = randomBytes(size).buffer

    typedArray.set(new typedArray.constructor(buffer))
  }
}


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/platform/node/dogstatsd.js":
/*!*****************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/platform/node/dogstatsd.js ***!
  \*****************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const dgram = __webpack_require__(/*! dgram */ "dgram")
const lookup = __webpack_require__(/*! dns */ "dns").lookup // cache to avoid instrumentation
const log = __webpack_require__(/*! ../../log */ "../../node_modules/dd-trace/packages/dd-trace/src/log.js")

const MAX_BUFFER_SIZE = 1024 // limit from the agent

class Client {
  constructor (options) {
    options = options || {}

    this._host = options.host || 'localhost'
    this._port = options.port || 8125
    this._prefix = options.prefix || ''
    this._tags = options.tags || []
    this._queue = []
    this._buffer = ''
    this._offset = 0
    this._udp4 = this._socket('udp4')
    this._udp6 = this._socket('udp6')
  }

  gauge (stat, value, tags) {
    this._add(stat, value, 'g', tags)
  }

  increment (stat, value, tags) {
    this._add(stat, value, 'c', tags)
  }

  flush () {
    const queue = this._enqueue()

    if (this._queue.length === 0) return

    this._queue = []

    lookup(this._host, (err, address, family) => {
      if (err) return log.error(err)

      queue.forEach(buffer => this._send(address, family, buffer))
    })
  }

  _send (address, family, buffer) {
    const socket = family === 6 ? this._udp6 : this._udp4

    log.debug(`Sending to DogStatsD: ${buffer}`)

    socket.send(buffer, 0, buffer.length, this._port, address)
  }

  _add (stat, value, type, tags) {
    const message = `${this._prefix + stat}:${value}|${type}`

    tags = tags ? this._tags.concat(tags) : this._tags

    if (tags.length > 0) {
      this._write(`${message}|#${tags.join(',')}\n`)
    } else {
      this._write(`${message}\n`)
    }
  }

  _write (message) {
    const offset = Buffer.byteLength(message)

    if (this._offset + offset > MAX_BUFFER_SIZE) {
      this._enqueue()
    }

    this._offset += offset
    this._buffer += message
  }

  _enqueue () {
    if (this._offset > 0) {
      this._queue.push(Buffer.from(this._buffer))
      this._buffer = ''
      this._offset = 0
    }

    return this._queue
  }

  _socket (type) {
    const socket = dgram.createSocket(type)

    socket.on('error', () => {})
    socket.unref()

    return socket
  }
}

module.exports = Client


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/platform/node/env.js":
/*!***********************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/platform/node/env.js ***!
  \***********************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = name => process.env[name]


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/platform/node/exporter.js":
/*!****************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/platform/node/exporter.js ***!
  \****************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const AgentExporter = __webpack_require__(/*! ../../exporters/agent */ "../../node_modules/dd-trace/packages/dd-trace/src/exporters/agent/index.js")
const LogExporter = __webpack_require__(/*! ../../exporters/log */ "../../node_modules/dd-trace/packages/dd-trace/src/exporters/log/index.js")
const env = __webpack_require__(/*! ./env */ "../../node_modules/dd-trace/packages/dd-trace/src/platform/node/env.js")
const exporters = __webpack_require__(/*! ../../../../../ext/exporters */ "../../node_modules/dd-trace/ext/exporters.js")

module.exports = name => {
  const inAWSLambda = env('AWS_LAMBDA_FUNCTION_NAME') !== undefined

  switch (name) {
    case exporters.LOG:
      return LogExporter
    case exporters.AGENT:
      return AgentExporter
    default:
      return inAWSLambda ? LogExporter : AgentExporter
  }
}


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/platform/node/hostname.js":
/*!****************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/platform/node/hostname.js ***!
  \****************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const os = __webpack_require__(/*! os */ "os")

module.exports = () => os.hostname()


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/platform/node/index.js":
/*!*************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/platform/node/index.js ***!
  \*************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const EventEmitter = __webpack_require__(/*! events */ "events")
const crypto = __webpack_require__(/*! ./crypto */ "../../node_modules/dd-trace/packages/dd-trace/src/platform/node/crypto.js")
const now = __webpack_require__(/*! ./now */ "../../node_modules/dd-trace/packages/dd-trace/src/platform/node/now.js")
const env = __webpack_require__(/*! ./env */ "../../node_modules/dd-trace/packages/dd-trace/src/platform/node/env.js")
const validate = __webpack_require__(/*! ./validate */ "../../node_modules/dd-trace/packages/dd-trace/src/platform/node/validate.js")
const request = __webpack_require__(/*! ./request */ "../../node_modules/dd-trace/packages/dd-trace/src/platform/node/request.js")
const metrics = __webpack_require__(/*! ./metrics */ "../../node_modules/dd-trace/packages/dd-trace/src/platform/node/metrics.js")
const plugins = __webpack_require__(/*! ../../plugins */ "../../node_modules/dd-trace/packages/dd-trace/src/plugins/index.js")
const hostname = __webpack_require__(/*! ./hostname */ "../../node_modules/dd-trace/packages/dd-trace/src/platform/node/hostname.js")
const Loader = __webpack_require__(/*! ./loader */ "../../node_modules/dd-trace/packages/dd-trace/src/platform/node/loader.js")
const scopes = __webpack_require__(/*! ../../../../../ext/scopes */ "../../node_modules/dd-trace/ext/scopes.js")
const exporter = __webpack_require__(/*! ./exporter */ "../../node_modules/dd-trace/packages/dd-trace/src/platform/node/exporter.js")
const profiler = __webpack_require__(/*! ./profiler */ "../../node_modules/dd-trace/packages/dd-trace/src/platform/node/profiler.js")
const pkg = __webpack_require__(/*! ./pkg */ "../../node_modules/dd-trace/packages/dd-trace/src/platform/node/pkg.js")
const startupLog = __webpack_require__(/*! ./startup-log */ "../../node_modules/dd-trace/packages/dd-trace/src/platform/node/startup-log.js")
const semver = __webpack_require__(/*! semver */ "../../node_modules/dd-trace/node_modules/semver/semver.js")

const emitter = new EventEmitter()

const hasSupportedAsyncLocalStorage = semver.satisfies(process.versions.node, '>=14.5 || ^12.19.0')

const platform = {
  _config: {},
  name: () => 'nodejs',
  version: () => process.version,
  engine: () => process.jsEngine || 'v8',
  crypto,
  now,
  env,
  tags: () => ({}),
  validate,
  service: () => process.env['AWS_LAMBDA_FUNCTION_NAME'] || pkg.name,
  appVersion: () => pkg.version,
  request,
  metrics,
  plugins,
  startupLog,
  hostname,
  on: emitter.on.bind(emitter),
  off: emitter.removeListener.bind(emitter),
  Loader,
  getScope (scope) {
    if (scope === scopes.ASYNC_RESOURCE) {
      return __webpack_require__(/*! ../../scope/async_resource */ "../../node_modules/dd-trace/packages/dd-trace/src/scope/async_resource.js")
    } else if (scope === scopes.ASYNC_LOCAL_STORAGE || (!scope && hasSupportedAsyncLocalStorage)) {
      return __webpack_require__(/*! ../../scope/async_local_storage */ "../../node_modules/dd-trace/packages/dd-trace/src/scope/async_local_storage.js")
    } else {
      return __webpack_require__(/*! ../../scope/async_hooks */ "../../node_modules/dd-trace/packages/dd-trace/src/scope/async_hooks.js")
    }
  },
  exporter,
  profiler () {
    return profiler(this._config)
  }
}

process.once('beforeExit', () => emitter.emit('exit'))

module.exports = platform


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/platform/node/loader.js":
/*!**************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/platform/node/loader.js ***!
  \**************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const semver = __webpack_require__(/*! semver */ "../../node_modules/dd-trace/node_modules/semver/semver.js")
const hook = __webpack_require__(/*! require-in-the-middle */ "../../node_modules/dd-trace/node_modules/require-in-the-middle/index.js")
const parse = __webpack_require__(/*! module-details-from-path */ "../../node_modules/module-details-from-path/index.js")
const path = __webpack_require__(/*! path */ "path")
const uniq = __webpack_require__(/*! lodash.uniq */ "../../node_modules/lodash.uniq/index.js")
const log = __webpack_require__(/*! ../../log */ "../../node_modules/dd-trace/packages/dd-trace/src/log.js")

const pathSepExpr = new RegExp(`\\${path.sep}`, 'g')

class Loader {
  constructor (instrumenter) {
    this._instrumenter = instrumenter
  }

  reload (plugins) {
    this._plugins = plugins

    const instrumentations = Array.from(this._plugins.keys())
      .reduce((prev, current) => prev.concat(current), [])

    const instrumentedModules = uniq(instrumentations
      .map(instrumentation => instrumentation.name))

    this._names = new Set(instrumentations
      .map(instrumentation => filename(instrumentation)))

    hook(instrumentedModules, { internals: true }, this._hookModule.bind(this))
  }

  load (instrumentation, config) {
    this._getModules(instrumentation).forEach(nodule => {
      this._instrumenter.patch(instrumentation, nodule, config)
    })
  }

  _getModules (instrumentation) {
    const modules = []
    const ids = Object.keys(__webpack_require__.c)

    let pkg

    for (let i = 0, l = ids.length; i < l; i++) {
      const id = ids[i].replace(pathSepExpr, '/')

      if (!id.includes(`/node_modules/${instrumentation.name}/`)) continue

      if (instrumentation.file) {
        if (!id.endsWith(`/node_modules/${filename(instrumentation)}`)) continue

        const basedir = getBasedir(ids[i])

        pkg = __webpack_require__("../../node_modules/dd-trace/packages/dd-trace/src/platform/node sync recursive ^.*\\/package\\.json$")(`${basedir}/package.json`)
      } else {
        const basedir = getBasedir(ids[i])

        pkg = __webpack_require__("../../node_modules/dd-trace/packages/dd-trace/src/platform/node sync recursive ^.*\\/package\\.json$")(`${basedir}/package.json`)

        const mainFile = path.posix.normalize(pkg.main || 'index.js')
        if (!id.endsWith(`/node_modules/${instrumentation.name}/${mainFile}`)) continue
      }

      if (!matchVersion(pkg.version, instrumentation.versions)) continue

      modules.push(__webpack_require__.c[ids[i]].exports)
    }

    return modules
  }

  _hookModule (moduleExports, moduleName, moduleBaseDir) {
    moduleName = moduleName.replace(pathSepExpr, '/')

    if (!this._names.has(moduleName)) {
      return moduleExports
    }

    if (moduleBaseDir) {
      moduleBaseDir = moduleBaseDir.replace(pathSepExpr, '/')
    }

    const moduleVersion = getVersion(moduleBaseDir)

    Array.from(this._plugins.keys())
      .filter(plugin => [].concat(plugin).some(instrumentation =>
        filename(instrumentation) === moduleName && matchVersion(moduleVersion, instrumentation.versions)
      ))
      .forEach(plugin => this._validate(plugin, moduleName, moduleBaseDir, moduleVersion))

    this._plugins
      .forEach((meta, plugin) => {
        try {
          [].concat(plugin)
            .filter(instrumentation => moduleName === filename(instrumentation))
            .filter(instrumentation => matchVersion(moduleVersion, instrumentation.versions))
            .forEach(instrumentation => {
              const config = this._plugins.get(plugin).config

              if (config.enabled !== false) {
                moduleExports = this._instrumenter.patch(instrumentation, moduleExports, config) || moduleExports
              }
            })
        } catch (e) {
          log.error(e)
          this._instrumenter.unload(plugin)
          log.debug(`Error while trying to patch ${meta.name}. The plugin has been disabled.`)
        }
      })

    return moduleExports
  }

  _validate (plugin, moduleName, moduleBaseDir, moduleVersion) {
    const meta = this._plugins.get(plugin)
    const instrumentations = [].concat(plugin)

    for (let i = 0; i < instrumentations.length; i++) {
      if (moduleName.indexOf(instrumentations[i].name) !== 0) continue
      if (instrumentations[i].versions && !matchVersion(moduleVersion, instrumentations[i].versions)) continue
      if (instrumentations[i].file && !exists(moduleBaseDir, instrumentations[i].file)) {
        this._instrumenter.unload(plugin)
        log.debug([
          `Plugin "${meta.name}" requires "${instrumentations[i].file}" which was not found.`,
          `The plugin was disabled.`
        ].join(' '))
        break
      }
    }
  }
}

function getBasedir (id) {
  return parse(id).basedir.replace(pathSepExpr, '/')
}

function matchVersion (version, ranges) {
  return !version || (ranges && ranges.some(range => semver.satisfies(semver.coerce(version), range)))
}

function getVersion (moduleBaseDir) {
  if (moduleBaseDir) {
    const packageJSON = `${moduleBaseDir}/package.json`
    return __webpack_require__("../../node_modules/dd-trace/packages/dd-trace/src/platform/node sync recursive")(packageJSON).version
  }
}

function filename (plugin) {
  return [plugin.name, plugin.file].filter(val => val).join('/')
}

function exists (basedir, file) {
  try {
    /*require.resolve*/(__webpack_require__("../../node_modules/dd-trace/packages/dd-trace/src/platform/node sync recursive ^.*\\/.*$").resolve(`${basedir}/${file}`))
    return true
  } catch (e) {
    return false
  }
}

module.exports = Loader


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/platform/node/metrics.js":
/*!***************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/platform/node/metrics.js ***!
  \***************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// TODO: capture every second and flush every 10 seconds

const v8 = __webpack_require__(/*! v8 */ "v8")
const path = __webpack_require__(/*! path */ "path")
const os = __webpack_require__(/*! os */ "os")
const Client = __webpack_require__(/*! ./dogstatsd */ "../../node_modules/dd-trace/packages/dd-trace/src/platform/node/dogstatsd.js")
const log = __webpack_require__(/*! ../../log */ "../../node_modules/dd-trace/packages/dd-trace/src/log.js")
const Histogram = __webpack_require__(/*! ../../histogram */ "../../node_modules/dd-trace/packages/dd-trace/src/histogram.js")

const INTERVAL = 10 * 1000

let nativeMetrics = null

let metrics
let interval
let client
let time
let cpuUsage
let gauges
let counters
let histograms

reset()

module.exports = function () {
  return metrics || (metrics = { // cache the metrics instance
    start: (options) => {
      const tags = []

      Object.keys(this._config.tags)
        .filter(key => typeof this._config.tags[key] === 'string')
        .forEach(key => {
          // https://docs.datadoghq.com/tagging/#defining-tags
          const value = this._config.tags[key].replace(/[^a-z0-9_:./-]/ig, '_')

          tags.push(`${key}:${value}`)
        })

      options = options || {}

      try {
        nativeMetrics = __webpack_require__(/*! node-gyp-build */ "../../node_modules/node-gyp-build/index.js")(path.join(__dirname, '..', '..', '..', '..', '..'))
        nativeMetrics.start()
      } catch (e) {
        log.error(e)
        nativeMetrics = null
      }

      client = new Client({
        host: this._config.dogstatsd.hostname,
        port: this._config.dogstatsd.port,
        tags
      })

      time = process.hrtime()

      if (nativeMetrics) {
        interval = setInterval(() => {
          captureCommonMetrics()
          captureNativeMetrics()
          client.flush()
        }, INTERVAL)
      } else {
        cpuUsage = process.cpuUsage()

        interval = setInterval(() => {
          captureCommonMetrics()
          captureCpuUsage()
          captureHeapSpace()
          client.flush()
        }, INTERVAL)
      }

      interval.unref()
    },

    stop: () => {
      if (nativeMetrics) {
        nativeMetrics.stop()
      }

      clearInterval(interval)
      reset()
    },

    track (span) {
      if (nativeMetrics) {
        const handle = nativeMetrics.track(span)

        return {
          finish: () => nativeMetrics.finish(handle)
        }
      }

      return { finish: () => {} }
    },

    boolean (name, value, tag) {
      metrics.gauge(name, value ? 1 : 0, tag)
    },

    histogram (name, value, tag) {
      if (!client) return

      histograms[name] = histograms[name] || new Map()

      if (!histograms[name].has(tag)) {
        histograms[name].set(tag, new Histogram())
      }

      histograms[name].get(tag).record(value)
    },

    count (name, count, tag, monotonic = false) {
      if (!client) return
      if (typeof tag === 'boolean') {
        monotonic = tag
        tag = undefined
      }

      const map = monotonic ? counters : gauges

      map[name] = map[name] || new Map()

      const value = map[name].get(tag) || 0

      map[name].set(tag, value + count)
    },

    gauge (name, value, tag) {
      if (!client) return

      gauges[name] = gauges[name] || new Map()
      gauges[name].set(tag, value)
    },

    increment (name, tag, monotonic) {
      this.count(name, 1, tag, monotonic)
    },

    decrement (name, tag) {
      this.count(name, -1, tag)
    }
  })
}

function reset () {
  interval = null
  client = null
  time = null
  cpuUsage = null
  gauges = {}
  counters = {}
  histograms = {}
}

function captureCpuUsage () {
  if (!process.cpuUsage) return

  const elapsedTime = process.hrtime(time)
  const elapsedUsage = process.cpuUsage(cpuUsage)

  time = process.hrtime()
  cpuUsage = process.cpuUsage()

  const elapsedMs = elapsedTime[0] * 1000 + elapsedTime[1] / 1000000
  const userPercent = 100 * elapsedUsage.user / 1000 / elapsedMs
  const systemPercent = 100 * elapsedUsage.system / 1000 / elapsedMs
  const totalPercent = userPercent + systemPercent

  client.gauge('runtime.node.cpu.system', systemPercent.toFixed(2))
  client.gauge('runtime.node.cpu.user', userPercent.toFixed(2))
  client.gauge('runtime.node.cpu.total', totalPercent.toFixed(2))
}

function captureMemoryUsage () {
  const stats = process.memoryUsage()

  client.gauge('runtime.node.mem.heap_total', stats.heapTotal)
  client.gauge('runtime.node.mem.heap_used', stats.heapUsed)
  client.gauge('runtime.node.mem.rss', stats.rss)
  client.gauge('runtime.node.mem.total', os.totalmem())
  client.gauge('runtime.node.mem.free', os.freemem())

  stats.external && client.gauge('runtime.node.mem.external', stats.external)
}

function captureProcess () {
  client.gauge('runtime.node.process.uptime', Math.round(process.uptime()))
}

function captureHeapStats () {
  const stats = v8.getHeapStatistics()

  client.gauge('runtime.node.heap.total_heap_size', stats.total_heap_size)
  client.gauge('runtime.node.heap.total_heap_size_executable', stats.total_heap_size_executable)
  client.gauge('runtime.node.heap.total_physical_size', stats.total_physical_size)
  client.gauge('runtime.node.heap.total_available_size', stats.total_available_size)
  client.gauge('runtime.node.heap.heap_size_limit', stats.heap_size_limit)

  stats.malloced_memory && client.gauge('runtime.node.heap.malloced_memory', stats.malloced_memory)
  stats.peak_malloced_memory && client.gauge('runtime.node.heap.peak_malloced_memory', stats.peak_malloced_memory)
}

function captureHeapSpace () {
  if (!v8.getHeapSpaceStatistics) return

  const stats = v8.getHeapSpaceStatistics()

  for (let i = 0, l = stats.length; i < l; i++) {
    const tags = [`space:${stats[i].space_name}`]

    client.gauge('runtime.node.heap.size.by.space', stats[i].space_size, tags)
    client.gauge('runtime.node.heap.used_size.by.space', stats[i].space_used_size, tags)
    client.gauge('runtime.node.heap.available_size.by.space', stats[i].space_available_size, tags)
    client.gauge('runtime.node.heap.physical_size.by.space', stats[i].physical_space_size, tags)
  }
}

function captureGauges () {
  Object.keys(gauges).forEach(name => {
    gauges[name].forEach((value, tag) => {
      client.gauge(name, value, tag && [tag])
    })
  })
}

function captureCounters () {
  Object.keys(counters).forEach(name => {
    counters[name].forEach((value, tag) => {
      client.increment(name, value, tag && [tag])
    })
  })

  counters = {}
}

function captureHistograms () {
  Object.keys(histograms).forEach(name => {
    histograms[name].forEach((stats, tag) => {
      histogram(name, stats, tag && [tag])
      stats.reset()
    })
  })
}

function captureCommonMetrics () {
  captureMemoryUsage()
  captureProcess()
  captureHeapStats()
  captureGauges()
  captureCounters()
  captureHistograms()
}

function captureNativeMetrics () {
  const stats = nativeMetrics.stats()
  const spaces = stats.heap.spaces
  const elapsedTime = process.hrtime(time)

  time = process.hrtime()

  const elapsedUs = elapsedTime[0] * 1e6 + elapsedTime[1] / 1e3
  const userPercent = 100 * stats.cpu.user / elapsedUs
  const systemPercent = 100 * stats.cpu.system / elapsedUs
  const totalPercent = userPercent + systemPercent

  client.gauge('runtime.node.cpu.system', systemPercent.toFixed(2))
  client.gauge('runtime.node.cpu.user', userPercent.toFixed(2))
  client.gauge('runtime.node.cpu.total', totalPercent.toFixed(2))

  histogram('runtime.node.event_loop.delay', stats.eventLoop)

  Object.keys(stats.gc).forEach(type => {
    if (type === 'all') {
      histogram('runtime.node.gc.pause', stats.gc[type])
    } else {
      histogram('runtime.node.gc.pause.by.type', stats.gc[type], [`gc_type:${type}`])
    }
  })

  client.gauge('runtime.node.spans.finished', stats.spans.total.finished)
  client.gauge('runtime.node.spans.unfinished', stats.spans.total.unfinished)

  for (let i = 0, l = spaces.length; i < l; i++) {
    const tags = [`heap_space:${spaces[i].space_name}`]

    client.gauge('runtime.node.heap.size.by.space', spaces[i].space_size, tags)
    client.gauge('runtime.node.heap.used_size.by.space', spaces[i].space_used_size, tags)
    client.gauge('runtime.node.heap.available_size.by.space', spaces[i].space_available_size, tags)
    client.gauge('runtime.node.heap.physical_size.by.space', spaces[i].physical_space_size, tags)
  }

  if (stats.spans.operations) {
    const operations = stats.spans.operations

    Object.keys(operations.finished).forEach(name => {
      client.gauge('runtime.node.spans.finished.by.name', operations.finished[name], [`span_name:${name}`])
    })

    Object.keys(operations.unfinished).forEach(name => {
      client.gauge('runtime.node.spans.unfinished.by.name', operations.unfinished[name], [`span_name:${name}`])
    })
  }
}

function histogram (name, stats, tags) {
  tags = [].concat(tags)

  client.gauge(`${name}.min`, stats.min, tags)
  client.gauge(`${name}.max`, stats.max, tags)
  client.increment(`${name}.sum`, stats.sum, tags)
  client.increment(`${name}.total`, stats.sum, tags)
  client.gauge(`${name}.avg`, stats.avg, tags)
  client.increment(`${name}.count`, stats.count, tags)
  client.gauge(`${name}.median`, stats.median, tags)
  client.gauge(`${name}.95percentile`, stats.p95, tags)
}


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/platform/node/now.js":
/*!***********************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/platform/node/now.js ***!
  \***********************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(/*! performance-now */ "../../node_modules/performance-now/lib/performance-now.js")


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/platform/node/pkg.js":
/*!***********************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/platform/node/pkg.js ***!
  \***********************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const path = __webpack_require__(/*! path */ "path")
const readPkgUp = __webpack_require__(/*! read-pkg-up */ "../../node_modules/dd-trace/node_modules/read-pkg-up/index.js")

function findRoot () {
  return __webpack_require__.c[__webpack_require__.s] && __webpack_require__.c[__webpack_require__.s].filename ? path.dirname(__webpack_require__.c[__webpack_require__.s].filename) : process.cwd()
}

function findPkg () {
  const cwd = findRoot()
  const up = readPkgUp.sync({ cwd })

  return up && up.pkg ? up.pkg : {}
}

module.exports = findPkg()


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/platform/node/profiler.js":
/*!****************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/platform/node/profiler.js ***!
  \****************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const log = __webpack_require__(/*! ../../log */ "../../node_modules/dd-trace/packages/dd-trace/src/log.js")
const { profiler, AgentExporter, FileExporter } = __webpack_require__(/*! ../../profiling */ "../../node_modules/dd-trace/packages/dd-trace/src/profiling/index.js")

let cached

module.exports = config => cached || (cached = {
  start: () => {
    const { service, version, env } = config
    const { enabled, sourceMap, exporters } = config.profiling
    const logger = {
      debug: (message) => log.debug(message),
      info: (message) => log.info(message),
      warn: (message) => log.warn(message),
      error: (message) => log.error(message)
    }

    profiler.start({
      enabled,
      service,
      version,
      env,
      logger,
      sourceMap,
      exporters: getExporters(exporters, config)
    })
  },

  stop: () => {
    profiler.stop()
  }
})

function getExporters (names, { url, hostname, port }) {
  const exporters = []

  for (const name of names.split(',')) {
    switch (name) {
      case 'agent':
        exporters.push(new AgentExporter({ url, hostname, port }))
        break
      case 'file':
        exporters.push(new FileExporter())
        break
    }
  }

  return exporters
}


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/platform/node/request.js":
/*!***************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/platform/node/request.js ***!
  \***************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const http = __webpack_require__(/*! http */ "http")
const https = __webpack_require__(/*! https */ "https")
const agents = __webpack_require__(/*! ./agents */ "../../node_modules/dd-trace/packages/dd-trace/src/platform/node/agents.js")
const containerInfo = __webpack_require__(/*! container-info */ "../../node_modules/container-info/index.js").sync() || {}

const containerId = containerInfo.containerId

function request (options, callback) {
  const platform = this

  options = Object.assign({
    headers: {},
    data: [],
    timeout: 2000
  }, options)

  const data = [].concat(options.data)
  const isSecure = options.protocol === 'https:'
  const { httpAgent, httpsAgent } = agents(platform._config)
  const client = isSecure ? https : http
  const agent = isSecure ? httpsAgent : httpAgent

  options.agent = agent
  options.headers['Content-Length'] = byteLength(data)

  if (containerId) {
    options.headers['Datadog-Container-ID'] = containerId
  }

  const req = client.request(options, res => {
    let data = ''

    res.setTimeout(options.timeout)

    res.on('data', chunk => { data += chunk })
    res.on('end', () => {
      if (res.statusCode >= 200 && res.statusCode <= 299) {
        callback(null, data, res.statusCode)
      } else {
        const error = new Error(`Error from the agent: ${res.statusCode} ${http.STATUS_CODES[res.statusCode]}`)
        error.status = res.statusCode

        callback(error, null, res.statusCode)
      }
    })
  })

  req.setTimeout(options.timeout, req.abort)
  req.on('error', e => callback(new Error(`Network error trying to reach the agent: ${e.message}`)))

  data.forEach(buffer => req.write(buffer))

  req.end()
}

function byteLength (data) {
  return data.length > 0 ? data.reduce((prev, next) => prev + next.length, 0) : 0
}

module.exports = request


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/platform/node/startup-log.js":
/*!*******************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/platform/node/startup-log.js ***!
  \*******************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const mainLogger = __webpack_require__(/*! ../../log */ "../../node_modules/dd-trace/packages/dd-trace/src/log.js")
const path = __webpack_require__(/*! path */ "path")
const os = __webpack_require__(/*! os */ "os")
const { inspect } = __webpack_require__(/*! util */ "util")
const tracerVersion = __webpack_require__(/*! ../../../lib/version */ "../../node_modules/dd-trace/packages/dd-trace/lib/version.js")

const logger = Object.create(mainLogger)
logger._enabled = true

let config
let instrumenter
let samplingRules = []

let alreadyRan = false

function getIntegrationsAndAnalytics () {
  const integrations = new Set()
  const extras = {}
  for (const plugin of instrumenter._instrumented.keys()) {
    if (plugin.versions) {
      try {
        const version = __webpack_require__("../../node_modules/dd-trace/packages/dd-trace/src/platform/node sync recursive")(path.join(plugin.name, 'package.json')).version
        integrations.add(`${plugin.name}@${version}`)
      } catch (e) {
        integrations.add(plugin.name)
      }
    } else {
      integrations.add(plugin.name)
    }

    const pluginData = instrumenter._plugins.get(plugin.name)
    if (pluginData) {
      const pluginConfig = pluginData.config
      if (pluginConfig && pluginConfig.analytics) {
        extras[`integration_${plugin.name}_analytics_enabled`] = true
        if (typeof pluginConfig.analytics !== 'boolean') {
          extras[`integration_${plugin.name}_sample_rate`] = pluginConfig.analytics
        }
      }
    }
  }
  extras.integrations_loaded = Array.from(integrations)
  return extras
}

function startupLog ({ agentError } = {}) {
  if (!config || !instrumenter) {
    return
  }

  if (alreadyRan) {
    return
  }

  alreadyRan = true

  if (!config.startupLogs) {
    return
  }

  const url = config.url || `http://${config.hostname || 'localhost'}:${config.port}`

  const out = {
    [inspect.custom] () {
      return String(this)
    },
    toString () {
      return JSON.stringify(this)
    }
  }

  out.date = new Date().toISOString()
  out.os_name = os.type()
  out.os_version = os.release()
  out.architecture = os.arch()
  out.version = tracerVersion
  out.lang = 'nodejs'
  out.lang_version = process.versions.node
  out.env = config.env
  out.enabled = config.enabled
  out.scope_manager = config.scope
  out.service = config.service
  out.agent_url = url
  if (agentError) {
    out.agent_error = agentError.message
  }
  out.debug = !!config.debug
  out.analytics_enabled = !!config.analytics
  out.sample_rate = config.sampleRate
  out.sampling_rules = samplingRules
  out.tags = config.tags
  if (config.tags && config.tags.version) {
    out.dd_version = config.tags.version
  }

  out.log_injection_enabled = !!config.logInjection
  out.runtime_metrics_enabled = !!config.runtimeMetrics
  Object.assign(out, getIntegrationsAndAnalytics())

  // // This next bunch is for features supported by other tracers, but not this
  // // one. They may be implemented in the future.

  // out.enabled_cli
  // out.sampling_rules_error
  // out.integration_XXX_analytics_enabled
  // out.integration_XXX_sample_rate
  // out.service_mapping
  // out.service_mapping_error

  logger.info('DATADOG TRACER CONFIGURATION - ' + out)
  if (agentError) {
    logger.warn('DATADOG TRACER DIAGNOSTIC - Agent Error: ' + agentError.message)
  }

  config = undefined
  instrumenter = undefined
  samplingRules = undefined
}

function setStartupLogConfig (aConfig) {
  config = aConfig
}

function setStartupLogInstrumenter (theInstrumenter) {
  instrumenter = theInstrumenter
}

function setSamplingRules (theRules) {
  samplingRules = theRules
}

module.exports = {
  startupLog,
  setStartupLogConfig,
  setStartupLogInstrumenter,
  setSamplingRules
}


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/platform/node/validate.js":
/*!****************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/platform/node/validate.js ***!
  \****************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const semver = __webpack_require__(/*! semver */ "../../node_modules/dd-trace/node_modules/semver/semver.js")

const SUPPORTED_VERSIONS = '>=8'

function validate () {
  if (!semver.satisfies(process.versions.node, SUPPORTED_VERSIONS)) {
    throw new Error([
      `Node ${process.versions.node} is not supported.`,
      `Only versions of Node matching "${SUPPORTED_VERSIONS}" are supported.`,
      `Tracing has been disabled.`
    ].join(' '))
  }
}

module.exports = validate


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/plugin_manager.js":
false,

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/plugins/index.js":
/*!*******************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/plugins/index.js ***!
  \*******************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = {
  'amqp10': __webpack_require__(/*! ../../../datadog-plugin-amqp10/src */ "../../node_modules/dd-trace/packages/datadog-plugin-amqp10/src/index.js"),
  'amqplib': __webpack_require__(/*! ../../../datadog-plugin-amqplib/src */ "../../node_modules/dd-trace/packages/datadog-plugin-amqplib/src/index.js"),
  'aws-sdk': __webpack_require__(/*! ../../../datadog-plugin-aws-sdk/src */ "../../node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/index.js"),
  'bluebird': __webpack_require__(/*! ../../../datadog-plugin-bluebird/src */ "../../node_modules/dd-trace/packages/datadog-plugin-bluebird/src/index.js"),
  'bunyan': __webpack_require__(/*! ../../../datadog-plugin-bunyan/src */ "../../node_modules/dd-trace/packages/datadog-plugin-bunyan/src/index.js"),
  'cassandra-driver': __webpack_require__(/*! ../../../datadog-plugin-cassandra-driver/src */ "../../node_modules/dd-trace/packages/datadog-plugin-cassandra-driver/src/index.js"),
  'connect': __webpack_require__(/*! ../../../datadog-plugin-connect/src */ "../../node_modules/dd-trace/packages/datadog-plugin-connect/src/index.js"),
  'couchbase': __webpack_require__(/*! ../../../datadog-plugin-couchbase/src */ "../../node_modules/dd-trace/packages/datadog-plugin-couchbase/src/index.js"),
  'dns': __webpack_require__(/*! ../../../datadog-plugin-dns/src */ "../../node_modules/dd-trace/packages/datadog-plugin-dns/src/index.js"),
  'elasticsearch': __webpack_require__(/*! ../../../datadog-plugin-elasticsearch/src */ "../../node_modules/dd-trace/packages/datadog-plugin-elasticsearch/src/index.js"),
  'express': __webpack_require__(/*! ../../../datadog-plugin-express/src */ "../../node_modules/dd-trace/packages/datadog-plugin-express/src/index.js"),
  'fastify': __webpack_require__(/*! ../../../datadog-plugin-fastify/src */ "../../node_modules/dd-trace/packages/datadog-plugin-fastify/src/index.js"),
  'fs': __webpack_require__(/*! ../../../datadog-plugin-fs/src */ "../../node_modules/dd-trace/packages/datadog-plugin-fs/src/index.js"),
  'generic-pool': __webpack_require__(/*! ../../../datadog-plugin-generic-pool/src */ "../../node_modules/dd-trace/packages/datadog-plugin-generic-pool/src/index.js"),
  'google-cloud-pubsub': __webpack_require__(/*! ../../../datadog-plugin-google-cloud-pubsub/src */ "../../node_modules/dd-trace/packages/datadog-plugin-google-cloud-pubsub/src/index.js"),
  'graphql': __webpack_require__(/*! ../../../datadog-plugin-graphql/src */ "../../node_modules/dd-trace/packages/datadog-plugin-graphql/src/index.js"),
  'grpc': __webpack_require__(/*! ../../../datadog-plugin-grpc/src */ "../../node_modules/dd-trace/packages/datadog-plugin-grpc/src/index.js"),
  'hapi': __webpack_require__(/*! ../../../datadog-plugin-hapi/src */ "../../node_modules/dd-trace/packages/datadog-plugin-hapi/src/index.js"),
  'http': __webpack_require__(/*! ../../../datadog-plugin-http/src */ "../../node_modules/dd-trace/packages/datadog-plugin-http/src/index.js"),
  'http2': __webpack_require__(/*! ../../../datadog-plugin-http2/src */ "../../node_modules/dd-trace/packages/datadog-plugin-http2/src/index.js"),
  'ioredis': __webpack_require__(/*! ../../../datadog-plugin-ioredis/src */ "../../node_modules/dd-trace/packages/datadog-plugin-ioredis/src/index.js"),
  'knex': __webpack_require__(/*! ../../../datadog-plugin-knex/src */ "../../node_modules/dd-trace/packages/datadog-plugin-knex/src/index.js"),
  'koa': __webpack_require__(/*! ../../../datadog-plugin-koa/src */ "../../node_modules/dd-trace/packages/datadog-plugin-koa/src/index.js"),
  'limitd-client': __webpack_require__(/*! ../../../datadog-plugin-limitd-client/src */ "../../node_modules/dd-trace/packages/datadog-plugin-limitd-client/src/index.js"),
  'memcached': __webpack_require__(/*! ../../../datadog-plugin-memcached/src */ "../../node_modules/dd-trace/packages/datadog-plugin-memcached/src/index.js"),
  'microgateway-core': __webpack_require__(/*! ../../../datadog-plugin-microgateway-core/src */ "../../node_modules/dd-trace/packages/datadog-plugin-microgateway-core/src/index.js"),
  'mongodb-core': __webpack_require__(/*! ../../../datadog-plugin-mongodb-core/src */ "../../node_modules/dd-trace/packages/datadog-plugin-mongodb-core/src/index.js"),
  'mongoose': __webpack_require__(/*! ../../../datadog-plugin-mongoose/src */ "../../node_modules/dd-trace/packages/datadog-plugin-mongoose/src/index.js"),
  'mysql': __webpack_require__(/*! ../../../datadog-plugin-mysql/src */ "../../node_modules/dd-trace/packages/datadog-plugin-mysql/src/index.js"),
  'mysql2': __webpack_require__(/*! ../../../datadog-plugin-mysql2/src */ "../../node_modules/dd-trace/packages/datadog-plugin-mysql2/src/index.js"),
  'net': __webpack_require__(/*! ../../../datadog-plugin-net/src */ "../../node_modules/dd-trace/packages/datadog-plugin-net/src/index.js"),
  'paperplane': __webpack_require__(/*! ../../../datadog-plugin-paperplane/src */ "../../node_modules/dd-trace/packages/datadog-plugin-paperplane/src/index.js"),
  'pg': __webpack_require__(/*! ../../../datadog-plugin-pg/src */ "../../node_modules/dd-trace/packages/datadog-plugin-pg/src/index.js"),
  'pino': __webpack_require__(/*! ../../../datadog-plugin-pino/src */ "../../node_modules/dd-trace/packages/datadog-plugin-pino/src/index.js"),
  'promise': __webpack_require__(/*! ../../../datadog-plugin-promise/src */ "../../node_modules/dd-trace/packages/datadog-plugin-promise/src/index.js"),
  'promise-js': __webpack_require__(/*! ../../../datadog-plugin-promise-js/src */ "../../node_modules/dd-trace/packages/datadog-plugin-promise-js/src/index.js"),
  'q': __webpack_require__(/*! ../../../datadog-plugin-q/src */ "../../node_modules/dd-trace/packages/datadog-plugin-q/src/index.js"),
  'redis': __webpack_require__(/*! ../../../datadog-plugin-redis/src */ "../../node_modules/dd-trace/packages/datadog-plugin-redis/src/index.js"),
  'restify': __webpack_require__(/*! ../../../datadog-plugin-restify/src */ "../../node_modules/dd-trace/packages/datadog-plugin-restify/src/index.js"),
  'rhea': __webpack_require__(/*! ../../../datadog-plugin-rhea/src */ "../../node_modules/dd-trace/packages/datadog-plugin-rhea/src/index.js"),
  'router': __webpack_require__(/*! ../../../datadog-plugin-router/src */ "../../node_modules/dd-trace/packages/datadog-plugin-router/src/index.js"),
  'tedious': __webpack_require__(/*! ../../../datadog-plugin-tedious/src */ "../../node_modules/dd-trace/packages/datadog-plugin-tedious/src/index.js"),
  'when': __webpack_require__(/*! ../../../datadog-plugin-when/src */ "../../node_modules/dd-trace/packages/datadog-plugin-when/src/index.js"),
  'winston': __webpack_require__(/*! ../../../datadog-plugin-winston/src */ "../../node_modules/dd-trace/packages/datadog-plugin-winston/src/index.js")
}


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/plugins/log_plugin.js":
false,

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/plugins/plugin.js":
false,

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/plugins/util/ci.js":
false,

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/plugins/util/env.js":
false,

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/plugins/util/exec.js":
false,

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/plugins/util/git.js":
false,

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/plugins/util/promise.js":
/*!**************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/plugins/util/promise.js ***!
  \**************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = {
  createWrapThen (tracer, config) {
    return function wrapThen (then) {
      return function thenWithTrace (onFulfilled, onRejected, onProgress) {
        arguments[0] = wrapCallback(tracer, onFulfilled)
        arguments[1] = wrapCallback(tracer, onRejected)

        // not standard but sometimes supported
        if (onProgress) {
          arguments[2] = wrapCallback(tracer, onProgress)
        }

        return then.apply(this, arguments)
      }
    }
  }
}

function wrapCallback (tracer, callback) {
  if (typeof callback !== 'function') return callback

  const span = tracer.scope().active()

  return function () {
    return tracer.scope().activate(span, () => {
      return callback.apply(this, arguments)
    })
  }
}


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/plugins/util/redis.js":
/*!************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/plugins/util/redis.js ***!
  \************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const analyticsSampler = __webpack_require__(/*! ../../analytics_sampler */ "../../node_modules/dd-trace/packages/dd-trace/src/analytics_sampler.js")
const urlFilter = __webpack_require__(/*! ../util/urlfilter */ "../../node_modules/dd-trace/packages/dd-trace/src/plugins/util/urlfilter.js")
const tx = __webpack_require__(/*! ./tx */ "../../node_modules/dd-trace/packages/dd-trace/src/plugins/util/tx.js")

const redis = {
  // Ensure the configuration has the correct structure and defaults.
  normalizeConfig (config) {
    const filter = urlFilter.getFilter(config)

    return Object.assign({}, config, {
      filter
    })
  },

  // Start a span for a Redis command.
  instrument (tracer, config, db, command, args) {
    const childOf = tracer.scope().active()
    const span = tracer.startSpan('redis.command', {
      childOf,
      tags: {
        'span.kind': 'client',
        'resource.name': command,
        'span.type': 'redis',
        'db.type': 'redis',
        'db.name': db || '0',
        'out.host': '127.0.0.1',
        'out.port': String(6379),
        'redis.raw_command': formatCommand(command, args)
      }
    })

    span.setTag('service.name', config.service || `${span.context()._tags['service.name']}-redis`)

    analyticsSampler.sample(span, config.analytics)

    return span
  }
}

function formatCommand (command, args) {
  command = command.toUpperCase()

  if (!args) return command

  for (let i = 0, l = args.length; i < l; i++) {
    if (typeof args[i] === 'function') continue

    command = `${command} ${formatArg(args[i])}`

    if (command.length > 1000) return trim(command, 1000)
  }

  return command
}

function formatArg (arg) {
  switch (typeof arg) {
    case 'string':
    case 'number':
      return trim(String(arg), 100)
    default:
      return '?'
  }
}

function trim (str, maxlen) {
  if (str.length > maxlen) {
    str = str.substr(0, maxlen - 3) + '...'
  }

  return str
}

module.exports = Object.assign({}, tx, redis)


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/plugins/util/tags.js":
false,

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/plugins/util/test.js":
false,

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/plugins/util/tx.js":
/*!*********************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/plugins/util/tx.js ***!
  \*********************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const tx = {
  // Set the outgoing host.
  setHost (span, hostname, port) {
    hostname && span.setTag('out.host', hostname)
    port && span.setTag('out.port', port)
  },

  // Wrap a promise or a callback to also finish the span.
  wrap (span, done) {
    if (typeof done === 'function' || !done) {
      return wrapCallback(span, done)
    } else if (isPromise(done)) {
      return wrapPromise(span, done)
    }
  }
}

function wrapCallback (span, callback) {
  const scope = span.tracer().scope()
  const previous = scope.active()

  return function (err) {
    finish(span, err)

    if (callback) {
      return scope.activate(previous, () => callback.apply(this, arguments))
    }
  }
}

function wrapPromise (span, promise) {
  promise.then(
    () => finish(span),
    err => finish(span, err)
  )

  return promise
}

function finish (span, error) {
  if (error) {
    span.addTags({
      'error.type': error.name,
      'error.msg': error.message,
      'error.stack': error.stack
    })
  }

  span.finish()
}

function isPromise (obj) {
  return isObject(obj) && typeof obj.then === 'function'
}

function isObject (obj) {
  return typeof obj === 'object' && obj !== null
}

module.exports = tx


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/plugins/util/urlfilter.js":
/*!****************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/plugins/util/urlfilter.js ***!
  \****************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const log = __webpack_require__(/*! ../../log */ "../../node_modules/dd-trace/packages/dd-trace/src/log.js")

const urlFilter = {
  getFilter (config) {
    if (typeof config.filter === 'function') {
      return config.filter
    } else if (config.hasOwnProperty('filter')) {
      log.error('Expected `filter` to be a function. Overriding filter property to default.')
    }

    const whitelist = config.whitelist || /.*/
    const blacklist = config.blacklist || []

    return uri => {
      const whitelisted = applyFilter(whitelist, uri)
      const blacklisted = applyFilter(blacklist, uri)
      return whitelisted && !blacklisted
    }

    function applyFilter (filter, uri) {
      if (typeof filter === 'function') {
        return filter(uri)
      } else if (filter instanceof RegExp) {
        return filter.test(uri)
      } else if (filter instanceof Array) {
        return filter.some(filter => applyFilter(filter, uri))
      }

      return filter === uri
    }
  }
}

module.exports = urlFilter


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/plugins/util/user-provided-git.js":
false,

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/plugins/util/web.js":
/*!**********************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/plugins/util/web.js ***!
  \**********************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const uniq = __webpack_require__(/*! lodash.uniq */ "../../node_modules/lodash.uniq/index.js")
const analyticsSampler = __webpack_require__(/*! ../../analytics_sampler */ "../../node_modules/dd-trace/packages/dd-trace/src/analytics_sampler.js")
const FORMAT_HTTP_HEADERS = __webpack_require__(/*! opentracing */ "../../node_modules/opentracing/lib/index.js").FORMAT_HTTP_HEADERS
const log = __webpack_require__(/*! ../../log */ "../../node_modules/dd-trace/packages/dd-trace/src/log.js")
const tags = __webpack_require__(/*! ../../../../../ext/tags */ "../../node_modules/dd-trace/ext/tags.js")
const types = __webpack_require__(/*! ../../../../../ext/types */ "../../node_modules/dd-trace/ext/types.js")
const kinds = __webpack_require__(/*! ../../../../../ext/kinds */ "../../node_modules/dd-trace/ext/kinds.js")
const urlFilter = __webpack_require__(/*! ./urlfilter */ "../../node_modules/dd-trace/packages/dd-trace/src/plugins/util/urlfilter.js")

const WEB = types.WEB
const SERVER = kinds.SERVER
const RESOURCE_NAME = tags.RESOURCE_NAME
const SERVICE_NAME = tags.SERVICE_NAME
const SPAN_TYPE = tags.SPAN_TYPE
const SPAN_KIND = tags.SPAN_KIND
const ERROR = tags.ERROR
const HTTP_METHOD = tags.HTTP_METHOD
const HTTP_URL = tags.HTTP_URL
const HTTP_STATUS_CODE = tags.HTTP_STATUS_CODE
const HTTP_ROUTE = tags.HTTP_ROUTE
const HTTP_REQUEST_HEADERS = tags.HTTP_REQUEST_HEADERS
const HTTP_RESPONSE_HEADERS = tags.HTTP_RESPONSE_HEADERS

const HTTP2_HEADER_AUTHORITY = ':authority'
const HTTP2_HEADER_SCHEME = ':scheme'
const HTTP2_HEADER_PATH = ':path'

const web = {
  // Ensure the configuration has the correct structure and defaults.
  normalizeConfig (config) {
    config = config.server || config

    const headers = getHeadersToRecord(config)
    const validateStatus = getStatusValidator(config)
    const hooks = getHooks(config)
    const filter = urlFilter.getFilter(config)
    const middleware = getMiddlewareSetting(config)

    return Object.assign({}, config, {
      headers,
      validateStatus,
      hooks,
      filter,
      middleware
    })
  },

  // Start a span and activate a scope for a request.
  instrument (tracer, config, req, res, name, callback) {
    this.patch(req)

    const span = startSpan(tracer, config, req, res, name)

    // TODO: replace this with a REFERENCE_NOOP after we split http/express/etc
    if (!config.filter(req.url)) {
      span.context()._traceFlags.sampled = false
    }

    if (config.service) {
      span.setTag(SERVICE_NAME, config.service)
    }

    analyticsSampler.sample(span, config.analytics, true)

    if (!req._datadog.instrumented) {
      wrapEnd(req)
      wrapEvents(req)

      req._datadog.instrumented = true
    }

    return callback && tracer.scope().activate(span, () => callback(span))
  },

  // Reactivate the request scope in case it was changed by a middleware.
  reactivate (req, fn) {
    return reactivate(req, fn)
  },

  // Add a route segment that will be used for the resource name.
  enterRoute (req, path) {
    if (typeof path === 'string') {
      req._datadog.paths.push(path)
    }
  },

  // Remove the current route segment.
  exitRoute (req) {
    req._datadog.paths.pop()
  },

  // Start a new middleware span and activate a new scope with the span.
  wrapMiddleware (req, middleware, name, fn) {
    if (!this.active(req)) return fn()

    const tracer = req._datadog.tracer
    const childOf = this.active(req)

    if (req._datadog.config.middleware === false) return this.bindAndWrapMiddlewareErrors(fn, req, tracer, childOf)

    const span = tracer.startSpan(name, { childOf })

    span.addTags({
      [RESOURCE_NAME]: middleware._name || middleware.name || '<anonymous>'
    })

    req._datadog.middleware.push(span)

    return tracer.scope().activate(span, fn)
  },

  // catch errors and apply to active span
  bindAndWrapMiddlewareErrors (fn, req, tracer, activeSpan) {
    try {
      return tracer.scope().bind(fn, activeSpan).apply(this, arguments)
    } catch (e) {
      web.addError(req, e) // TODO: remove when error formatting is moved to Span
      throw e
    }
  },

  // Finish the active middleware span.
  finish (req, error) {
    if (!this.active(req)) return

    const span = req._datadog.middleware.pop()

    if (span) {
      if (error) {
        span.addTags({
          'error.type': error.name,
          'error.msg': error.message,
          'error.stack': error.stack
        })
      }

      span.finish()
    }
  },

  // Register a callback to run before res.end() is called.
  beforeEnd (req, callback) {
    req._datadog.beforeEnd.push(callback)
  },

  // Prepare the request for instrumentation.
  patch (req) {
    if (req._datadog) return

    if (req.stream && req.stream._datadog) {
      req._datadog = req.stream._datadog
      return
    }

    req._datadog = {
      span: null,
      paths: [],
      middleware: [],
      beforeEnd: [],
      config: {}
    }
  },

  // Return the request root span.
  root (req) {
    return req._datadog ? req._datadog.span : null
  },

  // Return the active span.
  active (req) {
    if (!req._datadog) return null
    if (req._datadog.middleware.length === 0) return req._datadog.span || null

    return req._datadog.middleware.slice(-1)[0]
  },

  // Extract the parent span from the headers and start a new span as its child
  startChildSpan (tracer, name, headers) {
    const childOf = tracer.extract(FORMAT_HTTP_HEADERS, headers)
    const span = tracer.startSpan(name, { childOf })

    return span
  },

  // Validate a request's status code and then add error tags if necessary
  addStatusError (req, statusCode) {
    const span = req._datadog.span
    const error = req._datadog.error

    if (!req._datadog.config.validateStatus(statusCode)) {
      span.setTag(ERROR, error || true)
    }
  },

  // Add an error to the request
  addError (req, error) {
    if (error instanceof Error) {
      req._datadog.error = req._datadog.error || error
    }
  }
}

function startSpan (tracer, config, req, res, name) {
  req._datadog.config = config

  let span

  if (req._datadog.span) {
    req._datadog.span.context()._name = name
    span = req._datadog.span
  } else {
    span = web.startChildSpan(tracer, name, req.headers)
  }

  configureDatadogObject(tracer, span, req, res)

  return span
}

function configureDatadogObject (tracer, span, req, res) {
  const ddObj = req._datadog
  ddObj.tracer = tracer
  ddObj.span = span
  ddObj.res = res
}

function finish (req, res) {
  if (req._datadog.finished && !req.stream) return

  addRequestTags(req)
  addResponseTags(req)

  req._datadog.config.hooks.request(req._datadog.span, req, res)
  addResourceTag(req)

  req._datadog.span.finish()
  req._datadog.finished = true
}

function finishMiddleware (req, res) {
  if (req._datadog.finished) return

  let span

  while ((span = req._datadog.middleware.pop())) {
    span.finish()
  }
}

function wrapEnd (req) {
  const res = req._datadog.res
  const end = res.end

  res.writeHead = wrapWriteHead(req)

  res._datadog_end = function () {
    for (const beforeEnd of req._datadog.beforeEnd) {
      beforeEnd()
    }

    finishMiddleware(req, res)

    const returnValue = end.apply(res, arguments)

    finish(req, res)

    return returnValue
  }

  res._datadog_req = req

  if (!res._datadog_instrumented) {
    const target = Reflect.getPrototypeOf(res)
    Object.defineProperty(target, 'end', {
      configurable: true,
      get () {
        return this._datadog_end || end
      },
      set (value) {
        const req = this._datadog_req
        if (req && req._datadog) {
          const scope = req._datadog.tracer.scope()
          this._datadog_end = scope.bind(value, req._datadog.span)
        } else {
          this._datadog_end = value
        }
      }
    })
    target._datadog_instrumented = true
  }
}

function wrapWriteHead (req) {
  const res = req._datadog.res
  const writeHead = res.writeHead

  return function (statusCode, statusMessage, headers) {
    headers = typeof statusMessage === 'string' ? headers : statusMessage
    headers = Object.assign(res.getHeaders(), headers)

    if (req.method.toLowerCase() === 'options' && isOriginAllowed(req, headers)) {
      addAllowHeaders(req, headers)
    }

    return writeHead.apply(this, arguments)
  }
}

function addAllowHeaders (req, headers) {
  const res = req._datadog.res
  const allowHeaders = splitHeader(headers['access-control-allow-headers'])
  const requestHeaders = splitHeader(req.headers['access-control-request-headers'])
  const contextHeaders = [
    'x-datadog-parent-id',
    'x-datadog-sampled',
    'x-datadog-sampling-priority',
    'x-datadog-trace-id'
  ]

  for (const header of contextHeaders) {
    if (~requestHeaders.indexOf(header)) {
      allowHeaders.push(header)
    }
  }

  if (allowHeaders.length > 0) {
    res.setHeader('access-control-allow-headers', uniq(allowHeaders).join(','))
  }
}

function isOriginAllowed (req, headers) {
  const origin = req.headers['origin']
  const allowOrigin = headers['access-control-allow-origin']

  return origin && (allowOrigin === '*' || allowOrigin === origin)
}

function splitHeader (str) {
  return typeof str === 'string' ? str.split(/\s*,\s*/) : []
}

function wrapEvents (req) {
  const scope = req._datadog.tracer.scope()
  const res = req._datadog.res

  scope.bind(res, req._datadog.span)
}

function reactivate (req, fn) {
  return req._datadog
    ? req._datadog.tracer.scope().activate(req._datadog.span, fn)
    : fn()
}

function addRequestTags (req) {
  const url = extractURL(req)
  const span = req._datadog.span

  span.addTags({
    [HTTP_URL]: url.split('?')[0],
    [HTTP_METHOD]: req.method,
    [SPAN_KIND]: SERVER,
    [SPAN_TYPE]: WEB
  })

  addHeaders(req)
}

function addResponseTags (req) {
  const span = req._datadog.span
  const res = req._datadog.res

  if (req._datadog.paths.length > 0) {
    span.setTag(HTTP_ROUTE, req._datadog.paths.join(''))
  }

  span.addTags({
    [HTTP_STATUS_CODE]: res.statusCode
  })

  web.addStatusError(req, res.statusCode)
}

function addResourceTag (req) {
  const span = req._datadog.span
  const tags = span.context()._tags

  if (tags['resource.name']) return

  const resource = [req.method, tags[HTTP_ROUTE]]
    .filter(val => val)
    .join(' ')

  span.setTag(RESOURCE_NAME, resource)
}

function addHeaders (req) {
  const span = req._datadog.span

  req._datadog.config.headers.forEach(key => {
    const reqHeader = req.headers[key]
    const resHeader = req._datadog.res.getHeader(key)

    if (reqHeader) {
      span.setTag(`${HTTP_REQUEST_HEADERS}.${key}`, reqHeader)
    }

    if (resHeader) {
      span.setTag(`${HTTP_RESPONSE_HEADERS}.${key}`, resHeader)
    }
  })
}

function extractURL (req) {
  const headers = req.headers

  if (req.stream) {
    return `${headers[HTTP2_HEADER_SCHEME]}://${headers[HTTP2_HEADER_AUTHORITY]}${headers[HTTP2_HEADER_PATH]}`
  } else {
    const protocol = req.connection.encrypted ? 'https' : 'http'
    return `${protocol}://${req.headers['host']}${req.originalUrl || req.url}`
  }
}

function getHeadersToRecord (config) {
  if (Array.isArray(config.headers)) {
    try {
      return config.headers.map(key => key.toLowerCase())
    } catch (err) {
      log.error(err)
    }
  } else if (config.hasOwnProperty('headers')) {
    log.error('Expected `headers` to be an array of strings.')
  }
  return []
}

function getStatusValidator (config) {
  if (typeof config.validateStatus === 'function') {
    return config.validateStatus
  } else if (config.hasOwnProperty('validateStatus')) {
    log.error('Expected `validateStatus` to be a function.')
  }
  return code => code < 500
}

function getHooks (config) {
  const noop = () => {}
  const request = (config.hooks && config.hooks.request) || noop

  return { request }
}

function getMiddlewareSetting (config) {
  if (config && typeof config.middleware === 'boolean') {
    return config.middleware
  } else if (config && config.hasOwnProperty('middleware')) {
    log.error('Expected `middleware` to be a boolean.')
  }

  return true
}

module.exports = web


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/priority_sampler.js":
/*!**********************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/priority_sampler.js ***!
  \**********************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const RateLimiter = __webpack_require__(/*! ./rate_limiter */ "../../node_modules/dd-trace/packages/dd-trace/src/rate_limiter.js")
const Sampler = __webpack_require__(/*! ./sampler */ "../../node_modules/dd-trace/packages/dd-trace/src/sampler.js")
const ext = __webpack_require__(/*! ../../../ext */ "../../node_modules/dd-trace/ext/index.js")
const { setSamplingRules } = __webpack_require__(/*! ./platform */ "../../node_modules/dd-trace/packages/dd-trace/src/platform/index.js").startupLog

const {
  SAMPLING_RULE_DECISION,
  SAMPLING_LIMIT_DECISION,
  SAMPLING_AGENT_DECISION
} = __webpack_require__(/*! ./constants */ "../../node_modules/dd-trace/packages/dd-trace/src/constants.js")

const SERVICE_NAME = ext.tags.SERVICE_NAME
const SAMPLING_PRIORITY = ext.tags.SAMPLING_PRIORITY
const MANUAL_KEEP = ext.tags.MANUAL_KEEP
const MANUAL_DROP = ext.tags.MANUAL_DROP
const USER_REJECT = ext.priority.USER_REJECT
const AUTO_REJECT = ext.priority.AUTO_REJECT
const AUTO_KEEP = ext.priority.AUTO_KEEP
const USER_KEEP = ext.priority.USER_KEEP
const DEFAULT_KEY = 'service:,env:'

class PrioritySampler {
  constructor (env, { sampleRate, rateLimit = 100, rules = [] } = {}) {
    this._env = env
    this._rules = this._normalizeRules(rules, sampleRate)
    this._limiter = new RateLimiter(rateLimit)

    setSamplingRules(this._rules)

    this.update({})
  }

  isSampled (span) {
    const context = this._getContext(span)
    const rule = this._findRule(context)

    return rule
      ? this._isSampledByRule(context, rule) && this._isSampledByRateLimit(context)
      : this._isSampledByAgent(context)
  }

  sample (span) {
    if (!span) return

    const context = this._getContext(span)

    if (context._sampling.priority !== undefined) return

    const tag = this._getPriority(context._tags)

    if (this.validate(tag)) {
      context._sampling.priority = tag
      return
    }

    context._sampling.priority = this.isSampled(span) ? AUTO_KEEP : AUTO_REJECT
  }

  update (rates) {
    const samplers = {}

    for (const key in rates) {
      const rate = rates[key]
      const sampler = new Sampler(rate)

      samplers[key] = sampler
    }

    samplers[DEFAULT_KEY] = samplers[DEFAULT_KEY] || new Sampler(AUTO_KEEP)

    this._samplers = samplers
  }

  validate (samplingPriority) {
    switch (samplingPriority) {
      case USER_REJECT:
      case USER_KEEP:
      case AUTO_REJECT:
      case AUTO_KEEP:
        return true
      default:
        return false
    }
  }

  _getContext (span) {
    return typeof span.context === 'function' ? span.context() : span
  }

  _getPriority (tags) {
    if (tags.hasOwnProperty(MANUAL_KEEP) && tags[MANUAL_KEEP] !== false) {
      return USER_KEEP
    } else if (tags.hasOwnProperty(MANUAL_DROP) && tags[MANUAL_DROP] !== false) {
      return USER_REJECT
    } else {
      const priority = parseInt(tags[SAMPLING_PRIORITY], 10)

      if (priority === 1 || priority === 2) {
        return USER_KEEP
      } else if (priority === 0 || priority === -1) {
        return USER_REJECT
      }
    }
  }

  _isSampledByRule (context, rule) {
    context._tags[SAMPLING_RULE_DECISION] = rule.sampleRate

    return rule.sampler.isSampled(context)
  }

  _isSampledByRateLimit (context) {
    const allowed = this._limiter.isAllowed()

    context._tags[SAMPLING_LIMIT_DECISION] = this._limiter.effectiveRate()

    return allowed
  }

  _isSampledByAgent (context) {
    const key = `service:${context._tags[SERVICE_NAME]},env:${this._env}`
    const sampler = this._samplers[key] || this._samplers[DEFAULT_KEY]

    context._tags[SAMPLING_AGENT_DECISION] = sampler.rate()

    return sampler.isSampled(context)
  }

  _normalizeRules (rules, sampleRate) {
    return rules
      .concat({ sampleRate })
      .map(rule => ({ ...rule, sampleRate: parseFloat(rule.sampleRate) }))
      .filter(rule => !isNaN(rule.sampleRate))
      .map(rule => ({ ...rule, sampler: new Sampler(rule.sampleRate) }))
  }

  _findRule (context) {
    for (let i = 0, l = this._rules.length; i < l; i++) {
      if (this._matchRule(context, this._rules[i])) return this._rules[i]
    }
  }

  _matchRule (context, rule) {
    const name = context._name
    const service = context._tags['service.name']

    if (rule.name instanceof RegExp && !rule.name.test(name)) return false
    if (rule.name && rule.name !== name) return false
    if (rule.service instanceof RegExp && !rule.service.test(service)) return false
    if (rule.service && rule.service !== service) return false

    return true
  }
}

module.exports = PrioritySampler


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/profiler.js":
false,

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/profiling sync recursive":
/*!*****************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/profiling sync ***!
  \*****************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports) {

function webpackEmptyContext(req) {
	var e = new Error("Cannot find module '" + req + "'");
	e.code = 'MODULE_NOT_FOUND';
	throw e;
}
webpackEmptyContext.keys = function() { return []; };
webpackEmptyContext.resolve = webpackEmptyContext;
module.exports = webpackEmptyContext;
webpackEmptyContext.id = "../../node_modules/dd-trace/packages/dd-trace/src/profiling sync recursive";

/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/profiling/config.js":
/*!**********************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/profiling/config.js ***!
  \**********************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const coalesce = __webpack_require__(/*! koalas */ "../../node_modules/koalas/index.js")
const os = __webpack_require__(/*! os */ "os")
const { AgentExporter } = __webpack_require__(/*! ./exporters/agent */ "../../node_modules/dd-trace/packages/dd-trace/src/profiling/exporters/agent.js")
const { InspectorCpuProfiler } = __webpack_require__(/*! ./profilers/inspector/cpu */ "../../node_modules/dd-trace/packages/dd-trace/src/profiling/profilers/inspector/cpu.js")
const { InspectorHeapProfiler } = __webpack_require__(/*! ./profilers/inspector/heap */ "../../node_modules/dd-trace/packages/dd-trace/src/profiling/profilers/inspector/heap.js")
const { ConsoleLogger } = __webpack_require__(/*! ./loggers/console */ "../../node_modules/dd-trace/packages/dd-trace/src/profiling/loggers/console.js")
const { tagger } = __webpack_require__(/*! ./tagger */ "../../node_modules/dd-trace/packages/dd-trace/src/profiling/tagger.js")
const platform = __webpack_require__(/*! ../platform */ "../../node_modules/dd-trace/packages/dd-trace/src/platform/index.js")

const {
  DD_PROFILING_ENABLED,
  DD_ENV,
  DD_TAGS,
  DD_SERVICE,
  DD_VERSION
} = process.env

class Config {
  constructor (options = {}) {
    const enabled = coalesce(options.enabled, DD_PROFILING_ENABLED, true)
    const env = coalesce(options.env, DD_ENV)
    const service = coalesce(options.service, DD_SERVICE, platform.service())
    const host = os.hostname()
    const version = coalesce(options.version, DD_VERSION, platform.appVersion())
    const flushInterval = 60 * 1000

    this.enabled = String(enabled) !== 'false'
    this.service = service
    this.env = env
    this.host = host
    this.version = version
    this.tags = Object.assign(
      tagger.parse(DD_TAGS),
      tagger.parse(options.tags),
      tagger.parse({ env, host, service, version })
    )
    this.logger = options.logger || new ConsoleLogger()
    this.flushInterval = flushInterval
    this.exporters = options.exporters || [
      new AgentExporter()
    ]
    this.profilers = options.profilers || [
      new InspectorCpuProfiler(),
      new InspectorHeapProfiler()
    ]
  }
}

module.exports = { Config }


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/profiling/encoders/pprof.js":
/*!******************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/profiling/encoders/pprof.js ***!
  \******************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const { gzip } = __webpack_require__(/*! zlib */ "zlib")
const { perftools } = __webpack_require__(/*! ../../../../../protobuf/profile */ "../../node_modules/dd-trace/protobuf/profile.js")
const { Profile } = perftools.profiles

class Encoder {
  encode (profile, callback) {
    try {
      gzip(Profile.encode(profile).finish(), callback)
    } catch (e) {
      callback(e)
    }
  }
}

module.exports = { Encoder }


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/profiling/exporters/agent.js":
/*!*******************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/profiling/exporters/agent.js ***!
  \*******************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const FormData = __webpack_require__(/*! form-data */ "../../node_modules/form-data/lib/form_data.js")
const { URL } = __webpack_require__(/*! url */ "url")
const { Encoder } = __webpack_require__(/*! ../encoders/pprof */ "../../node_modules/dd-trace/packages/dd-trace/src/profiling/encoders/pprof.js")
const platform = __webpack_require__(/*! ../../platform */ "../../node_modules/dd-trace/packages/dd-trace/src/platform/index.js")
const { eachOfSeries } = __webpack_require__(/*! ../util */ "../../node_modules/dd-trace/packages/dd-trace/src/profiling/util.js")

class AgentExporter {
  constructor ({ url, hostname, port } = {}) {
    this._url = new URL(url || `http://${hostname || 'localhost'}:${port || 8126}`)
    this._encoder = new Encoder()
  }

  export ({ profiles, start, end, tags }, callback) {
    const form = new FormData()
    const types = Object.keys(profiles)
    const runtime = platform.name()

    form.append('recording-start', start.toISOString())
    form.append('recording-end', end.toISOString())
    form.append('language', 'javascript')
    form.append('runtime', runtime)
    form.append('format', 'pprof')

    form.append('tags[]', 'language:javascript')
    form.append('tags[]', `runtime:${runtime}`)
    form.append('tags[]', 'format:pprof')

    for (const key in tags) {
      form.append('tags[]', `${key}:${tags[key]}`)
    }

    eachOfSeries(types, (type, index, callback) => {
      const profile = profiles[type]

      this._encoder.encode(profile, (err, buffer) => {
        if (err) return callback(err)

        form.append(`types[${index}]`, type)
        form.append(`data[${index}]`, buffer, {
          filename: `${type}.pb.gz`,
          contentType: 'application/octet-stream',
          knownLength: buffer.length
        })

        callback(null, buffer)
      })
    }, err => {
      if (err) return callback(err)

      const options = {
        method: 'POST',
        path: '/profiling/v1/input',
        timeout: 10 * 1000
      }

      if (this._url.protocol === 'unix:') {
        options.socketPath = this._url.pathname
      } else {
        options.protocol = this._url.protocol
        options.hostname = this._url.hostname
        options.port = this._url.port
      }

      form.submit(options, (err, res) => {
        if (err) return callback(err)
        if (res.statusCode >= 400) {
          return callback(new Error(`Error from the agent: ${res.statusCode}`))
        }

        callback()
      })
    })
  }
}

module.exports = { AgentExporter }


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/profiling/exporters/file.js":
/*!******************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/profiling/exporters/file.js ***!
  \******************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const { writeFile } = __webpack_require__(/*! fs */ "fs")
const { Encoder } = __webpack_require__(/*! ../encoders/pprof */ "../../node_modules/dd-trace/packages/dd-trace/src/profiling/encoders/pprof.js")
const { parallel } = __webpack_require__(/*! ../util */ "../../node_modules/dd-trace/packages/dd-trace/src/profiling/util.js")

class FileExporter {
  constructor () {
    this._encoder = new Encoder()
  }

  export ({ profiles }, callback) {
    const types = Object.keys(profiles)
    const tasks = types.map(type => cb => this._write(type, profiles[type], cb))

    parallel(tasks, callback)
  }

  _write (type, profile, callback) {
    this._encoder.encode(profile, (err, buffer) => {
      if (err) return callback(err)

      writeFile(`${type}.pb.gz`, buffer, callback)
    })
  }
}

module.exports = { FileExporter }


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/profiling/index.js":
/*!*********************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/profiling/index.js ***!
  \*********************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const { Profiler } = __webpack_require__(/*! ./profiler */ "../../node_modules/dd-trace/packages/dd-trace/src/profiling/profiler.js")
const { InspectorCpuProfiler } = __webpack_require__(/*! ./profilers/inspector/cpu */ "../../node_modules/dd-trace/packages/dd-trace/src/profiling/profilers/inspector/cpu.js")
const { InspectorHeapProfiler } = __webpack_require__(/*! ./profilers/inspector/heap */ "../../node_modules/dd-trace/packages/dd-trace/src/profiling/profilers/inspector/heap.js")
const { NativeCpuProfiler } = __webpack_require__(/*! ./profilers/native/cpu */ "../../node_modules/dd-trace/packages/dd-trace/src/profiling/profilers/native/cpu.js")
const { NativeHeapProfiler } = __webpack_require__(/*! ./profilers/native/heap */ "../../node_modules/dd-trace/packages/dd-trace/src/profiling/profilers/native/heap.js")
const { AgentExporter } = __webpack_require__(/*! ./exporters/agent */ "../../node_modules/dd-trace/packages/dd-trace/src/profiling/exporters/agent.js")
const { FileExporter } = __webpack_require__(/*! ./exporters/file */ "../../node_modules/dd-trace/packages/dd-trace/src/profiling/exporters/file.js")
const { ConsoleLogger } = __webpack_require__(/*! ./loggers/console */ "../../node_modules/dd-trace/packages/dd-trace/src/profiling/loggers/console.js")

const profiler = new Profiler()

module.exports = {
  profiler,
  AgentExporter,
  FileExporter,
  InspectorCpuProfiler,
  InspectorHeapProfiler,
  NativeCpuProfiler,
  NativeHeapProfiler,
  ConsoleLogger
}


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/profiling/mapper.js":
/*!**********************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/profiling/mapper.js ***!
  \**********************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// TODO: use sourceRoot when set, possibly from source-map-resolve

const fs = __webpack_require__(/*! fs */ "fs")
const { SourceMapConsumer } = __webpack_require__(/*! source-map */ "../../node_modules/dd-trace/node_modules/source-map/source-map.js")
const sourceMapResolve = __webpack_require__(/*! source-map-resolve */ "../../node_modules/source-map-resolve/index.js")
const { fileURLToPath, pathToFileURL } = __webpack_require__(/*! url */ "url")

class SourceMapper {
  constructor () {
    this._consumers = Object.create(null)
    this._sources = Object.create(null)
  }

  async getSource (callFrame) {
    const { url, lineNumber, columnNumber, functionName } = callFrame
    const key = `${url}:${functionName}:${lineNumber}:${columnNumber}`

    if (!this._sources[key]) {
      this._sources[key] = await this._getMapping(callFrame)
    }

    return this._sources[key]
  }

  async _getConsumer (url) {
    if (this._consumers[url] === undefined) {
      this._consumers[url] = this._createConsumer(url)
    }

    return this._consumers[url]
  }

  async _createConsumer (url) {
    try {
      const map = await this._resolve(url)

      return map ? new SourceMapConsumer(map) : null
    } catch (e) {
      return null
    }
  }

  async _getMapping (callFrame) {
    const { url, functionName, lineNumber, columnNumber } = callFrame

    // Runtime.CallFrame is 0-based for both line and column numbers.
    // When the line or column number is not known the value is -1.
    // https://chromedevtools.github.io/devtools-protocol/v8/Runtime/#type-CallFrame
    if (lineNumber < 0 || columnNumber < 0) return callFrame

    const consumer = await this._getConsumer(url)

    if (!consumer) return callFrame

    // SourceMapConsumer is 1-based for lines and 0-based for columns
    // https://github.com/mozilla/source-map/blob/0.7.3/lib/source-map-consumer.js#L464-L487
    const map = consumer.originalPositionFor({
      line: lineNumber + 1,
      column: columnNumber
    })

    if (!map || !map.source || !map.line) return callFrame

    return {
      url: pathToFileURL(map.source).href,
      lineNumber: map.line - 1, // reset to 0-based from 1-based
      columnNumber: map.column !== null ? map.column : -1,
      functionName: map.name || functionName
    }
  }

  async _resolve (url) {
    const filename = fileURLToPath(url)
    const code = (await fs.promises.readFile(filename)).toString()

    return new Promise((resolve, reject) => {
      sourceMapResolve.resolve(code, filename, fs.readFile, (error, result) => {
        if (!result || error) return resolve(null)

        result.map.sourcesContent = result.sourcesContent
        result.map.sources = result.sourcesResolved

        resolve(result.map)
      })
    })
  }
}

module.exports = { SourceMapper }


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/profiling/profile.js":
/*!***********************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/profiling/profile.js ***!
  \***********************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const { perftools } = __webpack_require__(/*! ../../../../protobuf/profile */ "../../node_modules/dd-trace/protobuf/profile.js")

class Profile {
  constructor (sampleType, periodType, period) {
    this._stringTable = new Map([['', 0]])
    this._locations = new Map()
    this._functions = new Map()
    this._samples = new Map()
    this._links = new Map()
    this._sampleType = this._toSampleType(sampleType)
    this._periodType = this._toValueType(periodType)
    this._period = period
    this._timeNanos = Date.now() * 1e6
    this._properties = {}
  }

  export () {
    return new perftools.profiles.Profile({
      sampleType: this._sampleType,
      periodType: this._periodType,
      sample: Array.from(this._samples.values()),
      location: Array.from(this._locations.values()),
      function: Array.from(this._functions.values()),
      stringTable: Array.from(this._stringTable.keys()),
      timeNanos: this._timeNanos,
      durationNanos: this._durationNanos,
      period: this._period
    })
  }

  addDuration (nanoseconds) {
    this._durationNanos = nanoseconds
  }

  addString (value) {
    let idx = this._stringTable.get(value)

    if (idx === undefined) {
      idx = this._stringTable.size
      this._stringTable.set(value, idx)
    }

    return idx
  }

  addFunction (functionName, url) {
    const key = `${url}:${functionName}`

    let fn = this._functions.get(key)

    if (!fn) {
      const filename = this.addString(url)
      const name = this.addString(functionName || '(anonymous)')

      fn = new perftools.profiles.Function({
        filename,
        systemName: name,
        id: this._functions.size + 1,
        name
      })

      this._functions.set(key, fn)
    }

    return fn
  }

  // TODO: compute location id
  addLocation (functionId, locationId, lineNumber) {
    const location = new perftools.profiles.Location({
      id: locationId,
      line: [
        new perftools.profiles.Line({
          functionId,
          line: lineNumber + 1 // Runtime.CallFrame is 0-based
        })
      ]
    })

    this._locations.set(locationId, location)

    return location
  }

  addSample (locationId, values) {
    let sample = this._samples.get(locationId)

    if (!sample) {
      const locationIds = []

      let link = locationId

      do {
        locationIds.push(link)
      } while ((link = this._links.get(link)))

      sample = new perftools.profiles.Sample({
        locationId: locationIds,
        value: values
      })

      this._samples.set(locationId, sample)
    } else {
      for (let i = 0; i < values.length; i++) {
        sample.value[i] += values[i]
      }
    }

    return sample
  }

  addLink (locationId, childId) {
    this._links.set(childId, locationId)
  }

  _toSampleType (tuples) {
    return tuples.map(tuple => this._toValueType(tuple))
  }

  _toValueType (tuple) {
    return {
      type: this.addString(tuple[0]),
      unit: this.addString(tuple[1])
    }
  }
}

module.exports = { Profile }


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/profiling/profiler.js":
/*!************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/profiling/profiler.js ***!
  \************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const semver = __webpack_require__(/*! semver */ "../../node_modules/dd-trace/node_modules/semver/semver.js")
const { EventEmitter } = __webpack_require__(/*! events */ "events")
const { Config } = __webpack_require__(/*! ./config */ "../../node_modules/dd-trace/packages/dd-trace/src/profiling/config.js")
const { SourceMapper } = __webpack_require__(/*! ./mapper */ "../../node_modules/dd-trace/packages/dd-trace/src/profiling/mapper.js")
const { eachSeries } = __webpack_require__(/*! ./util */ "../../node_modules/dd-trace/packages/dd-trace/src/profiling/util.js")

class Profiler extends EventEmitter {
  start (options) {
    if (this._enabled) return

    const config = this._config = new Config(options)

    if (!config.enabled) return

    this._logger = config.logger

    if (!semver.satisfies(process.version, '>=10.12')) {
      this._logger.error('Profiling could not be started because it requires Node >=10.12')
      return this
    }

    this._enabled = true

    try {
      const mapper = config.sourceMap ? new SourceMapper() : null

      for (const profiler of config.profilers) {
        profiler.start({ mapper }) // TODO: move this outside of profilers
      }
    } catch (e) {
      this._logger.error(e)
      this.stop()
    }

    this._capture(config.flushInterval)

    return this
  }

  stop () {
    if (!this._enabled) return

    this._enabled = false

    for (const profiler of this._config.profilers) {
      profiler.stop()
    }

    clearTimeout(this._timer)

    return this
  }

  _capture (timeout) {
    const start = new Date()

    this._timer = setTimeout(() => this._collect(start), timeout)
    this._timer.unref()
  }

  _collect (start) {
    const end = new Date()
    const profiles = {}

    eachSeries(this._config.profilers, (profiler, callback) => {
      profiler.profile((err, profile) => {
        if (err) return callback(err)

        profiles[profiler.type] = profile

        callback(err, profile)
      })
    }, err => {
      if (err) {
        this._logger.error(err)
        this.stop()
      } else {
        this._capture(this._config.flushInterval)
        this._submit(profiles, start, end)
      }
    })
  }

  _submit (profiles, start, end) {
    const { tags } = this._config

    for (const exporter of this._config.exporters) {
      exporter.export({ profiles, start, end, tags }, err => {
        if (err) {
          this._logger.error(err)
        }
      })
    }
  }
}

module.exports = { Profiler }


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/profiling/profilers/cpu.js":
false,

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/profiling/profilers/heap.js":
false,

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/profiling/profilers/inspector/cpu.js":
/*!***************************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/profiling/profilers/inspector/cpu.js ***!
  \***************************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const { Profile } = __webpack_require__(/*! ../../profile */ "../../node_modules/dd-trace/packages/dd-trace/src/profiling/profile.js")

class InspectorCpuProfiler {
  constructor (options = {}) {
    this.type = 'wall'
    this._samplingInterval = options.samplingInterval || 10 * 1000
  }

  start ({ mapper }) {
    const { Session } = __webpack_require__(/*! inspector */ "inspector")

    this._mapper = mapper

    this._session = new Session()
    this._session.connect()
    this._session.post('Profiler.enable')
    this._session.post('Profiler.setSamplingInterval', {
      interval: this._samplingInterval
    })
    this._session.post('Profiler.start')
  }

  stop () {
    this._session.post('Profiler.stop')
    this._session.post('Profiler.disable')
    this._session.disconnect()
    this._session = null

    this._mapper = null
  }

  profile (callback) {
    this._session.post('Profiler.stop', (err, params) => {
      if (err) return callback(err)

      this._session.post('Profiler.start')

      this._serialize(params.profile, callback)
    })
  }

  _serialize ({ startTime, endTime, nodes, samples, timeDeltas }, callback) {
    const sampleType = [['sample', 'count'], ['wall', 'microseconds']]
    const periodType = ['wall', 'microseconds']
    const period = this._samplingInterval
    const profile = new Profile(sampleType, periodType, period)
    const skippedLocationIds = new Set()

    profile.addDuration((endTime - startTime) * 1000)

    for (const node of nodes) {
      // pprof has implicit root so skip root
      if (node.callFrame.functionName === '(root)') continue

      const { id, children, callFrame } = node
      const { functionName, url, lineNumber } = callFrame // TODO: support source maps
      const functionId = profile.addFunction(functionName, url).id
      const locationId = profile.addLocation(functionId, id, lineNumber).id

      // skip redundant samples that are handled by pprof and/or the backend
      if (functionName === '(program)' || functionName === '(idle)') {
        skippedLocationIds.add(locationId)
      }

      if (children) {
        for (const childId of children) {
          profile.addLink(locationId, childId)
        }
      }
    }

    for (let i = 0; i < samples.length; i++) {
      if (skippedLocationIds.has(samples[i])) continue

      profile.addSample(samples[i], [1, timeDeltas[i]])
    }

    callback(null, profile.export())
  }
}

module.exports = { InspectorCpuProfiler }


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/profiling/profilers/inspector/heap.js":
/*!****************************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/profiling/profilers/inspector/heap.js ***!
  \****************************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const { Profile } = __webpack_require__(/*! ../../profile */ "../../node_modules/dd-trace/packages/dd-trace/src/profiling/profile.js")

class InspectorHeapProfiler {
  constructor (options = {}) {
    this.type = 'space'
    this._samplingInterval = options.samplingInterval || 512 * 1024
  }

  start ({ mapper }) {
    const { Session } = __webpack_require__(/*! inspector */ "inspector")

    this._mapper = mapper

    this._session = new Session()
    this._session.connect()
    this._session.post('HeapProfiler.enable')
    this._session.post('HeapProfiler.startSampling', {
      samplingInterval: this._samplingInterval
    })
  }

  stop () {
    this._session.post('HeapProfiler.stopSampling')
    this._session.post('HeapProfiler.disable')
    this._session.disconnect()
    this._session = null

    this._mapper = null
  }

  profile (callback) {
    this._session.post('HeapProfiler.getSamplingProfile', (err, params) => {
      if (err) return callback(err)

      this._serialize(params.profile, callback)
    })
  }

  _serialize ({ head, samples }, callback) {
    const sampleType = [['space', 'bytes']]
    const periodType = ['space', 'bytes']
    const period = this._samplingInterval
    const profile = new Profile(sampleType, periodType, period)
    const nodes = head.children.slice() // pprof has implicit root so skip root

    let node

    while ((node = nodes.shift())) {
      const { id, selfSize, callFrame, children } = node
      const { functionName, url, lineNumber } = callFrame // TODO: support source maps
      const functionId = profile.addFunction(functionName, url).id
      const locationId = profile.addLocation(functionId, id, lineNumber).id

      if (children) {
        for (const child of children) {
          nodes.push(child)
          profile.addLink(locationId, child.id)
        }
      }

      if (selfSize) {
        profile.addSample(locationId, [selfSize])
      }
    }

    callback(null, profile.export())
  }
}

module.exports = { InspectorHeapProfiler }


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/profiling/profilers/native/cpu.js":
/*!************************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/profiling/profilers/native/cpu.js ***!
  \************************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const { maybeRequire } = __webpack_require__(/*! ../../util */ "../../node_modules/dd-trace/packages/dd-trace/src/profiling/util.js")

class NativeCpuProfiler {
  constructor (options = {}) {
    this.type = 'wall'
    this._pprof = maybeRequire('pprof')
    this._samplingInterval = options.samplingInterval || 10 * 1000
  }

  start () {
    // pprof otherwise crashes in worker threads
    if (!process._startProfilerIdleNotifier) {
      process._startProfilerIdleNotifier = () => {}
    }

    this._record()
  }

  profile () {
    const profile = this._stop()

    this._record()

    return profile
  }

  stop () {
    this._stop()
  }

  _record () {
    this._stop = this._pprof.time.start(this._samplingInterval)
  }
}

module.exports = { NativeCpuProfiler }


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/profiling/profilers/native/heap.js":
/*!*************************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/profiling/profilers/native/heap.js ***!
  \*************************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const { maybeRequire } = __webpack_require__(/*! ../../util */ "../../node_modules/dd-trace/packages/dd-trace/src/profiling/util.js")

class NativeHeapProfiler {
  constructor (options = {}) {
    this.type = 'space'
    this._pprof = maybeRequire('pprof')
    this._samplingInterval = options.samplingInterval || 512 * 1024
    this._stackDepth = options.stackDepth || 64
  }

  start () {
    this._pprof.heap.start(this._samplingInterval, this._stackDepth)
  }

  profile () {
    return this._pprof.heap.profile()
  }

  stop () {
    this._pprof.heap.stop()
  }
}

module.exports = { NativeHeapProfiler }


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/profiling/tagger.js":
/*!**********************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/profiling/tagger.js ***!
  \**********************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const tagger = {
  parse (tags) {
    if (!tags) return {}

    switch (typeof tags) {
      case 'object':
        if (Array.isArray(tags)) {
          return tags.reduce((prev, next) => {
            const parts = next.split(':')
            const key = parts.shift()
            const value = parts.join(':')

            if (!key || !value) return prev

            return Object.assign(prev, { [key]: value })
          }, {})
        } else {
          return tagger.parse(Object.keys(tags)
            .filter(key => tags[key] !== undefined && tags[key] !== null)
            .map(key => `${key}:${tags[key]}`))
        }
      case 'string':
        return tagger.parse(tags.split(','))
      default:
        return {}
    }
  }
}

module.exports = { tagger }


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/profiling/util.js":
/*!********************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/profiling/util.js ***!
  \********************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function maybeRequire (id) {
  try {
    return __webpack_require__("../../node_modules/dd-trace/packages/dd-trace/src/profiling sync recursive")(id)
  } catch (e) {
    return null
  }
}

function eachSeries (collection, iteratee, callback) {
  eachOfSeries(collection, (item, index, callback) => iteratee(item, callback), callback)
}

function eachOfSeries (collection, iteratee, callback = () => {}) {
  const results = new Array(collection.length)
  const next = index => {
    if (collection[index]) {
      iteratee(collection[index], index, (err, result) => {
        if (err) return callback(err)

        results[index] = result

        next(index + 1)
      })
    } else {
      callback(null, results)
    }
  }

  next(0)
}

function parallel (tasks, callback) {
  const results = new Array(tasks.length)

  let counter = 0
  let failing = false

  for (let i = 0; i < tasks.length; i++) {
    const taskIndex = i

    tasks[taskIndex]((err, result) => {
      if (failing) return
      if (err) {
        failing = true
        return callback(err)
      }

      results[taskIndex] = result

      if (++counter === tasks.length) {
        callback(null, results)
      }
    })
  }
}

module.exports = {
  maybeRequire,
  parallel,
  eachSeries,
  eachOfSeries
}


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/proxy.js":
/*!***********************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/proxy.js ***!
  \***********************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const BaseTracer = __webpack_require__(/*! opentracing */ "../../node_modules/opentracing/lib/index.js").Tracer
const NoopTracer = __webpack_require__(/*! ./noop/tracer */ "../../node_modules/dd-trace/packages/dd-trace/src/noop/tracer.js")
const DatadogTracer = __webpack_require__(/*! ./tracer */ "../../node_modules/dd-trace/packages/dd-trace/src/tracer.js")
const Config = __webpack_require__(/*! ./config */ "../../node_modules/dd-trace/packages/dd-trace/src/config.js")
const Instrumenter = __webpack_require__(/*! ./instrumenter */ "../../node_modules/dd-trace/packages/dd-trace/src/instrumenter.js")
const platform = __webpack_require__(/*! ./platform */ "../../node_modules/dd-trace/packages/dd-trace/src/platform/index.js")
const log = __webpack_require__(/*! ./log */ "../../node_modules/dd-trace/packages/dd-trace/src/log.js")
const { setStartupLogInstrumenter } = platform.startupLog
const analyticsSampler = __webpack_require__(/*! ./analytics_sampler */ "../../node_modules/dd-trace/packages/dd-trace/src/analytics_sampler.js")

const noop = new NoopTracer()

class Tracer extends BaseTracer {
  constructor () {
    super()
    this._tracer = noop
    this._instrumenter = new Instrumenter(this)
    this._deprecate = method => log.deprecate(`tracer.${method}`, [
      `tracer.${method}() is deprecated.`,
      'Please use tracer.startSpan() and tracer.scope() instead.',
      'See: https://datadog.github.io/dd-trace-js/#manual-instrumentation.'
    ].join(' '))
  }

  init (options) {
    if (this._tracer === noop) {
      try {
        const config = new Config(options)

        log.use(config.logger)
        log.toggle(config.debug, config.logLevel, this)

        platform.configure(config)
        platform.profiler().start()

        if (config.enabled) {
          platform.validate()

          if (config.runtimeMetrics) {
            platform.metrics().start()
          }

          if (config.analytics) {
            analyticsSampler.enable()
          }

          this._tracer = new DatadogTracer(config)
          this._instrumenter.enable(config)
          setStartupLogInstrumenter(this._instrumenter)
        }
      } catch (e) {
        log.error(e)
      }
    }

    return this
  }

  use () {
    this._instrumenter.use.apply(this._instrumenter, arguments)
    return this
  }

  trace (name, options, fn) {
    if (!fn) {
      fn = options
      options = {}
    }

    if (typeof fn !== 'function') return

    options = options || {}

    return this._tracer.trace(name, options, fn)
  }

  wrap (name, options, fn) {
    if (!fn) {
      fn = options
      options = {}
    }

    if (typeof fn !== 'function') return fn

    options = options || {}

    return this._tracer.wrap(name, options, fn)
  }

  setUrl () {
    this._tracer.setUrl.apply(this._tracer, arguments)
    return this
  }

  startSpan () {
    return this._tracer.startSpan.apply(this._tracer, arguments)
  }

  inject () {
    return this._tracer.inject.apply(this._tracer, arguments)
  }

  extract () {
    return this._tracer.extract.apply(this._tracer, arguments)
  }

  scopeManager () {
    this._deprecate('scopeManager')
    return this._tracer.scopeManager.apply(this._tracer, arguments)
  }

  scope () {
    return this._tracer.scope.apply(this._tracer, arguments)
  }

  currentSpan () {
    this._deprecate('currentSpan')
    return this._tracer.currentSpan.apply(this._tracer, arguments)
  }

  bind (callback) {
    this._deprecate('bind')
    return callback
  }

  bindEmitter () {
    this._deprecate('bindEmitter')
  }

  getRumData () {
    return this._tracer.getRumData.apply(this._tracer, arguments)
  }
}

module.exports = Tracer


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/require-package-json.js":
false,

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/ritm.js":
false,

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/scope.js":
false,

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/scope/async_hooks.js":
/*!***********************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/scope/async_hooks.js ***!
  \***********************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const asyncHooks = __webpack_require__(/*! async_hooks */ "async_hooks")
const Base = __webpack_require__(/*! ./base */ "../../node_modules/dd-trace/packages/dd-trace/src/scope/base.js")
const platform = __webpack_require__(/*! ../platform */ "../../node_modules/dd-trace/packages/dd-trace/src/platform/index.js")
const semver = __webpack_require__(/*! semver */ "../../node_modules/dd-trace/node_modules/semver/semver.js")

// https://github.com/nodejs/node/issues/19859
const hasKeepAliveBug = !semver.satisfies(process.version, '^8.13 || >=10.14.2')

// fixed in https://github.com/nodejs/node/pull/33801
const hasThenableBug = !semver.satisfies(process.version, '>=14.5 || ^12.19.0')

let singleton = null

class Scope extends Base {
  constructor (config) {
    if (singleton) return singleton

    super()

    singleton = this

    this._trackAsyncScope = config.trackAsyncScope && hasThenableBug
    this._debug = config.debug
    this._current = null
    this._spans = new Map()
    this._types = new Map()
    this._weaks = new WeakMap()
    this._promises = [false]
    this._stack = []
    this._depth = 0
    this._hook = asyncHooks.createHook({
      init: this._init.bind(this),
      before: this._before.bind(this),
      after: this._after.bind(this),
      destroy: this._destroy.bind(this)
    })

    this._enabled = true
    this._hook.enable()
  }

  _active () {
    return this._current
  }

  _activate (span, callback) {
    const active = this._active()

    this._enter(span)

    try {
      return callback()
    } finally {
      this._exit(active)
    }
  }

  _enter (span) {
    this._depth++
    this._stack[this._depth] = this._current
    this._current = span
    this._promises[this._depth] = false
  }

  _exit (span) {
    this._trackAsyncScope && this._await(span)
    this._current = span
    this._stack[this._depth] = null
    this._depth--
  }

  _exitNative () {
    this._current = null
    this._promises[0] = false
  }

  _await (span) {
    if (!this._promises[this._depth]) return

    this._enabled = false
    this._awaitAsync(span)
    this._enabled = true
  }

  // https://github.com/nodejs/node/issues/22360
  async _awaitAsync (span) {
    await {
      then: (resolve) => {
        this._current = span
        resolve()
      }
    }
  }

  _initPromise () {
    if (!this._promises[this._depth]) {
      this._promises[this._depth] = true
      this._await(this._current)
    }
  }

  _init (asyncId, type, triggerAsyncId, resource) {
    if (!this._enabled) return

    this._spans.set(asyncId, this._current)
    this._types.set(asyncId, type)

    if (hasKeepAliveBug && (type === 'TCPWRAP' || type === 'HTTPPARSER')) {
      this._destroy(this._weaks.get(resource))
      this._weaks.set(resource, asyncId)
    }

    if (this._debug) {
      const metrics = platform.metrics()
      metrics.increment('runtime.node.async.resources')
      metrics.increment('runtime.node.async.resources.by.type', `resource_type:${type}`)
    }

    if (this._trackAsyncScope && type === 'PROMISE') {
      this._initPromise()
    }
  }

  _before (asyncId) {
    this._depth === 0 && this._exitNative()
    this._enter(this._spans.get(asyncId))
  }

  _after () {
    this._exit(this._stack[this._depth])
  }

  _destroy (asyncId) {
    const type = this._types.get(asyncId)

    if (type && this._debug) {
      const metrics = platform.metrics()
      metrics.decrement('runtime.node.async.resources')
      metrics.decrement('runtime.node.async.resources.by.type', `resource_type:${type}`)
    }

    this._spans.delete(asyncId)
    this._types.delete(asyncId)
  }
}

module.exports = Scope


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/scope/async_local_storage.js":
/*!*******************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/scope/async_local_storage.js ***!
  \*******************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const { AsyncLocalStorage } = __webpack_require__(/*! async_hooks */ "async_hooks")
const Base = __webpack_require__(/*! ./base */ "../../node_modules/dd-trace/packages/dd-trace/src/scope/base.js")

let singleton = null

class Scope extends Base {
  constructor () {
    if (singleton) return singleton

    super()

    singleton = this

    this._storage = new AsyncLocalStorage()
  }

  _active () {
    const store = this._storage.getStore()
    return typeof store === 'undefined' ? null : store
  }

  _activate (span, callback) {
    return this._storage.run(span, callback)
  }
}

module.exports = Scope


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/scope/async_resource.js":
/*!**************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/scope/async_resource.js ***!
  \**************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const { createHook, executionAsyncResource } = __webpack_require__(/*! async_hooks */ "async_hooks")
const Base = __webpack_require__(/*! ./base */ "../../node_modules/dd-trace/packages/dd-trace/src/scope/base.js")

class Scope extends Base {
  constructor (config) {
    super()

    this._ddResourceStore = Symbol('ddResourceStore')
    this._config = config
    this._stack = []
    this._hook = createHook({
      init: this._init.bind(this)
    })

    this.enable()
  }

  enable () {
    this._enabled = true
    this._hook.enable()
  }

  disable () {
    this._enabled = false
    this._stack = []
    this._hook.disable()
  }

  _active () {
    if (!this._enabled) return null

    const resource = executionAsyncResource()

    return resource[this._ddResourceStore] || null
  }

  _activate (span, callback) {
    if (!this._enabled) return callback()

    const resource = executionAsyncResource()

    this._enter(span, resource)

    try {
      return callback()
    } finally {
      this._exit(resource)
    }
  }

  _enter (span, resource) {
    this._stack.push(resource[this._ddResourceStore])
    resource[this._ddResourceStore] = span
  }

  _exit (resource) {
    resource[this._ddResourceStore] = this._stack.pop()
  }

  _init (asyncId, type, triggerAsyncId, resource) {
    const triggerResource = executionAsyncResource()
    const span = triggerResource[this._ddResourceStore]

    if (span) {
      resource[this._ddResourceStore] = span
    }
  }
}

module.exports = Scope


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/scope/base.js":
/*!****************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/scope/base.js ***!
  \****************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


class Scope {
  active () {
    return this._active() || null
  }

  activate (span, callback) {
    if (typeof callback !== 'function') return callback

    try {
      return this._activate(span, callback)
    } catch (e) {
      if (span && typeof span.setTag === 'function') {
        span.setTag('error', e)
      }

      throw e
    }
  }

  bind (target, span) {
    target = this._bindEmitter(target, span)
    target = this._bindPromise(target, span)
    target = this._bindFn(target, span)

    return target
  }

  unbind (target) {
    target = this._unbindFn(target)
    target = this._unbindPromise(target)
    target = this._unbindEmitter(target)

    return target
  }

  _active () {
    return null
  }

  _activate (span, callback) {
    return callback()
  }

  _bindFn (fn, span) {
    if (typeof fn !== 'function') return fn

    const scope = this
    const spanOrActive = this._spanOrActive(span)

    const bound = function () {
      return scope.activate(spanOrActive, () => {
        return fn.apply(this, arguments)
      })
    }

    bound._datadog_unbound = fn

    return bound
  }

  _unbindFn (fn) {
    if (typeof fn !== 'function') return fn

    return fn._datadog_unbound || fn
  }

  _bindEmitter (emitter, span) {
    if (!this._isEmitter(emitter)) return emitter
    if (!emitter.__is_dd_emitter) {
      Scope._wrapEmitter(emitter)
    }
    emitter.__dd_span = span
    emitter.__dd_scope = this
    return emitter
  }

  // Occasionally we want to wrap a prototype rather than emitter instances,
  // so we're exposing this as a static method. This gives us a faster
  // path for binding instances of known EventEmitter subclasses.
  static _wrapEmitter (emitter) {
    wrapMethod(emitter, 'addListener', wrapAddListener)
    wrapMethod(emitter, 'prependListener', wrapAddListener)
    wrapMethod(emitter, 'on', wrapAddListener)
    wrapMethod(emitter, 'once', wrapAddListener)
    wrapMethod(emitter, 'removeListener', wrapRemoveListener)
    wrapMethod(emitter, 'off', wrapRemoveListener)
    wrapMethod(emitter, 'removeAllListeners', wrapRemoveAllListeners)
    emitter.__is_dd_emitter = true
  }

  _unbindEmitter (emitter) {
    if (!this._isEmitter(emitter)) return emitter
    delete emitter.__dd_scope
    delete emitter.__dd_span
    return emitter
  }

  _bindPromise (promise, span) {
    if (!this._isPromise(promise)) return promise

    wrapMethod(promise, 'then', wrapThen, this, span)

    return promise
  }

  _unbindPromise (promise) {
    if (!this._isPromise(promise)) return promise

    promise.then = promise.then._datadog_unbound || promise.then

    return promise
  }

  _spanOrActive (span) {
    return span !== undefined ? span : this.active()
  }

  _isEmitter (emitter) {
    return emitter &&
      typeof emitter.emit === 'function' &&
      typeof emitter.on === 'function' &&
      typeof emitter.addListener === 'function' &&
      typeof emitter.removeListener === 'function'
  }

  _isPromise (promise) {
    return promise && typeof promise.then === 'function'
  }
}

function wrapThen (then, scope, span) {
  return function thenWithTrace (onFulfilled, onRejected) {
    const args = new Array(arguments.length)

    for (let i = 0, l = args.length; i < l; i++) {
      args[i] = scope.bind(arguments[i], span)
    }

    return then.apply(this, args)
  }
}

function wrapAddListener (addListener) {
  return function addListenerWithTrace (eventName, listener) {
    if (!this.__dd_scope || !listener || listener._datadog_unbound || listener.listener) {
      return addListener.apply(this, arguments)
    }
    const scope = this.__dd_scope
    const span = this.__dd_span

    const bound = scope.bind(listener, scope._spanOrActive(span))

    this._datadog_events = this._datadog_events || {}

    if (!this._datadog_events[eventName]) {
      this._datadog_events[eventName] = new WeakMap()
    }

    const events = this._datadog_events[eventName]

    if (!events.has(listener)) {
      events.set(listener, [])
    }

    events.get(listener).push(bound)

    return addListener.call(this, eventName, bound)
  }
}

function wrapRemoveListener (removeListener) {
  return function removeListenerWithTrace (eventName, listener) {
    if (!this.__dd_scope) {
      return removeListener.apply(this, arguments)
    }

    const listeners = this._datadog_events && this._datadog_events[eventName]

    if (!listener || !listeners || !listeners.has(listener)) {
      return removeListener.apply(this, arguments)
    }

    for (const bound of listeners.get(listener)) {
      removeListener.call(this, eventName, bound)
    }

    listeners.delete(listener)

    return removeListener.call(this, eventName, listener)
  }
}

function wrapRemoveAllListeners (removeAllListeners) {
  return function removeAllListenersWithTrace (eventName) {
    if (this.__dd_scope && this._datadog_events) {
      if (eventName) {
        delete this._datadog_events[eventName]
      } else {
        delete this._datadog_events
      }
    }

    return removeAllListeners.call(this, eventName)
  }
}

function wrapMethod (target, name, wrapper, ...args) {
  if (!target[name] || target[name]._datadog_unbound) return

  const original = target[name]

  target[name] = wrapper(target[name], ...args)
  target[name]._datadog_unbound = original
}

module.exports = Scope


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/scope/noop/scope.js":
/*!**********************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/scope/noop/scope.js ***!
  \**********************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


class Scope {
  constructor (span, finishSpanOnClose) {
    this._span = span
    this._finishSpanOnClose = finishSpanOnClose
    this.close()
  }

  span () {
    return this._span
  }

  close () {
    if (this._finishSpanOnClose) {
      this._span.finish()
    }
  }
}

module.exports = Scope


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/scope/noop/scope_manager.js":
/*!******************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/scope/noop/scope_manager.js ***!
  \******************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Span = __webpack_require__(/*! opentracing */ "../../node_modules/opentracing/lib/index.js").Span
const Scope = __webpack_require__(/*! ./scope */ "../../node_modules/dd-trace/packages/dd-trace/src/scope/noop/scope.js")

let singleton = null

const span = new Span()

class ScopeManager {
  constructor () {
    if (!singleton) {
      singleton = this
    }

    return singleton
  }

  active () {
    return new Scope(span)
  }

  activate (span, finishSpanOnClose) {
    return new Scope(span, finishSpanOnClose)
  }
}

module.exports = ScopeManager


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/scope/scope_manager.js":
/*!*************************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/scope/scope_manager.js ***!
  \*************************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const ScopeManager = __webpack_require__(/*! ./noop/scope_manager */ "../../node_modules/dd-trace/packages/dd-trace/src/scope/noop/scope_manager.js")

module.exports = ScopeManager


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/span_processor.js":
/*!********************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/span_processor.js ***!
  \********************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

const log = __webpack_require__(/*! ./log */ "../../node_modules/dd-trace/packages/dd-trace/src/log.js")
const format = __webpack_require__(/*! ./format */ "../../node_modules/dd-trace/packages/dd-trace/src/format.js")

class SpanProcessor {
  constructor (exporter, prioritySampler) {
    this._exporter = exporter
    this._prioritySampler = prioritySampler
  }

  process (span) {
    const spanContext = span.context()
    const trace = spanContext._trace

    if (trace.started.length === trace.finished.length) {
      this._prioritySampler.sample(spanContext)

      if (spanContext._traceFlags.sampled === false) {
        log.debug(() => `Dropping trace due to user configured filtering: ${trace.started}`)
        this._erase(trace)
        return
      }

      const formattedSpans = trace.finished.map(format)
      this._exporter.export(formattedSpans)
      this._erase(trace)
    }
  }

  _erase (trace) {
    trace.finished.forEach(span => {
      span.context()._tags = {}
    })

    trace.started = []
    trace.finished = []
  }
}

module.exports = SpanProcessor


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/startup-log.js":
false,

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/tagger.js":
/*!************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/tagger.js ***!
  \************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const log = __webpack_require__(/*! ./log */ "../../node_modules/dd-trace/packages/dd-trace/src/log.js")

function add (carrier, keyValuePairs) {
  if (!carrier || !keyValuePairs) return

  if (typeof keyValuePairs === 'string') {
    return add(
      carrier,
      keyValuePairs
        .split(',')
        .filter(tag => tag.indexOf(':') !== -1)
        .reduce((prev, next) => {
          const tag = next.split(':')
          const key = tag[0]
          const value = tag.slice(1).join(':')

          prev[key] = value

          return prev
        }, {})
    )
  }

  if (Array.isArray(keyValuePairs)) {
    return keyValuePairs.forEach(tags => add(carrier, tags))
  }

  try {
    Object.keys(keyValuePairs).forEach(key => {
      carrier[key] = keyValuePairs[key]
    })
  } catch (e) {
    log.error(e)
  }
}

module.exports = { add }


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/telemetry.js":
false,

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/tracer.js":
/*!************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/tracer.js ***!
  \************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Tracer = __webpack_require__(/*! ./opentracing/tracer */ "../../node_modules/dd-trace/packages/dd-trace/src/opentracing/tracer.js")
const tags = __webpack_require__(/*! ../../../ext/tags */ "../../node_modules/dd-trace/ext/tags.js")
const scopes = __webpack_require__(/*! ../../../ext/scopes */ "../../node_modules/dd-trace/ext/scopes.js")
const platform = __webpack_require__(/*! ./platform */ "../../node_modules/dd-trace/packages/dd-trace/src/platform/index.js")
const { setStartupLogConfig } = platform.startupLog

const SPAN_TYPE = tags.SPAN_TYPE
const RESOURCE_NAME = tags.RESOURCE_NAME
const SERVICE_NAME = tags.SERVICE_NAME
const ANALYTICS = tags.ANALYTICS
const NOOP = scopes.NOOP

class DatadogTracer extends Tracer {
  constructor (config) {
    super(config)

    this._scopeManager = getScopeManager(config)
    this._scope = getScope(config)
    setStartupLogConfig(config)
  }

  trace (name, options, fn) {
    options = Object.assign({}, {
      childOf: this.scope().active()
    }, options)

    if (!options.childOf && options.orphanable === false) {
      return fn(null, () => {})
    }

    const span = this.startSpan(name, options)

    addTags(span, options)

    try {
      if (fn.length > 1) {
        return this.scope().activate(span, () => fn(span, err => {
          addError(span, err)
          span.finish()
        }))
      }

      const result = this.scope().activate(span, () => fn(span))

      if (result && typeof result.then === 'function') {
        result.then(
          () => span.finish(),
          err => {
            addError(span, err)
            span.finish()
          }
        )
      } else {
        span.finish()
      }

      return result
    } catch (e) {
      addError(span, e)
      span.finish()
      throw e
    }
  }

  wrap (name, options, fn) {
    const tracer = this

    return function () {
      if (typeof options === 'function' && typeof fn === 'function') {
        options = options.apply(this, arguments)
      }

      if (options.orphanable === false && !tracer.scope().active()) {
        return fn.apply(this, arguments)
      }

      const lastArgId = arguments.length - 1
      const cb = arguments[lastArgId]

      if (typeof cb === 'function') {
        const scopeBoundCb = tracer.scope().bind(cb)
        return tracer.trace(name, options, (span, done) => {
          arguments[lastArgId] = function (err) {
            done(err)
            return scopeBoundCb.apply(this, arguments)
          }

          return fn.apply(this, arguments)
        })
      } else {
        return tracer.trace(name, options, () => fn.apply(this, arguments))
      }
    }
  }

  setUrl (url) {
    this._exporter.setUrl(url)
  }

  scopeManager () {
    return this._scopeManager
  }

  scope () {
    return this._scope
  }

  currentSpan () {
    return this.scope().active()
  }

  getRumData () {
    if (!this._enableGetRumData) {
      return ''
    }
    const span = this.scope().active().context()
    const traceId = span.toTraceId()
    const traceTime = Date.now()
    return `\
<meta name="dd-trace-id" content="${traceId}" />\
<meta name="dd-trace-time" content="${traceTime}" />`
  }
}

function addError (span, error) {
  if (error && error instanceof Error) {
    span.addTags({
      'error.type': error.name,
      'error.msg': error.message,
      'error.stack': error.stack
    })
  }
}

function addTags (span, options) {
  const tags = {}

  if (options.type) tags[SPAN_TYPE] = options.type
  if (options.service) tags[SERVICE_NAME] = options.service
  if (options.resource) tags[RESOURCE_NAME] = options.resource

  tags[ANALYTICS] = options.analytics

  span.addTags(tags)
}

function getScopeManager (config) {
  let ScopeManager

  if (config.scope === NOOP) {
    ScopeManager = __webpack_require__(/*! ./scope/noop/scope_manager */ "../../node_modules/dd-trace/packages/dd-trace/src/scope/noop/scope_manager.js")
  } else {
    ScopeManager = __webpack_require__(/*! ./scope/scope_manager */ "../../node_modules/dd-trace/packages/dd-trace/src/scope/scope_manager.js")
  }

  return new ScopeManager()
}

function getScope (config) {
  let Scope

  if (config.scope === NOOP) {
    Scope = __webpack_require__(/*! ./scope/base */ "../../node_modules/dd-trace/packages/dd-trace/src/scope/base.js")
  } else {
    Scope = platform.getScope(config.scope)
  }

  return new Scope(config)
}

module.exports = DatadogTracer


/***/ }),

/***/ "../../node_modules/dd-trace/packages/dd-trace/src/util.js":
/*!**********************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/packages/dd-trace/src/util.js ***!
  \**********************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function isTrue (str) {
  str = String(str).toLowerCase()
  return str === 'true' || str === '1'
}

function isFalse (str) {
  str = String(str).toLowerCase()
  return str === 'false' || str === '0'
}

module.exports = {
  isTrue,
  isFalse
}


/***/ }),

/***/ "../../node_modules/dd-trace/protobuf/profile.js":
/*!************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/dd-trace/protobuf/profile.js ***!
  \************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/


var $protobuf = __webpack_require__(/*! protobufjs/minimal */ "../../node_modules/protobufjs/minimal.js");

// Common aliases
var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;

// Exported root namespace
var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});

$root.perftools = (function() {

    /**
     * Namespace perftools.
     * @exports perftools
     * @namespace
     */
    var perftools = {};

    perftools.profiles = (function() {

        /**
         * Namespace profiles.
         * @memberof perftools
         * @namespace
         */
        var profiles = {};

        profiles.Profile = (function() {

            /**
             * Properties of a Profile.
             * @memberof perftools.profiles
             * @interface IProfile
             * @property {Array.<perftools.profiles.IValueType>|null} [sampleType] Profile sampleType
             * @property {Array.<perftools.profiles.ISample>|null} [sample] Profile sample
             * @property {Array.<perftools.profiles.IMapping>|null} [mapping] Profile mapping
             * @property {Array.<perftools.profiles.ILocation>|null} [location] Profile location
             * @property {Array.<perftools.profiles.IFunction>|null} ["function"] Profile function
             * @property {Array.<string>|null} [stringTable] Profile stringTable
             * @property {number|Long|null} [dropFrames] Profile dropFrames
             * @property {number|Long|null} [keepFrames] Profile keepFrames
             * @property {number|Long|null} [timeNanos] Profile timeNanos
             * @property {number|Long|null} [durationNanos] Profile durationNanos
             * @property {perftools.profiles.IValueType|null} [periodType] Profile periodType
             * @property {number|Long|null} [period] Profile period
             * @property {Array.<number|Long>|null} [comment] Profile comment
             * @property {number|Long|null} [defaultSampleType] Profile defaultSampleType
             */

            /**
             * Constructs a new Profile.
             * @memberof perftools.profiles
             * @classdesc Represents a Profile.
             * @implements IProfile
             * @constructor
             * @param {perftools.profiles.IProfile=} [properties] Properties to set
             */
            function Profile(properties) {
                this.sampleType = [];
                this.sample = [];
                this.mapping = [];
                this.location = [];
                this["function"] = [];
                this.stringTable = [];
                this.comment = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Profile sampleType.
             * @member {Array.<perftools.profiles.IValueType>} sampleType
             * @memberof perftools.profiles.Profile
             * @instance
             */
            Profile.prototype.sampleType = $util.emptyArray;

            /**
             * Profile sample.
             * @member {Array.<perftools.profiles.ISample>} sample
             * @memberof perftools.profiles.Profile
             * @instance
             */
            Profile.prototype.sample = $util.emptyArray;

            /**
             * Profile mapping.
             * @member {Array.<perftools.profiles.IMapping>} mapping
             * @memberof perftools.profiles.Profile
             * @instance
             */
            Profile.prototype.mapping = $util.emptyArray;

            /**
             * Profile location.
             * @member {Array.<perftools.profiles.ILocation>} location
             * @memberof perftools.profiles.Profile
             * @instance
             */
            Profile.prototype.location = $util.emptyArray;

            /**
             * Profile function.
             * @member {Array.<perftools.profiles.IFunction>} function
             * @memberof perftools.profiles.Profile
             * @instance
             */
            Profile.prototype["function"] = $util.emptyArray;

            /**
             * Profile stringTable.
             * @member {Array.<string>} stringTable
             * @memberof perftools.profiles.Profile
             * @instance
             */
            Profile.prototype.stringTable = $util.emptyArray;

            /**
             * Profile dropFrames.
             * @member {number|Long} dropFrames
             * @memberof perftools.profiles.Profile
             * @instance
             */
            Profile.prototype.dropFrames = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Profile keepFrames.
             * @member {number|Long} keepFrames
             * @memberof perftools.profiles.Profile
             * @instance
             */
            Profile.prototype.keepFrames = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Profile timeNanos.
             * @member {number|Long} timeNanos
             * @memberof perftools.profiles.Profile
             * @instance
             */
            Profile.prototype.timeNanos = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Profile durationNanos.
             * @member {number|Long} durationNanos
             * @memberof perftools.profiles.Profile
             * @instance
             */
            Profile.prototype.durationNanos = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Profile periodType.
             * @member {perftools.profiles.IValueType|null|undefined} periodType
             * @memberof perftools.profiles.Profile
             * @instance
             */
            Profile.prototype.periodType = null;

            /**
             * Profile period.
             * @member {number|Long} period
             * @memberof perftools.profiles.Profile
             * @instance
             */
            Profile.prototype.period = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Profile comment.
             * @member {Array.<number|Long>} comment
             * @memberof perftools.profiles.Profile
             * @instance
             */
            Profile.prototype.comment = $util.emptyArray;

            /**
             * Profile defaultSampleType.
             * @member {number|Long} defaultSampleType
             * @memberof perftools.profiles.Profile
             * @instance
             */
            Profile.prototype.defaultSampleType = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new Profile instance using the specified properties.
             * @function create
             * @memberof perftools.profiles.Profile
             * @static
             * @param {perftools.profiles.IProfile=} [properties] Properties to set
             * @returns {perftools.profiles.Profile} Profile instance
             */
            Profile.create = function create(properties) {
                return new Profile(properties);
            };

            /**
             * Encodes the specified Profile message. Does not implicitly {@link perftools.profiles.Profile.verify|verify} messages.
             * @function encode
             * @memberof perftools.profiles.Profile
             * @static
             * @param {perftools.profiles.IProfile} message Profile message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Profile.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.sampleType != null && message.sampleType.length)
                    for (var i = 0; i < message.sampleType.length; ++i)
                        $root.perftools.profiles.ValueType.encode(message.sampleType[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.sample != null && message.sample.length)
                    for (var i = 0; i < message.sample.length; ++i)
                        $root.perftools.profiles.Sample.encode(message.sample[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.mapping != null && message.mapping.length)
                    for (var i = 0; i < message.mapping.length; ++i)
                        $root.perftools.profiles.Mapping.encode(message.mapping[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.location != null && message.location.length)
                    for (var i = 0; i < message.location.length; ++i)
                        $root.perftools.profiles.Location.encode(message.location[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message["function"] != null && message["function"].length)
                    for (var i = 0; i < message["function"].length; ++i)
                        $root.perftools.profiles.Function.encode(message["function"][i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.stringTable != null && message.stringTable.length)
                    for (var i = 0; i < message.stringTable.length; ++i)
                        writer.uint32(/* id 6, wireType 2 =*/50).string(message.stringTable[i]);
                if (message.dropFrames != null && Object.hasOwnProperty.call(message, "dropFrames"))
                    writer.uint32(/* id 7, wireType 0 =*/56).int64(message.dropFrames);
                if (message.keepFrames != null && Object.hasOwnProperty.call(message, "keepFrames"))
                    writer.uint32(/* id 8, wireType 0 =*/64).int64(message.keepFrames);
                if (message.timeNanos != null && Object.hasOwnProperty.call(message, "timeNanos"))
                    writer.uint32(/* id 9, wireType 0 =*/72).int64(message.timeNanos);
                if (message.durationNanos != null && Object.hasOwnProperty.call(message, "durationNanos"))
                    writer.uint32(/* id 10, wireType 0 =*/80).int64(message.durationNanos);
                if (message.periodType != null && Object.hasOwnProperty.call(message, "periodType"))
                    $root.perftools.profiles.ValueType.encode(message.periodType, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                if (message.period != null && Object.hasOwnProperty.call(message, "period"))
                    writer.uint32(/* id 12, wireType 0 =*/96).int64(message.period);
                if (message.comment != null && message.comment.length) {
                    writer.uint32(/* id 13, wireType 2 =*/106).fork();
                    for (var i = 0; i < message.comment.length; ++i)
                        writer.int64(message.comment[i]);
                    writer.ldelim();
                }
                if (message.defaultSampleType != null && Object.hasOwnProperty.call(message, "defaultSampleType"))
                    writer.uint32(/* id 14, wireType 0 =*/112).int64(message.defaultSampleType);
                return writer;
            };

            /**
             * Encodes the specified Profile message, length delimited. Does not implicitly {@link perftools.profiles.Profile.verify|verify} messages.
             * @function encodeDelimited
             * @memberof perftools.profiles.Profile
             * @static
             * @param {perftools.profiles.IProfile} message Profile message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Profile.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Profile message from the specified reader or buffer.
             * @function decode
             * @memberof perftools.profiles.Profile
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {perftools.profiles.Profile} Profile
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Profile.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.perftools.profiles.Profile();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.sampleType && message.sampleType.length))
                            message.sampleType = [];
                        message.sampleType.push($root.perftools.profiles.ValueType.decode(reader, reader.uint32()));
                        break;
                    case 2:
                        if (!(message.sample && message.sample.length))
                            message.sample = [];
                        message.sample.push($root.perftools.profiles.Sample.decode(reader, reader.uint32()));
                        break;
                    case 3:
                        if (!(message.mapping && message.mapping.length))
                            message.mapping = [];
                        message.mapping.push($root.perftools.profiles.Mapping.decode(reader, reader.uint32()));
                        break;
                    case 4:
                        if (!(message.location && message.location.length))
                            message.location = [];
                        message.location.push($root.perftools.profiles.Location.decode(reader, reader.uint32()));
                        break;
                    case 5:
                        if (!(message["function"] && message["function"].length))
                            message["function"] = [];
                        message["function"].push($root.perftools.profiles.Function.decode(reader, reader.uint32()));
                        break;
                    case 6:
                        if (!(message.stringTable && message.stringTable.length))
                            message.stringTable = [];
                        message.stringTable.push(reader.string());
                        break;
                    case 7:
                        message.dropFrames = reader.int64();
                        break;
                    case 8:
                        message.keepFrames = reader.int64();
                        break;
                    case 9:
                        message.timeNanos = reader.int64();
                        break;
                    case 10:
                        message.durationNanos = reader.int64();
                        break;
                    case 11:
                        message.periodType = $root.perftools.profiles.ValueType.decode(reader, reader.uint32());
                        break;
                    case 12:
                        message.period = reader.int64();
                        break;
                    case 13:
                        if (!(message.comment && message.comment.length))
                            message.comment = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.comment.push(reader.int64());
                        } else
                            message.comment.push(reader.int64());
                        break;
                    case 14:
                        message.defaultSampleType = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Profile message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof perftools.profiles.Profile
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {perftools.profiles.Profile} Profile
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Profile.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Profile message.
             * @function verify
             * @memberof perftools.profiles.Profile
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Profile.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.sampleType != null && message.hasOwnProperty("sampleType")) {
                    if (!Array.isArray(message.sampleType))
                        return "sampleType: array expected";
                    for (var i = 0; i < message.sampleType.length; ++i) {
                        var error = $root.perftools.profiles.ValueType.verify(message.sampleType[i]);
                        if (error)
                            return "sampleType." + error;
                    }
                }
                if (message.sample != null && message.hasOwnProperty("sample")) {
                    if (!Array.isArray(message.sample))
                        return "sample: array expected";
                    for (var i = 0; i < message.sample.length; ++i) {
                        var error = $root.perftools.profiles.Sample.verify(message.sample[i]);
                        if (error)
                            return "sample." + error;
                    }
                }
                if (message.mapping != null && message.hasOwnProperty("mapping")) {
                    if (!Array.isArray(message.mapping))
                        return "mapping: array expected";
                    for (var i = 0; i < message.mapping.length; ++i) {
                        var error = $root.perftools.profiles.Mapping.verify(message.mapping[i]);
                        if (error)
                            return "mapping." + error;
                    }
                }
                if (message.location != null && message.hasOwnProperty("location")) {
                    if (!Array.isArray(message.location))
                        return "location: array expected";
                    for (var i = 0; i < message.location.length; ++i) {
                        var error = $root.perftools.profiles.Location.verify(message.location[i]);
                        if (error)
                            return "location." + error;
                    }
                }
                if (message["function"] != null && message.hasOwnProperty("function")) {
                    if (!Array.isArray(message["function"]))
                        return "function: array expected";
                    for (var i = 0; i < message["function"].length; ++i) {
                        var error = $root.perftools.profiles.Function.verify(message["function"][i]);
                        if (error)
                            return "function." + error;
                    }
                }
                if (message.stringTable != null && message.hasOwnProperty("stringTable")) {
                    if (!Array.isArray(message.stringTable))
                        return "stringTable: array expected";
                    for (var i = 0; i < message.stringTable.length; ++i)
                        if (!$util.isString(message.stringTable[i]))
                            return "stringTable: string[] expected";
                }
                if (message.dropFrames != null && message.hasOwnProperty("dropFrames"))
                    if (!$util.isInteger(message.dropFrames) && !(message.dropFrames && $util.isInteger(message.dropFrames.low) && $util.isInteger(message.dropFrames.high)))
                        return "dropFrames: integer|Long expected";
                if (message.keepFrames != null && message.hasOwnProperty("keepFrames"))
                    if (!$util.isInteger(message.keepFrames) && !(message.keepFrames && $util.isInteger(message.keepFrames.low) && $util.isInteger(message.keepFrames.high)))
                        return "keepFrames: integer|Long expected";
                if (message.timeNanos != null && message.hasOwnProperty("timeNanos"))
                    if (!$util.isInteger(message.timeNanos) && !(message.timeNanos && $util.isInteger(message.timeNanos.low) && $util.isInteger(message.timeNanos.high)))
                        return "timeNanos: integer|Long expected";
                if (message.durationNanos != null && message.hasOwnProperty("durationNanos"))
                    if (!$util.isInteger(message.durationNanos) && !(message.durationNanos && $util.isInteger(message.durationNanos.low) && $util.isInteger(message.durationNanos.high)))
                        return "durationNanos: integer|Long expected";
                if (message.periodType != null && message.hasOwnProperty("periodType")) {
                    var error = $root.perftools.profiles.ValueType.verify(message.periodType);
                    if (error)
                        return "periodType." + error;
                }
                if (message.period != null && message.hasOwnProperty("period"))
                    if (!$util.isInteger(message.period) && !(message.period && $util.isInteger(message.period.low) && $util.isInteger(message.period.high)))
                        return "period: integer|Long expected";
                if (message.comment != null && message.hasOwnProperty("comment")) {
                    if (!Array.isArray(message.comment))
                        return "comment: array expected";
                    for (var i = 0; i < message.comment.length; ++i)
                        if (!$util.isInteger(message.comment[i]) && !(message.comment[i] && $util.isInteger(message.comment[i].low) && $util.isInteger(message.comment[i].high)))
                            return "comment: integer|Long[] expected";
                }
                if (message.defaultSampleType != null && message.hasOwnProperty("defaultSampleType"))
                    if (!$util.isInteger(message.defaultSampleType) && !(message.defaultSampleType && $util.isInteger(message.defaultSampleType.low) && $util.isInteger(message.defaultSampleType.high)))
                        return "defaultSampleType: integer|Long expected";
                return null;
            };

            /**
             * Creates a Profile message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof perftools.profiles.Profile
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {perftools.profiles.Profile} Profile
             */
            Profile.fromObject = function fromObject(object) {
                if (object instanceof $root.perftools.profiles.Profile)
                    return object;
                var message = new $root.perftools.profiles.Profile();
                if (object.sampleType) {
                    if (!Array.isArray(object.sampleType))
                        throw TypeError(".perftools.profiles.Profile.sampleType: array expected");
                    message.sampleType = [];
                    for (var i = 0; i < object.sampleType.length; ++i) {
                        if (typeof object.sampleType[i] !== "object")
                            throw TypeError(".perftools.profiles.Profile.sampleType: object expected");
                        message.sampleType[i] = $root.perftools.profiles.ValueType.fromObject(object.sampleType[i]);
                    }
                }
                if (object.sample) {
                    if (!Array.isArray(object.sample))
                        throw TypeError(".perftools.profiles.Profile.sample: array expected");
                    message.sample = [];
                    for (var i = 0; i < object.sample.length; ++i) {
                        if (typeof object.sample[i] !== "object")
                            throw TypeError(".perftools.profiles.Profile.sample: object expected");
                        message.sample[i] = $root.perftools.profiles.Sample.fromObject(object.sample[i]);
                    }
                }
                if (object.mapping) {
                    if (!Array.isArray(object.mapping))
                        throw TypeError(".perftools.profiles.Profile.mapping: array expected");
                    message.mapping = [];
                    for (var i = 0; i < object.mapping.length; ++i) {
                        if (typeof object.mapping[i] !== "object")
                            throw TypeError(".perftools.profiles.Profile.mapping: object expected");
                        message.mapping[i] = $root.perftools.profiles.Mapping.fromObject(object.mapping[i]);
                    }
                }
                if (object.location) {
                    if (!Array.isArray(object.location))
                        throw TypeError(".perftools.profiles.Profile.location: array expected");
                    message.location = [];
                    for (var i = 0; i < object.location.length; ++i) {
                        if (typeof object.location[i] !== "object")
                            throw TypeError(".perftools.profiles.Profile.location: object expected");
                        message.location[i] = $root.perftools.profiles.Location.fromObject(object.location[i]);
                    }
                }
                if (object["function"]) {
                    if (!Array.isArray(object["function"]))
                        throw TypeError(".perftools.profiles.Profile.function: array expected");
                    message["function"] = [];
                    for (var i = 0; i < object["function"].length; ++i) {
                        if (typeof object["function"][i] !== "object")
                            throw TypeError(".perftools.profiles.Profile.function: object expected");
                        message["function"][i] = $root.perftools.profiles.Function.fromObject(object["function"][i]);
                    }
                }
                if (object.stringTable) {
                    if (!Array.isArray(object.stringTable))
                        throw TypeError(".perftools.profiles.Profile.stringTable: array expected");
                    message.stringTable = [];
                    for (var i = 0; i < object.stringTable.length; ++i)
                        message.stringTable[i] = String(object.stringTable[i]);
                }
                if (object.dropFrames != null)
                    if ($util.Long)
                        (message.dropFrames = $util.Long.fromValue(object.dropFrames)).unsigned = false;
                    else if (typeof object.dropFrames === "string")
                        message.dropFrames = parseInt(object.dropFrames, 10);
                    else if (typeof object.dropFrames === "number")
                        message.dropFrames = object.dropFrames;
                    else if (typeof object.dropFrames === "object")
                        message.dropFrames = new $util.LongBits(object.dropFrames.low >>> 0, object.dropFrames.high >>> 0).toNumber();
                if (object.keepFrames != null)
                    if ($util.Long)
                        (message.keepFrames = $util.Long.fromValue(object.keepFrames)).unsigned = false;
                    else if (typeof object.keepFrames === "string")
                        message.keepFrames = parseInt(object.keepFrames, 10);
                    else if (typeof object.keepFrames === "number")
                        message.keepFrames = object.keepFrames;
                    else if (typeof object.keepFrames === "object")
                        message.keepFrames = new $util.LongBits(object.keepFrames.low >>> 0, object.keepFrames.high >>> 0).toNumber();
                if (object.timeNanos != null)
                    if ($util.Long)
                        (message.timeNanos = $util.Long.fromValue(object.timeNanos)).unsigned = false;
                    else if (typeof object.timeNanos === "string")
                        message.timeNanos = parseInt(object.timeNanos, 10);
                    else if (typeof object.timeNanos === "number")
                        message.timeNanos = object.timeNanos;
                    else if (typeof object.timeNanos === "object")
                        message.timeNanos = new $util.LongBits(object.timeNanos.low >>> 0, object.timeNanos.high >>> 0).toNumber();
                if (object.durationNanos != null)
                    if ($util.Long)
                        (message.durationNanos = $util.Long.fromValue(object.durationNanos)).unsigned = false;
                    else if (typeof object.durationNanos === "string")
                        message.durationNanos = parseInt(object.durationNanos, 10);
                    else if (typeof object.durationNanos === "number")
                        message.durationNanos = object.durationNanos;
                    else if (typeof object.durationNanos === "object")
                        message.durationNanos = new $util.LongBits(object.durationNanos.low >>> 0, object.durationNanos.high >>> 0).toNumber();
                if (object.periodType != null) {
                    if (typeof object.periodType !== "object")
                        throw TypeError(".perftools.profiles.Profile.periodType: object expected");
                    message.periodType = $root.perftools.profiles.ValueType.fromObject(object.periodType);
                }
                if (object.period != null)
                    if ($util.Long)
                        (message.period = $util.Long.fromValue(object.period)).unsigned = false;
                    else if (typeof object.period === "string")
                        message.period = parseInt(object.period, 10);
                    else if (typeof object.period === "number")
                        message.period = object.period;
                    else if (typeof object.period === "object")
                        message.period = new $util.LongBits(object.period.low >>> 0, object.period.high >>> 0).toNumber();
                if (object.comment) {
                    if (!Array.isArray(object.comment))
                        throw TypeError(".perftools.profiles.Profile.comment: array expected");
                    message.comment = [];
                    for (var i = 0; i < object.comment.length; ++i)
                        if ($util.Long)
                            (message.comment[i] = $util.Long.fromValue(object.comment[i])).unsigned = false;
                        else if (typeof object.comment[i] === "string")
                            message.comment[i] = parseInt(object.comment[i], 10);
                        else if (typeof object.comment[i] === "number")
                            message.comment[i] = object.comment[i];
                        else if (typeof object.comment[i] === "object")
                            message.comment[i] = new $util.LongBits(object.comment[i].low >>> 0, object.comment[i].high >>> 0).toNumber();
                }
                if (object.defaultSampleType != null)
                    if ($util.Long)
                        (message.defaultSampleType = $util.Long.fromValue(object.defaultSampleType)).unsigned = false;
                    else if (typeof object.defaultSampleType === "string")
                        message.defaultSampleType = parseInt(object.defaultSampleType, 10);
                    else if (typeof object.defaultSampleType === "number")
                        message.defaultSampleType = object.defaultSampleType;
                    else if (typeof object.defaultSampleType === "object")
                        message.defaultSampleType = new $util.LongBits(object.defaultSampleType.low >>> 0, object.defaultSampleType.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a plain object from a Profile message. Also converts values to other types if specified.
             * @function toObject
             * @memberof perftools.profiles.Profile
             * @static
             * @param {perftools.profiles.Profile} message Profile
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Profile.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.sampleType = [];
                    object.sample = [];
                    object.mapping = [];
                    object.location = [];
                    object["function"] = [];
                    object.stringTable = [];
                    object.comment = [];
                }
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.dropFrames = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.dropFrames = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.keepFrames = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.keepFrames = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.timeNanos = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.timeNanos = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.durationNanos = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.durationNanos = options.longs === String ? "0" : 0;
                    object.periodType = null;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.period = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.period = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.defaultSampleType = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.defaultSampleType = options.longs === String ? "0" : 0;
                }
                if (message.sampleType && message.sampleType.length) {
                    object.sampleType = [];
                    for (var j = 0; j < message.sampleType.length; ++j)
                        object.sampleType[j] = $root.perftools.profiles.ValueType.toObject(message.sampleType[j], options);
                }
                if (message.sample && message.sample.length) {
                    object.sample = [];
                    for (var j = 0; j < message.sample.length; ++j)
                        object.sample[j] = $root.perftools.profiles.Sample.toObject(message.sample[j], options);
                }
                if (message.mapping && message.mapping.length) {
                    object.mapping = [];
                    for (var j = 0; j < message.mapping.length; ++j)
                        object.mapping[j] = $root.perftools.profiles.Mapping.toObject(message.mapping[j], options);
                }
                if (message.location && message.location.length) {
                    object.location = [];
                    for (var j = 0; j < message.location.length; ++j)
                        object.location[j] = $root.perftools.profiles.Location.toObject(message.location[j], options);
                }
                if (message["function"] && message["function"].length) {
                    object["function"] = [];
                    for (var j = 0; j < message["function"].length; ++j)
                        object["function"][j] = $root.perftools.profiles.Function.toObject(message["function"][j], options);
                }
                if (message.stringTable && message.stringTable.length) {
                    object.stringTable = [];
                    for (var j = 0; j < message.stringTable.length; ++j)
                        object.stringTable[j] = message.stringTable[j];
                }
                if (message.dropFrames != null && message.hasOwnProperty("dropFrames"))
                    if (typeof message.dropFrames === "number")
                        object.dropFrames = options.longs === String ? String(message.dropFrames) : message.dropFrames;
                    else
                        object.dropFrames = options.longs === String ? $util.Long.prototype.toString.call(message.dropFrames) : options.longs === Number ? new $util.LongBits(message.dropFrames.low >>> 0, message.dropFrames.high >>> 0).toNumber() : message.dropFrames;
                if (message.keepFrames != null && message.hasOwnProperty("keepFrames"))
                    if (typeof message.keepFrames === "number")
                        object.keepFrames = options.longs === String ? String(message.keepFrames) : message.keepFrames;
                    else
                        object.keepFrames = options.longs === String ? $util.Long.prototype.toString.call(message.keepFrames) : options.longs === Number ? new $util.LongBits(message.keepFrames.low >>> 0, message.keepFrames.high >>> 0).toNumber() : message.keepFrames;
                if (message.timeNanos != null && message.hasOwnProperty("timeNanos"))
                    if (typeof message.timeNanos === "number")
                        object.timeNanos = options.longs === String ? String(message.timeNanos) : message.timeNanos;
                    else
                        object.timeNanos = options.longs === String ? $util.Long.prototype.toString.call(message.timeNanos) : options.longs === Number ? new $util.LongBits(message.timeNanos.low >>> 0, message.timeNanos.high >>> 0).toNumber() : message.timeNanos;
                if (message.durationNanos != null && message.hasOwnProperty("durationNanos"))
                    if (typeof message.durationNanos === "number")
                        object.durationNanos = options.longs === String ? String(message.durationNanos) : message.durationNanos;
                    else
                        object.durationNanos = options.longs === String ? $util.Long.prototype.toString.call(message.durationNanos) : options.longs === Number ? new $util.LongBits(message.durationNanos.low >>> 0, message.durationNanos.high >>> 0).toNumber() : message.durationNanos;
                if (message.periodType != null && message.hasOwnProperty("periodType"))
                    object.periodType = $root.perftools.profiles.ValueType.toObject(message.periodType, options);
                if (message.period != null && message.hasOwnProperty("period"))
                    if (typeof message.period === "number")
                        object.period = options.longs === String ? String(message.period) : message.period;
                    else
                        object.period = options.longs === String ? $util.Long.prototype.toString.call(message.period) : options.longs === Number ? new $util.LongBits(message.period.low >>> 0, message.period.high >>> 0).toNumber() : message.period;
                if (message.comment && message.comment.length) {
                    object.comment = [];
                    for (var j = 0; j < message.comment.length; ++j)
                        if (typeof message.comment[j] === "number")
                            object.comment[j] = options.longs === String ? String(message.comment[j]) : message.comment[j];
                        else
                            object.comment[j] = options.longs === String ? $util.Long.prototype.toString.call(message.comment[j]) : options.longs === Number ? new $util.LongBits(message.comment[j].low >>> 0, message.comment[j].high >>> 0).toNumber() : message.comment[j];
                }
                if (message.defaultSampleType != null && message.hasOwnProperty("defaultSampleType"))
                    if (typeof message.defaultSampleType === "number")
                        object.defaultSampleType = options.longs === String ? String(message.defaultSampleType) : message.defaultSampleType;
                    else
                        object.defaultSampleType = options.longs === String ? $util.Long.prototype.toString.call(message.defaultSampleType) : options.longs === Number ? new $util.LongBits(message.defaultSampleType.low >>> 0, message.defaultSampleType.high >>> 0).toNumber() : message.defaultSampleType;
                return object;
            };

            /**
             * Converts this Profile to JSON.
             * @function toJSON
             * @memberof perftools.profiles.Profile
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Profile.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Profile;
        })();

        profiles.ValueType = (function() {

            /**
             * Properties of a ValueType.
             * @memberof perftools.profiles
             * @interface IValueType
             * @property {number|Long|null} [type] ValueType type
             * @property {number|Long|null} [unit] ValueType unit
             */

            /**
             * Constructs a new ValueType.
             * @memberof perftools.profiles
             * @classdesc Represents a ValueType.
             * @implements IValueType
             * @constructor
             * @param {perftools.profiles.IValueType=} [properties] Properties to set
             */
            function ValueType(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ValueType type.
             * @member {number|Long} type
             * @memberof perftools.profiles.ValueType
             * @instance
             */
            ValueType.prototype.type = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * ValueType unit.
             * @member {number|Long} unit
             * @memberof perftools.profiles.ValueType
             * @instance
             */
            ValueType.prototype.unit = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new ValueType instance using the specified properties.
             * @function create
             * @memberof perftools.profiles.ValueType
             * @static
             * @param {perftools.profiles.IValueType=} [properties] Properties to set
             * @returns {perftools.profiles.ValueType} ValueType instance
             */
            ValueType.create = function create(properties) {
                return new ValueType(properties);
            };

            /**
             * Encodes the specified ValueType message. Does not implicitly {@link perftools.profiles.ValueType.verify|verify} messages.
             * @function encode
             * @memberof perftools.profiles.ValueType
             * @static
             * @param {perftools.profiles.IValueType} message ValueType message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ValueType.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.type);
                if (message.unit != null && Object.hasOwnProperty.call(message, "unit"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.unit);
                return writer;
            };

            /**
             * Encodes the specified ValueType message, length delimited. Does not implicitly {@link perftools.profiles.ValueType.verify|verify} messages.
             * @function encodeDelimited
             * @memberof perftools.profiles.ValueType
             * @static
             * @param {perftools.profiles.IValueType} message ValueType message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ValueType.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ValueType message from the specified reader or buffer.
             * @function decode
             * @memberof perftools.profiles.ValueType
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {perftools.profiles.ValueType} ValueType
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ValueType.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.perftools.profiles.ValueType();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.type = reader.int64();
                        break;
                    case 2:
                        message.unit = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ValueType message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof perftools.profiles.ValueType
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {perftools.profiles.ValueType} ValueType
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ValueType.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ValueType message.
             * @function verify
             * @memberof perftools.profiles.ValueType
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ValueType.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    if (!$util.isInteger(message.type) && !(message.type && $util.isInteger(message.type.low) && $util.isInteger(message.type.high)))
                        return "type: integer|Long expected";
                if (message.unit != null && message.hasOwnProperty("unit"))
                    if (!$util.isInteger(message.unit) && !(message.unit && $util.isInteger(message.unit.low) && $util.isInteger(message.unit.high)))
                        return "unit: integer|Long expected";
                return null;
            };

            /**
             * Creates a ValueType message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof perftools.profiles.ValueType
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {perftools.profiles.ValueType} ValueType
             */
            ValueType.fromObject = function fromObject(object) {
                if (object instanceof $root.perftools.profiles.ValueType)
                    return object;
                var message = new $root.perftools.profiles.ValueType();
                if (object.type != null)
                    if ($util.Long)
                        (message.type = $util.Long.fromValue(object.type)).unsigned = false;
                    else if (typeof object.type === "string")
                        message.type = parseInt(object.type, 10);
                    else if (typeof object.type === "number")
                        message.type = object.type;
                    else if (typeof object.type === "object")
                        message.type = new $util.LongBits(object.type.low >>> 0, object.type.high >>> 0).toNumber();
                if (object.unit != null)
                    if ($util.Long)
                        (message.unit = $util.Long.fromValue(object.unit)).unsigned = false;
                    else if (typeof object.unit === "string")
                        message.unit = parseInt(object.unit, 10);
                    else if (typeof object.unit === "number")
                        message.unit = object.unit;
                    else if (typeof object.unit === "object")
                        message.unit = new $util.LongBits(object.unit.low >>> 0, object.unit.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a plain object from a ValueType message. Also converts values to other types if specified.
             * @function toObject
             * @memberof perftools.profiles.ValueType
             * @static
             * @param {perftools.profiles.ValueType} message ValueType
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ValueType.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.type = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.type = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.unit = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.unit = options.longs === String ? "0" : 0;
                }
                if (message.type != null && message.hasOwnProperty("type"))
                    if (typeof message.type === "number")
                        object.type = options.longs === String ? String(message.type) : message.type;
                    else
                        object.type = options.longs === String ? $util.Long.prototype.toString.call(message.type) : options.longs === Number ? new $util.LongBits(message.type.low >>> 0, message.type.high >>> 0).toNumber() : message.type;
                if (message.unit != null && message.hasOwnProperty("unit"))
                    if (typeof message.unit === "number")
                        object.unit = options.longs === String ? String(message.unit) : message.unit;
                    else
                        object.unit = options.longs === String ? $util.Long.prototype.toString.call(message.unit) : options.longs === Number ? new $util.LongBits(message.unit.low >>> 0, message.unit.high >>> 0).toNumber() : message.unit;
                return object;
            };

            /**
             * Converts this ValueType to JSON.
             * @function toJSON
             * @memberof perftools.profiles.ValueType
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ValueType.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ValueType;
        })();

        profiles.Sample = (function() {

            /**
             * Properties of a Sample.
             * @memberof perftools.profiles
             * @interface ISample
             * @property {Array.<number|Long>|null} [locationId] Sample locationId
             * @property {Array.<number|Long>|null} [value] Sample value
             * @property {Array.<perftools.profiles.ILabel>|null} [label] Sample label
             */

            /**
             * Constructs a new Sample.
             * @memberof perftools.profiles
             * @classdesc Represents a Sample.
             * @implements ISample
             * @constructor
             * @param {perftools.profiles.ISample=} [properties] Properties to set
             */
            function Sample(properties) {
                this.locationId = [];
                this.value = [];
                this.label = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Sample locationId.
             * @member {Array.<number|Long>} locationId
             * @memberof perftools.profiles.Sample
             * @instance
             */
            Sample.prototype.locationId = $util.emptyArray;

            /**
             * Sample value.
             * @member {Array.<number|Long>} value
             * @memberof perftools.profiles.Sample
             * @instance
             */
            Sample.prototype.value = $util.emptyArray;

            /**
             * Sample label.
             * @member {Array.<perftools.profiles.ILabel>} label
             * @memberof perftools.profiles.Sample
             * @instance
             */
            Sample.prototype.label = $util.emptyArray;

            /**
             * Creates a new Sample instance using the specified properties.
             * @function create
             * @memberof perftools.profiles.Sample
             * @static
             * @param {perftools.profiles.ISample=} [properties] Properties to set
             * @returns {perftools.profiles.Sample} Sample instance
             */
            Sample.create = function create(properties) {
                return new Sample(properties);
            };

            /**
             * Encodes the specified Sample message. Does not implicitly {@link perftools.profiles.Sample.verify|verify} messages.
             * @function encode
             * @memberof perftools.profiles.Sample
             * @static
             * @param {perftools.profiles.ISample} message Sample message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Sample.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.locationId != null && message.locationId.length) {
                    writer.uint32(/* id 1, wireType 2 =*/10).fork();
                    for (var i = 0; i < message.locationId.length; ++i)
                        writer.uint64(message.locationId[i]);
                    writer.ldelim();
                }
                if (message.value != null && message.value.length) {
                    writer.uint32(/* id 2, wireType 2 =*/18).fork();
                    for (var i = 0; i < message.value.length; ++i)
                        writer.int64(message.value[i]);
                    writer.ldelim();
                }
                if (message.label != null && message.label.length)
                    for (var i = 0; i < message.label.length; ++i)
                        $root.perftools.profiles.Label.encode(message.label[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Sample message, length delimited. Does not implicitly {@link perftools.profiles.Sample.verify|verify} messages.
             * @function encodeDelimited
             * @memberof perftools.profiles.Sample
             * @static
             * @param {perftools.profiles.ISample} message Sample message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Sample.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Sample message from the specified reader or buffer.
             * @function decode
             * @memberof perftools.profiles.Sample
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {perftools.profiles.Sample} Sample
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Sample.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.perftools.profiles.Sample();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.locationId && message.locationId.length))
                            message.locationId = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.locationId.push(reader.uint64());
                        } else
                            message.locationId.push(reader.uint64());
                        break;
                    case 2:
                        if (!(message.value && message.value.length))
                            message.value = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.value.push(reader.int64());
                        } else
                            message.value.push(reader.int64());
                        break;
                    case 3:
                        if (!(message.label && message.label.length))
                            message.label = [];
                        message.label.push($root.perftools.profiles.Label.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Sample message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof perftools.profiles.Sample
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {perftools.profiles.Sample} Sample
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Sample.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Sample message.
             * @function verify
             * @memberof perftools.profiles.Sample
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Sample.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.locationId != null && message.hasOwnProperty("locationId")) {
                    if (!Array.isArray(message.locationId))
                        return "locationId: array expected";
                    for (var i = 0; i < message.locationId.length; ++i)
                        if (!$util.isInteger(message.locationId[i]) && !(message.locationId[i] && $util.isInteger(message.locationId[i].low) && $util.isInteger(message.locationId[i].high)))
                            return "locationId: integer|Long[] expected";
                }
                if (message.value != null && message.hasOwnProperty("value")) {
                    if (!Array.isArray(message.value))
                        return "value: array expected";
                    for (var i = 0; i < message.value.length; ++i)
                        if (!$util.isInteger(message.value[i]) && !(message.value[i] && $util.isInteger(message.value[i].low) && $util.isInteger(message.value[i].high)))
                            return "value: integer|Long[] expected";
                }
                if (message.label != null && message.hasOwnProperty("label")) {
                    if (!Array.isArray(message.label))
                        return "label: array expected";
                    for (var i = 0; i < message.label.length; ++i) {
                        var error = $root.perftools.profiles.Label.verify(message.label[i]);
                        if (error)
                            return "label." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a Sample message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof perftools.profiles.Sample
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {perftools.profiles.Sample} Sample
             */
            Sample.fromObject = function fromObject(object) {
                if (object instanceof $root.perftools.profiles.Sample)
                    return object;
                var message = new $root.perftools.profiles.Sample();
                if (object.locationId) {
                    if (!Array.isArray(object.locationId))
                        throw TypeError(".perftools.profiles.Sample.locationId: array expected");
                    message.locationId = [];
                    for (var i = 0; i < object.locationId.length; ++i)
                        if ($util.Long)
                            (message.locationId[i] = $util.Long.fromValue(object.locationId[i])).unsigned = true;
                        else if (typeof object.locationId[i] === "string")
                            message.locationId[i] = parseInt(object.locationId[i], 10);
                        else if (typeof object.locationId[i] === "number")
                            message.locationId[i] = object.locationId[i];
                        else if (typeof object.locationId[i] === "object")
                            message.locationId[i] = new $util.LongBits(object.locationId[i].low >>> 0, object.locationId[i].high >>> 0).toNumber(true);
                }
                if (object.value) {
                    if (!Array.isArray(object.value))
                        throw TypeError(".perftools.profiles.Sample.value: array expected");
                    message.value = [];
                    for (var i = 0; i < object.value.length; ++i)
                        if ($util.Long)
                            (message.value[i] = $util.Long.fromValue(object.value[i])).unsigned = false;
                        else if (typeof object.value[i] === "string")
                            message.value[i] = parseInt(object.value[i], 10);
                        else if (typeof object.value[i] === "number")
                            message.value[i] = object.value[i];
                        else if (typeof object.value[i] === "object")
                            message.value[i] = new $util.LongBits(object.value[i].low >>> 0, object.value[i].high >>> 0).toNumber();
                }
                if (object.label) {
                    if (!Array.isArray(object.label))
                        throw TypeError(".perftools.profiles.Sample.label: array expected");
                    message.label = [];
                    for (var i = 0; i < object.label.length; ++i) {
                        if (typeof object.label[i] !== "object")
                            throw TypeError(".perftools.profiles.Sample.label: object expected");
                        message.label[i] = $root.perftools.profiles.Label.fromObject(object.label[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a Sample message. Also converts values to other types if specified.
             * @function toObject
             * @memberof perftools.profiles.Sample
             * @static
             * @param {perftools.profiles.Sample} message Sample
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Sample.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.locationId = [];
                    object.value = [];
                    object.label = [];
                }
                if (message.locationId && message.locationId.length) {
                    object.locationId = [];
                    for (var j = 0; j < message.locationId.length; ++j)
                        if (typeof message.locationId[j] === "number")
                            object.locationId[j] = options.longs === String ? String(message.locationId[j]) : message.locationId[j];
                        else
                            object.locationId[j] = options.longs === String ? $util.Long.prototype.toString.call(message.locationId[j]) : options.longs === Number ? new $util.LongBits(message.locationId[j].low >>> 0, message.locationId[j].high >>> 0).toNumber(true) : message.locationId[j];
                }
                if (message.value && message.value.length) {
                    object.value = [];
                    for (var j = 0; j < message.value.length; ++j)
                        if (typeof message.value[j] === "number")
                            object.value[j] = options.longs === String ? String(message.value[j]) : message.value[j];
                        else
                            object.value[j] = options.longs === String ? $util.Long.prototype.toString.call(message.value[j]) : options.longs === Number ? new $util.LongBits(message.value[j].low >>> 0, message.value[j].high >>> 0).toNumber() : message.value[j];
                }
                if (message.label && message.label.length) {
                    object.label = [];
                    for (var j = 0; j < message.label.length; ++j)
                        object.label[j] = $root.perftools.profiles.Label.toObject(message.label[j], options);
                }
                return object;
            };

            /**
             * Converts this Sample to JSON.
             * @function toJSON
             * @memberof perftools.profiles.Sample
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Sample.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Sample;
        })();

        profiles.Label = (function() {

            /**
             * Properties of a Label.
             * @memberof perftools.profiles
             * @interface ILabel
             * @property {number|Long|null} [key] Label key
             * @property {number|Long|null} [str] Label str
             * @property {number|Long|null} [num] Label num
             * @property {number|Long|null} [numUnit] Label numUnit
             */

            /**
             * Constructs a new Label.
             * @memberof perftools.profiles
             * @classdesc Represents a Label.
             * @implements ILabel
             * @constructor
             * @param {perftools.profiles.ILabel=} [properties] Properties to set
             */
            function Label(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Label key.
             * @member {number|Long} key
             * @memberof perftools.profiles.Label
             * @instance
             */
            Label.prototype.key = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Label str.
             * @member {number|Long} str
             * @memberof perftools.profiles.Label
             * @instance
             */
            Label.prototype.str = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Label num.
             * @member {number|Long} num
             * @memberof perftools.profiles.Label
             * @instance
             */
            Label.prototype.num = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Label numUnit.
             * @member {number|Long} numUnit
             * @memberof perftools.profiles.Label
             * @instance
             */
            Label.prototype.numUnit = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new Label instance using the specified properties.
             * @function create
             * @memberof perftools.profiles.Label
             * @static
             * @param {perftools.profiles.ILabel=} [properties] Properties to set
             * @returns {perftools.profiles.Label} Label instance
             */
            Label.create = function create(properties) {
                return new Label(properties);
            };

            /**
             * Encodes the specified Label message. Does not implicitly {@link perftools.profiles.Label.verify|verify} messages.
             * @function encode
             * @memberof perftools.profiles.Label
             * @static
             * @param {perftools.profiles.ILabel} message Label message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Label.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.key);
                if (message.str != null && Object.hasOwnProperty.call(message, "str"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.str);
                if (message.num != null && Object.hasOwnProperty.call(message, "num"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int64(message.num);
                if (message.numUnit != null && Object.hasOwnProperty.call(message, "numUnit"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int64(message.numUnit);
                return writer;
            };

            /**
             * Encodes the specified Label message, length delimited. Does not implicitly {@link perftools.profiles.Label.verify|verify} messages.
             * @function encodeDelimited
             * @memberof perftools.profiles.Label
             * @static
             * @param {perftools.profiles.ILabel} message Label message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Label.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Label message from the specified reader or buffer.
             * @function decode
             * @memberof perftools.profiles.Label
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {perftools.profiles.Label} Label
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Label.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.perftools.profiles.Label();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.key = reader.int64();
                        break;
                    case 2:
                        message.str = reader.int64();
                        break;
                    case 3:
                        message.num = reader.int64();
                        break;
                    case 4:
                        message.numUnit = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Label message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof perftools.profiles.Label
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {perftools.profiles.Label} Label
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Label.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Label message.
             * @function verify
             * @memberof perftools.profiles.Label
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Label.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.key != null && message.hasOwnProperty("key"))
                    if (!$util.isInteger(message.key) && !(message.key && $util.isInteger(message.key.low) && $util.isInteger(message.key.high)))
                        return "key: integer|Long expected";
                if (message.str != null && message.hasOwnProperty("str"))
                    if (!$util.isInteger(message.str) && !(message.str && $util.isInteger(message.str.low) && $util.isInteger(message.str.high)))
                        return "str: integer|Long expected";
                if (message.num != null && message.hasOwnProperty("num"))
                    if (!$util.isInteger(message.num) && !(message.num && $util.isInteger(message.num.low) && $util.isInteger(message.num.high)))
                        return "num: integer|Long expected";
                if (message.numUnit != null && message.hasOwnProperty("numUnit"))
                    if (!$util.isInteger(message.numUnit) && !(message.numUnit && $util.isInteger(message.numUnit.low) && $util.isInteger(message.numUnit.high)))
                        return "numUnit: integer|Long expected";
                return null;
            };

            /**
             * Creates a Label message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof perftools.profiles.Label
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {perftools.profiles.Label} Label
             */
            Label.fromObject = function fromObject(object) {
                if (object instanceof $root.perftools.profiles.Label)
                    return object;
                var message = new $root.perftools.profiles.Label();
                if (object.key != null)
                    if ($util.Long)
                        (message.key = $util.Long.fromValue(object.key)).unsigned = false;
                    else if (typeof object.key === "string")
                        message.key = parseInt(object.key, 10);
                    else if (typeof object.key === "number")
                        message.key = object.key;
                    else if (typeof object.key === "object")
                        message.key = new $util.LongBits(object.key.low >>> 0, object.key.high >>> 0).toNumber();
                if (object.str != null)
                    if ($util.Long)
                        (message.str = $util.Long.fromValue(object.str)).unsigned = false;
                    else if (typeof object.str === "string")
                        message.str = parseInt(object.str, 10);
                    else if (typeof object.str === "number")
                        message.str = object.str;
                    else if (typeof object.str === "object")
                        message.str = new $util.LongBits(object.str.low >>> 0, object.str.high >>> 0).toNumber();
                if (object.num != null)
                    if ($util.Long)
                        (message.num = $util.Long.fromValue(object.num)).unsigned = false;
                    else if (typeof object.num === "string")
                        message.num = parseInt(object.num, 10);
                    else if (typeof object.num === "number")
                        message.num = object.num;
                    else if (typeof object.num === "object")
                        message.num = new $util.LongBits(object.num.low >>> 0, object.num.high >>> 0).toNumber();
                if (object.numUnit != null)
                    if ($util.Long)
                        (message.numUnit = $util.Long.fromValue(object.numUnit)).unsigned = false;
                    else if (typeof object.numUnit === "string")
                        message.numUnit = parseInt(object.numUnit, 10);
                    else if (typeof object.numUnit === "number")
                        message.numUnit = object.numUnit;
                    else if (typeof object.numUnit === "object")
                        message.numUnit = new $util.LongBits(object.numUnit.low >>> 0, object.numUnit.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a plain object from a Label message. Also converts values to other types if specified.
             * @function toObject
             * @memberof perftools.profiles.Label
             * @static
             * @param {perftools.profiles.Label} message Label
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Label.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.key = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.key = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.str = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.str = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.num = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.num = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.numUnit = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.numUnit = options.longs === String ? "0" : 0;
                }
                if (message.key != null && message.hasOwnProperty("key"))
                    if (typeof message.key === "number")
                        object.key = options.longs === String ? String(message.key) : message.key;
                    else
                        object.key = options.longs === String ? $util.Long.prototype.toString.call(message.key) : options.longs === Number ? new $util.LongBits(message.key.low >>> 0, message.key.high >>> 0).toNumber() : message.key;
                if (message.str != null && message.hasOwnProperty("str"))
                    if (typeof message.str === "number")
                        object.str = options.longs === String ? String(message.str) : message.str;
                    else
                        object.str = options.longs === String ? $util.Long.prototype.toString.call(message.str) : options.longs === Number ? new $util.LongBits(message.str.low >>> 0, message.str.high >>> 0).toNumber() : message.str;
                if (message.num != null && message.hasOwnProperty("num"))
                    if (typeof message.num === "number")
                        object.num = options.longs === String ? String(message.num) : message.num;
                    else
                        object.num = options.longs === String ? $util.Long.prototype.toString.call(message.num) : options.longs === Number ? new $util.LongBits(message.num.low >>> 0, message.num.high >>> 0).toNumber() : message.num;
                if (message.numUnit != null && message.hasOwnProperty("numUnit"))
                    if (typeof message.numUnit === "number")
                        object.numUnit = options.longs === String ? String(message.numUnit) : message.numUnit;
                    else
                        object.numUnit = options.longs === String ? $util.Long.prototype.toString.call(message.numUnit) : options.longs === Number ? new $util.LongBits(message.numUnit.low >>> 0, message.numUnit.high >>> 0).toNumber() : message.numUnit;
                return object;
            };

            /**
             * Converts this Label to JSON.
             * @function toJSON
             * @memberof perftools.profiles.Label
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Label.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Label;
        })();

        profiles.Mapping = (function() {

            /**
             * Properties of a Mapping.
             * @memberof perftools.profiles
             * @interface IMapping
             * @property {number|Long|null} [id] Mapping id
             * @property {number|Long|null} [memoryStart] Mapping memoryStart
             * @property {number|Long|null} [memoryLimit] Mapping memoryLimit
             * @property {number|Long|null} [fileOffset] Mapping fileOffset
             * @property {number|Long|null} [filename] Mapping filename
             * @property {number|Long|null} [buildId] Mapping buildId
             * @property {boolean|null} [hasFunctions] Mapping hasFunctions
             * @property {boolean|null} [hasFilenames] Mapping hasFilenames
             * @property {boolean|null} [hasLineNumbers] Mapping hasLineNumbers
             * @property {boolean|null} [hasInlineFrames] Mapping hasInlineFrames
             */

            /**
             * Constructs a new Mapping.
             * @memberof perftools.profiles
             * @classdesc Represents a Mapping.
             * @implements IMapping
             * @constructor
             * @param {perftools.profiles.IMapping=} [properties] Properties to set
             */
            function Mapping(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Mapping id.
             * @member {number|Long} id
             * @memberof perftools.profiles.Mapping
             * @instance
             */
            Mapping.prototype.id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Mapping memoryStart.
             * @member {number|Long} memoryStart
             * @memberof perftools.profiles.Mapping
             * @instance
             */
            Mapping.prototype.memoryStart = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Mapping memoryLimit.
             * @member {number|Long} memoryLimit
             * @memberof perftools.profiles.Mapping
             * @instance
             */
            Mapping.prototype.memoryLimit = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Mapping fileOffset.
             * @member {number|Long} fileOffset
             * @memberof perftools.profiles.Mapping
             * @instance
             */
            Mapping.prototype.fileOffset = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Mapping filename.
             * @member {number|Long} filename
             * @memberof perftools.profiles.Mapping
             * @instance
             */
            Mapping.prototype.filename = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Mapping buildId.
             * @member {number|Long} buildId
             * @memberof perftools.profiles.Mapping
             * @instance
             */
            Mapping.prototype.buildId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Mapping hasFunctions.
             * @member {boolean} hasFunctions
             * @memberof perftools.profiles.Mapping
             * @instance
             */
            Mapping.prototype.hasFunctions = false;

            /**
             * Mapping hasFilenames.
             * @member {boolean} hasFilenames
             * @memberof perftools.profiles.Mapping
             * @instance
             */
            Mapping.prototype.hasFilenames = false;

            /**
             * Mapping hasLineNumbers.
             * @member {boolean} hasLineNumbers
             * @memberof perftools.profiles.Mapping
             * @instance
             */
            Mapping.prototype.hasLineNumbers = false;

            /**
             * Mapping hasInlineFrames.
             * @member {boolean} hasInlineFrames
             * @memberof perftools.profiles.Mapping
             * @instance
             */
            Mapping.prototype.hasInlineFrames = false;

            /**
             * Creates a new Mapping instance using the specified properties.
             * @function create
             * @memberof perftools.profiles.Mapping
             * @static
             * @param {perftools.profiles.IMapping=} [properties] Properties to set
             * @returns {perftools.profiles.Mapping} Mapping instance
             */
            Mapping.create = function create(properties) {
                return new Mapping(properties);
            };

            /**
             * Encodes the specified Mapping message. Does not implicitly {@link perftools.profiles.Mapping.verify|verify} messages.
             * @function encode
             * @memberof perftools.profiles.Mapping
             * @static
             * @param {perftools.profiles.IMapping} message Mapping message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Mapping.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.id);
                if (message.memoryStart != null && Object.hasOwnProperty.call(message, "memoryStart"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.memoryStart);
                if (message.memoryLimit != null && Object.hasOwnProperty.call(message, "memoryLimit"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.memoryLimit);
                if (message.fileOffset != null && Object.hasOwnProperty.call(message, "fileOffset"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.fileOffset);
                if (message.filename != null && Object.hasOwnProperty.call(message, "filename"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int64(message.filename);
                if (message.buildId != null && Object.hasOwnProperty.call(message, "buildId"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int64(message.buildId);
                if (message.hasFunctions != null && Object.hasOwnProperty.call(message, "hasFunctions"))
                    writer.uint32(/* id 7, wireType 0 =*/56).bool(message.hasFunctions);
                if (message.hasFilenames != null && Object.hasOwnProperty.call(message, "hasFilenames"))
                    writer.uint32(/* id 8, wireType 0 =*/64).bool(message.hasFilenames);
                if (message.hasLineNumbers != null && Object.hasOwnProperty.call(message, "hasLineNumbers"))
                    writer.uint32(/* id 9, wireType 0 =*/72).bool(message.hasLineNumbers);
                if (message.hasInlineFrames != null && Object.hasOwnProperty.call(message, "hasInlineFrames"))
                    writer.uint32(/* id 10, wireType 0 =*/80).bool(message.hasInlineFrames);
                return writer;
            };

            /**
             * Encodes the specified Mapping message, length delimited. Does not implicitly {@link perftools.profiles.Mapping.verify|verify} messages.
             * @function encodeDelimited
             * @memberof perftools.profiles.Mapping
             * @static
             * @param {perftools.profiles.IMapping} message Mapping message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Mapping.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Mapping message from the specified reader or buffer.
             * @function decode
             * @memberof perftools.profiles.Mapping
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {perftools.profiles.Mapping} Mapping
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Mapping.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.perftools.profiles.Mapping();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = reader.uint64();
                        break;
                    case 2:
                        message.memoryStart = reader.uint64();
                        break;
                    case 3:
                        message.memoryLimit = reader.uint64();
                        break;
                    case 4:
                        message.fileOffset = reader.uint64();
                        break;
                    case 5:
                        message.filename = reader.int64();
                        break;
                    case 6:
                        message.buildId = reader.int64();
                        break;
                    case 7:
                        message.hasFunctions = reader.bool();
                        break;
                    case 8:
                        message.hasFilenames = reader.bool();
                        break;
                    case 9:
                        message.hasLineNumbers = reader.bool();
                        break;
                    case 10:
                        message.hasInlineFrames = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Mapping message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof perftools.profiles.Mapping
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {perftools.profiles.Mapping} Mapping
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Mapping.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Mapping message.
             * @function verify
             * @memberof perftools.profiles.Mapping
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Mapping.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                        return "id: integer|Long expected";
                if (message.memoryStart != null && message.hasOwnProperty("memoryStart"))
                    if (!$util.isInteger(message.memoryStart) && !(message.memoryStart && $util.isInteger(message.memoryStart.low) && $util.isInteger(message.memoryStart.high)))
                        return "memoryStart: integer|Long expected";
                if (message.memoryLimit != null && message.hasOwnProperty("memoryLimit"))
                    if (!$util.isInteger(message.memoryLimit) && !(message.memoryLimit && $util.isInteger(message.memoryLimit.low) && $util.isInteger(message.memoryLimit.high)))
                        return "memoryLimit: integer|Long expected";
                if (message.fileOffset != null && message.hasOwnProperty("fileOffset"))
                    if (!$util.isInteger(message.fileOffset) && !(message.fileOffset && $util.isInteger(message.fileOffset.low) && $util.isInteger(message.fileOffset.high)))
                        return "fileOffset: integer|Long expected";
                if (message.filename != null && message.hasOwnProperty("filename"))
                    if (!$util.isInteger(message.filename) && !(message.filename && $util.isInteger(message.filename.low) && $util.isInteger(message.filename.high)))
                        return "filename: integer|Long expected";
                if (message.buildId != null && message.hasOwnProperty("buildId"))
                    if (!$util.isInteger(message.buildId) && !(message.buildId && $util.isInteger(message.buildId.low) && $util.isInteger(message.buildId.high)))
                        return "buildId: integer|Long expected";
                if (message.hasFunctions != null && message.hasOwnProperty("hasFunctions"))
                    if (typeof message.hasFunctions !== "boolean")
                        return "hasFunctions: boolean expected";
                if (message.hasFilenames != null && message.hasOwnProperty("hasFilenames"))
                    if (typeof message.hasFilenames !== "boolean")
                        return "hasFilenames: boolean expected";
                if (message.hasLineNumbers != null && message.hasOwnProperty("hasLineNumbers"))
                    if (typeof message.hasLineNumbers !== "boolean")
                        return "hasLineNumbers: boolean expected";
                if (message.hasInlineFrames != null && message.hasOwnProperty("hasInlineFrames"))
                    if (typeof message.hasInlineFrames !== "boolean")
                        return "hasInlineFrames: boolean expected";
                return null;
            };

            /**
             * Creates a Mapping message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof perftools.profiles.Mapping
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {perftools.profiles.Mapping} Mapping
             */
            Mapping.fromObject = function fromObject(object) {
                if (object instanceof $root.perftools.profiles.Mapping)
                    return object;
                var message = new $root.perftools.profiles.Mapping();
                if (object.id != null)
                    if ($util.Long)
                        (message.id = $util.Long.fromValue(object.id)).unsigned = true;
                    else if (typeof object.id === "string")
                        message.id = parseInt(object.id, 10);
                    else if (typeof object.id === "number")
                        message.id = object.id;
                    else if (typeof object.id === "object")
                        message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);
                if (object.memoryStart != null)
                    if ($util.Long)
                        (message.memoryStart = $util.Long.fromValue(object.memoryStart)).unsigned = true;
                    else if (typeof object.memoryStart === "string")
                        message.memoryStart = parseInt(object.memoryStart, 10);
                    else if (typeof object.memoryStart === "number")
                        message.memoryStart = object.memoryStart;
                    else if (typeof object.memoryStart === "object")
                        message.memoryStart = new $util.LongBits(object.memoryStart.low >>> 0, object.memoryStart.high >>> 0).toNumber(true);
                if (object.memoryLimit != null)
                    if ($util.Long)
                        (message.memoryLimit = $util.Long.fromValue(object.memoryLimit)).unsigned = true;
                    else if (typeof object.memoryLimit === "string")
                        message.memoryLimit = parseInt(object.memoryLimit, 10);
                    else if (typeof object.memoryLimit === "number")
                        message.memoryLimit = object.memoryLimit;
                    else if (typeof object.memoryLimit === "object")
                        message.memoryLimit = new $util.LongBits(object.memoryLimit.low >>> 0, object.memoryLimit.high >>> 0).toNumber(true);
                if (object.fileOffset != null)
                    if ($util.Long)
                        (message.fileOffset = $util.Long.fromValue(object.fileOffset)).unsigned = true;
                    else if (typeof object.fileOffset === "string")
                        message.fileOffset = parseInt(object.fileOffset, 10);
                    else if (typeof object.fileOffset === "number")
                        message.fileOffset = object.fileOffset;
                    else if (typeof object.fileOffset === "object")
                        message.fileOffset = new $util.LongBits(object.fileOffset.low >>> 0, object.fileOffset.high >>> 0).toNumber(true);
                if (object.filename != null)
                    if ($util.Long)
                        (message.filename = $util.Long.fromValue(object.filename)).unsigned = false;
                    else if (typeof object.filename === "string")
                        message.filename = parseInt(object.filename, 10);
                    else if (typeof object.filename === "number")
                        message.filename = object.filename;
                    else if (typeof object.filename === "object")
                        message.filename = new $util.LongBits(object.filename.low >>> 0, object.filename.high >>> 0).toNumber();
                if (object.buildId != null)
                    if ($util.Long)
                        (message.buildId = $util.Long.fromValue(object.buildId)).unsigned = false;
                    else if (typeof object.buildId === "string")
                        message.buildId = parseInt(object.buildId, 10);
                    else if (typeof object.buildId === "number")
                        message.buildId = object.buildId;
                    else if (typeof object.buildId === "object")
                        message.buildId = new $util.LongBits(object.buildId.low >>> 0, object.buildId.high >>> 0).toNumber();
                if (object.hasFunctions != null)
                    message.hasFunctions = Boolean(object.hasFunctions);
                if (object.hasFilenames != null)
                    message.hasFilenames = Boolean(object.hasFilenames);
                if (object.hasLineNumbers != null)
                    message.hasLineNumbers = Boolean(object.hasLineNumbers);
                if (object.hasInlineFrames != null)
                    message.hasInlineFrames = Boolean(object.hasInlineFrames);
                return message;
            };

            /**
             * Creates a plain object from a Mapping message. Also converts values to other types if specified.
             * @function toObject
             * @memberof perftools.profiles.Mapping
             * @static
             * @param {perftools.profiles.Mapping} message Mapping
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Mapping.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.id = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.memoryStart = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.memoryStart = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.memoryLimit = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.memoryLimit = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.fileOffset = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.fileOffset = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.filename = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.filename = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.buildId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.buildId = options.longs === String ? "0" : 0;
                    object.hasFunctions = false;
                    object.hasFilenames = false;
                    object.hasLineNumbers = false;
                    object.hasInlineFrames = false;
                }
                if (message.id != null && message.hasOwnProperty("id"))
                    if (typeof message.id === "number")
                        object.id = options.longs === String ? String(message.id) : message.id;
                    else
                        object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true) : message.id;
                if (message.memoryStart != null && message.hasOwnProperty("memoryStart"))
                    if (typeof message.memoryStart === "number")
                        object.memoryStart = options.longs === String ? String(message.memoryStart) : message.memoryStart;
                    else
                        object.memoryStart = options.longs === String ? $util.Long.prototype.toString.call(message.memoryStart) : options.longs === Number ? new $util.LongBits(message.memoryStart.low >>> 0, message.memoryStart.high >>> 0).toNumber(true) : message.memoryStart;
                if (message.memoryLimit != null && message.hasOwnProperty("memoryLimit"))
                    if (typeof message.memoryLimit === "number")
                        object.memoryLimit = options.longs === String ? String(message.memoryLimit) : message.memoryLimit;
                    else
                        object.memoryLimit = options.longs === String ? $util.Long.prototype.toString.call(message.memoryLimit) : options.longs === Number ? new $util.LongBits(message.memoryLimit.low >>> 0, message.memoryLimit.high >>> 0).toNumber(true) : message.memoryLimit;
                if (message.fileOffset != null && message.hasOwnProperty("fileOffset"))
                    if (typeof message.fileOffset === "number")
                        object.fileOffset = options.longs === String ? String(message.fileOffset) : message.fileOffset;
                    else
                        object.fileOffset = options.longs === String ? $util.Long.prototype.toString.call(message.fileOffset) : options.longs === Number ? new $util.LongBits(message.fileOffset.low >>> 0, message.fileOffset.high >>> 0).toNumber(true) : message.fileOffset;
                if (message.filename != null && message.hasOwnProperty("filename"))
                    if (typeof message.filename === "number")
                        object.filename = options.longs === String ? String(message.filename) : message.filename;
                    else
                        object.filename = options.longs === String ? $util.Long.prototype.toString.call(message.filename) : options.longs === Number ? new $util.LongBits(message.filename.low >>> 0, message.filename.high >>> 0).toNumber() : message.filename;
                if (message.buildId != null && message.hasOwnProperty("buildId"))
                    if (typeof message.buildId === "number")
                        object.buildId = options.longs === String ? String(message.buildId) : message.buildId;
                    else
                        object.buildId = options.longs === String ? $util.Long.prototype.toString.call(message.buildId) : options.longs === Number ? new $util.LongBits(message.buildId.low >>> 0, message.buildId.high >>> 0).toNumber() : message.buildId;
                if (message.hasFunctions != null && message.hasOwnProperty("hasFunctions"))
                    object.hasFunctions = message.hasFunctions;
                if (message.hasFilenames != null && message.hasOwnProperty("hasFilenames"))
                    object.hasFilenames = message.hasFilenames;
                if (message.hasLineNumbers != null && message.hasOwnProperty("hasLineNumbers"))
                    object.hasLineNumbers = message.hasLineNumbers;
                if (message.hasInlineFrames != null && message.hasOwnProperty("hasInlineFrames"))
                    object.hasInlineFrames = message.hasInlineFrames;
                return object;
            };

            /**
             * Converts this Mapping to JSON.
             * @function toJSON
             * @memberof perftools.profiles.Mapping
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Mapping.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Mapping;
        })();

        profiles.Location = (function() {

            /**
             * Properties of a Location.
             * @memberof perftools.profiles
             * @interface ILocation
             * @property {number|Long|null} [id] Location id
             * @property {number|Long|null} [mappingId] Location mappingId
             * @property {number|Long|null} [address] Location address
             * @property {Array.<perftools.profiles.ILine>|null} [line] Location line
             * @property {boolean|null} [isFolded] Location isFolded
             */

            /**
             * Constructs a new Location.
             * @memberof perftools.profiles
             * @classdesc Represents a Location.
             * @implements ILocation
             * @constructor
             * @param {perftools.profiles.ILocation=} [properties] Properties to set
             */
            function Location(properties) {
                this.line = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Location id.
             * @member {number|Long} id
             * @memberof perftools.profiles.Location
             * @instance
             */
            Location.prototype.id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Location mappingId.
             * @member {number|Long} mappingId
             * @memberof perftools.profiles.Location
             * @instance
             */
            Location.prototype.mappingId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Location address.
             * @member {number|Long} address
             * @memberof perftools.profiles.Location
             * @instance
             */
            Location.prototype.address = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Location line.
             * @member {Array.<perftools.profiles.ILine>} line
             * @memberof perftools.profiles.Location
             * @instance
             */
            Location.prototype.line = $util.emptyArray;

            /**
             * Location isFolded.
             * @member {boolean} isFolded
             * @memberof perftools.profiles.Location
             * @instance
             */
            Location.prototype.isFolded = false;

            /**
             * Creates a new Location instance using the specified properties.
             * @function create
             * @memberof perftools.profiles.Location
             * @static
             * @param {perftools.profiles.ILocation=} [properties] Properties to set
             * @returns {perftools.profiles.Location} Location instance
             */
            Location.create = function create(properties) {
                return new Location(properties);
            };

            /**
             * Encodes the specified Location message. Does not implicitly {@link perftools.profiles.Location.verify|verify} messages.
             * @function encode
             * @memberof perftools.profiles.Location
             * @static
             * @param {perftools.profiles.ILocation} message Location message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Location.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.id);
                if (message.mappingId != null && Object.hasOwnProperty.call(message, "mappingId"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.mappingId);
                if (message.address != null && Object.hasOwnProperty.call(message, "address"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.address);
                if (message.line != null && message.line.length)
                    for (var i = 0; i < message.line.length; ++i)
                        $root.perftools.profiles.Line.encode(message.line[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.isFolded != null && Object.hasOwnProperty.call(message, "isFolded"))
                    writer.uint32(/* id 5, wireType 0 =*/40).bool(message.isFolded);
                return writer;
            };

            /**
             * Encodes the specified Location message, length delimited. Does not implicitly {@link perftools.profiles.Location.verify|verify} messages.
             * @function encodeDelimited
             * @memberof perftools.profiles.Location
             * @static
             * @param {perftools.profiles.ILocation} message Location message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Location.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Location message from the specified reader or buffer.
             * @function decode
             * @memberof perftools.profiles.Location
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {perftools.profiles.Location} Location
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Location.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.perftools.profiles.Location();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = reader.uint64();
                        break;
                    case 2:
                        message.mappingId = reader.uint64();
                        break;
                    case 3:
                        message.address = reader.uint64();
                        break;
                    case 4:
                        if (!(message.line && message.line.length))
                            message.line = [];
                        message.line.push($root.perftools.profiles.Line.decode(reader, reader.uint32()));
                        break;
                    case 5:
                        message.isFolded = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Location message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof perftools.profiles.Location
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {perftools.profiles.Location} Location
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Location.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Location message.
             * @function verify
             * @memberof perftools.profiles.Location
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Location.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                        return "id: integer|Long expected";
                if (message.mappingId != null && message.hasOwnProperty("mappingId"))
                    if (!$util.isInteger(message.mappingId) && !(message.mappingId && $util.isInteger(message.mappingId.low) && $util.isInteger(message.mappingId.high)))
                        return "mappingId: integer|Long expected";
                if (message.address != null && message.hasOwnProperty("address"))
                    if (!$util.isInteger(message.address) && !(message.address && $util.isInteger(message.address.low) && $util.isInteger(message.address.high)))
                        return "address: integer|Long expected";
                if (message.line != null && message.hasOwnProperty("line")) {
                    if (!Array.isArray(message.line))
                        return "line: array expected";
                    for (var i = 0; i < message.line.length; ++i) {
                        var error = $root.perftools.profiles.Line.verify(message.line[i]);
                        if (error)
                            return "line." + error;
                    }
                }
                if (message.isFolded != null && message.hasOwnProperty("isFolded"))
                    if (typeof message.isFolded !== "boolean")
                        return "isFolded: boolean expected";
                return null;
            };

            /**
             * Creates a Location message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof perftools.profiles.Location
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {perftools.profiles.Location} Location
             */
            Location.fromObject = function fromObject(object) {
                if (object instanceof $root.perftools.profiles.Location)
                    return object;
                var message = new $root.perftools.profiles.Location();
                if (object.id != null)
                    if ($util.Long)
                        (message.id = $util.Long.fromValue(object.id)).unsigned = true;
                    else if (typeof object.id === "string")
                        message.id = parseInt(object.id, 10);
                    else if (typeof object.id === "number")
                        message.id = object.id;
                    else if (typeof object.id === "object")
                        message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);
                if (object.mappingId != null)
                    if ($util.Long)
                        (message.mappingId = $util.Long.fromValue(object.mappingId)).unsigned = true;
                    else if (typeof object.mappingId === "string")
                        message.mappingId = parseInt(object.mappingId, 10);
                    else if (typeof object.mappingId === "number")
                        message.mappingId = object.mappingId;
                    else if (typeof object.mappingId === "object")
                        message.mappingId = new $util.LongBits(object.mappingId.low >>> 0, object.mappingId.high >>> 0).toNumber(true);
                if (object.address != null)
                    if ($util.Long)
                        (message.address = $util.Long.fromValue(object.address)).unsigned = true;
                    else if (typeof object.address === "string")
                        message.address = parseInt(object.address, 10);
                    else if (typeof object.address === "number")
                        message.address = object.address;
                    else if (typeof object.address === "object")
                        message.address = new $util.LongBits(object.address.low >>> 0, object.address.high >>> 0).toNumber(true);
                if (object.line) {
                    if (!Array.isArray(object.line))
                        throw TypeError(".perftools.profiles.Location.line: array expected");
                    message.line = [];
                    for (var i = 0; i < object.line.length; ++i) {
                        if (typeof object.line[i] !== "object")
                            throw TypeError(".perftools.profiles.Location.line: object expected");
                        message.line[i] = $root.perftools.profiles.Line.fromObject(object.line[i]);
                    }
                }
                if (object.isFolded != null)
                    message.isFolded = Boolean(object.isFolded);
                return message;
            };

            /**
             * Creates a plain object from a Location message. Also converts values to other types if specified.
             * @function toObject
             * @memberof perftools.profiles.Location
             * @static
             * @param {perftools.profiles.Location} message Location
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Location.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.line = [];
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.id = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.mappingId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.mappingId = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.address = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.address = options.longs === String ? "0" : 0;
                    object.isFolded = false;
                }
                if (message.id != null && message.hasOwnProperty("id"))
                    if (typeof message.id === "number")
                        object.id = options.longs === String ? String(message.id) : message.id;
                    else
                        object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true) : message.id;
                if (message.mappingId != null && message.hasOwnProperty("mappingId"))
                    if (typeof message.mappingId === "number")
                        object.mappingId = options.longs === String ? String(message.mappingId) : message.mappingId;
                    else
                        object.mappingId = options.longs === String ? $util.Long.prototype.toString.call(message.mappingId) : options.longs === Number ? new $util.LongBits(message.mappingId.low >>> 0, message.mappingId.high >>> 0).toNumber(true) : message.mappingId;
                if (message.address != null && message.hasOwnProperty("address"))
                    if (typeof message.address === "number")
                        object.address = options.longs === String ? String(message.address) : message.address;
                    else
                        object.address = options.longs === String ? $util.Long.prototype.toString.call(message.address) : options.longs === Number ? new $util.LongBits(message.address.low >>> 0, message.address.high >>> 0).toNumber(true) : message.address;
                if (message.line && message.line.length) {
                    object.line = [];
                    for (var j = 0; j < message.line.length; ++j)
                        object.line[j] = $root.perftools.profiles.Line.toObject(message.line[j], options);
                }
                if (message.isFolded != null && message.hasOwnProperty("isFolded"))
                    object.isFolded = message.isFolded;
                return object;
            };

            /**
             * Converts this Location to JSON.
             * @function toJSON
             * @memberof perftools.profiles.Location
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Location.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Location;
        })();

        profiles.Line = (function() {

            /**
             * Properties of a Line.
             * @memberof perftools.profiles
             * @interface ILine
             * @property {number|Long|null} [functionId] Line functionId
             * @property {number|Long|null} [line] Line line
             */

            /**
             * Constructs a new Line.
             * @memberof perftools.profiles
             * @classdesc Represents a Line.
             * @implements ILine
             * @constructor
             * @param {perftools.profiles.ILine=} [properties] Properties to set
             */
            function Line(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Line functionId.
             * @member {number|Long} functionId
             * @memberof perftools.profiles.Line
             * @instance
             */
            Line.prototype.functionId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Line line.
             * @member {number|Long} line
             * @memberof perftools.profiles.Line
             * @instance
             */
            Line.prototype.line = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new Line instance using the specified properties.
             * @function create
             * @memberof perftools.profiles.Line
             * @static
             * @param {perftools.profiles.ILine=} [properties] Properties to set
             * @returns {perftools.profiles.Line} Line instance
             */
            Line.create = function create(properties) {
                return new Line(properties);
            };

            /**
             * Encodes the specified Line message. Does not implicitly {@link perftools.profiles.Line.verify|verify} messages.
             * @function encode
             * @memberof perftools.profiles.Line
             * @static
             * @param {perftools.profiles.ILine} message Line message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Line.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.functionId != null && Object.hasOwnProperty.call(message, "functionId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.functionId);
                if (message.line != null && Object.hasOwnProperty.call(message, "line"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.line);
                return writer;
            };

            /**
             * Encodes the specified Line message, length delimited. Does not implicitly {@link perftools.profiles.Line.verify|verify} messages.
             * @function encodeDelimited
             * @memberof perftools.profiles.Line
             * @static
             * @param {perftools.profiles.ILine} message Line message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Line.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Line message from the specified reader or buffer.
             * @function decode
             * @memberof perftools.profiles.Line
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {perftools.profiles.Line} Line
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Line.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.perftools.profiles.Line();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.functionId = reader.uint64();
                        break;
                    case 2:
                        message.line = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Line message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof perftools.profiles.Line
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {perftools.profiles.Line} Line
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Line.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Line message.
             * @function verify
             * @memberof perftools.profiles.Line
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Line.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.functionId != null && message.hasOwnProperty("functionId"))
                    if (!$util.isInteger(message.functionId) && !(message.functionId && $util.isInteger(message.functionId.low) && $util.isInteger(message.functionId.high)))
                        return "functionId: integer|Long expected";
                if (message.line != null && message.hasOwnProperty("line"))
                    if (!$util.isInteger(message.line) && !(message.line && $util.isInteger(message.line.low) && $util.isInteger(message.line.high)))
                        return "line: integer|Long expected";
                return null;
            };

            /**
             * Creates a Line message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof perftools.profiles.Line
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {perftools.profiles.Line} Line
             */
            Line.fromObject = function fromObject(object) {
                if (object instanceof $root.perftools.profiles.Line)
                    return object;
                var message = new $root.perftools.profiles.Line();
                if (object.functionId != null)
                    if ($util.Long)
                        (message.functionId = $util.Long.fromValue(object.functionId)).unsigned = true;
                    else if (typeof object.functionId === "string")
                        message.functionId = parseInt(object.functionId, 10);
                    else if (typeof object.functionId === "number")
                        message.functionId = object.functionId;
                    else if (typeof object.functionId === "object")
                        message.functionId = new $util.LongBits(object.functionId.low >>> 0, object.functionId.high >>> 0).toNumber(true);
                if (object.line != null)
                    if ($util.Long)
                        (message.line = $util.Long.fromValue(object.line)).unsigned = false;
                    else if (typeof object.line === "string")
                        message.line = parseInt(object.line, 10);
                    else if (typeof object.line === "number")
                        message.line = object.line;
                    else if (typeof object.line === "object")
                        message.line = new $util.LongBits(object.line.low >>> 0, object.line.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a plain object from a Line message. Also converts values to other types if specified.
             * @function toObject
             * @memberof perftools.profiles.Line
             * @static
             * @param {perftools.profiles.Line} message Line
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Line.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.functionId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.functionId = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.line = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.line = options.longs === String ? "0" : 0;
                }
                if (message.functionId != null && message.hasOwnProperty("functionId"))
                    if (typeof message.functionId === "number")
                        object.functionId = options.longs === String ? String(message.functionId) : message.functionId;
                    else
                        object.functionId = options.longs === String ? $util.Long.prototype.toString.call(message.functionId) : options.longs === Number ? new $util.LongBits(message.functionId.low >>> 0, message.functionId.high >>> 0).toNumber(true) : message.functionId;
                if (message.line != null && message.hasOwnProperty("line"))
                    if (typeof message.line === "number")
                        object.line = options.longs === String ? String(message.line) : message.line;
                    else
                        object.line = options.longs === String ? $util.Long.prototype.toString.call(message.line) : options.longs === Number ? new $util.LongBits(message.line.low >>> 0, message.line.high >>> 0).toNumber() : message.line;
                return object;
            };

            /**
             * Converts this Line to JSON.
             * @function toJSON
             * @memberof perftools.profiles.Line
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Line.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Line;
        })();

        profiles.Function = (function() {

            /**
             * Properties of a Function.
             * @memberof perftools.profiles
             * @interface IFunction
             * @property {number|Long|null} [id] Function id
             * @property {number|Long|null} [name] Function name
             * @property {number|Long|null} [systemName] Function systemName
             * @property {number|Long|null} [filename] Function filename
             * @property {number|Long|null} [startLine] Function startLine
             */

            /**
             * Constructs a new Function.
             * @memberof perftools.profiles
             * @classdesc Represents a Function.
             * @implements IFunction
             * @constructor
             * @param {perftools.profiles.IFunction=} [properties] Properties to set
             */
            function Function(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Function id.
             * @member {number|Long} id
             * @memberof perftools.profiles.Function
             * @instance
             */
            Function.prototype.id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Function name.
             * @member {number|Long} name
             * @memberof perftools.profiles.Function
             * @instance
             */
            Function.prototype.name = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Function systemName.
             * @member {number|Long} systemName
             * @memberof perftools.profiles.Function
             * @instance
             */
            Function.prototype.systemName = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Function filename.
             * @member {number|Long} filename
             * @memberof perftools.profiles.Function
             * @instance
             */
            Function.prototype.filename = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Function startLine.
             * @member {number|Long} startLine
             * @memberof perftools.profiles.Function
             * @instance
             */
            Function.prototype.startLine = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new Function instance using the specified properties.
             * @function create
             * @memberof perftools.profiles.Function
             * @static
             * @param {perftools.profiles.IFunction=} [properties] Properties to set
             * @returns {perftools.profiles.Function} Function instance
             */
            Function.create = function create(properties) {
                return new Function(properties);
            };

            /**
             * Encodes the specified Function message. Does not implicitly {@link perftools.profiles.Function.verify|verify} messages.
             * @function encode
             * @memberof perftools.profiles.Function
             * @static
             * @param {perftools.profiles.IFunction} message Function message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Function.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.id);
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.name);
                if (message.systemName != null && Object.hasOwnProperty.call(message, "systemName"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int64(message.systemName);
                if (message.filename != null && Object.hasOwnProperty.call(message, "filename"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int64(message.filename);
                if (message.startLine != null && Object.hasOwnProperty.call(message, "startLine"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int64(message.startLine);
                return writer;
            };

            /**
             * Encodes the specified Function message, length delimited. Does not implicitly {@link perftools.profiles.Function.verify|verify} messages.
             * @function encodeDelimited
             * @memberof perftools.profiles.Function
             * @static
             * @param {perftools.profiles.IFunction} message Function message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Function.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Function message from the specified reader or buffer.
             * @function decode
             * @memberof perftools.profiles.Function
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {perftools.profiles.Function} Function
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Function.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.perftools.profiles.Function();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = reader.uint64();
                        break;
                    case 2:
                        message.name = reader.int64();
                        break;
                    case 3:
                        message.systemName = reader.int64();
                        break;
                    case 4:
                        message.filename = reader.int64();
                        break;
                    case 5:
                        message.startLine = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Function message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof perftools.profiles.Function
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {perftools.profiles.Function} Function
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Function.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Function message.
             * @function verify
             * @memberof perftools.profiles.Function
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Function.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                        return "id: integer|Long expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isInteger(message.name) && !(message.name && $util.isInteger(message.name.low) && $util.isInteger(message.name.high)))
                        return "name: integer|Long expected";
                if (message.systemName != null && message.hasOwnProperty("systemName"))
                    if (!$util.isInteger(message.systemName) && !(message.systemName && $util.isInteger(message.systemName.low) && $util.isInteger(message.systemName.high)))
                        return "systemName: integer|Long expected";
                if (message.filename != null && message.hasOwnProperty("filename"))
                    if (!$util.isInteger(message.filename) && !(message.filename && $util.isInteger(message.filename.low) && $util.isInteger(message.filename.high)))
                        return "filename: integer|Long expected";
                if (message.startLine != null && message.hasOwnProperty("startLine"))
                    if (!$util.isInteger(message.startLine) && !(message.startLine && $util.isInteger(message.startLine.low) && $util.isInteger(message.startLine.high)))
                        return "startLine: integer|Long expected";
                return null;
            };

            /**
             * Creates a Function message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof perftools.profiles.Function
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {perftools.profiles.Function} Function
             */
            Function.fromObject = function fromObject(object) {
                if (object instanceof $root.perftools.profiles.Function)
                    return object;
                var message = new $root.perftools.profiles.Function();
                if (object.id != null)
                    if ($util.Long)
                        (message.id = $util.Long.fromValue(object.id)).unsigned = true;
                    else if (typeof object.id === "string")
                        message.id = parseInt(object.id, 10);
                    else if (typeof object.id === "number")
                        message.id = object.id;
                    else if (typeof object.id === "object")
                        message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);
                if (object.name != null)
                    if ($util.Long)
                        (message.name = $util.Long.fromValue(object.name)).unsigned = false;
                    else if (typeof object.name === "string")
                        message.name = parseInt(object.name, 10);
                    else if (typeof object.name === "number")
                        message.name = object.name;
                    else if (typeof object.name === "object")
                        message.name = new $util.LongBits(object.name.low >>> 0, object.name.high >>> 0).toNumber();
                if (object.systemName != null)
                    if ($util.Long)
                        (message.systemName = $util.Long.fromValue(object.systemName)).unsigned = false;
                    else if (typeof object.systemName === "string")
                        message.systemName = parseInt(object.systemName, 10);
                    else if (typeof object.systemName === "number")
                        message.systemName = object.systemName;
                    else if (typeof object.systemName === "object")
                        message.systemName = new $util.LongBits(object.systemName.low >>> 0, object.systemName.high >>> 0).toNumber();
                if (object.filename != null)
                    if ($util.Long)
                        (message.filename = $util.Long.fromValue(object.filename)).unsigned = false;
                    else if (typeof object.filename === "string")
                        message.filename = parseInt(object.filename, 10);
                    else if (typeof object.filename === "number")
                        message.filename = object.filename;
                    else if (typeof object.filename === "object")
                        message.filename = new $util.LongBits(object.filename.low >>> 0, object.filename.high >>> 0).toNumber();
                if (object.startLine != null)
                    if ($util.Long)
                        (message.startLine = $util.Long.fromValue(object.startLine)).unsigned = false;
                    else if (typeof object.startLine === "string")
                        message.startLine = parseInt(object.startLine, 10);
                    else if (typeof object.startLine === "number")
                        message.startLine = object.startLine;
                    else if (typeof object.startLine === "object")
                        message.startLine = new $util.LongBits(object.startLine.low >>> 0, object.startLine.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a plain object from a Function message. Also converts values to other types if specified.
             * @function toObject
             * @memberof perftools.profiles.Function
             * @static
             * @param {perftools.profiles.Function} message Function
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Function.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.id = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.name = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.name = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.systemName = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.systemName = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.filename = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.filename = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.startLine = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.startLine = options.longs === String ? "0" : 0;
                }
                if (message.id != null && message.hasOwnProperty("id"))
                    if (typeof message.id === "number")
                        object.id = options.longs === String ? String(message.id) : message.id;
                    else
                        object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true) : message.id;
                if (message.name != null && message.hasOwnProperty("name"))
                    if (typeof message.name === "number")
                        object.name = options.longs === String ? String(message.name) : message.name;
                    else
                        object.name = options.longs === String ? $util.Long.prototype.toString.call(message.name) : options.longs === Number ? new $util.LongBits(message.name.low >>> 0, message.name.high >>> 0).toNumber() : message.name;
                if (message.systemName != null && message.hasOwnProperty("systemName"))
                    if (typeof message.systemName === "number")
                        object.systemName = options.longs === String ? String(message.systemName) : message.systemName;
                    else
                        object.systemName = options.longs === String ? $util.Long.prototype.toString.call(message.systemName) : options.longs === Number ? new $util.LongBits(message.systemName.low >>> 0, message.systemName.high >>> 0).toNumber() : message.systemName;
                if (message.filename != null && message.hasOwnProperty("filename"))
                    if (typeof message.filename === "number")
                        object.filename = options.longs === String ? String(message.filename) : message.filename;
                    else
                        object.filename = options.longs === String ? $util.Long.prototype.toString.call(message.filename) : options.longs === Number ? new $util.LongBits(message.filename.low >>> 0, message.filename.high >>> 0).toNumber() : message.filename;
                if (message.startLine != null && message.hasOwnProperty("startLine"))
                    if (typeof message.startLine === "number")
                        object.startLine = options.longs === String ? String(message.startLine) : message.startLine;
                    else
                        object.startLine = options.longs === String ? $util.Long.prototype.toString.call(message.startLine) : options.longs === Number ? new $util.LongBits(message.startLine.low >>> 0, message.startLine.high >>> 0).toNumber() : message.startLine;
                return object;
            };

            /**
             * Converts this Function to JSON.
             * @function toJSON
             * @memberof perftools.profiles.Function
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Function.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Function;
        })();

        return profiles;
    })();

    return perftools;
})();

module.exports = $root;


/***/ }),

/***/ "../../node_modules/decode-uri-component/index.js":
/*!*************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/decode-uri-component/index.js ***!
  \*************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var token = '%[a-f0-9]{2}';
var singleMatcher = new RegExp(token, 'gi');
var multiMatcher = new RegExp('(' + token + ')+', 'gi');

function decodeComponents(components, split) {
	try {
		// Try to decode the entire string first
		return decodeURIComponent(components.join(''));
	} catch (err) {
		// Do nothing
	}

	if (components.length === 1) {
		return components;
	}

	split = split || 1;

	// Split the array in 2 parts
	var left = components.slice(0, split);
	var right = components.slice(split);

	return Array.prototype.concat.call([], decodeComponents(left), decodeComponents(right));
}

function decode(input) {
	try {
		return decodeURIComponent(input);
	} catch (err) {
		var tokens = input.match(singleMatcher);

		for (var i = 1; i < tokens.length; i++) {
			input = decodeComponents(tokens, i).join('');

			tokens = input.match(singleMatcher);
		}

		return input;
	}
}

function customDecodeURIComponent(input) {
	// Keep track of all the replacements and prefill the map with the `BOM`
	var replaceMap = {
		'%FE%FF': '\uFFFD\uFFFD',
		'%FF%FE': '\uFFFD\uFFFD'
	};

	var match = multiMatcher.exec(input);
	while (match) {
		try {
			// Decode as big chunks as possible
			replaceMap[match[0]] = decodeURIComponent(match[0]);
		} catch (err) {
			var result = decode(match[0]);

			if (result !== match[0]) {
				replaceMap[match[0]] = result;
			}
		}

		match = multiMatcher.exec(input);
	}

	// Add `%C2` at the end of the map to make sure it does not replace the combinator before everything else
	replaceMap['%C2'] = '\uFFFD';

	var entries = Object.keys(replaceMap);

	for (var i = 0; i < entries.length; i++) {
		// Replace all decoded components
		var key = entries[i];
		input = input.replace(new RegExp(key, 'g'), replaceMap[key]);
	}

	return input;
}

module.exports = function (encodedURI) {
	if (typeof encodedURI !== 'string') {
		throw new TypeError('Expected `encodedURI` to be of type `string`, got `' + typeof encodedURI + '`');
	}

	try {
		encodedURI = encodedURI.replace(/\+/g, ' ');

		// Try the built in decoder first
		return decodeURIComponent(encodedURI);
	} catch (err) {
		// Fallback to a more advanced decoder
		return customDecodeURIComponent(encodedURI);
	}
};


/***/ }),

/***/ "../../node_modules/delay/index.js":
false,

/***/ "../../node_modules/detect-libc/lib/detect-libc.js":
false,

/***/ "../../node_modules/findit2/index.js":
false,

/***/ "../../node_modules/graceful-fs/clone.js":
/*!****************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/graceful-fs/clone.js ***!
  \****************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = clone

var getPrototypeOf = Object.getPrototypeOf || function (obj) {
  return obj.__proto__
}

function clone (obj) {
  if (obj === null || typeof obj !== 'object')
    return obj

  if (obj instanceof Object)
    var copy = { __proto__: getPrototypeOf(obj) }
  else
    var copy = Object.create(null)

  Object.getOwnPropertyNames(obj).forEach(function (key) {
    Object.defineProperty(copy, key, Object.getOwnPropertyDescriptor(obj, key))
  })

  return copy
}


/***/ }),

/***/ "../../node_modules/graceful-fs/graceful-fs.js":
/*!**********************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/graceful-fs/graceful-fs.js ***!
  \**********************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var fs = __webpack_require__(/*! fs */ "fs")
var polyfills = __webpack_require__(/*! ./polyfills.js */ "../../node_modules/graceful-fs/polyfills.js")
var legacy = __webpack_require__(/*! ./legacy-streams.js */ "../../node_modules/graceful-fs/legacy-streams.js")
var clone = __webpack_require__(/*! ./clone.js */ "../../node_modules/graceful-fs/clone.js")

var util = __webpack_require__(/*! util */ "util")

/* istanbul ignore next - node 0.x polyfill */
var gracefulQueue
var previousSymbol

/* istanbul ignore else - node 0.x polyfill */
if (typeof Symbol === 'function' && typeof Symbol.for === 'function') {
  gracefulQueue = Symbol.for('graceful-fs.queue')
  // This is used in testing by future versions
  previousSymbol = Symbol.for('graceful-fs.previous')
} else {
  gracefulQueue = '___graceful-fs.queue'
  previousSymbol = '___graceful-fs.previous'
}

function noop () {}

function publishQueue(context, queue) {
  Object.defineProperty(context, gracefulQueue, {
    get: function() {
      return queue
    }
  })
}

var debug = noop
if (util.debuglog)
  debug = util.debuglog('gfs4')
else if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || ''))
  debug = function() {
    var m = util.format.apply(util, arguments)
    m = 'GFS4: ' + m.split(/\n/).join('\nGFS4: ')
    console.error(m)
  }

// Once time initialization
if (!fs[gracefulQueue]) {
  // This queue can be shared by multiple loaded instances
  var queue = global[gracefulQueue] || []
  publishQueue(fs, queue)

  // Patch fs.close/closeSync to shared queue version, because we need
  // to retry() whenever a close happens *anywhere* in the program.
  // This is essential when multiple graceful-fs instances are
  // in play at the same time.
  fs.close = (function (fs$close) {
    function close (fd, cb) {
      return fs$close.call(fs, fd, function (err) {
        // This function uses the graceful-fs shared queue
        if (!err) {
          resetQueue()
        }

        if (typeof cb === 'function')
          cb.apply(this, arguments)
      })
    }

    Object.defineProperty(close, previousSymbol, {
      value: fs$close
    })
    return close
  })(fs.close)

  fs.closeSync = (function (fs$closeSync) {
    function closeSync (fd) {
      // This function uses the graceful-fs shared queue
      fs$closeSync.apply(fs, arguments)
      resetQueue()
    }

    Object.defineProperty(closeSync, previousSymbol, {
      value: fs$closeSync
    })
    return closeSync
  })(fs.closeSync)

  if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || '')) {
    process.on('exit', function() {
      debug(fs[gracefulQueue])
      __webpack_require__(/*! assert */ "assert").equal(fs[gracefulQueue].length, 0)
    })
  }
}

if (!global[gracefulQueue]) {
  publishQueue(global, fs[gracefulQueue]);
}

module.exports = patch(clone(fs))
if (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs.__patched) {
    module.exports = patch(fs)
    fs.__patched = true;
}

function patch (fs) {
  // Everything that references the open() function needs to be in here
  polyfills(fs)
  fs.gracefulify = patch

  fs.createReadStream = createReadStream
  fs.createWriteStream = createWriteStream
  var fs$readFile = fs.readFile
  fs.readFile = readFile
  function readFile (path, options, cb) {
    if (typeof options === 'function')
      cb = options, options = null

    return go$readFile(path, options, cb)

    function go$readFile (path, options, cb, startTime) {
      return fs$readFile(path, options, function (err) {
        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
          enqueue([go$readFile, [path, options, cb], err, startTime || Date.now(), Date.now()])
        else {
          if (typeof cb === 'function')
            cb.apply(this, arguments)
        }
      })
    }
  }

  var fs$writeFile = fs.writeFile
  fs.writeFile = writeFile
  function writeFile (path, data, options, cb) {
    if (typeof options === 'function')
      cb = options, options = null

    return go$writeFile(path, data, options, cb)

    function go$writeFile (path, data, options, cb, startTime) {
      return fs$writeFile(path, data, options, function (err) {
        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
          enqueue([go$writeFile, [path, data, options, cb], err, startTime || Date.now(), Date.now()])
        else {
          if (typeof cb === 'function')
            cb.apply(this, arguments)
        }
      })
    }
  }

  var fs$appendFile = fs.appendFile
  if (fs$appendFile)
    fs.appendFile = appendFile
  function appendFile (path, data, options, cb) {
    if (typeof options === 'function')
      cb = options, options = null

    return go$appendFile(path, data, options, cb)

    function go$appendFile (path, data, options, cb, startTime) {
      return fs$appendFile(path, data, options, function (err) {
        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
          enqueue([go$appendFile, [path, data, options, cb], err, startTime || Date.now(), Date.now()])
        else {
          if (typeof cb === 'function')
            cb.apply(this, arguments)
        }
      })
    }
  }

  var fs$copyFile = fs.copyFile
  if (fs$copyFile)
    fs.copyFile = copyFile
  function copyFile (src, dest, flags, cb) {
    if (typeof flags === 'function') {
      cb = flags
      flags = 0
    }
    return go$copyFile(src, dest, flags, cb)

    function go$copyFile (src, dest, flags, cb, startTime) {
      return fs$copyFile(src, dest, flags, function (err) {
        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
          enqueue([go$copyFile, [src, dest, flags, cb], err, startTime || Date.now(), Date.now()])
        else {
          if (typeof cb === 'function')
            cb.apply(this, arguments)
        }
      })
    }
  }

  var fs$readdir = fs.readdir
  fs.readdir = readdir
  function readdir (path, options, cb) {
    if (typeof options === 'function')
      cb = options, options = null

    return go$readdir(path, options, cb)

    function go$readdir (path, options, cb, startTime) {
      return fs$readdir(path, options, function (err, files) {
        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
          enqueue([go$readdir, [path, options, cb], err, startTime || Date.now(), Date.now()])
        else {
          if (files && files.sort)
            files.sort()

          if (typeof cb === 'function')
            cb.call(this, err, files)
        }
      })
    }
  }

  if (process.version.substr(0, 4) === 'v0.8') {
    var legStreams = legacy(fs)
    ReadStream = legStreams.ReadStream
    WriteStream = legStreams.WriteStream
  }

  var fs$ReadStream = fs.ReadStream
  if (fs$ReadStream) {
    ReadStream.prototype = Object.create(fs$ReadStream.prototype)
    ReadStream.prototype.open = ReadStream$open
  }

  var fs$WriteStream = fs.WriteStream
  if (fs$WriteStream) {
    WriteStream.prototype = Object.create(fs$WriteStream.prototype)
    WriteStream.prototype.open = WriteStream$open
  }

  Object.defineProperty(fs, 'ReadStream', {
    get: function () {
      return ReadStream
    },
    set: function (val) {
      ReadStream = val
    },
    enumerable: true,
    configurable: true
  })
  Object.defineProperty(fs, 'WriteStream', {
    get: function () {
      return WriteStream
    },
    set: function (val) {
      WriteStream = val
    },
    enumerable: true,
    configurable: true
  })

  // legacy names
  var FileReadStream = ReadStream
  Object.defineProperty(fs, 'FileReadStream', {
    get: function () {
      return FileReadStream
    },
    set: function (val) {
      FileReadStream = val
    },
    enumerable: true,
    configurable: true
  })
  var FileWriteStream = WriteStream
  Object.defineProperty(fs, 'FileWriteStream', {
    get: function () {
      return FileWriteStream
    },
    set: function (val) {
      FileWriteStream = val
    },
    enumerable: true,
    configurable: true
  })

  function ReadStream (path, options) {
    if (this instanceof ReadStream)
      return fs$ReadStream.apply(this, arguments), this
    else
      return ReadStream.apply(Object.create(ReadStream.prototype), arguments)
  }

  function ReadStream$open () {
    var that = this
    open(that.path, that.flags, that.mode, function (err, fd) {
      if (err) {
        if (that.autoClose)
          that.destroy()

        that.emit('error', err)
      } else {
        that.fd = fd
        that.emit('open', fd)
        that.read()
      }
    })
  }

  function WriteStream (path, options) {
    if (this instanceof WriteStream)
      return fs$WriteStream.apply(this, arguments), this
    else
      return WriteStream.apply(Object.create(WriteStream.prototype), arguments)
  }

  function WriteStream$open () {
    var that = this
    open(that.path, that.flags, that.mode, function (err, fd) {
      if (err) {
        that.destroy()
        that.emit('error', err)
      } else {
        that.fd = fd
        that.emit('open', fd)
      }
    })
  }

  function createReadStream (path, options) {
    return new fs.ReadStream(path, options)
  }

  function createWriteStream (path, options) {
    return new fs.WriteStream(path, options)
  }

  var fs$open = fs.open
  fs.open = open
  function open (path, flags, mode, cb) {
    if (typeof mode === 'function')
      cb = mode, mode = null

    return go$open(path, flags, mode, cb)

    function go$open (path, flags, mode, cb, startTime) {
      return fs$open(path, flags, mode, function (err, fd) {
        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
          enqueue([go$open, [path, flags, mode, cb], err, startTime || Date.now(), Date.now()])
        else {
          if (typeof cb === 'function')
            cb.apply(this, arguments)
        }
      })
    }
  }

  return fs
}

function enqueue (elem) {
  debug('ENQUEUE', elem[0].name, elem[1])
  fs[gracefulQueue].push(elem)
  retry()
}

// keep track of the timeout between retry() calls
var retryTimer

// reset the startTime and lastTime to now
// this resets the start of the 60 second overall timeout as well as the
// delay between attempts so that we'll retry these jobs sooner
function resetQueue () {
  var now = Date.now()
  for (var i = 0; i < fs[gracefulQueue].length; ++i) {
    // entries that are only a length of 2 are from an older version, don't
    // bother modifying those since they'll be retried anyway.
    if (fs[gracefulQueue][i].length > 2) {
      fs[gracefulQueue][i][3] = now // startTime
      fs[gracefulQueue][i][4] = now // lastTime
    }
  }
  // call retry to make sure we're actively processing the queue
  retry()
}

function retry () {
  // clear the timer and remove it to help prevent unintended concurrency
  clearTimeout(retryTimer)
  retryTimer = undefined

  if (fs[gracefulQueue].length === 0)
    return

  var elem = fs[gracefulQueue].shift()
  var fn = elem[0]
  var args = elem[1]
  // these items may be unset if they were added by an older graceful-fs
  var err = elem[2]
  var startTime = elem[3]
  var lastTime = elem[4]

  // if we don't have a startTime we have no way of knowing if we've waited
  // long enough, so go ahead and retry this item now
  if (startTime === undefined) {
    debug('RETRY', fn.name, args)
    fn.apply(null, args)
  } else if (Date.now() - startTime >= 60000) {
    // it's been more than 60 seconds total, bail now
    debug('TIMEOUT', fn.name, args)
    var cb = args.pop()
    if (typeof cb === 'function')
      cb.call(null, err)
  } else {
    // the amount of time between the last attempt and right now
    var sinceAttempt = Date.now() - lastTime
    // the amount of time between when we first tried, and when we last tried
    // rounded up to at least 1
    var sinceStart = Math.max(lastTime - startTime, 1)
    // backoff. wait longer than the total time we've been retrying, but only
    // up to a maximum of 100ms
    var desiredDelay = Math.min(sinceStart * 1.2, 100)
    // it's been long enough since the last retry, do it again
    if (sinceAttempt >= desiredDelay) {
      debug('RETRY', fn.name, args)
      fn.apply(null, args.concat([startTime]))
    } else {
      // if we can't do this job yet, push it to the end of the queue
      // and let the next iteration check again
      fs[gracefulQueue].push(elem)
    }
  }

  // schedule our next run if one isn't already scheduled
  if (retryTimer === undefined) {
    retryTimer = setTimeout(retry, 0)
  }
}


/***/ }),

/***/ "../../node_modules/graceful-fs/legacy-streams.js":
/*!*************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/graceful-fs/legacy-streams.js ***!
  \*************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var Stream = __webpack_require__(/*! stream */ "stream").Stream

module.exports = legacy

function legacy (fs) {
  return {
    ReadStream: ReadStream,
    WriteStream: WriteStream
  }

  function ReadStream (path, options) {
    if (!(this instanceof ReadStream)) return new ReadStream(path, options);

    Stream.call(this);

    var self = this;

    this.path = path;
    this.fd = null;
    this.readable = true;
    this.paused = false;

    this.flags = 'r';
    this.mode = 438; /*=0666*/
    this.bufferSize = 64 * 1024;

    options = options || {};

    // Mixin options into this
    var keys = Object.keys(options);
    for (var index = 0, length = keys.length; index < length; index++) {
      var key = keys[index];
      this[key] = options[key];
    }

    if (this.encoding) this.setEncoding(this.encoding);

    if (this.start !== undefined) {
      if ('number' !== typeof this.start) {
        throw TypeError('start must be a Number');
      }
      if (this.end === undefined) {
        this.end = Infinity;
      } else if ('number' !== typeof this.end) {
        throw TypeError('end must be a Number');
      }

      if (this.start > this.end) {
        throw new Error('start must be <= end');
      }

      this.pos = this.start;
    }

    if (this.fd !== null) {
      process.nextTick(function() {
        self._read();
      });
      return;
    }

    fs.open(this.path, this.flags, this.mode, function (err, fd) {
      if (err) {
        self.emit('error', err);
        self.readable = false;
        return;
      }

      self.fd = fd;
      self.emit('open', fd);
      self._read();
    })
  }

  function WriteStream (path, options) {
    if (!(this instanceof WriteStream)) return new WriteStream(path, options);

    Stream.call(this);

    this.path = path;
    this.fd = null;
    this.writable = true;

    this.flags = 'w';
    this.encoding = 'binary';
    this.mode = 438; /*=0666*/
    this.bytesWritten = 0;

    options = options || {};

    // Mixin options into this
    var keys = Object.keys(options);
    for (var index = 0, length = keys.length; index < length; index++) {
      var key = keys[index];
      this[key] = options[key];
    }

    if (this.start !== undefined) {
      if ('number' !== typeof this.start) {
        throw TypeError('start must be a Number');
      }
      if (this.start < 0) {
        throw new Error('start must be >= zero');
      }

      this.pos = this.start;
    }

    this.busy = false;
    this._queue = [];

    if (this.fd === null) {
      this._open = fs.open;
      this._queue.push([this._open, this.path, this.flags, this.mode, undefined]);
      this.flush();
    }
  }
}


/***/ }),

/***/ "../../node_modules/graceful-fs/polyfills.js":
/*!********************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/graceful-fs/polyfills.js ***!
  \********************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var constants = __webpack_require__(/*! constants */ "constants")

var origCwd = process.cwd
var cwd = null

var platform = process.env.GRACEFUL_FS_PLATFORM || process.platform

process.cwd = function() {
  if (!cwd)
    cwd = origCwd.call(process)
  return cwd
}
try {
  process.cwd()
} catch (er) {}

// This check is needed until node.js 12 is required
if (typeof process.chdir === 'function') {
  var chdir = process.chdir
  process.chdir = function (d) {
    cwd = null
    chdir.call(process, d)
  }
  if (Object.setPrototypeOf) Object.setPrototypeOf(process.chdir, chdir)
}

module.exports = patch

function patch (fs) {
  // (re-)implement some things that are known busted or missing.

  // lchmod, broken prior to 0.6.2
  // back-port the fix here.
  if (constants.hasOwnProperty('O_SYMLINK') &&
      process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) {
    patchLchmod(fs)
  }

  // lutimes implementation, or no-op
  if (!fs.lutimes) {
    patchLutimes(fs)
  }

  // https://github.com/isaacs/node-graceful-fs/issues/4
  // Chown should not fail on einval or eperm if non-root.
  // It should not fail on enosys ever, as this just indicates
  // that a fs doesn't support the intended operation.

  fs.chown = chownFix(fs.chown)
  fs.fchown = chownFix(fs.fchown)
  fs.lchown = chownFix(fs.lchown)

  fs.chmod = chmodFix(fs.chmod)
  fs.fchmod = chmodFix(fs.fchmod)
  fs.lchmod = chmodFix(fs.lchmod)

  fs.chownSync = chownFixSync(fs.chownSync)
  fs.fchownSync = chownFixSync(fs.fchownSync)
  fs.lchownSync = chownFixSync(fs.lchownSync)

  fs.chmodSync = chmodFixSync(fs.chmodSync)
  fs.fchmodSync = chmodFixSync(fs.fchmodSync)
  fs.lchmodSync = chmodFixSync(fs.lchmodSync)

  fs.stat = statFix(fs.stat)
  fs.fstat = statFix(fs.fstat)
  fs.lstat = statFix(fs.lstat)

  fs.statSync = statFixSync(fs.statSync)
  fs.fstatSync = statFixSync(fs.fstatSync)
  fs.lstatSync = statFixSync(fs.lstatSync)

  // if lchmod/lchown do not exist, then make them no-ops
  if (!fs.lchmod) {
    fs.lchmod = function (path, mode, cb) {
      if (cb) process.nextTick(cb)
    }
    fs.lchmodSync = function () {}
  }
  if (!fs.lchown) {
    fs.lchown = function (path, uid, gid, cb) {
      if (cb) process.nextTick(cb)
    }
    fs.lchownSync = function () {}
  }

  // on Windows, A/V software can lock the directory, causing this
  // to fail with an EACCES or EPERM if the directory contains newly
  // created files.  Try again on failure, for up to 60 seconds.

  // Set the timeout this long because some Windows Anti-Virus, such as Parity
  // bit9, may lock files for up to a minute, causing npm package install
  // failures. Also, take care to yield the scheduler. Windows scheduling gives
  // CPU to a busy looping process, which can cause the program causing the lock
  // contention to be starved of CPU by node, so the contention doesn't resolve.
  if (platform === "win32") {
    fs.rename = (function (fs$rename) { return function (from, to, cb) {
      var start = Date.now()
      var backoff = 0;
      fs$rename(from, to, function CB (er) {
        if (er
            && (er.code === "EACCES" || er.code === "EPERM")
            && Date.now() - start < 60000) {
          setTimeout(function() {
            fs.stat(to, function (stater, st) {
              if (stater && stater.code === "ENOENT")
                fs$rename(from, to, CB);
              else
                cb(er)
            })
          }, backoff)
          if (backoff < 100)
            backoff += 10;
          return;
        }
        if (cb) cb(er)
      })
    }})(fs.rename)
  }

  // if read() returns EAGAIN, then just try it again.
  fs.read = (function (fs$read) {
    function read (fd, buffer, offset, length, position, callback_) {
      var callback
      if (callback_ && typeof callback_ === 'function') {
        var eagCounter = 0
        callback = function (er, _, __) {
          if (er && er.code === 'EAGAIN' && eagCounter < 10) {
            eagCounter ++
            return fs$read.call(fs, fd, buffer, offset, length, position, callback)
          }
          callback_.apply(this, arguments)
        }
      }
      return fs$read.call(fs, fd, buffer, offset, length, position, callback)
    }

    // This ensures `util.promisify` works as it does for native `fs.read`.
    if (Object.setPrototypeOf) Object.setPrototypeOf(read, fs$read)
    return read
  })(fs.read)

  fs.readSync = (function (fs$readSync) { return function (fd, buffer, offset, length, position) {
    var eagCounter = 0
    while (true) {
      try {
        return fs$readSync.call(fs, fd, buffer, offset, length, position)
      } catch (er) {
        if (er.code === 'EAGAIN' && eagCounter < 10) {
          eagCounter ++
          continue
        }
        throw er
      }
    }
  }})(fs.readSync)

  function patchLchmod (fs) {
    fs.lchmod = function (path, mode, callback) {
      fs.open( path
             , constants.O_WRONLY | constants.O_SYMLINK
             , mode
             , function (err, fd) {
        if (err) {
          if (callback) callback(err)
          return
        }
        // prefer to return the chmod error, if one occurs,
        // but still try to close, and report closing errors if they occur.
        fs.fchmod(fd, mode, function (err) {
          fs.close(fd, function(err2) {
            if (callback) callback(err || err2)
          })
        })
      })
    }

    fs.lchmodSync = function (path, mode) {
      var fd = fs.openSync(path, constants.O_WRONLY | constants.O_SYMLINK, mode)

      // prefer to return the chmod error, if one occurs,
      // but still try to close, and report closing errors if they occur.
      var threw = true
      var ret
      try {
        ret = fs.fchmodSync(fd, mode)
        threw = false
      } finally {
        if (threw) {
          try {
            fs.closeSync(fd)
          } catch (er) {}
        } else {
          fs.closeSync(fd)
        }
      }
      return ret
    }
  }

  function patchLutimes (fs) {
    if (constants.hasOwnProperty("O_SYMLINK")) {
      fs.lutimes = function (path, at, mt, cb) {
        fs.open(path, constants.O_SYMLINK, function (er, fd) {
          if (er) {
            if (cb) cb(er)
            return
          }
          fs.futimes(fd, at, mt, function (er) {
            fs.close(fd, function (er2) {
              if (cb) cb(er || er2)
            })
          })
        })
      }

      fs.lutimesSync = function (path, at, mt) {
        var fd = fs.openSync(path, constants.O_SYMLINK)
        var ret
        var threw = true
        try {
          ret = fs.futimesSync(fd, at, mt)
          threw = false
        } finally {
          if (threw) {
            try {
              fs.closeSync(fd)
            } catch (er) {}
          } else {
            fs.closeSync(fd)
          }
        }
        return ret
      }

    } else {
      fs.lutimes = function (_a, _b, _c, cb) { if (cb) process.nextTick(cb) }
      fs.lutimesSync = function () {}
    }
  }

  function chmodFix (orig) {
    if (!orig) return orig
    return function (target, mode, cb) {
      return orig.call(fs, target, mode, function (er) {
        if (chownErOk(er)) er = null
        if (cb) cb.apply(this, arguments)
      })
    }
  }

  function chmodFixSync (orig) {
    if (!orig) return orig
    return function (target, mode) {
      try {
        return orig.call(fs, target, mode)
      } catch (er) {
        if (!chownErOk(er)) throw er
      }
    }
  }


  function chownFix (orig) {
    if (!orig) return orig
    return function (target, uid, gid, cb) {
      return orig.call(fs, target, uid, gid, function (er) {
        if (chownErOk(er)) er = null
        if (cb) cb.apply(this, arguments)
      })
    }
  }

  function chownFixSync (orig) {
    if (!orig) return orig
    return function (target, uid, gid) {
      try {
        return orig.call(fs, target, uid, gid)
      } catch (er) {
        if (!chownErOk(er)) throw er
      }
    }
  }

  function statFix (orig) {
    if (!orig) return orig
    // Older versions of Node erroneously returned signed integers for
    // uid + gid.
    return function (target, options, cb) {
      if (typeof options === 'function') {
        cb = options
        options = null
      }
      function callback (er, stats) {
        if (stats) {
          if (stats.uid < 0) stats.uid += 0x100000000
          if (stats.gid < 0) stats.gid += 0x100000000
        }
        if (cb) cb.apply(this, arguments)
      }
      return options ? orig.call(fs, target, options, callback)
        : orig.call(fs, target, callback)
    }
  }

  function statFixSync (orig) {
    if (!orig) return orig
    // Older versions of Node erroneously returned signed integers for
    // uid + gid.
    return function (target, options) {
      var stats = options ? orig.call(fs, target, options)
        : orig.call(fs, target)
      if (stats.uid < 0) stats.uid += 0x100000000
      if (stats.gid < 0) stats.gid += 0x100000000
      return stats;
    }
  }

  // ENOSYS means that the fs doesn't support the op. Just ignore
  // that, because it doesn't matter.
  //
  // if there's no getuid, or if getuid() is something other
  // than 0, and the error is EINVAL or EPERM, then just ignore
  // it.
  //
  // This specific case is a silent failure in cp, install, tar,
  // and most other unix tools that manage permissions.
  //
  // When running as root, or if other types of errors are
  // encountered, then it's strict.
  function chownErOk (er) {
    if (!er)
      return true

    if (er.code === "ENOSYS")
      return true

    var nonroot = !process.getuid || process.getuid() !== 0
    if (nonroot) {
      if (er.code === "EINVAL" || er.code === "EPERM")
        return true
    }

    return false
  }
}


/***/ }),

/***/ "../../node_modules/hdr-histogram-js/AbstractHistogram.encoding.js":
/*!******************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/hdr-histogram-js/AbstractHistogram.encoding.js ***!
  \******************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*
 * This is a TypeScript port of the original Java version, which was written by
 * Gil Tene as described in
 * https://github.com/HdrHistogram/HdrHistogram
 * and released to the public domain, as explained at
 * http://creativecommons.org/publicdomain/zero/1.0/
 */
var ByteBuffer_1 = __webpack_require__(/*! ./ByteBuffer */ "../../node_modules/hdr-histogram-js/ByteBuffer.js");
var AbstractHistogram_1 = __webpack_require__(/*! ./AbstractHistogram */ "../../node_modules/hdr-histogram-js/AbstractHistogram.js");
var ZigZagEncoding_1 = __webpack_require__(/*! ./ZigZagEncoding */ "../../node_modules/hdr-histogram-js/ZigZagEncoding.js");
var max = Math.max;
var V2EncodingCookieBase = 0x1c849303;
var V2CompressedEncodingCookieBase = 0x1c849304;
var V2maxWordSizeInBytes = 9; // LEB128-64b9B + ZigZag require up to 9 bytes per word
var encodingCookie = V2EncodingCookieBase | 0x10; // LSBit of wordsize byte indicates TLZE Encoding
var compressedEncodingCookie = V2CompressedEncodingCookieBase | 0x10; // LSBit of wordsize byte indicates TLZE Encoding
function fillBufferFromCountsArray(self, buffer) {
    var countsLimit = self.countsArrayIndex(self.maxValue) + 1;
    var srcIndex = 0;
    while (srcIndex < countsLimit) {
        // V2 encoding format uses a ZigZag LEB128-64b9B encoded long. Positive values are counts,
        // while negative values indicate a repeat zero counts.
        var count = self.getCountAtIndex(srcIndex++);
        if (count < 0) {
            throw new Error("Cannot encode histogram containing negative counts (" +
                count +
                ") at index " +
                srcIndex +
                ", corresponding the value range [" +
                self.lowestEquivalentValue(self.valueFromIndex(srcIndex)) +
                "," +
                self.nextNonEquivalentValue(self.valueFromIndex(srcIndex)) +
                ")");
        }
        // Count trailing 0s (which follow this count):
        var zerosCount = 0;
        if (count == 0) {
            zerosCount = 1;
            while (srcIndex < countsLimit && self.getCountAtIndex(srcIndex) == 0) {
                zerosCount++;
                srcIndex++;
            }
        }
        if (zerosCount > 1) {
            ZigZagEncoding_1.default.encode(buffer, -zerosCount);
        }
        else {
            ZigZagEncoding_1.default.encode(buffer, count);
        }
    }
}
/**
 * Encode this histogram into a ByteBuffer
 * @param buffer The buffer to encode into
 * @return The number of bytes written to the buffer
 */
function encodeIntoByteBuffer(buffer) {
    var self = this;
    var initialPosition = buffer.position;
    buffer.putInt32(encodingCookie);
    buffer.putInt32(0); // Placeholder for payload length in bytes.
    buffer.putInt32(1);
    buffer.putInt32(self.numberOfSignificantValueDigits);
    buffer.putInt64(self.lowestDiscernibleValue);
    buffer.putInt64(self.highestTrackableValue);
    buffer.putInt64(1);
    var payloadStartPosition = buffer.position;
    fillBufferFromCountsArray(self, buffer);
    var backupIndex = buffer.position;
    buffer.position = initialPosition + 4;
    buffer.putInt32(backupIndex - payloadStartPosition); // Record the payload length
    buffer.position = backupIndex;
    return backupIndex - initialPosition;
}
exports.encodeIntoByteBuffer = encodeIntoByteBuffer;
function fillCountsArrayFromSourceBuffer(self, sourceBuffer, lengthInBytes, wordSizeInBytes) {
    if (wordSizeInBytes != 2 &&
        wordSizeInBytes != 4 &&
        wordSizeInBytes != 8 &&
        wordSizeInBytes != V2maxWordSizeInBytes) {
        throw new Error("word size must be 2, 4, 8, or V2maxWordSizeInBytes (" +
            V2maxWordSizeInBytes +
            ") bytes");
    }
    var dstIndex = 0;
    var endPosition = sourceBuffer.position + lengthInBytes;
    while (sourceBuffer.position < endPosition) {
        var zerosCount = 0;
        var count = ZigZagEncoding_1.default.decode(sourceBuffer);
        if (count < 0) {
            zerosCount = -count;
            dstIndex += zerosCount; // No need to set zeros in array. Just skip them.
        }
        else {
            self.setCountAtIndex(dstIndex++, count);
        }
    }
    return dstIndex; // this is the destination length
}
function getCookieBase(cookie) {
    return cookie & ~0xf0;
}
function getWordSizeInBytesFromCookie(cookie) {
    if (getCookieBase(cookie) == V2EncodingCookieBase ||
        getCookieBase(cookie) == V2CompressedEncodingCookieBase) {
        return V2maxWordSizeInBytes;
    }
    var sizeByte = (cookie & 0xf0) >> 4;
    return sizeByte & 0xe;
}
function doDecodeFromByteBuffer(buffer, histogramConstr, minBarForHighestTrackableValue) {
    var cookie = buffer.getInt32();
    var payloadLengthInBytes;
    var numberOfSignificantValueDigits;
    var lowestTrackableUnitValue;
    var highestTrackableValue;
    if (getCookieBase(cookie) === V2EncodingCookieBase) {
        if (getWordSizeInBytesFromCookie(cookie) != V2maxWordSizeInBytes) {
            throw new Error("The buffer does not contain a Histogram (no valid cookie found)");
        }
        payloadLengthInBytes = buffer.getInt32();
        buffer.getInt32(); // normalizingIndexOffset not used
        numberOfSignificantValueDigits = buffer.getInt32();
        lowestTrackableUnitValue = buffer.getInt64();
        highestTrackableValue = buffer.getInt64();
        buffer.getInt64(); // integerToDoubleValueConversionRatio not used
    }
    else {
        throw new Error("The buffer does not contain a Histogram (no valid V2 encoding cookie found)");
    }
    highestTrackableValue = max(highestTrackableValue, minBarForHighestTrackableValue);
    var histogram = new histogramConstr(lowestTrackableUnitValue, highestTrackableValue, numberOfSignificantValueDigits);
    var filledLength = fillCountsArrayFromSourceBuffer(histogram, buffer, payloadLengthInBytes, V2maxWordSizeInBytes);
    histogram.establishInternalTackingValues(filledLength);
    return histogram;
}
exports.doDecodeFromByteBuffer = doDecodeFromByteBuffer;
function findDeflateFunction() {
    try {
        return eval('require("zlib").deflateSync');
    }
    catch (error) {
        var pako = __webpack_require__(/*! pako/lib/deflate */ "../../node_modules/pako/lib/deflate.js");
        return pako.deflate;
    }
}
function findInflateFunction() {
    try {
        return eval('require("zlib").inflateSync');
    }
    catch (error) {
        var pako = __webpack_require__(/*! pako/lib/inflate */ "../../node_modules/pako/lib/inflate.js");
        return pako.inflate;
    }
}
var deflate = findDeflateFunction();
var inflate = findInflateFunction();
function doDecodeFromCompressedByteBuffer(buffer, histogramConstr, minBarForHighestTrackableValue) {
    var initialTargetPosition = buffer.position;
    var cookie = buffer.getInt32();
    if ((cookie & ~0xf0) !== V2CompressedEncodingCookieBase) {
        throw new Error("Encoding not supported, only V2 is supported");
    }
    var lengthOfCompressedContents = buffer.getInt32();
    var uncompressedBuffer = inflate(buffer.data.slice(initialTargetPosition + 8, initialTargetPosition + 8 + lengthOfCompressedContents));
    return doDecodeFromByteBuffer(new ByteBuffer_1.default(uncompressedBuffer), histogramConstr, minBarForHighestTrackableValue);
}
exports.doDecodeFromCompressedByteBuffer = doDecodeFromCompressedByteBuffer;
/**
 * Encode this histogram in compressed form into a byte array
 * @param targetBuffer The buffer to encode into
 * @return The number of bytes written to the array
 */
function encodeIntoCompressedByteBuffer(targetBuffer, compressionLevel) {
    var self = this;
    var intermediateUncompressedByteBuffer = ByteBuffer_1.default.allocate();
    var uncompressedLength = self.encodeIntoByteBuffer(intermediateUncompressedByteBuffer);
    targetBuffer.putInt32(compressedEncodingCookie);
    var compressionOptions = compressionLevel
        ? { level: compressionLevel }
        : {};
    var compressedArray = deflate(intermediateUncompressedByteBuffer.data.slice(0, uncompressedLength), compressionOptions);
    targetBuffer.putInt32(compressedArray.byteLength);
    targetBuffer.putArray(compressedArray);
    return targetBuffer.position;
}
exports.encodeIntoCompressedByteBuffer = encodeIntoCompressedByteBuffer;
AbstractHistogram_1.AbstractHistogram.decodeFromByteBuffer = doDecodeFromByteBuffer;
AbstractHistogram_1.AbstractHistogram.decodeFromCompressedByteBuffer = doDecodeFromCompressedByteBuffer;
AbstractHistogram_1.AbstractHistogram.prototype.encodeIntoByteBuffer = encodeIntoByteBuffer;
AbstractHistogram_1.AbstractHistogram.prototype.encodeIntoCompressedByteBuffer = encodeIntoCompressedByteBuffer;
//# sourceMappingURL=AbstractHistogram.encoding.js.map

/***/ }),

/***/ "../../node_modules/hdr-histogram-js/AbstractHistogram.js":
/*!*********************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/hdr-histogram-js/AbstractHistogram.js ***!
  \*********************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
/*
 * This is a TypeScript port of the original Java version, which was written by
 * Gil Tene as described in
 * https://github.com/HdrHistogram/HdrHistogram
 * and released to the public domain, as explained at
 * http://creativecommons.org/publicdomain/zero/1.0/
 */
var AbstractHistogramBase_1 = __webpack_require__(/*! ./AbstractHistogramBase */ "../../node_modules/hdr-histogram-js/AbstractHistogramBase.js");
var RecordedValuesIterator_1 = __webpack_require__(/*! ./RecordedValuesIterator */ "../../node_modules/hdr-histogram-js/RecordedValuesIterator.js");
var PercentileIterator_1 = __webpack_require__(/*! ./PercentileIterator */ "../../node_modules/hdr-histogram-js/PercentileIterator.js");
var formatters_1 = __webpack_require__(/*! ./formatters */ "../../node_modules/hdr-histogram-js/formatters.js");
var ulp_1 = __webpack_require__(/*! ./ulp */ "../../node_modules/hdr-histogram-js/ulp.js");
var pow = Math.pow, floor = Math.floor, ceil = Math.ceil, log2 = Math.log2, max = Math.max, min = Math.min;
var AbstractHistogram = /** @class */ (function (_super) {
    __extends(AbstractHistogram, _super);
    function AbstractHistogram(lowestDiscernibleValue, highestTrackableValue, numberOfSignificantValueDigits) {
        var _this = _super.call(this) || this;
        _this.maxValue = 0;
        _this.minNonZeroValue = Number.MAX_SAFE_INTEGER;
        // Verify argument validity
        if (lowestDiscernibleValue < 1) {
            throw new Error("lowestDiscernibleValue must be >= 1");
        }
        if (highestTrackableValue < 2 * lowestDiscernibleValue) {
            throw new Error("highestTrackableValue must be >= 2 * lowestDiscernibleValue ( 2 * " + lowestDiscernibleValue + " )");
        }
        if (numberOfSignificantValueDigits < 0 ||
            numberOfSignificantValueDigits > 5) {
            throw new Error("numberOfSignificantValueDigits must be between 0 and 5");
        }
        _this.identity = AbstractHistogramBase_1.AbstractHistogramBase.identityBuilder++;
        _this.init(lowestDiscernibleValue, highestTrackableValue, numberOfSignificantValueDigits, 1.0, 0);
        return _this;
    }
    AbstractHistogram.prototype.updatedMaxValue = function (value) {
        var internalValue = value + this.unitMagnitudeMask;
        this.maxValue = internalValue;
    };
    AbstractHistogram.prototype.updateMinNonZeroValue = function (value) {
        if (value <= this.unitMagnitudeMask) {
            return;
        }
        var internalValue = floor(value / this.lowestDiscernibleValueRounded) *
            this.lowestDiscernibleValueRounded;
        this.minNonZeroValue = internalValue;
    };
    AbstractHistogram.prototype.resetMinNonZeroValue = function (minNonZeroValue) {
        var internalValue = floor(minNonZeroValue / this.lowestDiscernibleValueRounded) *
            this.lowestDiscernibleValueRounded;
        this.minNonZeroValue =
            minNonZeroValue === Number.MAX_SAFE_INTEGER
                ? minNonZeroValue
                : internalValue;
    };
    AbstractHistogram.prototype.init = function (lowestDiscernibleValue, highestTrackableValue, numberOfSignificantValueDigits, integerToDoubleValueConversionRatio, normalizingIndexOffset) {
        this.lowestDiscernibleValue = lowestDiscernibleValue;
        this.highestTrackableValue = highestTrackableValue;
        this.numberOfSignificantValueDigits = numberOfSignificantValueDigits;
        this.integerToDoubleValueConversionRatio = integerToDoubleValueConversionRatio;
        if (normalizingIndexOffset !== 0) {
            this.setNormalizingIndexOffset(normalizingIndexOffset);
        }
        /*
         * Given a 3 decimal point accuracy, the expectation is obviously for "+/- 1 unit at 1000". It also means that
         * it's "ok to be +/- 2 units at 2000". The "tricky" thing is that it is NOT ok to be +/- 2 units at 1999. Only
         * starting at 2000. So internally, we need to maintain single unit resolution to 2x 10^decimalPoints.
         */
        var largestValueWithSingleUnitResolution = 2 * floor(pow(10, numberOfSignificantValueDigits));
        this.unitMagnitude = floor(log2(lowestDiscernibleValue));
        this.lowestDiscernibleValueRounded = pow(2, this.unitMagnitude);
        this.unitMagnitudeMask = this.lowestDiscernibleValueRounded - 1;
        // We need to maintain power-of-two subBucketCount (for clean direct indexing) that is large enough to
        // provide unit resolution to at least largestValueWithSingleUnitResolution. So figure out
        // largestValueWithSingleUnitResolution's nearest power-of-two (rounded up), and use that:
        var subBucketCountMagnitude = ceil(log2(largestValueWithSingleUnitResolution));
        this.subBucketHalfCountMagnitude =
            (subBucketCountMagnitude > 1 ? subBucketCountMagnitude : 1) - 1;
        this.subBucketCount = pow(2, this.subBucketHalfCountMagnitude + 1);
        this.subBucketHalfCount = this.subBucketCount / 2;
        this.subBucketMask =
            (floor(this.subBucketCount) - 1) * pow(2, this.unitMagnitude);
        this.establishSize(highestTrackableValue);
        this.leadingZeroCountBase =
            53 - this.unitMagnitude - this.subBucketHalfCountMagnitude - 1;
        this.percentileIterator = new PercentileIterator_1.default(this, 1);
        this.recordedValuesIterator = new RecordedValuesIterator_1.default(this);
    };
    /**
     * The buckets (each of which has subBucketCount sub-buckets, here assumed to be 2048 as an example) overlap:
     *
     * <pre>
     * The 0'th bucket covers from 0...2047 in multiples of 1, using all 2048 sub-buckets
     * The 1'th bucket covers from 2048..4097 in multiples of 2, using only the top 1024 sub-buckets
     * The 2'th bucket covers from 4096..8191 in multiple of 4, using only the top 1024 sub-buckets
     * ...
     * </pre>
     *
     * Bucket 0 is "special" here. It is the only one that has 2048 entries. All the rest have 1024 entries (because
     * their bottom half overlaps with and is already covered by the all of the previous buckets put together). In other
     * words, the k'th bucket could represent 0 * 2^k to 2048 * 2^k in 2048 buckets with 2^k precision, but the midpoint
     * of 1024 * 2^k = 2048 * 2^(k-1) = the k-1'th bucket's end, so we would use the previous bucket for those lower
     * values as it has better precision.
     */
    AbstractHistogram.prototype.establishSize = function (newHighestTrackableValue) {
        // establish counts array length:
        this.countsArrayLength = this.determineArrayLengthNeeded(newHighestTrackableValue);
        // establish exponent range needed to support the trackable value with no overflow:
        this.bucketCount = this.getBucketsNeededToCoverValue(newHighestTrackableValue);
        // establish the new highest trackable value:
        this.highestTrackableValue = newHighestTrackableValue;
    };
    AbstractHistogram.prototype.determineArrayLengthNeeded = function (highestTrackableValue) {
        if (highestTrackableValue < 2 * this.lowestDiscernibleValue) {
            throw new Error("highestTrackableValue (" +
                highestTrackableValue +
                ") cannot be < (2 * lowestDiscernibleValue)");
        }
        //determine counts array length needed:
        var countsArrayLength = this.getLengthForNumberOfBuckets(this.getBucketsNeededToCoverValue(highestTrackableValue));
        return countsArrayLength;
    };
    /**
     * If we have N such that subBucketCount * 2^N > max value, we need storage for N+1 buckets, each with enough
     * slots to hold the top half of the subBucketCount (the lower half is covered by previous buckets), and the +1
     * being used for the lower half of the 0'th bucket. Or, equivalently, we need 1 more bucket to capture the max
     * value if we consider the sub-bucket length to be halved.
     */
    AbstractHistogram.prototype.getLengthForNumberOfBuckets = function (numberOfBuckets) {
        var lengthNeeded = (numberOfBuckets + 1) * (this.subBucketCount / 2);
        return lengthNeeded;
    };
    AbstractHistogram.prototype.getBucketsNeededToCoverValue = function (value) {
        // the k'th bucket can express from 0 * 2^k to subBucketCount * 2^k in units of 2^k
        var smallestUntrackableValue = this.subBucketCount * pow(2, this.unitMagnitude);
        // always have at least 1 bucket
        var bucketsNeeded = 1;
        while (smallestUntrackableValue <= value) {
            if (smallestUntrackableValue > Number.MAX_SAFE_INTEGER / 2) {
                // TODO check array max size in JavaScript
                // next shift will overflow, meaning that bucket could represent values up to ones greater than
                // Number.MAX_SAFE_INTEGER, so it's the last bucket
                return bucketsNeeded + 1;
            }
            smallestUntrackableValue = smallestUntrackableValue * 2;
            bucketsNeeded++;
        }
        return bucketsNeeded;
    };
    /**
     * Record a value in the histogram
     *
     * @param value The value to be recorded
     * @throws may throw Error if value is exceeds highestTrackableValue
     */
    AbstractHistogram.prototype.recordValue = function (value) {
        this.recordSingleValue(value);
    };
    AbstractHistogram.prototype.recordSingleValue = function (value) {
        var countsIndex = this.countsArrayIndex(value);
        if (countsIndex >= this.countsArrayLength) {
            this.handleRecordException(1, value);
        }
        else {
            this.incrementCountAtIndex(countsIndex);
        }
        this.updateMinAndMax(value);
        this.incrementTotalCount();
    };
    AbstractHistogram.prototype.handleRecordException = function (count, value) {
        if (!this.autoResize) {
            throw new Error("Value " + value + " is outside of histogram covered range");
        }
        this.resize(value);
        var countsIndex = this.countsArrayIndex(value);
        this.addToCountAtIndex(countsIndex, count);
        this.highestTrackableValue = this.highestEquivalentValue(this.valueFromIndex(this.countsArrayLength - 1));
    };
    AbstractHistogram.prototype.countsArrayIndex = function (value) {
        if (value < 0) {
            throw new Error("Histogram recorded value cannot be negative.");
        }
        var bucketIndex = this.getBucketIndex(value);
        var subBucketIndex = this.getSubBucketIndex(value, bucketIndex);
        return this.computeCountsArrayIndex(bucketIndex, subBucketIndex);
    };
    AbstractHistogram.prototype.computeCountsArrayIndex = function (bucketIndex, subBucketIndex) {
        // TODO
        //assert(subBucketIndex < subBucketCount);
        //assert(bucketIndex == 0 || (subBucketIndex >= subBucketHalfCount));
        // Calculate the index for the first entry that will be used in the bucket (halfway through subBucketCount).
        // For bucketIndex 0, all subBucketCount entries may be used, but bucketBaseIndex is still set in the middle.
        var bucketBaseIndex = (bucketIndex + 1) * pow(2, this.subBucketHalfCountMagnitude);
        // Calculate the offset in the bucket. This subtraction will result in a positive value in all buckets except
        // the 0th bucket (since a value in that bucket may be less than half the bucket's 0 to subBucketCount range).
        // However, this works out since we give bucket 0 twice as much space.
        var offsetInBucket = subBucketIndex - this.subBucketHalfCount;
        // The following is the equivalent of ((subBucketIndex  - subBucketHalfCount) + bucketBaseIndex;
        return bucketBaseIndex + offsetInBucket;
    };
    /**
     * @return the lowest (and therefore highest precision) bucket index that can represent the value
     */
    AbstractHistogram.prototype.getBucketIndex = function (value) {
        // Calculates the number of powers of two by which the value is greater than the biggest value that fits in
        // bucket 0. This is the bucket index since each successive bucket can hold a value 2x greater.
        // The mask maps small values to bucket 0.
        // return this.leadingZeroCountBase - Long.numberOfLeadingZeros(value | subBucketMask);
        return max(floor(log2(value)) -
            this.subBucketHalfCountMagnitude -
            this.unitMagnitude, 0);
    };
    AbstractHistogram.prototype.getSubBucketIndex = function (value, bucketIndex) {
        // For bucketIndex 0, this is just value, so it may be anywhere in 0 to subBucketCount.
        // For other bucketIndex, this will always end up in the top half of subBucketCount: assume that for some bucket
        // k > 0, this calculation will yield a value in the bottom half of 0 to subBucketCount. Then, because of how
        // buckets overlap, it would have also been in the top half of bucket k-1, and therefore would have
        // returned k-1 in getBucketIndex(). Since we would then shift it one fewer bits here, it would be twice as big,
        // and therefore in the top half of subBucketCount.
        return floor(value / pow(2, bucketIndex + this.unitMagnitude));
    };
    AbstractHistogram.prototype.updateMinAndMax = function (value) {
        if (value > this.maxValue) {
            this.updatedMaxValue(value);
        }
        if (value < this.minNonZeroValue && value !== 0) {
            this.updateMinNonZeroValue(value);
        }
    };
    /**
     * Get the value at a given percentile.
     * When the given percentile is &gt; 0.0, the value returned is the value that the given
     * percentage of the overall recorded value entries in the histogram are either smaller than
     * or equivalent to. When the given percentile is 0.0, the value returned is the value that all value
     * entries in the histogram are either larger than or equivalent to.
     * <p>
     * Note that two values are "equivalent" in this statement if
     * {@link org.HdrHistogram.AbstractHistogram#valuesAreEquivalent} would return true.
     *
     * @param percentile  The percentile for which to return the associated value
     * @return The value that the given percentage of the overall recorded value entries in the
     * histogram are either smaller than or equivalent to. When the percentile is 0.0, returns the
     * value that all value entries in the histogram are either larger than or equivalent to.
     */
    AbstractHistogram.prototype.getValueAtPercentile = function (percentile) {
        var requestedPercentile = min(percentile, 100); // Truncate down to 100%
        // round count up to nearest integer, to ensure that the largest value that the requested percentile
        // of overall recorded values is actually included. However, this must be done with care:
        //
        // First, Compute fp value for count at the requested percentile. Note that fp result end up
        // being 1 ulp larger than the correct integer count for this percentile:
        var fpCountAtPercentile = (requestedPercentile / 100.0) * this.getTotalCount();
        // Next, round up, but make sure to prevent <= 1 ulp inaccurancies in the above fp math from
        // making us skip a count:
        var countAtPercentile = max(ceil(fpCountAtPercentile - ulp_1.default(fpCountAtPercentile)), // round up
        1 // Make sure we at least reach the first recorded entry
        );
        var totalToCurrentIndex = 0;
        for (var i = 0; i < this.countsArrayLength; i++) {
            totalToCurrentIndex += this.getCountAtIndex(i);
            if (totalToCurrentIndex >= countAtPercentile) {
                var valueAtIndex = this.valueFromIndex(i);
                return percentile === 0.0
                    ? this.lowestEquivalentValue(valueAtIndex)
                    : this.highestEquivalentValue(valueAtIndex);
            }
        }
        return 0;
    };
    AbstractHistogram.prototype.valueFromIndexes = function (bucketIndex, subBucketIndex) {
        return subBucketIndex * pow(2, bucketIndex + this.unitMagnitude);
    };
    AbstractHistogram.prototype.valueFromIndex = function (index) {
        var bucketIndex = floor(index / this.subBucketHalfCount) - 1;
        var subBucketIndex = (index % this.subBucketHalfCount) + this.subBucketHalfCount;
        if (bucketIndex < 0) {
            subBucketIndex -= this.subBucketHalfCount;
            bucketIndex = 0;
        }
        return this.valueFromIndexes(bucketIndex, subBucketIndex);
    };
    /**
     * Get the lowest value that is equivalent to the given value within the histogram's resolution.
     * Where "equivalent" means that value samples recorded for any two
     * equivalent values are counted in a common total count.
     *
     * @param value The given value
     * @return The lowest value that is equivalent to the given value within the histogram's resolution.
     */
    AbstractHistogram.prototype.lowestEquivalentValue = function (value) {
        var bucketIndex = this.getBucketIndex(value);
        var subBucketIndex = this.getSubBucketIndex(value, bucketIndex);
        var thisValueBaseLevel = this.valueFromIndexes(bucketIndex, subBucketIndex);
        return thisValueBaseLevel;
    };
    /**
     * Get the highest value that is equivalent to the given value within the histogram's resolution.
     * Where "equivalent" means that value samples recorded for any two
     * equivalent values are counted in a common total count.
     *
     * @param value The given value
     * @return The highest value that is equivalent to the given value within the histogram's resolution.
     */
    AbstractHistogram.prototype.highestEquivalentValue = function (value) {
        return this.nextNonEquivalentValue(value) - 1;
    };
    /**
     * Get the next value that is not equivalent to the given value within the histogram's resolution.
     * Where "equivalent" means that value samples recorded for any two
     * equivalent values are counted in a common total count.
     *
     * @param value The given value
     * @return The next value that is not equivalent to the given value within the histogram's resolution.
     */
    AbstractHistogram.prototype.nextNonEquivalentValue = function (value) {
        return (this.lowestEquivalentValue(value) + this.sizeOfEquivalentValueRange(value));
    };
    /**
     * Get the size (in value units) of the range of values that are equivalent to the given value within the
     * histogram's resolution. Where "equivalent" means that value samples recorded for any two
     * equivalent values are counted in a common total count.
     *
     * @param value The given value
     * @return The size of the range of values equivalent to the given value.
     */
    AbstractHistogram.prototype.sizeOfEquivalentValueRange = function (value) {
        var bucketIndex = this.getBucketIndex(value);
        var subBucketIndex = this.getSubBucketIndex(value, bucketIndex);
        var distanceToNextValue = pow(2, this.unitMagnitude +
            (subBucketIndex >= this.subBucketCount ? bucketIndex + 1 : bucketIndex));
        return distanceToNextValue;
    };
    /**
     * Get a value that lies in the middle (rounded up) of the range of values equivalent the given value.
     * Where "equivalent" means that value samples recorded for any two
     * equivalent values are counted in a common total count.
     *
     * @param value The given value
     * @return The value lies in the middle (rounded up) of the range of values equivalent the given value.
     */
    AbstractHistogram.prototype.medianEquivalentValue = function (value) {
        return (this.lowestEquivalentValue(value) +
            floor(this.sizeOfEquivalentValueRange(value) / 2));
    };
    /**
     * Get the computed mean value of all recorded values in the histogram
     *
     * @return the mean value (in value units) of the histogram data
     */
    AbstractHistogram.prototype.getMean = function () {
        if (this.getTotalCount() === 0) {
            return 0;
        }
        this.recordedValuesIterator.reset();
        var totalValue = 0;
        while (this.recordedValuesIterator.hasNext()) {
            var iterationValue = this.recordedValuesIterator.next();
            totalValue +=
                this.medianEquivalentValue(iterationValue.valueIteratedTo) *
                    iterationValue.countAtValueIteratedTo;
        }
        return (totalValue * 1.0) / this.getTotalCount();
    };
    /**
     * Get the computed standard deviation of all recorded values in the histogram
     *
     * @return the standard deviation (in value units) of the histogram data
     */
    AbstractHistogram.prototype.getStdDeviation = function () {
        if (this.getTotalCount() === 0) {
            return 0;
        }
        var mean = this.getMean();
        var geometric_deviation_total = 0.0;
        this.recordedValuesIterator.reset();
        while (this.recordedValuesIterator.hasNext()) {
            var iterationValue = this.recordedValuesIterator.next();
            var deviation = this.medianEquivalentValue(iterationValue.valueIteratedTo) - mean;
            geometric_deviation_total +=
                deviation * deviation * iterationValue.countAddedInThisIterationStep;
        }
        var std_deviation = Math.sqrt(geometric_deviation_total / this.getTotalCount());
        return std_deviation;
    };
    /**
     * Produce textual representation of the value distribution of histogram data by percentile. The distribution is
     * output with exponentially increasing resolution, with each exponentially decreasing half-distance containing
     * <i>dumpTicksPerHalf</i> percentile reporting tick points.
     *
     * @param printStream    Stream into which the distribution will be output
     * <p>
     * @param percentileTicksPerHalfDistance  The number of reporting points per exponentially decreasing half-distance
     * <p>
     * @param outputValueUnitScalingRatio    The scaling factor by which to divide histogram recorded values units in
     *                                     output
     * @param useCsvFormat  Output in CSV format if true. Otherwise use plain text form.
     */
    AbstractHistogram.prototype.outputPercentileDistribution = function (percentileTicksPerHalfDistance, outputValueUnitScalingRatio, useCsvFormat) {
        if (percentileTicksPerHalfDistance === void 0) { percentileTicksPerHalfDistance = 5; }
        if (outputValueUnitScalingRatio === void 0) { outputValueUnitScalingRatio = 1; }
        if (useCsvFormat === void 0) { useCsvFormat = false; }
        var result = "";
        if (useCsvFormat) {
            result += '"Value","Percentile","TotalCount","1/(1-Percentile)"\n';
        }
        else {
            result += "       Value     Percentile TotalCount 1/(1-Percentile)\n\n";
        }
        var iterator = this.percentileIterator;
        iterator.reset(percentileTicksPerHalfDistance);
        var lineFormatter;
        var lastLineFormatter;
        if (useCsvFormat) {
            var valueFormatter_1 = formatters_1.floatFormatter(0, this.numberOfSignificantValueDigits);
            var percentileFormatter_1 = formatters_1.floatFormatter(0, 12);
            var lastFormatter_1 = formatters_1.floatFormatter(0, 2);
            lineFormatter = function (iterationValue) {
                return valueFormatter_1(iterationValue.valueIteratedTo / outputValueUnitScalingRatio) +
                    "," +
                    percentileFormatter_1(iterationValue.percentileLevelIteratedTo / 100) +
                    "," +
                    iterationValue.totalCountToThisValue +
                    "," +
                    lastFormatter_1(1 / (1 - iterationValue.percentileLevelIteratedTo / 100)) +
                    "\n";
            };
            lastLineFormatter = function (iterationValue) {
                return valueFormatter_1(iterationValue.valueIteratedTo / outputValueUnitScalingRatio) +
                    "," +
                    percentileFormatter_1(iterationValue.percentileLevelIteratedTo / 100) +
                    "," +
                    iterationValue.totalCountToThisValue +
                    ",Infinity\n";
            };
        }
        else {
            var valueFormatter_2 = formatters_1.floatFormatter(12, this.numberOfSignificantValueDigits);
            var percentileFormatter_2 = formatters_1.floatFormatter(2, 12);
            var totalCountFormatter_1 = formatters_1.integerFormatter(10);
            var lastFormatter_2 = formatters_1.floatFormatter(14, 2);
            lineFormatter = function (iterationValue) {
                return valueFormatter_2(iterationValue.valueIteratedTo / outputValueUnitScalingRatio) +
                    " " +
                    percentileFormatter_2(iterationValue.percentileLevelIteratedTo / 100) +
                    " " +
                    totalCountFormatter_1(iterationValue.totalCountToThisValue) +
                    " " +
                    lastFormatter_2(1 / (1 - iterationValue.percentileLevelIteratedTo / 100)) +
                    "\n";
            };
            lastLineFormatter = function (iterationValue) {
                return valueFormatter_2(iterationValue.valueIteratedTo / outputValueUnitScalingRatio) +
                    " " +
                    percentileFormatter_2(iterationValue.percentileLevelIteratedTo / 100) +
                    " " +
                    totalCountFormatter_1(iterationValue.totalCountToThisValue) +
                    "\n";
            };
        }
        while (iterator.hasNext()) {
            var iterationValue = iterator.next();
            if (iterationValue.percentileLevelIteratedTo < 100) {
                result += lineFormatter(iterationValue);
            }
            else {
                result += lastLineFormatter(iterationValue);
            }
        }
        if (!useCsvFormat) {
            // Calculate and output mean and std. deviation.
            // Note: mean/std. deviation numbers are very often completely irrelevant when
            // data is extremely non-normal in distribution (e.g. in cases of strong multi-modal
            // response time distribution associated with GC pauses). However, reporting these numbers
            // can be very useful for contrasting with the detailed percentile distribution
            // reported by outputPercentileDistribution(). It is not at all surprising to find
            // percentile distributions where results fall many tens or even hundreds of standard
            // deviations away from the mean - such results simply indicate that the data sampled
            // exhibits a very non-normal distribution, highlighting situations for which the std.
            // deviation metric is a useless indicator.
            //
            var formatter = formatters_1.floatFormatter(12, this.numberOfSignificantValueDigits);
            var mean = formatter(this.getMean() / outputValueUnitScalingRatio);
            var std_deviation = formatter(this.getStdDeviation() / outputValueUnitScalingRatio);
            var max_1 = formatter(this.maxValue / outputValueUnitScalingRatio);
            var intFormatter = formatters_1.integerFormatter(12);
            var totalCount = intFormatter(this.getTotalCount());
            var bucketCount = intFormatter(this.bucketCount);
            var subBucketCount = intFormatter(this.subBucketCount);
            result += "#[Mean    = " + mean + ", StdDeviation   = " + std_deviation + "]\n#[Max     = " + max_1 + ", Total count    = " + totalCount + "]\n#[Buckets = " + bucketCount + ", SubBuckets     = " + subBucketCount + "]\n";
        }
        return result;
    };
    /**
     * Provide a (conservatively high) estimate of the Histogram's total footprint in bytes
     *
     * @return a (conservatively high) estimate of the Histogram's total footprint in bytes
     */
    AbstractHistogram.prototype.getEstimatedFootprintInBytes = function () {
        return this._getEstimatedFootprintInBytes();
    };
    AbstractHistogram.prototype.recordSingleValueWithExpectedInterval = function (value, expectedIntervalBetweenValueSamples) {
        this.recordSingleValue(value);
        if (expectedIntervalBetweenValueSamples <= 0) {
            return;
        }
        for (var missingValue = value - expectedIntervalBetweenValueSamples; missingValue >= expectedIntervalBetweenValueSamples; missingValue -= expectedIntervalBetweenValueSamples) {
            this.recordSingleValue(missingValue);
        }
    };
    AbstractHistogram.prototype.recordCountAtValue = function (count, value) {
        var countsIndex = this.countsArrayIndex(value);
        if (countsIndex >= this.countsArrayLength) {
            this.handleRecordException(count, value);
        }
        else {
            this.addToCountAtIndex(countsIndex, count);
        }
        this.updateMinAndMax(value);
        this.addToTotalCount(count);
    };
    /**
     * Record a value in the histogram (adding to the value's current count)
     *
     * @param value The value to be recorded
     * @param count The number of occurrences of this value to record
     * @throws ArrayIndexOutOfBoundsException (may throw) if value is exceeds highestTrackableValue
     */
    AbstractHistogram.prototype.recordValueWithCount = function (value, count) {
        this.recordCountAtValue(count, value);
    };
    /**
     * Record a value in the histogram.
     * <p>
     * To compensate for the loss of sampled values when a recorded value is larger than the expected
     * interval between value samples, Histogram will auto-generate an additional series of decreasingly-smaller
     * (down to the expectedIntervalBetweenValueSamples) value records.
     * <p>
     * Note: This is a at-recording correction method, as opposed to the post-recording correction method provided
     * by {@link #copyCorrectedForCoordinatedOmission(long)}.
     * The two methods are mutually exclusive, and only one of the two should be be used on a given data set to correct
     * for the same coordinated omission issue.
     * <p>
     * See notes in the description of the Histogram calls for an illustration of why this corrective behavior is
     * important.
     *
     * @param value The value to record
     * @param expectedIntervalBetweenValueSamples If expectedIntervalBetweenValueSamples is larger than 0, add
     *                                           auto-generated value records as appropriate if value is larger
     *                                           than expectedIntervalBetweenValueSamples
     * @throws ArrayIndexOutOfBoundsException (may throw) if value is exceeds highestTrackableValue
     */
    AbstractHistogram.prototype.recordValueWithExpectedInterval = function (value, expectedIntervalBetweenValueSamples) {
        this.recordSingleValueWithExpectedInterval(value, expectedIntervalBetweenValueSamples);
    };
    AbstractHistogram.prototype.recordValueWithCountAndExpectedInterval = function (value, count, expectedIntervalBetweenValueSamples) {
        this.recordCountAtValue(count, value);
        if (expectedIntervalBetweenValueSamples <= 0) {
            return;
        }
        for (var missingValue = value - expectedIntervalBetweenValueSamples; missingValue >= expectedIntervalBetweenValueSamples; missingValue -= expectedIntervalBetweenValueSamples) {
            this.recordCountAtValue(count, missingValue);
        }
    };
    /**
     * Add the contents of another histogram to this one, while correcting the incoming data for coordinated omission.
     * <p>
     * To compensate for the loss of sampled values when a recorded value is larger than the expected
     * interval between value samples, the values added will include an auto-generated additional series of
     * decreasingly-smaller (down to the expectedIntervalBetweenValueSamples) value records for each count found
     * in the current histogram that is larger than the expectedIntervalBetweenValueSamples.
     *
     * Note: This is a post-recording correction method, as opposed to the at-recording correction method provided
     * by {@link #recordValueWithExpectedInterval(long, long) recordValueWithExpectedInterval}. The two
     * methods are mutually exclusive, and only one of the two should be be used on a given data set to correct
     * for the same coordinated omission issue.
     * by
     * <p>
     * See notes in the description of the Histogram calls for an illustration of why this corrective behavior is
     * important.
     *
     * @param otherHistogram The other histogram. highestTrackableValue and largestValueWithSingleUnitResolution must match.
     * @param expectedIntervalBetweenValueSamples If expectedIntervalBetweenValueSamples is larger than 0, add
     *                                           auto-generated value records as appropriate if value is larger
     *                                           than expectedIntervalBetweenValueSamples
     * @throws ArrayIndexOutOfBoundsException (may throw) if values exceed highestTrackableValue
     */
    AbstractHistogram.prototype.addWhileCorrectingForCoordinatedOmission = function (otherHistogram, expectedIntervalBetweenValueSamples) {
        var toHistogram = this;
        var otherValues = new RecordedValuesIterator_1.default(otherHistogram);
        while (otherValues.hasNext()) {
            var v = otherValues.next();
            toHistogram.recordValueWithCountAndExpectedInterval(v.valueIteratedTo, v.countAtValueIteratedTo, expectedIntervalBetweenValueSamples);
        }
    };
    /**
     * Add the contents of another histogram to this one.
     * <p>
     * As part of adding the contents, the start/end timestamp range of this histogram will be
     * extended to include the start/end timestamp range of the other histogram.
     *
     * @param otherHistogram The other histogram.
     * @throws (may throw) if values in fromHistogram's are
     * higher than highestTrackableValue.
     */
    AbstractHistogram.prototype.add = function (otherHistogram) {
        var highestRecordableValue = this.highestEquivalentValue(this.valueFromIndex(this.countsArrayLength - 1));
        if (highestRecordableValue < otherHistogram.maxValue) {
            if (!this.autoResize) {
                throw new Error("The other histogram includes values that do not fit in this histogram's range.");
            }
            this.resize(otherHistogram.maxValue);
        }
        if (this.bucketCount === otherHistogram.bucketCount &&
            this.subBucketCount === otherHistogram.subBucketCount &&
            this.unitMagnitude === otherHistogram.unitMagnitude) {
            // Counts arrays are of the same length and meaning, so we can just iterate and add directly:
            var observedOtherTotalCount = 0;
            for (var i = 0; i < otherHistogram.countsArrayLength; i++) {
                var otherCount = otherHistogram.getCountAtIndex(i);
                if (otherCount > 0) {
                    this.addToCountAtIndex(i, otherCount);
                    observedOtherTotalCount += otherCount;
                }
            }
            this.setTotalCount(this.getTotalCount() + observedOtherTotalCount);
            this.updatedMaxValue(max(this.maxValue, otherHistogram.maxValue));
            this.updateMinNonZeroValue(min(this.minNonZeroValue, otherHistogram.minNonZeroValue));
        }
        else {
            // Arrays are not a direct match (or the other could change on the fly in some valid way),
            // so we can't just stream through and add them. Instead, go through the array and add each
            // non-zero value found at it's proper value:
            // Do max value first, to avoid max value updates on each iteration:
            var otherMaxIndex = otherHistogram.countsArrayIndex(otherHistogram.maxValue);
            var otherCount = otherHistogram.getCountAtIndex(otherMaxIndex);
            this.recordCountAtValue(otherCount, otherHistogram.maxValue);
            // Record the remaining values, up to but not including the max value:
            for (var i = 0; i < otherMaxIndex; i++) {
                otherCount = otherHistogram.getCountAtIndex(i);
                if (otherCount > 0) {
                    this.recordCountAtValue(otherCount, otherHistogram.valueFromIndex(i));
                }
            }
        }
        this.startTimeStampMsec = min(this.startTimeStampMsec, otherHistogram.startTimeStampMsec);
        this.endTimeStampMsec = max(this.endTimeStampMsec, otherHistogram.endTimeStampMsec);
    };
    /**
     * Get the count of recorded values at a specific value (to within the histogram resolution at the value level).
     *
     * @param value The value for which to provide the recorded count
     * @return The total count of values recorded in the histogram within the value range that is
     * {@literal >=} lowestEquivalentValue(<i>value</i>) and {@literal <=} highestEquivalentValue(<i>value</i>)
     */
    AbstractHistogram.prototype.getCountAtValue = function (value) {
        var index = min(max(0, this.countsArrayIndex(value)), this.countsArrayLength - 1);
        return this.getCountAtIndex(index);
    };
    /**
     * Subtract the contents of another histogram from this one.
     * <p>
     * The start/end timestamps of this histogram will remain unchanged.
     *
     * @param otherHistogram The other histogram.
     * @throws ArrayIndexOutOfBoundsException (may throw) if values in otherHistogram's are higher than highestTrackableValue.
     *
     */
    AbstractHistogram.prototype.subtract = function (otherHistogram) {
        var highestRecordableValue = this.valueFromIndex(this.countsArrayLength - 1);
        if (highestRecordableValue < otherHistogram.maxValue) {
            if (!this.autoResize) {
                throw new Error("The other histogram includes values that do not fit in this histogram's range.");
            }
            this.resize(otherHistogram.maxValue);
        }
        if (this.bucketCount === otherHistogram.bucketCount &&
            this.subBucketCount === otherHistogram.subBucketCount &&
            this.unitMagnitude === otherHistogram.unitMagnitude) {
            // optim
            // Counts arrays are of the same length and meaning, so we can just iterate and add directly:
            for (var i = 0; i < otherHistogram.countsArrayLength; i++) {
                var otherCount = otherHistogram.getCountAtIndex(i);
                if (otherCount > 0) {
                    this.addToCountAtIndex(i, -otherCount);
                }
            }
        }
        else {
            for (var i = 0; i < otherHistogram.countsArrayLength; i++) {
                var otherCount = otherHistogram.getCountAtIndex(i);
                if (otherCount > 0) {
                    var otherValue = otherHistogram.valueFromIndex(i);
                    if (this.getCountAtValue(otherValue) < otherCount) {
                        throw new Error("otherHistogram count (" +
                            otherCount +
                            ") at value " +
                            otherValue +
                            " is larger than this one's (" +
                            this.getCountAtValue(otherValue) +
                            ")");
                    }
                    this.recordCountAtValue(-otherCount, otherValue);
                }
            }
        }
        // With subtraction, the max and minNonZero values could have changed:
        if (this.getCountAtValue(this.maxValue) <= 0 ||
            this.getCountAtValue(this.minNonZeroValue) <= 0) {
            this.establishInternalTackingValues();
        }
    };
    AbstractHistogram.prototype.establishInternalTackingValues = function (lengthToCover) {
        if (lengthToCover === void 0) { lengthToCover = this.countsArrayLength; }
        this.maxValue = 0;
        this.minNonZeroValue = Number.MAX_VALUE;
        var maxIndex = -1;
        var minNonZeroIndex = -1;
        var observedTotalCount = 0;
        for (var index = 0; index < lengthToCover; index++) {
            var countAtIndex = this.getCountAtIndex(index);
            if (countAtIndex > 0) {
                observedTotalCount += countAtIndex;
                maxIndex = index;
                if (minNonZeroIndex == -1 && index != 0) {
                    minNonZeroIndex = index;
                }
            }
        }
        if (maxIndex >= 0) {
            this.updatedMaxValue(this.highestEquivalentValue(this.valueFromIndex(maxIndex)));
        }
        if (minNonZeroIndex >= 0) {
            this.updateMinNonZeroValue(this.valueFromIndex(minNonZeroIndex));
        }
        this.setTotalCount(observedTotalCount);
    };
    AbstractHistogram.prototype.reset = function () {
        this.clearCounts();
        this.setTotalCount(0);
        this.startTimeStampMsec = 0;
        this.endTimeStampMsec = 0;
        this.tag = AbstractHistogramBase_1.NO_TAG;
        this.maxValue = 0;
        this.minNonZeroValue = Number.MAX_SAFE_INTEGER;
    };
    return AbstractHistogram;
}(AbstractHistogramBase_1.AbstractHistogramBase));
exports.AbstractHistogram = AbstractHistogram;
exports.default = AbstractHistogram;
//# sourceMappingURL=AbstractHistogram.js.map

/***/ }),

/***/ "../../node_modules/hdr-histogram-js/AbstractHistogramBase.js":
/*!*************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/hdr-histogram-js/AbstractHistogramBase.js ***!
  \*************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
/*
 * This is a TypeScript port of the original Java version, which was written by
 * Gil Tene as described in
 * https://github.com/HdrHistogram/HdrHistogram
 * and released to the public domain, as explained at
 * http://creativecommons.org/publicdomain/zero/1.0/
 */
var EncodableHistogram_1 = __webpack_require__(/*! ./EncodableHistogram */ "../../node_modules/hdr-histogram-js/EncodableHistogram.js");
exports.NO_TAG = "NO TAG";
var AbstractHistogramBase = /** @class */ (function (_super) {
    __extends(AbstractHistogramBase, _super);
    //intermediateUncompressedByteBuffer : ByteBuffer = null;
    //intermediateUncompressedByteArray : number[] = null;
    /* useless ?
    getIntegerToDoubleValueConversionRatio(): number {
        return this.integerToDoubleValueConversionRatio;
    }
  
    setIntegerToDoubleValueConversionRatio(integerToDoubleValueConversionRatio: number) {
        this.integerToDoubleValueConversionRatio = integerToDoubleValueConversionRatio;
    }*/
    function AbstractHistogramBase() {
        var _this = _super.call(this) || this;
        _this.autoResize = false;
        _this.startTimeStampMsec = Number.MAX_SAFE_INTEGER;
        _this.endTimeStampMsec = 0;
        _this.tag = exports.NO_TAG;
        _this.integerToDoubleValueConversionRatio = 1.0;
        _this.identity = 0;
        _this.highestTrackableValue = 0;
        _this.lowestDiscernibleValue = 0;
        _this.numberOfSignificantValueDigits = 0;
        _this.bucketCount = 0;
        _this.subBucketCount = 0;
        _this.countsArrayLength = 0;
        _this.wordSizeInBytes = 0;
        return _this;
    }
    return AbstractHistogramBase;
}(EncodableHistogram_1.EncodableHistogram));
exports.AbstractHistogramBase = AbstractHistogramBase;
//# sourceMappingURL=AbstractHistogramBase.js.map

/***/ }),

/***/ "../../node_modules/hdr-histogram-js/AbstractHistogramIterator.js":
/*!*****************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/hdr-histogram-js/AbstractHistogramIterator.js ***!
  \*****************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var HistogramIterationValue_1 = __webpack_require__(/*! ./HistogramIterationValue */ "../../node_modules/hdr-histogram-js/HistogramIterationValue.js");
/**
 * Used for iterating through histogram values.
 */
var AbstractHistogramIterator /* implements Iterator<HistogramIterationValue> */ = /** @class */ (function () {
    function AbstractHistogramIterator() {
        this.currentIterationValue = new HistogramIterationValue_1.default();
    }
    AbstractHistogramIterator.prototype.resetIterator = function (histogram) {
        this.histogram = histogram;
        this.savedHistogramTotalRawCount = histogram.getTotalCount();
        this.arrayTotalCount = histogram.getTotalCount();
        this.currentIndex = 0;
        this.currentValueAtIndex = 0;
        this.nextValueAtIndex = Math.pow(2, histogram.unitMagnitude);
        this.prevValueIteratedTo = 0;
        this.totalCountToPrevIndex = 0;
        this.totalCountToCurrentIndex = 0;
        this.totalValueToCurrentIndex = 0;
        this.countAtThisValue = 0;
        this.freshSubBucket = true;
        this.currentIterationValue.reset();
    };
    /**
     * Returns true if the iteration has more elements. (In other words, returns true if next would return an
     * element rather than throwing an exception.)
     *
     * @return true if the iterator has more elements.
     */
    AbstractHistogramIterator.prototype.hasNext = function () {
        if (this.histogram.getTotalCount() !== this.savedHistogramTotalRawCount) {
            throw "Concurrent Modification Exception";
        }
        return this.totalCountToCurrentIndex < this.arrayTotalCount;
    };
    /**
     * Returns the next element in the iteration.
     *
     * @return the {@link HistogramIterationValue} associated with the next element in the iteration.
     */
    AbstractHistogramIterator.prototype.next = function () {
        // Move through the sub buckets and buckets until we hit the next reporting level:
        while (!this.exhaustedSubBuckets()) {
            this.countAtThisValue = this.histogram.getCountAtIndex(this.currentIndex);
            if (this.freshSubBucket) {
                // Don't add unless we've incremented since last bucket...
                this.totalCountToCurrentIndex += this.countAtThisValue;
                this.totalValueToCurrentIndex +=
                    this.countAtThisValue *
                        this.histogram.highestEquivalentValue(this.currentValueAtIndex);
                this.freshSubBucket = false;
            }
            if (this.reachedIterationLevel()) {
                var valueIteratedTo = this.getValueIteratedTo();
                Object.assign(this.currentIterationValue, {
                    valueIteratedTo: valueIteratedTo,
                    valueIteratedFrom: this.prevValueIteratedTo,
                    countAtValueIteratedTo: this.countAtThisValue,
                    countAddedInThisIterationStep: this.totalCountToCurrentIndex - this.totalCountToPrevIndex,
                    totalCountToThisValue: this.totalCountToCurrentIndex,
                    totalValueToThisValue: this.totalValueToCurrentIndex,
                    percentile: 100 * this.totalCountToCurrentIndex / this.arrayTotalCount,
                    percentileLevelIteratedTo: this.getPercentileIteratedTo()
                });
                this.prevValueIteratedTo = valueIteratedTo;
                this.totalCountToPrevIndex = this.totalCountToCurrentIndex;
                this.incrementIterationLevel();
                if (this.histogram.getTotalCount() !== this.savedHistogramTotalRawCount) {
                    throw new Error("Concurrent Modification Exception");
                }
                return this.currentIterationValue;
            }
            this.incrementSubBucket();
        }
        throw new Error("Index Out Of Bounds Exception");
    };
    AbstractHistogramIterator.prototype.getPercentileIteratedTo = function () {
        return 100 * this.totalCountToCurrentIndex / this.arrayTotalCount;
    };
    AbstractHistogramIterator.prototype.getPercentileIteratedFrom = function () {
        return 100 * this.totalCountToPrevIndex / this.arrayTotalCount;
    };
    AbstractHistogramIterator.prototype.getValueIteratedTo = function () {
        return this.histogram.highestEquivalentValue(this.currentValueAtIndex);
    };
    AbstractHistogramIterator.prototype.exhaustedSubBuckets = function () {
        return this.currentIndex >= this.histogram.countsArrayLength;
    };
    AbstractHistogramIterator.prototype.incrementSubBucket = function () {
        this.freshSubBucket = true;
        this.currentIndex++;
        this.currentValueAtIndex = this.histogram.valueFromIndex(this.currentIndex);
        this.nextValueAtIndex = this.histogram.valueFromIndex(this.currentIndex + 1);
    };
    return AbstractHistogramIterator;
}());
exports.default = AbstractHistogramIterator;
//# sourceMappingURL=AbstractHistogramIterator.js.map

/***/ }),

/***/ "../../node_modules/hdr-histogram-js/ByteBuffer.js":
/*!**************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/hdr-histogram-js/ByteBuffer.js ***!
  \**************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var pow = Math.pow, floor = Math.floor;
var TWO_POW_32 = pow(2, 32);
/**
 * Mimic Java's ByteBufffer with big endian order
 */
var ByteBuffer = /** @class */ (function () {
    function ByteBuffer(data) {
        this.position = 0;
        this.data = data;
        this.int32ArrayForConvert = new Uint32Array(1);
        this.int8ArrayForConvert = new Uint8Array(this.int32ArrayForConvert.buffer);
    }
    ByteBuffer.allocate = function (size) {
        if (size === void 0) { size = 16; }
        return new ByteBuffer(new Uint8Array(size));
    };
    ByteBuffer.prototype.put = function (value) {
        if (this.position === this.data.length) {
            var oldArray = this.data;
            this.data = new Uint8Array(this.data.length * 2);
            this.data.set(oldArray);
        }
        this.data[this.position] = value;
        this.position++;
    };
    ByteBuffer.prototype.putInt32 = function (value) {
        if (this.data.length - this.position < 4) {
            var oldArray = this.data;
            this.data = new Uint8Array(this.data.length * 2 + 4);
            this.data.set(oldArray);
        }
        this.int32ArrayForConvert[0] = value;
        this.data.set(this.int8ArrayForConvert.reverse(), this.position);
        this.position += 4;
    };
    ByteBuffer.prototype.putInt64 = function (value) {
        this.putInt32(floor(value / TWO_POW_32));
        this.putInt32(value);
    };
    ByteBuffer.prototype.putArray = function (array) {
        if (this.data.length - this.position < array.byteLength) {
            var oldArray = this.data;
            this.data = new Uint8Array(this.position + array.byteLength);
            this.data.set(oldArray);
        }
        this.data.set(array, this.position);
        this.position += array.byteLength;
    };
    ByteBuffer.prototype.get = function () {
        var value = this.data[this.position];
        this.position++;
        return value;
    };
    ByteBuffer.prototype.getInt32 = function () {
        this.int8ArrayForConvert.set(this.data.slice(this.position, this.position + 4).reverse());
        var value = this.int32ArrayForConvert[0];
        this.position += 4;
        return value;
    };
    ByteBuffer.prototype.getInt64 = function () {
        var high = this.getInt32();
        var low = this.getInt32();
        return high * TWO_POW_32 + low;
    };
    ByteBuffer.prototype.resetPosition = function () {
        this.position = 0;
    };
    return ByteBuffer;
}());
exports.default = ByteBuffer;
//# sourceMappingURL=ByteBuffer.js.map

/***/ }),

/***/ "../../node_modules/hdr-histogram-js/EncodableHistogram.js":
/*!**********************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/hdr-histogram-js/EncodableHistogram.js ***!
  \**********************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * This is a TypeScript port of the original Java version, which was written by
 * Gil Tene as described in
 * https://github.com/HdrHistogram/HdrHistogram
 * and released to the public domain, as explained at
 * http://creativecommons.org/publicdomain/zero/1.0/
 */
Object.defineProperty(exports, "__esModule", { value: true });
var EncodableHistogram = /** @class */ (function () {
    function EncodableHistogram() {
    }
    return EncodableHistogram;
}());
exports.EncodableHistogram = EncodableHistogram;
//# sourceMappingURL=EncodableHistogram.js.map

/***/ }),

/***/ "../../node_modules/hdr-histogram-js/Float64Histogram.js":
/*!********************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/hdr-histogram-js/Float64Histogram.js ***!
  \********************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
/*
 * This is a TypeScript port of the original Java version, which was written by
 * Gil Tene as described in
 * https://github.com/HdrHistogram/HdrHistogram
 * and released to the public domain, as explained at
 * http://creativecommons.org/publicdomain/zero/1.0/
 */
var AbstractHistogram_1 = __webpack_require__(/*! ./AbstractHistogram */ "../../node_modules/hdr-histogram-js/AbstractHistogram.js");
var Float64Histogram = /** @class */ (function (_super) {
    __extends(Float64Histogram, _super);
    function Float64Histogram(lowestDiscernibleValue, highestTrackableValue, numberOfSignificantValueDigits) {
        var _this = _super.call(this, lowestDiscernibleValue, highestTrackableValue, numberOfSignificantValueDigits) || this;
        _this.totalCount = 0;
        _this.counts = new Float64Array(_this.countsArrayLength);
        return _this;
    }
    Float64Histogram.prototype.clearCounts = function () {
        this.counts.fill(0);
    };
    Float64Histogram.prototype.incrementCountAtIndex = function (index) {
        var currentCount = this.counts[index];
        var newCount = currentCount + 1;
        if (newCount < 0) {
            throw newCount + " would overflow short integer count";
        }
        this.counts[index] = newCount;
    };
    Float64Histogram.prototype.addToCountAtIndex = function (index, value) {
        var currentCount = this.counts[index];
        var newCount = currentCount + value;
        if (newCount < Number.MIN_SAFE_INTEGER ||
            newCount > Number.MAX_SAFE_INTEGER) {
            throw newCount + " would overflow integer count";
        }
        this.counts[index] = newCount;
    };
    Float64Histogram.prototype.setCountAtIndex = function (index, value) {
        if (value < Number.MIN_SAFE_INTEGER || value > Number.MAX_SAFE_INTEGER) {
            throw value + " would overflow integer count";
        }
        this.counts[index] = value;
    };
    Float64Histogram.prototype.resize = function (newHighestTrackableValue) {
        this.establishSize(newHighestTrackableValue);
        var newCounts = new Float64Array(this.countsArrayLength);
        newCounts.set(this.counts);
        this.counts = newCounts;
    };
    Float64Histogram.prototype.setNormalizingIndexOffset = function (normalizingIndexOffset) { };
    Float64Histogram.prototype.incrementTotalCount = function () {
        this.totalCount++;
    };
    Float64Histogram.prototype.addToTotalCount = function (value) {
        this.totalCount += value;
    };
    Float64Histogram.prototype.setTotalCount = function (value) {
        this.totalCount = value;
    };
    Float64Histogram.prototype.getTotalCount = function () {
        return this.totalCount;
    };
    Float64Histogram.prototype.getCountAtIndex = function (index) {
        return this.counts[index];
    };
    Float64Histogram.prototype._getEstimatedFootprintInBytes = function () {
        return 512 + 8 * this.counts.length;
    };
    Float64Histogram.prototype.copyCorrectedForCoordinatedOmission = function (expectedIntervalBetweenValueSamples) {
        var copy = new Float64Histogram(this.lowestDiscernibleValue, this.highestTrackableValue, this.numberOfSignificantValueDigits);
        copy.addWhileCorrectingForCoordinatedOmission(this, expectedIntervalBetweenValueSamples);
        return copy;
    };
    return Float64Histogram;
}(AbstractHistogram_1.default));
exports.default = Float64Histogram;
//# sourceMappingURL=Float64Histogram.js.map

/***/ }),

/***/ "../../node_modules/hdr-histogram-js/HistogramIterationValue.js":
/*!***************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/hdr-histogram-js/HistogramIterationValue.js ***!
  \***************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * This is a TypeScript port of the original Java version, which was written by
 * Gil Tene as described in
 * https://github.com/HdrHistogram/HdrHistogram
 * and released to the public domain, as explained at
 * http://creativecommons.org/publicdomain/zero/1.0/
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Represents a value point iterated through in a Histogram, with associated stats.
 * <ul>
 * <li><b><code>valueIteratedTo</code></b> :<br> The actual value level that was iterated to by the iterator</li>
 * <li><b><code>prevValueIteratedTo</code></b> :<br> The actual value level that was iterated from by the iterator</li>
 * <li><b><code>countAtValueIteratedTo</code></b> :<br> The count of recorded values in the histogram that
 * exactly match this [lowestEquivalentValue(valueIteratedTo)...highestEquivalentValue(valueIteratedTo)] value
 * range.</li>
 * <li><b><code>countAddedInThisIterationStep</code></b> :<br> The count of recorded values in the histogram that
 * were added to the totalCountToThisValue (below) as a result on this iteration step. Since multiple iteration
 * steps may occur with overlapping equivalent value ranges, the count may be lower than the count found at
 * the value (e.g. multiple linear steps or percentile levels can occur within a single equivalent value range)</li>
 * <li><b><code>totalCountToThisValue</code></b> :<br> The total count of all recorded values in the histogram at
 * values equal or smaller than valueIteratedTo.</li>
 * <li><b><code>totalValueToThisValue</code></b> :<br> The sum of all recorded values in the histogram at values
 * equal or smaller than valueIteratedTo.</li>
 * <li><b><code>percentile</code></b> :<br> The percentile of recorded values in the histogram at values equal
 * or smaller than valueIteratedTo.</li>
 * <li><b><code>percentileLevelIteratedTo</code></b> :<br> The percentile level that the iterator returning this
 * HistogramIterationValue had iterated to. Generally, percentileLevelIteratedTo will be equal to or smaller than
 * percentile, but the same value point can contain multiple iteration levels for some iterators. E.g. a
 * PercentileIterator can stop multiple times in the exact same value point (if the count at that value covers a
 * range of multiple percentiles in the requested percentile iteration points).</li>
 * </ul>
 */
var HistogramIterationValue = /** @class */ (function () {
    function HistogramIterationValue() {
        this.reset();
    }
    HistogramIterationValue.prototype.reset = function () {
        this.valueIteratedTo = 0;
        this.valueIteratedFrom = 0;
        this.countAtValueIteratedTo = 0;
        this.countAddedInThisIterationStep = 0;
        this.totalCountToThisValue = 0;
        this.totalValueToThisValue = 0;
        this.percentile = 0.0;
        this.percentileLevelIteratedTo = 0.0;
    };
    return HistogramIterationValue;
}());
exports.default = HistogramIterationValue;
//# sourceMappingURL=HistogramIterationValue.js.map

/***/ }),

/***/ "../../node_modules/hdr-histogram-js/HistogramLogReader.js":
/*!**********************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/hdr-histogram-js/HistogramLogReader.js ***!
  \**********************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*
 * This is a TypeScript port of the original Java version, which was written by
 * Gil Tene as described in
 * https://github.com/HdrHistogram/HdrHistogram
 * and released to the public domain, as explained at
 * http://creativecommons.org/publicdomain/zero/1.0/
 */
var AbstractHistogramBase_1 = __webpack_require__(/*! ./AbstractHistogramBase */ "../../node_modules/hdr-histogram-js/AbstractHistogramBase.js");
var Int32Histogram_1 = __webpack_require__(/*! ./Int32Histogram */ "../../node_modules/hdr-histogram-js/Int32Histogram.js");
var encoding_1 = __webpack_require__(/*! ./encoding */ "../../node_modules/hdr-histogram-js/encoding.js");
var TAG_PREFIX = "Tag=";
var TAG_PREFIX_LENGTH = "Tag=".length;
/**
 * A histogram log reader.
 * <p>
 * Histogram logs are used to capture full fidelity, per-time-interval
 * histograms of a recorded value.
 * <p>
 * For example, a histogram log can be used to capture high fidelity
 * reaction-time logs for some measured system or subsystem component.
 * Such a log would capture a full reaction time histogram for each
 * logged interval, and could be used to later reconstruct a full
 * HdrHistogram of the measured reaction time behavior for any arbitrary
 * time range within the log, by adding [only] the relevant interval
 * histograms.
 * <h3>Histogram log format:</h3>
 * A histogram log file consists of text lines. Lines beginning with
 * the "#" character are optional and treated as comments. Lines
 * containing the legend (starting with "Timestamp") are also optional
 * and ignored in parsing the histogram log. All other lines must
 * be valid interval description lines. Text fields are delimited by
 * commas, spaces.
 * <p>
 * A valid interval description line contains an optional Tag=tagString
 * text field, followed by an interval description.
 * <p>
 * A valid interval description must contain exactly four text fields:
 * <ul>
 * <li>StartTimestamp: The first field must contain a number parse-able as a Double value,
 * representing the start timestamp of the interval in seconds.</li>
 * <li>intervalLength: The second field must contain a number parse-able as a Double value,
 * representing the length of the interval in seconds.</li>
 * <li>Interval_Max: The third field must contain a number parse-able as a Double value,
 * which generally represents the maximum value of the interval histogram.</li>
 * <li>Interval_Compressed_Histogram: The fourth field must contain a text field
 * parse-able as a Base64 text representation of a compressed HdrHistogram.</li>
 * </ul>
 * The log file may contain an optional indication of a starting time. Starting time
 * is indicated using a special comments starting with "#[StartTime: " and followed
 * by a number parse-able as a double, representing the start time (in seconds)
 * that may be added to timestamps in the file to determine an absolute
 * timestamp (e.g. since the epoch) for each interval.
 */
var HistogramLogReader = /** @class */ (function () {
    function HistogramLogReader(logContent, options) {
        var _a;
        this.lines = splitLines(logContent);
        this.currentLineIndex = 0;
        this.histogramConstr = ((_a = options) === null || _a === void 0 ? void 0 : _a.histogramConstr) || Int32Histogram_1.default;
    }
    /**
     * Read the next interval histogram from the log. Returns a Histogram object if
     * an interval line was found, or null if not.
     * <p>Upon encountering any unexpected format errors in reading the next interval
     * from the file, this method will return a null.
     * @return a DecodedInterval, or a null if no appropriate interval found
     */
    HistogramLogReader.prototype.nextIntervalHistogram = function (rangeStartTimeSec, rangeEndTimeSec) {
        if (rangeStartTimeSec === void 0) { rangeStartTimeSec = 0; }
        if (rangeEndTimeSec === void 0) { rangeEndTimeSec = Number.MAX_VALUE; }
        while (this.currentLineIndex < this.lines.length) {
            var currentLine = this.lines[this.currentLineIndex];
            this.currentLineIndex++;
            if (currentLine.startsWith("#[StartTime:")) {
                this.parseStartTimeFromLine(currentLine);
            }
            else if (currentLine.startsWith("#[BaseTime:")) {
                this.parseBaseTimeFromLine(currentLine);
            }
            else if (currentLine.startsWith("#") ||
                currentLine.startsWith('"StartTimestamp"')) {
                // skip legend & meta data for now
            }
            else if (currentLine.includes(",")) {
                var tokens = currentLine.split(",");
                var firstToken = tokens[0];
                var tag = void 0;
                if (firstToken.startsWith(TAG_PREFIX)) {
                    tag = firstToken.substring(TAG_PREFIX_LENGTH);
                    tokens.shift();
                }
                else {
                    tag = AbstractHistogramBase_1.NO_TAG;
                }
                var rawLogTimeStampInSec = tokens[0], rawIntervalLengthSec = tokens[1], base64Histogram = tokens[3];
                var logTimeStampInSec = Number.parseFloat(rawLogTimeStampInSec);
                if (!this.baseTimeSec) {
                    // No explicit base time noted. Deduce from 1st observed time (compared to start time):
                    if (logTimeStampInSec < this.startTimeSec - 365 * 24 * 3600.0) {
                        // Criteria Note: if log timestamp is more than a year in the past (compared to
                        // StartTime), we assume that timestamps in the log are not absolute
                        this.baseTimeSec = this.startTimeSec;
                    }
                    else {
                        // Timestamps are absolute
                        this.baseTimeSec = 0.0;
                    }
                }
                if (rangeEndTimeSec < logTimeStampInSec) {
                    return null;
                }
                if (logTimeStampInSec < rangeStartTimeSec) {
                    continue;
                }
                var histogram = encoding_1.decodeFromCompressedBase64(base64Histogram, this.histogramConstr);
                histogram.startTimeStampMsec =
                    (this.baseTimeSec + logTimeStampInSec) * 1000;
                var intervalLengthSec = Number.parseFloat(rawIntervalLengthSec);
                histogram.endTimeStampMsec =
                    (this.baseTimeSec + logTimeStampInSec + intervalLengthSec) * 1000;
                histogram.tag = tag;
                return histogram;
            }
        }
        return null;
    };
    HistogramLogReader.prototype.parseStartTimeFromLine = function (line) {
        this.startTimeSec = Number.parseFloat(line.split(" ")[1]);
    };
    HistogramLogReader.prototype.parseBaseTimeFromLine = function (line) {
        this.baseTimeSec = Number.parseFloat(line.split(" ")[1]);
    };
    return HistogramLogReader;
}());
var splitLines = function (logContent) { return logContent.split(/\r\n|\r|\n/g); };
var shouldIncludeNoTag = function (lines) {
    return lines.find(function (line) {
        return !line.startsWith("#") &&
            !line.startsWith('"') &&
            !line.startsWith(TAG_PREFIX) &&
            line.includes(",");
    });
};
exports.listTags = function (content) {
    var lines = splitLines(content);
    var tags = lines
        .filter(function (line) { return line.includes(",") && line.startsWith(TAG_PREFIX); })
        .map(function (line) { return line.substring(TAG_PREFIX_LENGTH, line.indexOf(",")); });
    var tagsWithoutDuplicates = new Set(tags);
    var result = Array.from(tagsWithoutDuplicates);
    if (shouldIncludeNoTag(lines)) {
        result.unshift("NO TAG");
    }
    return result;
};
exports.default = HistogramLogReader;
//# sourceMappingURL=HistogramLogReader.js.map

/***/ }),

/***/ "../../node_modules/hdr-histogram-js/HistogramLogWriter.js":
/*!**********************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/hdr-histogram-js/HistogramLogWriter.js ***!
  \**********************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var AbstractHistogramBase_1 = __webpack_require__(/*! ./AbstractHistogramBase */ "../../node_modules/hdr-histogram-js/AbstractHistogramBase.js");
var encoding_1 = __webpack_require__(/*! ./encoding */ "../../node_modules/hdr-histogram-js/encoding.js");
var formatters_1 = __webpack_require__(/*! ./formatters */ "../../node_modules/hdr-histogram-js/formatters.js");
var HISTOGRAM_LOG_FORMAT_VERSION = "1.3";
var timeFormatter = formatters_1.floatFormatter(5, 3);
var HistogramLogWriter = /** @class */ (function () {
    function HistogramLogWriter(log) {
        this.log = log;
        /**
         * Base time to subtract from supplied histogram start/end timestamps when
         * logging based on histogram timestamps.
         * Base time is expected to be in msec since the epoch, as histogram start/end times
         * are typically stamped with absolute times in msec since the epoch.
         */
        this.baseTime = 0;
    }
    /**
     * Output an interval histogram, with the given timestamp information and the [optional] tag
     * associated with the histogram, using a configurable maxValueUnitRatio. (note that the
     * specified timestamp information will be used, and the timestamp information in the actual
     * histogram will be ignored).
     * The max value reported with the interval line will be scaled by the given maxValueUnitRatio.
     * @param startTimeStampSec The start timestamp to log with the interval histogram, in seconds.
     * @param endTimeStampSec The end timestamp to log with the interval histogram, in seconds.
     * @param histogram The interval histogram to log.
     * @param maxValueUnitRatio The ratio by which to divide the histogram's max value when reporting on it.
     */
    HistogramLogWriter.prototype.outputIntervalHistogram = function (histogram, startTimeStampSec, endTimeStampSec, maxValueUnitRatio) {
        if (startTimeStampSec === void 0) { startTimeStampSec = (histogram.startTimeStampMsec - this.baseTime) / 1000; }
        if (endTimeStampSec === void 0) { endTimeStampSec = (histogram.endTimeStampMsec - this.baseTime) / 1000; }
        if (maxValueUnitRatio === void 0) { maxValueUnitRatio = 1000; }
        var base64 = encoding_1.encodeIntoBase64String(histogram);
        var start = timeFormatter(startTimeStampSec);
        var duration = timeFormatter(endTimeStampSec - startTimeStampSec);
        var max = timeFormatter(histogram.maxValue / maxValueUnitRatio);
        var lineContent = start + "," + duration + "," + max + "," + base64 + "\n";
        if (histogram.tag && histogram.tag !== AbstractHistogramBase_1.NO_TAG) {
            this.log("Tag=" + histogram.tag + "," + lineContent);
        }
        else {
            this.log(lineContent);
        }
    };
    /**
     * Log a comment to the log.
     * Comments will be preceded with with the '#' character.
     * @param comment the comment string.
     */
    HistogramLogWriter.prototype.outputComment = function (comment) {
        this.log("#" + comment + "\n");
    };
    /**
     * Log a start time in the log.
     * @param startTimeMsec time (in milliseconds) since the absolute start time (the epoch)
     */
    HistogramLogWriter.prototype.outputStartTime = function (startTimeMsec) {
        this.outputComment("[StartTime: " + formatters_1.floatFormatter(5, 3)(startTimeMsec / 1000) + " (seconds since epoch), " + new Date(startTimeMsec) + "]\n");
    };
    /**
     * Output a legend line to the log.
     */
    HistogramLogWriter.prototype.outputLegend = function () {
        this.log('"StartTimestamp","Interval_Length","Interval_Max","Interval_Compressed_Histogram"\n');
    };
    /**
     * Output a log format version to the log.
     */
    HistogramLogWriter.prototype.outputLogFormatVersion = function () {
        this.outputComment("[Histogram log format version " + HISTOGRAM_LOG_FORMAT_VERSION + "]");
    };
    return HistogramLogWriter;
}());
exports.default = HistogramLogWriter;
//# sourceMappingURL=HistogramLogWriter.js.map

/***/ }),

/***/ "../../node_modules/hdr-histogram-js/Int16Histogram.js":
/*!******************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/hdr-histogram-js/Int16Histogram.js ***!
  \******************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
/*
 * This is a TypeScript port of the original Java version, which was written by
 * Gil Tene as described in
 * https://github.com/HdrHistogram/HdrHistogram
 * and released to the public domain, as explained at
 * http://creativecommons.org/publicdomain/zero/1.0/
 */
var AbstractHistogram_1 = __webpack_require__(/*! ./AbstractHistogram */ "../../node_modules/hdr-histogram-js/AbstractHistogram.js");
var Int16Histogram = /** @class */ (function (_super) {
    __extends(Int16Histogram, _super);
    function Int16Histogram(lowestDiscernibleValue, highestTrackableValue, numberOfSignificantValueDigits) {
        var _this = _super.call(this, lowestDiscernibleValue, highestTrackableValue, numberOfSignificantValueDigits) || this;
        _this.totalCount = 0;
        _this.counts = new Uint16Array(_this.countsArrayLength);
        return _this;
    }
    Int16Histogram.prototype.clearCounts = function () {
        this.counts.fill(0);
    };
    Int16Histogram.prototype.incrementCountAtIndex = function (index) {
        var currentCount = this.counts[index];
        var newCount = currentCount + 1;
        if (newCount < 0) {
            throw newCount + " would overflow short integer count";
        }
        this.counts[index] = newCount;
    };
    Int16Histogram.prototype.addToCountAtIndex = function (index, value) {
        var currentCount = this.counts[index];
        var newCount = currentCount + value;
        if (newCount < Number.MIN_SAFE_INTEGER ||
            newCount > Number.MAX_SAFE_INTEGER) {
            throw newCount + " would overflow integer count";
        }
        this.counts[index] = newCount;
    };
    Int16Histogram.prototype.setCountAtIndex = function (index, value) {
        if (value < Number.MIN_SAFE_INTEGER || value > Number.MAX_SAFE_INTEGER) {
            throw value + " would overflow integer count";
        }
        this.counts[index] = value;
    };
    Int16Histogram.prototype.resize = function (newHighestTrackableValue) {
        this.establishSize(newHighestTrackableValue);
        var newCounts = new Uint16Array(this.countsArrayLength);
        newCounts.set(this.counts);
        this.counts = newCounts;
    };
    Int16Histogram.prototype.setNormalizingIndexOffset = function (normalizingIndexOffset) { };
    Int16Histogram.prototype.incrementTotalCount = function () {
        this.totalCount++;
    };
    Int16Histogram.prototype.addToTotalCount = function (value) {
        this.totalCount += value;
    };
    Int16Histogram.prototype.setTotalCount = function (value) {
        this.totalCount = value;
    };
    Int16Histogram.prototype.getTotalCount = function () {
        return this.totalCount;
    };
    Int16Histogram.prototype.getCountAtIndex = function (index) {
        return this.counts[index];
    };
    Int16Histogram.prototype._getEstimatedFootprintInBytes = function () {
        return 512 + 2 * this.counts.length;
    };
    Int16Histogram.prototype.copyCorrectedForCoordinatedOmission = function (expectedIntervalBetweenValueSamples) {
        var copy = new Int16Histogram(this.lowestDiscernibleValue, this.highestTrackableValue, this.numberOfSignificantValueDigits);
        copy.addWhileCorrectingForCoordinatedOmission(this, expectedIntervalBetweenValueSamples);
        return copy;
    };
    return Int16Histogram;
}(AbstractHistogram_1.default));
exports.default = Int16Histogram;
//# sourceMappingURL=Int16Histogram.js.map

/***/ }),

/***/ "../../node_modules/hdr-histogram-js/Int32Histogram.js":
/*!******************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/hdr-histogram-js/Int32Histogram.js ***!
  \******************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
/*
 * This is a TypeScript port of the original Java version, which was written by
 * Gil Tene as described in
 * https://github.com/HdrHistogram/HdrHistogram
 * and released to the public domain, as explained at
 * http://creativecommons.org/publicdomain/zero/1.0/
 */
var AbstractHistogram_1 = __webpack_require__(/*! ./AbstractHistogram */ "../../node_modules/hdr-histogram-js/AbstractHistogram.js");
var Int32Histogram = /** @class */ (function (_super) {
    __extends(Int32Histogram, _super);
    function Int32Histogram(lowestDiscernibleValue, highestTrackableValue, numberOfSignificantValueDigits) {
        var _this = _super.call(this, lowestDiscernibleValue, highestTrackableValue, numberOfSignificantValueDigits) || this;
        _this.totalCount = 0;
        _this.counts = new Uint32Array(_this.countsArrayLength);
        return _this;
    }
    Int32Histogram.prototype.clearCounts = function () {
        this.counts.fill(0);
    };
    Int32Histogram.prototype.incrementCountAtIndex = function (index) {
        var currentCount = this.counts[index];
        var newCount = currentCount + 1;
        if (newCount < 0) {
            throw newCount + " would overflow short integer count";
        }
        this.counts[index] = newCount;
    };
    Int32Histogram.prototype.addToCountAtIndex = function (index, value) {
        var currentCount = this.counts[index];
        var newCount = currentCount + value;
        if (newCount < Number.MIN_SAFE_INTEGER ||
            newCount > Number.MAX_SAFE_INTEGER) {
            throw newCount + " would overflow integer count";
        }
        this.counts[index] = newCount;
    };
    Int32Histogram.prototype.setCountAtIndex = function (index, value) {
        if (value < Number.MIN_SAFE_INTEGER || value > Number.MAX_SAFE_INTEGER) {
            throw value + " would overflow integer count";
        }
        this.counts[index] = value;
    };
    Int32Histogram.prototype.resize = function (newHighestTrackableValue) {
        this.establishSize(newHighestTrackableValue);
        var newCounts = new Uint32Array(this.countsArrayLength);
        newCounts.set(this.counts);
        this.counts = newCounts;
    };
    Int32Histogram.prototype.setNormalizingIndexOffset = function (normalizingIndexOffset) { };
    Int32Histogram.prototype.incrementTotalCount = function () {
        this.totalCount++;
    };
    Int32Histogram.prototype.addToTotalCount = function (value) {
        this.totalCount += value;
    };
    Int32Histogram.prototype.setTotalCount = function (value) {
        this.totalCount = value;
    };
    Int32Histogram.prototype.getTotalCount = function () {
        return this.totalCount;
    };
    Int32Histogram.prototype.getCountAtIndex = function (index) {
        return this.counts[index];
    };
    Int32Histogram.prototype._getEstimatedFootprintInBytes = function () {
        return 512 + 4 * this.counts.length;
    };
    Int32Histogram.prototype.copyCorrectedForCoordinatedOmission = function (expectedIntervalBetweenValueSamples) {
        var copy = new Int32Histogram(this.lowestDiscernibleValue, this.highestTrackableValue, this.numberOfSignificantValueDigits);
        copy.addWhileCorrectingForCoordinatedOmission(this, expectedIntervalBetweenValueSamples);
        return copy;
    };
    return Int32Histogram;
}(AbstractHistogram_1.default));
exports.default = Int32Histogram;
//# sourceMappingURL=Int32Histogram.js.map

/***/ }),

/***/ "../../node_modules/hdr-histogram-js/Int8Histogram.js":
/*!*****************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/hdr-histogram-js/Int8Histogram.js ***!
  \*****************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
/*
 * This is a TypeScript port of the original Java version, which was written by
 * Gil Tene as described in
 * https://github.com/HdrHistogram/HdrHistogram
 * and released to the public domain, as explained at
 * http://creativecommons.org/publicdomain/zero/1.0/
 */
var AbstractHistogram_1 = __webpack_require__(/*! ./AbstractHistogram */ "../../node_modules/hdr-histogram-js/AbstractHistogram.js");
var Int8Histogram = /** @class */ (function (_super) {
    __extends(Int8Histogram, _super);
    function Int8Histogram(lowestDiscernibleValue, highestTrackableValue, numberOfSignificantValueDigits) {
        var _this = _super.call(this, lowestDiscernibleValue, highestTrackableValue, numberOfSignificantValueDigits) || this;
        _this.totalCount = 0;
        _this.counts = new Uint8Array(_this.countsArrayLength);
        return _this;
    }
    Int8Histogram.prototype.clearCounts = function () {
        this.counts.fill(0);
    };
    Int8Histogram.prototype.incrementCountAtIndex = function (index) {
        var currentCount = this.counts[index];
        var newCount = currentCount + 1;
        if (newCount < 0) {
            throw newCount + " would overflow short integer count";
        }
        this.counts[index] = newCount;
    };
    Int8Histogram.prototype.addToCountAtIndex = function (index, value) {
        var currentCount = this.counts[index];
        var newCount = currentCount + value;
        if (newCount < Number.MIN_SAFE_INTEGER ||
            newCount > Number.MAX_SAFE_INTEGER) {
            throw newCount + " would overflow integer count";
        }
        this.counts[index] = newCount;
    };
    Int8Histogram.prototype.setCountAtIndex = function (index, value) {
        if (value < Number.MIN_SAFE_INTEGER || value > Number.MAX_SAFE_INTEGER) {
            throw value + " would overflow integer count";
        }
        this.counts[index] = value;
    };
    Int8Histogram.prototype.resize = function (newHighestTrackableValue) {
        this.establishSize(newHighestTrackableValue);
        var newCounts = new Uint8Array(this.countsArrayLength);
        newCounts.set(this.counts);
        this.counts = newCounts;
    };
    Int8Histogram.prototype.setNormalizingIndexOffset = function (normalizingIndexOffset) { };
    Int8Histogram.prototype.incrementTotalCount = function () {
        this.totalCount++;
    };
    Int8Histogram.prototype.addToTotalCount = function (value) {
        this.totalCount += value;
    };
    Int8Histogram.prototype.setTotalCount = function (value) {
        this.totalCount = value;
    };
    Int8Histogram.prototype.getTotalCount = function () {
        return this.totalCount;
    };
    Int8Histogram.prototype.getCountAtIndex = function (index) {
        return this.counts[index];
    };
    Int8Histogram.prototype._getEstimatedFootprintInBytes = function () {
        return 512 + this.counts.length;
    };
    Int8Histogram.prototype.copyCorrectedForCoordinatedOmission = function (expectedIntervalBetweenValueSamples) {
        var copy = new Int8Histogram(this.lowestDiscernibleValue, this.highestTrackableValue, this.numberOfSignificantValueDigits);
        copy.addWhileCorrectingForCoordinatedOmission(this, expectedIntervalBetweenValueSamples);
        return copy;
    };
    return Int8Histogram;
}(AbstractHistogram_1.default));
exports.default = Int8Histogram;
//# sourceMappingURL=Int8Histogram.js.map

/***/ }),

/***/ "../../node_modules/hdr-histogram-js/PackedHistogram.js":
/*!*******************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/hdr-histogram-js/PackedHistogram.js ***!
  \*******************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
/*
 * This is a TypeScript port of the original Java version, which was written by
 * Gil Tene as described in
 * https://github.com/HdrHistogram/HdrHistogram
 * and released to the public domain, as explained at
 * http://creativecommons.org/publicdomain/zero/1.0/
 */
var AbstractHistogram_1 = __webpack_require__(/*! ./AbstractHistogram */ "../../node_modules/hdr-histogram-js/AbstractHistogram.js");
var PackedArray_1 = __webpack_require__(/*! ./packedarray/PackedArray */ "../../node_modules/hdr-histogram-js/packedarray/PackedArray.js");
/**
 * <h3>A High Dynamic Range (HDR) Histogram that uses a packed internal representation</h3>
 * <p>
 * {@link PackedHistogram} supports the recording and analyzing sampled data value counts across a configurable
 * integer value range with configurable value precision within the range. Value precision is expressed as the
 * number of significant digits in the value recording, and provides control over value quantization behavior
 * across the value range and the subsequent value resolution at any given level.
 * <p>
 * {@link PackedHistogram} tracks value counts in a packed internal representation optimized
 * for typical histogram recoded values are sparse in the value range and tend to be incremented in small unit counts.
 * This packed representation tends to require significantly smaller amounts of stoarge when compared to unpacked
 * representations, but can incur additional recording cost due to resizing and repacking operations that may
 * occur as previously unrecorded values are encountered.
 * <p>
 * For example, a {@link PackedHistogram} could be configured to track the counts of observed integer values between 0 and
 * 3,600,000,000,000 while maintaining a value precision of 3 significant digits across that range. Value quantization
 * within the range will thus be no larger than 1/1,000th (or 0.1%) of any value. This example Histogram could
 * be used to track and analyze the counts of observed response times ranging between 1 nanosecond and 1 hour
 * in magnitude, while maintaining a value resolution of 1 microsecond up to 1 millisecond, a resolution of
 * 1 millisecond (or better) up to one second, and a resolution of 1 second (or better) up to 1,000 seconds. At its
 * maximum tracked value (1 hour), it would still maintain a resolution of 3.6 seconds (or better).
 * <p>
 * Auto-resizing: When constructed with no specified value range range (or when auto-resize is turned on with {@link
 * Histogram#setAutoResize}) a {@link PackedHistogram} will auto-resize its dynamic range to include recorded values as
 * they are encountered. Note that recording calls that cause auto-resizing may take longer to execute, as resizing
 * incurs allocation and copying of internal data structures.
 * <p>
 */
var PackedHistogram = /** @class */ (function (_super) {
    __extends(PackedHistogram, _super);
    function PackedHistogram(lowestDiscernibleValue, highestTrackableValue, numberOfSignificantValueDigits) {
        var _this = _super.call(this, lowestDiscernibleValue, highestTrackableValue, numberOfSignificantValueDigits) || this;
        _this.totalCount = 0;
        _this.packedCounts = new PackedArray_1.PackedArray(_this.countsArrayLength);
        return _this;
    }
    PackedHistogram.prototype.clearCounts = function () {
        this.packedCounts.clear();
        this.totalCount = 0;
    };
    PackedHistogram.prototype.incrementCountAtIndex = function (index) {
        this.packedCounts.increment(index);
    };
    PackedHistogram.prototype.addToCountAtIndex = function (index, value) {
        this.packedCounts.add(index, value);
    };
    PackedHistogram.prototype.setCountAtIndex = function (index, value) {
        /* TODO move in packed array
        if (value < Number.MIN_SAFE_INTEGER || value > Number.MAX_SAFE_INTEGER) {
          throw value + " would overflow integer count";
        }*/
        this.packedCounts.set(index, value);
    };
    PackedHistogram.prototype.resize = function (newHighestTrackableValue) {
        this.establishSize(newHighestTrackableValue);
        this.packedCounts.setVirtualLength(this.countsArrayLength);
    };
    PackedHistogram.prototype.setNormalizingIndexOffset = function (normalizingIndexOffset) { };
    PackedHistogram.prototype.incrementTotalCount = function () {
        this.totalCount++;
    };
    PackedHistogram.prototype.addToTotalCount = function (value) {
        this.totalCount += value;
    };
    PackedHistogram.prototype.setTotalCount = function (value) {
        this.totalCount = value;
    };
    PackedHistogram.prototype.getTotalCount = function () {
        return this.totalCount;
    };
    PackedHistogram.prototype.getCountAtIndex = function (index) {
        return this.packedCounts.get(index);
    };
    PackedHistogram.prototype._getEstimatedFootprintInBytes = function () {
        return 192 + 8 * this.packedCounts.getPhysicalLength();
    };
    PackedHistogram.prototype.copyCorrectedForCoordinatedOmission = function (expectedIntervalBetweenValueSamples) {
        var copy = new PackedHistogram(this.lowestDiscernibleValue, this.highestTrackableValue, this.numberOfSignificantValueDigits);
        copy.addWhileCorrectingForCoordinatedOmission(this, expectedIntervalBetweenValueSamples);
        return copy;
    };
    return PackedHistogram;
}(AbstractHistogram_1.default));
exports.default = PackedHistogram;
//# sourceMappingURL=PackedHistogram.js.map

/***/ }),

/***/ "../../node_modules/hdr-histogram-js/PercentileIterator.js":
/*!**********************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/hdr-histogram-js/PercentileIterator.js ***!
  \**********************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var AbstractHistogramIterator_1 = __webpack_require__(/*! ./AbstractHistogramIterator */ "../../node_modules/hdr-histogram-js/AbstractHistogramIterator.js");
var pow = Math.pow, floor = Math.floor, log2 = Math.log2;
/**
 * Used for iterating through histogram values according to percentile levels. The iteration is
 * performed in steps that start at 0% and reduce their distance to 100% according to the
 * <i>percentileTicksPerHalfDistance</i> parameter, ultimately reaching 100% when all recorded histogram
 * values are exhausted.
 */
var PercentileIterator = /** @class */ (function (_super) {
    __extends(PercentileIterator, _super);
    /**
     * @param histogram The histogram this iterator will operate on
     * @param percentileTicksPerHalfDistance The number of equal-sized iteration steps per half-distance to 100%.
     */
    function PercentileIterator(histogram, percentileTicksPerHalfDistance) {
        var _this = _super.call(this) || this;
        _this.percentileTicksPerHalfDistance = 0;
        _this.percentileLevelToIterateTo = 0;
        _this.percentileLevelToIterateFrom = 0;
        _this.reachedLastRecordedValue = false;
        _this.doReset(histogram, percentileTicksPerHalfDistance);
        return _this;
    }
    /**
     * Reset iterator for re-use in a fresh iteration over the same histogram data set.
     *
     * @param percentileTicksPerHalfDistance The number of iteration steps per half-distance to 100%.
     */
    PercentileIterator.prototype.reset = function (percentileTicksPerHalfDistance) {
        this.doReset(this.histogram, percentileTicksPerHalfDistance);
    };
    PercentileIterator.prototype.doReset = function (histogram, percentileTicksPerHalfDistance) {
        _super.prototype.resetIterator.call(this, histogram);
        this.percentileTicksPerHalfDistance = percentileTicksPerHalfDistance;
        this.percentileLevelToIterateTo = 0;
        this.percentileLevelToIterateFrom = 0;
        this.reachedLastRecordedValue = false;
    };
    PercentileIterator.prototype.hasNext = function () {
        if (_super.prototype.hasNext.call(this))
            return true;
        if (!this.reachedLastRecordedValue && this.arrayTotalCount > 0) {
            this.percentileLevelToIterateTo = 100;
            this.reachedLastRecordedValue = true;
            return true;
        }
        return false;
    };
    PercentileIterator.prototype.incrementIterationLevel = function () {
        this.percentileLevelToIterateFrom = this.percentileLevelToIterateTo;
        // The choice to maintain fixed-sized "ticks" in each half-distance to 100% [starting
        // from 0%], as opposed to a "tick" size that varies with each interval, was made to
        // make the steps easily comprehensible and readable to humans. The resulting percentile
        // steps are much easier to browse through in a percentile distribution output, for example.
        //
        // We calculate the number of equal-sized "ticks" that the 0-100 range will be divided
        // by at the current scale. The scale is detemined by the percentile level we are
        // iterating to. The following math determines the tick size for the current scale,
        // and maintain a fixed tick size for the remaining "half the distance to 100%"
        // [from either 0% or from the previous half-distance]. When that half-distance is
        // crossed, the scale changes and the tick size is effectively cut in half.
        // percentileTicksPerHalfDistance = 5
        // percentileReportingTicks = 10,
        var percentileReportingTicks = this.percentileTicksPerHalfDistance *
            pow(2, floor(log2(100 / (100 - this.percentileLevelToIterateTo))) + 1);
        this.percentileLevelToIterateTo += 100 / percentileReportingTicks;
    };
    PercentileIterator.prototype.reachedIterationLevel = function () {
        if (this.countAtThisValue === 0) {
            return false;
        }
        var currentPercentile = 100 * this.totalCountToCurrentIndex / this.arrayTotalCount;
        return currentPercentile >= this.percentileLevelToIterateTo;
    };
    PercentileIterator.prototype.getPercentileIteratedTo = function () {
        return this.percentileLevelToIterateTo;
    };
    PercentileIterator.prototype.getPercentileIteratedFrom = function () {
        return this.percentileLevelToIterateFrom;
    };
    return PercentileIterator;
}(AbstractHistogramIterator_1.default));
exports.default = PercentileIterator;
//# sourceMappingURL=PercentileIterator.js.map

/***/ }),

/***/ "../../node_modules/hdr-histogram-js/RecordedValuesIterator.js":
/*!**************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/hdr-histogram-js/RecordedValuesIterator.js ***!
  \**************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * This is a TypeScript port of the original Java version, which was written by
 * Gil Tene as described in
 * https://github.com/HdrHistogram/HdrHistogram
 * and released to the public domain, as explained at
 * http://creativecommons.org/publicdomain/zero/1.0/
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var AbstractHistogramIterator_1 = __webpack_require__(/*! ./AbstractHistogramIterator */ "../../node_modules/hdr-histogram-js/AbstractHistogramIterator.js");
/**
 * Used for iterating through all recorded histogram values using the finest granularity steps supported by the
 * underlying representation. The iteration steps through all non-zero recorded value counts, and terminates when
 * all recorded histogram values are exhausted.
 */
var RecordedValuesIterator = /** @class */ (function (_super) {
    __extends(RecordedValuesIterator, _super);
    /**
     * @param histogram The histogram this iterator will operate on
     */
    function RecordedValuesIterator(histogram) {
        var _this = _super.call(this) || this;
        _this.doReset(histogram);
        return _this;
    }
    /**
     * Reset iterator for re-use in a fresh iteration over the same histogram data set.
     */
    RecordedValuesIterator.prototype.reset = function () {
        this.doReset(this.histogram);
    };
    RecordedValuesIterator.prototype.doReset = function (histogram) {
        _super.prototype.resetIterator.call(this, histogram);
        this.visitedIndex = -1;
    };
    RecordedValuesIterator.prototype.incrementIterationLevel = function () {
        this.visitedIndex = this.currentIndex;
    };
    RecordedValuesIterator.prototype.reachedIterationLevel = function () {
        var currentCount = this.histogram.getCountAtIndex(this.currentIndex);
        return currentCount != 0 && this.visitedIndex !== this.currentIndex;
    };
    return RecordedValuesIterator;
}(AbstractHistogramIterator_1.default));
exports.default = RecordedValuesIterator;
//# sourceMappingURL=RecordedValuesIterator.js.map

/***/ }),

/***/ "../../node_modules/hdr-histogram-js/Recorder.js":
/*!************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/hdr-histogram-js/Recorder.js ***!
  \************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * This is a TypeScript port of the original Java version, which was written by
 * Gil Tene as described in
 * https://github.com/HdrHistogram/HdrHistogram
 * and released to the public domain, as explained at
 * http://creativecommons.org/publicdomain/zero/1.0/
 */
Object.defineProperty(exports, "__esModule", { value: true });
var Int32Histogram_1 = __webpack_require__(/*! ./Int32Histogram */ "../../node_modules/hdr-histogram-js/Int32Histogram.js");
var PackedHistogram_1 = __webpack_require__(/*! ./PackedHistogram */ "../../node_modules/hdr-histogram-js/PackedHistogram.js");
/**
 * Records integer values, and provides stable interval {@link Histogram} samples from
 * live recorded data without interrupting or stalling active recording of values. Each interval
 * histogram provided contains all value counts accumulated since the previous interval histogram
 * was taken.
 * <p>
 * This pattern is commonly used in logging interval histogram information while recording is ongoing.
 * <p>
 * {@link Recorder} supports concurrent
 * {@link Recorder#recordValue} or
 * {@link Recorder#recordValueWithExpectedInterval} calls.
 *
 */
var Recorder = /** @class */ (function () {
    /**
     * Construct an auto-resizing {@link Recorder} with a lowest discernible value of
     * 1 and an auto-adjusting highestTrackableValue. Can auto-resize up to track values up to Number.MAX_SAFE_INTEGER.
     *
     * @param numberOfSignificantValueDigits Specifies the precision to use. This is the number of significant
     *                                       decimal digits to which the histogram will maintain value resolution
     *                                       and separation. Must be a non-negative integer between 0 and 5.
     * @param packed Specifies whether the recorder will uses a packed internal representation or not.
     * @param clock (for testing purpose) an action that give current time in ms since 1970
     */
    function Recorder(numberOfSignificantValueDigits, packed, clock) {
        if (numberOfSignificantValueDigits === void 0) { numberOfSignificantValueDigits = 3; }
        if (packed === void 0) { packed = false; }
        if (clock === void 0) { clock = function () { return new Date().getTime(); }; }
        this.numberOfSignificantValueDigits = numberOfSignificantValueDigits;
        this.packed = packed;
        this.clock = clock;
        this.histogramConstr = packed ? PackedHistogram_1.default : Int32Histogram_1.default;
        this.activeHistogram = new this.histogramConstr(1, Number.MAX_SAFE_INTEGER, numberOfSignificantValueDigits);
        Recorder.idGenerator++;
        this.activeHistogram.containingInstanceId = Recorder.idGenerator;
        this.activeHistogram.startTimeStampMsec = clock();
    }
    /**
     * Record a value in the histogram
     *
     * @param value The value to be recorded
     * @throws may throw Error if value is exceeds highestTrackableValue
     */
    Recorder.prototype.recordValue = function (value) {
        this.activeHistogram.recordValue(value);
    };
    /**
     * Record a value in the histogram (adding to the value's current count)
     *
     * @param value The value to be recorded
     * @param count The number of occurrences of this value to record
     * @throws ArrayIndexOutOfBoundsException (may throw) if value is exceeds highestTrackableValue
     */
    Recorder.prototype.recordValueWithCount = function (value, count) {
        this.activeHistogram.recordValueWithCount(value, count);
    };
    /**
     * Record a value
     * <p>
     * To compensate for the loss of sampled values when a recorded value is larger than the expected
     * interval between value samples, Histogram will auto-generate an additional series of decreasingly-smaller
     * (down to the expectedIntervalBetweenValueSamples) value records.
     * <p>
     * See related notes {@link AbstractHistogram#recordValueWithExpectedInterval(long, long)}
     * for more explanations about coordinated omission and expected interval correction.
     *      *
     * @param value The value to record
     * @param expectedIntervalBetweenValueSamples If expectedIntervalBetweenValueSamples is larger than 0, add
     *                                           auto-generated value records as appropriate if value is larger
     *                                           than expectedIntervalBetweenValueSamples
     * @throws ArrayIndexOutOfBoundsException (may throw) if value is exceeds highestTrackableValue
     */
    Recorder.prototype.recordValueWithExpectedInterval = function (value, expectedIntervalBetweenValueSamples) {
        this.activeHistogram.recordValueWithExpectedInterval(value, expectedIntervalBetweenValueSamples);
    };
    /**
     * Get an interval histogram, which will include a stable, consistent view of all value counts
     * accumulated since the last interval histogram was taken.
     * <p>
     * {@link Recorder#getIntervalHistogram(Histogram histogramToRecycle)
     * getIntervalHistogram(histogramToRecycle)}
     * accepts a previously returned interval histogram that can be recycled internally to avoid allocation
     * and content copying operations, and is therefore significantly more efficient for repeated use than
     * {@link Recorder#getIntervalHistogram()} and
     * {@link Recorder#getIntervalHistogramInto getIntervalHistogramInto()}. The provided
     * {@code histogramToRecycle} must
     * be either be null or an interval histogram returned by a previous call to
     * {@link Recorder#getIntervalHistogram(Histogram histogramToRecycle)
     * getIntervalHistogram(histogramToRecycle)} or
     * {@link Recorder#getIntervalHistogram()}.
     * <p>
     * NOTE: The caller is responsible for not recycling the same returned interval histogram more than once. If
     * the same interval histogram instance is recycled more than once, behavior is undefined.
     * <p>
     * Calling {@link Recorder#getIntervalHistogram(Histogram histogramToRecycle)
     * getIntervalHistogram(histogramToRecycle)} will reset the value counts, and start accumulating value
     * counts for the next interval
     *
     * @param histogramToRecycle a previously returned interval histogram that may be recycled to avoid allocation and
     *                           copy operations.
     * @return a histogram containing the value counts accumulated since the last interval histogram was taken.
     */
    Recorder.prototype.getIntervalHistogram = function (histogramToRecycle) {
        if (histogramToRecycle) {
            var histogramToRecycleWithId = histogramToRecycle;
            if (histogramToRecycleWithId.containingInstanceId !==
                this.activeHistogram.containingInstanceId) {
                throw "replacement histogram must have been obtained via a previous getIntervalHistogram() call from this Recorder";
            }
        }
        this.inactiveHistogram = histogramToRecycle;
        this.performIntervalSample();
        var sampledHistogram = this.inactiveHistogram;
        this.inactiveHistogram = null; // Once we expose the sample, we can't reuse it internally until it is recycled
        return sampledHistogram;
    };
    /**
     * Place a copy of the value counts accumulated since accumulated (since the last interval histogram
     * was taken) into {@code targetHistogram}.
     *
     * Calling {@link Recorder#getIntervalHistogramInto getIntervalHistogramInto()} will reset
     * the value counts, and start accumulating value counts for the next interval.
     *
     * @param targetHistogram the histogram into which the interval histogram's data should be copied
     */
    Recorder.prototype.getIntervalHistogramInto = function (targetHistogram) {
        this.performIntervalSample();
        if (this.inactiveHistogram) {
            targetHistogram.add(this.inactiveHistogram);
            targetHistogram.startTimeStampMsec = this.inactiveHistogram.startTimeStampMsec;
            targetHistogram.endTimeStampMsec = this.inactiveHistogram.endTimeStampMsec;
        }
    };
    /**
     * Reset any value counts accumulated thus far.
     */
    Recorder.prototype.reset = function () {
        this.activeHistogram.reset();
        this.activeHistogram.startTimeStampMsec = this.clock();
    };
    Recorder.prototype.performIntervalSample = function () {
        if (!this.inactiveHistogram) {
            this.inactiveHistogram = new this.histogramConstr(1, Number.MAX_SAFE_INTEGER, this.numberOfSignificantValueDigits);
            this.inactiveHistogram.containingInstanceId = this.activeHistogram.containingInstanceId;
        }
        this.inactiveHistogram.reset();
        var tempHistogram = this.activeHistogram;
        this.activeHistogram = this.inactiveHistogram;
        this.inactiveHistogram = tempHistogram;
        var currentTimeInMs = this.clock();
        this.inactiveHistogram.endTimeStampMsec = currentTimeInMs;
        this.activeHistogram.startTimeStampMsec = currentTimeInMs;
    };
    Recorder.idGenerator = 0;
    return Recorder;
}());
exports.default = Recorder;
//# sourceMappingURL=Recorder.js.map

/***/ }),

/***/ "../../node_modules/hdr-histogram-js/SparseArrayHistogram.js":
/*!************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/hdr-histogram-js/SparseArrayHistogram.js ***!
  \************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
/*
 * This is a TypeScript port of the original Java version, which was written by
 * Gil Tene as described in
 * https://github.com/HdrHistogram/HdrHistogram
 * and released to the public domain, as explained at
 * http://creativecommons.org/publicdomain/zero/1.0/
 */
var AbstractHistogram_1 = __webpack_require__(/*! ./AbstractHistogram */ "../../node_modules/hdr-histogram-js/AbstractHistogram.js");
var SparseArrayHistogram = /** @class */ (function (_super) {
    __extends(SparseArrayHistogram, _super);
    function SparseArrayHistogram(lowestDiscernibleValue, highestTrackableValue, numberOfSignificantValueDigits) {
        var _this = _super.call(this, lowestDiscernibleValue, highestTrackableValue, numberOfSignificantValueDigits) || this;
        _this.totalCount = 0;
        _this.counts = new Array();
        return _this;
    }
    SparseArrayHistogram.prototype.clearCounts = function () {
        this.counts.fill(0);
    };
    SparseArrayHistogram.prototype.incrementCountAtIndex = function (index) {
        var currentCount = this.counts[index] || 0;
        var newCount = currentCount + 1;
        if (newCount < 0) {
            throw newCount + " would overflow short integer count";
        }
        this.counts[index] = newCount;
    };
    SparseArrayHistogram.prototype.addToCountAtIndex = function (index, value) {
        var currentCount = this.counts[index] || 0;
        var newCount = currentCount + value;
        if (newCount < Number.MIN_SAFE_INTEGER ||
            newCount > Number.MAX_SAFE_INTEGER) {
            throw newCount + " would overflow integer count";
        }
        this.counts[index] = newCount;
    };
    SparseArrayHistogram.prototype.setCountAtIndex = function (index, value) {
        if (value < Number.MIN_SAFE_INTEGER || value > Number.MAX_SAFE_INTEGER) {
            throw value + " would overflow integer count";
        }
        this.counts[index] = value;
    };
    SparseArrayHistogram.prototype.resize = function (newHighestTrackableValue) {
        this.establishSize(newHighestTrackableValue);
    };
    SparseArrayHistogram.prototype.setNormalizingIndexOffset = function (normalizingIndexOffset) { };
    SparseArrayHistogram.prototype.incrementTotalCount = function () {
        this.totalCount++;
    };
    SparseArrayHistogram.prototype.addToTotalCount = function (value) {
        this.totalCount += value;
    };
    SparseArrayHistogram.prototype.setTotalCount = function (value) {
        this.totalCount = value;
    };
    SparseArrayHistogram.prototype.getTotalCount = function () {
        return this.totalCount;
    };
    SparseArrayHistogram.prototype.getCountAtIndex = function (index) {
        return this.counts[index] || 0;
    };
    SparseArrayHistogram.prototype._getEstimatedFootprintInBytes = function () {
        return 512 + this.counts.length;
    };
    SparseArrayHistogram.prototype.copyCorrectedForCoordinatedOmission = function (expectedIntervalBetweenValueSamples) {
        var copy = new SparseArrayHistogram(this.lowestDiscernibleValue, this.highestTrackableValue, this.numberOfSignificantValueDigits);
        copy.addWhileCorrectingForCoordinatedOmission(this, expectedIntervalBetweenValueSamples);
        return copy;
    };
    return SparseArrayHistogram;
}(AbstractHistogram_1.default));
exports.default = SparseArrayHistogram;
//# sourceMappingURL=SparseArrayHistogram.js.map

/***/ }),

/***/ "../../node_modules/hdr-histogram-js/ZigZagEncoding.js":
/*!******************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/hdr-histogram-js/ZigZagEncoding.js ***!
  \******************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var pow = Math.pow, floor = Math.floor;
var TWO_POW_7 = pow(2, 7);
var TWO_POW_14 = pow(2, 14);
var TWO_POW_21 = pow(2, 21);
var TWO_POW_28 = pow(2, 28);
var TWO_POW_35 = pow(2, 35);
var TWO_POW_42 = pow(2, 42);
var TWO_POW_49 = pow(2, 49);
var TWO_POW_56 = pow(2, 56);
/**
 * This class provides encoding and decoding methods for writing and reading
 * ZigZag-encoded LEB128-64b9B-variant (Little Endian Base 128) values to/from a
 * {@link ByteBuffer}. LEB128's variable length encoding provides for using a
 * smaller nuber of bytes for smaller values, and the use of ZigZag encoding
 * allows small (closer to zero) negative values to use fewer bytes. Details
 * on both LEB128 and ZigZag can be readily found elsewhere.
 *
 * The LEB128-64b9B-variant encoding used here diverges from the "original"
 * LEB128 as it extends to 64 bit values: In the original LEB128, a 64 bit
 * value can take up to 10 bytes in the stream, where this variant's encoding
 * of a 64 bit values will max out at 9 bytes.
 *
 * As such, this encoder/decoder should NOT be used for encoding or decoding
 * "standard" LEB128 formats (e.g. Google Protocol Buffers).
 */
var ZigZagEncoding = /** @class */ (function () {
    function ZigZagEncoding() {
    }
    /**
     * Writes a long value to the given buffer in LEB128 ZigZag encoded format
     * (negative numbers not supported)
     * @param buffer the buffer to write to
     * @param value  the value to write to the buffer
     */
    ZigZagEncoding.encode = function (buffer, value) {
        if (value >= 0) {
            value = value * 2;
        }
        else {
            value = -value * 2 - 1;
        }
        if (value < TWO_POW_7) {
            buffer.put(value);
        }
        else {
            buffer.put(value | 0x80);
            if (value < TWO_POW_14) {
                buffer.put(floor(value / TWO_POW_7));
            }
            else {
                buffer.put(floor(value / TWO_POW_7) | 0x80);
                if (value < TWO_POW_21) {
                    buffer.put(floor(value / TWO_POW_14));
                }
                else {
                    buffer.put(floor(value / TWO_POW_14) | 0x80);
                    if (value < TWO_POW_28) {
                        buffer.put(floor(value / TWO_POW_21));
                    }
                    else {
                        buffer.put(floor(value / TWO_POW_21) | 0x80);
                        if (value < TWO_POW_35) {
                            buffer.put(floor(value / TWO_POW_28));
                        }
                        else {
                            buffer.put(floor(value / TWO_POW_28) | 0x80);
                            if (value < TWO_POW_42) {
                                buffer.put(floor(value / TWO_POW_35));
                            }
                            else {
                                buffer.put(floor(value / TWO_POW_35) | 0x80);
                                if (value < TWO_POW_49) {
                                    buffer.put(floor(value / TWO_POW_42));
                                }
                                else {
                                    buffer.put(floor(value / TWO_POW_42) | 0x80);
                                    if (value < TWO_POW_56) {
                                        buffer.put(floor(value / TWO_POW_49));
                                    }
                                    else {
                                        // should not happen
                                        buffer.put(floor(value / TWO_POW_49) + 0x80);
                                        buffer.put(floor(value / TWO_POW_56));
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    };
    /**
     * Read an LEB128-64b9B ZigZag encoded long value from the given buffer
     * (negative numbers not supported)
     * @param buffer the buffer to read from
     * @return the value read from the buffer
     */
    ZigZagEncoding.decode = function (buffer) {
        var v = buffer.get();
        var value = v & 0x7f;
        if ((v & 0x80) != 0) {
            v = buffer.get();
            value += (v & 0x7f) * TWO_POW_7;
            if ((v & 0x80) != 0) {
                v = buffer.get();
                value += (v & 0x7f) * TWO_POW_14;
                if ((v & 0x80) != 0) {
                    v = buffer.get();
                    value += (v & 0x7f) * TWO_POW_21;
                    if ((v & 0x80) != 0) {
                        v = buffer.get();
                        value += (v & 0x7f) * TWO_POW_28;
                        if ((v & 0x80) != 0) {
                            v = buffer.get();
                            value += (v & 0x7f) * TWO_POW_35;
                            if ((v & 0x80) != 0) {
                                v = buffer.get();
                                value += (v & 0x7f) * TWO_POW_42;
                                if ((v & 0x80) != 0) {
                                    v = buffer.get();
                                    value += (v & 0x7f) * TWO_POW_49;
                                    if ((v & 0x80) != 0) {
                                        v = buffer.get();
                                        value += (v & 0x7f) * TWO_POW_56;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        if (value % 2 === 0) {
            value = value / 2;
        }
        else {
            value = -(value + 1) / 2;
        }
        return value;
    };
    return ZigZagEncoding;
}());
exports.default = ZigZagEncoding;
//# sourceMappingURL=ZigZagEncoding.js.map

/***/ }),

/***/ "../../node_modules/hdr-histogram-js/encoding.js":
/*!************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/hdr-histogram-js/encoding.js ***!
  \************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*
 * This is a TypeScript port of the original Java version, which was written by
 * Gil Tene as described in
 * https://github.com/HdrHistogram/HdrHistogram
 * and released to the public domain, as explained at
 * http://creativecommons.org/publicdomain/zero/1.0/
 */
var ByteBuffer_1 = __webpack_require__(/*! ./ByteBuffer */ "../../node_modules/hdr-histogram-js/ByteBuffer.js");
var AbstractHistogram_1 = __webpack_require__(/*! ./AbstractHistogram */ "../../node_modules/hdr-histogram-js/AbstractHistogram.js");
var Int32Histogram_1 = __webpack_require__(/*! ./Int32Histogram */ "../../node_modules/hdr-histogram-js/Int32Histogram.js");
__webpack_require__(/*! ./AbstractHistogram.encoding */ "../../node_modules/hdr-histogram-js/AbstractHistogram.encoding.js");
var base64 = __webpack_require__(/*! base64-js */ "../../node_modules/base64-js/index.js");
var decodeFromCompressedBase64 = function (base64String, histogramConstr, minBarForHighestTrackableValue) {
    if (histogramConstr === void 0) { histogramConstr = Int32Histogram_1.default; }
    if (minBarForHighestTrackableValue === void 0) { minBarForHighestTrackableValue = 0; }
    var buffer = new ByteBuffer_1.default(base64.toByteArray(base64String.trim()));
    return AbstractHistogram_1.AbstractHistogram.decodeFromCompressedByteBuffer(buffer, histogramConstr, minBarForHighestTrackableValue);
};
exports.decodeFromCompressedBase64 = decodeFromCompressedBase64;
var encodeIntoBase64String = function (histogram, compressionLevel) {
    var buffer = ByteBuffer_1.default.allocate();
    var bufferSize = histogram.encodeIntoCompressedByteBuffer(buffer, compressionLevel);
    var encodedBuffer = buffer.data.slice(0, bufferSize);
    return base64.fromByteArray(encodedBuffer);
};
exports.encodeIntoBase64String = encodeIntoBase64String;
//# sourceMappingURL=encoding.js.map

/***/ }),

/***/ "../../node_modules/hdr-histogram-js/formatters.js":
/*!**************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/hdr-histogram-js/formatters.js ***!
  \**************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var leftPadding = function (size) {
    return function (input) {
        if (input.length < size) {
            return " ".repeat(size - input.length) + input;
        }
        return input;
    };
};
exports.integerFormatter = function (size) {
    var padding = leftPadding(size);
    return function (integer) { return padding("" + integer); };
};
exports.floatFormatter = function (size, fractionDigits) {
    var numberFormatter = new Intl.NumberFormat("en-US", {
        maximumFractionDigits: fractionDigits,
        minimumFractionDigits: fractionDigits,
        useGrouping: false
    });
    var padding = leftPadding(size);
    return function (float) { return padding(numberFormatter.format(float)); };
};
//# sourceMappingURL=formatters.js.map

/***/ }),

/***/ "../../node_modules/hdr-histogram-js/index.js":
/*!*********************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/hdr-histogram-js/index.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*
 * This is a TypeScript port of the original Java version, which was written by
 * Gil Tene as described in
 * https://github.com/HdrHistogram/HdrHistogram
 * and released to the public domain, as explained at
 * http://creativecommons.org/publicdomain/zero/1.0/
 */
var ByteBuffer_1 = __webpack_require__(/*! ./ByteBuffer */ "../../node_modules/hdr-histogram-js/ByteBuffer.js");
exports.ByteBuffer = ByteBuffer_1.default;
var Int8Histogram_1 = __webpack_require__(/*! ./Int8Histogram */ "../../node_modules/hdr-histogram-js/Int8Histogram.js");
exports.Int8Histogram = Int8Histogram_1.default;
var Int16Histogram_1 = __webpack_require__(/*! ./Int16Histogram */ "../../node_modules/hdr-histogram-js/Int16Histogram.js");
exports.Int16Histogram = Int16Histogram_1.default;
var Int32Histogram_1 = __webpack_require__(/*! ./Int32Histogram */ "../../node_modules/hdr-histogram-js/Int32Histogram.js");
exports.Int32Histogram = Int32Histogram_1.default;
var Float64Histogram_1 = __webpack_require__(/*! ./Float64Histogram */ "../../node_modules/hdr-histogram-js/Float64Histogram.js");
exports.Float64Histogram = Float64Histogram_1.default;
var PackedHistogram_1 = __webpack_require__(/*! ./PackedHistogram */ "../../node_modules/hdr-histogram-js/PackedHistogram.js");
exports.PackedHistogram = PackedHistogram_1.default;
var SparseArrayHistogram_1 = __webpack_require__(/*! ./SparseArrayHistogram */ "../../node_modules/hdr-histogram-js/SparseArrayHistogram.js");
exports.SparseArrayHistogram = SparseArrayHistogram_1.default;
var AbstractHistogram_1 = __webpack_require__(/*! ./AbstractHistogram */ "../../node_modules/hdr-histogram-js/AbstractHistogram.js");
exports.AbstractHistogram = AbstractHistogram_1.default;
exports.Histogram = AbstractHistogram_1.default;
var HistogramLogReader_1 = __webpack_require__(/*! ./HistogramLogReader */ "../../node_modules/hdr-histogram-js/HistogramLogReader.js");
exports.HistogramLogReader = HistogramLogReader_1.default;
exports.listTags = HistogramLogReader_1.listTags;
var HistogramLogWriter_1 = __webpack_require__(/*! ./HistogramLogWriter */ "../../node_modules/hdr-histogram-js/HistogramLogWriter.js");
exports.HistogramLogWriter = HistogramLogWriter_1.default;
var encoding_1 = __webpack_require__(/*! ./encoding */ "../../node_modules/hdr-histogram-js/encoding.js");
exports.decodeFromCompressedBase64 = encoding_1.decodeFromCompressedBase64;
exports.encodeIntoBase64String = encoding_1.encodeIntoBase64String;
var Recorder_1 = __webpack_require__(/*! ./Recorder */ "../../node_modules/hdr-histogram-js/Recorder.js");
exports.Recorder = Recorder_1.default;
var defaultRequest = {
    bitBucketSize: 32,
    autoResize: true,
    lowestDiscernibleValue: 1,
    highestTrackableValue: 2,
    numberOfSignificantValueDigits: 3
};
exports.defaultRequest = defaultRequest;
/*const bigIntAvailable = (() => {
  try {
    eval("123n");
    return true;
  } catch (e) {
    return false;
  }
})();*/
var build = function (request) {
    if (request === void 0) { request = defaultRequest; }
    var parameters = Object.assign({}, defaultRequest, request);
    var histogramConstr;
    switch (parameters.bitBucketSize) {
        case 8:
            histogramConstr = Int8Histogram_1.default;
            break;
        case 16:
            histogramConstr = Int16Histogram_1.default;
            break;
        case 32:
            histogramConstr = Int32Histogram_1.default;
            break;
        case "sparse_array":
            histogramConstr = SparseArrayHistogram_1.default;
            break;
        case "packed":
            histogramConstr = PackedHistogram_1.default;
            break;
        default:
            //histogramConstr = bigIntAvailable ? BigIntHistogram : Float64Histogram;
            histogramConstr = Float64Histogram_1.default;
    }
    var histogram = new histogramConstr(parameters.lowestDiscernibleValue, parameters.highestTrackableValue, parameters.numberOfSignificantValueDigits);
    histogram.autoResize = parameters.autoResize;
    return histogram;
};
exports.build = build;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../node_modules/hdr-histogram-js/packedarray/PackedArray.js":
/*!***************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/hdr-histogram-js/packedarray/PackedArray.js ***!
  \***************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*
 * This is a TypeScript port of the original Java version, which was written by
 * Gil Tene as described in
 * https://github.com/HdrHistogram/HdrHistogram
 * and released to the public domain, as explained at
 * http://creativecommons.org/publicdomain/zero/1.0/
 */
var PackedArrayContext_1 = __webpack_require__(/*! ./PackedArrayContext */ "../../node_modules/hdr-histogram-js/packedarray/PackedArrayContext.js");
var ResizeError_1 = __webpack_require__(/*! ./ResizeError */ "../../node_modules/hdr-histogram-js/packedarray/ResizeError.js");
var NUMBER_OF_SETS = 8;
var pow = Math.pow, floor = Math.floor;
/**
 * A Packed array of signed 64 bit values, and supports {@link #get get()}, {@link #set set()},
 * {@link #add add()} and {@link #increment increment()} operations on the logical contents of the array.
 *
 * An {@link PackedLongArray} Uses {@link PackedArrayContext} to track
 * the array's logical contents. Contexts may be switched when a context requires resizing
 * to complete logical array operations (get, set, add, increment). Contexts are
 * established and used within critical sections in order to facilitate concurrent
 * implementors.
 *
 */
var PackedArray = /** @class */ (function () {
    function PackedArray(virtualLength, initialPhysicalLength) {
        if (initialPhysicalLength === void 0) { initialPhysicalLength = PackedArrayContext_1.MINIMUM_INITIAL_PACKED_ARRAY_CAPACITY; }
        this.arrayContext = new PackedArrayContext_1.PackedArrayContext(virtualLength, initialPhysicalLength);
    }
    PackedArray.prototype.setVirtualLength = function (newVirtualArrayLength) {
        if (newVirtualArrayLength < this.length()) {
            throw new Error("Cannot set virtual length, as requested length " +
                newVirtualArrayLength +
                " is smaller than the current virtual length " +
                this.length());
        }
        var currentArrayContext = this.arrayContext;
        if (currentArrayContext.isPacked &&
            currentArrayContext.determineTopLevelShiftForVirtualLength(newVirtualArrayLength) == currentArrayContext.getTopLevelShift()) {
            // No changes to the array context contents is needed. Just change the virtual length.
            currentArrayContext.setVirtualLength(newVirtualArrayLength);
            return;
        }
        this.arrayContext = currentArrayContext.copyAndIncreaseSize(this.getPhysicalLength(), newVirtualArrayLength);
    };
    /**
     * Get value at virtual index in the array
     * @param index the virtual array index
     * @return the array value at the virtual index given
     */
    PackedArray.prototype.get = function (index) {
        var value = 0;
        for (var byteNum = 0; byteNum < NUMBER_OF_SETS; byteNum++) {
            var byteValueAtPackedIndex = 0;
            // Deal with unpacked context:
            if (!this.arrayContext.isPacked) {
                return this.arrayContext.getAtUnpackedIndex(index);
            }
            // Context is packed:
            var packedIndex = this.arrayContext.getPackedIndex(byteNum, index, false);
            if (packedIndex < 0) {
                return value;
            }
            byteValueAtPackedIndex =
                this.arrayContext.getAtByteIndex(packedIndex) * pow(2, byteNum << 3);
            value += byteValueAtPackedIndex;
        }
        return value;
    };
    /**
     * Increment value at a virrual index in the array
     * @param index virtual index of value to increment
     */
    PackedArray.prototype.increment = function (index) {
        this.add(index, 1);
    };
    PackedArray.prototype.safeGetPackedIndexgetPackedIndex = function (setNumber, virtualIndex) {
        do {
            try {
                return this.arrayContext.getPackedIndex(setNumber, virtualIndex, true);
            }
            catch (ex) {
                if (ex instanceof ResizeError_1.ResizeError) {
                    this.arrayContext.resizeArray(ex.newSize);
                }
                else {
                    throw ex;
                }
            }
        } while (true);
    };
    /**
     * Add to a value at a virtual index in the array
     * @param index the virtual index of the value to be added to
     * @param value the value to add
     */
    PackedArray.prototype.add = function (index, value) {
        var remainingValueToAdd = value;
        for (var byteNum = 0, byteShift = 0; byteNum < NUMBER_OF_SETS; byteNum++, byteShift += 8) {
            // Deal with unpacked context:
            if (!this.arrayContext.isPacked) {
                this.arrayContext.addAndGetAtUnpackedIndex(index, value);
                return;
            }
            // Context is packed:
            var packedIndex = this.safeGetPackedIndexgetPackedIndex(byteNum, index);
            var byteToAdd = remainingValueToAdd & 0xff;
            var afterAddByteValue = this.arrayContext.addAtByteIndex(packedIndex, byteToAdd);
            // Reduce remaining value to add by amount just added:
            remainingValueToAdd -= byteToAdd;
            remainingValueToAdd = remainingValueToAdd / pow(2, 8);
            // Account for carry:
            remainingValueToAdd += floor(afterAddByteValue / pow(2, 8));
            if (remainingValueToAdd == 0) {
                return; // nothing to add to higher magnitudes
            }
        }
    };
    /**
     * Set the value at a virtual index in the array
     * @param index the virtual index of the value to set
     * @param value the value to set
     */
    PackedArray.prototype.set = function (index, value) {
        var bytesAlreadySet = 0;
        do {
            var valueForNextLevels = value;
            try {
                for (var byteNum = 0; byteNum < NUMBER_OF_SETS; byteNum++) {
                    // Establish context within: critical section
                    // Deal with unpacked context:
                    if (!this.arrayContext.isPacked) {
                        this.arrayContext.setAtUnpackedIndex(index, value);
                        return;
                    }
                    // Context is packed:
                    if (valueForNextLevels == 0) {
                        // Special-case zeros to avoid inflating packed array for no reason
                        var packedIndex_1 = this.arrayContext.getPackedIndex(byteNum, index, false);
                        if (packedIndex_1 < 0) {
                            return; // no need to create entries for zero values if they don't already exist
                        }
                    }
                    // Make sure byte is populated:
                    var packedIndex = this.arrayContext.getPackedIndex(byteNum, index, true);
                    // Determine value to write, and prepare for next levels
                    var byteToWrite = valueForNextLevels & 0xff;
                    valueForNextLevels = floor(valueForNextLevels / pow(2, 8));
                    if (byteNum < bytesAlreadySet) {
                        // We want to avoid writing to the same byte twice when not doing so for the
                        // entire 64 bit value atomically, as doing so opens a race with e.g. concurrent
                        // adders. So dobn't actually write the byte if has been written before.
                        continue;
                    }
                    this.arrayContext.setAtByteIndex(packedIndex, byteToWrite);
                    bytesAlreadySet++;
                }
                return;
            }
            catch (ex) {
                if (ex instanceof ResizeError_1.ResizeError) {
                    this.arrayContext.resizeArray(ex.newSize);
                }
                else {
                    throw ex;
                }
            }
        } while (true);
    };
    /**
     * Get the current physical length (in longs) of the array's backing storage
     * @return the current physical length (in longs) of the array's current backing storage
     */
    PackedArray.prototype.getPhysicalLength = function () {
        return this.arrayContext.physicalLength;
    };
    /**
     * Get the (virtual) length of the array
     * @return the (virtual) length of the array
     */
    PackedArray.prototype.length = function () {
        return this.arrayContext.getVirtualLength();
    };
    /**
     * Clear the array contents
     */
    PackedArray.prototype.clear = function () {
        this.arrayContext.clear();
    };
    PackedArray.prototype.toString = function () {
        var output = "PackedArray:\n";
        output += this.arrayContext.toString();
        return output;
    };
    return PackedArray;
}());
exports.PackedArray = PackedArray;
//# sourceMappingURL=PackedArray.js.map

/***/ }),

/***/ "../../node_modules/hdr-histogram-js/packedarray/PackedArrayContext.js":
/*!**********************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/hdr-histogram-js/packedarray/PackedArrayContext.js ***!
  \**********************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*
 * This is a TypeScript port of the original Java version, which was written by
 * Gil Tene as described in
 * https://github.com/HdrHistogram/HdrHistogram
 * and released to the public domain, as explained at
 * http://creativecommons.org/publicdomain/zero/1.0/
 */
var ResizeError_1 = __webpack_require__(/*! ./ResizeError */ "../../node_modules/hdr-histogram-js/packedarray/ResizeError.js");
/**
 * A packed-value, sparse array context used for storing 64 bit signed values.
 *
 * An array context is optimised for tracking sparsely set (as in mostly zeros) values that tend to not make
 * use pof the full 64 bit value range even when they are non-zero. The array context's internal representation
 * is such that the packed value at each virtual array index may be represented by 0-8 bytes of actual storage.
 *
 * An array context encodes the packed values in 8 "set trees" with each set tree representing one byte of the
 * packed value at the virtual index in question. The {@link #getPackedIndex(int, int, boolean)} method is used
 * to look up the byte-index corresponding to the given (set tree) value byte of the given virtual index, and can
 * be used to add entries to represent that byte as needed. As a succesful {@link #getPackedIndex(int, int, boolean)}
 * may require a resizing of the array, it can throw a {@link ResizeException} to indicate that the requested
 * packed index cannot be found or added without a resize of the physical storage.
 *
 */
exports.MINIMUM_INITIAL_PACKED_ARRAY_CAPACITY = 16;
var MAX_SUPPORTED_PACKED_COUNTS_ARRAY_LENGTH = Math.pow(2, 13) - 1; //(Short.MAX_VALUE / 4);  TODO ALEX why ???
var SET_0_START_INDEX = 0;
var NUMBER_OF_SETS = 8;
var LEAF_LEVEL_SHIFT = 3;
var NON_LEAF_ENTRY_SLOT_INDICATORS_OFFSET = 0;
var NON_LEAF_ENTRY_HEADER_SIZE_IN_SHORTS = 1;
var PACKED_ARRAY_GROWTH_INCREMENT = 16;
var PACKED_ARRAY_GROWTH_FRACTION_POW2 = 4;
var pow = Math.pow, ceil = Math.ceil, log2 = Math.log2, max = Math.max;
var bitCount = function (n) {
    var bits = 0;
    while (n !== 0) {
        bits += bitCount32(n | 0);
        n /= 0x100000000;
    }
    return bits;
};
var bitCount32 = function (n) {
    n = n - ((n >> 1) & 0x55555555);
    n = (n & 0x33333333) + ((n >> 2) & 0x33333333);
    return (((n + (n >> 4)) & 0xf0f0f0f) * 0x1010101) >> 24;
};
var PackedArrayContext = /** @class */ (function () {
    function PackedArrayContext(virtualLength, initialPhysicalLength) {
        this.populatedShortLength = 0;
        this.topLevelShift = Number.MAX_VALUE; // Make it non-sensical until properly initialized.
        this.physicalLength = Math.max(initialPhysicalLength, exports.MINIMUM_INITIAL_PACKED_ARRAY_CAPACITY);
        this.isPacked =
            this.physicalLength <= MAX_SUPPORTED_PACKED_COUNTS_ARRAY_LENGTH;
        if (!this.isPacked) {
            this.physicalLength = virtualLength;
        }
        this.array = new ArrayBuffer(this.physicalLength * 8);
        this.initArrayViews(this.array);
        this.init(virtualLength);
    }
    PackedArrayContext.prototype.initArrayViews = function (array) {
        this.byteArray = new Uint8Array(array);
        this.shortArray = new Uint16Array(array);
        this.longArray = new Float64Array(array);
    };
    PackedArrayContext.prototype.init = function (virtualLength) {
        if (!this.isPacked) {
            // Deal with non-packed context init:
            this.virtualLength = virtualLength;
            return;
        }
        this.populatedShortLength = SET_0_START_INDEX + 8;
        // Populate empty root entries, and point to them from the root indexes:
        for (var i = 0; i < NUMBER_OF_SETS; i++) {
            this.setAtShortIndex(SET_0_START_INDEX + i, 0);
        }
        this.setVirtualLength(virtualLength);
    };
    PackedArrayContext.prototype.clear = function () {
        this.byteArray.fill(0);
    };
    PackedArrayContext.prototype.copyAndIncreaseSize = function (newPhysicalArrayLength, newVirtualArrayLength) {
        var ctx = new PackedArrayContext(newVirtualArrayLength, newPhysicalArrayLength);
        if (this.isPacked) {
            ctx.populateEquivalentEntriesWithEntriesFromOther(this);
        }
        return ctx;
    };
    PackedArrayContext.prototype.getPopulatedShortLength = function () {
        return this.populatedShortLength;
    };
    PackedArrayContext.prototype.getPopulatedLongLength = function () {
        return (this.getPopulatedShortLength() + 3) >> 2; // round up
    };
    PackedArrayContext.prototype.setAtByteIndex = function (byteIndex, value) {
        this.byteArray[byteIndex] = value;
    };
    PackedArrayContext.prototype.getAtByteIndex = function (byteIndex) {
        return this.byteArray[byteIndex];
    };
    /**
     * add a byte value to a current byte value in the array
     * @param byteIndex index of byte value to add to
     * @param valueToAdd byte value to add
     * @return the afterAddValue. ((afterAddValue & 0x100) != 0) indicates a carry.
     */
    PackedArrayContext.prototype.addAtByteIndex = function (byteIndex, valueToAdd) {
        var newValue = this.byteArray[byteIndex] + valueToAdd;
        this.byteArray[byteIndex] = newValue;
        return newValue;
    };
    PackedArrayContext.prototype.setPopulatedLongLength = function (newPopulatedLongLength) {
        this.populatedShortLength = newPopulatedLongLength << 2;
    };
    PackedArrayContext.prototype.getVirtualLength = function () {
        return this.virtualLength;
    };
    PackedArrayContext.prototype.length = function () {
        return this.physicalLength;
    };
    PackedArrayContext.prototype.setAtShortIndex = function (shortIndex, value) {
        this.shortArray[shortIndex] = value;
    };
    PackedArrayContext.prototype.setAtLongIndex = function (longIndex, value) {
        this.longArray[longIndex] = value;
    };
    PackedArrayContext.prototype.getAtShortIndex = function (shortIndex) {
        return this.shortArray[shortIndex];
    };
    PackedArrayContext.prototype.getIndexAtShortIndex = function (shortIndex) {
        return this.shortArray[shortIndex];
    };
    PackedArrayContext.prototype.setPackedSlotIndicators = function (entryIndex, newPackedSlotIndicators) {
        this.setAtShortIndex(entryIndex + NON_LEAF_ENTRY_SLOT_INDICATORS_OFFSET, newPackedSlotIndicators);
    };
    PackedArrayContext.prototype.getPackedSlotIndicators = function (entryIndex) {
        return (this.shortArray[entryIndex + NON_LEAF_ENTRY_SLOT_INDICATORS_OFFSET] &
            0xffff);
    };
    PackedArrayContext.prototype.getIndexAtEntrySlot = function (entryIndex, slot) {
        return this.getAtShortIndex(entryIndex + NON_LEAF_ENTRY_HEADER_SIZE_IN_SHORTS + slot);
    };
    PackedArrayContext.prototype.setIndexAtEntrySlot = function (entryIndex, slot, newIndexValue) {
        this.setAtShortIndex(entryIndex + NON_LEAF_ENTRY_HEADER_SIZE_IN_SHORTS + slot, newIndexValue);
    };
    PackedArrayContext.prototype.expandArrayIfNeeded = function (entryLengthInLongs) {
        var currentLength = this.length();
        if (currentLength < this.getPopulatedLongLength() + entryLengthInLongs) {
            var growthIncrement = max(entryLengthInLongs, PACKED_ARRAY_GROWTH_INCREMENT, this.getPopulatedLongLength() >> PACKED_ARRAY_GROWTH_FRACTION_POW2);
            throw new ResizeError_1.ResizeError(currentLength + growthIncrement);
        }
    };
    PackedArrayContext.prototype.newEntry = function (entryLengthInShorts) {
        // Add entry at the end of the array:
        var newEntryIndex = this.populatedShortLength;
        this.expandArrayIfNeeded((entryLengthInShorts >> 2) + 1);
        this.populatedShortLength = newEntryIndex + entryLengthInShorts;
        for (var i = 0; i < entryLengthInShorts; i++) {
            this.setAtShortIndex(newEntryIndex + i, -1); // Poison value -1. Must be overriden before reads
        }
        return newEntryIndex;
    };
    PackedArrayContext.prototype.newLeafEntry = function () {
        // Add entry at the end of the array:
        var newEntryIndex;
        newEntryIndex = this.getPopulatedLongLength();
        this.expandArrayIfNeeded(1);
        this.setPopulatedLongLength(newEntryIndex + 1);
        this.setAtLongIndex(newEntryIndex, 0);
        return newEntryIndex;
    };
    /**
     * Consolidate entry with previous entry verison if one exists
     *
     * @param entryIndex The shortIndex of the entry to be consolidated
     * @param previousVersionIndex the index of the previous version of the entry
     */
    PackedArrayContext.prototype.consolidateEntry = function (entryIndex, previousVersionIndex) {
        var previousVersionPackedSlotsIndicators = this.getPackedSlotIndicators(previousVersionIndex);
        // Previous version exists, needs consolidation
        var packedSlotsIndicators = this.getPackedSlotIndicators(entryIndex);
        var insertedSlotMask = packedSlotsIndicators ^ previousVersionPackedSlotsIndicators; // the only bit that differs
        var slotsBelowBitNumber = packedSlotsIndicators & (insertedSlotMask - 1);
        var insertedSlotIndex = bitCount(slotsBelowBitNumber);
        var numberOfSlotsInEntry = bitCount(packedSlotsIndicators);
        // Copy the entry slots from previous version, skipping the newly inserted slot in the target:
        var sourceSlot = 0;
        for (var targetSlot = 0; targetSlot < numberOfSlotsInEntry; targetSlot++) {
            if (targetSlot !== insertedSlotIndex) {
                var indexAtSlot = this.getIndexAtEntrySlot(previousVersionIndex, sourceSlot);
                if (indexAtSlot !== 0) {
                    this.setIndexAtEntrySlot(entryIndex, targetSlot, indexAtSlot);
                }
                sourceSlot++;
            }
        }
    };
    /**
     * Expand entry as indicated.
     *
     * @param existingEntryIndex the index of the entry
     * @param entryPointerIndex  index to the slot pointing to the entry (needs to be fixed up)
     * @param insertedSlotIndex  realtive [packed] index of slot being inserted into entry
     * @param insertedSlotMask   mask value fo slot being inserted
     * @param nextLevelIsLeaf    the level below this one is a leaf level
     * @return the updated index of the entry (-1 if epansion failed due to conflict)
     * @throws RetryException if expansion fails due to concurrent conflict, and caller should try again.
     */
    PackedArrayContext.prototype.expandEntry = function (existingEntryIndex, entryPointerIndex, insertedSlotIndex, insertedSlotMask, nextLevelIsLeaf) {
        var packedSlotIndicators = this.getAtShortIndex(existingEntryIndex) & 0xffff;
        packedSlotIndicators |= insertedSlotMask;
        var numberOfslotsInExpandedEntry = bitCount(packedSlotIndicators);
        if (insertedSlotIndex >= numberOfslotsInExpandedEntry) {
            throw new Error("inserted slot index is out of range given provided masks");
        }
        var expandedEntryLength = numberOfslotsInExpandedEntry + NON_LEAF_ENTRY_HEADER_SIZE_IN_SHORTS;
        // Create new next-level entry to refer to from slot at this level:
        var indexOfNewNextLevelEntry = 0;
        if (nextLevelIsLeaf) {
            indexOfNewNextLevelEntry = this.newLeafEntry(); // Establish long-index to new leaf entry
        }
        else {
            // TODO: Optimize this by creating the whole sub-tree here, rather than a step that will immediaterly expand
            // Create a new 1 word (empty, no slots set) entry for the next level:
            indexOfNewNextLevelEntry = this.newEntry(NON_LEAF_ENTRY_HEADER_SIZE_IN_SHORTS); // Establish short-index to new leaf entry
            this.setPackedSlotIndicators(indexOfNewNextLevelEntry, 0);
        }
        var insertedSlotValue = indexOfNewNextLevelEntry;
        var expandedEntryIndex = this.newEntry(expandedEntryLength);
        // populate the packed indicators word:
        this.setPackedSlotIndicators(expandedEntryIndex, packedSlotIndicators);
        // Populate the inserted slot with the index of the new next level entry:
        this.setIndexAtEntrySlot(expandedEntryIndex, insertedSlotIndex, insertedSlotValue);
        this.setAtShortIndex(entryPointerIndex, expandedEntryIndex);
        this.consolidateEntry(expandedEntryIndex, existingEntryIndex);
        return expandedEntryIndex;
    };
    //
    //   ######   ######## ########    ##     ##    ###    ##             ## #### ##    ## ########  ######## ##     ##
    //  ##    ##  ##          ##       ##     ##   ## ##   ##            ##   ##  ###   ## ##     ## ##        ##   ##
    //  ##        ##          ##       ##     ##  ##   ##  ##           ##    ##  ####  ## ##     ## ##         ## ##
    //  ##   #### ######      ##       ##     ## ##     ## ##          ##     ##  ## ## ## ##     ## ######      ###
    //  ##    ##  ##          ##        ##   ##  ######### ##         ##      ##  ##  #### ##     ## ##         ## ##
    //  ##    ##  ##          ##         ## ##   ##     ## ##        ##       ##  ##   ### ##     ## ##        ##   ##
    //   ######   ########    ##          ###    ##     ## ######## ##       #### ##    ## ########  ######## ##     ##
    //
    PackedArrayContext.prototype.getRootEntry = function (setNumber, insertAsNeeded) {
        if (insertAsNeeded === void 0) { insertAsNeeded = false; }
        var entryPointerIndex = SET_0_START_INDEX + setNumber;
        var entryIndex = this.getIndexAtShortIndex(entryPointerIndex);
        if (entryIndex == 0) {
            if (!insertAsNeeded) {
                return 0; // Index does not currently exist in packed array;
            }
            entryIndex = this.newEntry(NON_LEAF_ENTRY_HEADER_SIZE_IN_SHORTS);
            // Create a new empty (no slots set) entry for the next level:
            this.setPackedSlotIndicators(entryIndex, 0);
            this.setAtShortIndex(entryPointerIndex, entryIndex);
        }
        return entryIndex;
    };
    /**
     * Get the byte-index (into the packed array) corresponding to a given (set tree) value byte of given virtual index.
     * Inserts new set tree nodes as needed if indicated.
     *
     * @param setNumber      The set tree number (0-7, 0 corresponding with the LSByte set tree)
     * @param virtualIndex   The virtual index into the PackedArray
     * @param insertAsNeeded If true, will insert new set tree nodes as needed if they do not already exist
     * @return the byte-index corresponding to the given (set tree) value byte of the given virtual index
     */
    PackedArrayContext.prototype.getPackedIndex = function (setNumber, virtualIndex, insertAsNeeded) {
        if (virtualIndex >= this.virtualLength) {
            throw new Error("Attempting access at index " + virtualIndex + ", beyond virtualLength " + this.virtualLength);
        }
        var entryPointerIndex = SET_0_START_INDEX + setNumber; // TODO init needed ?
        var entryIndex = this.getRootEntry(setNumber, insertAsNeeded);
        if (entryIndex == 0) {
            return -1; // Index does not currently exist in packed array;
        }
        // Work down the levels of non-leaf entries:
        for (var indexShift = this.topLevelShift; indexShift >= LEAF_LEVEL_SHIFT; indexShift -= 4) {
            var nextLevelIsLeaf = indexShift === LEAF_LEVEL_SHIFT;
            // Target is a packedSlotIndicators entry
            var packedSlotIndicators = this.getPackedSlotIndicators(entryIndex);
            var slotBitNumber = (virtualIndex / pow(2, indexShift)) & 0xf; //(virtualIndex >>> indexShift) & 0xf;
            var slotMask = 1 << slotBitNumber;
            var slotsBelowBitNumber = packedSlotIndicators & (slotMask - 1);
            var slotNumber = bitCount(slotsBelowBitNumber);
            if ((packedSlotIndicators & slotMask) === 0) {
                // The entryIndex slot does not have the contents we want
                if (!insertAsNeeded) {
                    return -1; // Index does not currently exist in packed array;
                }
                // Expand the entry, adding the index to new entry at the proper slot:
                entryIndex = this.expandEntry(entryIndex, entryPointerIndex, slotNumber, slotMask, nextLevelIsLeaf);
            }
            // Next level's entry pointer index is in the appropriate slot in in the entries array in this entry:
            entryPointerIndex =
                entryIndex + NON_LEAF_ENTRY_HEADER_SIZE_IN_SHORTS + slotNumber;
            entryIndex = this.getIndexAtShortIndex(entryPointerIndex);
        }
        // entryIndex is the long-index of a leaf entry that contains the value byte for the given set
        var byteIndex = (entryIndex << 3) + (virtualIndex & 0x7); // Determine byte index offset within leaf entry
        return byteIndex;
    };
    PackedArrayContext.prototype.determineTopLevelShiftForVirtualLength = function (virtualLength) {
        var sizeMagnitude = ceil(log2(virtualLength));
        var eightsSizeMagnitude = sizeMagnitude - 3;
        var multipleOfFourSizeMagnitude = ceil(eightsSizeMagnitude / 4) * 4;
        multipleOfFourSizeMagnitude = max(multipleOfFourSizeMagnitude, 8);
        var topLevelShiftNeeded = multipleOfFourSizeMagnitude - 4 + 3;
        return topLevelShiftNeeded;
    };
    PackedArrayContext.prototype.setVirtualLength = function (virtualLength) {
        if (!this.isPacked) {
            throw new Error("Should never be adjusting the virtual size of a non-packed context");
        }
        this.topLevelShift = this.determineTopLevelShiftForVirtualLength(virtualLength);
        this.virtualLength = virtualLength;
    };
    PackedArrayContext.prototype.getTopLevelShift = function () {
        return this.topLevelShift;
    };
    //
    //  ##     ##         ########   #######  ########  ##     ## ##          ###    ######## ########
    //   ##   ##          ##     ## ##     ## ##     ## ##     ## ##         ## ##      ##    ##
    //    ## ##           ##     ## ##     ## ##     ## ##     ## ##        ##   ##     ##    ##
    //     ###    ####### ########  ##     ## ########  ##     ## ##       ##     ##    ##    ######
    //    ## ##           ##        ##     ## ##        ##     ## ##       #########    ##    ##
    //   ##   ##          ##        ##     ## ##        ##     ## ##       ##     ##    ##    ##
    //  ##     ##         ##         #######  ##         #######  ######## ##     ##    ##    ########
    //
    PackedArrayContext.prototype.resizeArray = function (newLength) {
        var tmp = new Uint8Array(newLength * 8);
        tmp.set(this.byteArray);
        this.array = tmp.buffer;
        this.initArrayViews(this.array);
        this.physicalLength = newLength;
    };
    PackedArrayContext.prototype.populateEquivalentEntriesWithEntriesFromOther = function (other) {
        if (this.virtualLength < other.getVirtualLength()) {
            throw new Error("Cannot populate array of smaller virtual length");
        }
        for (var i = 0; i < NUMBER_OF_SETS; i++) {
            var otherEntryIndex = other.getAtShortIndex(SET_0_START_INDEX + i);
            if (otherEntryIndex == 0)
                continue; // No tree to duplicate
            var entryIndexPointer = SET_0_START_INDEX + i;
            for (var i_1 = this.topLevelShift; i_1 > other.topLevelShift; i_1 -= 4) {
                // for each inserted level:
                // Allocate entry in other:
                var sizeOfEntry = NON_LEAF_ENTRY_HEADER_SIZE_IN_SHORTS + 1;
                var newEntryIndex = this.newEntry(sizeOfEntry);
                // Link new level in.
                this.setAtShortIndex(entryIndexPointer, newEntryIndex);
                // Populate new level entry, use pointer to slot 0 as place to populate under:
                this.setPackedSlotIndicators(newEntryIndex, 0x1); // Slot 0 populated
                entryIndexPointer =
                    newEntryIndex + NON_LEAF_ENTRY_HEADER_SIZE_IN_SHORTS; // Where the slot 0 index goes.
            }
            this.copyEntriesAtLevelFromOther(other, otherEntryIndex, entryIndexPointer, other.topLevelShift);
        }
    };
    PackedArrayContext.prototype.copyEntriesAtLevelFromOther = function (other, otherLevelEntryIndex, levelEntryIndexPointer, otherIndexShift) {
        var nextLevelIsLeaf = otherIndexShift == LEAF_LEVEL_SHIFT;
        var packedSlotIndicators = other.getPackedSlotIndicators(otherLevelEntryIndex);
        var numberOfSlots = bitCount(packedSlotIndicators);
        var sizeOfEntry = NON_LEAF_ENTRY_HEADER_SIZE_IN_SHORTS + numberOfSlots;
        var entryIndex = this.newEntry(sizeOfEntry);
        this.setAtShortIndex(levelEntryIndexPointer, entryIndex);
        this.setAtShortIndex(entryIndex + NON_LEAF_ENTRY_SLOT_INDICATORS_OFFSET, packedSlotIndicators);
        for (var i = 0; i < numberOfSlots; i++) {
            if (nextLevelIsLeaf) {
                // Make leaf in other:
                var leafEntryIndex = this.newLeafEntry();
                this.setIndexAtEntrySlot(entryIndex, i, leafEntryIndex);
                // OPTIM
                // avoid iteration on all the values of the source ctx
                var otherNextLevelEntryIndex = other.getIndexAtEntrySlot(otherLevelEntryIndex, i);
                this.longArray[leafEntryIndex] =
                    other.longArray[otherNextLevelEntryIndex];
            }
            else {
                var otherNextLevelEntryIndex = other.getIndexAtEntrySlot(otherLevelEntryIndex, i);
                this.copyEntriesAtLevelFromOther(other, otherNextLevelEntryIndex, entryIndex + NON_LEAF_ENTRY_HEADER_SIZE_IN_SHORTS + i, otherIndexShift - 4);
            }
        }
    };
    PackedArrayContext.prototype.getAtUnpackedIndex = function (index) {
        return this.longArray[index];
    };
    PackedArrayContext.prototype.setAtUnpackedIndex = function (index, newValue) {
        this.longArray[index] = newValue;
    };
    PackedArrayContext.prototype.lazysetAtUnpackedIndex = function (index, newValue) {
        this.longArray[index] = newValue;
    };
    PackedArrayContext.prototype.incrementAndGetAtUnpackedIndex = function (index) {
        this.longArray[index]++;
        return this.longArray[index];
    };
    PackedArrayContext.prototype.addAndGetAtUnpackedIndex = function (index, valueToAdd) {
        this.longArray[index] += valueToAdd;
        return this.longArray[index];
    };
    //
    //   ########  #######           ######  ######## ########  #### ##    ##  ######
    //      ##    ##     ##         ##    ##    ##    ##     ##  ##  ###   ## ##    ##
    //      ##    ##     ##         ##          ##    ##     ##  ##  ####  ## ##
    //      ##    ##     ## #######  ######     ##    ########   ##  ## ## ## ##   ####
    //      ##    ##     ##               ##    ##    ##   ##    ##  ##  #### ##    ##
    //      ##    ##     ##         ##    ##    ##    ##    ##   ##  ##   ### ##    ##
    //      ##     #######           ######     ##    ##     ## #### ##    ##  ######
    //
    PackedArrayContext.prototype.nonLeafEntryToString = function (entryIndex, indexShift, indentLevel) {
        var output = "";
        for (var i = 0; i < indentLevel; i++) {
            output += "  ";
        }
        try {
            var packedSlotIndicators = this.getPackedSlotIndicators(entryIndex);
            output += "slotIndiators: 0x" + toHex(packedSlotIndicators) + ", prevVersionIndex: 0: [ ";
            var numberOfslotsInEntry = bitCount(packedSlotIndicators);
            for (var i = 0; i < numberOfslotsInEntry; i++) {
                output += this.getIndexAtEntrySlot(entryIndex, i);
                if (i < numberOfslotsInEntry - 1) {
                    output += ", ";
                }
            }
            output += " ] (indexShift = " + indexShift + ")\n";
            var nextLevelIsLeaf = indexShift == LEAF_LEVEL_SHIFT;
            for (var i = 0; i < numberOfslotsInEntry; i++) {
                var nextLevelEntryIndex = this.getIndexAtEntrySlot(entryIndex, i);
                if (nextLevelIsLeaf) {
                    output += this.leafEntryToString(nextLevelEntryIndex, indentLevel + 4);
                }
                else {
                    output += this.nonLeafEntryToString(nextLevelEntryIndex, indexShift - 4, indentLevel + 4);
                }
            }
        }
        catch (ex) {
            output += "Exception thrown at nonLeafEnty at index " + entryIndex + " with indexShift " + indexShift + "\n";
        }
        return output;
    };
    PackedArrayContext.prototype.leafEntryToString = function (entryIndex, indentLevel) {
        var output = "";
        for (var i = 0; i < indentLevel; i++) {
            output += "  ";
        }
        try {
            output += "Leaf bytes : ";
            for (var i = 0; i < 8; i++) {
                output += "0x" + toHex(this.byteArray[entryIndex * 8 + i]) + " ";
            }
            output += "\n";
        }
        catch (ex) {
            output += "Exception thrown at leafEnty at index " + entryIndex + "\n";
        }
        return output;
    };
    PackedArrayContext.prototype.toString = function () {
        var output = "PackedArrayContext:\n";
        if (!this.isPacked) {
            return output + "Context is unpacked:\n"; // unpackedToString();
        }
        for (var setNumber = 0; setNumber < NUMBER_OF_SETS; setNumber++) {
            try {
                var entryPointerIndex = SET_0_START_INDEX + setNumber;
                var entryIndex = this.getIndexAtShortIndex(entryPointerIndex);
                output += "Set " + setNumber + ": root = " + entryIndex + " \n";
                if (entryIndex == 0)
                    continue;
                output += this.nonLeafEntryToString(entryIndex, this.topLevelShift, 4);
            }
            catch (ex) {
                output += "Exception thrown in set " + setNumber + "%d\n";
            }
        }
        //output += recordedValuesToString();
        return output;
    };
    return PackedArrayContext;
}());
exports.PackedArrayContext = PackedArrayContext;
var toHex = function (n) {
    return Number(n)
        .toString(16)
        .padStart(2, "0");
};
//# sourceMappingURL=PackedArrayContext.js.map

/***/ }),

/***/ "../../node_modules/hdr-histogram-js/packedarray/ResizeError.js":
/*!***************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/hdr-histogram-js/packedarray/ResizeError.js ***!
  \***************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*
 * This is a TypeScript port of the original Java version, which was written by
 * Gil Tene as described in
 * https://github.com/HdrHistogram/HdrHistogram
 * and released to the public domain, as explained at
 * http://creativecommons.org/publicdomain/zero/1.0/
 */
var ResizeError = /** @class */ (function () {
    function ResizeError(newSize) {
        this.newSize = newSize;
    }
    return ResizeError;
}());
exports.ResizeError = ResizeError;
//# sourceMappingURL=ResizeError.js.map

/***/ }),

/***/ "../../node_modules/hdr-histogram-js/ulp.js":
/*!*******************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/hdr-histogram-js/ulp.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * This is a TypeScript port of the original Java version, which was written by
 * Gil Tene as described in
 * https://github.com/HdrHistogram/HdrHistogram
 * and released to the public domain, as explained at
 * http://creativecommons.org/publicdomain/zero/1.0/
 */
Object.defineProperty(exports, "__esModule", { value: true });
var ulp = function (x) { return Math.pow(2, Math.floor(Math.log2(x)) - 52); };
exports.default = ulp;
//# sourceMappingURL=ulp.js.map

/***/ }),

/***/ "../../node_modules/import-in-the-middle/index.js":
false,

/***/ "../../node_modules/import-in-the-middle/lib/register.js":
false,

/***/ "../../node_modules/json-parse-better-errors/index.js":
/*!*****************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/json-parse-better-errors/index.js ***!
  \*****************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = parseJson
function parseJson (txt, reviver, context) {
  context = context || 20
  try {
    return JSON.parse(txt, reviver)
  } catch (e) {
    if (typeof txt !== 'string') {
      const isEmptyArray = Array.isArray(txt) && txt.length === 0
      const errorMessage = 'Cannot parse ' +
      (isEmptyArray ? 'an empty array' : String(txt))
      throw new TypeError(errorMessage)
    }
    const syntaxErr = e.message.match(/^Unexpected token.*position\s+(\d+)/i)
    const errIdx = syntaxErr
    ? +syntaxErr[1]
    : e.message.match(/^Unexpected end of JSON.*/i)
    ? txt.length - 1
    : null
    if (errIdx != null) {
      const start = errIdx <= context
      ? 0
      : errIdx - context
      const end = errIdx + context >= txt.length
      ? txt.length
      : errIdx + context
      e.message += ` while parsing near '${
        start === 0 ? '' : '...'
      }${txt.slice(start, end)}${
        end === txt.length ? '' : '...'
      }'`
    } else {
      e.message += ` while parsing '${txt.slice(0, context * 2)}'`
    }
    throw e
  }
}


/***/ }),

/***/ "../../node_modules/load-json-file/index.js":
/*!*******************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/load-json-file/index.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

const path = __webpack_require__(/*! path */ "path");
const fs = __webpack_require__(/*! graceful-fs */ "../../node_modules/graceful-fs/graceful-fs.js");
const stripBom = __webpack_require__(/*! strip-bom */ "../../node_modules/load-json-file/node_modules/strip-bom/index.js");
const parseJson = __webpack_require__(/*! parse-json */ "../../node_modules/load-json-file/node_modules/parse-json/index.js");
const pify = __webpack_require__(/*! pify */ "../../node_modules/load-json-file/node_modules/pify/index.js");

const parse = (data, fp) => parseJson(stripBom(data), path.relative('.', fp));

module.exports = fp => pify(fs.readFile)(fp, 'utf8').then(data => parse(data, fp));
module.exports.sync = fp => parse(fs.readFileSync(fp, 'utf8'), fp);


/***/ }),

/***/ "../../node_modules/load-json-file/node_modules/parse-json/index.js":
/*!*******************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/load-json-file/node_modules/parse-json/index.js ***!
  \*******************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

const errorEx = __webpack_require__(/*! error-ex */ "../../node_modules/error-ex/index.js");
const fallback = __webpack_require__(/*! json-parse-better-errors */ "../../node_modules/json-parse-better-errors/index.js");

const JSONError = errorEx('JSONError', {
	fileName: errorEx.append('in %s')
});

module.exports = (input, reviver, filename) => {
	if (typeof reviver === 'string') {
		filename = reviver;
		reviver = null;
	}

	try {
		try {
			return JSON.parse(input, reviver);
		} catch (err) {
			fallback(input, reviver);

			throw err;
		}
	} catch (err) {
		err.message = err.message.replace(/\n/g, '');

		const jsonErr = new JSONError(err);
		if (filename) {
			jsonErr.fileName = filename;
		}

		throw jsonErr;
	}
};


/***/ }),

/***/ "../../node_modules/load-json-file/node_modules/pify/index.js":
/*!*************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/load-json-file/node_modules/pify/index.js ***!
  \*************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const processFn = (fn, opts) => function () {
	const P = opts.promiseModule;
	const args = new Array(arguments.length);

	for (let i = 0; i < arguments.length; i++) {
		args[i] = arguments[i];
	}

	return new P((resolve, reject) => {
		if (opts.errorFirst) {
			args.push(function (err, result) {
				if (opts.multiArgs) {
					const results = new Array(arguments.length - 1);

					for (let i = 1; i < arguments.length; i++) {
						results[i - 1] = arguments[i];
					}

					if (err) {
						results.unshift(err);
						reject(results);
					} else {
						resolve(results);
					}
				} else if (err) {
					reject(err);
				} else {
					resolve(result);
				}
			});
		} else {
			args.push(function (result) {
				if (opts.multiArgs) {
					const results = new Array(arguments.length - 1);

					for (let i = 0; i < arguments.length; i++) {
						results[i] = arguments[i];
					}

					resolve(results);
				} else {
					resolve(result);
				}
			});
		}

		fn.apply(this, args);
	});
};

module.exports = (obj, opts) => {
	opts = Object.assign({
		exclude: [/.+(Sync|Stream)$/],
		errorFirst: true,
		promiseModule: Promise
	}, opts);

	const filter = key => {
		const match = pattern => typeof pattern === 'string' ? key === pattern : pattern.test(key);
		return opts.include ? opts.include.some(match) : !opts.exclude.some(match);
	};

	let ret;
	if (typeof obj === 'function') {
		ret = function () {
			if (opts.excludeMain) {
				return obj.apply(this, arguments);
			}

			return processFn(obj, opts).apply(this, arguments);
		};
	} else {
		ret = Object.create(Object.getPrototypeOf(obj));
	}

	for (const key in obj) { // eslint-disable-line guard-for-in
		const x = obj[key];
		ret[key] = typeof x === 'function' && filter(key) ? processFn(x, opts) : x;
	}

	return ret;
};


/***/ }),

/***/ "../../node_modules/load-json-file/node_modules/strip-bom/index.js":
/*!******************************************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/load-json-file/node_modules/strip-bom/index.js ***!
  \******************************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = x => {
	if (typeof x !== 'string') {
		throw new TypeError('Expected a string, got ' + typeof x);
	}

	// Catches EFBBBF (UTF-8 BOM) because the buffer-to-string
	// conversion translates it to FEFF (UTF-16 BOM)
	if (x.charCodeAt(0) === 0xFEFF) {
		return x.slice(1);
	}

	return x;
};


/***/ }),

/***/ "../../node_modules/p-limit/index.js":
false,

/***/ "../../node_modules/pako/lib/deflate.js":
/*!***************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/pako/lib/deflate.js ***!
  \***************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";



var zlib_deflate = __webpack_require__(/*! ./zlib/deflate */ "../../node_modules/pako/lib/zlib/deflate.js");
var utils        = __webpack_require__(/*! ./utils/common */ "../../node_modules/pako/lib/utils/common.js");
var strings      = __webpack_require__(/*! ./utils/strings */ "../../node_modules/pako/lib/utils/strings.js");
var msg          = __webpack_require__(/*! ./zlib/messages */ "../../node_modules/pako/lib/zlib/messages.js");
var ZStream      = __webpack_require__(/*! ./zlib/zstream */ "../../node_modules/pako/lib/zlib/zstream.js");

var toString = Object.prototype.toString;

/* Public constants ==========================================================*/
/* ===========================================================================*/

var Z_NO_FLUSH      = 0;
var Z_FINISH        = 4;

var Z_OK            = 0;
var Z_STREAM_END    = 1;
var Z_SYNC_FLUSH    = 2;

var Z_DEFAULT_COMPRESSION = -1;

var Z_DEFAULT_STRATEGY    = 0;

var Z_DEFLATED  = 8;

/* ===========================================================================*/


/**
 * class Deflate
 *
 * Generic JS-style wrapper for zlib calls. If you don't need
 * streaming behaviour - use more simple functions: [[deflate]],
 * [[deflateRaw]] and [[gzip]].
 **/

/* internal
 * Deflate.chunks -> Array
 *
 * Chunks of output data, if [[Deflate#onData]] not overridden.
 **/

/**
 * Deflate.result -> Uint8Array|Array
 *
 * Compressed result, generated by default [[Deflate#onData]]
 * and [[Deflate#onEnd]] handlers. Filled after you push last chunk
 * (call [[Deflate#push]] with `Z_FINISH` / `true` param)  or if you
 * push a chunk with explicit flush (call [[Deflate#push]] with
 * `Z_SYNC_FLUSH` param).
 **/

/**
 * Deflate.err -> Number
 *
 * Error code after deflate finished. 0 (Z_OK) on success.
 * You will not need it in real life, because deflate errors
 * are possible only on wrong options or bad `onData` / `onEnd`
 * custom handlers.
 **/

/**
 * Deflate.msg -> String
 *
 * Error message, if [[Deflate.err]] != 0
 **/


/**
 * new Deflate(options)
 * - options (Object): zlib deflate options.
 *
 * Creates new deflator instance with specified params. Throws exception
 * on bad params. Supported options:
 *
 * - `level`
 * - `windowBits`
 * - `memLevel`
 * - `strategy`
 * - `dictionary`
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Additional options, for internal needs:
 *
 * - `chunkSize` - size of generated data chunks (16K by default)
 * - `raw` (Boolean) - do raw deflate
 * - `gzip` (Boolean) - create gzip wrapper
 * - `to` (String) - if equal to 'string', then result will be "binary string"
 *    (each char code [0..255])
 * - `header` (Object) - custom header for gzip
 *   - `text` (Boolean) - true if compressed data believed to be text
 *   - `time` (Number) - modification time, unix timestamp
 *   - `os` (Number) - operation system code
 *   - `extra` (Array) - array of bytes with extra data (max 65536)
 *   - `name` (String) - file name (binary string)
 *   - `comment` (String) - comment (binary string)
 *   - `hcrc` (Boolean) - true if header crc should be added
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])
 *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);
 *
 * var deflate = new pako.Deflate({ level: 3});
 *
 * deflate.push(chunk1, false);
 * deflate.push(chunk2, true);  // true -> last chunk
 *
 * if (deflate.err) { throw new Error(deflate.err); }
 *
 * console.log(deflate.result);
 * ```
 **/
function Deflate(options) {
  if (!(this instanceof Deflate)) return new Deflate(options);

  this.options = utils.assign({
    level: Z_DEFAULT_COMPRESSION,
    method: Z_DEFLATED,
    chunkSize: 16384,
    windowBits: 15,
    memLevel: 8,
    strategy: Z_DEFAULT_STRATEGY,
    to: ''
  }, options || {});

  var opt = this.options;

  if (opt.raw && (opt.windowBits > 0)) {
    opt.windowBits = -opt.windowBits;
  }

  else if (opt.gzip && (opt.windowBits > 0) && (opt.windowBits < 16)) {
    opt.windowBits += 16;
  }

  this.err    = 0;      // error code, if happens (0 = Z_OK)
  this.msg    = '';     // error message
  this.ended  = false;  // used to avoid multiple onEnd() calls
  this.chunks = [];     // chunks of compressed data

  this.strm = new ZStream();
  this.strm.avail_out = 0;

  var status = zlib_deflate.deflateInit2(
    this.strm,
    opt.level,
    opt.method,
    opt.windowBits,
    opt.memLevel,
    opt.strategy
  );

  if (status !== Z_OK) {
    throw new Error(msg[status]);
  }

  if (opt.header) {
    zlib_deflate.deflateSetHeader(this.strm, opt.header);
  }

  if (opt.dictionary) {
    var dict;
    // Convert data if needed
    if (typeof opt.dictionary === 'string') {
      // If we need to compress text, change encoding to utf8.
      dict = strings.string2buf(opt.dictionary);
    } else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {
      dict = new Uint8Array(opt.dictionary);
    } else {
      dict = opt.dictionary;
    }

    status = zlib_deflate.deflateSetDictionary(this.strm, dict);

    if (status !== Z_OK) {
      throw new Error(msg[status]);
    }

    this._dict_set = true;
  }
}

/**
 * Deflate#push(data[, mode]) -> Boolean
 * - data (Uint8Array|Array|ArrayBuffer|String): input data. Strings will be
 *   converted to utf8 byte sequence.
 * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.
 *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.
 *
 * Sends input data to deflate pipe, generating [[Deflate#onData]] calls with
 * new compressed chunks. Returns `true` on success. The last data block must have
 * mode Z_FINISH (or `true`). That will flush internal pending buffers and call
 * [[Deflate#onEnd]]. For interim explicit flushes (without ending the stream) you
 * can use mode Z_SYNC_FLUSH, keeping the compression context.
 *
 * On fail call [[Deflate#onEnd]] with error code and return false.
 *
 * We strongly recommend to use `Uint8Array` on input for best speed (output
 * array format is detected automatically). Also, don't skip last param and always
 * use the same type in your code (boolean or number). That will improve JS speed.
 *
 * For regular `Array`-s make sure all elements are [0..255].
 *
 * ##### Example
 *
 * ```javascript
 * push(chunk, false); // push one of data chunks
 * ...
 * push(chunk, true);  // push last chunk
 * ```
 **/
Deflate.prototype.push = function (data, mode) {
  var strm = this.strm;
  var chunkSize = this.options.chunkSize;
  var status, _mode;

  if (this.ended) { return false; }

  _mode = (mode === ~~mode) ? mode : ((mode === true) ? Z_FINISH : Z_NO_FLUSH);

  // Convert data if needed
  if (typeof data === 'string') {
    // If we need to compress text, change encoding to utf8.
    strm.input = strings.string2buf(data);
  } else if (toString.call(data) === '[object ArrayBuffer]') {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }

  strm.next_in = 0;
  strm.avail_in = strm.input.length;

  do {
    if (strm.avail_out === 0) {
      strm.output = new utils.Buf8(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }
    status = zlib_deflate.deflate(strm, _mode);    /* no bad return value */

    if (status !== Z_STREAM_END && status !== Z_OK) {
      this.onEnd(status);
      this.ended = true;
      return false;
    }
    if (strm.avail_out === 0 || (strm.avail_in === 0 && (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH))) {
      if (this.options.to === 'string') {
        this.onData(strings.buf2binstring(utils.shrinkBuf(strm.output, strm.next_out)));
      } else {
        this.onData(utils.shrinkBuf(strm.output, strm.next_out));
      }
    }
  } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END);

  // Finalize on the last chunk.
  if (_mode === Z_FINISH) {
    status = zlib_deflate.deflateEnd(this.strm);
    this.onEnd(status);
    this.ended = true;
    return status === Z_OK;
  }

  // callback interim results if Z_SYNC_FLUSH.
  if (_mode === Z_SYNC_FLUSH) {
    this.onEnd(Z_OK);
    strm.avail_out = 0;
    return true;
  }

  return true;
};


/**
 * Deflate#onData(chunk) -> Void
 * - chunk (Uint8Array|Array|String): output data. Type of array depends
 *   on js engine support. When string output requested, each chunk
 *   will be string.
 *
 * By default, stores data blocks in `chunks[]` property and glue
 * those in `onEnd`. Override this handler, if you need another behaviour.
 **/
Deflate.prototype.onData = function (chunk) {
  this.chunks.push(chunk);
};


/**
 * Deflate#onEnd(status) -> Void
 * - status (Number): deflate status. 0 (Z_OK) on success,
 *   other if not.
 *
 * Called once after you tell deflate that the input stream is
 * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)
 * or if an error happened. By default - join collected chunks,
 * free memory and fill `results` / `err` properties.
 **/
Deflate.prototype.onEnd = function (status) {
  // On success - join
  if (status === Z_OK) {
    if (this.options.to === 'string') {
      this.result = this.chunks.join('');
    } else {
      this.result = utils.flattenChunks(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};


/**
 * deflate(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * Compress `data` with deflate algorithm and `options`.
 *
 * Supported options are:
 *
 * - level
 * - windowBits
 * - memLevel
 * - strategy
 * - dictionary
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Sugar (options):
 *
 * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
 *   negative windowBits implicitly.
 * - `to` (String) - if equal to 'string', then result will be "binary string"
 *    (each char code [0..255])
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , data = Uint8Array([1,2,3,4,5,6,7,8,9]);
 *
 * console.log(pako.deflate(data));
 * ```
 **/
function deflate(input, options) {
  var deflator = new Deflate(options);

  deflator.push(input, true);

  // That will never happens, if you don't cheat with options :)
  if (deflator.err) { throw deflator.msg || msg[deflator.err]; }

  return deflator.result;
}


/**
 * deflateRaw(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * The same as [[deflate]], but creates raw data, without wrapper
 * (header and adler32 crc).
 **/
function deflateRaw(input, options) {
  options = options || {};
  options.raw = true;
  return deflate(input, options);
}


/**
 * gzip(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * The same as [[deflate]], but create gzip wrapper instead of
 * deflate one.
 **/
function gzip(input, options) {
  options = options || {};
  options.gzip = true;
  return deflate(input, options);
}


exports.Deflate = Deflate;
exports.deflate = deflate;
exports.deflateRaw = deflateRaw;
exports.gzip = gzip;


/***/ }),

/***/ "../../node_modules/pako/lib/inflate.js":
/*!***************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/pako/lib/inflate.js ***!
  \***************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";



var zlib_inflate = __webpack_require__(/*! ./zlib/inflate */ "../../node_modules/pako/lib/zlib/inflate.js");
var utils        = __webpack_require__(/*! ./utils/common */ "../../node_modules/pako/lib/utils/common.js");
var strings      = __webpack_require__(/*! ./utils/strings */ "../../node_modules/pako/lib/utils/strings.js");
var c            = __webpack_require__(/*! ./zlib/constants */ "../../node_modules/pako/lib/zlib/constants.js");
var msg          = __webpack_require__(/*! ./zlib/messages */ "../../node_modules/pako/lib/zlib/messages.js");
var ZStream      = __webpack_require__(/*! ./zlib/zstream */ "../../node_modules/pako/lib/zlib/zstream.js");
var GZheader     = __webpack_require__(/*! ./zlib/gzheader */ "../../node_modules/pako/lib/zlib/gzheader.js");

var toString = Object.prototype.toString;

/**
 * class Inflate
 *
 * Generic JS-style wrapper for zlib calls. If you don't need
 * streaming behaviour - use more simple functions: [[inflate]]
 * and [[inflateRaw]].
 **/

/* internal
 * inflate.chunks -> Array
 *
 * Chunks of output data, if [[Inflate#onData]] not overridden.
 **/

/**
 * Inflate.result -> Uint8Array|Array|String
 *
 * Uncompressed result, generated by default [[Inflate#onData]]
 * and [[Inflate#onEnd]] handlers. Filled after you push last chunk
 * (call [[Inflate#push]] with `Z_FINISH` / `true` param) or if you
 * push a chunk with explicit flush (call [[Inflate#push]] with
 * `Z_SYNC_FLUSH` param).
 **/

/**
 * Inflate.err -> Number
 *
 * Error code after inflate finished. 0 (Z_OK) on success.
 * Should be checked if broken data possible.
 **/

/**
 * Inflate.msg -> String
 *
 * Error message, if [[Inflate.err]] != 0
 **/


/**
 * new Inflate(options)
 * - options (Object): zlib inflate options.
 *
 * Creates new inflator instance with specified params. Throws exception
 * on bad params. Supported options:
 *
 * - `windowBits`
 * - `dictionary`
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Additional options, for internal needs:
 *
 * - `chunkSize` - size of generated data chunks (16K by default)
 * - `raw` (Boolean) - do raw inflate
 * - `to` (String) - if equal to 'string', then result will be converted
 *   from utf8 to utf16 (javascript) string. When string output requested,
 *   chunk length can differ from `chunkSize`, depending on content.
 *
 * By default, when no options set, autodetect deflate/gzip data format via
 * wrapper header.
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])
 *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);
 *
 * var inflate = new pako.Inflate({ level: 3});
 *
 * inflate.push(chunk1, false);
 * inflate.push(chunk2, true);  // true -> last chunk
 *
 * if (inflate.err) { throw new Error(inflate.err); }
 *
 * console.log(inflate.result);
 * ```
 **/
function Inflate(options) {
  if (!(this instanceof Inflate)) return new Inflate(options);

  this.options = utils.assign({
    chunkSize: 16384,
    windowBits: 0,
    to: ''
  }, options || {});

  var opt = this.options;

  // Force window size for `raw` data, if not set directly,
  // because we have no header for autodetect.
  if (opt.raw && (opt.windowBits >= 0) && (opt.windowBits < 16)) {
    opt.windowBits = -opt.windowBits;
    if (opt.windowBits === 0) { opt.windowBits = -15; }
  }

  // If `windowBits` not defined (and mode not raw) - set autodetect flag for gzip/deflate
  if ((opt.windowBits >= 0) && (opt.windowBits < 16) &&
      !(options && options.windowBits)) {
    opt.windowBits += 32;
  }

  // Gzip header has no info about windows size, we can do autodetect only
  // for deflate. So, if window size not set, force it to max when gzip possible
  if ((opt.windowBits > 15) && (opt.windowBits < 48)) {
    // bit 3 (16) -> gzipped data
    // bit 4 (32) -> autodetect gzip/deflate
    if ((opt.windowBits & 15) === 0) {
      opt.windowBits |= 15;
    }
  }

  this.err    = 0;      // error code, if happens (0 = Z_OK)
  this.msg    = '';     // error message
  this.ended  = false;  // used to avoid multiple onEnd() calls
  this.chunks = [];     // chunks of compressed data

  this.strm   = new ZStream();
  this.strm.avail_out = 0;

  var status  = zlib_inflate.inflateInit2(
    this.strm,
    opt.windowBits
  );

  if (status !== c.Z_OK) {
    throw new Error(msg[status]);
  }

  this.header = new GZheader();

  zlib_inflate.inflateGetHeader(this.strm, this.header);

  // Setup dictionary
  if (opt.dictionary) {
    // Convert data if needed
    if (typeof opt.dictionary === 'string') {
      opt.dictionary = strings.string2buf(opt.dictionary);
    } else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {
      opt.dictionary = new Uint8Array(opt.dictionary);
    }
    if (opt.raw) { //In raw mode we need to set the dictionary early
      status = zlib_inflate.inflateSetDictionary(this.strm, opt.dictionary);
      if (status !== c.Z_OK) {
        throw new Error(msg[status]);
      }
    }
  }
}

/**
 * Inflate#push(data[, mode]) -> Boolean
 * - data (Uint8Array|Array|ArrayBuffer|String): input data
 * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.
 *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.
 *
 * Sends input data to inflate pipe, generating [[Inflate#onData]] calls with
 * new output chunks. Returns `true` on success. The last data block must have
 * mode Z_FINISH (or `true`). That will flush internal pending buffers and call
 * [[Inflate#onEnd]]. For interim explicit flushes (without ending the stream) you
 * can use mode Z_SYNC_FLUSH, keeping the decompression context.
 *
 * On fail call [[Inflate#onEnd]] with error code and return false.
 *
 * We strongly recommend to use `Uint8Array` on input for best speed (output
 * format is detected automatically). Also, don't skip last param and always
 * use the same type in your code (boolean or number). That will improve JS speed.
 *
 * For regular `Array`-s make sure all elements are [0..255].
 *
 * ##### Example
 *
 * ```javascript
 * push(chunk, false); // push one of data chunks
 * ...
 * push(chunk, true);  // push last chunk
 * ```
 **/
Inflate.prototype.push = function (data, mode) {
  var strm = this.strm;
  var chunkSize = this.options.chunkSize;
  var dictionary = this.options.dictionary;
  var status, _mode;
  var next_out_utf8, tail, utf8str;

  // Flag to properly process Z_BUF_ERROR on testing inflate call
  // when we check that all output data was flushed.
  var allowBufError = false;

  if (this.ended) { return false; }
  _mode = (mode === ~~mode) ? mode : ((mode === true) ? c.Z_FINISH : c.Z_NO_FLUSH);

  // Convert data if needed
  if (typeof data === 'string') {
    // Only binary strings can be decompressed on practice
    strm.input = strings.binstring2buf(data);
  } else if (toString.call(data) === '[object ArrayBuffer]') {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }

  strm.next_in = 0;
  strm.avail_in = strm.input.length;

  do {
    if (strm.avail_out === 0) {
      strm.output = new utils.Buf8(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }

    status = zlib_inflate.inflate(strm, c.Z_NO_FLUSH);    /* no bad return value */

    if (status === c.Z_NEED_DICT && dictionary) {
      status = zlib_inflate.inflateSetDictionary(this.strm, dictionary);
    }

    if (status === c.Z_BUF_ERROR && allowBufError === true) {
      status = c.Z_OK;
      allowBufError = false;
    }

    if (status !== c.Z_STREAM_END && status !== c.Z_OK) {
      this.onEnd(status);
      this.ended = true;
      return false;
    }

    if (strm.next_out) {
      if (strm.avail_out === 0 || status === c.Z_STREAM_END || (strm.avail_in === 0 && (_mode === c.Z_FINISH || _mode === c.Z_SYNC_FLUSH))) {

        if (this.options.to === 'string') {

          next_out_utf8 = strings.utf8border(strm.output, strm.next_out);

          tail = strm.next_out - next_out_utf8;
          utf8str = strings.buf2string(strm.output, next_out_utf8);

          // move tail
          strm.next_out = tail;
          strm.avail_out = chunkSize - tail;
          if (tail) { utils.arraySet(strm.output, strm.output, next_out_utf8, tail, 0); }

          this.onData(utf8str);

        } else {
          this.onData(utils.shrinkBuf(strm.output, strm.next_out));
        }
      }
    }

    // When no more input data, we should check that internal inflate buffers
    // are flushed. The only way to do it when avail_out = 0 - run one more
    // inflate pass. But if output data not exists, inflate return Z_BUF_ERROR.
    // Here we set flag to process this error properly.
    //
    // NOTE. Deflate does not return error in this case and does not needs such
    // logic.
    if (strm.avail_in === 0 && strm.avail_out === 0) {
      allowBufError = true;
    }

  } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== c.Z_STREAM_END);

  if (status === c.Z_STREAM_END) {
    _mode = c.Z_FINISH;
  }

  // Finalize on the last chunk.
  if (_mode === c.Z_FINISH) {
    status = zlib_inflate.inflateEnd(this.strm);
    this.onEnd(status);
    this.ended = true;
    return status === c.Z_OK;
  }

  // callback interim results if Z_SYNC_FLUSH.
  if (_mode === c.Z_SYNC_FLUSH) {
    this.onEnd(c.Z_OK);
    strm.avail_out = 0;
    return true;
  }

  return true;
};


/**
 * Inflate#onData(chunk) -> Void
 * - chunk (Uint8Array|Array|String): output data. Type of array depends
 *   on js engine support. When string output requested, each chunk
 *   will be string.
 *
 * By default, stores data blocks in `chunks[]` property and glue
 * those in `onEnd`. Override this handler, if you need another behaviour.
 **/
Inflate.prototype.onData = function (chunk) {
  this.chunks.push(chunk);
};


/**
 * Inflate#onEnd(status) -> Void
 * - status (Number): inflate status. 0 (Z_OK) on success,
 *   other if not.
 *
 * Called either after you tell inflate that the input stream is
 * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)
 * or if an error happened. By default - join collected chunks,
 * free memory and fill `results` / `err` properties.
 **/
Inflate.prototype.onEnd = function (status) {
  // On success - join
  if (status === c.Z_OK) {
    if (this.options.to === 'string') {
      // Glue & convert here, until we teach pako to send
      // utf8 aligned strings to onData
      this.result = this.chunks.join('');
    } else {
      this.result = utils.flattenChunks(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};


/**
 * inflate(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * Decompress `data` with inflate/ungzip and `options`. Autodetect
 * format via wrapper header by default. That's why we don't provide
 * separate `ungzip` method.
 *
 * Supported options are:
 *
 * - windowBits
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information.
 *
 * Sugar (options):
 *
 * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
 *   negative windowBits implicitly.
 * - `to` (String) - if equal to 'string', then result will be converted
 *   from utf8 to utf16 (javascript) string. When string output requested,
 *   chunk length can differ from `chunkSize`, depending on content.
 *
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , input = pako.deflate([1,2,3,4,5,6,7,8,9])
 *   , output;
 *
 * try {
 *   output = pako.inflate(input);
 * } catch (err)
 *   console.log(err);
 * }
 * ```
 **/
function inflate(input, options) {
  var inflator = new Inflate(options);

  inflator.push(input, true);

  // That will never happens, if you don't cheat with options :)
  if (inflator.err) { throw inflator.msg || msg[inflator.err]; }

  return inflator.result;
}


/**
 * inflateRaw(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * The same as [[inflate]], but creates raw data, without wrapper
 * (header and adler32 crc).
 **/
function inflateRaw(input, options) {
  options = options || {};
  options.raw = true;
  return inflate(input, options);
}


/**
 * ungzip(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * Just shortcut to [[inflate]], because it autodetects format
 * by header.content. Done for convenience.
 **/


exports.Inflate = Inflate;
exports.inflate = inflate;
exports.inflateRaw = inflateRaw;
exports.ungzip  = inflate;


/***/ }),

/***/ "../../node_modules/pako/lib/utils/common.js":
/*!********************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/pako/lib/utils/common.js ***!
  \********************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";



var TYPED_OK =  (typeof Uint8Array !== 'undefined') &&
                (typeof Uint16Array !== 'undefined') &&
                (typeof Int32Array !== 'undefined');

function _has(obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key);
}

exports.assign = function (obj /*from1, from2, from3, ...*/) {
  var sources = Array.prototype.slice.call(arguments, 1);
  while (sources.length) {
    var source = sources.shift();
    if (!source) { continue; }

    if (typeof source !== 'object') {
      throw new TypeError(source + 'must be non-object');
    }

    for (var p in source) {
      if (_has(source, p)) {
        obj[p] = source[p];
      }
    }
  }

  return obj;
};


// reduce buffer size, avoiding mem copy
exports.shrinkBuf = function (buf, size) {
  if (buf.length === size) { return buf; }
  if (buf.subarray) { return buf.subarray(0, size); }
  buf.length = size;
  return buf;
};


var fnTyped = {
  arraySet: function (dest, src, src_offs, len, dest_offs) {
    if (src.subarray && dest.subarray) {
      dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
      return;
    }
    // Fallback to ordinary array
    for (var i = 0; i < len; i++) {
      dest[dest_offs + i] = src[src_offs + i];
    }
  },
  // Join array of chunks to single array.
  flattenChunks: function (chunks) {
    var i, l, len, pos, chunk, result;

    // calculate data length
    len = 0;
    for (i = 0, l = chunks.length; i < l; i++) {
      len += chunks[i].length;
    }

    // join chunks
    result = new Uint8Array(len);
    pos = 0;
    for (i = 0, l = chunks.length; i < l; i++) {
      chunk = chunks[i];
      result.set(chunk, pos);
      pos += chunk.length;
    }

    return result;
  }
};

var fnUntyped = {
  arraySet: function (dest, src, src_offs, len, dest_offs) {
    for (var i = 0; i < len; i++) {
      dest[dest_offs + i] = src[src_offs + i];
    }
  },
  // Join array of chunks to single array.
  flattenChunks: function (chunks) {
    return [].concat.apply([], chunks);
  }
};


// Enable/Disable typed arrays use, for testing
//
exports.setTyped = function (on) {
  if (on) {
    exports.Buf8  = Uint8Array;
    exports.Buf16 = Uint16Array;
    exports.Buf32 = Int32Array;
    exports.assign(exports, fnTyped);
  } else {
    exports.Buf8  = Array;
    exports.Buf16 = Array;
    exports.Buf32 = Array;
    exports.assign(exports, fnUntyped);
  }
};

exports.setTyped(TYPED_OK);


/***/ }),

/***/ "../../node_modules/pako/lib/utils/strings.js":
/*!*********************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/pako/lib/utils/strings.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// String encode/decode helpers



var utils = __webpack_require__(/*! ./common */ "../../node_modules/pako/lib/utils/common.js");


// Quick check if we can use fast array to bin string conversion
//
// - apply(Array) can fail on Android 2.2
// - apply(Uint8Array) can fail on iOS 5.1 Safari
//
var STR_APPLY_OK = true;
var STR_APPLY_UIA_OK = true;

try { String.fromCharCode.apply(null, [ 0 ]); } catch (__) { STR_APPLY_OK = false; }
try { String.fromCharCode.apply(null, new Uint8Array(1)); } catch (__) { STR_APPLY_UIA_OK = false; }


// Table with utf8 lengths (calculated by first byte of sequence)
// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,
// because max possible codepoint is 0x10ffff
var _utf8len = new utils.Buf8(256);
for (var q = 0; q < 256; q++) {
  _utf8len[q] = (q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1);
}
_utf8len[254] = _utf8len[254] = 1; // Invalid sequence start


// convert string to array (typed, when possible)
exports.string2buf = function (str) {
  var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;

  // count binary size
  for (m_pos = 0; m_pos < str_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 0xfc00) === 0xdc00) {
        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
        m_pos++;
      }
    }
    buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;
  }

  // allocate buffer
  buf = new utils.Buf8(buf_len);

  // convert
  for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 0xfc00) === 0xdc00) {
        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
        m_pos++;
      }
    }
    if (c < 0x80) {
      /* one byte */
      buf[i++] = c;
    } else if (c < 0x800) {
      /* two bytes */
      buf[i++] = 0xC0 | (c >>> 6);
      buf[i++] = 0x80 | (c & 0x3f);
    } else if (c < 0x10000) {
      /* three bytes */
      buf[i++] = 0xE0 | (c >>> 12);
      buf[i++] = 0x80 | (c >>> 6 & 0x3f);
      buf[i++] = 0x80 | (c & 0x3f);
    } else {
      /* four bytes */
      buf[i++] = 0xf0 | (c >>> 18);
      buf[i++] = 0x80 | (c >>> 12 & 0x3f);
      buf[i++] = 0x80 | (c >>> 6 & 0x3f);
      buf[i++] = 0x80 | (c & 0x3f);
    }
  }

  return buf;
};

// Helper (used in 2 places)
function buf2binstring(buf, len) {
  // On Chrome, the arguments in a function call that are allowed is `65534`.
  // If the length of the buffer is smaller than that, we can use this optimization,
  // otherwise we will take a slower path.
  if (len < 65534) {
    if ((buf.subarray && STR_APPLY_UIA_OK) || (!buf.subarray && STR_APPLY_OK)) {
      return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len));
    }
  }

  var result = '';
  for (var i = 0; i < len; i++) {
    result += String.fromCharCode(buf[i]);
  }
  return result;
}


// Convert byte array to binary string
exports.buf2binstring = function (buf) {
  return buf2binstring(buf, buf.length);
};


// Convert binary string (typed, when possible)
exports.binstring2buf = function (str) {
  var buf = new utils.Buf8(str.length);
  for (var i = 0, len = buf.length; i < len; i++) {
    buf[i] = str.charCodeAt(i);
  }
  return buf;
};


// convert array to string
exports.buf2string = function (buf, max) {
  var i, out, c, c_len;
  var len = max || buf.length;

  // Reserve max possible length (2 words per char)
  // NB: by unknown reasons, Array is significantly faster for
  //     String.fromCharCode.apply than Uint16Array.
  var utf16buf = new Array(len * 2);

  for (out = 0, i = 0; i < len;) {
    c = buf[i++];
    // quick process ascii
    if (c < 0x80) { utf16buf[out++] = c; continue; }

    c_len = _utf8len[c];
    // skip 5 & 6 byte codes
    if (c_len > 4) { utf16buf[out++] = 0xfffd; i += c_len - 1; continue; }

    // apply mask on first byte
    c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;
    // join the rest
    while (c_len > 1 && i < len) {
      c = (c << 6) | (buf[i++] & 0x3f);
      c_len--;
    }

    // terminated by end of string?
    if (c_len > 1) { utf16buf[out++] = 0xfffd; continue; }

    if (c < 0x10000) {
      utf16buf[out++] = c;
    } else {
      c -= 0x10000;
      utf16buf[out++] = 0xd800 | ((c >> 10) & 0x3ff);
      utf16buf[out++] = 0xdc00 | (c & 0x3ff);
    }
  }

  return buf2binstring(utf16buf, out);
};


// Calculate max possible position in utf8 buffer,
// that will not break sequence. If that's not possible
// - (very small limits) return max size as is.
//
// buf[] - utf8 bytes array
// max   - length limit (mandatory);
exports.utf8border = function (buf, max) {
  var pos;

  max = max || buf.length;
  if (max > buf.length) { max = buf.length; }

  // go back from last position, until start of sequence found
  pos = max - 1;
  while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) { pos--; }

  // Very small and broken sequence,
  // return max, because we should return something anyway.
  if (pos < 0) { return max; }

  // If we came to start of buffer - that means buffer is too small,
  // return max too.
  if (pos === 0) { return max; }

  return (pos + _utf8len[buf[pos]] > max) ? pos : max;
};


/***/ }),

/***/ "../../node_modules/pako/lib/zlib/adler32.js":
/*!********************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/pako/lib/zlib/adler32.js ***!
  \********************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// Note: adler32 takes 12% for level 0 and 2% for level 6.
// It isn't worth it to make additional optimizations as in original.
// Small size is preferable.

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

function adler32(adler, buf, len, pos) {
  var s1 = (adler & 0xffff) |0,
      s2 = ((adler >>> 16) & 0xffff) |0,
      n = 0;

  while (len !== 0) {
    // Set limit ~ twice less than 5552, to keep
    // s2 in 31-bits, because we force signed ints.
    // in other case %= will fail.
    n = len > 2000 ? 2000 : len;
    len -= n;

    do {
      s1 = (s1 + buf[pos++]) |0;
      s2 = (s2 + s1) |0;
    } while (--n);

    s1 %= 65521;
    s2 %= 65521;
  }

  return (s1 | (s2 << 16)) |0;
}


module.exports = adler32;


/***/ }),

/***/ "../../node_modules/pako/lib/zlib/constants.js":
/*!**********************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/pako/lib/zlib/constants.js ***!
  \**********************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

module.exports = {

  /* Allowed flush values; see deflate() and inflate() below for details */
  Z_NO_FLUSH:         0,
  Z_PARTIAL_FLUSH:    1,
  Z_SYNC_FLUSH:       2,
  Z_FULL_FLUSH:       3,
  Z_FINISH:           4,
  Z_BLOCK:            5,
  Z_TREES:            6,

  /* Return codes for the compression/decompression functions. Negative values
  * are errors, positive values are used for special but normal events.
  */
  Z_OK:               0,
  Z_STREAM_END:       1,
  Z_NEED_DICT:        2,
  Z_ERRNO:           -1,
  Z_STREAM_ERROR:    -2,
  Z_DATA_ERROR:      -3,
  //Z_MEM_ERROR:     -4,
  Z_BUF_ERROR:       -5,
  //Z_VERSION_ERROR: -6,

  /* compression levels */
  Z_NO_COMPRESSION:         0,
  Z_BEST_SPEED:             1,
  Z_BEST_COMPRESSION:       9,
  Z_DEFAULT_COMPRESSION:   -1,


  Z_FILTERED:               1,
  Z_HUFFMAN_ONLY:           2,
  Z_RLE:                    3,
  Z_FIXED:                  4,
  Z_DEFAULT_STRATEGY:       0,

  /* Possible values of the data_type field (though see inflate()) */
  Z_BINARY:                 0,
  Z_TEXT:                   1,
  //Z_ASCII:                1, // = Z_TEXT (deprecated)
  Z_UNKNOWN:                2,

  /* The deflate compression method */
  Z_DEFLATED:               8
  //Z_NULL:                 null // Use -1 or null inline, depending on var type
};


/***/ }),

/***/ "../../node_modules/pako/lib/zlib/crc32.js":
/*!******************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/pako/lib/zlib/crc32.js ***!
  \******************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// Note: we can't get significant speed boost here.
// So write code to minimize size - no pregenerated tables
// and array tools dependencies.

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

// Use ordinary array, since untyped makes no boost here
function makeTable() {
  var c, table = [];

  for (var n = 0; n < 256; n++) {
    c = n;
    for (var k = 0; k < 8; k++) {
      c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));
    }
    table[n] = c;
  }

  return table;
}

// Create table on load. Just 255 signed longs. Not a problem.
var crcTable = makeTable();


function crc32(crc, buf, len, pos) {
  var t = crcTable,
      end = pos + len;

  crc ^= -1;

  for (var i = pos; i < end; i++) {
    crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xFF];
  }

  return (crc ^ (-1)); // >>> 0;
}


module.exports = crc32;


/***/ }),

/***/ "../../node_modules/pako/lib/zlib/deflate.js":
/*!********************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/pako/lib/zlib/deflate.js ***!
  \********************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

var utils   = __webpack_require__(/*! ../utils/common */ "../../node_modules/pako/lib/utils/common.js");
var trees   = __webpack_require__(/*! ./trees */ "../../node_modules/pako/lib/zlib/trees.js");
var adler32 = __webpack_require__(/*! ./adler32 */ "../../node_modules/pako/lib/zlib/adler32.js");
var crc32   = __webpack_require__(/*! ./crc32 */ "../../node_modules/pako/lib/zlib/crc32.js");
var msg     = __webpack_require__(/*! ./messages */ "../../node_modules/pako/lib/zlib/messages.js");

/* Public constants ==========================================================*/
/* ===========================================================================*/


/* Allowed flush values; see deflate() and inflate() below for details */
var Z_NO_FLUSH      = 0;
var Z_PARTIAL_FLUSH = 1;
//var Z_SYNC_FLUSH    = 2;
var Z_FULL_FLUSH    = 3;
var Z_FINISH        = 4;
var Z_BLOCK         = 5;
//var Z_TREES         = 6;


/* Return codes for the compression/decompression functions. Negative values
 * are errors, positive values are used for special but normal events.
 */
var Z_OK            = 0;
var Z_STREAM_END    = 1;
//var Z_NEED_DICT     = 2;
//var Z_ERRNO         = -1;
var Z_STREAM_ERROR  = -2;
var Z_DATA_ERROR    = -3;
//var Z_MEM_ERROR     = -4;
var Z_BUF_ERROR     = -5;
//var Z_VERSION_ERROR = -6;


/* compression levels */
//var Z_NO_COMPRESSION      = 0;
//var Z_BEST_SPEED          = 1;
//var Z_BEST_COMPRESSION    = 9;
var Z_DEFAULT_COMPRESSION = -1;


var Z_FILTERED            = 1;
var Z_HUFFMAN_ONLY        = 2;
var Z_RLE                 = 3;
var Z_FIXED               = 4;
var Z_DEFAULT_STRATEGY    = 0;

/* Possible values of the data_type field (though see inflate()) */
//var Z_BINARY              = 0;
//var Z_TEXT                = 1;
//var Z_ASCII               = 1; // = Z_TEXT
var Z_UNKNOWN             = 2;


/* The deflate compression method */
var Z_DEFLATED  = 8;

/*============================================================================*/


var MAX_MEM_LEVEL = 9;
/* Maximum value for memLevel in deflateInit2 */
var MAX_WBITS = 15;
/* 32K LZ77 window */
var DEF_MEM_LEVEL = 8;


var LENGTH_CODES  = 29;
/* number of length codes, not counting the special END_BLOCK code */
var LITERALS      = 256;
/* number of literal bytes 0..255 */
var L_CODES       = LITERALS + 1 + LENGTH_CODES;
/* number of Literal or Length codes, including the END_BLOCK code */
var D_CODES       = 30;
/* number of distance codes */
var BL_CODES      = 19;
/* number of codes used to transfer the bit lengths */
var HEAP_SIZE     = 2 * L_CODES + 1;
/* maximum heap size */
var MAX_BITS  = 15;
/* All codes must not exceed MAX_BITS bits */

var MIN_MATCH = 3;
var MAX_MATCH = 258;
var MIN_LOOKAHEAD = (MAX_MATCH + MIN_MATCH + 1);

var PRESET_DICT = 0x20;

var INIT_STATE = 42;
var EXTRA_STATE = 69;
var NAME_STATE = 73;
var COMMENT_STATE = 91;
var HCRC_STATE = 103;
var BUSY_STATE = 113;
var FINISH_STATE = 666;

var BS_NEED_MORE      = 1; /* block not completed, need more input or more output */
var BS_BLOCK_DONE     = 2; /* block flush performed */
var BS_FINISH_STARTED = 3; /* finish started, need only more output at next deflate */
var BS_FINISH_DONE    = 4; /* finish done, accept no more input or output */

var OS_CODE = 0x03; // Unix :) . Don't detect, use this default.

function err(strm, errorCode) {
  strm.msg = msg[errorCode];
  return errorCode;
}

function rank(f) {
  return ((f) << 1) - ((f) > 4 ? 9 : 0);
}

function zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }


/* =========================================================================
 * Flush as much pending output as possible. All deflate() output goes
 * through this function so some applications may wish to modify it
 * to avoid allocating a large strm->output buffer and copying into it.
 * (See also read_buf()).
 */
function flush_pending(strm) {
  var s = strm.state;

  //_tr_flush_bits(s);
  var len = s.pending;
  if (len > strm.avail_out) {
    len = strm.avail_out;
  }
  if (len === 0) { return; }

  utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);
  strm.next_out += len;
  s.pending_out += len;
  strm.total_out += len;
  strm.avail_out -= len;
  s.pending -= len;
  if (s.pending === 0) {
    s.pending_out = 0;
  }
}


function flush_block_only(s, last) {
  trees._tr_flush_block(s, (s.block_start >= 0 ? s.block_start : -1), s.strstart - s.block_start, last);
  s.block_start = s.strstart;
  flush_pending(s.strm);
}


function put_byte(s, b) {
  s.pending_buf[s.pending++] = b;
}


/* =========================================================================
 * Put a short in the pending buffer. The 16-bit value is put in MSB order.
 * IN assertion: the stream state is correct and there is enough room in
 * pending_buf.
 */
function putShortMSB(s, b) {
//  put_byte(s, (Byte)(b >> 8));
//  put_byte(s, (Byte)(b & 0xff));
  s.pending_buf[s.pending++] = (b >>> 8) & 0xff;
  s.pending_buf[s.pending++] = b & 0xff;
}


/* ===========================================================================
 * Read a new buffer from the current input stream, update the adler32
 * and total number of bytes read.  All deflate() input goes through
 * this function so some applications may wish to modify it to avoid
 * allocating a large strm->input buffer and copying from it.
 * (See also flush_pending()).
 */
function read_buf(strm, buf, start, size) {
  var len = strm.avail_in;

  if (len > size) { len = size; }
  if (len === 0) { return 0; }

  strm.avail_in -= len;

  // zmemcpy(buf, strm->next_in, len);
  utils.arraySet(buf, strm.input, strm.next_in, len, start);
  if (strm.state.wrap === 1) {
    strm.adler = adler32(strm.adler, buf, len, start);
  }

  else if (strm.state.wrap === 2) {
    strm.adler = crc32(strm.adler, buf, len, start);
  }

  strm.next_in += len;
  strm.total_in += len;

  return len;
}


/* ===========================================================================
 * Set match_start to the longest match starting at the given string and
 * return its length. Matches shorter or equal to prev_length are discarded,
 * in which case the result is equal to prev_length and match_start is
 * garbage.
 * IN assertions: cur_match is the head of the hash chain for the current
 *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1
 * OUT assertion: the match length is not greater than s->lookahead.
 */
function longest_match(s, cur_match) {
  var chain_length = s.max_chain_length;      /* max hash chain length */
  var scan = s.strstart; /* current string */
  var match;                       /* matched string */
  var len;                           /* length of current match */
  var best_len = s.prev_length;              /* best match length so far */
  var nice_match = s.nice_match;             /* stop if match long enough */
  var limit = (s.strstart > (s.w_size - MIN_LOOKAHEAD)) ?
      s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0/*NIL*/;

  var _win = s.window; // shortcut

  var wmask = s.w_mask;
  var prev  = s.prev;

  /* Stop when cur_match becomes <= limit. To simplify the code,
   * we prevent matches with the string of window index 0.
   */

  var strend = s.strstart + MAX_MATCH;
  var scan_end1  = _win[scan + best_len - 1];
  var scan_end   = _win[scan + best_len];

  /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
   * It is easy to get rid of this optimization if necessary.
   */
  // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");

  /* Do not waste too much time if we already have a good match: */
  if (s.prev_length >= s.good_match) {
    chain_length >>= 2;
  }
  /* Do not look for matches beyond the end of the input. This is necessary
   * to make deflate deterministic.
   */
  if (nice_match > s.lookahead) { nice_match = s.lookahead; }

  // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");

  do {
    // Assert(cur_match < s->strstart, "no future");
    match = cur_match;

    /* Skip to next match if the match length cannot increase
     * or if the match length is less than 2.  Note that the checks below
     * for insufficient lookahead only occur occasionally for performance
     * reasons.  Therefore uninitialized memory will be accessed, and
     * conditional jumps will be made that depend on those values.
     * However the length of the match is limited to the lookahead, so
     * the output of deflate is not affected by the uninitialized values.
     */

    if (_win[match + best_len]     !== scan_end  ||
        _win[match + best_len - 1] !== scan_end1 ||
        _win[match]                !== _win[scan] ||
        _win[++match]              !== _win[scan + 1]) {
      continue;
    }

    /* The check at best_len-1 can be removed because it will be made
     * again later. (This heuristic is not always a win.)
     * It is not necessary to compare scan[2] and match[2] since they
     * are always equal when the other bytes match, given that
     * the hash keys are equal and that HASH_BITS >= 8.
     */
    scan += 2;
    match++;
    // Assert(*scan == *match, "match[2]?");

    /* We check for insufficient lookahead only every 8th comparison;
     * the 256th check will be made at strstart+258.
     */
    do {
      /*jshint noempty:false*/
    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             scan < strend);

    // Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");

    len = MAX_MATCH - (strend - scan);
    scan = strend - MAX_MATCH;

    if (len > best_len) {
      s.match_start = cur_match;
      best_len = len;
      if (len >= nice_match) {
        break;
      }
      scan_end1  = _win[scan + best_len - 1];
      scan_end   = _win[scan + best_len];
    }
  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);

  if (best_len <= s.lookahead) {
    return best_len;
  }
  return s.lookahead;
}


/* ===========================================================================
 * Fill the window when the lookahead becomes insufficient.
 * Updates strstart and lookahead.
 *
 * IN assertion: lookahead < MIN_LOOKAHEAD
 * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD
 *    At least one byte has been read, or avail_in == 0; reads are
 *    performed for at least two bytes (required for the zip translate_eol
 *    option -- not supported here).
 */
function fill_window(s) {
  var _w_size = s.w_size;
  var p, n, m, more, str;

  //Assert(s->lookahead < MIN_LOOKAHEAD, "already enough lookahead");

  do {
    more = s.window_size - s.lookahead - s.strstart;

    // JS ints have 32 bit, block below not needed
    /* Deal with !@#$% 64K limit: */
    //if (sizeof(int) <= 2) {
    //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {
    //        more = wsize;
    //
    //  } else if (more == (unsigned)(-1)) {
    //        /* Very unlikely, but possible on 16 bit machine if
    //         * strstart == 0 && lookahead == 1 (input done a byte at time)
    //         */
    //        more--;
    //    }
    //}


    /* If the window is almost full and there is insufficient lookahead,
     * move the upper half to the lower one to make room in the upper half.
     */
    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {

      utils.arraySet(s.window, s.window, _w_size, _w_size, 0);
      s.match_start -= _w_size;
      s.strstart -= _w_size;
      /* we now have strstart >= MAX_DIST */
      s.block_start -= _w_size;

      /* Slide the hash table (could be avoided with 32 bit values
       at the expense of memory usage). We slide even when level == 0
       to keep the hash table consistent if we switch back to level > 0
       later. (Using level 0 permanently is not an optimal usage of
       zlib, so we don't care about this pathological case.)
       */

      n = s.hash_size;
      p = n;
      do {
        m = s.head[--p];
        s.head[p] = (m >= _w_size ? m - _w_size : 0);
      } while (--n);

      n = _w_size;
      p = n;
      do {
        m = s.prev[--p];
        s.prev[p] = (m >= _w_size ? m - _w_size : 0);
        /* If n is not on any hash chain, prev[n] is garbage but
         * its value will never be used.
         */
      } while (--n);

      more += _w_size;
    }
    if (s.strm.avail_in === 0) {
      break;
    }

    /* If there was no sliding:
     *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&
     *    more == window_size - lookahead - strstart
     * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
     * => more >= window_size - 2*WSIZE + 2
     * In the BIG_MEM or MMAP case (not yet supported),
     *   window_size == input_size + MIN_LOOKAHEAD  &&
     *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.
     * Otherwise, window_size == 2*WSIZE so more >= 2.
     * If there was sliding, more >= WSIZE. So in all cases, more >= 2.
     */
    //Assert(more >= 2, "more < 2");
    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
    s.lookahead += n;

    /* Initialize the hash value now that we have some input: */
    if (s.lookahead + s.insert >= MIN_MATCH) {
      str = s.strstart - s.insert;
      s.ins_h = s.window[str];

      /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */
      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + 1]) & s.hash_mask;
//#if MIN_MATCH != 3
//        Call update_hash() MIN_MATCH-3 more times
//#endif
      while (s.insert) {
        /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;

        s.prev[str & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = str;
        str++;
        s.insert--;
        if (s.lookahead + s.insert < MIN_MATCH) {
          break;
        }
      }
    }
    /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
     * but this is not important since only literal bytes will be emitted.
     */

  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);

  /* If the WIN_INIT bytes after the end of the current data have never been
   * written, then zero those bytes in order to avoid memory check reports of
   * the use of uninitialized (or uninitialised as Julian writes) bytes by
   * the longest match routines.  Update the high water mark for the next
   * time through here.  WIN_INIT is set to MAX_MATCH since the longest match
   * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.
   */
//  if (s.high_water < s.window_size) {
//    var curr = s.strstart + s.lookahead;
//    var init = 0;
//
//    if (s.high_water < curr) {
//      /* Previous high water mark below current data -- zero WIN_INIT
//       * bytes or up to end of window, whichever is less.
//       */
//      init = s.window_size - curr;
//      if (init > WIN_INIT)
//        init = WIN_INIT;
//      zmemzero(s->window + curr, (unsigned)init);
//      s->high_water = curr + init;
//    }
//    else if (s->high_water < (ulg)curr + WIN_INIT) {
//      /* High water mark at or above current data, but below current data
//       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up
//       * to end of window, whichever is less.
//       */
//      init = (ulg)curr + WIN_INIT - s->high_water;
//      if (init > s->window_size - s->high_water)
//        init = s->window_size - s->high_water;
//      zmemzero(s->window + s->high_water, (unsigned)init);
//      s->high_water += init;
//    }
//  }
//
//  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,
//    "not enough room for search");
}

/* ===========================================================================
 * Copy without compression as much as possible from the input stream, return
 * the current block state.
 * This function does not insert new strings in the dictionary since
 * uncompressible data is probably not useful. This function is used
 * only for the level=0 compression option.
 * NOTE: this function should be optimized to avoid extra copying from
 * window to pending_buf.
 */
function deflate_stored(s, flush) {
  /* Stored blocks are limited to 0xffff bytes, pending_buf is limited
   * to pending_buf_size, and each stored block has a 5 byte header:
   */
  var max_block_size = 0xffff;

  if (max_block_size > s.pending_buf_size - 5) {
    max_block_size = s.pending_buf_size - 5;
  }

  /* Copy as much as possible from input to output: */
  for (;;) {
    /* Fill the window as much as possible: */
    if (s.lookahead <= 1) {

      //Assert(s->strstart < s->w_size+MAX_DIST(s) ||
      //  s->block_start >= (long)s->w_size, "slide too late");
//      if (!(s.strstart < s.w_size + (s.w_size - MIN_LOOKAHEAD) ||
//        s.block_start >= s.w_size)) {
//        throw  new Error("slide too late");
//      }

      fill_window(s);
      if (s.lookahead === 0 && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }

      if (s.lookahead === 0) {
        break;
      }
      /* flush the current block */
    }
    //Assert(s->block_start >= 0L, "block gone");
//    if (s.block_start < 0) throw new Error("block gone");

    s.strstart += s.lookahead;
    s.lookahead = 0;

    /* Emit a stored block if pending_buf will be full: */
    var max_start = s.block_start + max_block_size;

    if (s.strstart === 0 || s.strstart >= max_start) {
      /* strstart == 0 is possible when wraparound on 16-bit machine */
      s.lookahead = s.strstart - max_start;
      s.strstart = max_start;
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/


    }
    /* Flush if we may have to slide, otherwise block_start may become
     * negative and the data will be gone:
     */
    if (s.strstart - s.block_start >= (s.w_size - MIN_LOOKAHEAD)) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }

  s.insert = 0;

  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }

  if (s.strstart > s.block_start) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }

  return BS_NEED_MORE;
}

/* ===========================================================================
 * Compress as much as possible from the input stream, return the current
 * block state.
 * This function does not perform lazy evaluation of matches and inserts
 * new strings in the dictionary only for unmatched strings or for short
 * matches. It is used only for the fast compression options.
 */
function deflate_fast(s, flush) {
  var hash_head;        /* head of the hash chain */
  var bflush;           /* set if current block must be flushed */

  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the next match, plus MIN_MATCH bytes to insert the
     * string following the next match.
     */
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break; /* flush the current block */
      }
    }

    /* Insert the string window[strstart .. strstart+2] in the
     * dictionary, and set hash_head to the head of the hash chain:
     */
    hash_head = 0/*NIL*/;
    if (s.lookahead >= MIN_MATCH) {
      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
      /***/
    }

    /* Find the longest match, discarding those <= prev_length.
     * At this point we have always match_length < MIN_MATCH
     */
    if (hash_head !== 0/*NIL*/ && ((s.strstart - hash_head) <= (s.w_size - MIN_LOOKAHEAD))) {
      /* To simplify the code, we prevent matches with the string
       * of window index 0 (in particular we have to avoid a match
       * of the string with itself at the start of the input file).
       */
      s.match_length = longest_match(s, hash_head);
      /* longest_match() sets match_start */
    }
    if (s.match_length >= MIN_MATCH) {
      // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only

      /*** _tr_tally_dist(s, s.strstart - s.match_start,
                     s.match_length - MIN_MATCH, bflush); ***/
      bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);

      s.lookahead -= s.match_length;

      /* Insert new strings in the hash table only if the match length
       * is not too large. This saves time but degrades compression.
       */
      if (s.match_length <= s.max_lazy_match/*max_insert_length*/ && s.lookahead >= MIN_MATCH) {
        s.match_length--; /* string at strstart already in table */
        do {
          s.strstart++;
          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
          /***/
          /* strstart never exceeds WSIZE-MAX_MATCH, so there are
           * always MIN_MATCH bytes ahead.
           */
        } while (--s.match_length !== 0);
        s.strstart++;
      } else
      {
        s.strstart += s.match_length;
        s.match_length = 0;
        s.ins_h = s.window[s.strstart];
        /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */
        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + 1]) & s.hash_mask;

//#if MIN_MATCH != 3
//                Call UPDATE_HASH() MIN_MATCH-3 more times
//#endif
        /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not
         * matter since it will be recomputed at next deflate call.
         */
      }
    } else {
      /* No match, output a literal byte */
      //Tracevv((stderr,"%c", s.window[s.strstart]));
      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);

      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = ((s.strstart < (MIN_MATCH - 1)) ? s.strstart : MIN_MATCH - 1);
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
}

/* ===========================================================================
 * Same as above, but achieves better compression. We use a lazy
 * evaluation for matches: a match is finally adopted only if there is
 * no better match at the next window position.
 */
function deflate_slow(s, flush) {
  var hash_head;          /* head of hash chain */
  var bflush;              /* set if current block must be flushed */

  var max_insert;

  /* Process the input block. */
  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the next match, plus MIN_MATCH bytes to insert the
     * string following the next match.
     */
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) { break; } /* flush the current block */
    }

    /* Insert the string window[strstart .. strstart+2] in the
     * dictionary, and set hash_head to the head of the hash chain:
     */
    hash_head = 0/*NIL*/;
    if (s.lookahead >= MIN_MATCH) {
      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
      /***/
    }

    /* Find the longest match, discarding those <= prev_length.
     */
    s.prev_length = s.match_length;
    s.prev_match = s.match_start;
    s.match_length = MIN_MATCH - 1;

    if (hash_head !== 0/*NIL*/ && s.prev_length < s.max_lazy_match &&
        s.strstart - hash_head <= (s.w_size - MIN_LOOKAHEAD)/*MAX_DIST(s)*/) {
      /* To simplify the code, we prevent matches with the string
       * of window index 0 (in particular we have to avoid a match
       * of the string with itself at the start of the input file).
       */
      s.match_length = longest_match(s, hash_head);
      /* longest_match() sets match_start */

      if (s.match_length <= 5 &&
         (s.strategy === Z_FILTERED || (s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096/*TOO_FAR*/))) {

        /* If prev_match is also MIN_MATCH, match_start is garbage
         * but we will ignore the current match anyway.
         */
        s.match_length = MIN_MATCH - 1;
      }
    }
    /* If there was a match at the previous step and the current
     * match is not better, output the previous match:
     */
    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
      max_insert = s.strstart + s.lookahead - MIN_MATCH;
      /* Do not insert strings in hash table beyond this. */

      //check_match(s, s.strstart-1, s.prev_match, s.prev_length);

      /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,
                     s.prev_length - MIN_MATCH, bflush);***/
      bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
      /* Insert in hash table all strings up to the end of the match.
       * strstart-1 and strstart are already inserted. If there is not
       * enough lookahead, the last two strings are not inserted in
       * the hash table.
       */
      s.lookahead -= s.prev_length - 1;
      s.prev_length -= 2;
      do {
        if (++s.strstart <= max_insert) {
          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
          /***/
        }
      } while (--s.prev_length !== 0);
      s.match_available = 0;
      s.match_length = MIN_MATCH - 1;
      s.strstart++;

      if (bflush) {
        /*** FLUSH_BLOCK(s, 0); ***/
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
        /***/
      }

    } else if (s.match_available) {
      /* If there was no match at the previous position, output a
       * single literal. If there was a match but the current match
       * is longer, truncate the previous match to a single literal.
       */
      //Tracevv((stderr,"%c", s->window[s->strstart-1]));
      /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
      bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);

      if (bflush) {
        /*** FLUSH_BLOCK_ONLY(s, 0) ***/
        flush_block_only(s, false);
        /***/
      }
      s.strstart++;
      s.lookahead--;
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    } else {
      /* There is no previous match to compare with, wait for
       * the next step to decide.
       */
      s.match_available = 1;
      s.strstart++;
      s.lookahead--;
    }
  }
  //Assert (flush != Z_NO_FLUSH, "no flush?");
  if (s.match_available) {
    //Tracevv((stderr,"%c", s->window[s->strstart-1]));
    /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
    bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);

    s.match_available = 0;
  }
  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }

  return BS_BLOCK_DONE;
}


/* ===========================================================================
 * For Z_RLE, simply look for runs of bytes, generate matches only of distance
 * one.  Do not maintain a hash table.  (It will be regenerated if this run of
 * deflate switches away from Z_RLE.)
 */
function deflate_rle(s, flush) {
  var bflush;            /* set if current block must be flushed */
  var prev;              /* byte at distance one to match */
  var scan, strend;      /* scan goes up to strend for length of run */

  var _win = s.window;

  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the longest run, plus one for the unrolled loop.
     */
    if (s.lookahead <= MAX_MATCH) {
      fill_window(s);
      if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) { break; } /* flush the current block */
    }

    /* See how many times the previous byte repeats */
    s.match_length = 0;
    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
      scan = s.strstart - 1;
      prev = _win[scan];
      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
        strend = s.strstart + MAX_MATCH;
        do {
          /*jshint noempty:false*/
        } while (prev === _win[++scan] && prev === _win[++scan] &&
                 prev === _win[++scan] && prev === _win[++scan] &&
                 prev === _win[++scan] && prev === _win[++scan] &&
                 prev === _win[++scan] && prev === _win[++scan] &&
                 scan < strend);
        s.match_length = MAX_MATCH - (strend - scan);
        if (s.match_length > s.lookahead) {
          s.match_length = s.lookahead;
        }
      }
      //Assert(scan <= s->window+(uInt)(s->window_size-1), "wild scan");
    }

    /* Emit match if have run of MIN_MATCH or longer, else emit literal */
    if (s.match_length >= MIN_MATCH) {
      //check_match(s, s.strstart, s.strstart - 1, s.match_length);

      /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/
      bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);

      s.lookahead -= s.match_length;
      s.strstart += s.match_length;
      s.match_length = 0;
    } else {
      /* No match, output a literal byte */
      //Tracevv((stderr,"%c", s->window[s->strstart]));
      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);

      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
}

/* ===========================================================================
 * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.
 * (It will be regenerated if this run of deflate switches away from Huffman.)
 */
function deflate_huff(s, flush) {
  var bflush;             /* set if current block must be flushed */

  for (;;) {
    /* Make sure that we have a literal to write. */
    if (s.lookahead === 0) {
      fill_window(s);
      if (s.lookahead === 0) {
        if (flush === Z_NO_FLUSH) {
          return BS_NEED_MORE;
        }
        break;      /* flush the current block */
      }
    }

    /* Output a literal byte */
    s.match_length = 0;
    //Tracevv((stderr,"%c", s->window[s->strstart]));
    /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
    bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
    s.lookahead--;
    s.strstart++;
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
}

/* Values for max_lazy_match, good_match and max_chain_length, depending on
 * the desired pack level (0..9). The values given below have been tuned to
 * exclude worst case performance for pathological files. Better values may be
 * found for specific files.
 */
function Config(good_length, max_lazy, nice_length, max_chain, func) {
  this.good_length = good_length;
  this.max_lazy = max_lazy;
  this.nice_length = nice_length;
  this.max_chain = max_chain;
  this.func = func;
}

var configuration_table;

configuration_table = [
  /*      good lazy nice chain */
  new Config(0, 0, 0, 0, deflate_stored),          /* 0 store only */
  new Config(4, 4, 8, 4, deflate_fast),            /* 1 max speed, no lazy matches */
  new Config(4, 5, 16, 8, deflate_fast),           /* 2 */
  new Config(4, 6, 32, 32, deflate_fast),          /* 3 */

  new Config(4, 4, 16, 16, deflate_slow),          /* 4 lazy matches */
  new Config(8, 16, 32, 32, deflate_slow),         /* 5 */
  new Config(8, 16, 128, 128, deflate_slow),       /* 6 */
  new Config(8, 32, 128, 256, deflate_slow),       /* 7 */
  new Config(32, 128, 258, 1024, deflate_slow),    /* 8 */
  new Config(32, 258, 258, 4096, deflate_slow)     /* 9 max compression */
];


/* ===========================================================================
 * Initialize the "longest match" routines for a new zlib stream
 */
function lm_init(s) {
  s.window_size = 2 * s.w_size;

  /*** CLEAR_HASH(s); ***/
  zero(s.head); // Fill with NIL (= 0);

  /* Set the default configuration parameters:
   */
  s.max_lazy_match = configuration_table[s.level].max_lazy;
  s.good_match = configuration_table[s.level].good_length;
  s.nice_match = configuration_table[s.level].nice_length;
  s.max_chain_length = configuration_table[s.level].max_chain;

  s.strstart = 0;
  s.block_start = 0;
  s.lookahead = 0;
  s.insert = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  s.ins_h = 0;
}


function DeflateState() {
  this.strm = null;            /* pointer back to this zlib stream */
  this.status = 0;            /* as the name implies */
  this.pending_buf = null;      /* output still pending */
  this.pending_buf_size = 0;  /* size of pending_buf */
  this.pending_out = 0;       /* next pending byte to output to the stream */
  this.pending = 0;           /* nb of bytes in the pending buffer */
  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */
  this.gzhead = null;         /* gzip header information to write */
  this.gzindex = 0;           /* where in extra, name, or comment */
  this.method = Z_DEFLATED; /* can only be DEFLATED */
  this.last_flush = -1;   /* value of flush param for previous deflate call */

  this.w_size = 0;  /* LZ77 window size (32K by default) */
  this.w_bits = 0;  /* log2(w_size)  (8..16) */
  this.w_mask = 0;  /* w_size - 1 */

  this.window = null;
  /* Sliding window. Input bytes are read into the second half of the window,
   * and move to the first half later to keep a dictionary of at least wSize
   * bytes. With this organization, matches are limited to a distance of
   * wSize-MAX_MATCH bytes, but this ensures that IO is always
   * performed with a length multiple of the block size.
   */

  this.window_size = 0;
  /* Actual size of window: 2*wSize, except when the user input buffer
   * is directly used as sliding window.
   */

  this.prev = null;
  /* Link to older string with same hash index. To limit the size of this
   * array to 64K, this link is maintained only for the last 32K strings.
   * An index in this array is thus a window index modulo 32K.
   */

  this.head = null;   /* Heads of the hash chains or NIL. */

  this.ins_h = 0;       /* hash index of string to be inserted */
  this.hash_size = 0;   /* number of elements in hash table */
  this.hash_bits = 0;   /* log2(hash_size) */
  this.hash_mask = 0;   /* hash_size-1 */

  this.hash_shift = 0;
  /* Number of bits by which ins_h must be shifted at each input
   * step. It must be such that after MIN_MATCH steps, the oldest
   * byte no longer takes part in the hash key, that is:
   *   hash_shift * MIN_MATCH >= hash_bits
   */

  this.block_start = 0;
  /* Window position at the beginning of the current output block. Gets
   * negative when the window is moved backwards.
   */

  this.match_length = 0;      /* length of best match */
  this.prev_match = 0;        /* previous match */
  this.match_available = 0;   /* set if previous match exists */
  this.strstart = 0;          /* start of string to insert */
  this.match_start = 0;       /* start of matching string */
  this.lookahead = 0;         /* number of valid bytes ahead in window */

  this.prev_length = 0;
  /* Length of the best match at previous step. Matches not greater than this
   * are discarded. This is used in the lazy match evaluation.
   */

  this.max_chain_length = 0;
  /* To speed up deflation, hash chains are never searched beyond this
   * length.  A higher limit improves compression ratio but degrades the
   * speed.
   */

  this.max_lazy_match = 0;
  /* Attempt to find a better match only when the current match is strictly
   * smaller than this value. This mechanism is used only for compression
   * levels >= 4.
   */
  // That's alias to max_lazy_match, don't use directly
  //this.max_insert_length = 0;
  /* Insert new strings in the hash table only if the match length is not
   * greater than this length. This saves time but degrades compression.
   * max_insert_length is used only for compression levels <= 3.
   */

  this.level = 0;     /* compression level (1..9) */
  this.strategy = 0;  /* favor or force Huffman coding*/

  this.good_match = 0;
  /* Use a faster search when the previous match is longer than this */

  this.nice_match = 0; /* Stop searching when current match exceeds this */

              /* used by trees.c: */

  /* Didn't use ct_data typedef below to suppress compiler warning */

  // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */
  // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */
  // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */

  // Use flat array of DOUBLE size, with interleaved fata,
  // because JS does not support effective
  this.dyn_ltree  = new utils.Buf16(HEAP_SIZE * 2);
  this.dyn_dtree  = new utils.Buf16((2 * D_CODES + 1) * 2);
  this.bl_tree    = new utils.Buf16((2 * BL_CODES + 1) * 2);
  zero(this.dyn_ltree);
  zero(this.dyn_dtree);
  zero(this.bl_tree);

  this.l_desc   = null;         /* desc. for literal tree */
  this.d_desc   = null;         /* desc. for distance tree */
  this.bl_desc  = null;         /* desc. for bit length tree */

  //ush bl_count[MAX_BITS+1];
  this.bl_count = new utils.Buf16(MAX_BITS + 1);
  /* number of codes at each bit length for an optimal tree */

  //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */
  this.heap = new utils.Buf16(2 * L_CODES + 1);  /* heap used to build the Huffman trees */
  zero(this.heap);

  this.heap_len = 0;               /* number of elements in the heap */
  this.heap_max = 0;               /* element of largest frequency */
  /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.
   * The same heap array is used to build all trees.
   */

  this.depth = new utils.Buf16(2 * L_CODES + 1); //uch depth[2*L_CODES+1];
  zero(this.depth);
  /* Depth of each subtree used as tie breaker for trees of equal frequency
   */

  this.l_buf = 0;          /* buffer index for literals or lengths */

  this.lit_bufsize = 0;
  /* Size of match buffer for literals/lengths.  There are 4 reasons for
   * limiting lit_bufsize to 64K:
   *   - frequencies can be kept in 16 bit counters
   *   - if compression is not successful for the first block, all input
   *     data is still in the window so we can still emit a stored block even
   *     when input comes from standard input.  (This can also be done for
   *     all blocks if lit_bufsize is not greater than 32K.)
   *   - if compression is not successful for a file smaller than 64K, we can
   *     even emit a stored file instead of a stored block (saving 5 bytes).
   *     This is applicable only for zip (not gzip or zlib).
   *   - creating new Huffman trees less frequently may not provide fast
   *     adaptation to changes in the input data statistics. (Take for
   *     example a binary file with poorly compressible code followed by
   *     a highly compressible string table.) Smaller buffer sizes give
   *     fast adaptation but have of course the overhead of transmitting
   *     trees more frequently.
   *   - I can't count above 4
   */

  this.last_lit = 0;      /* running index in l_buf */

  this.d_buf = 0;
  /* Buffer index for distances. To simplify the code, d_buf and l_buf have
   * the same number of elements. To use different lengths, an extra flag
   * array would be necessary.
   */

  this.opt_len = 0;       /* bit length of current block with optimal trees */
  this.static_len = 0;    /* bit length of current block with static trees */
  this.matches = 0;       /* number of string matches in current block */
  this.insert = 0;        /* bytes at end of window left to insert */


  this.bi_buf = 0;
  /* Output buffer. bits are inserted starting at the bottom (least
   * significant bits).
   */
  this.bi_valid = 0;
  /* Number of valid bits in bi_buf.  All bits above the last valid bit
   * are always zero.
   */

  // Used for window memory init. We safely ignore it for JS. That makes
  // sense only for pointers and memory check tools.
  //this.high_water = 0;
  /* High water mark offset in window for initialized bytes -- bytes above
   * this are set to zero in order to avoid memory check warnings when
   * longest match routines access bytes past the input.  This is then
   * updated to the new high water mark.
   */
}


function deflateResetKeep(strm) {
  var s;

  if (!strm || !strm.state) {
    return err(strm, Z_STREAM_ERROR);
  }

  strm.total_in = strm.total_out = 0;
  strm.data_type = Z_UNKNOWN;

  s = strm.state;
  s.pending = 0;
  s.pending_out = 0;

  if (s.wrap < 0) {
    s.wrap = -s.wrap;
    /* was made negative by deflate(..., Z_FINISH); */
  }
  s.status = (s.wrap ? INIT_STATE : BUSY_STATE);
  strm.adler = (s.wrap === 2) ?
    0  // crc32(0, Z_NULL, 0)
  :
    1; // adler32(0, Z_NULL, 0)
  s.last_flush = Z_NO_FLUSH;
  trees._tr_init(s);
  return Z_OK;
}


function deflateReset(strm) {
  var ret = deflateResetKeep(strm);
  if (ret === Z_OK) {
    lm_init(strm.state);
  }
  return ret;
}


function deflateSetHeader(strm, head) {
  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  if (strm.state.wrap !== 2) { return Z_STREAM_ERROR; }
  strm.state.gzhead = head;
  return Z_OK;
}


function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
  if (!strm) { // === Z_NULL
    return Z_STREAM_ERROR;
  }
  var wrap = 1;

  if (level === Z_DEFAULT_COMPRESSION) {
    level = 6;
  }

  if (windowBits < 0) { /* suppress zlib wrapper */
    wrap = 0;
    windowBits = -windowBits;
  }

  else if (windowBits > 15) {
    wrap = 2;           /* write gzip wrapper instead */
    windowBits -= 16;
  }


  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED ||
    windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||
    strategy < 0 || strategy > Z_FIXED) {
    return err(strm, Z_STREAM_ERROR);
  }


  if (windowBits === 8) {
    windowBits = 9;
  }
  /* until 256-byte window bug fixed */

  var s = new DeflateState();

  strm.state = s;
  s.strm = strm;

  s.wrap = wrap;
  s.gzhead = null;
  s.w_bits = windowBits;
  s.w_size = 1 << s.w_bits;
  s.w_mask = s.w_size - 1;

  s.hash_bits = memLevel + 7;
  s.hash_size = 1 << s.hash_bits;
  s.hash_mask = s.hash_size - 1;
  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);

  s.window = new utils.Buf8(s.w_size * 2);
  s.head = new utils.Buf16(s.hash_size);
  s.prev = new utils.Buf16(s.w_size);

  // Don't need mem init magic for JS.
  //s.high_water = 0;  /* nothing written to s->window yet */

  s.lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */

  s.pending_buf_size = s.lit_bufsize * 4;

  //overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);
  //s->pending_buf = (uchf *) overlay;
  s.pending_buf = new utils.Buf8(s.pending_buf_size);

  // It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)
  //s->d_buf = overlay + s->lit_bufsize/sizeof(ush);
  s.d_buf = 1 * s.lit_bufsize;

  //s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;
  s.l_buf = (1 + 2) * s.lit_bufsize;

  s.level = level;
  s.strategy = strategy;
  s.method = method;

  return deflateReset(strm);
}

function deflateInit(strm, level) {
  return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
}


function deflate(strm, flush) {
  var old_flush, s;
  var beg, val; // for gzip header write only

  if (!strm || !strm.state ||
    flush > Z_BLOCK || flush < 0) {
    return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
  }

  s = strm.state;

  if (!strm.output ||
      (!strm.input && strm.avail_in !== 0) ||
      (s.status === FINISH_STATE && flush !== Z_FINISH)) {
    return err(strm, (strm.avail_out === 0) ? Z_BUF_ERROR : Z_STREAM_ERROR);
  }

  s.strm = strm; /* just in case */
  old_flush = s.last_flush;
  s.last_flush = flush;

  /* Write the header */
  if (s.status === INIT_STATE) {

    if (s.wrap === 2) { // GZIP header
      strm.adler = 0;  //crc32(0L, Z_NULL, 0);
      put_byte(s, 31);
      put_byte(s, 139);
      put_byte(s, 8);
      if (!s.gzhead) { // s->gzhead == Z_NULL
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, s.level === 9 ? 2 :
                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?
                     4 : 0));
        put_byte(s, OS_CODE);
        s.status = BUSY_STATE;
      }
      else {
        put_byte(s, (s.gzhead.text ? 1 : 0) +
                    (s.gzhead.hcrc ? 2 : 0) +
                    (!s.gzhead.extra ? 0 : 4) +
                    (!s.gzhead.name ? 0 : 8) +
                    (!s.gzhead.comment ? 0 : 16)
        );
        put_byte(s, s.gzhead.time & 0xff);
        put_byte(s, (s.gzhead.time >> 8) & 0xff);
        put_byte(s, (s.gzhead.time >> 16) & 0xff);
        put_byte(s, (s.gzhead.time >> 24) & 0xff);
        put_byte(s, s.level === 9 ? 2 :
                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?
                     4 : 0));
        put_byte(s, s.gzhead.os & 0xff);
        if (s.gzhead.extra && s.gzhead.extra.length) {
          put_byte(s, s.gzhead.extra.length & 0xff);
          put_byte(s, (s.gzhead.extra.length >> 8) & 0xff);
        }
        if (s.gzhead.hcrc) {
          strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);
        }
        s.gzindex = 0;
        s.status = EXTRA_STATE;
      }
    }
    else // DEFLATE header
    {
      var header = (Z_DEFLATED + ((s.w_bits - 8) << 4)) << 8;
      var level_flags = -1;

      if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
        level_flags = 0;
      } else if (s.level < 6) {
        level_flags = 1;
      } else if (s.level === 6) {
        level_flags = 2;
      } else {
        level_flags = 3;
      }
      header |= (level_flags << 6);
      if (s.strstart !== 0) { header |= PRESET_DICT; }
      header += 31 - (header % 31);

      s.status = BUSY_STATE;
      putShortMSB(s, header);

      /* Save the adler32 of the preset dictionary: */
      if (s.strstart !== 0) {
        putShortMSB(s, strm.adler >>> 16);
        putShortMSB(s, strm.adler & 0xffff);
      }
      strm.adler = 1; // adler32(0L, Z_NULL, 0);
    }
  }

//#ifdef GZIP
  if (s.status === EXTRA_STATE) {
    if (s.gzhead.extra/* != Z_NULL*/) {
      beg = s.pending;  /* start of bytes to update crc */

      while (s.gzindex < (s.gzhead.extra.length & 0xffff)) {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            break;
          }
        }
        put_byte(s, s.gzhead.extra[s.gzindex] & 0xff);
        s.gzindex++;
      }
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (s.gzindex === s.gzhead.extra.length) {
        s.gzindex = 0;
        s.status = NAME_STATE;
      }
    }
    else {
      s.status = NAME_STATE;
    }
  }
  if (s.status === NAME_STATE) {
    if (s.gzhead.name/* != Z_NULL*/) {
      beg = s.pending;  /* start of bytes to update crc */
      //int val;

      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            val = 1;
            break;
          }
        }
        // JS specific: little magic to add zero terminator to end of string
        if (s.gzindex < s.gzhead.name.length) {
          val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);

      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (val === 0) {
        s.gzindex = 0;
        s.status = COMMENT_STATE;
      }
    }
    else {
      s.status = COMMENT_STATE;
    }
  }
  if (s.status === COMMENT_STATE) {
    if (s.gzhead.comment/* != Z_NULL*/) {
      beg = s.pending;  /* start of bytes to update crc */
      //int val;

      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            val = 1;
            break;
          }
        }
        // JS specific: little magic to add zero terminator to end of string
        if (s.gzindex < s.gzhead.comment.length) {
          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);

      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (val === 0) {
        s.status = HCRC_STATE;
      }
    }
    else {
      s.status = HCRC_STATE;
    }
  }
  if (s.status === HCRC_STATE) {
    if (s.gzhead.hcrc) {
      if (s.pending + 2 > s.pending_buf_size) {
        flush_pending(strm);
      }
      if (s.pending + 2 <= s.pending_buf_size) {
        put_byte(s, strm.adler & 0xff);
        put_byte(s, (strm.adler >> 8) & 0xff);
        strm.adler = 0; //crc32(0L, Z_NULL, 0);
        s.status = BUSY_STATE;
      }
    }
    else {
      s.status = BUSY_STATE;
    }
  }
//#endif

  /* Flush as much pending output as possible */
  if (s.pending !== 0) {
    flush_pending(strm);
    if (strm.avail_out === 0) {
      /* Since avail_out is 0, deflate will be called again with
       * more output space, but possibly with both pending and
       * avail_in equal to zero. There won't be anything to do,
       * but this is not an error situation so make sure we
       * return OK instead of BUF_ERROR at next call of deflate:
       */
      s.last_flush = -1;
      return Z_OK;
    }

    /* Make sure there is something to do and avoid duplicate consecutive
     * flushes. For repeated and useless calls with Z_FINISH, we keep
     * returning Z_STREAM_END instead of Z_BUF_ERROR.
     */
  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) &&
    flush !== Z_FINISH) {
    return err(strm, Z_BUF_ERROR);
  }

  /* User must not provide more input after the first FINISH: */
  if (s.status === FINISH_STATE && strm.avail_in !== 0) {
    return err(strm, Z_BUF_ERROR);
  }

  /* Start a new block or continue the current one.
   */
  if (strm.avail_in !== 0 || s.lookahead !== 0 ||
    (flush !== Z_NO_FLUSH && s.status !== FINISH_STATE)) {
    var bstate = (s.strategy === Z_HUFFMAN_ONLY) ? deflate_huff(s, flush) :
      (s.strategy === Z_RLE ? deflate_rle(s, flush) :
        configuration_table[s.level].func(s, flush));

    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
      s.status = FINISH_STATE;
    }
    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
      if (strm.avail_out === 0) {
        s.last_flush = -1;
        /* avoid BUF_ERROR next call, see above */
      }
      return Z_OK;
      /* If flush != Z_NO_FLUSH && avail_out == 0, the next call
       * of deflate should use the same flush parameter to make sure
       * that the flush is complete. So we don't have to output an
       * empty block here, this will be done at next call. This also
       * ensures that for a very small output buffer, we emit at most
       * one empty block.
       */
    }
    if (bstate === BS_BLOCK_DONE) {
      if (flush === Z_PARTIAL_FLUSH) {
        trees._tr_align(s);
      }
      else if (flush !== Z_BLOCK) { /* FULL_FLUSH or SYNC_FLUSH */

        trees._tr_stored_block(s, 0, 0, false);
        /* For a full flush, this empty block will be recognized
         * as a special marker by inflate_sync().
         */
        if (flush === Z_FULL_FLUSH) {
          /*** CLEAR_HASH(s); ***/             /* forget history */
          zero(s.head); // Fill with NIL (= 0);

          if (s.lookahead === 0) {
            s.strstart = 0;
            s.block_start = 0;
            s.insert = 0;
          }
        }
      }
      flush_pending(strm);
      if (strm.avail_out === 0) {
        s.last_flush = -1; /* avoid BUF_ERROR at next call, see above */
        return Z_OK;
      }
    }
  }
  //Assert(strm->avail_out > 0, "bug2");
  //if (strm.avail_out <= 0) { throw new Error("bug2");}

  if (flush !== Z_FINISH) { return Z_OK; }
  if (s.wrap <= 0) { return Z_STREAM_END; }

  /* Write the trailer */
  if (s.wrap === 2) {
    put_byte(s, strm.adler & 0xff);
    put_byte(s, (strm.adler >> 8) & 0xff);
    put_byte(s, (strm.adler >> 16) & 0xff);
    put_byte(s, (strm.adler >> 24) & 0xff);
    put_byte(s, strm.total_in & 0xff);
    put_byte(s, (strm.total_in >> 8) & 0xff);
    put_byte(s, (strm.total_in >> 16) & 0xff);
    put_byte(s, (strm.total_in >> 24) & 0xff);
  }
  else
  {
    putShortMSB(s, strm.adler >>> 16);
    putShortMSB(s, strm.adler & 0xffff);
  }

  flush_pending(strm);
  /* If avail_out is zero, the application will call deflate again
   * to flush the rest.
   */
  if (s.wrap > 0) { s.wrap = -s.wrap; }
  /* write the trailer only once! */
  return s.pending !== 0 ? Z_OK : Z_STREAM_END;
}

function deflateEnd(strm) {
  var status;

  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {
    return Z_STREAM_ERROR;
  }

  status = strm.state.status;
  if (status !== INIT_STATE &&
    status !== EXTRA_STATE &&
    status !== NAME_STATE &&
    status !== COMMENT_STATE &&
    status !== HCRC_STATE &&
    status !== BUSY_STATE &&
    status !== FINISH_STATE
  ) {
    return err(strm, Z_STREAM_ERROR);
  }

  strm.state = null;

  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
}


/* =========================================================================
 * Initializes the compression dictionary from the given byte
 * sequence without producing any compressed output.
 */
function deflateSetDictionary(strm, dictionary) {
  var dictLength = dictionary.length;

  var s;
  var str, n;
  var wrap;
  var avail;
  var next;
  var input;
  var tmpDict;

  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {
    return Z_STREAM_ERROR;
  }

  s = strm.state;
  wrap = s.wrap;

  if (wrap === 2 || (wrap === 1 && s.status !== INIT_STATE) || s.lookahead) {
    return Z_STREAM_ERROR;
  }

  /* when using zlib wrappers, compute Adler-32 for provided dictionary */
  if (wrap === 1) {
    /* adler32(strm->adler, dictionary, dictLength); */
    strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
  }

  s.wrap = 0;   /* avoid computing Adler-32 in read_buf */

  /* if dictionary would fill window, just replace the history */
  if (dictLength >= s.w_size) {
    if (wrap === 0) {            /* already empty otherwise */
      /*** CLEAR_HASH(s); ***/
      zero(s.head); // Fill with NIL (= 0);
      s.strstart = 0;
      s.block_start = 0;
      s.insert = 0;
    }
    /* use the tail */
    // dictionary = dictionary.slice(dictLength - s.w_size);
    tmpDict = new utils.Buf8(s.w_size);
    utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);
    dictionary = tmpDict;
    dictLength = s.w_size;
  }
  /* insert dictionary into window and hash */
  avail = strm.avail_in;
  next = strm.next_in;
  input = strm.input;
  strm.avail_in = dictLength;
  strm.next_in = 0;
  strm.input = dictionary;
  fill_window(s);
  while (s.lookahead >= MIN_MATCH) {
    str = s.strstart;
    n = s.lookahead - (MIN_MATCH - 1);
    do {
      /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;

      s.prev[str & s.w_mask] = s.head[s.ins_h];

      s.head[s.ins_h] = str;
      str++;
    } while (--n);
    s.strstart = str;
    s.lookahead = MIN_MATCH - 1;
    fill_window(s);
  }
  s.strstart += s.lookahead;
  s.block_start = s.strstart;
  s.insert = s.lookahead;
  s.lookahead = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  strm.next_in = next;
  strm.input = input;
  strm.avail_in = avail;
  s.wrap = wrap;
  return Z_OK;
}


exports.deflateInit = deflateInit;
exports.deflateInit2 = deflateInit2;
exports.deflateReset = deflateReset;
exports.deflateResetKeep = deflateResetKeep;
exports.deflateSetHeader = deflateSetHeader;
exports.deflate = deflate;
exports.deflateEnd = deflateEnd;
exports.deflateSetDictionary = deflateSetDictionary;
exports.deflateInfo = 'pako deflate (from Nodeca project)';

/* Not implemented
exports.deflateBound = deflateBound;
exports.deflateCopy = deflateCopy;
exports.deflateParams = deflateParams;
exports.deflatePending = deflatePending;
exports.deflatePrime = deflatePrime;
exports.deflateTune = deflateTune;
*/


/***/ }),

/***/ "../../node_modules/pako/lib/zlib/gzheader.js":
/*!*********************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/pako/lib/zlib/gzheader.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

function GZheader() {
  /* true if compressed data believed to be text */
  this.text       = 0;
  /* modification time */
  this.time       = 0;
  /* extra flags (not used when writing a gzip file) */
  this.xflags     = 0;
  /* operating system */
  this.os         = 0;
  /* pointer to extra field or Z_NULL if none */
  this.extra      = null;
  /* extra field length (valid if extra != Z_NULL) */
  this.extra_len  = 0; // Actually, we don't need it in JS,
                       // but leave for few code modifications

  //
  // Setup limits is not necessary because in js we should not preallocate memory
  // for inflate use constant limit in 65536 bytes
  //

  /* space at extra (only when reading header) */
  // this.extra_max  = 0;
  /* pointer to zero-terminated file name or Z_NULL */
  this.name       = '';
  /* space at name (only when reading header) */
  // this.name_max   = 0;
  /* pointer to zero-terminated comment or Z_NULL */
  this.comment    = '';
  /* space at comment (only when reading header) */
  // this.comm_max   = 0;
  /* true if there was or will be a header crc */
  this.hcrc       = 0;
  /* true when done reading gzip header (not used when writing a gzip file) */
  this.done       = false;
}

module.exports = GZheader;


/***/ }),

/***/ "../../node_modules/pako/lib/zlib/inffast.js":
/*!********************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/pako/lib/zlib/inffast.js ***!
  \********************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

// See state defs from inflate.js
var BAD = 30;       /* got a data error -- remain here until reset */
var TYPE = 12;      /* i: waiting for type bits, including last-flag bit */

/*
   Decode literal, length, and distance codes and write out the resulting
   literal and match bytes until either not enough input or output is
   available, an end-of-block is encountered, or a data error is encountered.
   When large enough input and output buffers are supplied to inflate(), for
   example, a 16K input buffer and a 64K output buffer, more than 95% of the
   inflate execution time is spent in this routine.

   Entry assumptions:

        state.mode === LEN
        strm.avail_in >= 6
        strm.avail_out >= 258
        start >= strm.avail_out
        state.bits < 8

   On return, state.mode is one of:

        LEN -- ran out of enough output space or enough available input
        TYPE -- reached end of block code, inflate() to interpret next block
        BAD -- error in block data

   Notes:

    - The maximum input bits used by a length/distance pair is 15 bits for the
      length code, 5 bits for the length extra, 15 bits for the distance code,
      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.
      Therefore if strm.avail_in >= 6, then there is enough input to avoid
      checking for available input while decoding.

    - The maximum bytes that a single length/distance pair can output is 258
      bytes, which is the maximum length that can be coded.  inflate_fast()
      requires strm.avail_out >= 258 for each loop to avoid checking for
      output space.
 */
module.exports = function inflate_fast(strm, start) {
  var state;
  var _in;                    /* local strm.input */
  var last;                   /* have enough input while in < last */
  var _out;                   /* local strm.output */
  var beg;                    /* inflate()'s initial strm.output */
  var end;                    /* while out < end, enough space available */
//#ifdef INFLATE_STRICT
  var dmax;                   /* maximum distance from zlib header */
//#endif
  var wsize;                  /* window size or zero if not using window */
  var whave;                  /* valid bytes in the window */
  var wnext;                  /* window write index */
  // Use `s_window` instead `window`, avoid conflict with instrumentation tools
  var s_window;               /* allocated sliding window, if wsize != 0 */
  var hold;                   /* local strm.hold */
  var bits;                   /* local strm.bits */
  var lcode;                  /* local strm.lencode */
  var dcode;                  /* local strm.distcode */
  var lmask;                  /* mask for first level of length codes */
  var dmask;                  /* mask for first level of distance codes */
  var here;                   /* retrieved table entry */
  var op;                     /* code bits, operation, extra bits, or */
                              /*  window position, window bytes to copy */
  var len;                    /* match length, unused bytes */
  var dist;                   /* match distance */
  var from;                   /* where to copy match from */
  var from_source;


  var input, output; // JS specific, because we have no pointers

  /* copy state to local variables */
  state = strm.state;
  //here = state.here;
  _in = strm.next_in;
  input = strm.input;
  last = _in + (strm.avail_in - 5);
  _out = strm.next_out;
  output = strm.output;
  beg = _out - (start - strm.avail_out);
  end = _out + (strm.avail_out - 257);
//#ifdef INFLATE_STRICT
  dmax = state.dmax;
//#endif
  wsize = state.wsize;
  whave = state.whave;
  wnext = state.wnext;
  s_window = state.window;
  hold = state.hold;
  bits = state.bits;
  lcode = state.lencode;
  dcode = state.distcode;
  lmask = (1 << state.lenbits) - 1;
  dmask = (1 << state.distbits) - 1;


  /* decode literals and length/distances until end-of-block or not enough
     input data or output space */

  top:
  do {
    if (bits < 15) {
      hold += input[_in++] << bits;
      bits += 8;
      hold += input[_in++] << bits;
      bits += 8;
    }

    here = lcode[hold & lmask];

    dolen:
    for (;;) { // Goto emulation
      op = here >>> 24/*here.bits*/;
      hold >>>= op;
      bits -= op;
      op = (here >>> 16) & 0xff/*here.op*/;
      if (op === 0) {                          /* literal */
        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
        //        "inflate:         literal '%c'\n" :
        //        "inflate:         literal 0x%02x\n", here.val));
        output[_out++] = here & 0xffff/*here.val*/;
      }
      else if (op & 16) {                     /* length base */
        len = here & 0xffff/*here.val*/;
        op &= 15;                           /* number of extra bits */
        if (op) {
          if (bits < op) {
            hold += input[_in++] << bits;
            bits += 8;
          }
          len += hold & ((1 << op) - 1);
          hold >>>= op;
          bits -= op;
        }
        //Tracevv((stderr, "inflate:         length %u\n", len));
        if (bits < 15) {
          hold += input[_in++] << bits;
          bits += 8;
          hold += input[_in++] << bits;
          bits += 8;
        }
        here = dcode[hold & dmask];

        dodist:
        for (;;) { // goto emulation
          op = here >>> 24/*here.bits*/;
          hold >>>= op;
          bits -= op;
          op = (here >>> 16) & 0xff/*here.op*/;

          if (op & 16) {                      /* distance base */
            dist = here & 0xffff/*here.val*/;
            op &= 15;                       /* number of extra bits */
            if (bits < op) {
              hold += input[_in++] << bits;
              bits += 8;
              if (bits < op) {
                hold += input[_in++] << bits;
                bits += 8;
              }
            }
            dist += hold & ((1 << op) - 1);
//#ifdef INFLATE_STRICT
            if (dist > dmax) {
              strm.msg = 'invalid distance too far back';
              state.mode = BAD;
              break top;
            }
//#endif
            hold >>>= op;
            bits -= op;
            //Tracevv((stderr, "inflate:         distance %u\n", dist));
            op = _out - beg;                /* max distance in output */
            if (dist > op) {                /* see if copy from window */
              op = dist - op;               /* distance back in window */
              if (op > whave) {
                if (state.sane) {
                  strm.msg = 'invalid distance too far back';
                  state.mode = BAD;
                  break top;
                }

// (!) This block is disabled in zlib defaults,
// don't enable it for binary compatibility
//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
//                if (len <= op - whave) {
//                  do {
//                    output[_out++] = 0;
//                  } while (--len);
//                  continue top;
//                }
//                len -= op - whave;
//                do {
//                  output[_out++] = 0;
//                } while (--op > whave);
//                if (op === 0) {
//                  from = _out - dist;
//                  do {
//                    output[_out++] = output[from++];
//                  } while (--len);
//                  continue top;
//                }
//#endif
              }
              from = 0; // window index
              from_source = s_window;
              if (wnext === 0) {           /* very common case */
                from += wsize - op;
                if (op < len) {         /* some from window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = _out - dist;  /* rest from output */
                  from_source = output;
                }
              }
              else if (wnext < op) {      /* wrap around window */
                from += wsize + wnext - op;
                op -= wnext;
                if (op < len) {         /* some from end of window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = 0;
                  if (wnext < len) {  /* some from start of window */
                    op = wnext;
                    len -= op;
                    do {
                      output[_out++] = s_window[from++];
                    } while (--op);
                    from = _out - dist;      /* rest from output */
                    from_source = output;
                  }
                }
              }
              else {                      /* contiguous in window */
                from += wnext - op;
                if (op < len) {         /* some from window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = _out - dist;  /* rest from output */
                  from_source = output;
                }
              }
              while (len > 2) {
                output[_out++] = from_source[from++];
                output[_out++] = from_source[from++];
                output[_out++] = from_source[from++];
                len -= 3;
              }
              if (len) {
                output[_out++] = from_source[from++];
                if (len > 1) {
                  output[_out++] = from_source[from++];
                }
              }
            }
            else {
              from = _out - dist;          /* copy direct from output */
              do {                        /* minimum length is three */
                output[_out++] = output[from++];
                output[_out++] = output[from++];
                output[_out++] = output[from++];
                len -= 3;
              } while (len > 2);
              if (len) {
                output[_out++] = output[from++];
                if (len > 1) {
                  output[_out++] = output[from++];
                }
              }
            }
          }
          else if ((op & 64) === 0) {          /* 2nd level distance code */
            here = dcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];
            continue dodist;
          }
          else {
            strm.msg = 'invalid distance code';
            state.mode = BAD;
            break top;
          }

          break; // need to emulate goto via "continue"
        }
      }
      else if ((op & 64) === 0) {              /* 2nd level length code */
        here = lcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];
        continue dolen;
      }
      else if (op & 32) {                     /* end-of-block */
        //Tracevv((stderr, "inflate:         end of block\n"));
        state.mode = TYPE;
        break top;
      }
      else {
        strm.msg = 'invalid literal/length code';
        state.mode = BAD;
        break top;
      }

      break; // need to emulate goto via "continue"
    }
  } while (_in < last && _out < end);

  /* return unused bytes (on entry, bits < 8, so in won't go too far back) */
  len = bits >> 3;
  _in -= len;
  bits -= len << 3;
  hold &= (1 << bits) - 1;

  /* update state and return */
  strm.next_in = _in;
  strm.next_out = _out;
  strm.avail_in = (_in < last ? 5 + (last - _in) : 5 - (_in - last));
  strm.avail_out = (_out < end ? 257 + (end - _out) : 257 - (_out - end));
  state.hold = hold;
  state.bits = bits;
  return;
};


/***/ }),

/***/ "../../node_modules/pako/lib/zlib/inflate.js":
/*!********************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/pako/lib/zlib/inflate.js ***!
  \********************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

var utils         = __webpack_require__(/*! ../utils/common */ "../../node_modules/pako/lib/utils/common.js");
var adler32       = __webpack_require__(/*! ./adler32 */ "../../node_modules/pako/lib/zlib/adler32.js");
var crc32         = __webpack_require__(/*! ./crc32 */ "../../node_modules/pako/lib/zlib/crc32.js");
var inflate_fast  = __webpack_require__(/*! ./inffast */ "../../node_modules/pako/lib/zlib/inffast.js");
var inflate_table = __webpack_require__(/*! ./inftrees */ "../../node_modules/pako/lib/zlib/inftrees.js");

var CODES = 0;
var LENS = 1;
var DISTS = 2;

/* Public constants ==========================================================*/
/* ===========================================================================*/


/* Allowed flush values; see deflate() and inflate() below for details */
//var Z_NO_FLUSH      = 0;
//var Z_PARTIAL_FLUSH = 1;
//var Z_SYNC_FLUSH    = 2;
//var Z_FULL_FLUSH    = 3;
var Z_FINISH        = 4;
var Z_BLOCK         = 5;
var Z_TREES         = 6;


/* Return codes for the compression/decompression functions. Negative values
 * are errors, positive values are used for special but normal events.
 */
var Z_OK            = 0;
var Z_STREAM_END    = 1;
var Z_NEED_DICT     = 2;
//var Z_ERRNO         = -1;
var Z_STREAM_ERROR  = -2;
var Z_DATA_ERROR    = -3;
var Z_MEM_ERROR     = -4;
var Z_BUF_ERROR     = -5;
//var Z_VERSION_ERROR = -6;

/* The deflate compression method */
var Z_DEFLATED  = 8;


/* STATES ====================================================================*/
/* ===========================================================================*/


var    HEAD = 1;       /* i: waiting for magic header */
var    FLAGS = 2;      /* i: waiting for method and flags (gzip) */
var    TIME = 3;       /* i: waiting for modification time (gzip) */
var    OS = 4;         /* i: waiting for extra flags and operating system (gzip) */
var    EXLEN = 5;      /* i: waiting for extra length (gzip) */
var    EXTRA = 6;      /* i: waiting for extra bytes (gzip) */
var    NAME = 7;       /* i: waiting for end of file name (gzip) */
var    COMMENT = 8;    /* i: waiting for end of comment (gzip) */
var    HCRC = 9;       /* i: waiting for header crc (gzip) */
var    DICTID = 10;    /* i: waiting for dictionary check value */
var    DICT = 11;      /* waiting for inflateSetDictionary() call */
var        TYPE = 12;      /* i: waiting for type bits, including last-flag bit */
var        TYPEDO = 13;    /* i: same, but skip check to exit inflate on new block */
var        STORED = 14;    /* i: waiting for stored size (length and complement) */
var        COPY_ = 15;     /* i/o: same as COPY below, but only first time in */
var        COPY = 16;      /* i/o: waiting for input or output to copy stored block */
var        TABLE = 17;     /* i: waiting for dynamic block table lengths */
var        LENLENS = 18;   /* i: waiting for code length code lengths */
var        CODELENS = 19;  /* i: waiting for length/lit and distance code lengths */
var            LEN_ = 20;      /* i: same as LEN below, but only first time in */
var            LEN = 21;       /* i: waiting for length/lit/eob code */
var            LENEXT = 22;    /* i: waiting for length extra bits */
var            DIST = 23;      /* i: waiting for distance code */
var            DISTEXT = 24;   /* i: waiting for distance extra bits */
var            MATCH = 25;     /* o: waiting for output space to copy string */
var            LIT = 26;       /* o: waiting for output space to write literal */
var    CHECK = 27;     /* i: waiting for 32-bit check value */
var    LENGTH = 28;    /* i: waiting for 32-bit length (gzip) */
var    DONE = 29;      /* finished check, done -- remain here until reset */
var    BAD = 30;       /* got a data error -- remain here until reset */
var    MEM = 31;       /* got an inflate() memory error -- remain here until reset */
var    SYNC = 32;      /* looking for synchronization bytes to restart inflate() */

/* ===========================================================================*/



var ENOUGH_LENS = 852;
var ENOUGH_DISTS = 592;
//var ENOUGH =  (ENOUGH_LENS+ENOUGH_DISTS);

var MAX_WBITS = 15;
/* 32K LZ77 window */
var DEF_WBITS = MAX_WBITS;


function zswap32(q) {
  return  (((q >>> 24) & 0xff) +
          ((q >>> 8) & 0xff00) +
          ((q & 0xff00) << 8) +
          ((q & 0xff) << 24));
}


function InflateState() {
  this.mode = 0;             /* current inflate mode */
  this.last = false;          /* true if processing last block */
  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */
  this.havedict = false;      /* true if dictionary provided */
  this.flags = 0;             /* gzip header method and flags (0 if zlib) */
  this.dmax = 0;              /* zlib header max distance (INFLATE_STRICT) */
  this.check = 0;             /* protected copy of check value */
  this.total = 0;             /* protected copy of output count */
  // TODO: may be {}
  this.head = null;           /* where to save gzip header information */

  /* sliding window */
  this.wbits = 0;             /* log base 2 of requested window size */
  this.wsize = 0;             /* window size or zero if not using window */
  this.whave = 0;             /* valid bytes in the window */
  this.wnext = 0;             /* window write index */
  this.window = null;         /* allocated sliding window, if needed */

  /* bit accumulator */
  this.hold = 0;              /* input bit accumulator */
  this.bits = 0;              /* number of bits in "in" */

  /* for string and stored block copying */
  this.length = 0;            /* literal or length of data to copy */
  this.offset = 0;            /* distance back to copy string from */

  /* for table and code decoding */
  this.extra = 0;             /* extra bits needed */

  /* fixed and dynamic code tables */
  this.lencode = null;          /* starting table for length/literal codes */
  this.distcode = null;         /* starting table for distance codes */
  this.lenbits = 0;           /* index bits for lencode */
  this.distbits = 0;          /* index bits for distcode */

  /* dynamic table building */
  this.ncode = 0;             /* number of code length code lengths */
  this.nlen = 0;              /* number of length code lengths */
  this.ndist = 0;             /* number of distance code lengths */
  this.have = 0;              /* number of code lengths in lens[] */
  this.next = null;              /* next available space in codes[] */

  this.lens = new utils.Buf16(320); /* temporary storage for code lengths */
  this.work = new utils.Buf16(288); /* work area for code table building */

  /*
   because we don't have pointers in js, we use lencode and distcode directly
   as buffers so we don't need codes
  */
  //this.codes = new utils.Buf32(ENOUGH);       /* space for code tables */
  this.lendyn = null;              /* dynamic table for length/literal codes (JS specific) */
  this.distdyn = null;             /* dynamic table for distance codes (JS specific) */
  this.sane = 0;                   /* if false, allow invalid distance too far */
  this.back = 0;                   /* bits back of last unprocessed length/lit */
  this.was = 0;                    /* initial length of match */
}

function inflateResetKeep(strm) {
  var state;

  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  state = strm.state;
  strm.total_in = strm.total_out = state.total = 0;
  strm.msg = ''; /*Z_NULL*/
  if (state.wrap) {       /* to support ill-conceived Java test suite */
    strm.adler = state.wrap & 1;
  }
  state.mode = HEAD;
  state.last = 0;
  state.havedict = 0;
  state.dmax = 32768;
  state.head = null/*Z_NULL*/;
  state.hold = 0;
  state.bits = 0;
  //state.lencode = state.distcode = state.next = state.codes;
  state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);
  state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);

  state.sane = 1;
  state.back = -1;
  //Tracev((stderr, "inflate: reset\n"));
  return Z_OK;
}

function inflateReset(strm) {
  var state;

  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  state = strm.state;
  state.wsize = 0;
  state.whave = 0;
  state.wnext = 0;
  return inflateResetKeep(strm);

}

function inflateReset2(strm, windowBits) {
  var wrap;
  var state;

  /* get the state */
  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  state = strm.state;

  /* extract wrap request from windowBits parameter */
  if (windowBits < 0) {
    wrap = 0;
    windowBits = -windowBits;
  }
  else {
    wrap = (windowBits >> 4) + 1;
    if (windowBits < 48) {
      windowBits &= 15;
    }
  }

  /* set number of window bits, free window if different */
  if (windowBits && (windowBits < 8 || windowBits > 15)) {
    return Z_STREAM_ERROR;
  }
  if (state.window !== null && state.wbits !== windowBits) {
    state.window = null;
  }

  /* update state and reset the rest of it */
  state.wrap = wrap;
  state.wbits = windowBits;
  return inflateReset(strm);
}

function inflateInit2(strm, windowBits) {
  var ret;
  var state;

  if (!strm) { return Z_STREAM_ERROR; }
  //strm.msg = Z_NULL;                 /* in case we return an error */

  state = new InflateState();

  //if (state === Z_NULL) return Z_MEM_ERROR;
  //Tracev((stderr, "inflate: allocated\n"));
  strm.state = state;
  state.window = null/*Z_NULL*/;
  ret = inflateReset2(strm, windowBits);
  if (ret !== Z_OK) {
    strm.state = null/*Z_NULL*/;
  }
  return ret;
}

function inflateInit(strm) {
  return inflateInit2(strm, DEF_WBITS);
}


/*
 Return state with length and distance decoding tables and index sizes set to
 fixed code decoding.  Normally this returns fixed tables from inffixed.h.
 If BUILDFIXED is defined, then instead this routine builds the tables the
 first time it's called, and returns those tables the first time and
 thereafter.  This reduces the size of the code by about 2K bytes, in
 exchange for a little execution time.  However, BUILDFIXED should not be
 used for threaded applications, since the rewriting of the tables and virgin
 may not be thread-safe.
 */
var virgin = true;

var lenfix, distfix; // We have no pointers in JS, so keep tables separate

function fixedtables(state) {
  /* build fixed huffman tables if first call (may not be thread safe) */
  if (virgin) {
    var sym;

    lenfix = new utils.Buf32(512);
    distfix = new utils.Buf32(32);

    /* literal/length table */
    sym = 0;
    while (sym < 144) { state.lens[sym++] = 8; }
    while (sym < 256) { state.lens[sym++] = 9; }
    while (sym < 280) { state.lens[sym++] = 7; }
    while (sym < 288) { state.lens[sym++] = 8; }

    inflate_table(LENS,  state.lens, 0, 288, lenfix,   0, state.work, { bits: 9 });

    /* distance table */
    sym = 0;
    while (sym < 32) { state.lens[sym++] = 5; }

    inflate_table(DISTS, state.lens, 0, 32,   distfix, 0, state.work, { bits: 5 });

    /* do this just once */
    virgin = false;
  }

  state.lencode = lenfix;
  state.lenbits = 9;
  state.distcode = distfix;
  state.distbits = 5;
}


/*
 Update the window with the last wsize (normally 32K) bytes written before
 returning.  If window does not exist yet, create it.  This is only called
 when a window is already in use, or when output has been written during this
 inflate call, but the end of the deflate stream has not been reached yet.
 It is also called to create a window for dictionary data when a dictionary
 is loaded.

 Providing output buffers larger than 32K to inflate() should provide a speed
 advantage, since only the last 32K of output is copied to the sliding window
 upon return from inflate(), and since all distances after the first 32K of
 output will fall in the output data, making match copies simpler and faster.
 The advantage may be dependent on the size of the processor's data caches.
 */
function updatewindow(strm, src, end, copy) {
  var dist;
  var state = strm.state;

  /* if it hasn't been done already, allocate space for the window */
  if (state.window === null) {
    state.wsize = 1 << state.wbits;
    state.wnext = 0;
    state.whave = 0;

    state.window = new utils.Buf8(state.wsize);
  }

  /* copy state->wsize or less output bytes into the circular window */
  if (copy >= state.wsize) {
    utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);
    state.wnext = 0;
    state.whave = state.wsize;
  }
  else {
    dist = state.wsize - state.wnext;
    if (dist > copy) {
      dist = copy;
    }
    //zmemcpy(state->window + state->wnext, end - copy, dist);
    utils.arraySet(state.window, src, end - copy, dist, state.wnext);
    copy -= dist;
    if (copy) {
      //zmemcpy(state->window, end - copy, copy);
      utils.arraySet(state.window, src, end - copy, copy, 0);
      state.wnext = copy;
      state.whave = state.wsize;
    }
    else {
      state.wnext += dist;
      if (state.wnext === state.wsize) { state.wnext = 0; }
      if (state.whave < state.wsize) { state.whave += dist; }
    }
  }
  return 0;
}

function inflate(strm, flush) {
  var state;
  var input, output;          // input/output buffers
  var next;                   /* next input INDEX */
  var put;                    /* next output INDEX */
  var have, left;             /* available input and output */
  var hold;                   /* bit buffer */
  var bits;                   /* bits in bit buffer */
  var _in, _out;              /* save starting available input and output */
  var copy;                   /* number of stored or match bytes to copy */
  var from;                   /* where to copy match bytes from */
  var from_source;
  var here = 0;               /* current decoding table entry */
  var here_bits, here_op, here_val; // paked "here" denormalized (JS specific)
  //var last;                   /* parent table entry */
  var last_bits, last_op, last_val; // paked "last" denormalized (JS specific)
  var len;                    /* length to copy for repeats, bits to drop */
  var ret;                    /* return code */
  var hbuf = new utils.Buf8(4);    /* buffer for gzip header crc calculation */
  var opts;

  var n; // temporary var for NEED_BITS

  var order = /* permutation of code lengths */
    [ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ];


  if (!strm || !strm.state || !strm.output ||
      (!strm.input && strm.avail_in !== 0)) {
    return Z_STREAM_ERROR;
  }

  state = strm.state;
  if (state.mode === TYPE) { state.mode = TYPEDO; }    /* skip check */


  //--- LOAD() ---
  put = strm.next_out;
  output = strm.output;
  left = strm.avail_out;
  next = strm.next_in;
  input = strm.input;
  have = strm.avail_in;
  hold = state.hold;
  bits = state.bits;
  //---

  _in = have;
  _out = left;
  ret = Z_OK;

  inf_leave: // goto emulation
  for (;;) {
    switch (state.mode) {
      case HEAD:
        if (state.wrap === 0) {
          state.mode = TYPEDO;
          break;
        }
        //=== NEEDBITS(16);
        while (bits < 16) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if ((state.wrap & 2) && hold === 0x8b1f) {  /* gzip header */
          state.check = 0/*crc32(0L, Z_NULL, 0)*/;
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          state.check = crc32(state.check, hbuf, 2, 0);
          //===//

          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
          state.mode = FLAGS;
          break;
        }
        state.flags = 0;           /* expect zlib header */
        if (state.head) {
          state.head.done = false;
        }
        if (!(state.wrap & 1) ||   /* check if zlib header allowed */
          (((hold & 0xff)/*BITS(8)*/ << 8) + (hold >> 8)) % 31) {
          strm.msg = 'incorrect header check';
          state.mode = BAD;
          break;
        }
        if ((hold & 0x0f)/*BITS(4)*/ !== Z_DEFLATED) {
          strm.msg = 'unknown compression method';
          state.mode = BAD;
          break;
        }
        //--- DROPBITS(4) ---//
        hold >>>= 4;
        bits -= 4;
        //---//
        len = (hold & 0x0f)/*BITS(4)*/ + 8;
        if (state.wbits === 0) {
          state.wbits = len;
        }
        else if (len > state.wbits) {
          strm.msg = 'invalid window size';
          state.mode = BAD;
          break;
        }
        state.dmax = 1 << len;
        //Tracev((stderr, "inflate:   zlib header ok\n"));
        strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;
        state.mode = hold & 0x200 ? DICTID : TYPE;
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        break;
      case FLAGS:
        //=== NEEDBITS(16); */
        while (bits < 16) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.flags = hold;
        if ((state.flags & 0xff) !== Z_DEFLATED) {
          strm.msg = 'unknown compression method';
          state.mode = BAD;
          break;
        }
        if (state.flags & 0xe000) {
          strm.msg = 'unknown header flags set';
          state.mode = BAD;
          break;
        }
        if (state.head) {
          state.head.text = ((hold >> 8) & 1);
        }
        if (state.flags & 0x0200) {
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          state.check = crc32(state.check, hbuf, 2, 0);
          //===//
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = TIME;
        /* falls through */
      case TIME:
        //=== NEEDBITS(32); */
        while (bits < 32) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if (state.head) {
          state.head.time = hold;
        }
        if (state.flags & 0x0200) {
          //=== CRC4(state.check, hold)
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          hbuf[2] = (hold >>> 16) & 0xff;
          hbuf[3] = (hold >>> 24) & 0xff;
          state.check = crc32(state.check, hbuf, 4, 0);
          //===
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = OS;
        /* falls through */
      case OS:
        //=== NEEDBITS(16); */
        while (bits < 16) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if (state.head) {
          state.head.xflags = (hold & 0xff);
          state.head.os = (hold >> 8);
        }
        if (state.flags & 0x0200) {
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          state.check = crc32(state.check, hbuf, 2, 0);
          //===//
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = EXLEN;
        /* falls through */
      case EXLEN:
        if (state.flags & 0x0400) {
          //=== NEEDBITS(16); */
          while (bits < 16) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.length = hold;
          if (state.head) {
            state.head.extra_len = hold;
          }
          if (state.flags & 0x0200) {
            //=== CRC2(state.check, hold);
            hbuf[0] = hold & 0xff;
            hbuf[1] = (hold >>> 8) & 0xff;
            state.check = crc32(state.check, hbuf, 2, 0);
            //===//
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
        }
        else if (state.head) {
          state.head.extra = null/*Z_NULL*/;
        }
        state.mode = EXTRA;
        /* falls through */
      case EXTRA:
        if (state.flags & 0x0400) {
          copy = state.length;
          if (copy > have) { copy = have; }
          if (copy) {
            if (state.head) {
              len = state.head.extra_len - state.length;
              if (!state.head.extra) {
                // Use untyped array for more convenient processing later
                state.head.extra = new Array(state.head.extra_len);
              }
              utils.arraySet(
                state.head.extra,
                input,
                next,
                // extra field is limited to 65536 bytes
                // - no need for additional size check
                copy,
                /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                len
              );
              //zmemcpy(state.head.extra + len, next,
              //        len + copy > state.head.extra_max ?
              //        state.head.extra_max - len : copy);
            }
            if (state.flags & 0x0200) {
              state.check = crc32(state.check, input, copy, next);
            }
            have -= copy;
            next += copy;
            state.length -= copy;
          }
          if (state.length) { break inf_leave; }
        }
        state.length = 0;
        state.mode = NAME;
        /* falls through */
      case NAME:
        if (state.flags & 0x0800) {
          if (have === 0) { break inf_leave; }
          copy = 0;
          do {
            // TODO: 2 or 1 bytes?
            len = input[next + copy++];
            /* use constant limit because in js we should not preallocate memory */
            if (state.head && len &&
                (state.length < 65536 /*state.head.name_max*/)) {
              state.head.name += String.fromCharCode(len);
            }
          } while (len && copy < have);

          if (state.flags & 0x0200) {
            state.check = crc32(state.check, input, copy, next);
          }
          have -= copy;
          next += copy;
          if (len) { break inf_leave; }
        }
        else if (state.head) {
          state.head.name = null;
        }
        state.length = 0;
        state.mode = COMMENT;
        /* falls through */
      case COMMENT:
        if (state.flags & 0x1000) {
          if (have === 0) { break inf_leave; }
          copy = 0;
          do {
            len = input[next + copy++];
            /* use constant limit because in js we should not preallocate memory */
            if (state.head && len &&
                (state.length < 65536 /*state.head.comm_max*/)) {
              state.head.comment += String.fromCharCode(len);
            }
          } while (len && copy < have);
          if (state.flags & 0x0200) {
            state.check = crc32(state.check, input, copy, next);
          }
          have -= copy;
          next += copy;
          if (len) { break inf_leave; }
        }
        else if (state.head) {
          state.head.comment = null;
        }
        state.mode = HCRC;
        /* falls through */
      case HCRC:
        if (state.flags & 0x0200) {
          //=== NEEDBITS(16); */
          while (bits < 16) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          if (hold !== (state.check & 0xffff)) {
            strm.msg = 'header crc mismatch';
            state.mode = BAD;
            break;
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
        }
        if (state.head) {
          state.head.hcrc = ((state.flags >> 9) & 1);
          state.head.done = true;
        }
        strm.adler = state.check = 0;
        state.mode = TYPE;
        break;
      case DICTID:
        //=== NEEDBITS(32); */
        while (bits < 32) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        strm.adler = state.check = zswap32(hold);
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = DICT;
        /* falls through */
      case DICT:
        if (state.havedict === 0) {
          //--- RESTORE() ---
          strm.next_out = put;
          strm.avail_out = left;
          strm.next_in = next;
          strm.avail_in = have;
          state.hold = hold;
          state.bits = bits;
          //---
          return Z_NEED_DICT;
        }
        strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;
        state.mode = TYPE;
        /* falls through */
      case TYPE:
        if (flush === Z_BLOCK || flush === Z_TREES) { break inf_leave; }
        /* falls through */
      case TYPEDO:
        if (state.last) {
          //--- BYTEBITS() ---//
          hold >>>= bits & 7;
          bits -= bits & 7;
          //---//
          state.mode = CHECK;
          break;
        }
        //=== NEEDBITS(3); */
        while (bits < 3) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.last = (hold & 0x01)/*BITS(1)*/;
        //--- DROPBITS(1) ---//
        hold >>>= 1;
        bits -= 1;
        //---//

        switch ((hold & 0x03)/*BITS(2)*/) {
          case 0:                             /* stored block */
            //Tracev((stderr, "inflate:     stored block%s\n",
            //        state.last ? " (last)" : ""));
            state.mode = STORED;
            break;
          case 1:                             /* fixed block */
            fixedtables(state);
            //Tracev((stderr, "inflate:     fixed codes block%s\n",
            //        state.last ? " (last)" : ""));
            state.mode = LEN_;             /* decode codes */
            if (flush === Z_TREES) {
              //--- DROPBITS(2) ---//
              hold >>>= 2;
              bits -= 2;
              //---//
              break inf_leave;
            }
            break;
          case 2:                             /* dynamic block */
            //Tracev((stderr, "inflate:     dynamic codes block%s\n",
            //        state.last ? " (last)" : ""));
            state.mode = TABLE;
            break;
          case 3:
            strm.msg = 'invalid block type';
            state.mode = BAD;
        }
        //--- DROPBITS(2) ---//
        hold >>>= 2;
        bits -= 2;
        //---//
        break;
      case STORED:
        //--- BYTEBITS() ---// /* go to byte boundary */
        hold >>>= bits & 7;
        bits -= bits & 7;
        //---//
        //=== NEEDBITS(32); */
        while (bits < 32) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if ((hold & 0xffff) !== ((hold >>> 16) ^ 0xffff)) {
          strm.msg = 'invalid stored block lengths';
          state.mode = BAD;
          break;
        }
        state.length = hold & 0xffff;
        //Tracev((stderr, "inflate:       stored length %u\n",
        //        state.length));
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = COPY_;
        if (flush === Z_TREES) { break inf_leave; }
        /* falls through */
      case COPY_:
        state.mode = COPY;
        /* falls through */
      case COPY:
        copy = state.length;
        if (copy) {
          if (copy > have) { copy = have; }
          if (copy > left) { copy = left; }
          if (copy === 0) { break inf_leave; }
          //--- zmemcpy(put, next, copy); ---
          utils.arraySet(output, input, next, copy, put);
          //---//
          have -= copy;
          next += copy;
          left -= copy;
          put += copy;
          state.length -= copy;
          break;
        }
        //Tracev((stderr, "inflate:       stored end\n"));
        state.mode = TYPE;
        break;
      case TABLE:
        //=== NEEDBITS(14); */
        while (bits < 14) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.nlen = (hold & 0x1f)/*BITS(5)*/ + 257;
        //--- DROPBITS(5) ---//
        hold >>>= 5;
        bits -= 5;
        //---//
        state.ndist = (hold & 0x1f)/*BITS(5)*/ + 1;
        //--- DROPBITS(5) ---//
        hold >>>= 5;
        bits -= 5;
        //---//
        state.ncode = (hold & 0x0f)/*BITS(4)*/ + 4;
        //--- DROPBITS(4) ---//
        hold >>>= 4;
        bits -= 4;
        //---//
//#ifndef PKZIP_BUG_WORKAROUND
        if (state.nlen > 286 || state.ndist > 30) {
          strm.msg = 'too many length or distance symbols';
          state.mode = BAD;
          break;
        }
//#endif
        //Tracev((stderr, "inflate:       table sizes ok\n"));
        state.have = 0;
        state.mode = LENLENS;
        /* falls through */
      case LENLENS:
        while (state.have < state.ncode) {
          //=== NEEDBITS(3);
          while (bits < 3) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.lens[order[state.have++]] = (hold & 0x07);//BITS(3);
          //--- DROPBITS(3) ---//
          hold >>>= 3;
          bits -= 3;
          //---//
        }
        while (state.have < 19) {
          state.lens[order[state.have++]] = 0;
        }
        // We have separate tables & no pointers. 2 commented lines below not needed.
        //state.next = state.codes;
        //state.lencode = state.next;
        // Switch to use dynamic table
        state.lencode = state.lendyn;
        state.lenbits = 7;

        opts = { bits: state.lenbits };
        ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
        state.lenbits = opts.bits;

        if (ret) {
          strm.msg = 'invalid code lengths set';
          state.mode = BAD;
          break;
        }
        //Tracev((stderr, "inflate:       code lengths ok\n"));
        state.have = 0;
        state.mode = CODELENS;
        /* falls through */
      case CODELENS:
        while (state.have < state.nlen + state.ndist) {
          for (;;) {
            here = state.lencode[hold & ((1 << state.lenbits) - 1)];/*BITS(state.lenbits)*/
            here_bits = here >>> 24;
            here_op = (here >>> 16) & 0xff;
            here_val = here & 0xffff;

            if ((here_bits) <= bits) { break; }
            //--- PULLBYTE() ---//
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
            //---//
          }
          if (here_val < 16) {
            //--- DROPBITS(here.bits) ---//
            hold >>>= here_bits;
            bits -= here_bits;
            //---//
            state.lens[state.have++] = here_val;
          }
          else {
            if (here_val === 16) {
              //=== NEEDBITS(here.bits + 2);
              n = here_bits + 2;
              while (bits < n) {
                if (have === 0) { break inf_leave; }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              //===//
              //--- DROPBITS(here.bits) ---//
              hold >>>= here_bits;
              bits -= here_bits;
              //---//
              if (state.have === 0) {
                strm.msg = 'invalid bit length repeat';
                state.mode = BAD;
                break;
              }
              len = state.lens[state.have - 1];
              copy = 3 + (hold & 0x03);//BITS(2);
              //--- DROPBITS(2) ---//
              hold >>>= 2;
              bits -= 2;
              //---//
            }
            else if (here_val === 17) {
              //=== NEEDBITS(here.bits + 3);
              n = here_bits + 3;
              while (bits < n) {
                if (have === 0) { break inf_leave; }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              //===//
              //--- DROPBITS(here.bits) ---//
              hold >>>= here_bits;
              bits -= here_bits;
              //---//
              len = 0;
              copy = 3 + (hold & 0x07);//BITS(3);
              //--- DROPBITS(3) ---//
              hold >>>= 3;
              bits -= 3;
              //---//
            }
            else {
              //=== NEEDBITS(here.bits + 7);
              n = here_bits + 7;
              while (bits < n) {
                if (have === 0) { break inf_leave; }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              //===//
              //--- DROPBITS(here.bits) ---//
              hold >>>= here_bits;
              bits -= here_bits;
              //---//
              len = 0;
              copy = 11 + (hold & 0x7f);//BITS(7);
              //--- DROPBITS(7) ---//
              hold >>>= 7;
              bits -= 7;
              //---//
            }
            if (state.have + copy > state.nlen + state.ndist) {
              strm.msg = 'invalid bit length repeat';
              state.mode = BAD;
              break;
            }
            while (copy--) {
              state.lens[state.have++] = len;
            }
          }
        }

        /* handle error breaks in while */
        if (state.mode === BAD) { break; }

        /* check for end-of-block code (better have one) */
        if (state.lens[256] === 0) {
          strm.msg = 'invalid code -- missing end-of-block';
          state.mode = BAD;
          break;
        }

        /* build code tables -- note: do not change the lenbits or distbits
           values here (9 and 6) without reading the comments in inftrees.h
           concerning the ENOUGH constants, which depend on those values */
        state.lenbits = 9;

        opts = { bits: state.lenbits };
        ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
        // We have separate tables & no pointers. 2 commented lines below not needed.
        // state.next_index = opts.table_index;
        state.lenbits = opts.bits;
        // state.lencode = state.next;

        if (ret) {
          strm.msg = 'invalid literal/lengths set';
          state.mode = BAD;
          break;
        }

        state.distbits = 6;
        //state.distcode.copy(state.codes);
        // Switch to use dynamic table
        state.distcode = state.distdyn;
        opts = { bits: state.distbits };
        ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
        // We have separate tables & no pointers. 2 commented lines below not needed.
        // state.next_index = opts.table_index;
        state.distbits = opts.bits;
        // state.distcode = state.next;

        if (ret) {
          strm.msg = 'invalid distances set';
          state.mode = BAD;
          break;
        }
        //Tracev((stderr, 'inflate:       codes ok\n'));
        state.mode = LEN_;
        if (flush === Z_TREES) { break inf_leave; }
        /* falls through */
      case LEN_:
        state.mode = LEN;
        /* falls through */
      case LEN:
        if (have >= 6 && left >= 258) {
          //--- RESTORE() ---
          strm.next_out = put;
          strm.avail_out = left;
          strm.next_in = next;
          strm.avail_in = have;
          state.hold = hold;
          state.bits = bits;
          //---
          inflate_fast(strm, _out);
          //--- LOAD() ---
          put = strm.next_out;
          output = strm.output;
          left = strm.avail_out;
          next = strm.next_in;
          input = strm.input;
          have = strm.avail_in;
          hold = state.hold;
          bits = state.bits;
          //---

          if (state.mode === TYPE) {
            state.back = -1;
          }
          break;
        }
        state.back = 0;
        for (;;) {
          here = state.lencode[hold & ((1 << state.lenbits) - 1)];  /*BITS(state.lenbits)*/
          here_bits = here >>> 24;
          here_op = (here >>> 16) & 0xff;
          here_val = here & 0xffff;

          if (here_bits <= bits) { break; }
          //--- PULLBYTE() ---//
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
          //---//
        }
        if (here_op && (here_op & 0xf0) === 0) {
          last_bits = here_bits;
          last_op = here_op;
          last_val = here_val;
          for (;;) {
            here = state.lencode[last_val +
                    ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];
            here_bits = here >>> 24;
            here_op = (here >>> 16) & 0xff;
            here_val = here & 0xffff;

            if ((last_bits + here_bits) <= bits) { break; }
            //--- PULLBYTE() ---//
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
            //---//
          }
          //--- DROPBITS(last.bits) ---//
          hold >>>= last_bits;
          bits -= last_bits;
          //---//
          state.back += last_bits;
        }
        //--- DROPBITS(here.bits) ---//
        hold >>>= here_bits;
        bits -= here_bits;
        //---//
        state.back += here_bits;
        state.length = here_val;
        if (here_op === 0) {
          //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
          //        "inflate:         literal '%c'\n" :
          //        "inflate:         literal 0x%02x\n", here.val));
          state.mode = LIT;
          break;
        }
        if (here_op & 32) {
          //Tracevv((stderr, "inflate:         end of block\n"));
          state.back = -1;
          state.mode = TYPE;
          break;
        }
        if (here_op & 64) {
          strm.msg = 'invalid literal/length code';
          state.mode = BAD;
          break;
        }
        state.extra = here_op & 15;
        state.mode = LENEXT;
        /* falls through */
      case LENEXT:
        if (state.extra) {
          //=== NEEDBITS(state.extra);
          n = state.extra;
          while (bits < n) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.length += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;
          //--- DROPBITS(state.extra) ---//
          hold >>>= state.extra;
          bits -= state.extra;
          //---//
          state.back += state.extra;
        }
        //Tracevv((stderr, "inflate:         length %u\n", state.length));
        state.was = state.length;
        state.mode = DIST;
        /* falls through */
      case DIST:
        for (;;) {
          here = state.distcode[hold & ((1 << state.distbits) - 1)];/*BITS(state.distbits)*/
          here_bits = here >>> 24;
          here_op = (here >>> 16) & 0xff;
          here_val = here & 0xffff;

          if ((here_bits) <= bits) { break; }
          //--- PULLBYTE() ---//
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
          //---//
        }
        if ((here_op & 0xf0) === 0) {
          last_bits = here_bits;
          last_op = here_op;
          last_val = here_val;
          for (;;) {
            here = state.distcode[last_val +
                    ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];
            here_bits = here >>> 24;
            here_op = (here >>> 16) & 0xff;
            here_val = here & 0xffff;

            if ((last_bits + here_bits) <= bits) { break; }
            //--- PULLBYTE() ---//
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
            //---//
          }
          //--- DROPBITS(last.bits) ---//
          hold >>>= last_bits;
          bits -= last_bits;
          //---//
          state.back += last_bits;
        }
        //--- DROPBITS(here.bits) ---//
        hold >>>= here_bits;
        bits -= here_bits;
        //---//
        state.back += here_bits;
        if (here_op & 64) {
          strm.msg = 'invalid distance code';
          state.mode = BAD;
          break;
        }
        state.offset = here_val;
        state.extra = (here_op) & 15;
        state.mode = DISTEXT;
        /* falls through */
      case DISTEXT:
        if (state.extra) {
          //=== NEEDBITS(state.extra);
          n = state.extra;
          while (bits < n) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.offset += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;
          //--- DROPBITS(state.extra) ---//
          hold >>>= state.extra;
          bits -= state.extra;
          //---//
          state.back += state.extra;
        }
//#ifdef INFLATE_STRICT
        if (state.offset > state.dmax) {
          strm.msg = 'invalid distance too far back';
          state.mode = BAD;
          break;
        }
//#endif
        //Tracevv((stderr, "inflate:         distance %u\n", state.offset));
        state.mode = MATCH;
        /* falls through */
      case MATCH:
        if (left === 0) { break inf_leave; }
        copy = _out - left;
        if (state.offset > copy) {         /* copy from window */
          copy = state.offset - copy;
          if (copy > state.whave) {
            if (state.sane) {
              strm.msg = 'invalid distance too far back';
              state.mode = BAD;
              break;
            }
// (!) This block is disabled in zlib defaults,
// don't enable it for binary compatibility
//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
//          Trace((stderr, "inflate.c too far\n"));
//          copy -= state.whave;
//          if (copy > state.length) { copy = state.length; }
//          if (copy > left) { copy = left; }
//          left -= copy;
//          state.length -= copy;
//          do {
//            output[put++] = 0;
//          } while (--copy);
//          if (state.length === 0) { state.mode = LEN; }
//          break;
//#endif
          }
          if (copy > state.wnext) {
            copy -= state.wnext;
            from = state.wsize - copy;
          }
          else {
            from = state.wnext - copy;
          }
          if (copy > state.length) { copy = state.length; }
          from_source = state.window;
        }
        else {                              /* copy from output */
          from_source = output;
          from = put - state.offset;
          copy = state.length;
        }
        if (copy > left) { copy = left; }
        left -= copy;
        state.length -= copy;
        do {
          output[put++] = from_source[from++];
        } while (--copy);
        if (state.length === 0) { state.mode = LEN; }
        break;
      case LIT:
        if (left === 0) { break inf_leave; }
        output[put++] = state.length;
        left--;
        state.mode = LEN;
        break;
      case CHECK:
        if (state.wrap) {
          //=== NEEDBITS(32);
          while (bits < 32) {
            if (have === 0) { break inf_leave; }
            have--;
            // Use '|' instead of '+' to make sure that result is signed
            hold |= input[next++] << bits;
            bits += 8;
          }
          //===//
          _out -= left;
          strm.total_out += _out;
          state.total += _out;
          if (_out) {
            strm.adler = state.check =
                /*UPDATE(state.check, put - _out, _out);*/
                (state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out));

          }
          _out = left;
          // NB: crc32 stored as signed 32-bit int, zswap32 returns signed too
          if ((state.flags ? hold : zswap32(hold)) !== state.check) {
            strm.msg = 'incorrect data check';
            state.mode = BAD;
            break;
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
          //Tracev((stderr, "inflate:   check matches trailer\n"));
        }
        state.mode = LENGTH;
        /* falls through */
      case LENGTH:
        if (state.wrap && state.flags) {
          //=== NEEDBITS(32);
          while (bits < 32) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          if (hold !== (state.total & 0xffffffff)) {
            strm.msg = 'incorrect length check';
            state.mode = BAD;
            break;
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
          //Tracev((stderr, "inflate:   length matches trailer\n"));
        }
        state.mode = DONE;
        /* falls through */
      case DONE:
        ret = Z_STREAM_END;
        break inf_leave;
      case BAD:
        ret = Z_DATA_ERROR;
        break inf_leave;
      case MEM:
        return Z_MEM_ERROR;
      case SYNC:
        /* falls through */
      default:
        return Z_STREAM_ERROR;
    }
  }

  // inf_leave <- here is real place for "goto inf_leave", emulated via "break inf_leave"

  /*
     Return from inflate(), updating the total counts and the check value.
     If there was no progress during the inflate() call, return a buffer
     error.  Call updatewindow() to create and/or update the window state.
     Note: a memory error from inflate() is non-recoverable.
   */

  //--- RESTORE() ---
  strm.next_out = put;
  strm.avail_out = left;
  strm.next_in = next;
  strm.avail_in = have;
  state.hold = hold;
  state.bits = bits;
  //---

  if (state.wsize || (_out !== strm.avail_out && state.mode < BAD &&
                      (state.mode < CHECK || flush !== Z_FINISH))) {
    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
      state.mode = MEM;
      return Z_MEM_ERROR;
    }
  }
  _in -= strm.avail_in;
  _out -= strm.avail_out;
  strm.total_in += _in;
  strm.total_out += _out;
  state.total += _out;
  if (state.wrap && _out) {
    strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
      (state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out));
  }
  strm.data_type = state.bits + (state.last ? 64 : 0) +
                    (state.mode === TYPE ? 128 : 0) +
                    (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
  if (((_in === 0 && _out === 0) || flush === Z_FINISH) && ret === Z_OK) {
    ret = Z_BUF_ERROR;
  }
  return ret;
}

function inflateEnd(strm) {

  if (!strm || !strm.state /*|| strm->zfree == (free_func)0*/) {
    return Z_STREAM_ERROR;
  }

  var state = strm.state;
  if (state.window) {
    state.window = null;
  }
  strm.state = null;
  return Z_OK;
}

function inflateGetHeader(strm, head) {
  var state;

  /* check state */
  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  state = strm.state;
  if ((state.wrap & 2) === 0) { return Z_STREAM_ERROR; }

  /* save header structure */
  state.head = head;
  head.done = false;
  return Z_OK;
}

function inflateSetDictionary(strm, dictionary) {
  var dictLength = dictionary.length;

  var state;
  var dictid;
  var ret;

  /* check state */
  if (!strm /* == Z_NULL */ || !strm.state /* == Z_NULL */) { return Z_STREAM_ERROR; }
  state = strm.state;

  if (state.wrap !== 0 && state.mode !== DICT) {
    return Z_STREAM_ERROR;
  }

  /* check for correct dictionary identifier */
  if (state.mode === DICT) {
    dictid = 1; /* adler32(0, null, 0)*/
    /* dictid = adler32(dictid, dictionary, dictLength); */
    dictid = adler32(dictid, dictionary, dictLength, 0);
    if (dictid !== state.check) {
      return Z_DATA_ERROR;
    }
  }
  /* copy dictionary to window using updatewindow(), which will amend the
   existing dictionary if appropriate */
  ret = updatewindow(strm, dictionary, dictLength, dictLength);
  if (ret) {
    state.mode = MEM;
    return Z_MEM_ERROR;
  }
  state.havedict = 1;
  // Tracev((stderr, "inflate:   dictionary set\n"));
  return Z_OK;
}

exports.inflateReset = inflateReset;
exports.inflateReset2 = inflateReset2;
exports.inflateResetKeep = inflateResetKeep;
exports.inflateInit = inflateInit;
exports.inflateInit2 = inflateInit2;
exports.inflate = inflate;
exports.inflateEnd = inflateEnd;
exports.inflateGetHeader = inflateGetHeader;
exports.inflateSetDictionary = inflateSetDictionary;
exports.inflateInfo = 'pako inflate (from Nodeca project)';

/* Not implemented
exports.inflateCopy = inflateCopy;
exports.inflateGetDictionary = inflateGetDictionary;
exports.inflateMark = inflateMark;
exports.inflatePrime = inflatePrime;
exports.inflateSync = inflateSync;
exports.inflateSyncPoint = inflateSyncPoint;
exports.inflateUndermine = inflateUndermine;
*/


/***/ }),

/***/ "../../node_modules/pako/lib/zlib/inftrees.js":
/*!*********************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/pako/lib/zlib/inftrees.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

var utils = __webpack_require__(/*! ../utils/common */ "../../node_modules/pako/lib/utils/common.js");

var MAXBITS = 15;
var ENOUGH_LENS = 852;
var ENOUGH_DISTS = 592;
//var ENOUGH = (ENOUGH_LENS+ENOUGH_DISTS);

var CODES = 0;
var LENS = 1;
var DISTS = 2;

var lbase = [ /* Length codes 257..285 base */
  3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
  35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0
];

var lext = [ /* Length codes 257..285 extra */
  16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,
  19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78
];

var dbase = [ /* Distance codes 0..29 base */
  1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
  257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
  8193, 12289, 16385, 24577, 0, 0
];

var dext = [ /* Distance codes 0..29 extra */
  16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,
  23, 23, 24, 24, 25, 25, 26, 26, 27, 27,
  28, 28, 29, 29, 64, 64
];

module.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts)
{
  var bits = opts.bits;
      //here = opts.here; /* table entry for duplication */

  var len = 0;               /* a code's length in bits */
  var sym = 0;               /* index of code symbols */
  var min = 0, max = 0;          /* minimum and maximum code lengths */
  var root = 0;              /* number of index bits for root table */
  var curr = 0;              /* number of index bits for current table */
  var drop = 0;              /* code bits to drop for sub-table */
  var left = 0;                   /* number of prefix codes available */
  var used = 0;              /* code entries in table used */
  var huff = 0;              /* Huffman code */
  var incr;              /* for incrementing code, index */
  var fill;              /* index for replicating entries */
  var low;               /* low bits for current root entry */
  var mask;              /* mask for low root bits */
  var next;             /* next available space in table */
  var base = null;     /* base value table to use */
  var base_index = 0;
//  var shoextra;    /* extra bits table to use */
  var end;                    /* use base and extra for symbol > end */
  var count = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];    /* number of codes of each length */
  var offs = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];     /* offsets in table for each length */
  var extra = null;
  var extra_index = 0;

  var here_bits, here_op, here_val;

  /*
   Process a set of code lengths to create a canonical Huffman code.  The
   code lengths are lens[0..codes-1].  Each length corresponds to the
   symbols 0..codes-1.  The Huffman code is generated by first sorting the
   symbols by length from short to long, and retaining the symbol order
   for codes with equal lengths.  Then the code starts with all zero bits
   for the first code of the shortest length, and the codes are integer
   increments for the same length, and zeros are appended as the length
   increases.  For the deflate format, these bits are stored backwards
   from their more natural integer increment ordering, and so when the
   decoding tables are built in the large loop below, the integer codes
   are incremented backwards.

   This routine assumes, but does not check, that all of the entries in
   lens[] are in the range 0..MAXBITS.  The caller must assure this.
   1..MAXBITS is interpreted as that code length.  zero means that that
   symbol does not occur in this code.

   The codes are sorted by computing a count of codes for each length,
   creating from that a table of starting indices for each length in the
   sorted table, and then entering the symbols in order in the sorted
   table.  The sorted table is work[], with that space being provided by
   the caller.

   The length counts are used for other purposes as well, i.e. finding
   the minimum and maximum length codes, determining if there are any
   codes at all, checking for a valid set of lengths, and looking ahead
   at length counts to determine sub-table sizes when building the
   decoding tables.
   */

  /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
  for (len = 0; len <= MAXBITS; len++) {
    count[len] = 0;
  }
  for (sym = 0; sym < codes; sym++) {
    count[lens[lens_index + sym]]++;
  }

  /* bound code lengths, force root to be within code lengths */
  root = bits;
  for (max = MAXBITS; max >= 1; max--) {
    if (count[max] !== 0) { break; }
  }
  if (root > max) {
    root = max;
  }
  if (max === 0) {                     /* no symbols to code at all */
    //table.op[opts.table_index] = 64;  //here.op = (var char)64;    /* invalid code marker */
    //table.bits[opts.table_index] = 1;   //here.bits = (var char)1;
    //table.val[opts.table_index++] = 0;   //here.val = (var short)0;
    table[table_index++] = (1 << 24) | (64 << 16) | 0;


    //table.op[opts.table_index] = 64;
    //table.bits[opts.table_index] = 1;
    //table.val[opts.table_index++] = 0;
    table[table_index++] = (1 << 24) | (64 << 16) | 0;

    opts.bits = 1;
    return 0;     /* no symbols, but wait for decoding to report error */
  }
  for (min = 1; min < max; min++) {
    if (count[min] !== 0) { break; }
  }
  if (root < min) {
    root = min;
  }

  /* check for an over-subscribed or incomplete set of lengths */
  left = 1;
  for (len = 1; len <= MAXBITS; len++) {
    left <<= 1;
    left -= count[len];
    if (left < 0) {
      return -1;
    }        /* over-subscribed */
  }
  if (left > 0 && (type === CODES || max !== 1)) {
    return -1;                      /* incomplete set */
  }

  /* generate offsets into symbol table for each length for sorting */
  offs[1] = 0;
  for (len = 1; len < MAXBITS; len++) {
    offs[len + 1] = offs[len] + count[len];
  }

  /* sort symbols by length, by symbol order within each length */
  for (sym = 0; sym < codes; sym++) {
    if (lens[lens_index + sym] !== 0) {
      work[offs[lens[lens_index + sym]]++] = sym;
    }
  }

  /*
   Create and fill in decoding tables.  In this loop, the table being
   filled is at next and has curr index bits.  The code being used is huff
   with length len.  That code is converted to an index by dropping drop
   bits off of the bottom.  For codes where len is less than drop + curr,
   those top drop + curr - len bits are incremented through all values to
   fill the table with replicated entries.

   root is the number of index bits for the root table.  When len exceeds
   root, sub-tables are created pointed to by the root entry with an index
   of the low root bits of huff.  This is saved in low to check for when a
   new sub-table should be started.  drop is zero when the root table is
   being filled, and drop is root when sub-tables are being filled.

   When a new sub-table is needed, it is necessary to look ahead in the
   code lengths to determine what size sub-table is needed.  The length
   counts are used for this, and so count[] is decremented as codes are
   entered in the tables.

   used keeps track of how many table entries have been allocated from the
   provided *table space.  It is checked for LENS and DIST tables against
   the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in
   the initial root table size constants.  See the comments in inftrees.h
   for more information.

   sym increments through all symbols, and the loop terminates when
   all codes of length max, i.e. all codes, have been processed.  This
   routine permits incomplete codes, so another loop after this one fills
   in the rest of the decoding tables with invalid code markers.
   */

  /* set up for code type */
  // poor man optimization - use if-else instead of switch,
  // to avoid deopts in old v8
  if (type === CODES) {
    base = extra = work;    /* dummy value--not used */
    end = 19;

  } else if (type === LENS) {
    base = lbase;
    base_index -= 257;
    extra = lext;
    extra_index -= 257;
    end = 256;

  } else {                    /* DISTS */
    base = dbase;
    extra = dext;
    end = -1;
  }

  /* initialize opts for loop */
  huff = 0;                   /* starting code */
  sym = 0;                    /* starting code symbol */
  len = min;                  /* starting code length */
  next = table_index;              /* current table to fill in */
  curr = root;                /* current table index bits */
  drop = 0;                   /* current bits to drop from code for index */
  low = -1;                   /* trigger new sub-table when len > root */
  used = 1 << root;          /* use root table entries */
  mask = used - 1;            /* mask for comparing low */

  /* check available table space */
  if ((type === LENS && used > ENOUGH_LENS) ||
    (type === DISTS && used > ENOUGH_DISTS)) {
    return 1;
  }

  /* process all codes and make table entries */
  for (;;) {
    /* create table entry */
    here_bits = len - drop;
    if (work[sym] < end) {
      here_op = 0;
      here_val = work[sym];
    }
    else if (work[sym] > end) {
      here_op = extra[extra_index + work[sym]];
      here_val = base[base_index + work[sym]];
    }
    else {
      here_op = 32 + 64;         /* end of block */
      here_val = 0;
    }

    /* replicate for those indices with low len bits equal to huff */
    incr = 1 << (len - drop);
    fill = 1 << curr;
    min = fill;                 /* save offset to next table */
    do {
      fill -= incr;
      table[next + (huff >> drop) + fill] = (here_bits << 24) | (here_op << 16) | here_val |0;
    } while (fill !== 0);

    /* backwards increment the len-bit code huff */
    incr = 1 << (len - 1);
    while (huff & incr) {
      incr >>= 1;
    }
    if (incr !== 0) {
      huff &= incr - 1;
      huff += incr;
    } else {
      huff = 0;
    }

    /* go to next symbol, update count, len */
    sym++;
    if (--count[len] === 0) {
      if (len === max) { break; }
      len = lens[lens_index + work[sym]];
    }

    /* create new sub-table if needed */
    if (len > root && (huff & mask) !== low) {
      /* if first time, transition to sub-tables */
      if (drop === 0) {
        drop = root;
      }

      /* increment past last table */
      next += min;            /* here min is 1 << curr */

      /* determine length of next table */
      curr = len - drop;
      left = 1 << curr;
      while (curr + drop < max) {
        left -= count[curr + drop];
        if (left <= 0) { break; }
        curr++;
        left <<= 1;
      }

      /* check for enough space */
      used += 1 << curr;
      if ((type === LENS && used > ENOUGH_LENS) ||
        (type === DISTS && used > ENOUGH_DISTS)) {
        return 1;
      }

      /* point entry in root table to sub-table */
      low = huff & mask;
      /*table.op[low] = curr;
      table.bits[low] = root;
      table.val[low] = next - opts.table_index;*/
      table[low] = (root << 24) | (curr << 16) | (next - table_index) |0;
    }
  }

  /* fill in remaining table entry if code is incomplete (guaranteed to have
   at most one remaining entry, since if the code is incomplete, the
   maximum code length that was allowed to get this far is one bit) */
  if (huff !== 0) {
    //table.op[next + huff] = 64;            /* invalid code marker */
    //table.bits[next + huff] = len - drop;
    //table.val[next + huff] = 0;
    table[next + huff] = ((len - drop) << 24) | (64 << 16) |0;
  }

  /* set return parameters */
  //opts.table_index += used;
  opts.bits = root;
  return 0;
};


/***/ }),

/***/ "../../node_modules/pako/lib/zlib/messages.js":
/*!*********************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/pako/lib/zlib/messages.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

module.exports = {
  2:      'need dictionary',     /* Z_NEED_DICT       2  */
  1:      'stream end',          /* Z_STREAM_END      1  */
  0:      '',                    /* Z_OK              0  */
  '-1':   'file error',          /* Z_ERRNO         (-1) */
  '-2':   'stream error',        /* Z_STREAM_ERROR  (-2) */
  '-3':   'data error',          /* Z_DATA_ERROR    (-3) */
  '-4':   'insufficient memory', /* Z_MEM_ERROR     (-4) */
  '-5':   'buffer error',        /* Z_BUF_ERROR     (-5) */
  '-6':   'incompatible version' /* Z_VERSION_ERROR (-6) */
};


/***/ }),

/***/ "../../node_modules/pako/lib/zlib/trees.js":
/*!******************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/pako/lib/zlib/trees.js ***!
  \******************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

/* eslint-disable space-unary-ops */

var utils = __webpack_require__(/*! ../utils/common */ "../../node_modules/pako/lib/utils/common.js");

/* Public constants ==========================================================*/
/* ===========================================================================*/


//var Z_FILTERED          = 1;
//var Z_HUFFMAN_ONLY      = 2;
//var Z_RLE               = 3;
var Z_FIXED               = 4;
//var Z_DEFAULT_STRATEGY  = 0;

/* Possible values of the data_type field (though see inflate()) */
var Z_BINARY              = 0;
var Z_TEXT                = 1;
//var Z_ASCII             = 1; // = Z_TEXT
var Z_UNKNOWN             = 2;

/*============================================================================*/


function zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }

// From zutil.h

var STORED_BLOCK = 0;
var STATIC_TREES = 1;
var DYN_TREES    = 2;
/* The three kinds of block type */

var MIN_MATCH    = 3;
var MAX_MATCH    = 258;
/* The minimum and maximum match lengths */

// From deflate.h
/* ===========================================================================
 * Internal compression state.
 */

var LENGTH_CODES  = 29;
/* number of length codes, not counting the special END_BLOCK code */

var LITERALS      = 256;
/* number of literal bytes 0..255 */

var L_CODES       = LITERALS + 1 + LENGTH_CODES;
/* number of Literal or Length codes, including the END_BLOCK code */

var D_CODES       = 30;
/* number of distance codes */

var BL_CODES      = 19;
/* number of codes used to transfer the bit lengths */

var HEAP_SIZE     = 2 * L_CODES + 1;
/* maximum heap size */

var MAX_BITS      = 15;
/* All codes must not exceed MAX_BITS bits */

var Buf_size      = 16;
/* size of bit buffer in bi_buf */


/* ===========================================================================
 * Constants
 */

var MAX_BL_BITS = 7;
/* Bit length codes must not exceed MAX_BL_BITS bits */

var END_BLOCK   = 256;
/* end of block literal code */

var REP_3_6     = 16;
/* repeat previous bit length 3-6 times (2 bits of repeat count) */

var REPZ_3_10   = 17;
/* repeat a zero length 3-10 times  (3 bits of repeat count) */

var REPZ_11_138 = 18;
/* repeat a zero length 11-138 times  (7 bits of repeat count) */

/* eslint-disable comma-spacing,array-bracket-spacing */
var extra_lbits =   /* extra bits for each length code */
  [0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0];

var extra_dbits =   /* extra bits for each distance code */
  [0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13];

var extra_blbits =  /* extra bits for each bit length code */
  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7];

var bl_order =
  [16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];
/* eslint-enable comma-spacing,array-bracket-spacing */

/* The lengths of the bit length codes are sent in order of decreasing
 * probability, to avoid transmitting the lengths for unused bit length codes.
 */

/* ===========================================================================
 * Local data. These are initialized only once.
 */

// We pre-fill arrays with 0 to avoid uninitialized gaps

var DIST_CODE_LEN = 512; /* see definition of array dist_code below */

// !!!! Use flat array instead of structure, Freq = i*2, Len = i*2+1
var static_ltree  = new Array((L_CODES + 2) * 2);
zero(static_ltree);
/* The static literal tree. Since the bit lengths are imposed, there is no
 * need for the L_CODES extra codes used during heap construction. However
 * The codes 286 and 287 are needed to build a canonical tree (see _tr_init
 * below).
 */

var static_dtree  = new Array(D_CODES * 2);
zero(static_dtree);
/* The static distance tree. (Actually a trivial tree since all codes use
 * 5 bits.)
 */

var _dist_code    = new Array(DIST_CODE_LEN);
zero(_dist_code);
/* Distance codes. The first 256 values correspond to the distances
 * 3 .. 258, the last 256 values correspond to the top 8 bits of
 * the 15 bit distances.
 */

var _length_code  = new Array(MAX_MATCH - MIN_MATCH + 1);
zero(_length_code);
/* length code for each normalized match length (0 == MIN_MATCH) */

var base_length   = new Array(LENGTH_CODES);
zero(base_length);
/* First normalized length for each code (0 = MIN_MATCH) */

var base_dist     = new Array(D_CODES);
zero(base_dist);
/* First normalized distance for each code (0 = distance of 1) */


function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {

  this.static_tree  = static_tree;  /* static tree or NULL */
  this.extra_bits   = extra_bits;   /* extra bits for each code or NULL */
  this.extra_base   = extra_base;   /* base index for extra_bits */
  this.elems        = elems;        /* max number of elements in the tree */
  this.max_length   = max_length;   /* max bit length for the codes */

  // show if `static_tree` has data or dummy - needed for monomorphic objects
  this.has_stree    = static_tree && static_tree.length;
}


var static_l_desc;
var static_d_desc;
var static_bl_desc;


function TreeDesc(dyn_tree, stat_desc) {
  this.dyn_tree = dyn_tree;     /* the dynamic tree */
  this.max_code = 0;            /* largest code with non zero frequency */
  this.stat_desc = stat_desc;   /* the corresponding static tree */
}



function d_code(dist) {
  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
}


/* ===========================================================================
 * Output a short LSB first on the stream.
 * IN assertion: there is enough room in pendingBuf.
 */
function put_short(s, w) {
//    put_byte(s, (uch)((w) & 0xff));
//    put_byte(s, (uch)((ush)(w) >> 8));
  s.pending_buf[s.pending++] = (w) & 0xff;
  s.pending_buf[s.pending++] = (w >>> 8) & 0xff;
}


/* ===========================================================================
 * Send a value on a given number of bits.
 * IN assertion: length <= 16 and value fits in length bits.
 */
function send_bits(s, value, length) {
  if (s.bi_valid > (Buf_size - length)) {
    s.bi_buf |= (value << s.bi_valid) & 0xffff;
    put_short(s, s.bi_buf);
    s.bi_buf = value >> (Buf_size - s.bi_valid);
    s.bi_valid += length - Buf_size;
  } else {
    s.bi_buf |= (value << s.bi_valid) & 0xffff;
    s.bi_valid += length;
  }
}


function send_code(s, c, tree) {
  send_bits(s, tree[c * 2]/*.Code*/, tree[c * 2 + 1]/*.Len*/);
}


/* ===========================================================================
 * Reverse the first len bits of a code, using straightforward code (a faster
 * method would use a table)
 * IN assertion: 1 <= len <= 15
 */
function bi_reverse(code, len) {
  var res = 0;
  do {
    res |= code & 1;
    code >>>= 1;
    res <<= 1;
  } while (--len > 0);
  return res >>> 1;
}


/* ===========================================================================
 * Flush the bit buffer, keeping at most 7 bits in it.
 */
function bi_flush(s) {
  if (s.bi_valid === 16) {
    put_short(s, s.bi_buf);
    s.bi_buf = 0;
    s.bi_valid = 0;

  } else if (s.bi_valid >= 8) {
    s.pending_buf[s.pending++] = s.bi_buf & 0xff;
    s.bi_buf >>= 8;
    s.bi_valid -= 8;
  }
}


/* ===========================================================================
 * Compute the optimal bit lengths for a tree and update the total bit length
 * for the current block.
 * IN assertion: the fields freq and dad are set, heap[heap_max] and
 *    above are the tree nodes sorted by increasing frequency.
 * OUT assertions: the field len is set to the optimal bit length, the
 *     array bl_count contains the frequencies for each bit length.
 *     The length opt_len is updated; static_len is also updated if stree is
 *     not null.
 */
function gen_bitlen(s, desc)
//    deflate_state *s;
//    tree_desc *desc;    /* the tree descriptor */
{
  var tree            = desc.dyn_tree;
  var max_code        = desc.max_code;
  var stree           = desc.stat_desc.static_tree;
  var has_stree       = desc.stat_desc.has_stree;
  var extra           = desc.stat_desc.extra_bits;
  var base            = desc.stat_desc.extra_base;
  var max_length      = desc.stat_desc.max_length;
  var h;              /* heap index */
  var n, m;           /* iterate over the tree elements */
  var bits;           /* bit length */
  var xbits;          /* extra bits */
  var f;              /* frequency */
  var overflow = 0;   /* number of elements with bit length too large */

  for (bits = 0; bits <= MAX_BITS; bits++) {
    s.bl_count[bits] = 0;
  }

  /* In a first pass, compute the optimal bit lengths (which may
   * overflow in the case of the bit length tree).
   */
  tree[s.heap[s.heap_max] * 2 + 1]/*.Len*/ = 0; /* root of the heap */

  for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {
    n = s.heap[h];
    bits = tree[tree[n * 2 + 1]/*.Dad*/ * 2 + 1]/*.Len*/ + 1;
    if (bits > max_length) {
      bits = max_length;
      overflow++;
    }
    tree[n * 2 + 1]/*.Len*/ = bits;
    /* We overwrite tree[n].Dad which is no longer needed */

    if (n > max_code) { continue; } /* not a leaf node */

    s.bl_count[bits]++;
    xbits = 0;
    if (n >= base) {
      xbits = extra[n - base];
    }
    f = tree[n * 2]/*.Freq*/;
    s.opt_len += f * (bits + xbits);
    if (has_stree) {
      s.static_len += f * (stree[n * 2 + 1]/*.Len*/ + xbits);
    }
  }
  if (overflow === 0) { return; }

  // Trace((stderr,"\nbit length overflow\n"));
  /* This happens for example on obj2 and pic of the Calgary corpus */

  /* Find the first bit length which could increase: */
  do {
    bits = max_length - 1;
    while (s.bl_count[bits] === 0) { bits--; }
    s.bl_count[bits]--;      /* move one leaf down the tree */
    s.bl_count[bits + 1] += 2; /* move one overflow item as its brother */
    s.bl_count[max_length]--;
    /* The brother of the overflow item also moves one step up,
     * but this does not affect bl_count[max_length]
     */
    overflow -= 2;
  } while (overflow > 0);

  /* Now recompute all bit lengths, scanning in increasing frequency.
   * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
   * lengths instead of fixing only the wrong ones. This idea is taken
   * from 'ar' written by Haruhiko Okumura.)
   */
  for (bits = max_length; bits !== 0; bits--) {
    n = s.bl_count[bits];
    while (n !== 0) {
      m = s.heap[--h];
      if (m > max_code) { continue; }
      if (tree[m * 2 + 1]/*.Len*/ !== bits) {
        // Trace((stderr,"code %d bits %d->%d\n", m, tree[m].Len, bits));
        s.opt_len += (bits - tree[m * 2 + 1]/*.Len*/) * tree[m * 2]/*.Freq*/;
        tree[m * 2 + 1]/*.Len*/ = bits;
      }
      n--;
    }
  }
}


/* ===========================================================================
 * Generate the codes for a given tree and bit counts (which need not be
 * optimal).
 * IN assertion: the array bl_count contains the bit length statistics for
 * the given tree and the field len is set for all tree elements.
 * OUT assertion: the field code is set for all tree elements of non
 *     zero code length.
 */
function gen_codes(tree, max_code, bl_count)
//    ct_data *tree;             /* the tree to decorate */
//    int max_code;              /* largest code with non zero frequency */
//    ushf *bl_count;            /* number of codes at each bit length */
{
  var next_code = new Array(MAX_BITS + 1); /* next code value for each bit length */
  var code = 0;              /* running code value */
  var bits;                  /* bit index */
  var n;                     /* code index */

  /* The distribution counts are first used to generate the code values
   * without bit reversal.
   */
  for (bits = 1; bits <= MAX_BITS; bits++) {
    next_code[bits] = code = (code + bl_count[bits - 1]) << 1;
  }
  /* Check that the bit counts in bl_count are consistent. The last code
   * must be all ones.
   */
  //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,
  //        "inconsistent bit counts");
  //Tracev((stderr,"\ngen_codes: max_code %d ", max_code));

  for (n = 0;  n <= max_code; n++) {
    var len = tree[n * 2 + 1]/*.Len*/;
    if (len === 0) { continue; }
    /* Now reverse the bits */
    tree[n * 2]/*.Code*/ = bi_reverse(next_code[len]++, len);

    //Tracecv(tree != static_ltree, (stderr,"\nn %3d %c l %2d c %4x (%x) ",
    //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));
  }
}


/* ===========================================================================
 * Initialize the various 'constant' tables.
 */
function tr_static_init() {
  var n;        /* iterates over tree elements */
  var bits;     /* bit counter */
  var length;   /* length value */
  var code;     /* code value */
  var dist;     /* distance index */
  var bl_count = new Array(MAX_BITS + 1);
  /* number of codes at each bit length for an optimal tree */

  // do check in _tr_init()
  //if (static_init_done) return;

  /* For some embedded targets, global variables are not initialized: */
/*#ifdef NO_INIT_GLOBAL_POINTERS
  static_l_desc.static_tree = static_ltree;
  static_l_desc.extra_bits = extra_lbits;
  static_d_desc.static_tree = static_dtree;
  static_d_desc.extra_bits = extra_dbits;
  static_bl_desc.extra_bits = extra_blbits;
#endif*/

  /* Initialize the mapping length (0..255) -> length code (0..28) */
  length = 0;
  for (code = 0; code < LENGTH_CODES - 1; code++) {
    base_length[code] = length;
    for (n = 0; n < (1 << extra_lbits[code]); n++) {
      _length_code[length++] = code;
    }
  }
  //Assert (length == 256, "tr_static_init: length != 256");
  /* Note that the length 255 (match length 258) can be represented
   * in two different ways: code 284 + 5 bits or code 285, so we
   * overwrite length_code[255] to use the best encoding:
   */
  _length_code[length - 1] = code;

  /* Initialize the mapping dist (0..32K) -> dist code (0..29) */
  dist = 0;
  for (code = 0; code < 16; code++) {
    base_dist[code] = dist;
    for (n = 0; n < (1 << extra_dbits[code]); n++) {
      _dist_code[dist++] = code;
    }
  }
  //Assert (dist == 256, "tr_static_init: dist != 256");
  dist >>= 7; /* from now on, all distances are divided by 128 */
  for (; code < D_CODES; code++) {
    base_dist[code] = dist << 7;
    for (n = 0; n < (1 << (extra_dbits[code] - 7)); n++) {
      _dist_code[256 + dist++] = code;
    }
  }
  //Assert (dist == 256, "tr_static_init: 256+dist != 512");

  /* Construct the codes of the static literal tree */
  for (bits = 0; bits <= MAX_BITS; bits++) {
    bl_count[bits] = 0;
  }

  n = 0;
  while (n <= 143) {
    static_ltree[n * 2 + 1]/*.Len*/ = 8;
    n++;
    bl_count[8]++;
  }
  while (n <= 255) {
    static_ltree[n * 2 + 1]/*.Len*/ = 9;
    n++;
    bl_count[9]++;
  }
  while (n <= 279) {
    static_ltree[n * 2 + 1]/*.Len*/ = 7;
    n++;
    bl_count[7]++;
  }
  while (n <= 287) {
    static_ltree[n * 2 + 1]/*.Len*/ = 8;
    n++;
    bl_count[8]++;
  }
  /* Codes 286 and 287 do not exist, but we must include them in the
   * tree construction to get a canonical Huffman tree (longest code
   * all ones)
   */
  gen_codes(static_ltree, L_CODES + 1, bl_count);

  /* The static distance tree is trivial: */
  for (n = 0; n < D_CODES; n++) {
    static_dtree[n * 2 + 1]/*.Len*/ = 5;
    static_dtree[n * 2]/*.Code*/ = bi_reverse(n, 5);
  }

  // Now data ready and we can init static trees
  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0,          D_CODES, MAX_BITS);
  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0,         BL_CODES, MAX_BL_BITS);

  //static_init_done = true;
}


/* ===========================================================================
 * Initialize a new block.
 */
function init_block(s) {
  var n; /* iterates over tree elements */

  /* Initialize the trees. */
  for (n = 0; n < L_CODES;  n++) { s.dyn_ltree[n * 2]/*.Freq*/ = 0; }
  for (n = 0; n < D_CODES;  n++) { s.dyn_dtree[n * 2]/*.Freq*/ = 0; }
  for (n = 0; n < BL_CODES; n++) { s.bl_tree[n * 2]/*.Freq*/ = 0; }

  s.dyn_ltree[END_BLOCK * 2]/*.Freq*/ = 1;
  s.opt_len = s.static_len = 0;
  s.last_lit = s.matches = 0;
}


/* ===========================================================================
 * Flush the bit buffer and align the output on a byte boundary
 */
function bi_windup(s)
{
  if (s.bi_valid > 8) {
    put_short(s, s.bi_buf);
  } else if (s.bi_valid > 0) {
    //put_byte(s, (Byte)s->bi_buf);
    s.pending_buf[s.pending++] = s.bi_buf;
  }
  s.bi_buf = 0;
  s.bi_valid = 0;
}

/* ===========================================================================
 * Copy a stored block, storing first the length and its
 * one's complement if requested.
 */
function copy_block(s, buf, len, header)
//DeflateState *s;
//charf    *buf;    /* the input data */
//unsigned len;     /* its length */
//int      header;  /* true if block header must be written */
{
  bi_windup(s);        /* align on byte boundary */

  if (header) {
    put_short(s, len);
    put_short(s, ~len);
  }
//  while (len--) {
//    put_byte(s, *buf++);
//  }
  utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);
  s.pending += len;
}

/* ===========================================================================
 * Compares to subtrees, using the tree depth as tie breaker when
 * the subtrees have equal frequency. This minimizes the worst case length.
 */
function smaller(tree, n, m, depth) {
  var _n2 = n * 2;
  var _m2 = m * 2;
  return (tree[_n2]/*.Freq*/ < tree[_m2]/*.Freq*/ ||
         (tree[_n2]/*.Freq*/ === tree[_m2]/*.Freq*/ && depth[n] <= depth[m]));
}

/* ===========================================================================
 * Restore the heap property by moving down the tree starting at node k,
 * exchanging a node with the smallest of its two sons if necessary, stopping
 * when the heap property is re-established (each father smaller than its
 * two sons).
 */
function pqdownheap(s, tree, k)
//    deflate_state *s;
//    ct_data *tree;  /* the tree to restore */
//    int k;               /* node to move down */
{
  var v = s.heap[k];
  var j = k << 1;  /* left son of k */
  while (j <= s.heap_len) {
    /* Set j to the smallest of the two sons: */
    if (j < s.heap_len &&
      smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
      j++;
    }
    /* Exit if v is smaller than both sons */
    if (smaller(tree, v, s.heap[j], s.depth)) { break; }

    /* Exchange v with the smallest son */
    s.heap[k] = s.heap[j];
    k = j;

    /* And continue down the tree, setting j to the left son of k */
    j <<= 1;
  }
  s.heap[k] = v;
}


// inlined manually
// var SMALLEST = 1;

/* ===========================================================================
 * Send the block data compressed using the given Huffman trees
 */
function compress_block(s, ltree, dtree)
//    deflate_state *s;
//    const ct_data *ltree; /* literal tree */
//    const ct_data *dtree; /* distance tree */
{
  var dist;           /* distance of matched string */
  var lc;             /* match length or unmatched char (if dist == 0) */
  var lx = 0;         /* running index in l_buf */
  var code;           /* the code to send */
  var extra;          /* number of extra bits to send */

  if (s.last_lit !== 0) {
    do {
      dist = (s.pending_buf[s.d_buf + lx * 2] << 8) | (s.pending_buf[s.d_buf + lx * 2 + 1]);
      lc = s.pending_buf[s.l_buf + lx];
      lx++;

      if (dist === 0) {
        send_code(s, lc, ltree); /* send a literal byte */
        //Tracecv(isgraph(lc), (stderr," '%c' ", lc));
      } else {
        /* Here, lc is the match length - MIN_MATCH */
        code = _length_code[lc];
        send_code(s, code + LITERALS + 1, ltree); /* send the length code */
        extra = extra_lbits[code];
        if (extra !== 0) {
          lc -= base_length[code];
          send_bits(s, lc, extra);       /* send the extra length bits */
        }
        dist--; /* dist is now the match distance - 1 */
        code = d_code(dist);
        //Assert (code < D_CODES, "bad d_code");

        send_code(s, code, dtree);       /* send the distance code */
        extra = extra_dbits[code];
        if (extra !== 0) {
          dist -= base_dist[code];
          send_bits(s, dist, extra);   /* send the extra distance bits */
        }
      } /* literal or match pair ? */

      /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */
      //Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,
      //       "pendingBuf overflow");

    } while (lx < s.last_lit);
  }

  send_code(s, END_BLOCK, ltree);
}


/* ===========================================================================
 * Construct one Huffman tree and assigns the code bit strings and lengths.
 * Update the total bit length for the current block.
 * IN assertion: the field freq is set for all tree elements.
 * OUT assertions: the fields len and code are set to the optimal bit length
 *     and corresponding code. The length opt_len is updated; static_len is
 *     also updated if stree is not null. The field max_code is set.
 */
function build_tree(s, desc)
//    deflate_state *s;
//    tree_desc *desc; /* the tree descriptor */
{
  var tree     = desc.dyn_tree;
  var stree    = desc.stat_desc.static_tree;
  var has_stree = desc.stat_desc.has_stree;
  var elems    = desc.stat_desc.elems;
  var n, m;          /* iterate over heap elements */
  var max_code = -1; /* largest code with non zero frequency */
  var node;          /* new node being created */

  /* Construct the initial heap, with least frequent element in
   * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
   * heap[0] is not used.
   */
  s.heap_len = 0;
  s.heap_max = HEAP_SIZE;

  for (n = 0; n < elems; n++) {
    if (tree[n * 2]/*.Freq*/ !== 0) {
      s.heap[++s.heap_len] = max_code = n;
      s.depth[n] = 0;

    } else {
      tree[n * 2 + 1]/*.Len*/ = 0;
    }
  }

  /* The pkzip format requires that at least one distance code exists,
   * and that at least one bit should be sent even if there is only one
   * possible code. So to avoid special checks later on we force at least
   * two codes of non zero frequency.
   */
  while (s.heap_len < 2) {
    node = s.heap[++s.heap_len] = (max_code < 2 ? ++max_code : 0);
    tree[node * 2]/*.Freq*/ = 1;
    s.depth[node] = 0;
    s.opt_len--;

    if (has_stree) {
      s.static_len -= stree[node * 2 + 1]/*.Len*/;
    }
    /* node is 0 or 1 so it does not have extra bits */
  }
  desc.max_code = max_code;

  /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
   * establish sub-heaps of increasing lengths:
   */
  for (n = (s.heap_len >> 1/*int /2*/); n >= 1; n--) { pqdownheap(s, tree, n); }

  /* Construct the Huffman tree by repeatedly combining the least two
   * frequent nodes.
   */
  node = elems;              /* next internal node of the tree */
  do {
    //pqremove(s, tree, n);  /* n = node of least frequency */
    /*** pqremove ***/
    n = s.heap[1/*SMALLEST*/];
    s.heap[1/*SMALLEST*/] = s.heap[s.heap_len--];
    pqdownheap(s, tree, 1/*SMALLEST*/);
    /***/

    m = s.heap[1/*SMALLEST*/]; /* m = node of next least frequency */

    s.heap[--s.heap_max] = n; /* keep the nodes sorted by frequency */
    s.heap[--s.heap_max] = m;

    /* Create a new node father of n and m */
    tree[node * 2]/*.Freq*/ = tree[n * 2]/*.Freq*/ + tree[m * 2]/*.Freq*/;
    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
    tree[n * 2 + 1]/*.Dad*/ = tree[m * 2 + 1]/*.Dad*/ = node;

    /* and insert the new node in the heap */
    s.heap[1/*SMALLEST*/] = node++;
    pqdownheap(s, tree, 1/*SMALLEST*/);

  } while (s.heap_len >= 2);

  s.heap[--s.heap_max] = s.heap[1/*SMALLEST*/];

  /* At this point, the fields freq and dad are set. We can now
   * generate the bit lengths.
   */
  gen_bitlen(s, desc);

  /* The field len is now set, we can generate the bit codes */
  gen_codes(tree, max_code, s.bl_count);
}


/* ===========================================================================
 * Scan a literal or distance tree to determine the frequencies of the codes
 * in the bit length tree.
 */
function scan_tree(s, tree, max_code)
//    deflate_state *s;
//    ct_data *tree;   /* the tree to be scanned */
//    int max_code;    /* and its largest code of non zero frequency */
{
  var n;                     /* iterates over all tree elements */
  var prevlen = -1;          /* last emitted length */
  var curlen;                /* length of current code */

  var nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */

  var count = 0;             /* repeat count of the current code */
  var max_count = 7;         /* max repeat count */
  var min_count = 4;         /* min repeat count */

  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  tree[(max_code + 1) * 2 + 1]/*.Len*/ = 0xffff; /* guard */

  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;

    if (++count < max_count && curlen === nextlen) {
      continue;

    } else if (count < min_count) {
      s.bl_tree[curlen * 2]/*.Freq*/ += count;

    } else if (curlen !== 0) {

      if (curlen !== prevlen) { s.bl_tree[curlen * 2]/*.Freq*/++; }
      s.bl_tree[REP_3_6 * 2]/*.Freq*/++;

    } else if (count <= 10) {
      s.bl_tree[REPZ_3_10 * 2]/*.Freq*/++;

    } else {
      s.bl_tree[REPZ_11_138 * 2]/*.Freq*/++;
    }

    count = 0;
    prevlen = curlen;

    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;

    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;

    } else {
      max_count = 7;
      min_count = 4;
    }
  }
}


/* ===========================================================================
 * Send a literal or distance tree in compressed form, using the codes in
 * bl_tree.
 */
function send_tree(s, tree, max_code)
//    deflate_state *s;
//    ct_data *tree; /* the tree to be scanned */
//    int max_code;       /* and its largest code of non zero frequency */
{
  var n;                     /* iterates over all tree elements */
  var prevlen = -1;          /* last emitted length */
  var curlen;                /* length of current code */

  var nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */

  var count = 0;             /* repeat count of the current code */
  var max_count = 7;         /* max repeat count */
  var min_count = 4;         /* min repeat count */

  /* tree[max_code+1].Len = -1; */  /* guard already set */
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }

  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;

    if (++count < max_count && curlen === nextlen) {
      continue;

    } else if (count < min_count) {
      do { send_code(s, curlen, s.bl_tree); } while (--count !== 0);

    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        send_code(s, curlen, s.bl_tree);
        count--;
      }
      //Assert(count >= 3 && count <= 6, " 3_6?");
      send_code(s, REP_3_6, s.bl_tree);
      send_bits(s, count - 3, 2);

    } else if (count <= 10) {
      send_code(s, REPZ_3_10, s.bl_tree);
      send_bits(s, count - 3, 3);

    } else {
      send_code(s, REPZ_11_138, s.bl_tree);
      send_bits(s, count - 11, 7);
    }

    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;

    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;

    } else {
      max_count = 7;
      min_count = 4;
    }
  }
}


/* ===========================================================================
 * Construct the Huffman tree for the bit lengths and return the index in
 * bl_order of the last bit length code to send.
 */
function build_bl_tree(s) {
  var max_blindex;  /* index of last bit length code of non zero freq */

  /* Determine the bit length frequencies for literal and distance trees */
  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);

  /* Build the bit length tree: */
  build_tree(s, s.bl_desc);
  /* opt_len now includes the length of the tree representations, except
   * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.
   */

  /* Determine the number of bit length codes to send. The pkzip format
   * requires that at least 4 bit length codes be sent. (appnote.txt says
   * 3 but the actual value used is 4.)
   */
  for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
    if (s.bl_tree[bl_order[max_blindex] * 2 + 1]/*.Len*/ !== 0) {
      break;
    }
  }
  /* Update opt_len to include the bit length tree and counts */
  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
  //Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld",
  //        s->opt_len, s->static_len));

  return max_blindex;
}


/* ===========================================================================
 * Send the header for a block using dynamic Huffman trees: the counts, the
 * lengths of the bit length codes, the literal tree and the distance tree.
 * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
 */
function send_all_trees(s, lcodes, dcodes, blcodes)
//    deflate_state *s;
//    int lcodes, dcodes, blcodes; /* number of codes for each tree */
{
  var rank;                    /* index in bl_order */

  //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, "not enough codes");
  //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,
  //        "too many codes");
  //Tracev((stderr, "\nbl counts: "));
  send_bits(s, lcodes - 257, 5); /* not +255 as stated in appnote.txt */
  send_bits(s, dcodes - 1,   5);
  send_bits(s, blcodes - 4,  4); /* not -3 as stated in appnote.txt */
  for (rank = 0; rank < blcodes; rank++) {
    //Tracev((stderr, "\nbl code %2d ", bl_order[rank]));
    send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1]/*.Len*/, 3);
  }
  //Tracev((stderr, "\nbl tree: sent %ld", s->bits_sent));

  send_tree(s, s.dyn_ltree, lcodes - 1); /* literal tree */
  //Tracev((stderr, "\nlit tree: sent %ld", s->bits_sent));

  send_tree(s, s.dyn_dtree, dcodes - 1); /* distance tree */
  //Tracev((stderr, "\ndist tree: sent %ld", s->bits_sent));
}


/* ===========================================================================
 * Check if the data type is TEXT or BINARY, using the following algorithm:
 * - TEXT if the two conditions below are satisfied:
 *    a) There are no non-portable control characters belonging to the
 *       "black list" (0..6, 14..25, 28..31).
 *    b) There is at least one printable character belonging to the
 *       "white list" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).
 * - BINARY otherwise.
 * - The following partially-portable control characters form a
 *   "gray list" that is ignored in this detection algorithm:
 *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).
 * IN assertion: the fields Freq of dyn_ltree are set.
 */
function detect_data_type(s) {
  /* black_mask is the bit mask of black-listed bytes
   * set bits 0..6, 14..25, and 28..31
   * 0xf3ffc07f = binary 11110011111111111100000001111111
   */
  var black_mask = 0xf3ffc07f;
  var n;

  /* Check for non-textual ("black-listed") bytes. */
  for (n = 0; n <= 31; n++, black_mask >>>= 1) {
    if ((black_mask & 1) && (s.dyn_ltree[n * 2]/*.Freq*/ !== 0)) {
      return Z_BINARY;
    }
  }

  /* Check for textual ("white-listed") bytes. */
  if (s.dyn_ltree[9 * 2]/*.Freq*/ !== 0 || s.dyn_ltree[10 * 2]/*.Freq*/ !== 0 ||
      s.dyn_ltree[13 * 2]/*.Freq*/ !== 0) {
    return Z_TEXT;
  }
  for (n = 32; n < LITERALS; n++) {
    if (s.dyn_ltree[n * 2]/*.Freq*/ !== 0) {
      return Z_TEXT;
    }
  }

  /* There are no "black-listed" or "white-listed" bytes:
   * this stream either is empty or has tolerated ("gray-listed") bytes only.
   */
  return Z_BINARY;
}


var static_init_done = false;

/* ===========================================================================
 * Initialize the tree data structures for a new zlib stream.
 */
function _tr_init(s)
{

  if (!static_init_done) {
    tr_static_init();
    static_init_done = true;
  }

  s.l_desc  = new TreeDesc(s.dyn_ltree, static_l_desc);
  s.d_desc  = new TreeDesc(s.dyn_dtree, static_d_desc);
  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);

  s.bi_buf = 0;
  s.bi_valid = 0;

  /* Initialize the first block of the first file: */
  init_block(s);
}


/* ===========================================================================
 * Send a stored block
 */
function _tr_stored_block(s, buf, stored_len, last)
//DeflateState *s;
//charf *buf;       /* input block */
//ulg stored_len;   /* length of input block */
//int last;         /* one if this is the last block for a file */
{
  send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);    /* send block type */
  copy_block(s, buf, stored_len, true); /* with header */
}


/* ===========================================================================
 * Send one empty static block to give enough lookahead for inflate.
 * This takes 10 bits, of which 7 may remain in the bit buffer.
 */
function _tr_align(s) {
  send_bits(s, STATIC_TREES << 1, 3);
  send_code(s, END_BLOCK, static_ltree);
  bi_flush(s);
}


/* ===========================================================================
 * Determine the best encoding for the current block: dynamic trees, static
 * trees or store, and output the encoded block to the zip file.
 */
function _tr_flush_block(s, buf, stored_len, last)
//DeflateState *s;
//charf *buf;       /* input block, or NULL if too old */
//ulg stored_len;   /* length of input block */
//int last;         /* one if this is the last block for a file */
{
  var opt_lenb, static_lenb;  /* opt_len and static_len in bytes */
  var max_blindex = 0;        /* index of last bit length code of non zero freq */

  /* Build the Huffman trees unless a stored block is forced */
  if (s.level > 0) {

    /* Check if the file is binary or text */
    if (s.strm.data_type === Z_UNKNOWN) {
      s.strm.data_type = detect_data_type(s);
    }

    /* Construct the literal and distance trees */
    build_tree(s, s.l_desc);
    // Tracev((stderr, "\nlit data: dyn %ld, stat %ld", s->opt_len,
    //        s->static_len));

    build_tree(s, s.d_desc);
    // Tracev((stderr, "\ndist data: dyn %ld, stat %ld", s->opt_len,
    //        s->static_len));
    /* At this point, opt_len and static_len are the total bit lengths of
     * the compressed block data, excluding the tree representations.
     */

    /* Build the bit length tree for the above two trees, and get the index
     * in bl_order of the last bit length code to send.
     */
    max_blindex = build_bl_tree(s);

    /* Determine the best encoding. Compute the block lengths in bytes. */
    opt_lenb = (s.opt_len + 3 + 7) >>> 3;
    static_lenb = (s.static_len + 3 + 7) >>> 3;

    // Tracev((stderr, "\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u ",
    //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,
    //        s->last_lit));

    if (static_lenb <= opt_lenb) { opt_lenb = static_lenb; }

  } else {
    // Assert(buf != (char*)0, "lost buf");
    opt_lenb = static_lenb = stored_len + 5; /* force a stored block */
  }

  if ((stored_len + 4 <= opt_lenb) && (buf !== -1)) {
    /* 4: two words for the lengths */

    /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
     * Otherwise we can't have processed more than WSIZE input bytes since
     * the last block flush, because compression would have been
     * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
     * transform a block into a stored block.
     */
    _tr_stored_block(s, buf, stored_len, last);

  } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {

    send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
    compress_block(s, static_ltree, static_dtree);

  } else {
    send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
    compress_block(s, s.dyn_ltree, s.dyn_dtree);
  }
  // Assert (s->compressed_len == s->bits_sent, "bad compressed size");
  /* The above check is made mod 2^32, for files larger than 512 MB
   * and uLong implemented on 32 bits.
   */
  init_block(s);

  if (last) {
    bi_windup(s);
  }
  // Tracev((stderr,"\ncomprlen %lu(%lu) ", s->compressed_len>>3,
  //       s->compressed_len-7*last));
}

/* ===========================================================================
 * Save the match info and tally the frequency counts. Return true if
 * the current block must be flushed.
 */
function _tr_tally(s, dist, lc)
//    deflate_state *s;
//    unsigned dist;  /* distance of matched string */
//    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */
{
  //var out_length, in_length, dcode;

  s.pending_buf[s.d_buf + s.last_lit * 2]     = (dist >>> 8) & 0xff;
  s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 0xff;

  s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff;
  s.last_lit++;

  if (dist === 0) {
    /* lc is the unmatched char */
    s.dyn_ltree[lc * 2]/*.Freq*/++;
  } else {
    s.matches++;
    /* Here, lc is the match length - MIN_MATCH */
    dist--;             /* dist = match distance - 1 */
    //Assert((ush)dist < (ush)MAX_DIST(s) &&
    //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&
    //       (ush)d_code(dist) < (ush)D_CODES,  "_tr_tally: bad match");

    s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]/*.Freq*/++;
    s.dyn_dtree[d_code(dist) * 2]/*.Freq*/++;
  }

// (!) This block is disabled in zlib defaults,
// don't enable it for binary compatibility

//#ifdef TRUNCATE_BLOCK
//  /* Try to guess if it is profitable to stop the current block here */
//  if ((s.last_lit & 0x1fff) === 0 && s.level > 2) {
//    /* Compute an upper bound for the compressed length */
//    out_length = s.last_lit*8;
//    in_length = s.strstart - s.block_start;
//
//    for (dcode = 0; dcode < D_CODES; dcode++) {
//      out_length += s.dyn_dtree[dcode*2]/*.Freq*/ * (5 + extra_dbits[dcode]);
//    }
//    out_length >>>= 3;
//    //Tracev((stderr,"\nlast_lit %u, in %ld, out ~%ld(%ld%%) ",
//    //       s->last_lit, in_length, out_length,
//    //       100L - out_length*100L/in_length));
//    if (s.matches < (s.last_lit>>1)/*int /2*/ && out_length < (in_length>>1)/*int /2*/) {
//      return true;
//    }
//  }
//#endif

  return (s.last_lit === s.lit_bufsize - 1);
  /* We avoid equality with lit_bufsize because of wraparound at 64K
   * on 16 bit machines and because stored blocks are restricted to
   * 64K-1 bytes.
   */
}

exports._tr_init  = _tr_init;
exports._tr_stored_block = _tr_stored_block;
exports._tr_flush_block  = _tr_flush_block;
exports._tr_tally = _tr_tally;
exports._tr_align = _tr_align;


/***/ }),

/***/ "../../node_modules/pako/lib/zlib/zstream.js":
/*!********************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/pako/lib/zlib/zstream.js ***!
  \********************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

function ZStream() {
  /* next input byte */
  this.input = null; // JS specific, because we have no pointers
  this.next_in = 0;
  /* number of bytes available at input */
  this.avail_in = 0;
  /* total number of input bytes read so far */
  this.total_in = 0;
  /* next output byte should be put there */
  this.output = null; // JS specific, because we have no pointers
  this.next_out = 0;
  /* remaining free space at output */
  this.avail_out = 0;
  /* total number of bytes output so far */
  this.total_out = 0;
  /* last error message, NULL if no error */
  this.msg = ''/*Z_NULL*/;
  /* not visible by applications */
  this.state = null;
  /* best guess about the data type: binary or text */
  this.data_type = 2/*Z_UNKNOWN*/;
  /* adler32 value of the uncompressed data */
  this.adler = 0;
}

module.exports = ZStream;


/***/ }),

/***/ "../../node_modules/querystringify/index.js":
/*!*******************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/querystringify/index.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var has = Object.prototype.hasOwnProperty
  , undef;

/**
 * Decode a URI encoded string.
 *
 * @param {String} input The URI encoded string.
 * @returns {String|Null} The decoded string.
 * @api private
 */
function decode(input) {
  try {
    return decodeURIComponent(input.replace(/\+/g, ' '));
  } catch (e) {
    return null;
  }
}

/**
 * Attempts to encode a given input.
 *
 * @param {String} input The string that needs to be encoded.
 * @returns {String|Null} The encoded string.
 * @api private
 */
function encode(input) {
  try {
    return encodeURIComponent(input);
  } catch (e) {
    return null;
  }
}

/**
 * Simple query string parser.
 *
 * @param {String} query The query string that needs to be parsed.
 * @returns {Object}
 * @api public
 */
function querystring(query) {
  var parser = /([^=?#&]+)=?([^&]*)/g
    , result = {}
    , part;

  while (part = parser.exec(query)) {
    var key = decode(part[1])
      , value = decode(part[2]);

    //
    // Prevent overriding of existing properties. This ensures that build-in
    // methods like `toString` or __proto__ are not overriden by malicious
    // querystrings.
    //
    // In the case if failed decoding, we want to omit the key/value pairs
    // from the result.
    //
    if (key === null || value === null || key in result) continue;
    result[key] = value;
  }

  return result;
}

/**
 * Transform a query string to an object.
 *
 * @param {Object} obj Object that should be transformed.
 * @param {String} prefix Optional prefix.
 * @returns {String}
 * @api public
 */
function querystringify(obj, prefix) {
  prefix = prefix || '';

  var pairs = []
    , value
    , key;

  //
  // Optionally prefix with a '?' if needed
  //
  if ('string' !== typeof prefix) prefix = '?';

  for (key in obj) {
    if (has.call(obj, key)) {
      value = obj[key];

      //
      // Edge cases where we actually want to encode the value to an empty
      // string instead of the stringified value.
      //
      if (!value && (value === null || value === undef || isNaN(value))) {
        value = '';
      }

      key = encode(key);
      value = encode(value);

      //
      // If we failed to encode the strings, we should bail out as we don't
      // want to add invalid strings to the query.
      //
      if (key === null || value === null) continue;
      pairs.push(key +'='+ value);
    }
  }

  return pairs.length ? prefix + pairs.join('&') : '';
}

//
// Expose the module.
//
exports.stringify = querystringify;
exports.parse = querystring;


/***/ }),

/***/ "../../node_modules/requires-port/index.js":
/*!******************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/requires-port/index.js ***!
  \******************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Check if we're required to add a port number.
 *
 * @see https://url.spec.whatwg.org/#default-port
 * @param {Number|String} port Port number we need to check
 * @param {String} protocol Protocol we need to check against.
 * @returns {Boolean} Is it a default port for the given protocol
 * @api private
 */
module.exports = function required(port, protocol) {
  protocol = protocol.split(':')[0];
  port = +port;

  if (!port) return false;

  switch (protocol) {
    case 'http':
    case 'ws':
    return port !== 80;

    case 'https':
    case 'wss':
    return port !== 443;

    case 'ftp':
    return port !== 21;

    case 'gopher':
    return port !== 70;

    case 'file':
    return false;
  }

  return port !== 0;
};


/***/ }),

/***/ "../../node_modules/source-map-resolve/index.js":
/*!***********************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/source-map-resolve/index.js ***!
  \***********************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var atob = __webpack_require__(/*! atob */ "../../node_modules/atob/node-atob.js")
var urlLib = __webpack_require__(/*! url */ "url")
var pathLib = __webpack_require__(/*! path */ "path")
var decodeUriComponentLib = __webpack_require__(/*! decode-uri-component */ "../../node_modules/decode-uri-component/index.js")



function resolveUrl(/* ...urls */) {
  return Array.prototype.reduce.call(arguments, function(resolved, nextUrl) {
    return urlLib.resolve(resolved, nextUrl)
  })
}

function convertWindowsPath(aPath) {
  return pathLib.sep === "\\" ? aPath.replace(/\\/g, "/").replace(/^[a-z]:\/?/i, "/") : aPath
}

function customDecodeUriComponent(string) {
  // `decodeUriComponentLib` turns `+` into ` `, but that's not wanted.
  return decodeUriComponentLib(string.replace(/\+/g, "%2B"))
}

function callbackAsync(callback, error, result) {
  setImmediate(function() { callback(error, result) })
}

function parseMapToJSON(string, data) {
  try {
    return JSON.parse(string.replace(/^\)\]\}'/, ""))
  } catch (error) {
    error.sourceMapData = data
    throw error
  }
}

function readSync(read, url, data) {
  var readUrl = customDecodeUriComponent(url)
  try {
    return String(read(readUrl))
  } catch (error) {
    error.sourceMapData = data
    throw error
  }
}



var innerRegex = /[#@] sourceMappingURL=([^\s'"]*)/

var sourceMappingURLRegex = RegExp(
  "(?:" +
    "/\\*" +
    "(?:\\s*\r?\n(?://)?)?" +
    "(?:" + innerRegex.source + ")" +
    "\\s*" +
    "\\*/" +
    "|" +
    "//(?:" + innerRegex.source + ")" +
  ")" +
  "\\s*"
)

function getSourceMappingUrl(code) {
  var match = code.match(sourceMappingURLRegex)
  return match ? match[1] || match[2] || "" : null
}



function resolveSourceMap(code, codeUrl, read, callback) {
  var mapData
  try {
    mapData = resolveSourceMapHelper(code, codeUrl)
  } catch (error) {
    return callbackAsync(callback, error)
  }
  if (!mapData || mapData.map) {
    return callbackAsync(callback, null, mapData)
  }
  var readUrl = customDecodeUriComponent(mapData.url)
  read(readUrl, function(error, result) {
    if (error) {
      error.sourceMapData = mapData
      return callback(error)
    }
    mapData.map = String(result)
    try {
      mapData.map = parseMapToJSON(mapData.map, mapData)
    } catch (error) {
      return callback(error)
    }
    callback(null, mapData)
  })
}

function resolveSourceMapSync(code, codeUrl, read) {
  var mapData = resolveSourceMapHelper(code, codeUrl)
  if (!mapData || mapData.map) {
    return mapData
  }
  mapData.map = readSync(read, mapData.url, mapData)
  mapData.map = parseMapToJSON(mapData.map, mapData)
  return mapData
}

var dataUriRegex = /^data:([^,;]*)(;[^,;]*)*(?:,(.*))?$/

/**
 * The media type for JSON text is application/json.
 *
 * {@link https://tools.ietf.org/html/rfc8259#section-11 | IANA Considerations }
 *
 * `text/json` is non-standard media type
 */
var jsonMimeTypeRegex = /^(?:application|text)\/json$/

/**
 * JSON text exchanged between systems that are not part of a closed ecosystem
 * MUST be encoded using UTF-8.
 *
 * {@link https://tools.ietf.org/html/rfc8259#section-8.1 | Character Encoding}
 */
var jsonCharacterEncoding = "utf-8"

function base64ToBuf(b64) {
  var binStr = atob(b64)
  var len = binStr.length
  var arr = new Uint8Array(len)
  for (var i = 0; i < len; i++) {
    arr[i] = binStr.charCodeAt(i)
  }
  return arr
}

function decodeBase64String(b64) {
  if (typeof TextDecoder === "undefined" || typeof Uint8Array === "undefined") {
    return atob(b64)
  }
  var buf = base64ToBuf(b64);
  // Note: `decoder.decode` method will throw a `DOMException` with the
  // `"EncodingError"` value when an coding error is found.
  var decoder = new TextDecoder(jsonCharacterEncoding, {fatal: true})
  return decoder.decode(buf);
}

function resolveSourceMapHelper(code, codeUrl) {
  codeUrl = convertWindowsPath(codeUrl)

  var url = getSourceMappingUrl(code)
  if (!url) {
    return null
  }

  var dataUri = url.match(dataUriRegex)
  if (dataUri) {
    var mimeType = dataUri[1] || "text/plain"
    var lastParameter = dataUri[2] || ""
    var encoded = dataUri[3] || ""
    var data = {
      sourceMappingURL: url,
      url: null,
      sourcesRelativeTo: codeUrl,
      map: encoded
    }
    if (!jsonMimeTypeRegex.test(mimeType)) {
      var error = new Error("Unuseful data uri mime type: " + mimeType)
      error.sourceMapData = data
      throw error
    }
    try {
      data.map = parseMapToJSON(
        lastParameter === ";base64" ? decodeBase64String(encoded) : decodeURIComponent(encoded),
        data
      )
    } catch (error) {
      error.sourceMapData = data
      throw error
    }
    return data
  }

  var mapUrl = resolveUrl(codeUrl, url)
  return {
    sourceMappingURL: url,
    url: mapUrl,
    sourcesRelativeTo: mapUrl,
    map: null
  }
}



function resolveSources(map, mapUrl, read, options, callback) {
  if (typeof options === "function") {
    callback = options
    options = {}
  }
  var pending = map.sources ? map.sources.length : 0
  var result = {
    sourcesResolved: [],
    sourcesContent:  []
  }

  if (pending === 0) {
    callbackAsync(callback, null, result)
    return
  }

  var done = function() {
    pending--
    if (pending === 0) {
      callback(null, result)
    }
  }

  resolveSourcesHelper(map, mapUrl, options, function(fullUrl, sourceContent, index) {
    result.sourcesResolved[index] = fullUrl
    if (typeof sourceContent === "string") {
      result.sourcesContent[index] = sourceContent
      callbackAsync(done, null)
    } else {
      var readUrl = customDecodeUriComponent(fullUrl)
      read(readUrl, function(error, source) {
        result.sourcesContent[index] = error ? error : String(source)
        done()
      })
    }
  })
}

function resolveSourcesSync(map, mapUrl, read, options) {
  var result = {
    sourcesResolved: [],
    sourcesContent:  []
  }

  if (!map.sources || map.sources.length === 0) {
    return result
  }

  resolveSourcesHelper(map, mapUrl, options, function(fullUrl, sourceContent, index) {
    result.sourcesResolved[index] = fullUrl
    if (read !== null) {
      if (typeof sourceContent === "string") {
        result.sourcesContent[index] = sourceContent
      } else {
        var readUrl = customDecodeUriComponent(fullUrl)
        try {
          result.sourcesContent[index] = String(read(readUrl))
        } catch (error) {
          result.sourcesContent[index] = error
        }
      }
    }
  })

  return result
}

var endingSlash = /\/?$/

function resolveSourcesHelper(map, mapUrl, options, fn) {
  options = options || {}
  mapUrl = convertWindowsPath(mapUrl)
  var fullUrl
  var sourceContent
  var sourceRoot
  for (var index = 0, len = map.sources.length; index < len; index++) {
    sourceRoot = null
    if (typeof options.sourceRoot === "string") {
      sourceRoot = options.sourceRoot
    } else if (typeof map.sourceRoot === "string" && options.sourceRoot !== false) {
      sourceRoot = map.sourceRoot
    }
    // If the sourceRoot is the empty string, it is equivalent to not setting
    // the property at all.
    if (sourceRoot === null || sourceRoot === '') {
      fullUrl = resolveUrl(mapUrl, map.sources[index])
    } else {
      // Make sure that the sourceRoot ends with a slash, so that `/scripts/subdir` becomes
      // `/scripts/subdir/<source>`, not `/scripts/<source>`. Pointing to a file as source root
      // does not make sense.
      fullUrl = resolveUrl(mapUrl, sourceRoot.replace(endingSlash, "/"), map.sources[index])
    }
    sourceContent = (map.sourcesContent || [])[index]
    fn(fullUrl, sourceContent, index)
  }
}



function resolve(code, codeUrl, read, options, callback) {
  if (typeof options === "function") {
    callback = options
    options = {}
  }
  if (code === null) {
    var mapUrl = codeUrl
    var data = {
      sourceMappingURL: null,
      url: mapUrl,
      sourcesRelativeTo: mapUrl,
      map: null
    }
    var readUrl = customDecodeUriComponent(mapUrl)
    read(readUrl, function(error, result) {
      if (error) {
        error.sourceMapData = data
        return callback(error)
      }
      data.map = String(result)
      try {
        data.map = parseMapToJSON(data.map, data)
      } catch (error) {
        return callback(error)
      }
      _resolveSources(data)
    })
  } else {
    resolveSourceMap(code, codeUrl, read, function(error, mapData) {
      if (error) {
        return callback(error)
      }
      if (!mapData) {
        return callback(null, null)
      }
      _resolveSources(mapData)
    })
  }

  function _resolveSources(mapData) {
    resolveSources(mapData.map, mapData.sourcesRelativeTo, read, options, function(error, result) {
      if (error) {
        return callback(error)
      }
      mapData.sourcesResolved = result.sourcesResolved
      mapData.sourcesContent  = result.sourcesContent
      callback(null, mapData)
    })
  }
}

function resolveSync(code, codeUrl, read, options) {
  var mapData
  if (code === null) {
    var mapUrl = codeUrl
    mapData = {
      sourceMappingURL: null,
      url: mapUrl,
      sourcesRelativeTo: mapUrl,
      map: null
    }
    mapData.map = readSync(read, mapUrl, mapData)
    mapData.map = parseMapToJSON(mapData.map, mapData)
  } else {
    mapData = resolveSourceMapSync(code, codeUrl, read)
    if (!mapData) {
      return null
    }
  }
  var result = resolveSourcesSync(mapData.map, mapData.sourcesRelativeTo, read, options)
  mapData.sourcesResolved = result.sourcesResolved
  mapData.sourcesContent  = result.sourcesContent
  return mapData
}



module.exports = {
  resolveSourceMap:     resolveSourceMap,
  resolveSourceMapSync: resolveSourceMapSync,
  resolveSources:       resolveSources,
  resolveSourcesSync:   resolveSourcesSync,
  resolve:              resolve,
  resolveSync:          resolveSync,
  parseMapToJSON:       parseMapToJSON
}


/***/ }),

/***/ "../../node_modules/split/index.js":
false,

/***/ "../../node_modules/through/index.js":
false,

/***/ "../../node_modules/url-parse/index.js":
/*!**************************************************************************************!*\
  !*** /Users/opagani/projects/zillowgroup/rentals-js/node_modules/url-parse/index.js ***!
  \**************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var required = __webpack_require__(/*! requires-port */ "../../node_modules/requires-port/index.js")
  , qs = __webpack_require__(/*! querystringify */ "../../node_modules/querystringify/index.js")
  , slashes = /^[A-Za-z][A-Za-z0-9+-.]*:\/\//
  , protocolre = /^([a-z][a-z0-9.+-]*:)?(\/\/)?([\\/]+)?([\S\s]*)/i
  , windowsDriveLetter = /^[a-zA-Z]:/
  , whitespace = '[\\x09\\x0A\\x0B\\x0C\\x0D\\x20\\xA0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u3000\\u2028\\u2029\\uFEFF]'
  , left = new RegExp('^'+ whitespace +'+');

/**
 * Trim a given string.
 *
 * @param {String} str String to trim.
 * @public
 */
function trimLeft(str) {
  return (str ? str : '').toString().replace(left, '');
}

/**
 * These are the parse rules for the URL parser, it informs the parser
 * about:
 *
 * 0. The char it Needs to parse, if it's a string it should be done using
 *    indexOf, RegExp using exec and NaN means set as current value.
 * 1. The property we should set when parsing this value.
 * 2. Indication if it's backwards or forward parsing, when set as number it's
 *    the value of extra chars that should be split off.
 * 3. Inherit from location if non existing in the parser.
 * 4. `toLowerCase` the resulting value.
 */
var rules = [
  ['#', 'hash'],                        // Extract from the back.
  ['?', 'query'],                       // Extract from the back.
  function sanitize(address, url) {     // Sanitize what is left of the address
    return isSpecial(url.protocol) ? address.replace(/\\/g, '/') : address;
  },
  ['/', 'pathname'],                    // Extract from the back.
  ['@', 'auth', 1],                     // Extract from the front.
  [NaN, 'host', undefined, 1, 1],       // Set left over value.
  [/:(\d+)$/, 'port', undefined, 1],    // RegExp the back.
  [NaN, 'hostname', undefined, 1, 1]    // Set left over.
];

/**
 * These properties should not be copied or inherited from. This is only needed
 * for all non blob URL's as a blob URL does not include a hash, only the
 * origin.
 *
 * @type {Object}
 * @private
 */
var ignore = { hash: 1, query: 1 };

/**
 * The location object differs when your code is loaded through a normal page,
 * Worker or through a worker using a blob. And with the blobble begins the
 * trouble as the location object will contain the URL of the blob, not the
 * location of the page where our code is loaded in. The actual origin is
 * encoded in the `pathname` so we can thankfully generate a good "default"
 * location from it so we can generate proper relative URL's again.
 *
 * @param {Object|String} loc Optional default location object.
 * @returns {Object} lolcation object.
 * @public
 */
function lolcation(loc) {
  var globalVar;

  if (typeof window !== 'undefined') globalVar = window;
  else if (typeof global !== 'undefined') globalVar = global;
  else if (typeof self !== 'undefined') globalVar = self;
  else globalVar = {};

  var location = globalVar.location || {};
  loc = loc || location;

  var finaldestination = {}
    , type = typeof loc
    , key;

  if ('blob:' === loc.protocol) {
    finaldestination = new Url(unescape(loc.pathname), {});
  } else if ('string' === type) {
    finaldestination = new Url(loc, {});
    for (key in ignore) delete finaldestination[key];
  } else if ('object' === type) {
    for (key in loc) {
      if (key in ignore) continue;
      finaldestination[key] = loc[key];
    }

    if (finaldestination.slashes === undefined) {
      finaldestination.slashes = slashes.test(loc.href);
    }
  }

  return finaldestination;
}

/**
 * Check whether a protocol scheme is special.
 *
 * @param {String} The protocol scheme of the URL
 * @return {Boolean} `true` if the protocol scheme is special, else `false`
 * @private
 */
function isSpecial(scheme) {
  return (
    scheme === 'file:' ||
    scheme === 'ftp:' ||
    scheme === 'http:' ||
    scheme === 'https:' ||
    scheme === 'ws:' ||
    scheme === 'wss:'
  );
}

/**
 * @typedef ProtocolExtract
 * @type Object
 * @property {String} protocol Protocol matched in the URL, in lowercase.
 * @property {Boolean} slashes `true` if protocol is followed by "//", else `false`.
 * @property {String} rest Rest of the URL that is not part of the protocol.
 */

/**
 * Extract protocol information from a URL with/without double slash ("//").
 *
 * @param {String} address URL we want to extract from.
 * @param {Object} location
 * @return {ProtocolExtract} Extracted information.
 * @private
 */
function extractProtocol(address, location) {
  address = trimLeft(address);
  location = location || {};

  var match = protocolre.exec(address);
  var protocol = match[1] ? match[1].toLowerCase() : '';
  var forwardSlashes = !!match[2];
  var otherSlashes = !!match[3];
  var slashesCount = 0;
  var rest;

  if (forwardSlashes) {
    if (otherSlashes) {
      rest = match[2] + match[3] + match[4];
      slashesCount = match[2].length + match[3].length;
    } else {
      rest = match[2] + match[4];
      slashesCount = match[2].length;
    }
  } else {
    if (otherSlashes) {
      rest = match[3] + match[4];
      slashesCount = match[3].length;
    } else {
      rest = match[4]
    }
  }

  if (protocol === 'file:') {
    if (slashesCount >= 2) {
      rest = rest.slice(2);
    }
  } else if (isSpecial(protocol)) {
    rest = match[4];
  } else if (protocol) {
    if (forwardSlashes) {
      rest = rest.slice(2);
    }
  } else if (slashesCount >= 2 && isSpecial(location.protocol)) {
    rest = match[4];
  }

  return {
    protocol: protocol,
    slashes: forwardSlashes || isSpecial(protocol),
    slashesCount: slashesCount,
    rest: rest
  };
}

/**
 * Resolve a relative URL pathname against a base URL pathname.
 *
 * @param {String} relative Pathname of the relative URL.
 * @param {String} base Pathname of the base URL.
 * @return {String} Resolved pathname.
 * @private
 */
function resolve(relative, base) {
  if (relative === '') return base;

  var path = (base || '/').split('/').slice(0, -1).concat(relative.split('/'))
    , i = path.length
    , last = path[i - 1]
    , unshift = false
    , up = 0;

  while (i--) {
    if (path[i] === '.') {
      path.splice(i, 1);
    } else if (path[i] === '..') {
      path.splice(i, 1);
      up++;
    } else if (up) {
      if (i === 0) unshift = true;
      path.splice(i, 1);
      up--;
    }
  }

  if (unshift) path.unshift('');
  if (last === '.' || last === '..') path.push('');

  return path.join('/');
}

/**
 * The actual URL instance. Instead of returning an object we've opted-in to
 * create an actual constructor as it's much more memory efficient and
 * faster and it pleases my OCD.
 *
 * It is worth noting that we should not use `URL` as class name to prevent
 * clashes with the global URL instance that got introduced in browsers.
 *
 * @constructor
 * @param {String} address URL we want to parse.
 * @param {Object|String} [location] Location defaults for relative paths.
 * @param {Boolean|Function} [parser] Parser for the query string.
 * @private
 */
function Url(address, location, parser) {
  address = trimLeft(address);

  if (!(this instanceof Url)) {
    return new Url(address, location, parser);
  }

  var relative, extracted, parse, instruction, index, key
    , instructions = rules.slice()
    , type = typeof location
    , url = this
    , i = 0;

  //
  // The following if statements allows this module two have compatibility with
  // 2 different API:
  //
  // 1. Node.js's `url.parse` api which accepts a URL, boolean as arguments
  //    where the boolean indicates that the query string should also be parsed.
  //
  // 2. The `URL` interface of the browser which accepts a URL, object as
  //    arguments. The supplied object will be used as default values / fall-back
  //    for relative paths.
  //
  if ('object' !== type && 'string' !== type) {
    parser = location;
    location = null;
  }

  if (parser && 'function' !== typeof parser) parser = qs.parse;

  location = lolcation(location);

  //
  // Extract protocol information before running the instructions.
  //
  extracted = extractProtocol(address || '', location);
  relative = !extracted.protocol && !extracted.slashes;
  url.slashes = extracted.slashes || relative && location.slashes;
  url.protocol = extracted.protocol || location.protocol || '';
  address = extracted.rest;

  //
  // When the authority component is absent the URL starts with a path
  // component.
  //
  if (
    extracted.protocol === 'file:' && (
      extracted.slashesCount !== 2 || windowsDriveLetter.test(address)) ||
    (!extracted.slashes &&
      (extracted.protocol ||
        extracted.slashesCount < 2 ||
        !isSpecial(url.protocol)))
  ) {
    instructions[3] = [/(.*)/, 'pathname'];
  }

  for (; i < instructions.length; i++) {
    instruction = instructions[i];

    if (typeof instruction === 'function') {
      address = instruction(address, url);
      continue;
    }

    parse = instruction[0];
    key = instruction[1];

    if (parse !== parse) {
      url[key] = address;
    } else if ('string' === typeof parse) {
      if (~(index = address.indexOf(parse))) {
        if ('number' === typeof instruction[2]) {
          url[key] = address.slice(0, index);
          address = address.slice(index + instruction[2]);
        } else {
          url[key] = address.slice(index);
          address = address.slice(0, index);
        }
      }
    } else if ((index = parse.exec(address))) {
      url[key] = index[1];
      address = address.slice(0, index.index);
    }

    url[key] = url[key] || (
      relative && instruction[3] ? location[key] || '' : ''
    );

    //
    // Hostname, host and protocol should be lowercased so they can be used to
    // create a proper `origin`.
    //
    if (instruction[4]) url[key] = url[key].toLowerCase();
  }

  //
  // Also parse the supplied query string in to an object. If we're supplied
  // with a custom parser as function use that instead of the default build-in
  // parser.
  //
  if (parser) url.query = parser(url.query);

  //
  // If the URL is relative, resolve the pathname against the base URL.
  //
  if (
      relative
    && location.slashes
    && url.pathname.charAt(0) !== '/'
    && (url.pathname !== '' || location.pathname !== '')
  ) {
    url.pathname = resolve(url.pathname, location.pathname);
  }

  //
  // Default to a / for pathname if none exists. This normalizes the URL
  // to always have a /
  //
  if (url.pathname.charAt(0) !== '/' && isSpecial(url.protocol)) {
    url.pathname = '/' + url.pathname;
  }

  //
  // We should not add port numbers if they are already the default port number
  // for a given protocol. As the host also contains the port number we're going
  // override it with the hostname which contains no port number.
  //
  if (!required(url.port, url.protocol)) {
    url.host = url.hostname;
    url.port = '';
  }

  //
  // Parse down the `auth` for the username and password.
  //
  url.username = url.password = '';
  if (url.auth) {
    instruction = url.auth.split(':');
    url.username = instruction[0] || '';
    url.password = instruction[1] || '';
  }

  url.origin = url.protocol !== 'file:' && isSpecial(url.protocol) && url.host
    ? url.protocol +'//'+ url.host
    : 'null';

  //
  // The href is just the compiled result.
  //
  url.href = url.toString();
}

/**
 * This is convenience method for changing properties in the URL instance to
 * insure that they all propagate correctly.
 *
 * @param {String} part          Property we need to adjust.
 * @param {Mixed} value          The newly assigned value.
 * @param {Boolean|Function} fn  When setting the query, it will be the function
 *                               used to parse the query.
 *                               When setting the protocol, double slash will be
 *                               removed from the final url if it is true.
 * @returns {URL} URL instance for chaining.
 * @public
 */
function set(part, value, fn) {
  var url = this;

  switch (part) {
    case 'query':
      if ('string' === typeof value && value.length) {
        value = (fn || qs.parse)(value);
      }

      url[part] = value;
      break;

    case 'port':
      url[part] = value;

      if (!required(value, url.protocol)) {
        url.host = url.hostname;
        url[part] = '';
      } else if (value) {
        url.host = url.hostname +':'+ value;
      }

      break;

    case 'hostname':
      url[part] = value;

      if (url.port) value += ':'+ url.port;
      url.host = value;
      break;

    case 'host':
      url[part] = value;

      if (/:\d+$/.test(value)) {
        value = value.split(':');
        url.port = value.pop();
        url.hostname = value.join(':');
      } else {
        url.hostname = value;
        url.port = '';
      }

      break;

    case 'protocol':
      url.protocol = value.toLowerCase();
      url.slashes = !fn;
      break;

    case 'pathname':
    case 'hash':
      if (value) {
        var char = part === 'pathname' ? '/' : '#';
        url[part] = value.charAt(0) !== char ? char + value : value;
      } else {
        url[part] = value;
      }
      break;

    default:
      url[part] = value;
  }

  for (var i = 0; i < rules.length; i++) {
    var ins = rules[i];

    if (ins[4]) url[ins[1]] = url[ins[1]].toLowerCase();
  }

  url.origin = url.protocol !== 'file:' && isSpecial(url.protocol) && url.host
    ? url.protocol +'//'+ url.host
    : 'null';

  url.href = url.toString();

  return url;
}

/**
 * Transform the properties back in to a valid and full URL string.
 *
 * @param {Function} stringify Optional query stringify function.
 * @returns {String} Compiled version of the URL.
 * @public
 */
function toString(stringify) {
  if (!stringify || 'function' !== typeof stringify) stringify = qs.stringify;

  var query
    , url = this
    , protocol = url.protocol;

  if (protocol && protocol.charAt(protocol.length - 1) !== ':') protocol += ':';

  var result = protocol + (url.slashes || isSpecial(url.protocol) ? '//' : '');

  if (url.username) {
    result += url.username;
    if (url.password) result += ':'+ url.password;
    result += '@';
  }

  result += url.host + url.pathname;

  query = 'object' === typeof url.query ? stringify(url.query) : url.query;
  if (query) result += '?' !== query.charAt(0) ? '?'+ query : query;

  if (url.hash) result += url.hash;

  return result;
}

Url.prototype = { set: set, toString: toString };

//
// Expose the URL parser and some additional properties that might be useful for
// others or testing.
//
Url.extractProtocol = extractProtocol;
Url.location = lolcation;
Url.trimLeft = trimLeft;
Url.qs = qs;

module.exports = Url;


/***/ }),

/***/ "../../node_modules/yocto-queue/index.js":
false,

/***/ "child_process":
/*!********************************!*\
  !*** external "child_process" ***!
  \********************************/
/*! no static exports found */
/*! exports used: default, fork, spawn */
/***/ (function(module, exports) {

module.exports = require("child_process");

/***/ }),

/***/ "constants":
/*!****************************!*\
  !*** external "constants" ***!
  \****************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports) {

module.exports = require("constants");

/***/ }),

/***/ "diagnostics_channel":
false,

/***/ "inspector":
/*!****************************!*\
  !*** external "inspector" ***!
  \****************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports) {

module.exports = require("inspector");

/***/ })

};
//# sourceMappingURL=index.d814953efc0af0928596.hot-update.js.map