{"version":3,"file":"docker-entrypoint.d814953efc0af0928596.hot-update.js","sources":["webpack:////Users/opagani/projects/zillowgroup/rentals-js/modules/cli-tools/src/subprocess.ts","webpack:////Users/opagani/projects/zillowgroup/rentals-js/modules/docker/src/entrypoint.ts","webpack:///external \"child_process\""],"sourcesContent":["import { isDryRun } from './dry-run';\nimport os from 'os';\nimport through2 from 'through2';\nimport type { Readable } from 'stream';\nimport type { ChildProcess, SpawnOptions } from 'child_process';\nimport { spawn } from 'child_process';\nimport type { LogStep } from '@zg-rentals/node-logger';\nimport getLogger from '@zg-rentals/node-logger';\n\nexport interface RunSpec {\n  action: string;\n  cmd: string;\n  args?: Array<string>;\n  opts?: SpawnOptions;\n  logger?: LogStep;\n  blockInDryRun?: boolean;\n}\n\nlet REPO_ROOT: string = process.cwd();\n\nexport function setDefaultCwd(cwd: string) {\n  REPO_ROOT = cwd;\n}\n\ninterface SubprocessErrorConfig {\n  command: string;\n  error: string;\n  logger: LogStep;\n  code?: number;\n  signal?: string;\n  stack?: string;\n}\n\nexport class BatchError extends Error {}\n\nexport class SubprocessError extends Error {\n  code: number | undefined;\n  signal: string | undefined;\n\n  logger: LogStep;\n  command: string;\n  error: string;\n\n  constructor({ command, error, code, signal, logger, stack }: SubprocessErrorConfig) {\n    super(error.trim());\n\n    if (stack) {\n      this.stack = stack;\n    }\n\n    this.code = code;\n    this.signal = signal;\n    this.logger = logger;\n    this.command = command;\n    this.error = error.trim();\n  }\n}\n\nexport async function run(options: RunSpec): Promise<{ output: string; subprocess?: ChildProcess }> {\n  return new Promise(async (resolve, reject) => {\n    const logger = options.logger || getLogger().createStep(options.action);\n\n    const { blockInDryRun } = options;\n    const { logger: _logger, ...withoutLogger } = options;\n    const commandText = `${options.cmd} ${(options.args || []).join(' ')}`;\n    const command = `\"${commandText}\": ${JSON.stringify(withoutLogger)}`;\n\n    if (blockInDryRun && isDryRun()) {\n      logger.info(`DRY-RUN Running command: ${commandText}`);\n      !options.logger && logger.end();\n      return resolve({ output: '' });\n    }\n\n    logger.info(`Running command: ${commandText}`);\n\n    const { subprocess, getError, getOutput } = await start(options);\n\n    subprocess.on('error', () => {\n      logger.fail();\n      reject(new SubprocessError({ error: `${getError()}\\n${getOutput()}`, logger, code: 1, command }));\n    });\n\n    subprocess.on('exit', (code) => {\n      const output = `${getError()}\\n${getOutput()}`;\n      if (code && isFinite(code)) {\n        !options.logger && logger.fail();\n        reject(new SubprocessError({ error: output, logger, code, command }));\n        return;\n      }\n      if (output.trim()) {\n        logger.info(`Command output:\\n${output}\\n`);\n      }\n      !options.logger && logger.end();\n      resolve({\n        output: output.trim(),\n        subprocess,\n      });\n    });\n\n    if (options.opts?.detached) {\n      !options.logger && logger.end();\n      resolve({\n        output: '',\n        subprocess,\n      });\n    }\n  });\n}\n\ntype BuildPromises = Array<() => Promise<string>>;\n\nexport async function batch(processes: Array<RunSpec>, parallel = true): Promise<Array<string | Error>> {\n  const results: Array<string | Error> = [];\n\n  const buildPromises: BuildPromises = processes.map((process) => {\n    return () => {\n      const step = getLogger().createStep(process.action);\n      return run({ ...process, logger: step })\n        .then((output) => {\n          step.end();\n          return output.output;\n        })\n        .catch((e) => {\n          step.error(e);\n          step.fail();\n          throw e;\n        });\n    };\n  });\n\n  let failing = false;\n  const maxParallel = parallel ? Math.min(os.cpus().length - 1, buildPromises.length) : 1;\n\n  return new Promise((resolve, reject) => {\n    function runTask(runner: () => Promise<string>): Promise<void> {\n      return runner()\n        .then((result) => {\n          results.push(result);\n          return;\n        })\n        .catch((e) => {\n          failing = true;\n          results.push(e);\n        })\n        .finally(() => {\n          runNextTask();\n        });\n    }\n\n    function runNextTask() {\n      if (buildPromises.length) {\n        const runnable = buildPromises.shift();\n        if (runnable) {\n          runTask(runnable);\n        }\n      }\n\n      if (!buildPromises.length && results.length === processes.length) {\n        if (failing) {\n          reject(new BatchError('Batch processes failed'));\n        }\n        resolve(results);\n      }\n    }\n\n    buildPromises.splice(0, maxParallel).forEach((promise) => {\n      runTask(promise);\n    });\n  });\n}\n\nexport async function start(options: RunSpec): Promise<{\n  subprocess: ChildProcess;\n  stdout: Readable | undefined;\n  stderr: Readable | undefined;\n  getError: () => string;\n  getOutput: () => string;\n}> {\n  return new Promise((resolve) => {\n    const { args = [], cmd, opts = {} } = options;\n\n    const subprocess = spawn(cmd, args, {\n      cwd: REPO_ROOT,\n      ...opts,\n      env: { ...process.env, ...(opts.env || {}) },\n      stdio: opts.stdio || ['inherit', 'pipe', 'pipe'],\n    });\n\n    if (!subprocess) {\n      throw new Error('Unable to start process');\n    }\n\n    let output = '';\n    let error = '';\n    let stdout;\n    let stderr;\n\n    if (opts.stdio !== 'inherit' && opts.stdio !== 'ignore' && subprocess.stdout && subprocess.stderr) {\n      stdout = subprocess.stdout.pipe(\n        through2(\n          { highWaterMark: 0x100000 },\n          (chunk, enc, cb) => {\n            output += chunk.toString('utf8');\n            cb(null, chunk);\n          },\n          (cb) => {\n            if (!/\\n$/.test(output) && output.length > 0) {\n              // @ts-ignore the definition is wrong for through2\n              cb(null, '\\n');\n            }\n          },\n        ),\n      );\n\n      stderr = subprocess.stderr.pipe(\n        through2(\n          { highWaterMark: 0x100000 },\n          (chunk, enc, cb) => {\n            error += chunk.toString('utf8');\n            cb(null, chunk);\n          },\n          (cb) => {\n            if (!/\\n$/.test(error) && error.length > 0) {\n              // @ts-ignore the definition is wrong for through2\n              cb(null, '\\n');\n            }\n          },\n        ),\n      );\n    }\n\n    if (opts.detached) {\n      subprocess.unref();\n    }\n\n    resolve({\n      subprocess,\n      stdout,\n      stderr,\n      getOutput() {\n        return output.trim();\n      },\n      getError() {\n        return error.trim();\n      },\n    });\n  });\n}\n","import type { ChildProcess } from 'child_process';\nimport { fork } from 'child_process';\n\nimport { loadDotEnv } from '@zg-rentals/app';\n\nexport async function setupEntrypoint({\n  root,\n  serverPath,\n  env = {},\n}: {\n  root: string;\n  serverPath: string;\n  env?: NodeJS.ProcessEnv;\n}) {\n  loadDotEnv(root, env.ZG_ENV);\n\n  const gracefulShutdownPeriod = parseInt(process.env.NODE_SHUTDOWN_WAIT || '') || 120_000;\n\n  function setupExitListener(subprocess: ChildProcess) {\n    process.on('SIGTERM', () => {\n      subprocess.send({\n        topic: 'TRIGGER_SHUTDOWN',\n      });\n\n      setTimeout(() => {\n        if (subprocess && subprocess.pid) {\n          process.kill(subprocess.pid);\n          process.exit(0);\n        }\n      }, gracefulShutdownPeriod);\n    });\n  }\n\n  const child = fork(serverPath, {\n    detached: true,\n    env: {\n      ...env,\n      ...process.env,\n    },\n  });\n\n  if (child.pid) {\n    setupExitListener(child);\n  } else {\n    process.exit(2);\n  }\n\n  return child;\n}\n","module.exports = require(\"child_process\");"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AAGA;AAEA;AAWA;AAEA;AACA;AACA;AAWA;AAAA;AACA;AADA;AACA;AADA;AAAA;AACA;AADA;AAAA;AACA;AADA;AAAA;AAEA;AAAA;AACA;AADA;AACA;AAOA;AAAA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AACA;AAAA;AACA;AAFA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAXA;AAYA;AACA;AArBA;AAAA;AAuBA;AAAA;AAAA;AACA;;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AADA;AACA;AADA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AAPA;AAAA;AAAA;AAAA;AACA;AAQA;AACA;AAVA;AAWA;AAAA;AACA;AAZA;AAcA;AAdA;AAAA;AACA;AADA;AAAA;AAgBA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAFA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AAIA;AACA;AA/CA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AAAA;AAAA;AAAA;AACA;AAFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAqDA;AAAA;AAAA;AACA;;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AApBA;AAuBA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA1DA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AA4DA;AAAA;AAAA;AACA;;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAQA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AADA;AAGA;AACA;AAJA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAIA;AAEA;AAAA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AATA;AAWA;AACA;AA5EA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC1KA;AAEA;AAEA;AAAA;AAAA;AACA;;AADA;AAAA;AACA;AADA;AAAA;AAAA;AAAA;AAaA;AACA;AACA;AACA;AADA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA1BA;AAQA;AAEA;AAiBA;AACA;AACA;AAFA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AAzCA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;ACLA;;;;A","sourceRoot":""}