{"version":3,"file":"docker-entrypoint.1cc52cf01743c7e55a4f.hot-update.js","sources":["webpack:////Users/opagani/projects/zillowgroup/rentals-js/modules/app/src/env.ts"],"sourcesContent":["import type { Arguments } from 'yargs';\nimport type { DetailedArguments } from 'yargs-parser';\nimport type { DefaultArgv } from '@zg-rentals/cli-tools';\nimport type yargs from 'yargs';\n\nimport { config } from 'dotenv';\nimport { getWorkspaceGraph } from '@zg-rentals/workspace-graph';\nimport expand from 'dotenv-expand';\nimport fs from 'fs';\nimport path from 'path';\n\nexport function loadDotEnv(root = process.cwd(), zgEnv = process.env.ZG_ENV): void {\n  const envFilePaths = [];\n\n  if (!zgEnv) {\n    envFilePaths.push(path.join(root, '.env'));\n  } else {\n    envFilePaths.push(\n      `${path.join(root, '/.env')}.${zgEnv}.local`,\n      `${path.join(root, '/.env')}.${zgEnv}`,\n      path.join(root, '/.env'),\n    );\n  }\n\n  envFilePaths.forEach((filepath) => {\n    if (fs.existsSync(filepath)) {\n      expand(\n        config({\n          path: filepath,\n        }),\n      );\n    }\n  });\n}\n\nexport function loadDotEnvYargsMiddleware<T>(argv: Arguments<DefaultArgv & T>, workspaceName: string) {\n  const graph = getWorkspaceGraph(argv['repo-root']);\n  const workspace = graph.getWorkspace(workspaceName);\n\n  if (!workspace) {\n    throw new Error('Require a workspace to load dotenv');\n  }\n\n  loadDotEnv(workspace.location, argv['zg-env'] as string);\n}\n\nexport function setYargsDefaultsMiddleware(\n  cli: typeof yargs,\n  options: {\n    useEnvVars?: boolean;\n    defaults?: Record<string, string | number | boolean>;\n    types?: Record<string, typeof String | typeof Number | typeof Boolean>;\n  },\n) {\n  const { types = {}, useEnvVars, defaults = {} } = options || {};\n  const {\n    aliases = {},\n    argv = { _: [], $0: '' },\n  }: {\n    aliases: DetailedArguments['aliases'];\n    argv: DetailedArguments['argv'];\n  } = cli.parsed as DetailedArguments;\n  if (useEnvVars) {\n    Object.keys(aliases).forEach((key) => {\n      if (argv[key] === undefined) {\n        const upperSnakeCaseKey = key.replace(/-/g, '_').toUpperCase();\n        const envVarValue = process.env[upperSnakeCaseKey];\n        if (envVarValue !== undefined) {\n          const type = types[key] || (defaults[key] === undefined ? String : defaults[key].constructor);\n          (argv as Record<string, unknown>)[key] = type(envVarValue);\n        }\n      }\n    });\n  }\n  Object.keys(defaults).forEach((key) => {\n    if (argv[key] === undefined && defaults[key] !== undefined) {\n      let defaultValue = defaults[key];\n      if (types[key]) {\n        defaultValue = types[key](defaultValue);\n      }\n      (argv as Record<string, unknown>)[key] = defaultValue;\n    }\n  });\n}\n\n//\n// The following types convert a generic type T from snake_case or spinal-case to camelCase.\n// Consider this example:\n//\n// interface Argv {\n//   'zg-env': string;\n//   'my_arg': boolean;\n// }\n// type ArgvCamelCase = KeysToCamelCase<Argv>;\n//\n// ArgvCamelCase would now be equivalent to:\n//\n// interface ArgvCamelCase {\n//   zgEnv: string;\n//   myArg: boolean;\n// }\n//\n\ntype CamelCase<S extends string> = S extends `${infer P1}${'-' | '_'}${infer P2}${infer P3}`\n  ? `${Lowercase<P1>}${Uppercase<P2>}${CamelCase<P3>}`\n  : Lowercase<S>;\n\nexport type KeysToCamelCase<T> = {\n  [K in keyof T as CamelCase<string & K>]: T[K] extends Record<string, unknown> ? KeysToCamelCase<T[K]> : T[K];\n};\n\nexport function yargsToCamelCase<T extends { 'zg-env': string }>(argv: Arguments<T>): KeysToCamelCase<T> {\n  const formattedArgs = {} as KeysToCamelCase<T>;\n  Object.keys(argv).forEach((key) => {\n    const formattedKey = key\n      .split(/[-_]/)\n      .map((word, index) => {\n        if (word) {\n          if (index === 0) {\n            return word.toLowerCase();\n          }\n          return word[0].toUpperCase() + word.slice(1).toLowerCase();\n        }\n        return word;\n      })\n      .join('');\n    (formattedArgs as Record<string, unknown>)[formattedKey] = argv[key];\n  });\n  return formattedArgs;\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAKA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AAEA;AADA;AAIA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAQA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AASA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;;;;A","sourceRoot":""}